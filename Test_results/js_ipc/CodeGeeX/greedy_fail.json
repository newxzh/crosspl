[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a class for interacting with the EXMO cryptocurrency exchange API, handling authentication, request signing, and response processing.\n\nClass Description: The Trader class provides methods to authenticate and send signed requests to the EXMO API. It handles nonce generation, request signing using HMAC-SHA512, and response error handling.\n\nAttributes:\n- key: [String] - API key for authentication\n- secret: [String] - API secret for request signing\n- currency: [String] - Base currency for trading pairs\n- asset: [String] - Asset currency for trading pairs\n- pair: [String] - Combined trading pair in format 'asset_currency'\n- name: [String] - Exchange name (fixed as 'EXMO')\n- nonce: [Number] - Counter for API requests to prevent replay attacks\n\nMethods:\n- constructor(config) -> [Void] - Initializes the trader instance with configuration including API keys and currency pairs\n- api_query(method, params, callback) -> [Void] - Makes authenticated POST requests to the EXMO API\n  - method: [String] - API endpoint method\n  - params: [Object] - Request parameters\n  - callback: [Function] - Callback function to handle response (error, data)",
    "Canonical_solution": "const CryptoJS = require(\"crypto-js\");\nconst querystring = require('querystring');\nconst request = require('request');\n\nclass Trader {\n  constructor(config) {\n    this.key = \"\";\n    this.secret = \"\";\n    \n    if(_.isObject(config)) {\n      if(_.isString(config.key)) this.key = config.key;\n      if(_.isString(config.secret)) this.secret = config.secret;\n      this.currency = config.currency;\n      this.asset = config.asset;\n      this.pair = this.asset + '_' + this.currency;\n    };\n\n    this.name = 'EXMO';\n    this.nonce = new Date() * 1000;\n  }\n\n  api_query(method, params, callback) {\n    params.nonce = this.nonce++;\n    var post_data = querystring.stringify(params);\n\n    var options = {\n      url: API_URL + method,\n      headers: {'Key': this.key,'Sign': CryptoJS.HmacSHA512(post_data, this.secret).toString(CryptoJS.enc.hex) },\n      form: params\n    };\n    \n    request.post(options, function (error, response, body) {\n      if (!error && response.statusCode == 200) {\n        data=JSON.parse(body);          \n        if(data.error) error = { message: data.error }\n        else if (data.result!=undefined && data.result==false)  error = { message: '\"result\": false' } ;\n        callback(error, data);\n      } else {\n        console.log('cb request error');\n        console.log(body);\n\n        if(error) {\n          if(includes(error.message, recoverableErrors)) {\n            error.notFatal = true;\n          }\n          console.log(error);\n          callback(error);\n        };\n      };\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass Trader {\n  constructor(config) {\n    this.key = config.key;\n    this.secret = config.secret;\n    this.currency = config.currency;\n    this.asset = config.asset;\n    this.pair = `${this.asset}_${this.currency}`;\n    this.name = 'EXMO';\n    this.nonce = 0;\n  }\n\n  api_query(method, params, callback) {\n    const query = Object.assign({ nonce: ++this.nonce }, params);\n    const post_data = Object.keys(query)\n      .sort()\n      .map((key) => `${key}=${encodeURIComponent(query[key])}`)\n      .join('&');\n    const sign = CryptoJS.HmacSHA512(post_data, this.secret).toString();\n    const options = {\n      url: `https://api.exmo.com/v1/${method}/`,\n      method: 'POST',\n      headers: {\n        'Key': this.key,\n        'Sign': sign,\n      },\n      form: query,\n    };\n    request(options, (error, response, body) => {\n      if (error) {\n        return callback(error);\n      }\n      try {\n        const data = JSON.parse(body);\n        if (data.error) {\n          return callback(new Error(data.error));\n        }\n        callback(null, data);\n      } catch (e) {\n        callback(e);\n      }\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a class that implements an Express HTTP server with middleware configuration, route definitions, and server startup functionality.\n\nClass Description: The ExpressServer class encapsulates the creation and management of an Express.js web server. It handles server configuration, middleware setup, route definitions, and server startup. The class is designed to be modular, allowing for easy extension of middleware and routes.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number on which the server will listen, either from environment variables or defaulting to 3000\n\nMethods:\n- constructor() -> [void] - Initializes the Express application and sets the default port\n- configureMiddleware() -> [void] - Configures essential middleware including static file serving and body parsing\n- defineRoutes() -> [void] - Defines route handlers for various HTTP methods and paths including GET and POST requests\n- startServer() -> [void] - Starts the HTTP server and begins listening on the specified port\n\nMethods Details:\n- configureMiddleware(): \n  - Adds express.static middleware to serve static files from the 'public' directory\n  - Adds body-parser middleware for parsing request bodies\n  - No input parameters\n  - No return value\n\n- defineRoutes():\n  - Defines a GET route for the home page ('/')\n  - Defines a GET route for the about page ('/about') with dynamic content\n  - Defines a POST route for newsletter signup ('/newsletter') with validation logic\n  - No input parameters\n  - No return value\n\n- startServer():\n  - Starts the server listening on the configured port\n  - Logs server startup information to the console\n  - No input parameters\n  - No return value",
    "Canonical_solution": "var express = require('express');\n\nclass ExpressServer {\n    constructor() {\n        this.app = express();\n        this.port = process.env.PORT || 3000;\n    }\n\n    configureMiddleware() {\n        this.app.use(express.static(__dirname + '/public'));\n        this.app.use(require('body-parser')());\n    }\n\n    defineRoutes() {\n        this.app.get('/', function(req, res) {\n            res.render('home');\n        });\n        \n        this.app.get('/about', function(req,res){\n            res.render('about', { \n                fortune: fortune.getFortune(),\n                pageTestScript: '/qa/tests-about.js' \n            });\n        });\n\n        this.app.post('/newsletter', function(req, res){\n            var name = req.body.name || '', email = req.body.email || '';\n            if(!email.match(VALID_EMAIL_REGEX)) {\n                if(req.xhr) return res.json({ error: 'Invalid name email address.' });\n                req.session.flash = {\n                    type: 'danger',\n                    intro: 'Validation error!',\n                    message: 'The email address you entered was  not valid.',\n                };\n                return res.redirect(303, '/newsletter/archive');\n            }\n            new NewsletterSignup({ name: name, email: email }).save(function(err){\n                if(err) {\n                    if(req.xhr) return res.json({ error: 'Database error.' });\n                    req.session.flash = {\n                        type: 'danger',\n                        intro: 'Database error!',\n                        message: 'There was a database error; please try again later.',\n                    };\n                    return res.redirect(303, '/newsletter/archive');\n                }\n                if(req.xhr) return res.json({ success: true });\n                req.session.flash = {\n                    type: 'success',\n                    intro: 'Thank you!',\n                    message: 'You have now been signed up for the newsletter.',\n                };\n                return res.redirect(303, '/newsletter/archive');\n            });\n        });\n    }\n\n    startServer() {\n        this.app.listen(this.port, function(){\n            console.log('Express started on http://localhost:' + this.port + '; press Ctrl-C to terminate.');\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nclass ExpressServer {\n  constructor() {\n    this.app = express();\n    this.port = process.env.PORT || 3000;\n  }\n\n  configureMiddleware() {\n    this.app.use(express.static('public'));\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n  }\n\n  defineRoutes() {\n    this.app.get('/', (req, res) => {\n      res.send('Welcome to the home page!');\n    });\n\n    this.app.get('/about', (req, res) => {\n      res.send('About us: We are a team of developers.');\n    });\n\n    this.app.post('/newsletter', (req, res) => {\n      const { email } = req.body;\n      if (email) {\n        res.send(`Thank you for subscribing to our newsletter, ${email}!`);\n      } else {\n        res.status(400).send('Please provide a valid email address.');\n      }\n    });\n  }\n\n  startServer() {\n    this.app.listen(this.port, () => {\n      console.log(`Server is running on port ${this.port}`);\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a function that sets up an Express server with Socket.IO for real-time communication, including CORS support, route handling, and socket event management for chat room functionality.\n\nFunction Description: The function `setupServer` initializes an Express application with HTTP and WebSocket support. It configures CORS middleware, handles socket connections for chat room operations (joining, messaging, disconnecting), and starts the server on a specified port. The function integrates Express routing and Socket.IO events to manage real-time communication between clients in different rooms.\n\nInput: None (The function uses environment variables for port configuration, with a default fallback to port 5000)\n\nOutput: None (The function starts a server process that listens for incoming HTTP and WebSocket connections, but doesn't return any value)",
    "Canonical_solution": "function setupServer() {\n    const http = require('http');\n    const express = require('express');\n    const socketio = require('socket.io');\n    const cors = require('cors');\n    \n    const app = express();\n    const server = http.createServer(app);\n    const io = socketio(server);\n    \n    app.use(cors());\n    app.use(router);\n    \n    io.on('connect', (socket) => {\n        socket.on('join', ({ name, room }, callback) => {\n            const { error, user } = addUser({ id: socket.id, name, room });\n            if(error) return callback(error);\n            socket.join(user.room);\n            socket.emit('message', { user: 'admin', text: `${user.name}, welcome to room ${user.room}.`});\n            socket.broadcast.to(user.room).emit('message', { user: 'admin', text: `${user.name} has joined!` });\n            io.to(user.room).emit('roomData', { room: user.room, users: getUsersInRoom(user.room) });\n            callback();\n        });\n        \n        socket.on('sendMessage', (message, callback) => {\n            const user = getUser(socket.id);\n            io.to(user.room).emit('message', { user: user.name, text: message });\n            callback();\n        });\n        \n        socket.on('disconnect', () => {\n            const user = removeUser(socket.id);\n            if(user) {\n                io.to(user.room).emit('message', { user: 'Admin', text: `${user.name} has left.` });\n                io.to(user.room).emit('roomData', { room: user.room, users: getUsersInRoom(user.room)});\n            }\n        });\n    });\n    \n    server.listen(process.env.PORT || 5000, () => console.log(`Server has started.`));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server, {\n  cors: {\n    origin: '*',\n    methods: ['GET', 'POST']\n  }\n});\n\napp.use(cors());\n\nio.on('connection', (socket) => {\n  socket.on('joinRoom', ({ username, room }) => {\n    socket.join(room);\n    socket.emit('message', { text: `${username} has joined the room` });\n    socket.broadcast.to(room).emit('message', { text: `${username} has joined the room` });\n  });\n\n  socket.on('chatMessage', (msg) => {\n    socket.broadcast.to(msg.room).emit('message', msg);\n  });\n\n  socket.on('disconnect', () => {\n    socket.broadcast.emit('message', { text: 'user has left' });\n  });\n});\n\nconst PORT = process.env.PORT || 5000;\n\nserver.listen(PORT, () => console.log(`Server running on port ${PORT}`));\n```"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server with WebSocket support using Express and Socket.IO, implementing a particle simulation system with cluster and client event handling.\n\nFunction Description: The function `startServer` initializes an Express application, sets up static file serving, integrates Socket.IO for real-time communication, and configures a particle simulation system with collision detection and cluster management. It handles particle movement, boundary collisions, and client interactions through defined event handlers.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function starts a server listening on port 3000 but doesn't return any value)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const app = express();\n    const server = require('http').Server(app);\n    const io = require('socket.io')(server);\n    const swip = require('../../../src/server/index.js');\n\n    app.use(express.static(__dirname + './../static'));\n\n    swip(io, {\n        cluster: {\n            events: {\n                update: (cluster) => {\n                    const blobs = cluster.data.blobs;\n                    const clients = cluster.clients;\n\n                    const updatedBlobs = blobs.map((blob) => {\n                        const boundaryOffset = blob.size;\n                        const client = clients.find((c) => isParticleInClient(blob, c));\n\n                        let nextPosX = blob.x + blob.speedX;\n                        let nextPosY = blob.y + blob.speedY;\n                        let nextSpeedX = blob.speedX;\n                        let nextSpeedY = blob.speedY;\n\n                        if (client) {\n                            if (((blob.speedX < 0) &&\n                                ((nextPosX - boundaryOffset) < client.transform.x)\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.left, nextPosY))) {\n                                nextPosX = client.transform.x + boundaryOffset;\n                                nextSpeedX = blob.speedX * -1;\n                            } else if (((blob.speedX > 0) &&\n                                ((nextPosX + boundaryOffset) > (client.transform.x + client.size.width))\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.right, nextPosY))) {\n                                nextPosX = client.transform.x + (client.size.width - boundaryOffset);\n                                nextSpeedX = blob.speedX * -1;\n                            }\n\n                            if (((blob.speedY < 0) &&\n                                ((nextPosY - boundaryOffset) < client.transform.y\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.top, nextPosX)))) {\n                                nextPosY = client.transform.y + boundaryOffset;\n                                nextSpeedY = blob.speedY * -1;\n                            } else if (((blob.speedY > 0) &&\n                                ((nextPosY + boundaryOffset) > (client.transform.y + client.size.height))\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.bottom, nextPosX))\n                            ) {\n                                nextPosY = client.transform.y + (client.size.height - boundaryOffset);\n                                nextSpeedY = blob.speedY * -1;\n                            }\n                        } else {\n                            const firstClient = clients[0];\n                            nextPosX = firstClient.transform.x + (firstClient.size.width / 2);\n                            nextPosY = firstClient.transform.y + (firstClient.size.height / 2);\n                            nextSpeedX = 0;\n                            nextSpeedY = 0;\n                        }\n\n                        blob.x = nextPosX;\n                        blob.y = nextPosY;\n                        blob.speedX = nextSpeedX;\n                        blob.speedY = nextSpeedY;\n\n                        return blob;\n                    });\n\n                    return {\n                        blobs: { $set: updatedBlobs },\n                    };\n                },\n                merge: (cluster1, cluster2, transform) => ({\n                    blobs: { $set: getNewParticleDist(cluster1, cluster2, transform) },\n                    backgroundColor: { $set: cluster1.data.backgroundColor },\n                }),\n            },\n            init: () => ({ blobs: [], backgroundColor: getRandomColor() }),\n        },\n\n        client: {\n            init: () => ({}),\n            events: {\n                addBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $push: blobs } },\n                        },\n                    };\n                },\n                updateBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $set: blobs } },\n                        },\n                    };\n                },\n            },\n        },\n    });\n\n    server.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst numCPUs = require('os').cpus().length;\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n\n  // Fork workers.\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  console.log(`Worker ${process.pid} started`);\n\n  app.use(express.static('public'));\n\n  io.on('connection', (socket) => {\n    console.log('a user connected');\n\n    socket.on('disconnect', () => {\n      console.log('user disconnected');\n    });\n\n    socket.on('move', (data) => {\n      // Handle particle movement\n    });\n\n    socket.on('collision', (data) => {\n      // Handle collision detection\n    });\n\n    socket.on('cluster', (data) => {\n      // Handle cluster management\n    });\n  });\n\n  server.listen(3000, () => {\n    console.log('listening on *:3000');\n  });\n}\n```\n"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by:\n1. Maintaining a mapping of known URL shortening services\n2. Using service-specific APIs when available\n3. Falling back to generic HTTP HEAD requests to follow redirects\n4. Preventing infinite loops through depth tracking and URL history\n\nAttributes:\nmap: [Object] - A mapping of URL shortening services to their known domains\ntimeout: [Number] - HTTP request timeout in milliseconds (default: 5000)\n\nMethods:\nconstructor() -> [URLExpander] - Initializes the URL expander with default configuration\n\nexpand: [Function](args: Object, callback: Function) -> [void] - Main method to expand a URL\n- args: Object containing:\n  - url: String - The URL to expand\n  - depth: Number - Current recursion depth (optional)\n  - seen: Object - Map of previously seen URLs (optional)\n- callback: Function to receive the result with expanded args object\n\nAPIs: [Object] - Collection of service-specific expansion methods:\n- isgd: [Function](args: Object, callback: Function) -> [void] - Expands is.gd URLs\n- googl: [Function](args: Object, callback: Function) -> [void] - Expands goo.gl URLs\n- budurl: [Function](args: Object, callback: Function) -> [void] - Expands budurl.com URLs\n- snipurl: [Function](args: Object, callback: Function) -> [void] - Expands snipurl.com and related URLs\n- generic: [Function](args: Object, callback: Function) -> [void] - Generic URL expansion using HTTP HEAD requests",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass URLExpander {\n  constructor() {\n    this.map = {\n      isgd: ['is.gd'],\n      googl: ['goo.gl'],\n      budurl: ['budurl.com'],\n      snipurl: ['snipurl.com', 'snipurl.eu', 'snipurl.it', 'snipurl.co.uk', 'snipurl.de', 'snipurl.es', 'snipurl.fr', 'snipurl.nl', 'snipurl.no', 'snipurl.pl', 'snipurl.se', 'snipurl.sk', 'snipurl.at', 'snipurl.ch', 'snipurl.cz', 'snipurl.dk', 'snipurl.fi', 'snipurl.hu', 'snipurl.lt', 'snipurl.ro', 'snipurl.bg', 'snipurl.gr', 'snipurl.md', 'snipurl.rs', 'snipurl.tr', 'snipurl.co.jp', 'snipurl.co.kr', 'snipurl.co.nz', 'snipurl.co.za', 'snipurl.com.au', 'snipurl.com.br', 'snipurl.com.cn', 'snipurl.com.mx', 'snipurl.com.tr', 'snipurl.in', 'snipurl.my', 'snipurl.ph', 'snipurl.pk', 'snipurl.sg', 'snipurl.th', 'snipurl.com.ar', 'snipurl.com.co', 'snipurl.com.ec', 'snipurl.com.pe', 'snipurl.com.uy', 'snipurl.com.vn', 'snipurl.fr.be', 'snipurl.fr.ca', 'snipurl.fr.ch', 'snipurl.fr.lu', 'snipurl.fr.mc', 'snipurl.fr.re', 'snipurl.fr.yt', 'snipurl.it.be', 'snipurl.it.ch', 'snipurl.it.co', 'snipurl.it.it', 'snipurl.it.sm', 'snipurl.it.vc', 'snipurl.nl.be', 'snipurl.nl.nl', 'snipurl.nl.sx', 'snipurl.nl.wf', 'snipurl.nl.yt', 'snipurl.no.no', 'snipurl.no.sx', 'snipurl.no.wf', 'snipurl.no.yt', 'snipurl.pl.pl', 'snipurl.pl.sx', 'snipurl.pl.wf', 'snipurl.pl.yt', 'snipurl.se.se', 'snipurl.se.sx', 'snipurl.se.wf', 'snipurl.se.yt', 'snipurl.sk.sk', 'snipurl.sk.sx', 'snipurl.sk.wf', 'snipurl.sk.yt', 'snipurl.at.at', 'snipurl.at.sx', 'snipurl.at.wf', 'snipurl.at.yt', 'snipurl.ch.ch', 'snipurl.ch.sx', 'snipurl.ch.wf', 'snipurl.ch.yt', 'snipurl.cz.cz', 'snipurl.cz.sx', 'snipurl.cz.wf', 'snipurl.cz.yt', 'snipurl.dk.dk', 'snipurl.dk.sx', 'snipurl.dk.wf', 'snipurl.dk.yt', 'snipurl.fi.fi', 'snipurl.fi.sx', 'snipurl.fi.wf', 'snipurl.fi.yt', 'snipurl.hu.hu', 'snipurl.hu.sx', 'snipurl.hu.wf', 'snipurl.hu.yt', 'snipurl.lt.lt', 'snipurl.lt.sx', 'snipurl.lt.wf', 'snipurl.lt.yt', 'snipurl.ro.ro', 'snipurl.ro.sx', 'snipurl.ro.wf', 'snipurl.ro.yt', 'snipurl.bg.bg', 'snipurl.bg.sx', 'snipurl.bg.wf', 'snipurl.bg.yt', 'snipurl.gr.gr', 'snipurl.gr.sx', 'snipurl.gr.wf', 'snipurl.gr.yt', 'snipurl.md.md', 'snipurl.md.sx', 'snipurl.md.wf', 'snipurl.md.yt', 'snipurl.rs.rs', 'snipurl.rs.sx', 'snipurl.rs.wf', 'snipurl.rs.yt', 'snipurl.tr.tr', 'snipurl.tr.sx', 'snipurl.tr.wf', 'snipurl.tr.yt', 'snipurl.co.jp.co.jp', 'snipurl.co.jp.sx', 'snipurl.co.jp.wf', 'snipurl.co.jp.yt', 'snipurl.co.kr.co.kr', 'snipurl.co.kr.sx', 'snipurl.co.kr.wf', 'snipurl.co.kr.yt', 'snipurl.co.nz.co.nz', 'snipurl.co.nz.sx', 'snipurl.co.nz.wf', 'snipurl.co.nz.yt', 'snipurl.co.za.co.za', 'snipurl.co.za.sx', 'snipurl.co.za.wf', 'snipurl.co.za.yt', 'snipurl.com.au.com.au', 'snipurl.com.au.sx', 'snipurl.com.au.wf', 'snipurl.com.au.yt', 'snipurl.com.br.com.br', 'snipurl.com.br.sx', 'snipurl.com.br.wf', 'snipurl.com.br.yt', 'snipurl.com.cn.com.cn', 'snipurl.com.cn.sx', 'snipurl.com.cn.wf', 'snipurl.com.cn.yt', 'snipurl.com.mx.com.mx', 'snipurl.com.mx.sx', 'snipurl.com.mx.wf', 'snipurl.com.mx.yt', 'snipurl.com.tr.com.tr', 'snipurl.com.tr.sx', 'snipurl.com.tr.wf', 'snipurl.com.tr.yt', 'snipurl.in.in', 'snipurl.in.sx', 'snipurl.in.wf', 'snipurl.in.yt', 'snipurl.my.my', 'snipurl.my.sx', 'snipurl.my.wf', 'snipurl.my.yt', 'snipurl.ph.ph', 'snipurl.ph.sx', 'snipurl.ph.wf', 'snipurl.ph.yt', 'snipurl.pk.pk', 'snipurl.pk.sx', 'snipurl.pk.wf', 'snipurl.pk.yt', 'snipurl.sg.sg', 'snipurl.sg.sx', 'snipurl.sg.wf', 'snipurl.sg.yt', 'snipurl.th.th', 'snipurl.th.sx', 'snipurl.th.wf', 'snipurl.th.yt', 'snipurl.com.ar.com.ar', 'snipurl.com.ar.sx', 'snipurl.com.ar.wf', 'snipurl.com.ar.yt', 'snipurl.com.co.com.co', 'snipurl.com.co.sx', 'snipurl.com.co.wf', 'snipurl.com.co.yt', 'snipurl.com.ec.com.ec', 'snipurl.com.ec.sx', 'snipurl.com.ec.wf', 'snipurl.com.ec.yt', 'snipurl.com.pe.com.pe', 'snipurl.com.pe.sx', 'snipurl.com.pe.wf', 'snipurl.com.pe.yt', 'snipurl.com.uy.com.uy', 'snipurl.com.uy.sx', 'snipurl.com.uy.wf', 'snipurl.com.uy.yt', 'snipurl.com.vn.com.vn', 'snipurl.com.vn.sx', 'snipurl.com.vn.wf', 'snipurl.com.vn.yt', 'snipurl.fr.be.fr.be', 'snipurl.fr.be.sx', 'snipurl.fr.be.wf', 'snipurl.fr.be.yt', 'snipurl.fr.ca.fr.ca', 'snipurl.fr.ca.sx', 'snipurl.fr.ca.wf', 'snipurl.fr.ca.yt', 'snipurl.fr.ch.fr.ch', 'snipurl.fr.ch.sx', 'snipurl.fr.ch.wf', 'snipurl.fr.ch.yt', 'snipurl.fr.lu.fr.lu', 'snipurl.fr.lu.sx', 'snipurl.fr.lu.wf', 'snipurl.fr.lu.yt', 'snipurl.fr.mc.fr.mc', 'snipurl.fr.mc.sx', 'snipurl.fr.mc.wf', 'snipurl.fr.mc.yt', 'snipurl.fr.re.fr.re', 'snipurl.fr.re.sx', 'snipurl.fr.re.wf', 'snipurl.fr.re.yt', 'snipurl.fr.yt.fr.yt', 'snipurl.fr.yt.sx', 'snipurl.fr.yt.wf', 'snipurl.fr.yt.yt', 'snipurl.it.be.it.be', 'snipurl.it.be.sx', 'snipurl.it.be.wf', 'snipurl.it.be.yt', 'snipurl.it.ch.it.ch', 'snipurl.it.ch.sx', 'snipurl.it.ch.wf', 'snipurl.it.ch.yt', 'snipurl.it.co.it.co', 'snipurl.it.co.sx', 'snipurl.it.co.wf', 'snipurl.it.co.yt', 'snipurl.it.it.it', 'snipurl.it.it.sx', 'snipurl.it.it.wf', 'snipurl.it.it.yt', 'snipurl.it.sm.it.sm', 'snipurl.it.sm.sx', 'snipurl.it.sm.wf', 'snipurl.it.sm.yt', 'snipurl.it.vc.it.vc', 'snipurl.it.vc.sx', 'snipurl.it.vc.wf', 'snipurl.it.vc.yt', 'snipurl.nl.be.nl.be', 'snipurl.nl.be.sx', 'snipurl.nl.be.wf', 'snipurl.nl.be.yt', 'snipurl.nl.nl.nl.nl', 'snipurl.nl.nl.sx', 'snipurl.nl.nl.wf', 'snipurl.nl.nl.yt', 'snipurl.nl.sx.nl.sx', 'snipurl.nl.sx.sx', 'snipurl.nl.sx.wf', 'snipurl.nl.sx.yt', 'snipurl.nl.wf.nl.wf', 'snipurl.nl.wf.sx', 'snipurl.nl.wf.wf', 'snipurl.nl.wf.yt', 'snipurl.nl.yt.nl.yt', 'snipurl.nl.yt.sx', 'snipurl.nl.yt.wf', 'snipurl.nl.yt.yt', 'snipurl.no.no.no', 'snipurl.no.no.sx', 'snipurl.no.no.wf', 'snipurl.no.no.yt', 'snipurl.no.sx.no.sx', 'snipurl.no.sx.sx', 'snipurl.no.sx.wf', 'snipurl.no.sx.yt', 'snipurl.no.wf.no.wf', 'snipurl.no.wf.sx', 'snipurl.no.wf.wf', 'snipurl.no.wf.yt', 'snipurl.no.yt.no.yt', 'snipurl.no.yt.sx', 'snipurl.no.yt.wf', 'snipurl.no.yt.yt', 'snipurl.pl.pl.pl', 'snipurl.pl.pl.sx', 'snipurl.pl.pl.wf', 'snipurl.pl.pl.yt', 'snipurl.pl.sx.pl.sx', 'snipurl.pl.sx.sx', 'snipurl.pl.sx.wf', 'snipurl.pl.sx.yt', 'snipurl.pl.wf.pl.wf', 'snipurl.pl.wf.sx', 'snipurl.pl.wf.wf', 'snipurl.pl.wf.yt', 'snipurl.pl.yt.pl.yt', 'snipurl.pl.yt.sx', 'snipurl.pl.yt.wf', 'snipurl.pl.yt.yt', 'snipurl.se.se.se', 'snipurl.se.se.sx', 'snipurl.se.se.wf', 'snipurl.se.se.yt', 'snipurl.se.sx.se.sx', 'snipurl.se.sx.sx', 'snipurl.se.sx.wf', 'snipurl.se.sx.yt', 'snipurl.se.wf.se.wf', 'snipurl.se.wf.sx', 'snipurl.se.wf.wf', 'snipurl.se.wf.yt', 'snipurl.se.yt.se.yt', 'snipurl.se.yt.sx', 'snipurl.se.yt.wf', 'snipurl.se.yt.yt', 'snipurl.sk.sk.sk', 'snipurl.sk.sk.sx', 'snipurl.sk.sk.wf', 'snipurl.sk.sk.yt', 'snipurl.sk.sx.sk.sx', 'snipurl.sk.sx.sx', 'snipurl.sk.sx.wf', 'snipurl.sk.sx.yt', 'snipurl.sk.wf.sk.wf', 'snipurl.sk.wf.sx', 'snipurl.sk.wf.wf', 'snipurl.sk.wf.yt', 'snipurl.sk.yt.sk.yt', 'snipurl.sk.yt.sx', 'snipurl.sk.yt.wf', 'snipurl.sk.yt.yt', 'snipurl.at.at.at', 'snipurl.at.at.sx', 'snipurl.at.at.wf', 'snipurl.at.at.yt', 'snipurl.at.sx.at.sx', 'snipurl.at.sx.sx', 'snipurl.at.sx.wf', 'snipurl.at.sx.yt', 'snipurl.at.wf.at.wf', 'snipurl.at.wf.sx', 'snipurl.at.wf.wf', 'snipurl.at.wf.yt', 'snipurl.at.yt.at.yt', 'snipurl.at.yt.sx', 'snipurl.at.yt.wf', 'snipurl.at.yt.yt', 'snipurl.ch.ch.ch', 'snipurl.ch.ch.sx', 'snipurl.ch.ch.wf', 'snipurl.ch.ch.yt', 'snipurl.ch.sx.ch.sx', 'snipurl.ch.sx.sx', 'snipurl.ch.sx.wf', 'snipurl.ch.sx.yt', 'snipurl.ch.wf.ch.wf', 'snipurl.ch.wf.sx', 'snipurl.ch.wf.wf', 'snipurl.ch.wf.yt', 'snipurl.ch.yt.ch.yt', 'snipurl.ch.yt.sx', 'snipurl.ch.yt.wf', 'snipurl.ch.yt.yt', 'snipurl.cz.cz.cz', 'snipurl.cz.cz.sx', 'snipurl.cz.cz.wf', 'snipurl.cz.cz.yt', 'snipurl.cz.sx.cz.sx', 'snipurl.cz.sx.sx', 'snipurl.cz.sx.wf', 'snipurl.cz.sx.yt', 'snipurl.cz.wf.cz.wf', 'snipurl.cz.wf.sx', 'snipurl.cz.wf.wf', 'snipurl.cz.wf.yt', 'snipurl.cz.yt.cz.yt', 'snipurl.cz.yt.sx', 'snipurl.cz.yt.wf', 'snipurl.cz.yt.yt', 'snipurl.dk.dk.dk', 'snipurl.dk.dk.sx', 'snipurl.dk.dk.wf', 'snipurl.dk.dk.yt', 'snipurl.dk.sx.dk.sx', 'snipurl.dk.sx.sx', 'snipurl.dk.sx.wf', 'snipurl.dk.sx.yt', 'snipurl.dk.wf.dk.wf', 'snipurl.dk.wf.sx', 'snipurl.dk.wf.wf', 'snipurl.dk.wf.yt', 'snipurl.dk.yt.dk.yt', 'snipurl.dk.yt.sx', 'snipurl.dk.yt.wf', 'snipurl.dk.yt.yt', 'snipurl.fi.fi.fi', 'snipurl.fi.fi.sx', 'snipurl.fi.fi.wf', 'snipurl.fi.fi.yt', 'snipurl.fi.sx.fi.sx', 'snipurl.fi.sx.sx', 'snipurl.fi.sx.wf', 'snipurl.fi.sx.yt', 'snipurl.fi.wf.fi.wf', 'snipurl.fi.wf.sx', 'snipurl.fi.wf.wf', 'snipurl.fi.wf.yt', 'snipurl.fi.yt.fi.yt', 'snipurl.fi.yt.sx', 'snipurl.fi.yt.wf', 'snipurl.fi.yt.yt', 'snipurl.hu.hu.hu', 'snipurl.hu.hu.sx', 'snipurl.hu.hu.wf', 'snipurl.hu.hu.yt', 'snipurl.hu.sx.hu.sx', 'snipurl.hu.sx.sx', 'snipurl.hu.sx.wf', 'snipurl.hu.sx.yt', 'snipurl.hu.wf.hu.wf', 'snipurl.hu.wf.sx', 'snipurl.hu.wf.wf', 'snipurl.hu.wf.yt', 'snipurl.hu.yt.hu.yt', 'snipurl.hu.yt.sx', 'snipurl.hu.yt.wf', 'snipurl.hu.yt.yt', 'snipurl.lt.lt.lt', 'snipurl.lt.lt.sx', 'snipurl.lt.lt.wf', 'snipurl.lt.lt.yt', 'snipurl.lt.sx.lt.sx', 'snipurl.lt.sx.sx', 'snipurl.lt.sx.wf', 'snipurl.lt.sx.yt', 'snipurl.lt.wf.lt.wf', 'snipurl.lt.wf.sx', 'snipurl.lt.wf.wf', 'snipurl.lt.w"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a function that sets up and starts an HTTP server using the Express framework in JavaScript, with middleware configurations for request processing and static file serving.\n\nFunction Description: The function `createServer` initializes an Express application, configures various middleware for logging, request parsing, and static file serving, and starts an HTTP server listening on a specified port. It also includes environment-specific error handling for development mode.\n\nInput: None (The function does not take any parameters; it uses environment variables like `process.env.PORT` for configuration.)\n\nOutput: None (The function does not return any value; it starts an HTTP server that listens on the specified port and logs a message upon successful startup.)",
    "Canonical_solution": "function createServer() {\n    var express = require('express');\n    var http = require('http');\n    var path = require('path');\n\n    var app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.favicon());\n    app.use(express.logger('dev'));\n    app.use(express.json());\n    app.use(express.urlencoded());\n    app.use(express.methodOverride());\n    app.use(express.static(path.join(__dirname, '/public')));\n    app.use(express.static(path.join(__dirname, '/tests')));\n\n    if ('development' == app.get('env')) {\n        app.use(express.errorHandler());\n    }\n\n    http.createServer(app).listen(app.get('port'), function(){\n        console.log('Express server listening on port ' + app.get('port'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst morgan = require('morgan');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  const error = new Error('Not found');\n  error.status = 404;\n  next(error);\n});\n\napp.use((error, req, res, next) => {\n  res.status(error.status || 500);\n  res.json({\n    error: {\n      message: error.message\n    }\n  });\n});\n\nconst port = process.env.PORT || 3000;\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a function that sets up an Express server with middleware configuration, route handling, and server initialization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with essential middleware (CORS, static file serving, JSON body parsing), configures route handlers, and starts listening on a specified port. It handles both API routes and serves static HTML files.\n\nInput: None (The function uses imported modules and configuration from './src/config' and './src/routes')\n\nOutput: None (The function's side effect is starting an HTTP server that listens on the configured port)",
    "Canonical_solution": "function setupExpressServer() {\n    const bodyParser = require('body-parser');\n    const express = require('express');\n    const path = require('path');\n    const cors = require('cors');\n    const config = require('./src/config');\n    const routes = require('./src/routes');\n\n    const app = express();\n\n    app.enable('trust proxy');\n    app.use(cors());\n    app.use(express.static(path.join(__dirname, 'www')));\n    app.use(bodyParser.json());\n\n    app.get('/v2', (req, res) => res.sendFile(path.join(__dirname, 'www/index.html')));\n    app.use(routes);\n\n    app.listen(config.PORT, err => {\n        if (err) console.error(err);\n        console.log('Server started on ' + config.PORT);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst routes = require('./src/routes');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use(bodyParser.json());\n\napp.use('/api', routes);\n\nconst { port } = require('./src/config');\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Twitter Search Client class that handles searching tweets, managing search state, and storing results locally.\n\nClass Description: TSClient is a Twitter search client that performs searches, tracks search state (including pagination and since_id), caches results to local files, and provides synchronization capabilities.\n\nAttributes:\n- search: [Object] - Contains search parameters and state including query (q), since_id, result count (rcount), and a unique search id\n- id: [String] - MD5 hash of the search query used as a unique identifier\n- new_since_id: [String] - Tracks the newest tweet ID retrieved during the current sync\n\nMethods:\n- constructor(query, cb) -> [TSClient] - Initializes a new search client with the given query. Creates a unique ID for the search and loads previous state if available. Calls the callback with the initialized client.\n  - query: [String] - The search query string\n  - cb: [Function] - Callback function that receives the initialized TSClient instance\n\n- syncSearch(callback) -> [void] - Initiates a new synchronization of search results, walking through paginated results.\n  - callback: [Function] - Called with the array of results when sync completes\n\n- set(search) -> [void] - Updates the search state and persists it to disk.\n  - search: [Object] - The search state object to save\n\n- _walker(s) -> [void] - Internal recursive method that handles pagination through search results.\n  - s: [Object] - State object containing:\n    - ts: [TSClient] - Reference to the TSClient instance\n    - search: [Object] - Current search parameters\n    - cb: [Function] - Completion callback\n    - page: [Number] - Current page number\n    - results: [Array] - Accumulated results\n    - new_since_id: [String] - Newest tweet ID in current batch (optional)",
    "Canonical_solution": "var request = require('request');\nvar url = require('url');\n\nclass TSClient {\n    constructor(query, cb) {\n        this.search = {};\n        this.search.q = query;\n        this.search.since_id = 0;\n        this.search.rcount = 0;\n        var hash = crypto.createHash('md5');\n        hash.update(query);\n        this.search.id = hash.digest('hex');\n        var self = this;\n        lfs.readObjectFromFile(self.search.id+'.search', function(data) {\n            if(data && data.id) {\n                self.search = data;            \n            } else {\n                lfs.writeObjectToFile(self.search.id+'.search',self.search);\n            }\n            cb(self);\n        });\n    }\n\n    syncSearch(callback) {\n        console.log(\"new sync \"+JSON.stringify(this.search));\n        this._walker({ts:this, search:this.search, cb:callback, page:1, results:[]});\n    }\n\n    set(search) {\n        this.search = search;\n        lfs.writeObjectToFile(search.id+'.search',search);    \n    }\n\n    _walker(s) {\n        var uri = url.parse(\"http://search.twitter.com/search.json\");\n        uri.query = {q:s.search.q, rpp:100, page:s.page, since_id:s.search.since_id};\n        console.log(\"walking page \"+url.format(uri));\n        request.get({uri:url.format(uri)}, function(err, resp, body) {\n            if(err) {\n                console.log(\"request failed: \"+err);\n                s.cb([]);\n                return;\n            }\n            var data = JSON.parse(body);\n            if(data && data.results && data.results.length > 0) {\n                s.results = s.results.concat(data.results);\n                s.page++;\n                console.log(\"page \"+data.page+\" and max \"+data.max_id_str);\n                if(data.page == 1) s.new_since_id = data.max_id_str;\n            } else {\n                s.page=16;\n            }\n            if(s.page <= 15) {\n                this._walker(s);\n            } else {\n                console.log(\"saving \"+s.results.length+\" tweets\");\n                lfs.writeObjectsToFile(s.search.id+'.tweets',s.results);\n                s.search.rcount += s.results.length;\n                if(s.new_since_id) s.search.since_id = s.new_since_id;\n                s.ts.set(s.search);\n                s.cb(s.results);\n            }\n        }.bind(this));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```typescript\nclass TSClient {\n  search: any;\n  id: string;\n  new_since_id: string;\n\n  constructor(query: string, cb: Function) {\n    this.search = {\n      q: query,\n      since_id: null,\n      rcount: 100,\n      search_id: null\n    };\n    this.id = md5(query);\n    this.new_since_id = null;\n    this._loadState();\n    cb(this);\n  }\n\n  syncSearch(callback: Function) {\n    this._walker({\n      ts: this,\n      search: this.search,\n      cb: callback,\n      page: 1,\n      results: []\n    });\n  }\n\n  set(search: any) {\n    this.search = search;\n    this._saveState();\n  }\n\n  _walker(s: any) {\n    let ts = s.ts;\n    let search = s.search;\n    let cb = s.cb;\n    let page = s.page;\n    let results = s.results;\n    let new_since_id = s.new_since_id || null;\n\n    let params = {\n      q: search.q,\n      rpp: search.rcount,\n      result_filter: 'user',\n      include_entities: false,\n      include_rts: false,\n      since_id: search.since_id\n    };\n\n    if (new_since_id) {\n      params.since_id = new_since_id;\n    }\n\n    twitter.search.tweets(params, function (error: any, data: any) {\n      if (error) {\n        console.log(error);\n        return;\n      }\n\n      let tweets = data.statuses;\n      if (tweets.length > 0) {\n        let last_tweet = tweets[tweets.length - 1];\n        new_since_id = last_tweet.id_str;\n        results = results.concat(tweets);\n        search.since_id = new_since_id;\n        ts.set(search);\n        ts._walker({\n          ts: ts,\n          search: search,\n          cb: cb,\n          page: page + 1,\n          results: results,\n          new_since_id: new_since_id\n        });\n      } else {\n        cb(results);\n      }\n    });\n  }\n\n  _loadState() {\n    let state = fs.readFileSync(path.join(__dirname, this.id + '.json'), 'utf8');\n    if (state) {\n      this.search = JSON.parse(state);\n    }\n  }\n\n  _saveState() {\n    fs.writeFileSync(path.join(__dirname, this.id + '.json'), JSON.stringify(this.search));\n  }\n}\n```"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a function that sets up and starts an Express server with basic configuration, static file serving, and additional route handlers.\n\nFunction Description: The function `createExpressServer` initializes an Express application, configures it to serve static files from a parent directory, integrates additional route handlers from a separate module, and starts listening on a specified port (either from environment variables or defaulting to 3000).\n\nInput: None (The function takes no parameters but uses environment variables for configuration)\n\nOutput: Returns the HTTP server instance created by `app.listen()`, which is actively listening on the specified port. The function also logs server start information to the console.",
    "Canonical_solution": "function createExpressServer() {\n    const express = require('express');\n    const app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.static('../'));\n\n    require('./src-server/multerImpl')(app);\n\n    return app.listen(app.get('port'), () => {\n        console.log('Express server listening on port ' + app.get('port'));\n        console.log('Visit http://localhost:' + app.get('port') + '/example/ to check out the upload example');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additionalRoutes');\n\nfunction createExpressServer() {\n  const app = express();\n  const port = process.env.PORT || 3000;\n\n  app.use(express.static(path.join(__dirname, '..')));\n\n  additionalRoutes(app);\n\n  const server = app.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n\n  return server;\n}\n\nmodule.exports = createExpressServer;\n```"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to efficiently handle large files.\n\nFunction Description: The function `uploadFileViaPipe` streams a file from the local filesystem to an HTTP server using Node.js's built-in `fs` and `http` modules. It utilizes the pipe mechanism to efficiently transfer data without loading the entire file into memory, making it suitable for large files. The function assumes a predefined server port and file path.\n\nInput: \n- None (The function uses hardcoded values for demonstration purposes. In a real implementation, these would typically be parameters.)\n\nOutput: \n- None (The function performs a side effect of uploading a file. Success or failure would typically be handled via callbacks or events in a production implementation.)",
    "Canonical_solution": "function uploadFileViaPipe() {\n    var http = require('http');\n    var fs = require('fs');\n    var path = require('path');\n    \n    var testFilePath = path.join(__dirname, '../fixture/file/binaryfile.tar.gz');\n    var port = common.port;\n\n    var request = http.request({\n        port: port,\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/octet-stream'\n        }\n    });\n\n    fs.createReadStream(testFilePath).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "wrong_result": "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction uploadFileViaPipe() {\n  const options = {\n    hostname: 'localhost',\n    port: 8080,\n    path: '/upload',\n    method: 'POST'\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`Upload successful. Server responded with: ${res.statusCode}`);\n  });\n\n  const fileStream = fs.createReadStream('/path/to/large/file');\n  fileStream.pipe(req);\n\n  req.on('error', (e) => {\n    console.error(`Upload failed: ${e.message}`);\n  });\n\n  fileStream.on('end', () => {\n    req.end();\n  });\n}\n\nuploadFileViaPipe();\n```"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that makes an HTTP POST request to a specified URL with custom headers and data, then handles the response.\n\nFunction Description: The function `makeHttpRequest` sends an HTTP POST request to a given URL with specified headers and a data payload. It uses the `request` module to perform the HTTP request and includes a callback function to handle the response or errors. The function is designed to be reusable for making HTTP POST requests with minimal configuration.\n\nInput: \n- None (The URL, headers, and data are hardcoded within the function for simplicity. In a real-world scenario, these could be passed as parameters.)\n\nOutput: \n- None (The function logs the response body to the console if the request is successful. In a real-world scenario, the response could be returned or processed further.)\n\nNote: The function assumes the `request` module is available in the environment. If not, it must be installed via npm or another package manager.",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    };\n\n    var dataString = '18233982904';\n\n    var options = {\n        url: 'http://localhost:28139/CurlToNode',\n        method: 'POST',\n        headers: headers,\n        body: dataString\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'https://example.com/api';\n  const headers = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer token123'\n  };\n  const data = {\n    key1: 'value1',\n    key2: 'value2'\n  };\n\n  request.post({ url, headers, json: data }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else if (response.statusCode !== 200) {\n      console.error('Status Code:', response.statusCode);\n    } else {\n      console.log('Response Body:', body);\n    }\n  });\n}\n\nmakeHttpRequest();\n```"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to record incoming connections and requests, piping the request data to individual files for each connection.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming connections. For each connection, it creates a unique file to store the raw HTTP request data. The server handles regular requests by responding with connection information and provides an HTML upload form for the root path. The server tracks active connections and logs connection/disconnection events.\n\nInput: None (The function takes no parameters but uses environment variable `PORT` for configuration)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server that writes to files)\n\nNote: The function maintains internal state including:\n- A connection counter\n- An active HTTP server instance\n- File streams for each connection\n- Logging of connection events to console",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nlet connections = 0;\nlet server;\nlet fileStreams = {};\n\nfunction createServer() {\n  server = http.createServer((req, res) => {\n    connections++;\n    const connectionId = connections;\n    const filePath = path.join(__dirname, `connection_${connectionId}.txt`);\n    const fileStream = fs.createWriteStream(filePath);\n\n    fileStreams[connectionId] = fileStream;\n\n    console.log(`Connection ${connectionId} established`);\n\n    req.on('data', (chunk) => {\n      fileStream.write(chunk);\n    });\n\n    req.on('end', () => {\n      fileStream.end();\n      console.log(`Connection ${connectionId} closed`);\n    });\n\n    if (req.url === '/') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.write(`\n        <html>\n          <body>\n            <h1>Upload a file</h1>\n            <form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n              <input type=\"file\" name=\"file\"><br><br>\n              <input type=\"submit\" value=\"Upload File\">\n            </form>\n          </body>\n        </html>\n      `);\n      res.end();\n    } else {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.write(`Connection ID: ${connectionId}\\n`);\n      res.write(`Active connections: ${connections}\\n`);\n      res.end();\n    }\n  });\n\n  server.listen(process.env.PORT, () => {\n    console.log(`Server running at http://localhost:${process.env.PORT}/`);\n  });\n}\n\nmodule.exports = createServer;\n```"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a JavaScript class that implements a server capable of handling HTTP requests and piping data to responses, with support for live reload functionality and error handling.\n\nClass Description: The `Server` class is designed to create an HTTP server that can handle incoming requests, pipe data to responses (particularly for live reload functionality), and manage server lifecycle events. It supports both standalone operation and integration with existing Express-like applications.\n\nAttributes:\n- options: [Object] - Configuration options for the server including livereload file path and port number.\n- clients: [Object] - Storage for connected clients (used for live reload functionality).\n- server: [http.Server] - The underlying HTTP server instance.\n- app: [Object] - Optional Express-like application instance for integration.\n- port: [Number] - The port number the server is listening on.\n\nMethods:\n- constructor(options) -> [Server] - Initializes the server with given options, setting defaults for livereload path and port.\n- configure(app) -> [Server] - Configures the server to work with an existing Express-like application.\n- handler(req, res, next) -> [Server] - Handles incoming HTTP requests, supporting both middleware and direct handling modes.\n- livereload(req, res) -> [void] - Pipes the livereload JavaScript file to the response.\n- listen(port, fn) -> [void] - Starts the server listening on the specified port.\n- close(req, res) -> [void] - Closes the server and optionally ends a response.\n- error(e) -> [void] - Handles and logs server errors.\n\nNote: The class demonstrates inter-process communication through HTTP and file system operations, particularly in the `livereload` method where it pipes file contents directly to HTTP responses.",
    "Canonical_solution": "var fs = require('fs');\nvar http = require('http');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.options.livereload = this.options.livereload || path.join(__dirname, 'public/livereload.js');\n    this.options.port = parseInt(this.options.port || 35729, 10);\n    this.clients = {};\n    this.configure(this.options.app);\n  }\n\n  configure(app) {\n    if(!app) {\n      this.server = http.createServer(this.handler.bind(this));\n      this.server.on('error', this.error.bind(this));\n      return this;\n    }\n\n    var self = this;\n    this.app = app;\n\n    this.app.listen = function(port, done) {\n      done = done || function() {};\n      var srv = self.server = http.createServer(app);\n      srv.on('error', self.error.bind(self));\n      srv.on('close', self.close.bind(self));\n      return srv.listen(port, done);\n    };\n\n    return this;\n  }\n\n  handler(req, res, next) {\n    var middleware = typeof next === 'function';\n    if(middleware) {\n      this.handle(req, res, next);\n      return this;\n    }\n\n    req\n      .on('end', this.handle.bind(this, req, res))\n      .on('data', function(chunk) {\n        req.data = req.data || '';\n        req.data += chunk;\n      });\n\n    return this;\n  }\n\n  livereload(req, res) {\n    fs.createReadStream(this.options.livereload).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.port = port;\n    this.server.listen(port, fn);\n  }\n\n  close(req, res) {\n    if(res) res.end();\n    if(this.server._handle) this.server.close();\n  }\n\n  error(e) {\n    console.error('Error:', e.message);\n    console.error(e.stack);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nclass Server {\n  constructor(options) {\n    this.options = options;\n    this.clients = {};\n    this.server = null;\n    this.app = null;\n    this.port = options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else {\n      next();\n    }\n  }\n\n  livereload(req, res) {\n    const fs = require('fs');\n    const path = require('path');\n    const filePath = path.join(__dirname, this.options.livereload);\n    fs.createReadStream(filePath).pipe(res);\n  }\n\n  listen(port, fn) {\n    const http = require('http');\n    this.server = http.createServer((req, res) => {\n      this.handler(req, res, (err) => {\n        if (err) {\n          this.error(err);\n          res.statusCode = 500;\n          res.end('Internal Server Error');\n        } else {\n          res.statusCode = 404;\n          res.end('Not Found');\n        }\n      });\n    });\n    this.server.listen(port, fn);\n  }\n\n  close(req, res) {\n    if (this.server) {\n      this.server.close();\n    }\n    if (res) {\n      res.end();\n    }\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n```\n"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Retrieve and process TV channel information from multiple providers via HTTP requests, then extract and deduplicate channel details.\n\nFunction Description: The function makes HTTP POST requests to a TV guide service for each provider, extracts channel information from the HTML response, and returns a deduplicated list of channels. It uses axios for HTTP requests, cheerio for HTML parsing, and lodash for deduplication.\n\nInput: None (The function uses hardcoded providers array and automatically determines the current date)\n\nOutput: Array of objects containing unique TV channel information with the following structure:\n[\n    {\n        lang: string,       // Language code ('it' for Italian)\n        name: string,       // Channel name\n        site_id: string     // Unique identifier combining channel number and slug\n    },\n    ...\n]",
    "Canonical_solution": "function async channels() {\n    const axios = require('axios')\n    const _ = require('lodash')\n\n    const providers = ['-1', '-2', '-3']\n\n    const channels = []\n    for (let provider of providers) {\n        const data = await axios\n            .post('https://www.guida.tv/guide/schedule', null, {\n                params: {\n                    provider,\n                    region: 'Italy',\n                    TVperiod: 'Night',\n                    date: dayjs().format('YYYY-MM-DD'),\n                    st: 0,\n                    u_time: 1429,\n                    is_mobile: 1\n                }\n            })\n            .then(r => r.data)\n            .catch(console.log)\n\n        const $ = cheerio.load(data)\n        $('.channelname').each((i, el) => {\n            const name = $(el).find('center > a:eq(1)').text()\n            const url = $(el).find('center > a:eq(1)').attr('href')\n            const [, number, slug] = url.match(/\\/(\\d+)\\/(.*)\\.html$/)\n\n            channels.push({\n                lang: 'it',\n                name,\n                site_id: `${number}/${slug}`\n            })\n        })\n    }\n\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    {\n        name: 'Mediaset',\n        url: 'https://www.mediasetplay.it/guida-tv/guida-tv-today',\n        lang: 'it'\n    },\n    {\n        name: 'Sky',\n        url: 'https://www.sky.it/guida-tv/guida-tv-today',\n        lang: 'it'\n    },\n    {\n        name: 'Rai',\n        url: 'https://www.raiplay.it/guida-tv/guida-tv-today',\n        lang: 'it'\n    }\n];\n\nasync function getChannels() {\n    const channels = [];\n\n    for (const provider of providers) {\n        const response = await axios.post(provider.url);\n        const $ = cheerio.load(response.data);\n        const providerChannels = [];\n\n        $('div.channel').each((index, element) => {\n            const lang = provider.lang;\n            const name = $(element).find('div.channel-name').text().trim();\n            const site_id = $(element).find('div.channel-number').text().trim() + '-' + $(element).find('div.channel-name').attr('data-slug');\n\n            providerChannels.push({ lang, name, site_id });\n        });\n\n        channels.push(...providerChannels);\n    }\n\n    return _.uniqBy(channels, 'site_id');\n}\n\nmodule.exports = getChannels;\n```"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files, using Node.js's built-in `http` and `fs` modules. The server should handle different MIME types and pipe file contents to the response stream.\n\nFunction Description: The `createServer` function initializes an HTTP server that listens on port 5000. It serves static files from the local file system, automatically determining the appropriate MIME type based on the file extension. If a requested file doesn't exist, it logs a warning. The function uses streaming to efficiently pipe file contents to the HTTP response.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server)",
    "Canonical_solution": "function createServer() {\n  var http = require('http'), fs = require('fs'), mimeTypes = {\n    'html': 'text/html',\n    'css': 'text/css',\n    'js': 'text/javascript',\n    'json': 'application/json',\n    'png': 'image/png',\n    'jpg': 'image/jpg'\n  };\n\n  http.createServer(function (req, res) {\n    var file = (req.url === '/') ? 'index.html' : \".\" + req.url;\n    var ext = require('path').extname(file),\n      type = (mimeTypes[ext] ? mimeTypes[ext] : '');\n\n    fs.exists(file, function (exists) {\n      if (exists) {\n        res.writeHead(200, {'Content-Type': type});\n        fs.createReadStream(file).pipe(res);\n      } else {\n        console.warn(file, ' does not exit');\n      }\n    });\n  }).listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst mimeTypes = {\n  '.html': 'text/html',\n  '.js': 'text/javascript',\n  '.css': 'text/css',\n  '.json': 'application/json',\n  '.png': 'image/png',\n  '.jpg': 'image/jpeg',\n  '.gif': 'image/gif',\n  '.wav': 'audio/wav',\n  '.mp4': 'video/mp4',\n  '.woff': 'application/font-woff',\n  '.ttf': 'application/font-sfnt',\n};\n\nfunction createServer() {\n  http.createServer((req, res) => {\n    let filePath = '.' + req.url;\n    if (filePath === './') {\n      filePath = './index.html';\n    }\n    const extname = String(path.extname(filePath)).toLowerCase();\n    const contentType = mimeTypes[extname] || 'application/octet-stream';\n    fs.readFile(filePath, (error, content) => {\n      if (error) {\n        if (error.code == 'ENOENT') {\n          fs.readFile('./404.html', (error, content) => {\n            res.writeHead(404, { 'Content-Type': 'text/html' });\n            res.end(content, 'utf-8');\n          });\n        } else {\n          res.writeHead(500);\n          res.end(`Server Error: ${error.code}`);\n        }\n      } else {\n        res.writeHead(200, { 'Content-Type': contentType });\n        res.end(content, 'utf-8');\n      }\n    });\n  }).listen(5000);\n}\n\ncreateServer();\n```"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files and handle dynamic JavaScript file concatenation, with support for piping binary files.\n\nFunction Description: The `createServer` function initializes an HTTP server that serves static files from specified directories, handles dynamic concatenation of JavaScript files, and pipes binary files directly to the response. It supports virtual paths, content type detection, and redirection.\n\nInput: \n- Optional command line argument [string] - The port number to listen on (defaults to 90 if not provided)\n\nOutput: \n- None (directly creates and starts an HTTP server)\n- Console output indicating server startup and loaded files\n\nAttributes: (N/A - This is a function, not a class)\n\nMethods: (N/A - This is a function, not a class)\n\nAdditional Implementation Details:\n1. Reads and caches static files from '../src' and '../dist' directories at startup\n2. Handles binary files separately from text files\n3. Supports special handling for core JavaScript files and plugins\n4. Implements virtual path redirection\n5. Uses file extension to determine content type\n6. Provides fallback behavior for undefined routes\n7. Listens on localhost (127.0.0.1) only\n8. Outputs loaded file list to console at startup",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require(\"fs\");\n    var url = require(\"url\");\n\n    var BASE_URL=\"http://www.servicestack.net\", \n        VIRTUAL_PATH=\"/jqbuilder\"; \n\n    var getExt = function(path) {\n        return path.substring(path.lastIndexOf('.')+1);\n    };\n    String.prototype.startsWith = function (str){\n        return this.indexOf(str) === 0;\n    };\n\n    var contentTypes = { \"htm\": \"text/html\", \"js\": \"text/javascript\", \"gif\": \"image/gif\" };\n\n    var srcDir = '../src', targetDir = '../dist';\n    var webFiles = fs.readdirSync(targetDir);\n    var staticFiles = {}, binaryFiles = {};\n    fs.readdirSync(srcDir).forEach(function(file) { \n        var filePath = srcDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(targetDir).forEach(function(file) { \n        var filePath = targetDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(\"./\").forEach(function(file) {\n        var isText = (contentTypes[getExt(file)]||\"\").startsWith(\"text\");\n        if (isText)\n            staticFiles[\"/\" + file] = fs.readFileSync(file).toString('utf-8');\n        else \n            binaryFiles[\"/\" + file] = file;\n    });\n\n    staticFiles[\"/\"] = staticFiles[\"/default.htm\"];\n\n    console.log(\"loaded: \", Object.keys(staticFiles));\n\n    var isCore = { \"/jquip.js\": true, \"/jquip.min.js\": true };\n\n    var port = process.argv[2] || 90;\n\n    http.createServer(function (req, res) {\n        var reqUrl = url.parse(req.url), path = reqUrl.pathname.replace(VIRTUAL_PATH,'');\n        if (reqUrl.pathname == VIRTUAL_PATH){\n            res.writeHead(302,BASE_URL+VIRTUAL_PATH+\"/\");\n            res.end();\n            return;\n        }\n\n        var fileContents = staticFiles[path];\n\n        if (fileContents) {\n            var ext = path == \"/\" ? \"htm\" : getExt(path);\n            var contentType = contentTypes[ext];\n            res.writeHead(200, {'Content-Type': contentType });\n            var isPlugin = ext == \"js\" && path.startsWith(\"/jquip.\") && !isCore[path];\n            if (isPlugin) {\n                var coreJs = path.indexOf(\"min\") != -1 \n                    ? staticFiles[\"/jquip.min.js\"]\n                    : staticFiles[\"/jquip.js\"];\n                fileContents = coreJs + \";\" + fileContents;\n            }\n\n            res.end(fileContents);\n        }\n        else if (binaryFiles[path]) { \n            var filePath = binaryFiles[path]; \n            fs.createReadStream(filePath, {\n              'bufferSize': 4 * 1024\n            }).pipe(res);\n        }\n        else\n        {\n            var isDynamic = path.startsWith(\"/jquip.\");\n            if (isDynamic) {\n                var parts = path.substring(1).split('.');\n                var isMin = parts.indexOf(\"min\") >= 0;\n                var js = isMin ? staticFiles[\"/jquip.min.js\"] : staticFiles[\"/jquip.js\"];\t\t\t\n                parts.forEach(function(part){\n                    if (part == \"jquip\" || part == \"min\" || part == \"js\") return;\n                    var path = \"/jquip.\" + part + (isMin ? \".min.js\" : \".js\");\n                    var jsFile = staticFiles[path];\n                    if (jsFile)\n                        js += \";\" + jsFile;\n                });\n                res.writeHead(200, {'Content-Type': 'text/javascript' });\n                res.end(js);\t\t\n                return;\n            }\n\n            res.writeHead(200, {'Content-Type': 'text/plain'});\n            var sb = \"\";\n            for (var i in reqUrl) {\n                if (sb) sb += \"\\n\";\n                sb += i + \": \" + reqUrl[i];\n            }\n            res.end(\"Path not found:\\n\" + sb);\n        }\n    })\n    .listen(port, \"127.0.0.1\");\n    console.log('Server running at http://127.0.0.1:'+port+'/');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst url = require('url');\nconst zlib = require('zlib');\n\nconst port = process.argv[2] || 90;\nconst staticDirs = ['../src', '../dist'];\nconst coreFiles = ['core.js', 'core.min.js'];\nconst pluginFiles = ['plugin.js', 'plugin.min.js'];\nconst binaryExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.bin', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '.iso', '.img', '.tar', '.gz', '.bz2', '.xz', '.mp3', '.mp4', '.webm', '.ogg', '.wav', '.pdf', '.zip', '.rar', '.7z', '.gz', '.bz2', '.xz', '.exe', '.msi', '.dll', '.so', '.dylib', '.a', '."
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement an OAuth server class that handles GitHub OAuth authentication flow, including starting a server to receive the authorization code and exchanging it for an access token.\n\nClass Description: The OAuthServer class represents a server that facilitates GitHub OAuth authentication. It creates an Express server to handle the OAuth callback, exchanges the authorization code for an access token using GitHub's API, and provides methods to start and stop the server.\n\nAttributes:\n- options: [Object] - Configuration object containing client credentials and server settings\n- prompt: [Object] - Reference to an external prompt object used to signal completion of authentication\n- app: [Object] - Express application instance for handling HTTP requests\n- server: [Object] - HTTP server instance created by Express\n- token: [String|null] - Stores the obtained OAuth access token\n\nMethods:\n- constructor(options) -> [OAuthServer] - Initializes the OAuth server with configuration options and sets up the Express route for handling OAuth callbacks\n- start() -> [Promise] - Starts the HTTP server on the configured port and returns a promise that resolves when the server is ready or rejects on error\n- stop() -> [void] - Stops the HTTP server and cleans up resources",
    "Canonical_solution": "const express = require('express');\nconst axios = require('axios');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = this.options.prompt;\n    this.app = express();\n    this.app.get('/', (req, res) => {\n      const code = req.query.code;\n      axios\n        .post(\n          `https://github.com/login/oauth/access_token?client_secret=${\n            this.options.client_secret\n          }&client_id=${this.options.client_id}&code=${code}`,\n          {},\n          {\n            headers: {\n              Accept: 'application/json'\n            }\n          }\n        )\n        .then(response => {\n          const accessToken = response.data.access_token;\n          this.token = accessToken;\n          res.send('Enquirer: Github OAuth Server is up');\n          this.prompt.submit();\n        })\n        .catch(e => console.log('axios error', e));\n    });\n    this.token = null;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.options.port, err => {\n        if (err) {\n          return reject(err);\n        }\n        resolve();\n      });\n    });\n  }\n\n  stop() {\n    this.server.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = options.prompt;\n    this.app = express();\n    this.server = http.createServer(this.app);\n    this.token = null;\n\n    this.app.get('/oauth/callback', async (req, res) => {\n      const code = req.query.code;\n      if (!code) {\n        return res.status(400).send('Authorization code not found');\n      }\n\n      try {\n        const tokenResponse = await axios.post('https://github.com/login/oauth/access_token', {\n          client_id: this.options.clientId,\n          client_secret: this.options.clientSecret,\n          code: code,\n        }, {\n          headers: {\n            Accept: 'application/json',\n          },\n        });\n\n        this.token = tokenResponse.data.access_token;\n        this.prompt.resolve();\n      } catch (error) {\n        this.prompt.reject(error);\n      }\n\n      res.send('Authentication successful');\n    });\n  }\n\n  async start() {\n    return new Promise((resolve, reject) => {\n      this.server.listen(this.options.port, () => {\n        console.log(`OAuth server listening on port ${this.options.port}`);\n        resolve();\n      }).on('error', reject);\n    });\n  }\n\n  stop() {\n    this.server.close();\n  }\n}\n```"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files from a specified directory, handling different MIME types and responding with 404 errors for non-existent files.\n\nFunction Description: The function `createFileServer` initializes an HTTP server that serves static files (HTML, images, JavaScript, CSS) from a 'static' directory in the current working directory. It handles proper MIME types for different file extensions and responds with 404 errors when files are not found. The server listens on port 1338 by default.\n\nInput: None (The function takes no parameters; all configuration is internal)\n\nOutput: None (The function doesn't return anything; it creates and starts an HTTP server that continues running)",
    "Canonical_solution": "function createFileServer() {\n    var http = require('http'),\n        url = require('url'),\n        path = require('path'),\n        fs = require('fs'),\n        port = 1338;\n    var mimeTypes = {\n        \"html\": \"text/html\",\n        \"jpeg\": \"image/jpeg\",\n        \"jpg\": \"image/jpeg\",\n        \"png\": \"image/png\",\n        \"js\": \"text/javascript\",\n        \"css\": \"text/css\"};\n\n    http.createServer(function(req, res) {\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(process.cwd(),'static', uri);\n        fs.exists(filename, function(exists) {\n            if(!exists) {\n                console.error(\"not exists: \" + filename);\n                res.writeHead(404, {'Content-Type': 'text/plain'});\n                res.write('404 Not Found\\n');\n                res.end();\n                return;\n            }\n            var mimeType = mimeTypes[path.extname(filename).split(\".\")[1]];\n            res.writeHead(200, {'Content-Type':mimeType});\n\n            var fileStream = fs.createReadStream(filename);\n            fileStream.pipe(res);\n        });\n    }).listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createFileServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = path.join(__dirname, 'static', req.url);\n    const fileExt = path.extname(filePath).toLowerCase();\n\n    let contentType = 'text/plain';\n    switch (fileExt) {\n      case '.html':\n        contentType = 'text/html';\n        break;\n      case '.css':\n        contentType = 'text/css';\n        break;\n      case '.js':\n        contentType = 'application/javascript';\n        break;\n      case '.jpg':\n      case '.jpeg':\n        contentType = 'image/jpeg';\n        break;\n      case '.png':\n        contentType = 'image/png';\n        break;\n      case '.gif':\n        contentType = 'image/gif';\n        break;\n    }\n\n    fs.readFile(filePath, (err, content) => {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          res.writeHead(404, { 'Content-Type': 'text/plain' });\n          res.end('404 Not Found');\n        } else {\n          res.writeHead(500);\n          res.end('Sorry, something went wrong.');\n        }\n      } else {\n        res.writeHead(200, { 'Content-Type': contentType });\n        res.end(content, 'utf-8');\n      }\n    });\n  });\n\n  server.listen(1338, () => {\n    console.log('Server running at http://127.0.0.1:1338/');\n  });\n}\n\ncreateFileServer();\n```"
  },
  {
    "Task_id": 154,
    "Instruction": "Task Description: Create a TCP server class in JavaScript that can handle both regular and TLS-encrypted connections, manage client connections, and provide methods to start and destroy the server.\n\nClass Description: The MockServer class is a TCP server implementation that can be configured to use either regular TCP or TLS encryption. It manages server lifecycle, client connections, and provides methods to start and stop the server gracefully.\n\nAttributes:\n- host: [String] - The host address the server binds to\n- port: [Number] - The port number the server listens on\n- family: [String] - The IP address family (e.g., 'ipv4')\n- server: [Object] - The underlying TCP/TLS server instance\n- tlsEnabled: [Boolean] - Flag indicating if TLS is enabled\n- state: [String] - Current server state ('stopped', 'running', or 'destroyed')\n- connections: [Number] - Count of active client connections\n- sockets: [Array] - Array of active client sockets\n\nMethods:\n- constructor(port, host, options) -> [void] - Initializes the server with specified port, host, and options (including TLS configuration)\n- start() -> [Promise] - Starts the server and returns a promise that resolves when listening\n- destroy() -> [Promise] - Gracefully shuts down the server and returns a promise that resolves when complete",
    "Canonical_solution": "const net = require('net');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    // Save the settings\n    this.host = host;\n    this.port = port;\n    this.family = 'ipv4';\n\n    // Create a server socket\n    this.server = options.tls ? tls.createServer(options) : net.createServer(options);\n    this.tlsEnabled = !!options.tls;\n\n    // state\n    this.state = 'stopped';\n\n    // Number of connections\n    this.connections = 0;\n\n    // sockets\n    this.sockets = [];\n  }\n\n  /**\n   * Start the TCP server\n   */\n  start() {\n    const self = this;\n    return new Promise((resolve, reject) => {\n      self.server.on('error', err => {\n        reject(err);\n      });\n\n      const connectionEventName = self.tlsEnabled ? 'secureConnection' : 'connection';\n      self.server.on(connectionEventName, c => {\n        self.connections = self.connections + 1;\n        self.sockets.push(c);\n\n        c.on('error', e => {\n          console.warn('connection error: ', e);\n        });\n\n        c.on('close', () => {\n          self.connections = self.connections - 1;\n          const index = self.sockets.indexOf(c);\n          if (index !== -1) {\n            self.sockets.splice(index, 1);\n          }\n        });\n      });\n\n      self.server.listen(self.port, self.host, () => {\n        // update address information if necessary\n        self.host = self.server.address().address;\n        self.port = self.server.address().port;\n        self.family = self.server.address().family;\n\n        resolve(self);\n      });\n\n      self.state = 'running';\n    });\n  }\n\n  /**\n   * Destroy the TCP server\n   */\n  destroy() {\n    const self = this;\n    if (self.state === 'destroyed') {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      self.sockets.forEach(socket => socket.destroy());\n      self.server.close(err => {\n        if (err) return reject(err);\n        self.state = 'destroyed';\n        resolve();\n      });\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nclass MockServer {\n  constructor(port, host, options) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = options.tlsEnabled || false;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'running') {\n        reject(new Error('Server is already running'));\n        return;\n      }\n\n      if (this.tlsEnabled) {\n        const tls = require('tls');\n        this.server = tls.createServer(options, (socket) => this.onConnection(socket));\n      } else {\n        const net = require('net');\n        this.server = net.createServer((socket) => this.onConnection(socket));\n      }\n\n      this.server.listen(this.port, this.host, () => {\n        this.state = 'running';\n        resolve();\n      });\n\n      this.server.on('error', (err) => {\n        this.state = 'stopped';\n        reject(err);\n      });\n    });\n  }\n\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'destroyed') {\n        reject(new Error('Server is already destroyed'));\n        return;\n      }\n\n      this.server.close((err) => {\n        if (err) {\n          reject(err);\n        } else {\n          this.state = 'destroyed';\n          resolve();\n        }\n      });\n    });\n  }\n\n  onConnection(socket) {\n    this.connections++;\n    this.sockets.push(socket);\n\n    socket.on('close', () => {\n      this.connections--;\n      const index = this.sockets.indexOf(socket);\n      if (index > -1) {\n        this.sockets.splice(index, 1);\n      }\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 155,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's 'net' module that can handle client connections, respond to incoming data, and manage server lifecycle events.\n\nClass Description: The Server class represents a TCP server that listens on a dynamically assigned port. It handles client connections, processes incoming data, and sends appropriate responses. The server can be started, stopped, and connections can be dropped.\n\nAttributes:\n- server: [Object] - The TCP server instance created using the 'net' module\n- socket: [Object] - The current client socket connection\n- response: [Buffer|Object] - The predefined response to send to clients (optional)\n\nMethods:\n- constructor(response) -> [Server] - Initializes a new Server instance with an optional response buffer/object\n- start(cb) -> [void] - Starts the server on a random available port and invokes the callback with connection details (host and port)\n- drop() -> [void] - Terminates the current client connection\n- close(cb) -> [void] - Stops the server and invokes the callback when complete",
    "Canonical_solution": "var net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = undefined;\n    this.socket = undefined;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server = net.createServer(\n      function(socket) {\n        this.socket = socket;\n        if (this.response) {\n          this.socket.on(\n            'data',\n            function(data) {\n              if (data.length == 8) {\n                this.socket.write(Buffer.from('N', 'utf8'));\n              } else if (!data[0]) {\n                this.socket.write(buffers.authenticationOk());\n              } else {\n                this.socket.write(this.response);\n              }\n            }.bind(this)\n          );\n        }\n      }.bind(this)\n    );\n\n    const host = 'localhost';\n    this.server.listen({ host, port: 0 }, () => {\n      const port = this.server.address().port;\n      cb({\n        host,\n        port,\n      });\n    });\n  }\n\n  drop() {\n    this.socket.destroy();\n  }\n\n  close(cb) {\n    this.server.close(cb);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = net.createServer();\n    this.socket = null;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server.listen(0, () => {\n      const { port } = this.server.address();\n      cb(`Server listening on port ${port}`);\n    });\n\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n      socket.on('data', (data) => {\n        if (this.response) {\n          socket.write(this.response);\n        }\n      });\n    });\n  }\n\n  drop() {\n    if (this.socket) {\n      this.socket.end();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    this.server.close(cb);\n  }\n}\n```"
  },
  {
    "Task_id": 159,
    "Instruction": "Task Description: Create a TCP server class that handles authentication requests for Git or SSH operations, generating dynamic listening paths and managing server lifecycle events.\n\nClass Description: The ResponseServer class is designed to create a TCP server that responds to authentication prompts from Git or SSH clients. It generates platform-specific listening paths, handles incoming connection requests, and provides appropriate authentication credentials based on the server type.\n\nAttributes:\n- auth: [Object] - Contains authentication credentials (username, password, passphrase)\n- serverType: [String] - Specifies the server type ('git' or 'ssh')\n\nMethods:\n- constructor(auth, serverType = 'git') -> [void] - Initializes the server with authentication credentials and server type\n- getListenPath() -> [String] - Generates a platform-specific listening path with a random component for security\n- start() -> [Promise<Object>] - Starts the TCP server and returns a promise that resolves to an object containing the listening path and a close method\n\nMethods Details:\n1. constructor(auth, serverType = 'git'):\n   - auth: [Object] - Authentication credentials object\n   - serverType: [String] - Type of server ('git' or 'ssh'), defaults to 'git'\n   - Returns: [void]\n\n2. getListenPath():\n   - Returns: [String] - Platform-specific listening path (Windows named pipe or Unix domain socket path)\n\n3. start():\n   - Returns: [Promise<Object>] - Resolves to an object with:\n     - path: [String] - The listening path\n     - close: [Function] - Method to close the server\n   - The promise may reject with an error if server startup fails",
    "Canonical_solution": "var net = require(\"net\");\nvar fs = require(\"fs-extra\");\nvar path = require(\"path\");\nvar os = require(\"os\");\nconst crypto = require(\"crypto\");\n\nclass ResponseServer {\n    constructor(auth, serverType = 'git') {\n        this.auth = auth;\n        this.serverType = serverType;\n    }\n\n    getListenPath() {\n        var seed = crypto.randomBytes(8).toString('hex');\n        var fn = 'node-red-git-askpass-'+seed+'-sock';\n        var listenPath;\n        if (process.platform === 'win32') {\n            listenPath = '\\\\\\\\.\\\\pipe\\\\'+fn;\n        } else {\n            listenPath = path.join(process.env['XDG_RUNTIME_DIR'] || os.tmpdir(), fn);\n        }\n        return listenPath;\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            var server = net.createServer((connection) => {\n                connection.setEncoding('utf8');\n                var parts = [];\n                connection.on('data', (data) => {\n                    var m = data.indexOf(\"\\n\");\n                    if (m !== -1) {\n                        parts.push(data.substring(0, m));\n                        data = data.substring(m);\n                        var line = parts.join(\"\");\n                        parts = [];\n                        if (this.serverType === 'git') {\n                            if (line === 'Username') {\n                                connection.end(this.auth.username);\n                            } else if (line === 'Password') {\n                                connection.end(this.auth.password);\n                                server.close();\n                            }\n                        } else if (this.serverType === 'ssh') {\n                            if (line === 'The') {\n                                connection.end('yes');\n                            } else if (line === 'Enter') {\n                                connection.end(this.auth.passphrase);\n                            }\n                        }\n                    }\n                    if (data.length > 0) {\n                        parts.push(data);\n                    }\n                });\n            });\n\n            var listenPath = this.getListenPath();\n\n            server.listen(listenPath, (ready) => {\n                resolve({\n                    path: listenPath,\n                    close: () => { server.close(); }\n                });\n            });\n\n            server.on('close', () => {\n                fs.removeSync(listenPath);\n            });\n\n            server.on('error', (err) => {\n                console.log(\"ResponseServer unexpectedError:\", err.toString());\n                server.close();\n                reject(err);\n            });\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```typescript\nclass ResponseServer {\n  auth: { username: string; password: string; passphrase: string };\n  serverType: 'git' | 'ssh';\n\n  constructor(auth: { username: string; password: string; passphrase: string }, serverType: 'git' | 'ssh' = 'git') {\n    this.auth = auth;\n    this.serverType = serverType;\n  }\n\n  getListenPath(): string {\n    if (process.platform === 'win32') {\n      return `\\\\\\\\.\\\\pipe\\\\${Math.random().toString(36).substring(2)}`;\n    } else {\n      return `/tmp/${Math.random().toString(36).substring(2)}`;\n    }\n  }\n\n  async start(): Promise<{ path: string; close: () => void }> {\n    const path = this.getListenPath();\n    // Start the server logic here, using the path and auth credentials\n    // Return a promise that resolves to an object with the path and a close method\n    return { path, close: () => {} };\n  }\n}\n```"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a class that handles HTTP requests with authentication and custom headers for a specific API service. The class should support both GET and POST methods, generate required authentication signatures, and handle request errors appropriately.\n\nClass Description: The TaskRequest class is designed to make authenticated HTTP requests to a specific API endpoint. It handles request signing, header generation, and error management. The class maintains authentication-related attributes and provides a method to execute requests.\n\nAttributes:\n- did: [String] - Device identifier used for authentication\n- finger: [String] - Fingerprint information for the request\n- token: [String] - Authentication token for API access\n- oaid: [String] - OAID (Open Anonymous Identification) for tracking\n\nMethods:\n- constructor(did, finger, token, oaid) -> [None] - Initializes the TaskRequest instance with authentication parameters\n- taskRequest(method, url, body) -> [Promise<Object>] - Executes an HTTP request with the specified method to the given URL, optionally with a request body. Returns the response data or throws an error if the request fails. The method handles request signing and header generation internally.\n\nInput:\n- method: [String] - HTTP method to use ('get' or 'post')\n- url: [String] - Target URL for the request\n- body: [String] (optional) - Request body for POST requests (default: empty string)\n\nOutput:\n- [Promise<Object>] - Resolves with the response data if the request succeeds\n- [Error] - Throws an error if the request fails",
    "Canonical_solution": "const axios = require('axios');\n\nclass TaskRequest {\n    constructor(did, finger, token, oaid) {\n        this.did = did;\n        this.finger = finger;\n        this.token = token;\n        this.oaid = oaid;\n    }\n\n    async taskRequest(method, url, body = \"\") {\n        let re = function (e) {\n            function convertObjectToQueryString(obj) {\n                let queryString = \"\";\n                if (obj) {\n                    const keys = Object.keys(obj).sort();\n                    keys.forEach(key => {\n                        const value = obj[key];\n                        if (value !== null && typeof value !== 'object') {\n                            queryString += `&${key}=${value}`;\n                        }\n                    });\n                }\n                return queryString.slice(1);\n            }\n            return convertObjectToQueryString(e)\n        }\n        \n        function v(e) {\n            const crypto = require(\"crypto\")\n            return crypto.createHash(\"md5\").update(e).digest(\"hex\")\n        }\n        \n        const g = {\n            traceid: v((new Date).getTime().toString() + Math.random().toString()),\n            noncestr: Math.random().toString().slice(2, 10),\n            timestamp: Date.now(),\n            platform: \"h5\",\n            did: this.did,\n            version: \"1.0.0\",\n            finger: this.finger,\n            token: this.token,\n            oaid: this.oaid,\n        }\n        \n        const c = \"\\u7c89\\u8c61\\u597d\\u725b\\u903ca8c19d8267527ea4c7d2f011acf7766f\"\n        let s = method === \"get\" ? void 0 : JSON.parse(body)\n        let e = void 0 === s ? {} : s\n        g.sign = v(re(e) + re(g) + c)\n        \n        let headers = {\n            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; MI 8 Lite Build/QKQ1.190910.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/80.0.3987.99 Mobile Safari/537.36 AgentWeb/5.0.0  UCBrowser/11.6.4.950',\n            'Accept': 'application/json, text/plain, */*',\n            'Accept-Encoding': 'gzip, deflate',\n            'Content-Type': 'application/json',\n            'origin': 'https://m.fenxianglife.com',\n            'sec-fetch-dest': 'empty',\n            'x-requested-with': 'com.n_add.android',\n            'sec-fetch-site': 'same-site',\n            'sec-fetch-mode': 'cors',\n            'referer': 'https://m.fenxianglife.com/h5-lottery/index.html?hideBack=1&sourceType=lottery_tab&token=030e7e9158af06dea2b3d0175a471ada&AppToken=96e06ae9f3cab6784de443015b8d9ad8&uid=515226607&v=5.4.3&did=njia992631e6-b9b2-4383-b67c-86b5d0fe818a&level=1&platform=android&timestamp=1717426249&channel=xiaomi&traFromId=23192687628924991393323633117947',\n            'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\n            \"Content-Type\": \"application/json\"\n        }\n        \n        Object.assign(headers, g)\n        \n        const reqeuestOptions = {\n            url: url,\n            method: method,\n            headers: headers,\n            data: body\n        }\n        \n        try {\n            const response = await axios(reqeuestOptions);\n            return response.data;\n        } catch (error) {\n            console.log('axios error', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass TaskRequest {\n  constructor(did, finger, token, oaid) {\n    this.did = did;\n    this.finger = finger;\n    this.token = token;\n    this.oaid = oaid;\n  }\n\n  async taskRequest(method, url, body = '') {\n    const headers = {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${this.token}`,\n      'X-Device-Id': this.did,\n      'X-Fingerprint': this.finger,\n      'X-OAID': this.oaid,\n    };\n\n    const options = {\n      method,\n      headers,\n      body: method === 'post' ? JSON.stringify(body) : null,\n    };\n\n    try {\n      const response = await fetch(url, options);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      throw new Error(`Request failed: ${error.message}`);\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a POP3 server class in Node.js that handles secure and non-secure connections, manages client connections, and provides event-driven communication.\n\nClass Description: The POP3Server class extends EventEmitter to create a TCP server that can handle both regular and TLS-secured POP3 connections. It manages client connections and emits events for server lifecycle and errors.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- connections: [Set] - Tracks active client connections\n- server: [net.Server|tls.Server] - The underlying TCP/TLS server instance\n\nMethods:\n- constructor(options) -> [void] - Initializes the server with optional configuration\n- _setListeners() -> [void] - Sets up event listeners for the server\n- _onListening() -> [void] - Handles the 'listening' event\n- _onClose() -> [void] - Handles the 'close' event\n- _onError(err) -> [void] - Handles the 'error' event\n- connect(socket, socketOptions) -> [void] - Creates and manages a new client connection\n- listen(...args) -> [void] - Starts the server listening on specified port\n- close(callback) -> [void] - Stops the server and invokes callback when closed",
    "Canonical_solution": "const EventEmitter = require('events');\nconst net = require('net');\nconst tls = require('tls');\n\nclass POP3Server extends EventEmitter {\n    constructor(options) {\n        super();\n\n        this.options = options || {};\n        this.connections = new Set();\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    this.connect(socket, socketOptions);\n                });\n            });\n        }\n\n        this._setListeners();\n    }\n\n    _setListeners() {\n        this.server.on('listening', () => this._onListening());\n        this.server.on('close', () => this._onClose());\n        this.server.on('error', err => this._onError(err));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new POP3Connection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.once('error', err => {\n            this.connections.delete(connection);\n            this._onError(err);\n        });\n        connection.once('close', () => {\n            this.connections.delete(connection);\n        });\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            if (typeof callback === 'function') {\n                return callback();\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options || {};\n    this.connections = new Set();\n    this.server = null;\n    this._setListeners();\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    const client = new POP3Client(socket, socketOptions);\n    this.connections.add(client);\n    client.on('close', () => this.connections.delete(client));\n    this.emit('connection', client);\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options, this.connect.bind(this));\n    } else {\n      this.server = net.createServer(this.connect.bind(this));\n    }\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n```\n"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a TCP server connector class in JavaScript using Node.js's 'net' module that handles server creation, connection events, and lifecycle management.\n\nClass Description: The Connector class is an EventEmitter that creates and manages a TCP server. It handles server connections, errors, and provides methods to start and stop the server.\n\nAttributes:\n- opts: [Object] - Optional configuration options for the server\n- host: [String] - The host address the server will bind to\n- port: [Number] - The port number the server will listen on\n- tcpServer: [Object] - The underlying TCP server instance\n\nMethods:\n- constructor: [Connector](port, host, opts) -> [Connector] - Initializes a new Connector instance with specified port, host, and options\n- start: [start](cb) -> [undefined] - Starts the TCP server and sets up connection and error event handlers. Calls the callback when server is ready\n- stop: [stop](force, cb) -> [undefined] - Stops the TCP server and calls the callback when complete. The force parameter determines whether to force close connections",
    "Canonical_solution": "var net = require('net');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nvar Connector = function(port, host, opts) {\n  if (!(this instanceof Connector)) {\n    return new Connector(port, host, opts);\n  }\n\n  EventEmitter.call(this);\n  this.opts = opts || {};\n  this.host = host;\n  this.port = port;\n};\n\nutil.inherits(Connector, EventEmitter);\n\nConnector.prototype.start = function(cb) {\n  var self = this;\n  this.tcpServer = net.createServer();\n  \n  this.tcpServer.on('connection', function(socket) {\n    self.emit('connection', socket);\n  });\n\n  this.tcpServer.on('error', function(err) {\n    self.emit('error', err);\n  });\n\n  this.tcpServer.listen(this.port, this.host);\n  process.nextTick(cb);\n};\n\nConnector.prototype.stop = function(force, cb) {\n  this.tcpServer.close();\n  process.nextTick(cb);\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\n\nclass Connector extends EventEmitter {\n  constructor(port, host, opts) {\n    super();\n    this.opts = opts || {};\n    this.host = host || 'localhost';\n    this.port = port;\n    this.tcpServer = net.createServer(this.opts);\n  }\n\n  start(cb) {\n    this.tcpServer.listen(this.port, this.host, () => {\n      this.tcpServer.on('connection', (socket) => {\n        this.emit('connection', socket);\n      });\n\n      this.tcpServer.on('error', (err) => {\n        this.emit('error', err);\n      });\n\n      cb();\n    });\n  }\n\n  stop(force, cb) {\n    this.tcpServer.close((err) => {\n      if (err) {\n        this.emit('error', err);\n      }\n\n      if (force) {\n        this.tcpServer.getConnections((err, count) => {\n          if (err) {\n            this.emit('error', err);\n          }\n\n          for (let i = 0; i < count; i++) {\n            this.tcpServer.close();\n          }\n        });\n      }\n\n      cb();\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 167,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's 'net' module to listen for incoming connections, handle client messages, and emit events for commands received.\n\nClass Description: TCPListener is a class that creates a TCP server to listen for incoming connections on a specified port. It handles client connections, processes incoming data, and emits events when commands are received. The class extends Node.js's EventEmitter to provide event-driven functionality.\n\nAttributes:\n- port: [Number] - The port number on which the TCP server will listen\n- server: [Object] - The TCP server instance created by the 'net' module\n\nMethods:\n- constructor(port) -> [TCPListener] - Initializes the TCPListener instance with the specified port\n- start() -> [void] - Creates and starts the TCP server, sets up event handlers for client connections, data reception, and errors. Emits 'command' events when valid messages are received and 'log' events for server status updates\n\nThe class emits the following events:\n- 'command': (command, params, options, callback) - Emitted when a valid command message is received from a client\n- 'log': (message) - Emitted for logging server status and errors",
    "Canonical_solution": "var events = require('events');\nvar net = require('net');\n\nclass TCPListener {\n    constructor(port) {\n        this.port = port;\n        this.server = null;\n    }\n\n    start() {\n        this.server = net.createServer((c) => {\n            var data = '';\n            try {\n                c.on('data', (d) => {\n                    data += d;\n                    if (data.slice(-1) === '\\n') {\n                        var message = JSON.parse(data);\n                        this.emit('command', message.command, message.params, message.options, (message) => {\n                            c.end(message);\n                        });\n                    }\n                });\n                c.on('end', () => {});\n                c.on('error', () => {});\n            }\n            catch(e) {\n                this.emit('log', 'CLI listener failed to parse message ' + data);\n            }\n        }).listen(this.port, '127.0.0.1', () => {\n            this.emit('log', 'CLI listening on port ' + this.port);\n        });\n    }\n}\n\nTCPListener.prototype.__proto__ = events.EventEmitter.prototype;",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\n\nclass TCPListener extends require('events').EventEmitter {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server = net.createServer();\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      this.emit('log', `Server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', (socket) => {\n      this.emit('log', 'Client connected');\n      socket.on('data', (data) => {\n        const message = data.toString().trim();\n        const [command, ...params] = message.split(' ');\n        const options = {};\n        const callback = (err, result) => {\n          socket.write(JSON.stringify({ err, result }));\n        };\n        this.emit('command', command, params, options, callback);\n      });\n      socket.on('end', () => {\n        this.emit('log', 'Client disconnected');\n      });\n    });\n\n    this.server.on('error', (err) => {\n      this.emit('log', `Server error: ${err.message}`);\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 168,
    "Instruction": "Task Description: Create a TCP server using Node.js's `net` module to handle client connections and manage sessions with unique identifiers, while optionally supporting weak references for garbage collection.\n\nClass Description: The `DNodeServer` class is a TCP server implementation that manages client connections, assigns unique session IDs, and provides event-based interaction with connected clients. It supports optional weak reference handling for callbacks to prevent memory leaks.\n\nAttributes:\n- cons: [Function] - The constructor or function to be called for each new connection.\n- opts: [Object] - Configuration options for the server, including weak reference settings.\n- server: [net.Server] - The underlying TCP server instance.\n- server.sessions: [Object] - Dictionary of active sessions indexed by session IDs.\n\nMethods:\n- constructor(cons, opts) -> [DNodeServer] - Initializes the server with a connection handler and options. Sets up weak reference handling if enabled.\n- _handleConnection(stream) -> [void] - Handles new client connections, creates session with unique ID, and sets up data piping and event forwarding.\n- listen(port, host, callback) -> [net.Server] - Starts the server listening on specified port/host or UNIX socket path. Accepts optional callback for 'listening' event.\n- _randomId() -> [string] - Generates a random 16-character hexadecimal string for session identification.\n\nInput:\n- cons: [Function] - Required connection handler function\n- opts: [Object] - Optional configuration object (may contain 'weak' and 'proto' properties)\n- port: [number|string] - Port number or UNIX socket path to listen on\n- host: [string] - Optional hostname to bind to\n- callback: [Function] - Optional callback for listening event\n\nOutput:\n- Instance of DNodeServer when constructed\n- Instance of net.Server when calling listen()",
    "Canonical_solution": "var dnode = require('./lib/dnode');\nvar net = require('net');\nvar weak;\n\nclass DNodeServer {\n    constructor(cons, opts) {\n        if (!opts) opts = {};\n        \n        if (opts.weak !== false && !opts.proto) {\n            if (!weak) {\n                weak = require(\"weak\");\n            }\n            \n            opts.proto = {};\n            opts.proto.wrap = function (cb, id) {\n                var proto = this;\n                return weak(cb, function () {\n                    proto.cull(id);\n                });\n            };\n            opts.proto.unwrap = function (ref, id) {\n                var cb = weak.get(ref);\n                return cb || function () {};\n            };\n        }\n        \n        this.cons = cons;\n        this.opts = opts;\n        this.server = net.createServer(this._handleConnection.bind(this));\n        this.server.sessions = {};\n    }\n\n    _handleConnection(stream) {\n        var d = new dnode(this.cons, this.opts);\n        do { d.id = this._randomId(); }\n        while (this.server.sessions[d.id]);\n        \n        this.server.sessions[d.id] = d;\n        d.on('end', () => {\n            delete this.server.sessions[d.id];\n        });\n        \n        d.on('local', (ref) => {\n            this.server.emit('local', ref, d);\n        });\n        \n        d.on('remote', (remote) => {\n            this.server.emit('remote', remote, d);\n        });\n        \n        stream.on('error', (err) => {\n            if (err && err.code === 'EPIPE') return;\n            d.emit('error', err);\n        });\n        \n        d.stream = stream;\n        stream.pipe(d);\n        d.pipe(stream);\n    }\n\n    listen(port, host, callback) {\n        if (typeof port === 'number' && port >= 0) {\n            this.server.listen(port, host);\n        } else if (typeof port === 'string') {\n            this.server.listen(port);\n        } else {\n            throw new Error('no port or path provided');\n        }\n        \n        if (callback) {\n            this.server.on('listening', callback);\n        }\n        \n        return this.server;\n    }\n\n    _randomId() {\n        var s = '';\n        for (var i = 0; i < 4; i++) {\n            s += Math.random().toString(16).slice(2);\n        }\n        return s;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nclass DNodeServer {\n  constructor(cons, opts) {\n    this.cons = cons;\n    this.opts = opts || {};\n    this.server = new net.Server();\n    this.server.sessions = {};\n    if (this.opts.weak) {\n      this.server.on('connection', this._handleConnection.bind(this));\n    }\n  }\n\n  _handleConnection(stream) {\n    const id = this._randomId();\n    const session = { id, stream };\n    this.server.sessions[id] = session;\n    const conn = this.cons(session);\n    conn.on('close', () => {\n      delete this.server.sessions[id];\n    });\n    if (!this.opts.weak) {\n      stream.pipe(conn).pipe(stream);\n    }\n  }\n\n  listen(port, host, callback) {\n    return this.server.listen(port, host, callback);\n  }\n\n  _randomId() {\n    return crypto.randomBytes(8).toString('hex');\n  }\n}\n```\n"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a class that provides wallpaper retrieval functionality from different APIs (Unsplash or Bing) based on client availability.\n\nClass Description: The WallpaperService class is designed to fetch random wallpapers from either Unsplash (if an API key is provided) or Bing's wallpaper API (as a fallback). It handles API requests, processes responses, and provides a consistent output format regardless of the source.\n\nAttributes: None (This is a static service class with no instance attributes)\n\nMethods:\ngetWallpaper: static async getWallpaper(unsplashClientId: string) -> Promise<Object> - Fetches a random wallpaper from either Unsplash or Bing. \n  - Input: \n    - unsplashClientId: string - The API client ID for Unsplash (optional, if not provided will use Bing)\n  - Output: \n    - Returns a Promise that resolves to an object with:\n      - type: string - Indicates the source ('unsplash' or 'bing')\n      - data: Array/Object - Contains the wallpaper data in the respective API's format\n    - On error, returns a fallback Bing wallpaper object with a default image",
    "Canonical_solution": "const axios = require('axios');\n\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    const wallpaperAPI = unsplashClientId\n      ? 'https://api.unsplash.com/photos/random?orientation=landscape&count=1&client_id=' + unsplashClientId\n      : 'https://cn.bing.com/HPImageArchive.aspx?format=js&n=1';\n\n    try {\n      const res = await axios.get(wallpaperAPI);\n      return unsplashClientId\n        ? { type: 'unsplash', data: res.data }\n        : { type: 'bing', data: res.data.images };\n    } catch (error) {\n      return {\n        type: 'bing',\n        data: [{\n          url: '/az/hprichbg/rb/SWFC_ZH-CN9558503653_1920x1080.jpg',\n          copyrightlink: '/search?q=%e4%b8%8a%e6%b5%b7%e4%b8%96%e7%95%8c%e9%87%91%e8%9e%8d%e4%b8%ad%e5%bf%83&form=hpcapt&mkt=zh-cn'\n        }]\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```typescript\nimport axios from 'axios';\n\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId?: string): Promise<Object> {\n    try {\n      if (unsplashClientId) {\n        const response = await axios.get(`https://api.unsplash.com/photos/random?client_id=${unsplashClientId}`);\n        return {\n          type: 'unsplash',\n          data: response.data\n        };\n      } else {\n        const response = await axios.get('https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1&mkt=en-US');\n        const imageUrl = `https://www.bing.com${response.data.images[0].url}`;\n        return {\n          type: 'bing',\n          data: {\n            url: imageUrl\n          }\n        };\n      }\n    } catch (error) {\n      console.error('Error fetching wallpaper:', error);\n      return {\n        type: 'bing',\n        data: {\n          url: 'https://www.bing.com/th?id=OIP.5QYXZJrQY5YJZQYJZQYJZQHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHa"
  },
  {
    "Task_id": 176,
    "Instruction": "Task Description: Create a TCP server class that intercepts Redis traffic, capable of operating in different modes (capture, test, or forward), with functionality to save, mock, or forward data between client and Redis server.\n\nClass Description: RedisInterceptor is a class that creates a TCP server to intercept Redis protocol traffic. It can operate in three modes: capture (save request/response pairs), test (respond with mocked data), or forward (pass through traffic unchanged). The class handles client connections, data forwarding, and response processing.\n\nAttributes:\n- Pythagora: [Object] - Reference to the parent Pythagora object for saving captured data\n- listenPort: [Number] - Port number on which the interceptor listens for client connections\n- targetPort: [Number] - Port number of the target Redis server (default: 6379)\n- intermediateData: [Array] - Array containing mocked request/response pairs for test mode\n- listenSocket: [Object] - Reference to the net.Server instance\n- targetSocket: [Object] - Reference to the net.Socket connection to Redis\n- mode: [String] - Current operation mode ('capture', 'test', or undefined for forward)\n\nMethods:\n- constructor(Pythagora, listenPort, targetPort, intermediateData) -> [RedisInterceptor] - Initializes the interceptor with configuration parameters\n- init() -> [Promise] - Asynchronously creates and starts the TCP server, resolving when listening\n- forwardData(connection, data, saveData) -> [undefined] - Forwards data to Redis server and handles response, optionally saving it\n- splitIntoChunks(str, chunkSize) -> [Array] - Helper method to split strings into chunks of specified size\n\nNote: The class assumes the existence of constants MODES (for operation modes) and CHUNK_SIZE (for response chunking) which should be defined elsewhere in the code.",
    "Canonical_solution": "const net = require('net');\n\nclass RedisInterceptor {\n    constructor(Pythagora, listenPort, targetPort, intermediateData) {\n        this.Pythagora = Pythagora;\n        this.listenPort = listenPort;\n        this.targetPort = targetPort || 6379;\n        this.intermediateData = intermediateData || [];\n    }\n\n    async init() {\n        await new Promise((resolve, reject) => {\n            this.listenSocket = net.createServer(connection => {\n                connection.on('data', data => {\n                    if (this.mode === MODES.capture) {\n                        this.forwardData(connection, data, true);\n                    } else if (this.mode === 'test') {\n                        let mockData = this.intermediateData.find(d => d.type === 'redis' && d.request === data.toString());\n                        if (mockData) {\n                            const chunks = this.splitIntoChunks(mockData.response, CHUNK_SIZE);\n                            chunks.forEach(chunk => connection.write(`+${chunk}\\r\\n`, 'utf8'));\n                        } else {\n                            this.forwardData(connection, data);\n                        }\n                    } else {\n                        this.forwardData(connection, data);\n                    }\n                });\n            });\n\n            this.listenSocket.listen(this.listenPort, () => {\n                resolve();\n            });\n        });\n    }\n\n    forwardData(connection, data, saveData) {\n        this.targetSocket = new net.Socket();\n        this.targetSocket.connect(this.targetPort, 'localhost', () => {\n            this.targetSocket.write(data);\n        });\n\n        this.targetSocket.on('data', response => {\n            if (saveData) Pythagora.saveRedisData(data.toString(), response.toString().replace(/^.*\\r\\n/, '').replace(/\\r\\n$/, ''));\n            connection.write(response);\n        });\n    }\n\n    splitIntoChunks(str, chunkSize) {\n        const chunks = [];\n        for (let i = 0; i < str.length; i += chunkSize) {\n            chunks.push(str.substring(i, i + chunkSize));\n        }\n        return chunks;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nclass RedisInterceptor {\n  constructor(Pythagora, listenPort, targetPort, intermediateData) {\n    this.Pythagora = Pythagora;\n    this.listenPort = listenPort;\n    this.targetPort = targetPort || 6379;\n    this.intermediateData = intermediateData;\n    this.listenSocket = null;\n    this.targetSocket = null;\n    this.mode = undefined;\n  }\n\n  async init() {\n    this.listenSocket = net.createServer();\n    this.listenSocket.on('connection', this.handleClientConnection.bind(this));\n    return new Promise((resolve, reject) => {\n      this.listenSocket.listen(this.listenPort, () => {\n        resolve();\n      });\n    });\n  }\n\n  handleClientConnection(connection) {\n    connection.on('data', (data) => {\n      this.forwardData(connection, data, true);\n    });\n    connection.on('end', () => {\n      if (this.targetSocket) {\n        this.targetSocket.end();\n      }\n    });\n  }\n\n  forwardData(connection, data, saveData) {\n    if (!this.targetSocket) {\n      this.targetSocket = net.createConnection(this.targetPort);\n      this.targetSocket.on('data', (data) => {\n        this.handleTargetResponse(connection, data, saveData);\n      });\n      this.targetSocket.on('end', () => {\n        connection.end();\n      });\n    }\n    this.targetSocket.write(data);\n  }\n\n  handleTargetResponse(connection, data, saveData) {\n    if (this.mode === MODES.CAPTURE && saveData) {\n      this.Pythagora.saveData(data);\n    }\n    if (this.mode === MODES.TEST) {\n      const chunkSize = CHUNK_SIZE;\n      const chunks = this.splitIntoChunks(data.toString(), chunkSize);\n      for (let chunk of chunks) {\n        connection.write(chunk);\n      }\n    } else {\n      connection.write(data);\n    }\n  }\n\n  splitIntoChunks(str, chunkSize) {\n    const chunks = [];\n    for (let i = 0; i < str.length; i += chunkSize) {\n      chunks.push(str.substr(i, chunkSize));\n    }\n    return chunks;\n  }\n}\n```"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Write a function that fetches version information and schema data from a remote API, caches the results locally, and handles errors appropriately.\n\nFunction Description: The function `fetchAndCacheVersions` retrieves version data from a specified API endpoint, then fetches schema data for each non-deprecated version. It caches all retrieved data in JSON files in a local directory. Errors during the process are caught and logged, with the process exiting on failure.\n\nInput: None (The function takes no parameters; all URLs and paths are hardcoded)\n\nOutput: \n- Success: Writes JSON files to the cache directory and logs success messages\n- Failure: Logs error messages and exits the process with status code 1",
    "Canonical_solution": "function fetchAndCacheVersions() {\n    const axios = require('axios');\n    const { writeJsonSync } = require('fs-extra');\n    const path = require('path');\n\n    axios\n        .get('https://exp.host/--/versions')\n        .then(async ({ data }) => {\n            writeJsonSync(path.join(__dirname, '../caches/versions.json'), data);\n\n            for (const version of Object.keys(data.sdkVersions)) {\n                if (data.sdkVersions[version].isDeprecated) {\n                    continue;\n                }\n                const {\n                    data: { data: schema },\n                } = await axios.get(`https://exp.host/--/api/v2/project/configuration/schema/${version}`);\n\n                const filePath = path.join(__dirname, `../caches/schema-${version}.json`);\n                console.log('Writing', filePath);\n                writeJsonSync(filePath, schema);\n            }\n        })\n        .then(() => console.log('Caches updated.'))\n        .catch(error => {\n            console.error(error);\n            console.error('Updating caches failed.');\n            process.exit(1);\n        });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst fs = require('fs');\nconst path = require('path');\nconst fetch = require('node-fetch');\n\nconst API_URL = 'https://example.com/api/versions';\nconst CACHE_DIR = './cache';\n\nasync function fetchAndCacheVersions() {\n  try {\n    // Fetch version data from the API\n    const response = await fetch(API_URL);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch versions: ${response.statusText}`);\n    }\n    const versions = await response.json();\n\n    // Create cache directory if it doesn't exist\n    if (!fs.existsSync(CACHE_DIR)) {\n      fs.mkdirSync(CACHE_DIR);\n    }\n\n    // Fetch schema data for each version and cache it\n    for (const version of versions) {\n      if (!version.deprecated) {\n        const schemaUrl = `${API_URL}/${version.id}/schema`;\n        const schemaResponse = await fetch(schemaUrl);\n        if (!schemaResponse.ok) {\n          throw new Error(`Failed to fetch schema for version ${version.id}: ${schemaResponse.statusText}`);\n        }\n        const schema = await schemaResponse.json();\n\n        const cachePath = path.join(CACHE_DIR, `${version.id}.json`);\n        fs.writeFileSync(cachePath, JSON.stringify(schema, null, 2));\n        console.log(`Cached schema for version ${version.id}`);\n      }\n    }\n\n    console.log('All versions cached successfully');\n  } catch (error) {\n    console.error(`Error: ${error.message}`);\n    process.exit(1);\n  }\n}\n\nfetchAndCacheVersions();\n```"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a Flash Policy Server class in JavaScript using Node.js's net module to handle cross-domain policy requests for socket connections.\n\nClass Description: The FlashPolicyServer class creates a TCP server that responds to Flash socket policy requests. It manages allowed origins/ports, compiles the XML policy file, and handles server lifecycle events.\n\nAttributes:\n- origins: [Array] - List of allowed domain:port combinations\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [Object] - TCP server instance\n- buffer: [Buffer] - Compiled policy file in binary format\n- server: [Object] - Optional existing server instance to attach to\n\nMethods:\n- constructor(options, origins) -> [FlashPolicyServer] - Initializes the server with options and allowed origins\n- listen(port, server, cb) -> [FlashPolicyServer] - Starts listening on specified port, optionally attaching to existing server\n- responder(socket) -> [void] - Responds to policy requests on a socket connection\n- compile() -> [FlashPolicyServer] - Generates the XML policy buffer from allowed origins\n- add() -> [FlashPolicyServer] - Adds new allowed origins to the policy\n- remove(origin) -> [FlashPolicyServer] - Removes an origin from the allowed list\n- close() -> [FlashPolicyServer] - Stops the server and cleans up listeners",
    "Canonical_solution": "var net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => this.responder(socket));\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges.'\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (data && data[0] === 60 && data.toString() === '<policy-file-request/>\\0' &&\n              socket && (socket.readyState === 'open' || socket.readyState === 'writeOnly')) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    this.port >= 0 && this.socket.listen(this.port, () => {\n      this.socket.online = true;\n      if (callback) {\n        callback.call(this);\n        callback = undefined;\n      }\n    });\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = new Buffer(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options && options.port || 843;\n    this.log = options && options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options && options.server;\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    this.port = port || this.port;\n    this.server = server || this.server;\n    this.socket = this.server || net.createServer();\n    this.socket.on('connection', this.responder.bind(this));\n    this.socket.listen(this.port, cb);\n    this.log(`Policy server listening on port ${this.port}`);\n    return this;\n  }\n\n  responder(socket) {\n    socket.write(this.buffer);\n    socket.end();\n  }\n\n  compile() {\n    const xml = `<?xml version=\"1.0\"?><!DOCTYPE cross-domain-policy SYSTEM \"http://www.adobe.com/xml/dtds/cross-domain-policy.dtd\"><cross-domain-policy>`;\n    this.origins.forEach(origin => {\n      xml += `<allow-access-from domain=\"${origin}\" to-ports=\"${this.port}\"/>`;\n    });\n    xml += '</cross-domain-policy>';\n    this.buffer = Buffer.from(xml, 'utf-8');\n    return this;\n  }\n\n  add(origins) {\n    this.origins = this.origins.concat(origins);\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    this.origins = this.origins.filter(o => o !== origin);\n    this.compile();\n    return this;\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n      this.log('Policy server closed');\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 186,
    "Instruction": "Task Description: Create a UDP communication class in JavaScript using Node.js's dgram module for bidirectional message handling between processes.\n\nClass Description: The Udp class facilitates UDP-based communication with capabilities for both sending and receiving messages. It manages socket creation, port binding, message queuing, and event handling for network communication.\n\nAttributes:\n- stack: [Array] - Stores outgoing messages in a queue before sending\n- port: [Number|null] - The target port number for outgoing messages\n- socket: [dgram.Socket|null] - UDP socket instance for sending messages\n- listener: [dgram.Socket|null] - UDP socket instance for receiving messages\n- client: [Object] - Reference to the parent client object for message handling\n\nMethods:\n- constructor(client) -> [void] - Initializes the UDP instance with a client reference and creates socket objects\n- start() -> [void] - Begins UDP communication by setting up input and output sockets\n- clear() -> [void] - Clears the message queue\n- run() -> [void] - Processes all messages in the queue\n- push(msg) -> [void] - Adds a message to the outgoing queue (Input: msg [String] - Message to send)\n- play(data) -> [void] - Sends a single message via UDP (Input: data [String] - Message content)\n- selectOutput(port=49161) -> [void] - Configures the output port (Input: port [Number] - Target port number)\n- selectInput(port=49160) -> [void] - Configures and starts the input listener (Input: port [Number] - Listening port number)",
    "Canonical_solution": "const dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = dgram ? dgram.createSocket('udp4') : null;\n    this.listener = dgram ? dgram.createSocket('udp4') : null;\n    this.client = client;\n  }\n\n  start() {\n    if (!dgram || !this.socket || !this.listener) { \n      console.warn('UDP', 'Could not start.'); \n      return; \n    }\n    console.info('UDP', 'Starting..');\n\n    this.selectInput();\n    this.selectOutput();\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    for (const item of this.stack) {\n      this.play(item);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (!this.socket) { return; }\n    this.socket.send(Buffer.from(`${data}`), this.port, this.client.io.ip, (err) => {\n      if (err) { console.warn(err); }\n    });\n  }\n\n  selectOutput(port = 49161) {\n    if (!dgram) { console.warn('UDP', 'Unavailable.'); return; }\n    if (parseInt(port) === this.port) { console.warn('UDP', 'Already selected'); return; }\n    if (isNaN(port) || port < 1000) { console.warn('UDP', 'Unavailable port'); return; }\n\n    console.log('UDP', `Output: ${port}`);\n    this.port = parseInt(port);\n  }\n\n  selectInput(port = 49160) {\n    if (!dgram) { console.warn('UDP', 'Unavailable.'); return; }\n    if (this.listener) { this.listener.close(); }\n\n    console.log('UDP', `Input: ${port}`);\n    this.listener = dgram.createSocket('udp4');\n\n    this.listener.on('message', (msg, rinfo) => {\n      this.client.commander.trigger(`${msg}`);\n    });\n\n    this.listener.on('listening', () => {\n      const address = this.listener.address();\n      console.info('UDP', `Started socket at ${address.address}:${address.port}`);\n    });\n\n    this.listener.on('error', (err) => {\n      console.warn('UDP', `Server error:\\n ${err.stack}`);\n      this.listener.close();\n    });\n\n    this.listener.bind(port);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "wrong_result": "```javascript\nconst dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = null;\n    this.listener = null;\n    this.client = client;\n  }\n\n  start() {\n    this.socket = dgram.createSocket('udp4');\n    this.listener = dgram.createSocket('udp4');\n    this.selectOutput();\n    this.selectInput();\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    while (this.stack.length > 0) {\n      const msg = this.stack.shift();\n      this.play(msg);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    this.socket.send(data, 0, data.length, this.port, 'localhost');\n  }\n\n  selectOutput(port = 49161) {\n    this.port = port;\n  }\n\n  selectInput(port = 49160) {\n    this.listener.bind(port);\n    this.listener.on('message', (msg, rinfo) => {\n      this.client.handleMessage(msg.toString());\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 188,
    "Instruction": "Task Description: Create a UDP-based poller class in JavaScript that can send ping messages to a target UDP server and handle pong responses, with timeout functionality.\n\nClass Description: The UdpPoller class is designed to monitor UDP servers by sending periodic ping messages and listening for pong responses. It inherits from a base poller class and implements UDP communication using Node.js's dgram module.\n\nAttributes:\n- udpServer: [Object] - The UDP socket instance created using dgram module\n- target: [Object/String] - The target server address and port (parsed from input URL)\n- timeout: [Number] - The maximum time to wait for a response before timing out\n- callback: [Function] - The callback function to be executed when a response is received or an error occurs\n\nMethods:\n- constructor(target, timeout, callback) -> [void] - Initializes the poller with target, timeout, and callback\n- static get type() -> [String] - Returns the poller type ('udp')\n- static validateTarget(target) -> [Boolean] - Validates if the target URL matches UDP format\n- initialize() -> [void] - Sets up the UDP socket and parses the target address\n- poll() -> [void] - Sends a ping message to the target server and sets up response listener\n- onResponseCallback(message, sender) -> [void] - Handles incoming messages and processes pong responses\n- timeoutReached() -> [void] - Cleans up socket listeners when timeout occurs",
    "Canonical_solution": "var util = require('util');\nvar dgram = require('dgram');\nvar BasePoller = require('../basePoller');\n\nclass UdpPoller {\n  constructor(target, timeout, callback) {\n    UdpPoller.super_.call(this, target, timeout, callback);\n    this.udpServer = null;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    var reg = new RegExp('udp:\\/\\/(.*):(\\\\d{1,5})');\n    return reg.test(target);\n  }\n\n  initialize() {\n    this.udpServer = dgram.createSocket('udp4');\n    this.udpServer.bind();\n    this.udpServer.on('error', function() {});\n    \n    var reg = new RegExp('udp:\\/\\/(.*):(\\\\d{1,5})');\n    if(!reg.test(this.target)) {\n      console.log(this.target + ' does not seems to be valid udp url');\n    }\n    var host = reg.exec(this.target);\n    this.target = {\n      'address': host[1],\n      'port': host[2]\n    };\n  }\n\n  poll() {\n    var ping = new Buffer(JSON.stringify({'command': 'ping'}));\n    this.udpServer.send(ping, 0, ping.length, this.target.port, this.target.address);\n    this.udpServer.on(\"message\", this.onResponseCallback.bind(this));\n  }\n\n  onResponseCallback(message, sender) {\n    var cmd;\n    try {\n      cmd = JSON.parse(message);\n    } catch (e) {\n      return this.onErrorCallback({ name: \"Unparsable answer\", message: \"server return answer \" + message.toString()});\n    }\n    if (cmd.command === 'pong') {\n      this.timer.stop();\n      this.callback(null, this.getTime(), cmd);\n    }\n  }\n\n  timeoutReached() {\n    this.udpServer.removeAllListeners();\n  }\n}\n\nutil.inherits(UdpPoller, BasePoller);",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "wrong_result": "```javascript\nclass UdpPoller extends Poller {\n  constructor(target, timeout, callback) {\n    super(target, timeout, callback);\n    this.udpServer = dgram.createSocket('udp4');\n    this.target = this.parseTarget(target);\n    this.timeout = timeout;\n    this.callback = callback;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    const url = new URL(target);\n    return url.protocol === 'udp:';\n  }\n\n  initialize() {\n    this.udpServer.on('message', this.onResponseCallback.bind(this));\n    this.udpServer.on('error', this.callback);\n    this.udpServer.bind();\n  }\n\n  poll() {\n    const message = Buffer.from('ping');\n    this.udpServer.send(message, 0, message.length, this.target.port, this.target.address, (err) => {\n      if (err) {\n        this.callback(err);\n      }\n    });\n    setTimeout(this.timeoutReached.bind(this), this.timeout);\n  }\n\n  onResponseCallback(message, sender) {\n    if (sender.address === this.target.address && sender.port === this.target.port) {\n      this.callback(null, message.toString());\n    }\n  }\n\n  timeoutReached() {\n    this.udpServer.removeAllListeners('message');\n    this.udpServer.close();\n    this.callback(new Error('Timeout reached'));\n  }\n}\n```"
  },
  {
    "Task_id": 189,
    "Instruction": "Task Description: Create a class that implements inter-process communication (IPC) using UDP sockets in Node.js, allowing communication between a master process and worker processes.\n\nClass Description: The MasterIPC class facilitates communication between a master process and worker processes using UDP sockets. It handles socket creation, message parsing, method invocation, and event emission for worker connections and restarts.\n\nAttributes:\n- options: [Object] - Configuration options including socket port and address.\n- _sock: [dgram.Socket] - The UDP socket instance for communication.\n- children: [Array] - List of connected worker processes.\n- sock: [dgram.Socket] - Alternative socket reference used for sending messages.\n\nMethods:\n- IPCSocket() -> [dgram.Socket] - Creates and configures a UDP socket if not already created, setting up message event handling.\n- setupIPC() -> [void] - Binds the socket to the specified port and address, emits 'start' event when listening.\n- call(id, method, ...args) -> [void] - Sends a message to a worker process with the specified ID, method, and arguments.\n- invoke(method, args, worker) -> [void] - Invokes the specified method with given arguments and worker context if the method exists.\n- connect(worker) -> [void] - Emits a 'worker connected' event for the specified worker.\n- connectMaster(sig) -> [void] - Kills the parent process with the specified signal, either immediately or after the socket is listening.\n- masterKilled(data) -> [void] - Emits a 'restart' event with the provided data.",
    "Canonical_solution": "var dgram = require('dgram');\nvar net = require('net');\nvar utils = require('./utils');\n\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n  }\n\n  IPCSocket() {\n    var self = this;\n    if (this._sock) return this._sock;\n    \n    this._sock = dgram.createSocket('udp4');\n    this._sock.on('message', function(msg, info) {\n      try {\n        msg = JSON.parse(msg.toString('ascii'));\n        self.invoke(msg.method, msg.args, self.children[msg.id]);\n      } catch (err) {\n        console.error(err.stack || String(err));\n      }\n    });\n    return this._sock;\n  }\n\n  setupIPC() {\n    var self = this;\n    this.IPCSocket().on('listening', function() {\n      process.nextTick(function() {\n        self.emit('start');\n      });\n    });\n    this.IPCSocket().bind(\n      this.options['socket port'],\n      this.options['socket addr']\n    );\n  }\n\n  call(id, method) {\n    this.sock = this.sock || dgram.createSocket('udp4');\n    var msg = new Buffer(utils.frame({\n      args: utils.toArray(arguments, 2),\n      method: method,\n      id: id\n    }));\n    this.sock.send(\n      msg,\n      0,\n      msg.length,\n      this.options['socket port'],\n      this.options['socket addr']\n    );\n  }\n\n  invoke(method, args, worker) {\n    if (this[method]) {\n      this[method].apply(this, args.concat(worker));\n    }\n  }\n\n  connect(worker) {\n    this.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    var self = this;\n    function kill() {\n      process.kill(self.ppid, sig);\n    }\n    if (this.listening) return kill();\n    this.on('listening', kill);\n  }\n\n  masterKilled(data) {\n    this.emit('restart', data);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "wrong_result": "```javascript\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n    this.sock = null;\n  }\n\n  IPCSocket() {\n    if (!this._sock) {\n      this._sock = dgram.createSocket('udp4');\n      this._sock.on('message', this.onMessage.bind(this));\n    }\n    return this._sock;\n  }\n\n  setupIPC() {\n    this.sock = this.IPCSocket();\n    this.sock.bind(this.options.port, this.options.address);\n    this.sock.on('listening', () => {\n      this.emit('start');\n    });\n  }\n\n  call(id, method, ...args) {\n    const msg = {\n      id,\n      method,\n      args\n    };\n    this.sock.send(JSON.stringify(msg), this.options.port, this.options.address);\n  }\n\n  invoke(method, args, worker) {\n    if (this[method]) {\n      this[method](...args, worker);\n    }\n  }\n\n  connect(worker) {\n    this.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    if (this.options.parent) {\n      if (this.sock && this.sock.listening) {\n        process.kill(this.options.parent, sig);\n      } else {\n        this.once('start', () => {\n          process.kill(this.options.parent, sig);\n        });\n      }\n    }\n  }\n\n  masterKilled(data) {\n    this.emit('restart', data);\n  }\n\n  onMessage(msg, rinfo) {\n    const data = JSON.parse(msg);\n    this.invoke(data.method, data.args, data.id);\n  }\n}\n```\n"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a reusable HTTP client class that simplifies making HTTP requests using Axios, with support for common methods like GET and POST, while handling errors consistently.\n\nClass Description: The HTTPClient class encapsulates Axios functionality to provide a clean interface for making HTTP requests. It maintains headers across requests and provides methods for GET and POST operations with error handling.\n\nAttributes:\n- headers: Object - Contains HTTP headers to be sent with every request\n\nMethods:\n- constructor(headers: Object) -> void - Initializes the HTTP client with default headers\n- get(url: String, params: Object = {}) -> Promise<Object> - Sends a GET request to the specified URL with optional query parameters, returns response data or throws error\n- post(url: String, data: Object = {}, params: Object = {}) -> Promise<Object> - Sends a POST request to the specified URL with optional request body and query parameters, returns response data or throws error",
    "Canonical_solution": "const axios = require('axios');\n\nclass HTTPClient {\n    constructor(headers) {\n        this.headers = headers;\n    }\n\n    async get(url, params = {}) {\n        try {\n            const response = await axios({\n                method: 'get',\n                url: url,\n                headers: this.headers,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('GET request failed:', error);\n            throw error;\n        }\n    }\n\n    async post(url, data = {}, params = {}) {\n        try {\n            const response = await axios({\n                method: 'post',\n                url: url,\n                headers: this.headers,\n                data: data,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('POST request failed:', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```typescript\nimport axios, { AxiosRequestConfig, AxiosResponse } from 'axios';\n\nclass HTTPClient {\n  private headers: AxiosRequestConfig['headers'];\n\n  constructor(headers: AxiosRequestConfig['headers']) {\n    this.headers = headers;\n  }\n\n  private async request(method: 'get' | 'post', url: string, data: object = {}, params: object = {}): Promise<AxiosResponse> {\n    try {\n      const response = await axios({\n        method,\n        url,\n        data,\n        params,\n        headers: this.headers,\n      });\n      return response;\n    } catch (error) {\n      throw new Error(error.response ? error.response.data.message : error.message);\n    }\n  }\n\n  public async get(url: string, params: object = {}): Promise<AxiosResponse> {\n    return this.request('get', url, {}, params);\n  }\n\n  public async post(url: string, data: object = {}, params: object = {}): Promise<AxiosResponse> {\n    return this.request('post', url, data, params);\n  }\n}\n```"
  },
  {
    "Task_id": 191,
    "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome DevTools Protocol, handling connection, message exchange, and disconnection events.\n\nClass Description: The Chrome class is an EventEmitter that establishes and manages a WebSocket connection to Chrome's DevTools Protocol. It handles message parsing, error handling, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The WebSocket instance\n- _notifier: [EventEmitter] - External event notifier\n- _callbacks: [Object] - Stores pending command callbacks\n- _nextCommandId: [Number] - Tracks the next command ID\n\nMethods:\n- constructor(options, notifier) -> [void] - Initializes the Chrome instance with connection options and notifier\n- _start() -> [Promise] - Internal method to initiate WebSocket connection\n- _connectToWebSocket() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleConnectionClose() -> [void] - Cleans up when connection closes\n- _handleMessage(message) -> [void] - Processes incoming WebSocket messages\n- send(method, params, sessionId, callback) -> [Promise|void] - Sends a command to Chrome DevTools Protocol\n- _enqueueCommand(method, params, sessionId, callback) -> [void] - Internal method to queue commands\n- close(callback) -> [Promise|void] - Closes the WebSocket connection cleanly",
    "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this.webSocketUrl = undefined;\n        this._ws = null;\n        this._notifier = notifier;\n        this._start();\n    }\n\n    async _start() {\n        try {\n            await this._connectToWebSocket();\n            process.nextTick(() => {\n                this._notifier.emit('connect', this);\n            });\n        } catch (err) {\n            this._notifier.emit('error', err);\n        }\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleConnectionClose() {\n        this._callbacks = {};\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n\n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    close(callback) {\n        const closeWebSocket = (callback) => {\n            if (this._ws.readyState === 3) {\n                callback();\n            } else {\n                this._ws.removeAllListeners('close');\n                this._ws.once('close', () => {\n                    this._ws.removeAllListeners();\n                    this._handleConnectionClose();\n                    callback();\n                });\n                this._ws.close();\n            }\n        };\n        if (typeof callback === 'function') {\n            closeWebSocket(callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                closeWebSocket(fulfill);\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nclass Chrome {\n  constructor(options, notifier) {\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = `ws${this.secure ? 's' : ''}://${this.host}:${this.port}/devtools/browser`;\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 1;\n  }\n\n  async _start() {\n    return this._connectToWebSocket();\n  }\n\n  async _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => resolve();\n      this._ws.onerror = (error) => reject(error);\n      this._ws.onmessage = (message) => this._handleMessage(message);\n      this._ws.onclose = () => this._handleConnectionClose();\n    });\n  }\n\n  _handleConnectionClose() {\n    this._ws = null;\n    this._notifier.emit('disconnect');\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(data.result, data.error);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this._notifier.emit('event', data);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    if (!this._ws) {\n      return;\n    }\n    const id = this._nextCommandId++;\n    const command = { id, method, params, sessionId };\n    if (callback) {\n      this._callbacks[id] = callback;\n    }\n    this._ws.send(JSON.stringify(command));\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    if (!this._ws) {\n      this._notifier.once('connect', () => this.send(method, params, sessionId, callback));\n    } else {\n      this.send(method, params, sessionId, callback);\n    }\n  }\n\n  close(callback) {\n    if (!this._ws) {\n      return;\n    }\n    this._ws.close();\n    this._ws = null;\n    if (callback) {\n      this._notifier.once('disconnect', callback);\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a WebSocket-based OrderBook class for managing real-time order book data from a cryptocurrency exchange, with connection management and state handling capabilities.\n\nClass Description: The OrderBook class maintains a real-time order book for a specified trading pair by connecting to a WebSocket feed. It handles connection states, processes incoming messages, and provides event-driven updates. The class inherits from EventEmitter to notify consumers of state changes and order book updates.\n\nAttributes:\n- productID: string - The trading pair identifier (e.g., 'BTC-USD')\n- websocketURI: string - The WebSocket endpoint URL for real-time data\n- restURI: string - The REST API endpoint URL for initial snapshot\n- state: string - Current connection/processing state (from STATES enum)\n- fail_count: number - Count of consecutive connection failures\n- timeProvider: any - Service for timestamp generation\n- socket: WebSocket - The active WebSocket connection instance\n- queue: Array - Buffer for messages received during synchronization\n- book: object - The current order book state with sequence, bids, and asks\n\nMethods:\n- constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) -> OrderBook - Initializes the order book with configuration and starts connection\n- clear_book() -> void - Resets the order book and message queue\n- connect() -> void - Establishes new WebSocket connection with event handlers\n- disconnect() -> void - Closes active WebSocket connection\n- changeState(stateName: string) -> void - Updates state machine and handles transitions (emits statechange event)\n- onOpen() -> void - Handles WebSocket open event (starts synchronization)\n- onClose() -> void - Handles WebSocket close event (updates state)\n- onMessage(datastr: string) -> void - Processes incoming WebSocket messages\n- sync() -> void - Sends subscription message and loads initial snapshot\n- processMessage(message: object, t: Date) -> void - Validates and processes order book updates (emits message-type events)",
    "Canonical_solution": "var WebSocket = require('ws');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nclass OrderBook {\n    constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n        var self = this;\n        EventEmitter.call(self);\n\n        self.productID = productID || 'BTC-USD';\n        self.websocketURI = websocketURI || 'wss://ws-feed.exchange.coinbase.com';\n        self.restURI = restURI;\n        self.state = self.STATES.closed;\n        self.fail_count = 0;\n        self.timeProvider = timeProvider;\n        self.connect();\n    }\n\n    STATES = {\n        'closed': 'closed',\n        'open': 'open',\n        'syncing': 'syncing',\n        'processing': 'processing',\n        'error': 'error',\n    };\n\n    clear_book() {\n        var self = this;\n        self.queue = [];\n        self.book = {\n            'sequence': -1,\n            'bids': {},\n            'asks': {},\n        };\n    };\n\n    connect() {\n        var self = this;\n        if (self.socket) {\n            self.socket.close();\n        }\n        self.clear_book();\n        self.socket = new WebSocket(self.websocketURI);\n        self.socket.on('message', self.onMessage.bind(self));\n        self.socket.on('open', self.onOpen.bind(self));\n        self.socket.on('close', self.onClose.bind(self));\n    };\n\n    disconnect() {\n        var self = this;\n        if (!self.socket) {\n            throw \"Could not disconnect (not connected)\"\n        }\n        self.socket.close();\n        self.onClose();\n    };\n\n    changeState(stateName) {\n        var self = this;\n        var newState = self.STATES[stateName];\n        if (newState === undefined) {\n            throw \"Unrecognized state: \" + stateName;\n        }\n        var oldState = self.state;\n        self.state = newState;\n\n        if (self.fail_count > 3)\n            throw \"Tried to reconnect 4 times. Giving up.\";\n\n        if (self.state === self.STATES.error || self.state === self.STATES.closed) {\n            self.fail_count += 1;\n            self.socket.close();\n            setTimeout(() => self.connect(), 5000);\n        }\n        else if (self.state === self.STATES.processing) {\n            self.fail_count = 0;\n        }\n\n        self.emit('statechange', { 'old': oldState, 'new': newState });\n    };\n\n    onOpen() {\n        var self = this;\n        self.changeState(self.STATES.open);\n        self.sync();\n    };\n\n    onClose() {\n        var self = this;\n        self.changeState(self.STATES.closed);\n    };\n\n    onMessage(datastr: string) {\n        var self = this;\n        var t = self.timeProvider.utcNow();\n        var data = JSON.parse(datastr);\n        if (self.state !== self.STATES.processing) {\n            self.queue.push(data);\n        } else {\n            self.processMessage(data, t);\n        }\n    };\n\n    sync() {\n        var self = this;\n        self.changeState(self.STATES.syncing);\n        var subscribeMessage = {\n            'type': 'subscribe',\n            'product_id': self.productID,\n        };\n        self.socket.send(JSON.stringify(subscribeMessage));\n        self.loadSnapshot();\n    };\n\n    processMessage(message, t: Date) {\n        var self = this;\n        if (message.sequence <= self.book.sequence) {\n            self.emit('ignored', message);\n            return;\n        }\n        if (message.sequence != self.book.sequence + 1) {\n            self.changeState(self.STATES.error);\n        }\n        self.book.sequence = message.sequence;\n\n        self.emit(message.type, new Models.Timestamped(message, t));\n    };\n}\n\nutil.inherits(OrderBook, EventEmitter);",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "```typescript\nclass OrderBook extends EventEmitter {\n  productID: string;\n  websocketURI: string;\n  restURI: string;\n  state: string;\n  fail_count: number;\n  timeProvider: any;\n  socket: WebSocket;\n  queue: Array<any>;\n  book: any;\n\n  constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = 'disconnected';\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = { sequence: null, bids: [], asks: [] };\n    this.connect();\n  }\n\n  clear_book() {\n    this.book = { sequence: null, bids: [], asks: [] };\n    this.queue = [];\n  }\n\n  connect() {\n    this.socket = new WebSocket(this.websocketURI);\n    this.socket.onopen = () => this.onOpen();\n    this.socket.onclose = () => this.onClose();\n    this.socket.onmessage = (event) => this.onMessage(event.data);\n  }\n\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n\n  changeState(stateName: string) {\n    this.state = stateName;\n    this.emit('statechange', stateName);\n  }\n\n  onOpen() {\n    this.changeState('connected');\n    this.sync();\n  }\n\n  onClose() {\n    this.changeState('disconnected');\n    this.socket = null;\n    this.fail_count++;\n    setTimeout(() => this.connect(), 1000);\n  }\n\n  onMessage(datastr: string) {\n    const data = JSON.parse(datastr);\n    const t = this.timeProvider.now();\n    this.processMessage(data, t);\n  }\n\n  sync() {\n    this.socket.send(JSON.stringify({ type: 'subscribe', product_ids: [this.productID], channels: ['level2'] }));\n    // Fetch initial snapshot\n  }\n\n  processMessage(message: object, t: Date) {\n    if (message.type === 'l2update') {\n      // Process order book update\n    } else if (message.type === 'snapshot') {\n      // Process initial snapshot\n    }\n  }\n}\n```\n"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a WebSocket-based communication channel class that handles message sending, receiving, and connection management between a client and server.\n\nClass Description: The Channel class manages WebSocket communication by providing methods to send messages, handle incoming messages, and manage connection lifecycle events. It acts as an abstraction layer over raw WebSocket connections.\n\nAttributes:\n- _ws: [WebSocket] - The underlying WebSocket connection instance\n- _handler: [Object|null] - The message handler object that processes incoming messages\n- _messageListener: [Function] - The bound message event listener function\n\nMethods:\n- constructor(ws) -> [void] - Initializes the channel with a WebSocket instance and sets up message listener\n- send(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Closes the WebSocket connection\n- listen(handler) -> [void] - Sets the message handler for incoming messages\n- dispose() -> [void] - Cleans up event listeners\n- _messageReceived(message) -> [void] - Internal method that forwards incoming messages to the handler\n\nTask Description: Create a service class that manages multiple WebSocket connections and sessions for debugging purposes.\n\nClass Description: The NddService class manages multiple debugging sessions through WebSocket connections, handling session creation, connection events, and cleanup.\n\nAttributes:\n- _disconnectPromise: [Promise] - Promise that resolves when the process disconnects\n- _connected: [Set] - Set of currently connected session IDs\n- _frontend: [Object] - Frontend interface for handling session events\n- _pipe: [string] - Path to the named pipe for IPC communication\n\nMethods:\n- constructor(frontend) -> [void] - Initializes the service with frontend interface and sets up IPC server\n- _startSession(info, frontend) -> [Promise<Function>] - Starts a new debugging session and returns a cleanup function\n  - info: [Object] - Session information including inspector URL and ID\n  - frontend: [Object] - Frontend interface for session events\n  - Returns: [Function] - Async cleanup function for the session",
    "Canonical_solution": "const { spawn } = require('child_process');\nconst os = require('os');\nconst path = require('path');\nconst net = require('net');\nconst WebSocket = require('ws');\n\nclass Channel {\n  /**\n   * @param {!WebSocket} ws\n   */\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.on('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  /**\n   * @param {!Object}\n   */\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeListener('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler.dispatchMessage(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => process.once('disconnect', () => resolve()));\n    this._connected = new Set();\n    this._frontend = frontend;\n\n    const pipePrefix = process.platform === 'win32' ? '\\\\\\\\.\\\\pipe\\\\' : os.tmpdir();\n    const pipeName = `node-ndb.${process.pid}.sock`;\n    this._pipe = path.join(pipePrefix, pipeName);\n    const server = net.createServer(socket => {\n      socket.on('data', async d => {\n        const runSession = await this._startSession(JSON.parse(d), frontend);\n        socket.write('run');\n        runSession();\n      });\n      socket.on('error', e => {});\n    }).listen(this._pipe);\n    server.unref();\n  }\n\n  async _startSession(info, frontend) {\n    const ws = new WebSocket(info.inspectorUrl);\n    const openPromise = new Promise(resolve => ws.once('open', () => resolve()));\n    const errorPromise = new Promise(resolve => ws.once('error', () => resolve()));\n    const closePromise = new Promise(resolve => ws.once('close', () => resolve()));\n    let state = await Promise.race([openPromise, errorPromise, closePromise, this._disconnectPromise]);\n    if (state === openPromise) {\n      this._connected.add(info.id);\n      const channel = new Channel(ws);\n      state = await Promise.race([frontend.detected(info, rpc.handle(channel)), this._disconnectPromise]);\n      return async() => {\n        if (state !== this._disconnectPromise)\n          state = await Promise.race([closePromise, errorPromise, this._disconnectPromise]);\n        channel.dispose();\n        this._connected.delete(info.id);\n        if (state !== this._disconnectPromise)\n          frontend.disconnected(info.id);\n        else\n          ws.send(CALL_EXIT_MESSAGE, () => ws.close());\n      };\n    } else {\n      return async function() {};\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "```typescript\nclass Channel {\n  private _ws: WebSocket;\n  private _handler: any = null;\n  private _messageListener: any = null;\n\n  constructor(ws: WebSocket) {\n    this._ws = ws;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.addEventListener('message', this._messageListener);\n  }\n\n  send(message: any): void {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close(): void {\n    this._ws.close();\n  }\n\n  listen(handler: any): void {\n    this._handler = handler;\n  }\n\n  dispose(): void {\n    this._ws.removeEventListener('message', this._messageListener);\n  }\n\n  private _messageReceived(message: any): void {\n    if (this._handler) {\n      this._handler(message);\n    }\n  }\n}\n\nclass NddService {\n  private _disconnectPromise: Promise<void>;\n  private _connected: Set<string>;\n  private _frontend: any;\n  private _pipe: string;\n\n  constructor(frontend: any) {\n    this._disconnectPromise = new Promise((resolve) => {\n      process.on('disconnect', resolve);\n    });\n    this._connected = new Set();\n    this._frontend = frontend;\n    this._pipe = '/tmp/ndd.sock';\n    this._setupIpcServer();\n  }\n\n  private async _startSession(info: any, frontend: any): Promise<Function> {\n    const { inspectorURL, id } = info;\n    const cleanup = await this._frontend.startSession(inspectorURL, id);\n    this._connected.add(id);\n    return async () => {\n      await cleanup();\n      this._connected.delete(id);\n    };\n  }\n\n  private _setupIpcServer(): void {\n    // Implementation of IPC server setup\n  }\n}\n```"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome's DevTools Protocol, handling connection, message exchange, and event emission.\n\nClass Description: The Chrome class extends EventEmitter to create a WebSocket client that connects to Chrome's DevTools Protocol. It manages WebSocket connections, handles message parsing, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- _notifier: [Object] - External notification handler\n- _callbacks: [Object] - Map of pending command callbacks\n- _nextCommandId: [Number] - Counter for generating command IDs\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The active WebSocket connection instance\n\nMethods:\n- constructor: [constructor](options: Object, notifier: Object) -> [Chrome] - Initializes the Chrome instance with connection options and notifier\n- _connectToWebSocket: [_connectToWebSocket]() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleMessage: [_handleMessage](message: Object) -> [void] - Processes incoming WebSocket messages (responses and events)\n- _enqueueCommand: [_enqueueCommand](method: String, params: Object, sessionId: String, callback: Function) -> [void] - Sends a command through WebSocket and tracks its callback\n- send: [send](method: String, ...args: Any) -> [Promise|undefined] - Public method to send commands, supporting both callback and Promise patterns",
    "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this._notifier = notifier;\n        this._callbacks = {};\n        this._nextCommandId = 1;\n        this.webSocketUrl = undefined;\n        this._start();\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n        \n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nclass Chrome extends EventEmitter {\n  constructor(options = {}, notifier = {}) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 1;\n    this.webSocketUrl = `${this.secure ? 'wss' : 'ws'}://${this.host}:${this.port}/devtools/browser`;\n    this._ws = null;\n  }\n\n  async _connectToWebSocket() {\n    if (this._ws) {\n      this._ws.close();\n    }\n    this._ws = new WebSocket(this.webSocketUrl);\n    this._ws.onopen = () => {\n      this._notifier.notify('connected');\n    };\n    this._ws.onmessage = (message) => {\n      this._handleMessage(JSON.parse(message.data));\n    };\n    this._ws.onclose = () => {\n      this._notifier.notify('disconnected');\n    };\n    this._ws.onerror = (error) => {\n      this._notifier.notify('error', error);\n    };\n  }\n\n  _handleMessage(message) {\n    if (message.id) {\n      const callback = this._callbacks[message.id];\n      if (callback) {\n        callback(message.error, message.result);\n        delete this._callbacks[message.id];\n      }\n    } else {\n      this.emit(message.method, message.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const id = this._nextCommandId++;\n    this._callbacks[id] = callback;\n    this._ws.send(JSON.stringify({\n      id,\n      method,\n      params,\n      sessionId,\n    }));\n  }\n\n  send(method, ...args) {\n    const [params, sessionId, callback] = args;\n    if (typeof sessionId === 'function') {\n      callback = sessionId;\n      sessionId = null;\n    }\n    if (typeof callback === 'function') {\n      return new Promise((resolve, reject) => {\n        this._enqueueCommand(method, params, sessionId, (error, result) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(result);\n          }\n          callback(error, result);\n        });\n      });\n    } else {\n      this._enqueueCommand(method, params, sessionId, null);\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a WebSocket client class in Node.js that handles WebSocket connections, message transmission, and connection lifecycle events.\n\nClass Description: WebSocketImpl is a WebSocket client implementation that manages WebSocket connections, including establishing connections, handling incoming messages, managing connection states, and sending messages. It wraps the 'ws' library functionality with additional state management and event handling.\n\nAttributes:\n- _globalObject: [Object] - The global context in which the WebSocket operates\n- _ownerDocument: [Object] - The document associated with the WebSocket\n- _urlRecord: [Object|null] - URL information for the WebSocket connection\n- url: [String] - The WebSocket server URL\n- extensions: [String] - Supported WebSocket extensions\n- binaryType: [String] - Type of binary data handling (\"blob\" or \"arraybuffer\")\n- _ws: [Object|null] - The underlying WebSocket instance\n- _readyState: [Number] - Current connection state (0=CONNECTING, 1=OPEN, 2=CLOSING, 3=CLOSED)\n- _requiredToFail: [Boolean] - Flag indicating if the connection should fail\n- bufferedAmount: [Number] - Number of bytes of queued data\n- _sendQueue: [Array] - Queue of messages waiting to be sent\n- _dequeueScheduled: [Boolean] - Flag for send queue scheduling\n\nMethods:\n- constructor(globalObject, args, privateData) -> [void] - Initializes the WebSocket client with configuration and establishes connection\n- _onConnectionEstablished() -> [void] - Handles successful connection establishment\n- _onMessageReceived(data, isBinary) -> [void] - Processes incoming WebSocket messages\n- _onConnectionClosed(code, reason) -> [void] - Handles connection closure\n- close(code, reason) -> [void] - Closes the WebSocket connection with optional code and reason\n- send(data) -> [void] - Queues data for sending through the WebSocket\n- _actuallySend() -> [void] - Internal method that sends queued messages\n- _scheduleSend() -> [void] - Schedules message sending on the next event loop tick",
    "Canonical_solution": "const WebSocket = require(\"ws\");\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = privateData.document;\n    this._urlRecord = null;\n    this.url = \"\";\n    this.extensions = \"\";\n    this.binaryType = \"blob\";\n    this._ws = null;\n    this._readyState = 0; // CONNECTING\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n\n    const url = args[0];\n    let protocols = args[1] !== undefined ? args[1] : [];\n\n    this._ws = new WebSocket(this.url, protocols, {\n      headers: {\n        \"user-agent\": globalObject.navigator.userAgent,\n        \"cookie\": this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, { http: true }),\n        \"origin\": globalObject._origin\n      },\n      rejectUnauthorized: globalObject._resourceLoader._strictSSL\n    });\n\n    this._ws.once(\"open\", () => {\n      this._onConnectionEstablished();\n    });\n    this._ws.on(\"message\", this._onMessageReceived.bind(this));\n    this._ws.once(\"close\", (...closeArgs) => {\n      this._onConnectionClosed(...closeArgs);\n    });\n    this._ws.once(\"error\", () => {\n      this._requiredToFail = true;\n    });\n  }\n\n  _onConnectionEstablished() {\n    if (this._ws.extensions !== null) {\n      this.extensions = Object.keys(this._ws.extensions).join(\", \");\n    }\n    // fire open event\n  }\n\n  _onMessageReceived(data, isBinary) {\n    if (this.readyState !== 1) { // OPEN\n      return;\n    }\n    // process message data and fire message event\n  }\n\n  _onConnectionClosed(code, reason) {\n    // fire close event\n  }\n\n  close(code = undefined, reason = undefined) {\n    if (this.readyState === 0) { // CONNECTING\n      this._requiredToFail = true;\n      if (this._ws !== null) {\n        this._ws.terminate();\n      } else {\n        this._readyState = 2; // CLOSING\n      }\n    } else if (this.readyState === 1) { // OPEN\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this.readyState === 0) { // CONNECTING\n      throw new Error(\"Still in CONNECTING state.\");\n    }\n    if (this.readyState !== 1) { // OPEN\n      return;\n    }\n    let length;\n    if (typeof data === \"string\") {\n      length = Buffer.byteLength(data, \"utf8\");\n    } else {\n      length = data.byteLength;\n    }\n    this.bufferedAmount += length;\n    this._sendQueue.push([data, length]);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    for (const [data, length] of this._sendQueue.splice(0)) {\n      this._ws.send(data, { binary: typeof data !== \"string\" }, () => {\n        this.bufferedAmount -= length;\n      });\n    }\n  }\n\n  _scheduleSend() {\n    if (this._dequeueScheduled) {\n      return;\n    }\n    this._dequeueScheduled = true;\n    process.nextTick(() => {\n      this._dequeueScheduled = false;\n      this._actuallySend();\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = args[0];\n    this._urlRecord = args[1];\n    this.url = args[1].url.href;\n    this.extensions = \"\";\n    this.binaryType = \"blob\";\n    this._ws = null;\n    this._readyState = 0;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n    this._ws = new WebSocket(args[1].url.href);\n    this._ws.onopen = this._onConnectionEstablished.bind(this);\n    this._ws.onmessage = this._onMessageReceived.bind(this);\n    this._ws.onclose = this._onConnectionClosed.bind(this);\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = 1;\n    this.dispatchEvent(new Event(\"open\"));\n  }\n\n  _onMessageReceived(data, isBinary) {\n    this.dispatchEvent(new MessageEvent(\"message\", { data: data, isTrusted: true }));\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = 3;\n    this.dispatchEvent(new CloseEvent(\"close\", { code: code, reason: reason }));\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this._sendQueue.push(data);\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      this._globalObject.setTimeout(this._actuallySend.bind(this), 0);\n    }\n  }\n\n  _actuallySend() {\n    while (this._sendQueue.length > 0) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n    }\n    this._dequeueScheduled = false;\n  }\n}\n```"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a JavaScript class for interacting with the Cryptsy cryptocurrency exchange API, handling both public and private endpoints with proper authentication and request management.\n\nClass Description: The Cryptsy class provides a wrapper for the Cryptsy API, enabling users to make authenticated requests to private endpoints and public data requests. It handles API authentication, request signing, and response processing.\n\nAttributes:\n- key: string - API key for authentication\n- secret: string - API secret for request signing\n- PUBLIC_API_URL: string - Base URL for public API endpoints (default: 'http://pubapi.cryptsy.com/api.php')\n- PRIVATE_API_URL: string - Base URL for private API endpoints (default: 'https://api.cryptsy.com/api')\n- USER_AGENT: string - User agent string for requests (default: 'nomp/node-open-mining-portal')\n- STRICT_SSL: boolean - Static flag for SSL verification (default: true)\n\nMethods:\n- constructor(key, secret) -> Cryptsy - Initializes the API client with credentials\n- _getPrivateHeaders(parameters: object) -> object - Generates authentication headers for private requests\n- _request(options: object, callback: function) -> Cryptsy - Base request method with common configuration\n- _public(parameters: object, callback: function) -> Cryptsy - Makes public API requests\n- _private(parameters: object, callback: function) -> Cryptsy - Makes authenticated private API requests\n- getTicker(callback: function) -> Cryptsy - Gets market ticker data\n- getOrderBook(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets order book for a currency pair\n- getTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets public trade history\n- myBalances(callback: function) -> Cryptsy - Gets user's account balances\n- myOpenOrders(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's open orders\n- myTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's trade history\n- buy(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a buy order\n- sell(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a sell order\n- cancelOrder(currencyA: string, currencyB: string, orderNumber: string, callback: function) -> Cryptsy - Cancels an order\n- withdraw(currency: string, amount: number, address: string, callback: function) -> Cryptsy - Withdraws funds\n- _joinCurrencies(currencyA: string, currencyB: string) -> string - Helper to format currency pairs",
    "Canonical_solution": "var request = require('request');\nvar nonce = require('nonce');\nvar crypto = require('crypto');\n\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n    }\n\n    static STRICT_SSL = true;\n\n    _getPrivateHeaders(parameters) {\n        if (!this.key || !this.secret) {\n            throw 'Cryptsy: Error. API key and secret required';\n        }\n\n        let paramString = Object.keys(parameters).sort().map(function(param) {\n            return encodeURIComponent(param) + '=' + encodeURIComponent(parameters[param]);\n        }).join('&');\n\n        let signature = crypto.createHmac('sha512', this.secret).update(paramString).digest('hex');\n\n        return {\n            Key: this.key,\n            Sign: signature\n        };\n    }\n\n    _request(options, callback) {\n        if (!('headers' in options)) {\n            options.headers = {};\n        }\n\n        options.headers['User-Agent'] = this.USER_AGENT;\n        options.json = true;\n        options.strictSSL = Cryptsy.STRICT_SSL;\n\n        request(options, function(err, response, body) {\n            callback(err, body);\n        });\n\n        return this;\n    }\n\n    _public(parameters, callback) {\n        let options = {\n            method: 'GET',\n            url: this.PUBLIC_API_URL,\n            qs: parameters\n        };\n\n        return this._request(options, callback);\n    }\n\n    _private(parameters, callback) {\n        parameters.nonce = nonce();\n        let options = {\n            method: 'POST',\n            url: this.PRIVATE_API_URL,\n            form: parameters,\n            headers: this._getPrivateHeaders(parameters)\n        };\n\n        return this._request(options, callback);\n    }\n\n    getTicker(callback) {\n        let parameters = {\n            method: 'marketdatav2'\n        };\n        return this._public(parameters, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOrderBook',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    myBalances(callback) {\n        let parameters = {\n            command: 'returnBalances'\n        };\n        return this._private(parameters, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOpenOrders',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'buy',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'sell',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        let parameters = {\n            command: 'cancelOrder',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            orderNumber: orderNumber\n        };\n        return this._private(parameters, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        let parameters = {\n            command: 'withdraw',\n            currency: currency,\n            amount: amount,\n            address: address\n        };\n        return this._private(parameters, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return currencyA + '_' + currencyB;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass Cryptsy {\n  constructor(key, secret) {\n    this.key = key;\n    this.secret = secret;\n    this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n    this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n    this.USER_AGENT = 'nomp/node-open-mining-portal';\n    this.STRICT_SSL = true;\n  }\n\n  _getPrivateHeaders(parameters) {\n    const nonce = new Date().getTime();\n    const message = nonce + this.key + this.secret;\n    const signature = CryptoJS.HmacSHA512(message, this.secret).toString(CryptoJS.enc.Hex);\n    return {\n      'Key': this.key,\n      'Sign': signature,\n      'Content-Type': 'application/json',\n      'User-Agent': this.USER_AGENT,\n      'Nonce': nonce\n    };\n  }\n\n  _request(options, callback) {\n    const request = https.request(options, (response) => {\n      let data = '';\n      response.on('data', (chunk) => {\n        data += chunk;\n      });\n      response.on('end', () => {\n        callback(null, JSON.parse(data));\n      });\n    });\n    request.on('error', (error) => {\n      callback(error);\n    });\n    if (options.method === 'POST' && options.body) {\n      request.write(JSON.stringify(options.body));\n    }\n    request.end();\n  }\n\n  _public(parameters, callback) {\n    const options = {\n      hostname: this.PUBLIC_API_URL,\n      path: '?method=' + parameters.method,\n      method: 'GET',\n      headers: {\n        'User-Agent': this.USER_AGENT\n      }\n    };\n    this._request(options, callback);\n  }\n\n  _private(parameters, callback) {\n    const options = {\n      hostname: this.PRIVATE_API_URL,\n      path: '',\n      method: 'POST',\n      headers: this._getPrivateHeaders(parameters),\n      body: parameters\n    };\n    this._request(options, callback);\n  }\n\n  getTicker(callback) {\n    this._public({ method: 'getmarketsummary' }, callback);\n  }\n\n  getOrderBook(currencyA, currencyB, callback) {\n    this._public({ method: 'getorderbook', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  getTradeHistory(currencyA, currencyB, callback) {\n    this._public({ method: 'getmarkethistory', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  myBalances(callback) {\n    this._private({ method: 'getinfo' }, callback);\n  }\n\n  myOpenOrders(currencyA, currencyB, callback) {\n    this._private({ method: 'myopenorders', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  myTradeHistory(currencyA, currencyB, callback) {\n    this._private({ method: 'mytrades', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  buy(currencyA, currencyB, rate, amount, callback) {\n    this._private({ method: 'buy', marketid: this._joinCurrencies(currencyA, currencyB), rate: rate, quantity: amount }, callback);\n  }\n\n  sell(currencyA, currencyB, rate, amount, callback) {\n    this._private({ method: 'sell', marketid: this._joinCurrencies(currencyA, currencyB), rate: rate, quantity: amount }, callback);\n  }\n\n  cancelOrder(currencyA, currencyB, orderNumber, callback) {\n    this._private({ method: 'cancelorder', marketid: this._joinCurrencies(currencyA, currencyB), orderid: orderNumber }, callback);\n  }\n\n  withdraw(currency, amount, address, callback) {\n    this._private({ method: 'withdraw', currency: currency, amount: amount, address: address }, callback);\n  }\n\n  _joinCurrencies(currencyA, currencyB) {\n    return currencyA + '_' + currencyB;\n  }\n}\n```"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a class that handles the downloading and installation of binary packages from a specified URL, including directory management and error handling.\n\nClass Description: The Binary class is responsible for downloading a binary package from a given URL, extracting it to a specified directory, and managing the installation process. It handles directory creation, file extraction, and provides feedback on the installation status.\n\nAttributes:\n- url: [String] - The URL from which the binary package will be downloaded.\n- name: [String] - The name of the binary package (optional, defaults to -1).\n- installDirectory: [String] - The base directory where the binary will be installed (optional, defaults to a 'bin' subdirectory in the current working directory).\n- binaryDirectory: [String] - The full path to the directory where the binary will be extracted (initialized as -1, set during installation).\n- binaryPath: [String] - The full path to the binary file (initialized as -1, not used in current implementation).\n\nMethods:\n- constructor(url, data) -> [None] - Initializes the Binary instance with the download URL and optional configuration data (name and installDirectory).\n- install() -> [Promise] - Handles the complete installation process including directory preparation, downloading, extraction, and cleanup. Returns a Promise that resolves when installation is complete or rejects on error.\n  - Internal method _getInstallDirectory() is used to determine the installation directory path.",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass Binary {\n    constructor(url, data) {\n        this.url = url;\n        this.name = data.name || -1;\n        this.installDirectory = data.installDirectory || join(__dirname, \"bin\");\n        this.binaryDirectory = -1;\n        this.binaryPath = -1;\n    }\n\n    install() {\n        const dir = this._getInstallDirectory();\n        if (!existsSync(dir)) {\n            mkdirSync(dir, { recursive: true });\n        }\n\n        this.binaryDirectory = join(dir, \"bin\");\n\n        if (existsSync(this.binaryDirectory)) {\n            rimraf.sync(this.binaryDirectory);\n        }\n\n        mkdirSync(this.binaryDirectory, { recursive: true });\n\n        console.log(`Downloading release from ${this.url}`);\n\n        return axios({ url: this.url, responseType: \"stream\" })\n            .then(res => {\n                const writer = tar.x({ strip: 1, C: this.binaryDirectory });\n\n                return new Promise((resolve, reject) => {\n                    res.data.pipe(writer);\n                    let error = null;\n                    writer.on('error', err => {\n                      error = err;\n                      reject(err);\n                    });\n                    writer.on('close', () => {\n                      if (!error) {\n                        resolve(true);\n                      }\n                    });\n                })\n            })\n            .then(() => {\n                console.log(\n                    `${this.name ? this.name : \"Your package\"} has been installed!`\n                );\n            })\n            .catch(e => {\n                error(`Error fetching release: ${e.message}`);\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```python\nimport os\nimport urllib.request\nimport tarfile\nimport shutil\nimport asyncio\n\nclass Binary:\n    def __init__(self, url, data=None):\n        self.url = url\n        self.name = data.get('name', -1)\n        self.installDirectory = data.get('installDirectory', os.path.join(os.getcwd(), 'bin'))\n        self.binaryDirectory = -1\n        self.binaryPath = -1\n\n    async def install(self):\n        try:\n            self.binaryDirectory = self._getInstallDirectory()\n            os.makedirs(self.binaryDirectory, exist_ok=True)\n            await self._downloadBinary()\n            await self._extractBinary()\n            await self._cleanup()\n            print(\"Installation complete.\")\n        except Exception as e:\n            print(f\"Installation failed: {e}\")\n            raise\n\n    def _getInstallDirectory(self):\n        return os.path.join(self.installDirectory, self.name)\n\n    async def _downloadBinary(self):\n        print(f\"Downloading binary from {self.url}...\")\n        with urllib.request.urlopen(self.url) as response, open('binary.tar.gz', 'wb') as out_file:\n            shutil.copyfileobj(response, out_file)\n        print(\"Download complete.\")\n\n    async def _extractBinary(self):\n        print(\"Extracting binary...\")\n        with tarfile.open('binary.tar.gz', 'r:gz') as tar:\n            tar.extractall(path=self.binaryDirectory)\n        print(\"Extraction complete.\")\n\n    async def _cleanup(self):\n        print(\"Cleaning up...\")\n        os.remove('binary.tar.gz')\n        print(\"Cleanup complete.\")\n```\n"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a server, sends and receives messages in JSON format, and handles connection events including opening, closing, and errors.\n\nFunction Description: The function `testWebSocketConnection` initiates a WebSocket client connection to a specified server URL. It sends initial messages upon successful connection, listens for incoming messages, and handles connection lifecycle events. The function demonstrates a basic WebSocket interaction pattern including sending/receiving JSON data and proper connection cleanup.\n\nInput: \n- wssUrl: [String] - The WebSocket server URL (without protocol) to connect to (e.g., \"example.com:8080\")\n\nOutput: \n- None (void) - The function doesn't return any value but logs connection status and received messages to the console. All operations are performed through side effects (event handlers and WebSocket operations).",
    "Canonical_solution": "function testWebSocketConnection() {\n  var WebSocket = require('ws');\n  var echoWs = new WebSocket('wss://' + wssUrl + '/examples/echo');\n  \n  echoWs.on('open', function open() {\n    console.log('WebSocket connection established');\n    \n    echoWs.send('hello');\n    echoWs.once('message', function(data, flags) {\n      data = JSON.parse(data);\n      console.log('Received:', data);\n      \n      echoWs.send('{\"foo\": \"bar\"}');\n      echoWs.once('message', function(data, flags) {\n        data = JSON.parse(data);\n        console.log('Received:', data);\n        \n        echoWs.close();\n      });\n    });\n  });\n  \n  echoWs.on('close', function() {\n    console.log('WebSocket connection closed');\n  });\n  \n  echoWs.on('error', function(err) {\n    console.error('WebSocket error:', err);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nfunction testWebSocketConnection(wssUrl) {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    ws.send(JSON.stringify({ type: 'initial', message: 'Hello, server!' }));\n  };\n\n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    console.log('Received message:', message);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n}\n```\n"
  },
  {
    "Task_id": 201,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript using Node.js that establishes a connection to a WebSocket server, handles incoming messages, and manages connection events.\n\nClass Description: The WebSocketImpl class provides a wrapper around the Node.js 'ws' library to create and manage WebSocket connections. It handles connection establishment, message reception, error handling, and connection closure events. The class also provides methods for sending data and closing the connection.\n\nAttributes:\n- _globalObject: [Object] - The global context in which the WebSocket operates\n- _ownerDocument: [Object] - The document object associated with the WebSocket\n- _urlRecord: [Object] - Parsed URL information for the WebSocket connection\n- url: [String] - The WebSocket server URL as a string\n- _ws: [WebSocket|null] - The underlying WebSocket instance or null if not connected\n- _readyState: [Number] - Current connection state (0 = CONNECTING)\n- _requiredToFail: [Boolean] - Flag indicating if the connection should fail\n- bufferedAmount: [Number] - Amount of buffered data in bytes\n- _sendQueue: [Array] - Queue of messages waiting to be sent\n\nMethods:\n- constructor(globalObject, args, privateData) -> [void] - Initializes the WebSocket connection with the given parameters and sets up event handlers\n- _onConnectionEstablished() -> [void] - Internal method called when the WebSocket connection is successfully established\n- _onMessageReceived(data, isBinary) -> [void] - Internal method called when a message is received from the server\n- _onConnectionClosed(code, reason) -> [void] - Internal method called when the WebSocket connection is closed\n- close(code, reason) -> [void] - Closes the WebSocket connection with optional code and reason\n- send(data) -> [void] - Sends data through the WebSocket connection (supports strings and Blob objects)\n- get readyState() -> [Number] - Returns the current ready state of the WebSocket connection",
    "Canonical_solution": "const WebSocket = require(\"ws\");\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = idlUtils.implForWrapper(globalObject._document);\n    this._urlRecord = parseURL(args[0]);\n    this.url = serializeURL(this._urlRecord);\n    this._ws = null;\n    this._readyState = 0; // CONNECTING\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n\n    const protocols = typeof args[1] === \"string\" ? [args[1]] : (args[1] || []);\n    const nodeParsedURL = nodeURL.parse(this.url);\n\n    this._ws = new WebSocket(this.url, protocols, {\n      headers: {\n        \"user-agent\": globalObject.navigator.userAgent,\n        \"cookie\": this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, { http: true }),\n        \"origin\": globalObject._origin\n      },\n      rejectUnauthorized: globalObject._resourceLoader._strictSSL\n    });\n\n    this._ws.once(\"open\", () => {\n      this._onConnectionEstablished();\n    });\n    this._ws.on(\"message\", this._onMessageReceived.bind(this));\n    this._ws.once(\"close\", (...closeArgs) => {\n      this._onConnectionClosed(...closeArgs);\n    });\n    this._ws.once(\"error\", () => {\n      this._requiredToFail = true;\n    });\n  }\n\n  _onConnectionEstablished() {\n    fireAnEvent(\"open\", this);\n  }\n\n  _onMessageReceived(data, isBinary) {\n    let dataForEvent;\n    if (!isBinary) {\n      dataForEvent = data.toString();\n    } else if (this.binaryType === \"arraybuffer\") {\n      dataForEvent = copyToArrayBufferInNewRealm(data, this._globalObject);\n    } else {\n      dataForEvent = Blob.create(this._globalObject, [[data], { type: \"\" }]);\n    }\n    fireAnEvent(\"message\", this, MessageEvent, {\n      data: dataForEvent,\n      origin: serializeURLOrigin(this._urlRecord)\n    });\n  }\n\n  _onConnectionClosed(code, reason) {\n    fireAnEvent(\"close\", this, CloseEvent, {\n      wasClean: !this._requiredToFail,\n      code,\n      reason: reason.toString()\n    });\n  }\n\n  close(code = undefined, reason = undefined) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN) {\n      if (Blob.isImpl(data)) {\n        data = data._buffer;\n      }\n      this._ws.send(data, { binary: typeof data !== \"string\" });\n    }\n  }\n\n  get readyState() {\n    return this._ws ? this._ws.readyState : this._readyState;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = privateData.ownerDocument;\n    this._urlRecord = privateData.urlRecord;\n    this.url = this._urlRecord.url.href;\n    this._ws = null;\n    this._readyState = WebSocket.CONNECTING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n\n    this._ws = new WebSocket(this.url);\n    this._ws.onopen = this._onConnectionEstablished.bind(this);\n    this._ws.onmessage = (event) => this._onMessageReceived(event.data, event.isBinary);\n    this._ws.onclose = (event) => this._onConnectionClosed(event.code, event.reason);\n    this._ws.onerror = () => this._onConnectionClosed(1006, '');\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n    this._sendQueue.forEach((message) => this._ws.send(message));\n    this._sendQueue = [];\n    this._globalObject.dispatchEvent(new Event('open'));\n  }\n\n  _onMessageReceived(data, isBinary) {\n    const event = new MessageEvent('message', { data: data, isTrusted: true });\n    this._globalObject.dispatchEvent(event);\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    this._ws = null;\n    this._globalObject.dispatchEvent(new CloseEvent('close', { code: code, reason: reason }));\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n}\n```"
  },
  {
    "Task_id": 210,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that handles WebSocket connections, message processing, and connection lifecycle events. The class should support sending and receiving JSON messages, handling different commands, and managing connection states.\n\nClass Description: The `Client` class represents a WebSocket client that connects to a server, processes incoming messages, and sends commands. It handles connection events, message parsing, and provides methods for common operations like sending hello messages and triggering reloads.\n\nAttributes:\n- `ws`: [WebSocket] - The WebSocket connection instance.\n- `options`: [Object] - Configuration options for the client.\n- `id`: [String] - Unique identifier for the client instance.\n- `plugins`: [Array] - List of plugins received from the server.\n- `url`: [String] - URL received from the server.\n\nMethods:\n- `constructor(req, socket, head, options)` -> [Client] - Initializes a new WebSocket client instance with the given request, socket, head, and options.\n- `message(event)` -> [void] - Handles incoming WebSocket messages, parses them, and routes to appropriate command handlers.\n- `close(event)` -> [void] - Closes the WebSocket connection and emits an 'end' event.\n- `hello()` -> [void] - Sends a 'hello' command to the server with supported protocols and server name.\n- `info(data)` -> [void] - Processes 'info' command data from the server, storing plugins and URL.\n- `reload(files)` -> [void] - Sends 'reload' commands for each file in the provided list, with live reload options.\n- `_data(event)` -> [Object] - Parses incoming message data from JSON string to object.\n- `send(data)` -> [void] - Sends data as a JSON string over the WebSocket connection.\n- `uniqueId(prefix)` -> [String] - Generates a unique ID with an optional prefix.",
    "Canonical_solution": "var WebSocket = require('faye-websocket');\n\nclass Client {\n  constructor(req, socket, head, options) {\n    options = this.options = options || {};\n    this.ws = new WebSocket(req, socket, head);\n    this.ws.onmessage = this.message.bind(this);\n    this.ws.onclose = this.close.bind(this);\n    this.id = this.uniqueId('ws');\n  }\n\n  message(event) {\n    var data = this.data(event);\n    if(this[data.command]) return this[data.command](data);\n  }\n\n  close(event) {\n    if(this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.emit('end', event);\n  }\n\n  hello() {\n    this.send({\n      command: 'hello',\n      protocols: [\n        'http://livereload.com/protocols/official-7'\n      ],\n      serverName: 'tiny-lr'\n    });\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(function(file) {\n      this.send({\n        command: 'reload',\n        path: file,\n        liveCss: this.options.liveCss !== false,\n        liveJs: this.options.liveJs !== false,\n        liveImg: this.options.liveImg !== false\n      });\n    }, this);\n  }\n\n  _data(event) {\n    var data = {};\n    try {\n      data = JSON.parse(event.data);\n    } catch (e) {}\n    return data;\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  }\n}\n\nvar idCounter = 0;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nclass Client {\n  constructor(req, socket, head, options) {\n    this.ws = new WebSocket(req, socket, head, options);\n    this.options = options;\n    this.id = this.uniqueId();\n    this.plugins = [];\n    this.url = null;\n    this.ws.on('message', this.message.bind(this));\n    this.ws.on('close', this.close.bind(this));\n  }\n\n  message(event) {\n    const data = this._data(event);\n    if (data && data.command) {\n      this[data.command](data);\n    }\n  }\n\n  close(event) {\n    this.ws.close();\n    this.emit('end', event);\n  }\n\n  hello() {\n    this.send({\n      command: 'hello',\n      protocols: this.options.protocols,\n      serverName: this.options.serverName,\n    });\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(file => {\n      this.send({\n        command: 'reload',\n        files: [file],\n        liveReload: true,\n      });\n    });\n  }\n\n  _data(event) {\n    try {\n      return JSON.parse(event.data);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    return `${prefix || ''}${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n```"
  },
  {
    "Task_id": 229,
    "Instruction": "Task Description: Implement a LiveQueryClient class that manages WebSocket connections for real-time data updates in a Parse server environment, handling connection lifecycle, subscriptions, and error recovery.\n\nClass Description: The LiveQueryClient class establishes and maintains a WebSocket connection to a Parse LiveQuery server, manages subscriptions to queries, handles connection events (open, message, error, close), and implements automatic reconnection logic.\n\nAttributes:\n- attempts: number - Tracks reconnection attempts for exponential backoff\n- id: number - Unique client identifier assigned by server\n- requestId: number - Counter for subscription requests\n- applicationId: string - Parse application ID for authentication\n- serverURL: string - WebSocket server URL (must start with 'ws' or 'wss')\n- javascriptKey: string (optional) - JavaScript key for authentication\n- masterKey: string (optional) - Master key for authentication\n- sessionToken: string (optional) - User session token\n- installationId: string (optional) - Device installation identifier\n- additionalProperties: boolean - Flag to include additional properties in requests\n- connectPromise: Promise - Promise resolved when connection is established\n- subscriptions: Map<number, LiveQuerySubscription> - Active subscriptions\n- socket: WebSocketController - WebSocket connection controller\n- state: string - Current connection state (INITIALIZED, CONNECTING, CONNECTED, etc.)\n- reconnectHandle: any - Timeout handle for reconnection attempts\n- emitter: EventEmitter - Event emitter for connection events\n- on: function - Shortcut to emitter.on\n- emit: function - Shortcut to emitter.emit\n\nMethods:\n- constructor({applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId}) -> void - Initializes the client with connection parameters and validates serverURL\n- open() -> void - Establishes WebSocket connection and sets up event handlers\n- _handleWebSocketOpen() -> void - Sends connection request to server after WebSocket opens\n- _handleWebSocketMessage(event: any) -> void - Processes incoming messages from server and handles connection confirmation\n- _handleWebSocketClose() -> void - Handles connection closure and triggers reconnection\n- _handleWebSocketError(error: any) -> void - Handles WebSocket errors and triggers reconnection\n- _handleReconnect() -> void - Implements exponential backoff reconnection logic",
    "Canonical_solution": "import CoreManager, { WebSocketController } from './CoreManager';\nimport ParseObject from './ParseObject';\nimport LiveQuerySubscription from './LiveQuerySubscription';\nimport { resolvingPromise } from './promiseUtils';\nimport ParseError from './ParseError';\nimport type ParseQuery from './ParseQuery';\n\nclass LiveQueryClient {\n  attempts: number;\n  id: number;\n  requestId: number;\n  applicationId: string;\n  serverURL: string;\n  javascriptKey?: string;\n  masterKey?: string;\n  sessionToken?: string;\n  installationId?: string;\n  additionalProperties: boolean;\n  connectPromise: any;\n  subscriptions: Map<number, LiveQuerySubscription>;\n  socket: WebSocketController & { closingPromise?: any };\n  state: string;\n  reconnectHandle: any;\n  emitter: any;\n  on: any;\n  emit: any;\n\n  constructor({\n    applicationId,\n    serverURL,\n    javascriptKey,\n    masterKey,\n    sessionToken,\n    installationId,\n  }) {\n    if (!serverURL || serverURL.indexOf('ws') !== 0) {\n      throw new Error(\n        'You need to set a proper Parse LiveQuery server url before using LiveQueryClient'\n      );\n    }\n\n    this.reconnectHandle = null;\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.serverURL = serverURL;\n    this.applicationId = applicationId;\n    this.javascriptKey = javascriptKey || undefined;\n    this.masterKey = masterKey || undefined;\n    this.sessionToken = sessionToken || undefined;\n    this.installationId = installationId || undefined;\n    this.additionalProperties = true;\n    this.connectPromise = resolvingPromise();\n    this.subscriptions = new Map();\n    this.state = CLIENT_STATE.INITIALIZED;\n    const EventEmitter = CoreManager.getEventEmitter();\n    this.emitter = new EventEmitter();\n\n    this.on = (eventName, listener) => this.emitter.on(eventName, listener);\n    this.emit = (eventName, ...args) => this.emitter.emit(eventName, ...args);\n    this.on('error', () => {});\n  }\n\n  open() {\n    const WebSocketImplementation = CoreManager.getWebSocketController();\n    if (!WebSocketImplementation) {\n      this.emit(CLIENT_EMMITER_TYPES.ERROR, 'Can not find WebSocket implementation');\n      return;\n    }\n\n    if (this.state !== CLIENT_STATE.RECONNECTING) {\n      this.state = CLIENT_STATE.CONNECTING;\n    }\n\n    this.socket = new WebSocketImplementation(this.serverURL);\n    this.socket.closingPromise = resolvingPromise();\n\n    this.socket.onopen = () => {\n      this._handleWebSocketOpen();\n    };\n\n    this.socket.onmessage = event => {\n      this._handleWebSocketMessage(event);\n    };\n\n    this.socket.onclose = event => {\n      this.socket.closingPromise?.resolve(event);\n      this._handleWebSocketClose();\n    };\n\n    this.socket.onerror = error => {\n      this._handleWebSocketError(error);\n    };\n  }\n\n  _handleWebSocketOpen() {\n    const connectRequest = {\n      op: OP_TYPES.CONNECT,\n      applicationId: this.applicationId,\n      javascriptKey: this.javascriptKey,\n      masterKey: this.masterKey,\n      sessionToken: this.sessionToken,\n      installationId: undefined as string | undefined,\n    };\n    if (this.additionalProperties) {\n      connectRequest.installationId = this.installationId;\n    }\n    this.socket.send(JSON.stringify(connectRequest));\n  }\n\n  _handleWebSocketMessage(event: any) {\n    let data = event.data;\n    if (typeof data === 'string') {\n      data = JSON.parse(data);\n    }\n    let subscription: null | LiveQuerySubscription = null;\n    if (data.requestId) {\n      subscription = this.subscriptions.get(data.requestId) || null;\n    }\n    const response = {\n      clientId: data.clientId,\n      installationId: data.installationId,\n    };\n    switch (data.op) {\n    case OP_EVENTS.CONNECTED:\n      if (this.state === CLIENT_STATE.RECONNECTING) {\n        this.resubscribe();\n      }\n      this.emit(CLIENT_EMMITER_TYPES.OPEN);\n      this.id = data.clientId;\n      this.connectPromise.resolve();\n      this.state = CLIENT_STATE.CONNECTED;\n      break;\n    }\n  }\n\n  _handleWebSocketClose() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.CLOSED;\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE);\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error: any) {\n    this.emit(CLIENT_EMMITER_TYPES.ERROR, error);\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, error);\n    }\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.RECONNECTING;\n    const time = generateInterval(this.attempts);\n\n    if (this.reconnectHandle) {\n      clearTimeout(this.reconnectHandle);\n    }\n    this.reconnectHandle = setTimeout(\n      (() => {\n        this.attempts++;\n        this.connectPromise = resolvingPromise();\n        this.open();\n      }).bind(this),\n      time\n    );\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```typescript\nclass LiveQueryClient {\n  attempts: number;\n  id: number;\n  requestId: number;\n  applicationId: string;\n  serverURL: string;\n  javascriptKey: string;\n  masterKey: string;\n  sessionToken: string;\n  installationId: string;\n  additionalProperties: boolean;\n  connectPromise: Promise<any>;\n  subscriptions: Map<number, LiveQuerySubscription>;\n  socket: WebSocketController;\n  state: string;\n  reconnectHandle: any;\n  emitter: EventEmitter;\n  on: Function;\n  emit: Function;\n\n  constructor({\n    applicationId,\n    serverURL,\n    javascriptKey,\n    masterKey,\n    sessionToken,\n    installationId,\n  }) {\n    this.attempts = 0;\n    this.id = 0;\n    this.requestId = 0;\n    this.applicationId = applicationId;\n    this.serverURL = serverURL;\n    this.javascriptKey = javascriptKey;\n    this.masterKey = masterKey;\n    this.sessionToken = sessionToken;\n    this.installationId = installationId;\n    this.additionalProperties = true;\n    this.connectPromise = new Promise((resolve) => {\n      this.connectPromiseResolve = resolve;\n    });\n    this.subscriptions = new Map();\n    this.socket = new WebSocketController();\n    this.state = 'INITIALIZED';\n    this.reconnectHandle = null;\n    this.emitter = new EventEmitter();\n    this.on = this.emitter.on.bind(this.emitter);\n    this.emit = this.emitter.emit.bind(this.emitter);\n\n    if (!/^wss?:\\/\\//.test(this.serverURL)) {\n      throw new Error('serverURL must start with ws:// or wss://');\n    }\n  }\n\n  open() {\n    this.state = 'CONNECTING';\n    this.socket.open(this.serverURL);\n    this.socket.on('open', this._handleWebSocketOpen.bind(this));\n    this.socket.on('message', this._handleWebSocketMessage.bind(this));\n    this.socket.on('close', this._handleWebSocketClose.bind(this));\n    this.socket.on('error', this._handleWebSocketError.bind(this));\n  }\n\n  _handleWebSocketOpen() {\n    this.emit('open');\n    this._sendConnectionRequest();\n  }\n\n  _handleWebSocketMessage(event) {\n    const data = JSON.parse(event.data);\n    if (data.action === 'connected') {\n      this.id = data.clientId;\n      this.state = 'CONNECTED';\n      this.connectPromiseResolve();\n      this.emit('connected', data);\n    } else if (data.action === 'subscribed') {\n      const subscription = this.subscriptions.get(data.requestId);\n      if (subscription) {\n        subscription.handleSubscribeResponse(data);\n      }\n    } else if (data.action === 'unsubscribed') {\n      const subscription = this.subscriptions.get(data.requestId);\n      if (subscription) {\n        subscription.handleUnsubscribeResponse(data);\n      }\n    } else if (data.action === 'message') {\n      const subscription = this.subscriptions.get(data.subscriptionId);\n      if (subscription) {\n        subscription.handleMessage(data);\n      }\n    }\n  }\n\n  _handleWebSocketClose() {\n    this.state = 'DISCONNECTED';\n    this.emit('close');\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error) {\n    this.state = 'ERROR';\n    this.emit('error', error);\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    if (this.reconnectHandle) {\n      clearTimeout(this.reconnectHandle);\n    }\n    const delay = Math.min(1000 * Math.pow(2, this.attempts), 30000);\n    this.reconnectHandle = setTimeout(() => {\n      this.attempts++;\n      this.open();\n    }, delay);\n  }\n\n  _sendConnectionRequest() {\n    const request = {\n      action: 'connect',\n      applicationId: this.applicationId,\n      installationId: this.installationId,\n      sessionToken: this.sessionToken,\n      javascriptKey: this.javascriptKey,\n      masterKey: this.masterKey,\n      useMasterKey: !!this.masterKey,\n      useSSL: this.serverURL.startsWith('wss:'),\n      version: 3,\n      additionalProperties: this.additionalProperties,\n    };\n    this.socket.send(JSON.stringify(request));\n  }\n}\n```\n"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a function that interacts with Microsoft's Speech API to convert SSML (Speech Synthesis Markup Language) text into speech audio using HTTP requests.\n\nFunction Description: The function `speechApi` sends a POST request to Microsoft's Speech API endpoint with SSML text as input and receives audio data in MP3 format as response. It handles the HTTP communication including request configuration, headers, payload, and error handling.\n\nInput: \n- ssml: [String] - The SSML formatted text to be converted to speech\n\nOutput: \n- [Promise] - Resolves with the audio data in arraybuffer format if successful, rejects with error if the request fails",
    "Canonical_solution": "const axios = require(\"axios\");\nconst { v4: uuidv4 } = require(\"uuid\");\n\nfunction speechApi(ssml) {\n    var data = JSON.stringify({\n        ssml,\n        ttsAudioFormat: \"audio-24khz-160kbitrate-mono-mp3\",\n        offsetInPlainText: 0,\n        properties: {\n            SpeakTriggerSource: \"AccTuningPagePlayButton\",\n        },\n    });\n\n    var config = {\n        method: \"post\",\n        url: \"https://southeastasia.api.speech.microsoft.com/accfreetrial/texttospeech/acc/v3.0-beta1/vcg/speak\",\n        responseType: \"arraybuffer\",\n        headers: {\n            authority: \"southeastasia.api.speech.microsoft.com\",\n            accept: \"*/*\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            customvoiceconnectionid: uuidv4(),\n            origin: \"https://speech.microsoft.com\",\n            \"sec-ch-ua\": '\"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-site\",\n            \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\",\n            \"content-type\": \"application/json\",\n        },\n        data: data,\n    };\n\n    return new Promise((resolve, reject) => {\n        axios(config)\n            .then(function(response) {\n                resolve(response.data);\n            })\n            .catch(function(error) {\n                console.error(error);\n                reject(error);\n            });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst fetch = require('node-fetch');\n\nasync function speechApi(ssml) {\n  const subscriptionKey = 'YOUR_SUBSCRIPTION_KEY';\n  const serviceRegion = 'YOUR_SERVICE_REGION';\n  const endpoint = `https://${serviceRegion}.tts.speech.microsoft.com/cognitiveservices/v1`;\n\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/ssml+xml',\n      'X-Microsoft-OutputFormat': 'audio-24khz-160kbitrate-mono-mp3',\n      'Authorization': `Bearer ${subscriptionKey}`\n    },\n    body: ssml\n  };\n\n  try {\n    const response = await fetch(endpoint, options);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const audioData = await response.arrayBuffer();\n    return audioData;\n  } catch (error) {\n    throw new Error(`Failed to convert SSML to speech: ${error.message}`);\n  }\n}\n```"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that connects to a server, sends messages, and displays received messages in a chat interface.\n\nFunction Description: The function `setupWebSocket` initializes a WebSocket connection to a server when a button is clicked. It handles connection events (open, close, message) and allows sending messages via an input field. The function disables the join button during active connection and re-enables it when closed.\n\nInput: \n- None (the function uses DOM elements internally: username input, join button, chat textarea, and message input field)\n\nOutput: \n- None (the function sets up event listeners and modifies DOM elements directly)\n\nAttributes: N/A (function-level implementation)\n\nMethods: N/A (function-level implementation)",
    "Canonical_solution": "function setupWebSocket() {\n    const username = document.querySelector(\"#username\");\n    const join_btn = document.querySelector(\"#join-chat\");\n    const textarea = document.querySelector(\"#chat\");\n    const input = document.querySelector(\"#input\");\n\n    join_btn.addEventListener(\"click\", function(e) {\n        this.disabled = true;\n\n        const websocket = new WebSocket(\"ws://localhost:3000/websocket\");\n\n        websocket.onopen = function() {\n            console.log(\"connection opened\");\n            websocket.send(username.value);\n        }\n\n        const btn = this;\n\n        websocket.onclose = function() {\n            console.log(\"connection closed\");\n            btn.disabled = false;\n        }\n\n        websocket.onmessage = function(e) {\n            console.log(\"received message: \"+e.data);\n            textarea.value += e.data+\"\\r\\n\";\n        }\n\n        input.onkeydown = function(e) {\n            if (e.key == \"Enter\") {\n                websocket.send(input.value);\n                input.value = \"\";\n            }\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nfunction setupWebSocket() {\n  const usernameInput = document.getElementById('username');\n  const joinButton = document.getElementById('join');\n  const chatTextarea = document.getElementById('chat');\n  const messageInput = document.getElementById('message');\n  const sendButton = document.getElementById('send');\n\n  joinButton.addEventListener('click', () => {\n    const username = usernameInput.value;\n    const socket = new WebSocket('ws://localhost:8080');\n\n    socket.addEventListener('open', () => {\n      joinButton.disabled = true;\n      chatTextarea.textContent = '';\n      chatTextarea.textContent += `${username} has joined the chat.\\n`;\n    });\n\n    socket.addEventListener('close', () => {\n      joinButton.disabled = false;\n      chatTextarea.textContent += 'Connection closed.\\n';\n    });\n\n    socket.addEventListener('message', (event) => {\n      chatTextarea.textContent += `${event.data}\\n`;\n    });\n\n    sendButton.addEventListener('click', () => {\n      const message = messageInput.value;\n      socket.send(`${username}: ${message}`);\n      messageInput.value = '';\n    });\n  });\n}\n```"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a class that serves as an HTTP client for interacting with a build service API, handling different types of package-related operations with proper error handling.\n\nClass Description: The BuildService class provides methods to fetch package build statistics, exports, and export sizes from a remote build service. It uses Axios for HTTP requests and implements centralized error handling.\n\nAttributes:\n- operations: [Array] - A predefined list of available API operations, each specifying the operation type, endpoint, and corresponding method name\n\nMethods:\n- _makeHttpRequest: [Name](operation: Object, packageString: String) -> Promise<Object> - Makes an HTTP GET request to the build service with the specified operation and package string, handles the response and errors\n- _handleError: [Name](error: Error, operationType: String) -> Throws CustomError - Centralized error handling that processes different types of errors (response errors, request errors, and other errors) and throws appropriate custom errors\n- getPackageBuildStats: [Name](packageString: String) -> Promise<Object> - Retrieves build statistics for the specified package\n- getPackageExports: [Name](packageString: String) -> Promise<Object> - Retrieves all exports for the specified package\n- getPackageExportSizes: [Name](packageString: String) -> Promise<Object> - Retrieves size information for all exports of the specified package",
    "Canonical_solution": "const axios = require('axios');\nconst CustomError = require('../CustomError');\n\nclass BuildService {\n  constructor() {\n    this.operations = [\n      {\n        type: 'PACKAGE_BUILD_STATS',\n        endpoint: '/size',\n        methodName: 'getPackageStats',\n      },\n      {\n        type: 'PACKAGE_EXPORTS',\n        endpoint: '/exports',\n        methodName: 'getAllPackageExports',\n      },\n      {\n        type: 'PACKAGE_EXPORTS_SIZES',\n        endpoint: '/exports-sizes',\n        methodName: 'getPackageExportSizes',\n      },\n    ];\n  }\n\n  async _makeHttpRequest(operation, packageString) {\n    try {\n      const response = await axios.get(\n        `${process.env.BUILD_SERVICE_ENDPOINT}${operation.endpoint}?p=${encodeURIComponent(packageString)}`\n      );\n      return response.data;\n    } catch (error) {\n      this._handleError(error, operation.type);\n    }\n  }\n\n  _handleError(error, operationType) {\n    if (error.response) {\n      const contents = error.response.data;\n      throw new CustomError(\n        contents.name || 'BuildError',\n        contents.originalError,\n        contents.extra\n      );\n    } else if (error.request) {\n      throw new CustomError('BuildError', {\n        operation: operationType,\n        reason: 'BUILD_SERVICE_UNREACHABLE',\n        url: error.request._currentUrl,\n      });\n    } else {\n      throw new CustomError('BuildError', error.message, {\n        operation: operationType,\n      });\n    }\n  }\n\n  async getPackageBuildStats(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_BUILD_STATS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExports(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExportSizes(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS_SIZES');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```typescript\nimport axios from 'axios';\n\nclass BuildService {\n  private operations: { type: string, endpoint: string, methodName: string }[];\n\n  constructor() {\n    this.operations = [\n      { type: 'buildStats', endpoint: '/build/stats', methodName: 'getPackageBuildStats' },\n      { type: 'exports', endpoint: '/exports', methodName: 'getPackageExports' },\n      { type: 'exportSizes', endpoint: '/export/sizes', methodName: 'getPackageExportSizes' }\n    ];\n  }\n\n  private async _makeHttpRequest(operation: { type: string, endpoint: string, methodName: string }, packageString: string): Promise<Object> {\n    try {\n      const response = await axios.get(`${operation.endpoint}/${packageString}`);\n      return response.data;\n    } catch (error) {\n      this._handleError(error, operation.type);\n    }\n  }\n\n  private _handleError(error: Error, operationType: string): void {\n    if (error.response) {\n      // The request was made and the server responded with a status code\n      // that falls out of the range of 2xx\n      throw new Error(`API Error: ${error.response.data.message}`);\n    } else if (error.request) {\n      // The request was made but no response was received\n      throw new Error(`Request Error: No response received for ${operationType}`);\n    } else {\n      // Something happened in setting up the request that triggered an Error\n      throw new Error(`Error: ${error.message}`);\n    }\n  }\n\n  public async getPackageBuildStats(packageString: string): Promise<Object> {\n    const operation = this.operations.find(op => op.methodName === 'getPackageBuildStats');\n    return this._makeHttpRequest(operation, packageString);\n  }\n\n  public async getPackageExports(packageString: string): Promise<Object> {\n    const operation = this.operations.find(op => op.methodName === 'getPackageExports');\n    return this._makeHttpRequest(operation, packageString);\n  }\n\n  public async getPackageExportSizes(packageString: string): Promise<Object> {\n    const operation = this.operations.find(op => op.methodName === 'getPackageExportSizes');\n    return this._makeHttpRequest(operation, packageString);\n  }\n}\n```"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Implement a WebSocket client class for streaming timeline data from a server, handling connection events, message parsing, and connection cleanup.\n\nClass Description: The TimelineStream class establishes and manages a WebSocket connection to stream timeline data from a specified API endpoint. It handles connection setup, message reception, error handling, and proper connection closure.\n\nAttributes:\n- _streamingApi: [String] - The base URL of the streaming API server\n- _accessToken: [String] - Authentication token for the API connection\n- _timeline: [String] - Identifier for the specific timeline stream\n- _ws: [WebSocketClient] - Instance of the WebSocket connection\n- _opened: [Boolean] - Flag indicating if the connection is established\n\nMethods:\n- constructor(streamingApi, accessToken, timeline) -> [TimelineStream] - Initializes a new TimelineStream instance with API details and sets up the WebSocket connection\n- _setupWebSocket() -> [void] - Creates a new WebSocket connection, configures event handlers for open, message, and close events\n- _closeWebSocket() -> [void] - Properly closes the WebSocket connection and cleans up event handlers\n- sendMessage(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Public method to close the WebSocket connection",
    "Canonical_solution": "import { WebSocketClient } from '../../_thirdparty/websocket/websocket.js'\nimport { getStreamUrl } from './getStreamUrl.js'\nimport { safeParse } from '../../_utils/safeParse.js'\n\nclass TimelineStream {\n  constructor (streamingApi, accessToken, timeline) {\n    this._streamingApi = streamingApi\n    this._accessToken = accessToken\n    this._timeline = timeline\n    this._setupWebSocket()\n  }\n\n  _setupWebSocket () {\n    const url = getStreamUrl(this._streamingApi, this._accessToken, this._timeline)\n    const ws = new WebSocketClient(url)\n\n    ws.onopen = () => {\n      if (!this._opened) {\n        this._opened = true\n      }\n    }\n    ws.onmessage = (e) => safeParse(e.data)\n    ws.onclose = () => {}\n\n    this._ws = ws\n  }\n\n  _closeWebSocket () {\n    if (this._ws) {\n      this._ws.onopen = null\n      this._ws.onmessage = null\n      this._ws.onclose = null\n      this._ws.close()\n      this._ws = null\n    }\n  }\n\n  sendMessage (message) {\n    if (this._ws && this._ws.readyState === WebSocketClient.OPEN) {\n      this._ws.send(message)\n    }\n  }\n\n  close () {\n    this._closeWebSocket()\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```typescript\nclass TimelineStream {\n  private _streamingApi: string;\n  private _accessToken: string;\n  private _timeline: string;\n  private _ws: WebSocketClient;\n  private _opened: boolean;\n\n  constructor(streamingApi: string, accessToken: string, timeline: string) {\n    this._streamingApi = streamingApi;\n    this._accessToken = accessToken;\n    this._timeline = timeline;\n    this._ws = null;\n    this._opened = false;\n    this._setupWebSocket();\n  }\n\n  private _setupWebSocket() {\n    const url = `${this._streamingApi}/timeline/${this._timeline}?access_token=${this._accessToken}`;\n    this._ws = new WebSocketClient(url);\n\n    this._ws.on('open', () => {\n      this._opened = true;\n      console.log('WebSocket connection opened');\n    });\n\n    this._ws.on('message', (message) => {\n      const parsedMessage = JSON.parse(message);\n      // Handle parsed message\n    });\n\n    this._ws.on('close', () => {\n      this._opened = false;\n      console.log('WebSocket connection closed');\n    });\n\n    this._ws.on('error', (error) => {\n      console.error('WebSocket error:', error);\n    });\n  }\n\n  private _closeWebSocket() {\n    if (this._ws) {\n      this._ws.close();\n      this._ws = null;\n    }\n  }\n\n  sendMessage(message: string) {\n    if (this._opened && this._ws) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._closeWebSocket();\n  }\n}\n```"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Write a function that retrieves TV channel data from a specified URL, processes the data to extract relevant channel information, and returns it in a structured format.\n\nFunction Description: The function `getChannels` asynchronously fetches TV channel data from a remote API endpoint using HTTP GET request. It processes the response to extract channel details such as language, site ID, and name, then returns them as an array of objects. Error handling is included to log any issues during the request.\n\nInput: None (The function does not take any input parameters; it uses a hardcoded URL for the API endpoint.)\n\nOutput: An array of objects, where each object represents a TV channel with the following properties:\n- `lang`: [String] - The language of the channel (e.g., 'lv').\n- `site_id`: [String] - The unique identifier/slug for the channel.\n- `name`: [String] - The display name of the channel.\n\nIf an error occurs during the HTTP request, the error will be logged to the console, and the function may return an empty array or undefined depending on the error handling flow.",
    "Canonical_solution": "async function getChannels() {\n    const axios = require('axios');\n    const groups = await axios\n        .get('https://www.tv.lv/data/channels/lvall')\n        .then(r => r.data)\n        .catch(console.log);\n\n    let channels = [];\n\n    groups.forEach(group => {\n        group.channels.forEach(item => {\n            channels.push({\n                lang: 'lv',\n                site_id: item.slug,\n                name: item.name\n            });\n        });\n    });\n\n    return channels;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function getChannels() {\n  const url = 'https://api.example.com/tv-channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    const channels = data.channels.map(channel => ({\n      lang: channel.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n    return channels;\n  } catch (error) {\n    console.error('Failed to fetch TV channels:', error);\n    return [];\n  }\n}\n```"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a WebSocket server, handles connection events, sends messages, and manages errors and closures.\n\nFunction Description: The function `connectWebSocket` initializes a WebSocket client connection to a specified server. It sets up event handlers for connection opening, incoming messages, and connection closing. The function also sends an initial message upon successful connection and logs all events to the console.\n\nInput: \n- Optional command line arguments:\n  - `port` (number): The port number to connect to (default: 7000).\n  - `secure` (boolean): Whether to use a secure WebSocket connection (wss) (default: false, uses ws).\n\nOutput: \n- No explicit return value. The function logs connection status, received messages, and closure events to the console.\n- Side effects: Establishes a WebSocket connection and sends/receives messages.",
    "Canonical_solution": "function connectWebSocket() {\n    var WebSocket = require('../lib/faye/websocket'),\n        port = process.argv[2] || 7000,\n        secure = process.argv[3] === 'ssl',\n        scheme = secure ? 'wss' : 'ws',\n        ws = new WebSocket.Client(scheme + '://localhost:' + port + '/');\n\n    console.log('Connecting to ' + ws.url);\n\n    ws.onopen = function(event) {\n        console.log('open');\n        ws.send('Hello, WebSocket!');\n    };\n\n    ws.onmessage = function(event) {\n        console.log('message', event.data);\n    };\n\n    ws.onclose = function(event) {\n        console.log('close', event.code, event.reason);\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nconst WebSocket = require('ws');\n\nfunction connectWebSocket(port = 7000, secure = false) {\n  const protocol = secure ? 'wss' : 'ws';\n  const ws = new WebSocket(`${protocol}://localhost:${port}`);\n\n  ws.on('open', () => {\n    console.log('Connected to WebSocket server');\n    ws.send('Hello, WebSocket server!');\n  });\n\n  ws.on('message', (message) => {\n    console.log('Received message:', message);\n  });\n\n  ws.on('close', (code, reason) => {\n    console.log('WebSocket connection closed:', code, reason);\n  });\n\n  ws.on('error', (error) => {\n    console.error('WebSocket error:', error);\n  });\n}\n\nmodule.exports = connectWebSocket;\n```"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes a connection to a server, handles incoming messages, manages connection errors, and provides functionality to close the connection.\n\nClass Description: The WebSocketClient class encapsulates WebSocket functionality for establishing and managing a WebSocket connection. It handles connection events, message reception, and error scenarios, while providing a clean interface for external message handling through a callback.\n\nAttributes:\n- url: [String] - The server URL to connect to (without protocol)\n- actionId: [String] - An identifier for the specific WebSocket action/channel\n- onMessageCallback: [Function] - Callback function to handle incoming messages\n- socket: [WebSocket|null] - Reference to the WebSocket connection instance\n- initData: [Boolean] - Flag indicating whether initial data has been received\n- WebSocket: [WebSocket|null] - Alias for the socket instance (set after successful connection)\n\nMethods:\n- constructor(url, actionId, onMessageCallback) -> [void] - Initializes the WebSocketClient with connection URL, action ID, and message callback\n- connect() -> [void] - Establishes the WebSocket connection and sets up event handlers\n- close() -> [void] - Closes the WebSocket connection if it exists",
    "Canonical_solution": "import axios from 'axios';\n\nclass WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n  }\n\n  connect() {\n    try {\n      this.socket = new WebSocket(\n        `${location.protocol === 'https:' ? 'wss' : 'ws'}://${this.url}/api/interface/solve_conflict?id=${this.actionId}`\n      );\n\n      this.socket.onopen = () => {\n        this.WebSocket = this.socket;\n      };\n\n      this.socket.onmessage = (e) => {\n        this.initData = true;\n        const result = JSON.parse(e.data);\n        this.onMessageCallback(result);\n      };\n\n      this.socket.onerror = () => {\n        console.warn('websocket \u8fde\u63a5\u5931\u8d25\uff0c\u5c06\u5bfc\u81f4\u591a\u4eba\u7f16\u8f91\u540c\u4e00\u4e2a\u63a5\u53e3\u51b2\u7a81\u3002');\n      };\n\n    } catch (e) {\n      console.error('websocket \u8fde\u63a5\u5931\u8d25\uff0c\u5c06\u5bfc\u81f4\u591a\u4eba\u7f16\u8f91\u540c\u4e00\u4e2a\u63a5\u53e3\u51b2\u7a81\u3002');\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nclass WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n    this.WebSocket = WebSocket;\n  }\n\n  connect() {\n    this.socket = new this.WebSocket(`ws://${this.url}/ws/${this.actionId}/`);\n    this.socket.onopen = () => {\n      console.log('WebSocket connection established');\n    };\n    this.socket.onmessage = (event) => {\n      if (!this.initData) {\n        this.initData = true;\n        return;\n      }\n      this.onMessageCallback(event.data);\n    };\n    this.socket.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n    this.socket.onclose = () => {\n      console.log('WebSocket connection closed');\n    };\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Implement a WebSocket server class for peer-to-peer communication that handles connections, messages, and room management.\n\nClass Description: The SnapdropServer class represents a WebSocket server that facilitates peer-to-peer communication. It manages WebSocket connections, handles incoming messages, and maintains rooms for peer grouping. The server also handles connection headers and keeps connections alive.\n\nAttributes:\n- _wss: [WebSocket.Server] - The WebSocket server instance\n- _rooms: [Object] - A dictionary tracking peers grouped by their IP addresses (rooms)\n\nMethods:\n- constructor(port: number) -> void - Initializes the WebSocket server on the specified port and sets up event handlers\n- _onConnection(peer: Peer) -> void - Handles new WebSocket connections, sets up message handlers, and joins the peer to a room\n- _onHeaders(headers: Array, response: Object) -> void - Processes HTTP headers during WebSocket handshake, setting cookies if needed\n- _onMessage(sender: Peer, message: string) -> void - Handles incoming messages from peers, routing them to appropriate recipients\n- _send(peer: Peer, message: Object) -> void - Sends a message to a specific peer over WebSocket connection\n- _joinRoom(peer: Peer) -> void - Adds a peer to their respective room (Not shown in reference but implied)\n- _leaveRoom(peer: Peer) -> void - Removes a peer from their room (Not shown in reference but implied)\n- _keepAlive(peer: Peer) -> void - Maintains connection with periodic pings (Not shown in reference but implied)",
    "Canonical_solution": "const WebSocket = require('ws');\n\nclass SnapdropServer {\n    constructor(port) {\n        this._wss = new WebSocket.Server({ port: port });\n        this._wss.on('connection', (socket, request) => this._onConnection(new Peer(socket, request)));\n        this._wss.on('headers', (headers, response) => this._onHeaders(headers, response));\n\n        this._rooms = {};\n    }\n\n    _onConnection(peer) {\n        this._joinRoom(peer);\n        peer.socket.on('message', message => this._onMessage(peer, message));\n        peer.socket.on('error', console.error);\n        this._keepAlive(peer);\n\n        this._send(peer, {\n            type: 'display-name',\n            message: {\n                displayName: peer.name.displayName,\n                deviceName: peer.name.deviceName\n            }\n        });\n    }\n\n    _onHeaders(headers, response) {\n        if (response.headers.cookie && response.headers.cookie.indexOf('peerid=') > -1) return;\n        response.peerId = Peer.uuid();\n        headers.push('Set-Cookie: peerid=' + response.peerId + \"; SameSite=Strict; Secure\");\n    }\n\n    _onMessage(sender, message) {\n        try {\n            message = JSON.parse(message);\n        } catch (e) {\n            return;\n        }\n\n        switch (message.type) {\n            case 'disconnect':\n                this._leaveRoom(sender);\n                break;\n            case 'pong':\n                sender.lastBeat = Date.now();\n                break;\n        }\n\n        if (message.to && this._rooms[sender.ip]) {\n            const recipientId = message.to;\n            const recipient = this._rooms[sender.ip][recipientId];\n            delete message.to;\n            message.sender = sender.id;\n            this._send(recipient, message);\n            return;\n        }\n    }\n\n    _send(peer, message) {\n        if (!peer) return;\n        if (this._wss.readyState !== this._wss.OPEN) return;\n        message = JSON.stringify(message);\n        peer.socket.send(message, error => '');\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "```typescript\nimport * as WebSocket from 'ws';\n\nclass SnapdropServer {\n  private _wss: WebSocket.Server;\n  private _rooms: { [key: string]: Peer[] };\n\n  constructor(port: number) {\n    this._wss = new WebSocket.Server({ port });\n    this._rooms = {};\n\n    this._wss.on('connection', this._onConnection.bind(this));\n    this._wss.on('headers', this._onHeaders.bind(this));\n  }\n\n  private _onConnection(peer: Peer) {\n    peer.on('message', this._onMessage.bind(this, peer));\n    this._joinRoom(peer);\n    this._keepAlive(peer);\n  }\n\n  private _onHeaders(headers: Array, response: Object) {\n    // Set cookies if needed\n  }\n\n  private _onMessage(sender: Peer, message: string) {\n    const data = JSON.parse(message);\n    const room = this._rooms[sender.ip];\n\n    if (data.type === 'offer') {\n      room.forEach((peer) => {\n        if (peer !== sender) {\n          this._send(peer, data);\n        }\n      });\n    } else if (data.type === 'answer') {\n      const target = room.find((peer) => peer.id === data.target);\n      if (target) {\n        this._send(target, data);\n      }\n    } else if (data.type === 'candidate') {\n      const target = room.find((peer) => peer.id === data.target);\n      if (target) {\n        this._send(target, data);\n      }\n    }\n  }\n\n  private _send(peer: Peer, message: Object) {\n    peer.send(JSON.stringify(message));\n  }\n\n  private _joinRoom(peer: Peer) {\n    if (!this._rooms[peer.ip]) {\n      this._rooms[peer.ip] = [];\n    }\n    this._rooms[peer.ip].push(peer);\n  }\n\n  private _leaveRoom(peer: Peer) {\n    const room = this._rooms[peer.ip];\n    if (room) {\n      const index = room.indexOf(peer);\n      if (index > -1) {\n        room.splice(index, 1);\n      }\n    }\n  }\n\n  private _keepAlive(peer: Peer) {\n    // Implement keep-alive logic\n  }\n}\n```\n"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a WebSocket server in Node.js that handles client connections, tracks connection counts, and provides broadcast functionality to all connected clients.\n\nFunction Description: The function creates and configures a WebSocket server instance. It maintains a count of active connections, logs connection/disconnection events, and provides a broadcast method to send data to all connected clients. The server handles WebSocket connections on the specified port.\n\nInput: \n- port: [Number] - The port number on which the WebSocket server should listen for connections\n\nOutput:\n- Returns: [WebSocket.Server] - An instance of WebSocket server with additional connection tracking and broadcast functionality\n\nAttributes:\n- connectionCount: [Number] - Tracks the number of active WebSocket connections\n\nMethods:\n- broadcast: [Name](data) -> [void] - Sends the provided data to all connected clients that are in OPEN state\n- on: [Name](event, callback) -> [void] - Inherited from WebSocket.Server to handle server events ('connection', 'error', etc.)",
    "Canonical_solution": "function createWebSocketServer(port) {\n    var WebSocket = require('ws');\n    var socketServer = new WebSocket.Server({port: port, perMessageDeflate: false});\n    socketServer.connectionCount = 0;\n    socketServer.on('connection', function(socket, upgradeReq) {\n        socketServer.connectionCount++;\n        console.log(\n            'New WebSocket Connection: ',\n            (upgradeReq || socket.upgradeReq).socket.remoteAddress,\n            (upgradeReq || socket.upgradeReq).headers['user-agent'],\n            '('+socketServer.connectionCount+' total)'\n        );\n        socket.on('close', function(code, message){\n            socketServer.connectionCount--;\n            console.log(\n                'Disconnected WebSocket ('+socketServer.connectionCount+' total)'\n            );\n        });\n    });\n    socketServer.broadcast = function(data) {\n        socketServer.clients.forEach(function each(client) {\n            if (client.readyState === WebSocket.OPEN) {\n                client.send(data);\n            }\n        });\n    };\n    return socketServer;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "wrong_result": "```javascript\nconst WebSocket = require('ws');\n\nclass CustomWebSocketServer extends WebSocket.Server {\n  constructor(port) {\n    super({ port });\n    this.connectionCount = 0;\n    this.on('connection', this.handleConnection);\n  }\n\n  handleConnection = (ws) => {\n    this.connectionCount++;\n    console.log(`New connection: ${this.connectionCount}`);\n    ws.on('close', () => {\n      this.connectionCount--;\n      console.log(`Connection closed: ${this.connectionCount}`);\n    });\n  }\n\n  broadcast = (data) => {\n    this.clients.forEach(client => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(data);\n      }\n    });\n  }\n\n  on = (event, callback) => {\n    super.on(event, callback);\n  }\n}\n\nmodule.exports = CustomWebSocketServer;\n```"
  },
  {
    "Task_id": 265,
    "Instruction": "Task Description: Create a WebSocket server class in Node.js that handles incoming connections, manages sessions, and processes messages with customizable handlers.\n\nClass Description: The XVIZServer class is a WebSocket server implementation that manages WebSocket connections, delegates session handling to provided handlers, and provides logging capabilities. It wraps the 'ws' library functionality with additional session management features.\n\nAttributes:\n- _server: [WebSocket.Server] - The underlying WebSocket server instance\n- handlers: [Array] - Array of handler objects responsible for managing sessions\n- options: [Object] - Configuration options for the server, merged with defaults\n\nMethods:\n- constructor(handlers, options, callback) -> [XVIZServer] - Initializes the WebSocket server with message handlers, options, and an optional callback. Throws an error if no handlers are provided.\n- get server() -> [WebSocket.Server] - Getter for the underlying WebSocket server instance\n- close(cb) -> [void] - Closes the WebSocket server, accepting an optional callback\n- handleSession(socket, request) -> [Promise<void>] - Handles new WebSocket connections, delegates to handlers for session creation, and closes the connection if no handler accepts it\n- log(...msg) -> [void] - Logs messages using the configured logger if available",
    "Canonical_solution": "const WebSocket = require('ws');\n\nexport class XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers) {\n      throw new Error('Must specify a handler for messages');\n    }\n\n    this.handlers = handlers;\n    this.options = Object.assign(DEFAULT_OPTIONS, options);\n    this._server = new WebSocket.Server(this.options, callback);\n\n    this.server.on('connection', (socket, request) => this.handleSession(socket, request));\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this._server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    this.log(`[> Connection] created: ${request.url}`);\n    const req = getRequestData(request.url);\n\n    for (const handler of this.handlers) {\n      const session = await handler.newSession(socket, req);\n      if (session) {\n        session.onConnect();\n        return;\n      }\n    }\n\n    socket.close();\n    this.log('[> Connection] closed due to no handler found');\n  }\n\n  log(...msg) {\n    const {logger} = this.options;\n    if (logger && logger.log) {\n      logger.log(...msg);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "```javascript\nclass XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || !handlers.length) {\n      throw new Error('No handlers provided');\n    }\n    this.handlers = handlers;\n    this.options = { ...this.defaultOptions, ...options };\n    this._server = new WebSocket.Server(this.options);\n    this._server.on('connection', this.handleSession.bind(this));\n    if (callback) {\n      callback();\n    }\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this._server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    for (const handler of this.handlers) {\n      const session = await handler.createSession(socket, request);\n      if (session) {\n        this.log(`Session created: ${session.id}`);\n        session.on('close', () => this.log(`Session closed: ${session.id}`));\n        return;\n      }\n    }\n    this.log('No handler accepted the session');\n    socket.close();\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n\n  get defaultOptions() {\n    return {\n      noServer: true,\n      perMessageDeflate: false,\n      verifyClient: () => true,\n      logger: console.log\n    };\n  }\n}\n```\n"
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Create a WebSocket server class that manages WebSocket connections for a webview application, handling connection events and maintaining active connections.\n\nClass Description: The WebviewServer class is responsible for setting up and managing a WebSocket server that facilitates real-time communication between a webview application and a data source. It maintains active connections and provides server information.\n\nAttributes:\n- server: [http.Server] - The underlying HTTP server instance used for WebSocket communication\n- secret: [string] - A secret string used for authentication or security purposes\n- connections: [Set<WebviewConnection>] - A collection of active WebSocket connections\n- config: [Config] - Configuration object containing server settings\n\nMethods:\n- constructor(dataSource: [VisualizationWatchModel], config: [Config]) -> [void] - Initializes the WebSocket server, sets up connection handlers, and stores the configuration\n- get port() -> [number] - Returns the port number on which the server is listening for connections",
    "Canonical_solution": "import { WebSocketStream } from \"@hediet/typed-json-rpc-websocket\";\nimport WebSocket = require(\"ws\");\nimport * as express from \"express\";\nimport * as http from \"http\";\n\nexport class WebviewServer {\n\tprivate readonly server: http.Server;\n\tpublic readonly secret: string;\n\n\tpublic readonly connections = new Set<WebviewConnection>();\n\n\tconstructor(\n\t\tdataSource: VisualizationWatchModel,\n\t\tprivate readonly config: Config\n\t) {\n\t\tconst app = express();\n\t\tthis.server = app.listen();\n\n\t\tconst wss = new WebSocket.Server({ server: this.server });\n\t\twss.on(\"connection\", async ws => {\n\t\t\tconst stream = new WebSocketStream(ws);\n\t\t\tconst c = new WebviewConnection(\n\t\t\t\tdataSource,\n\t\t\t\tstream,\n\t\t\t\tthis,\n\t\t\t\tconfig,\n\t\t\t\tthis.secret\n\t\t\t);\n\t\t\tthis.connections.add(c);\n\t\t\tawait stream.onClosed;\n\t\t\tthis.connections.delete(c);\n\t\t});\n\t}\n\n\tpublic get port(): number {\n\t\tconst httpPort = (this.server.address() as AddressInfo).port;\n\t\treturn httpPort;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "```typescript\nimport { Server } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { WebviewConnection } from './WebviewConnection';\nimport { Config } from './Config';\n\nexport class WebviewServer {\n  private server: Server;\n  private secret: string;\n  private connections: Set<WebviewConnection>;\n  private config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.server = new Server();\n    this.secret = config.secret;\n    this.connections = new Set();\n    this.config = config;\n\n    const wss = new WebSocketServer({ server: this.server });\n\n    wss.on('connection', (ws) => {\n      const connection = new WebviewConnection(ws, this.secret, dataSource);\n      this.connections.add(connection);\n\n      connection.on('close', () => {\n        this.connections.delete(connection);\n      });\n    });\n  }\n\n  get port(): number {\n    return this.server.address().port;\n  }\n}\n```"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Create a class that implements HTTP client functionality using Axios for making HTTP requests with support for GET and POST methods, including proper header and parameter handling.\n\nClass Description: HTTPClient is a class that provides HTTP request capabilities using Axios as the underlying library. It handles request configuration, parameter serialization, content-type detection, and response processing.\n\nAttributes:\n- requestModule: [String] - Specifies the HTTP library being used (default: 'axios')\n\nMethods:\n- httpRequest: [async](options) -> [Object] - Makes an HTTP request based on provided options\n  - options: [Object] - Configuration object containing:\n    - method: [String] - HTTP method (GET/POST)\n    - url: [String] - Request URL\n    - headers: [Object] - Request headers\n    - params: [Object] - Query parameters\n    - body: [Object|String] - Request payload\n- queryStr: [function](options) -> [String] - Converts an object to URL-encoded query string\n  - options: [Object] - Key-value pairs to serialize\n- isJSONString: [function](str) -> [Boolean] - Checks if a string is valid JSON\n  - str: [String] - String to validate\n- isJson: [function](obj) -> [Boolean] - Checks if an object is a plain JSON object\n  - obj: [Any] - Object to validate",
    "Canonical_solution": "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n    constructor() {\n        this.requestModule = 'axios';\n    }\n\n    async httpRequest(options) {\n        let t = { ...options };\n        t.headers = t.headers || {};\n        if (t.params) {\n            t.url += '?' + this.queryStr(t.params);\n        }\n        t.method = t.method.toLowerCase();\n        if (t.method === 'get') {\n            delete t.headers['Content-Type'];\n            delete t.headers['Content-Length'];\n            delete t.headers['content-type'];\n            delete t.headers['content-length'];\n            delete t.body;\n        } else if (t.method === 'post') {\n            let ContentType;\n            if (!t.body) {\n                t.body = \"\";\n            } else if (typeof t.body === \"string\") {\n                ContentType = this.isJSONString(t.body) ? 'application/json' : 'application/x-www-form-urlencoded';\n            } else if (this.isJson(t.body)) {\n                t.body = JSON.stringify(t.body);\n                ContentType = 'application/json';\n            }\n            if (!t.headers['Content-Type'] && !t.headers['content-type']) {\n                t.headers['Content-Type'] = ContentType;\n            }\n        }\n        if (this.requestModule === \"axios\" && t.method === \"post\") {\n            t.data = t.body;\n            delete t.body;\n        }\n        let httpResult;\n        if (this.requestModule === \"axios\") {\n            httpResult = await axios(t);\n            httpResult.body = httpResult.data;\n        }\n        return httpResult;\n    }\n\n    queryStr(options) {\n        return Object.entries(options).map(([key, value]) => `${key}=${typeof value === 'object' ? JSON.stringify(value) : value}`).join('&');\n    }\n\n    isJSONString(str) {\n        try {\n            return JSON.parse(str) && typeof JSON.parse(str) === 'object';\n        } catch (e) {\n            return false;\n        }\n    }\n\n    isJson(obj) {\n        var isjson = typeof (obj) == \"object\" && Object.prototype.toString.call(obj).toLowerCase() == \"[object object]\" && !obj.length;\n        return isjson;\n    }\n}\n```",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    const axios = require(this.requestModule);\n\n    const config = {\n      method,\n      url,\n      headers: {\n        ...headers,\n        'Content-Type': this.detectContentType(body),\n      },\n      params: params ? this.queryStr(params) : null,\n      data: body,\n    };\n\n    try {\n      const response = await axios(config);\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response ? error.response.data : error.message);\n    }\n  }\n\n  queryStr(options) {\n    const str = Object.keys(options)\n      .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n    return str;\n  }\n\n  detectContentType(body) {\n    if (this.isJSONString(body)) {\n      return 'application/json';\n    }\n    return 'application/x-www-form-urlencoded';\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n\n  isJson(obj) {\n    return obj !== null && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}\n```"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Write a function that scrapes TV channel information from a webpage, processes the data, and returns a list of channel objects with their details.\n\nFunction Description: The function `getChannels` asynchronously fetches HTML content from a URL, parses it to extract TV channel information, and returns an array of channel objects. Each channel object contains language, site ID, and name. The function uses Axios for HTTP requests and Cheerio for HTML parsing.\n\nInput: None (The function uses an implicit `this.url()` method to generate the target URL)\n\nOutput: Array<Object> - Returns an array of channel objects with the following structure:\n[\n  {\n    lang: string,      // Language code of the channel (e.g., 'tr')\n    site_id: string,   // Unique identifier for the channel\n    name: string       // Name of the channel\n  },\n  ...\n]",
    "Canonical_solution": "async function getChannels() {\n    const channels = {};\n    const axios = require('axios');\n    const data = await axios\n        .get(this.url({ date: dayjs() }))\n        .then(r => r.data)\n        .catch(console.error);\n\n    const $ = cheerio.load(data);\n    $('.channelContent').toArray()\n        .forEach(el => {\n            const item = $(el);\n            const channelId = item.find('.channelDetail .tvGuideResult-box-wholeDates-title')\n                .first()\n                .attr('onclick');\n            if (channelId) {\n                const site_id = channelId.match(/\\s(\\d+)\\)/)[1];\n                if (channels[site_id] === undefined) {\n                    channels[site_id] = {\n                        lang: 'tr',\n                        site_id,\n                        name: item.find('#channelID').val()\n                    };\n                }\n            }\n        });\n\n    return Object.values(channels);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const { data } = await axios.get(url);\n  const $ = cheerio.load(data);\n  const channels = [];\n\n  $('.channel').each((index, element) => {\n    const lang = $(element).attr('lang');\n    const site_id = $(element).attr('data-site-id');\n    const name = $(element).find('.channel-name').text().trim();\n    channels.push({ lang, site_id, name });\n  });\n\n  return channels;\n}\n```"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a function to send telemetry data to a remote endpoint after a software installation, while respecting user preferences for telemetry collection.\n\nFunction Description: The function `installTelemetry` sends a POST request to a specified telemetry endpoint with installation-related data (Node.js version and platform). It checks an environment variable to determine if telemetry collection is enabled before sending any data. The function handles both success and error cases silently.\n\nInput: None (uses environment variable `TUNNELMOLE_TELEMETRY` and Node.js process information)\n\nOutput: None (the function doesn't return any value, it only performs a side effect of sending telemetry data)",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function installTelemetry() {\n  const telemetryEndpoint = `https://service.tunnelmole.com/tunnelmole-log-telemetry`;\n\n  if (process.env.TUNNELMOLE_TELEMETRY === \"0\") {\n    return;\n  }\n\n  axios\n    .post(telemetryEndpoint, {\n      type: \"post-install\",\n      data: {\n        nodeVersion: process.version ? process.version : \"Unknown\",\n        platform: process.platform ? process.platform : \"Unknown\"\n      }\n    }).then(function () {\n      // Ignore the response\n    }).catch(function () {\n      // Ignore the error\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst https = require('https');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (!telemetryEnabled) return;\n\n  const data = JSON.stringify({\n    nodeVersion: process.version,\n    platform: process.platform\n  });\n\n  const options = {\n    hostname: 'telemetry.example.com',\n    port: 443,\n    path: '/install',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': data.length\n    }\n  };\n\n  const req = https.request(options, (res) => {\n    res.on('data', (d) => {\n      process.stdout.write(d);\n    });\n  });\n\n  req.on('error', (error) => {\n    // Handle error silently\n  });\n\n  req.write(data);\n  req.end();\n}\n```"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a SauceLabs API client class in JavaScript that handles HTTP requests to the SauceLabs REST API, including authentication and basic GET/POST operations.\n\nClass Description: The SauceLabsClient class provides methods to interact with the SauceLabs REST API. It handles authentication and provides simplified methods for making GET and POST requests to the API endpoints.\n\nAttributes:\n- auth: [Object] - An object containing user authentication credentials (username and access token)\n\nMethods:\n- setAuth: [setAuth](saucelabsUsername: String, saucelabsToken: String) -> Void - Sets the authentication credentials for API requests\n- get: [get](path: String, callback: Function) -> Void - Makes a GET request to the specified API path and handles the response through a callback\n- post: [post](path: String, data: Object, callback: Function) -> Void - Makes a POST request to the specified API path with provided data and handles the response through a callback",
    "Canonical_solution": "var request = require('request');\n\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {\n      user: null,\n      password: null\n    };\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.user = saucelabsUsername;\n    this.auth.password = saucelabsToken;\n  }\n\n  get(path, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + path,\n      auth: this.auth\n    };\n    request.get(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        console.log(params);\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(JSON.parse(body));\n    });\n  }\n\n  post(path, data, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + this.auth.user + '/' + path,\n      auth: { user: this.auth.user, password: this.auth.password },\n      json: data\n    };\n    request.post(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(body);\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass SauceLabsClient {\n  constructor() {\n    this.auth = null;\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth = {\n      username: saucelabsUsername,\n      access_token: saucelabsToken\n    };\n  }\n\n  get(path, callback) {\n    const options = {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${this.auth.access_token}`\n      }\n    };\n\n    fetch(`https://api.saucelabs.com/v1/${this.auth.username}${path}`, options)\n      .then(response => response.json())\n      .then(data => callback(null, data))\n      .catch(error => callback(error, null));\n  }\n\n  post(path, data, callback) {\n    const options = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${this.auth.access_token}`\n      },\n      body: JSON.stringify(data)\n    };\n\n    fetch(`https://api.saucelabs.com/v1/${this.auth.username}${path}`, options)\n      .then(response => response.json())\n      .then(data => callback(null, data))\n      .catch(error => callback(error, null));\n  }\n}\n```"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Write a function that retrieves TV channel information from multiple regions, processes the data, and returns a unique list of channels based on their site IDs.\n\nFunction Description: The function `channels` makes HTTP GET requests to a TV channel API for multiple regions, collects channel data from all available pages for each region, and returns a deduplicated list of channels. It uses axios for HTTP requests and lodash for data processing.\n\nInput: None (The function uses hardcoded region IDs internally)\n\nOutput: An array of objects representing unique TV channels, where each object contains:\n- lang: string - Language code ('ru' for Russian)\n- name: string - Name of the TV channel\n- site_id: string/number - Unique identifier for the channel on the site\n\nThe output is deduplicated based on the site_id field using lodash's uniqBy function.",
    "Canonical_solution": "async function channels() {\n    const _ = require('lodash')\n    const axios = require('axios')\n\n    const regions = [5506, 1096, 1125, 285]\n    let channels = []\n    for (let region of regions) {\n        const totalPages = await getTotalPageCount(region)\n        const pages = Array.from(Array(totalPages).keys())\n        for (let page of pages) {\n            const data = await axios\n                .get('https://tv.mail.ru/ajax/channel/list/', {\n                    params: { page },\n                    headers: {\n                        cookie: `s=fver=0|geo=${region};`\n                    }\n                })\n                .then(r => r.data)\n                .catch(console.log)\n\n            data.channels.forEach(item => {\n                channels.push({\n                    lang: 'ru',\n                    name: item.name,\n                    site_id: item.id\n                })\n            })\n        }\n    }\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst axios = require('axios');\nconst _ = require('lodash');\n\nconst regions = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Create a class that interacts with a bundle size tracking API to get and set file size values for a repository.\n\nClass Description: The BundleSizeAPI class provides methods to retrieve and store file size information from a remote API. It handles authentication, repository name sanitization, and error logging.\n\nAttributes:\n- repo: [String] - The repository name (e.g., \"owner/repo\")\n- token: [String] - Authentication token for API access\n- sha: [String] - Commit SHA associated with the bundle sizes\n- ci: [Any] - CI environment information (usage not shown in reference)\n- url: [String] - Base URL for the bundle size API (\"https://bundlesize-store.now.sh/values\")\n- enabled: [Boolean] - Flag indicating if API operations are enabled (true when repo and token are provided)\n\nMethods:\n- get: [get]() -> [Promise<Object>] - Retrieves file size values from the API. Returns a promise that resolves to an object mapping file paths to their sizes. Automatically sanitizes repository name by replacing dots with underscores.\n- set: [set](values: Object) -> [void] - Posts file size values to the API. Takes an object mapping file paths to sizes. Only operates when repo and token are available. Sanitizes repository name and includes commit SHA in the payload. Errors are logged to console.\n\nNote: Both methods handle errors by logging them to the console and continue execution (errors don't propagate). The class is designed to be fail-safe when API credentials aren't provided.",
    "Canonical_solution": "const axios = require('axios');\n\nclass BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = (this.repo && this.token) ? true : false;\n  }\n\n  get() {\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    return axios\n      .get(`${this.url}?repo=${sanitizedRepo}&token=${this.token}`)\n      .then(response => {\n        const values = {};\n        if (response && response.data && response.data.length) {\n          response.data.map(file => (values[file.path] = file.size));\n        }\n        return values;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  }\n\n  set(values) {\n    if (this.repo && this.token) {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      axios\n        .post(this.url, { repo: sanitizedRepo, token: this.token, sha: this.sha, values })\n        .catch(error => console.log(error));\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```typescript\nclass BundleSizeAPI {\n  repo: string;\n  token: string;\n  sha: string;\n  ci: any;\n  url: string;\n  enabled: boolean;\n\n  constructor(repo: string, token: string, sha: string, ci: any) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = \"https://bundlesize-store.now.sh/values\";\n    this.enabled = !!repo && !!token;\n  }\n\n  async get(): Promise<Object> {\n    if (!this.enabled) return {};\n    try {\n      const response = await fetch(`${this.url}/${this.sanitizeRepo()}`, {\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n        },\n      });\n      if (!response.ok) throw new Error(`API responded with status ${response.status}`);\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.error(\"Failed to fetch bundle sizes:\", error);\n      return {};\n    }\n  }\n\n  async set(values: Object): Promise<void> {\n    if (!this.enabled) return;\n    try {\n      const response = await fetch(`${this.url}/${this.sanitizeRepo()}`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${this.token}`,\n        },\n        body: JSON.stringify({\n          sha: this.sha,\n          values,\n        }),\n      });\n      if (!response.ok) throw new Error(`API responded with status ${response.status}`);\n    } catch (error) {\n      console.error(\"Failed to set bundle sizes:\", error);\n    }\n  }\n\n  private sanitizeRepo(): string {\n    return this.repo.replace(/\\./g, \"_\");\n  }\n}\n```"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a function that fetches COVID-19 related data from the Israeli government's health dashboard API using HTTP POST request and processes the response.\n\nFunction Description: The function makes a batch request to the Israeli health ministry's API endpoint to retrieve multiple COVID-19 related datasets including updates, patient statistics, test results, and demographic breakdowns. It handles the HTTP communication, error cases, and returns the parsed data or null if the request fails.\n\nInput: None (The function takes no parameters as all request configuration is internally defined)\n\nOutput: \n- On success: Returns parsed data from the API response (type depends on parseData implementation)\n- On failure: Returns null and logs the error",
    "Canonical_solution": "function israelData() {\n    const axios = require('axios');\n    const logger = require('../../../utils/logger');\n    const params = {\n        requests: [\n            { queryName: 'lastUpdate', single: true },\n            { queryName: 'patientsPerDate' },\n            { queryName: 'deadPatientsPerDate' },\n            { queryName: 'recoveredPerDay' },\n            { queryName: 'testResultsPerDate' },\n            { queryName: 'infectedByPeriodAndAgeAndGender' },\n            { queryName: 'deadByPeriodAndAgeAndGender' },\n            { queryName: 'breatheByPeriodAndAgeAndGender' },\n            { queryName: 'severeByPeriodAndAgeAndGender' },\n            { queryName: 'spotlightPublic' },\n            { queryName: 'spotlightLastupdate' }\n        ]\n    };\n    return axios.post('https://datadashboardapi.health.gov.il/api/queries/_batch', params, {\n        headers: { 'Content-Type': 'application/json' }\n    }).then(data => {\n        return parseData(data.data);\n    }).catch(err => {\n        logger.err('Error: Requesting Israel Gov Data failed!', err);\n        return null;\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst https = require('https');\n\nfunction fetchData() {\n  const options = {\n    hostname: 'covid19.health.gov.il',\n    port: 443,\n    path: '/api/CoronaVirusStatistics',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  };\n\n  const req = https.request(options, (res) => {\n    let data = '';\n\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    res.on('end', () => {\n      try {\n        const parsedData = parseData(JSON.parse(data));\n        return parsedData;\n      } catch (error) {\n        console.error('Error parsing data:', error);\n        return null;\n      }\n    });\n  });\n\n  req.on('error', (error) => {\n    console.error('Error making request:', error);\n    return null;\n  });\n\n  req.end();\n}\n\nfunction parseData(data) {\n  // Implement data parsing logic here\n  // Return the parsed data\n  return data;\n}\n```"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a function to send emails using different email service providers (Mailgun and Sendgrid) through HTTP requests, with error handling and promise-based asynchronous operation.\n\nFunction Description: The function `sendMail` sends an email using a configured transporter (either Mailgun or Sendgrid). It wraps the transporter's send operation in a Promise for better async handling. The transporter is configured to make HTTP requests to the respective email service API.\n\nInput:\n- `to`: [String] - Recipient email address\n- `subject`: [String] - Email subject\n- `text`: [String] - Email body content\n- `options`: [Object] (optional) - Additional email options (defaults to empty object)\n\nOutput:\n- [Promise] - Resolves with email sending success info, or rejects with an error if sending fails.\n\n---\n\nClass Description: (Not applicable, as the reference code is at the function level)",
    "Canonical_solution": "function sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    transporter.sendMail({\n      from: `\"${ config.plugins.email.name || '' }\" <${ config.plugins.email.email || config.plugins.email.username }>`,\n      to,\n      subject,\n      text,\n    }, (error, info) => {\n      if(error) {\n        return reject(error);\n      }\n      return resolve(info);\n    });\n  });\n}\n\n// External libraries and global variables used:\nconst axios = require('axios');\nconst FormData = require('form-data');\nconst config = appRequire('services/config').all();\nlet transporter;\n\n// Mailgun implementation\ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  const form = new FormData();\n  form.append('from', options.from);\n  form.append('to', options.to);\n  form.append('subject', options.subject);\n  form.append('text', options.text);\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: form.getHeaders(),\n    data: form,\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};\n\n// Sendgrid implementation  \ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${ emailConfig.apiKey }`,\n    },\n    data: {\n      personalizations: [{\n        to: [{ email: options.to }]\n      }],\n      from: { email: options.from },\n      subject: options.subject,\n      content: [{\n        type: 'text/plain',\n        value: options.text,\n      }]\n    },\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst nodemailer = require('nodemailer');\n\nconst sendMail = (to, subject, text, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const transporter = nodemailer.createTransport({\n      service: 'Mailgun',\n      auth: {\n        user: process.env.MAILGUN_USER,\n        pass: process.env.MAILGUN_PASSWORD\n      }\n    });\n\n    const mailOptions = {\n      from: process.env.MAILGUN_FROM,\n      to: to,\n      subject: subject,\n      text: text,\n      ...options\n    };\n\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n};\n```"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create an asynchronous function that fetches TV channel data from a specified API endpoint and processes it into a standardized format.\n\nFunction Description: The function makes an HTTP GET request to retrieve TV channel information from a remote API. It processes the response to extract relevant channel details (language, site ID, and name) and returns them in a structured array format. The function includes error handling to log any request failures.\n\nInput: None (The function uses a hardcoded API URL and parameters)\n\nOutput: An array of objects where each object represents a TV channel with the following properties:\n- lang: String - The language code for the channel (hardcoded as 'sq' in this case)\n- site_id: String - The unique identifier for the channel from the API\n- name: String - The display name of the channel",
    "Canonical_solution": "async function channels() {\n    const axios = require('axios')\n    const data = await axios\n        .get('https://www.tvim.tv/script/epg/category_channels?category=all&filter=playable')\n        .then(r => r.data)\n        .catch(console.log)\n\n    let channels = []\n    data.data.forEach(item => {\n        channels.push({\n            lang: 'sq',\n            site_id: item.epg_id,\n            name: item.name\n        })\n    })\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function getTVChannels() {\n  const url = 'https://api.example.com/tv-channels';\n  const params = {\n    lang: 'sq',\n    limit: 100\n  };\n\n  try {\n    const response = await fetch(url, { method: 'GET', params });\n    const data = await response.json();\n\n    const channels = data.channels.map(channel => ({\n      lang: params.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n\n    return channels;\n  } catch (error) {\n    console.error('Failed to fetch TV channels:', error);\n    return [];\n  }\n}\n```"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Create a function that retrieves TV channel information from multiple providers and returns a list of unique channels.\n\nFunction Description: The function makes HTTP POST requests to a TV guide service for each provider, extracts channel information from the HTML response, and returns a deduplicated list of channels. It uses axios for HTTP requests, cheerio for HTML parsing, and lodash for deduplication.\n\nInput: None (The function uses hardcoded providers and parameters)\n\nOutput: Array of objects - Returns an array of channel objects containing language, name, and site_id (deduplicated by site_id). Each channel object has the following structure:\n{\n    lang: string,    // Language code ('fr' for French)\n    name: string,    // Channel name\n    site_id: string  // Unique identifier combining channel number and slug\n}",
    "Canonical_solution": "function async channels() {\n    const axios = require('axios')\n    const _ = require('lodash')\n\n    const providers = ['-1', '-2', '-3', '-4', '-5']\n\n    const channels = []\n    for (let provider of providers) {\n        const data = await axios\n            .post('https://www.tvcesoir.fr/guide/schedule', null, {\n                params: {\n                    provider,\n                    region: 'France',\n                    TVperiod: 'Night',\n                    date: dayjs().format('YYYY-MM-DD'),\n                    st: 0,\n                    u_time: 2155,\n                    is_mobile: 1\n                }\n            })\n            .then(r => r.data)\n            .catch(console.log)\n\n        const $ = cheerio.load(data)\n        $('.channelname').each((i, el) => {\n            const name = $(el).find('center > a:eq(1)').text()\n            const url = $(el).find('center > a:eq(1)').attr('href')\n            const [, number, slug] = url.match(/\\/(\\d+)\\/(.*)\\.html$/)\n\n            channels.push({\n                lang: 'fr',\n                name,\n                site_id: `${number}/${slug}`\n            })\n        })\n    }\n\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getChannels() {\n    const providers = [\n        {\n            url: 'https://www.tv-guide.fr',\n            lang: 'fr'\n        },\n        {\n            url: 'https://www.tv-guide.be',\n            lang: 'fr'\n        },\n        {\n            url: 'https://www.tv-guide.ch',\n            lang: 'fr'\n        },\n        {\n            url: 'https://www.tv-guide.de',\n            lang: 'de'\n        },\n        {\n            url: 'https://www.tv-guide.at',\n            lang: 'de'\n        }\n    ];\n\n    const channels = [];\n\n    for (const provider of providers) {\n        const response = await axios.post(provider.url, {\n            // Add necessary parameters for the POST request\n        });\n\n        const $ = cheerio.load(response.data);\n\n        $('div.channel').each((index, element) => {\n            const lang = provider.lang;\n            const name = $(element).find('span.channel-name').text().trim();\n            const site_id = $(element).find('a').attr('href').split('/').pop();\n\n            channels.push({ lang, name, site_id });\n        });\n    }\n\n    return _.uniqBy(channels, 'site_id');\n}\n\nmodule.exports = getChannels;\n```"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a function to download a video file from a given URL and save it with a specified description as the filename.\n\nFunction Description: The function `downloadVideo` initiates an asynchronous HTTP GET request to download a video file from the provided URL. It handles the response as a binary blob, creates a downloadable link, and triggers the download automatically. The function includes error handling for empty URLs and checks for successful request completion.\n\nInput:\n- `url` (String): The URL of the video file to be downloaded.\n- `desc` (String): The description to be used as the filename for the downloaded video.\n\nOutput: None (The function triggers a file download but does not return any value.)",
    "Canonical_solution": "function downloadVideo(url, desc) {\n    if (isEmpty(url)) {\n        layer.msg('\u6682\u65e0\u6570\u636e');\n        return;\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'blob';\n    xhr.setRequestHeader(\"Access-Control-Allow-Origin\", \"*\");\n    xhr.setRequestHeader(\"Access-Control-Allow-Credentials\", true);\n    xhr.onload = function () {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            let blob = this.response;\n            let u = window.URL.createObjectURL(new Blob([blob]));\n            let a = document.createElement('a');\n            a.download = desc + '.mp4';\n            a.href = u;\n            a.style.display = 'none';\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    throw new Error('URL is required');\n  }\n\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    const blob = await response.blob();\n    const link = document.createElement('a');\n    link.href = URL.createObjectURL(blob);\n    link.download = desc;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  } catch (error) {\n    console.error('Error downloading video:', error);\n  }\n}\n```"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a class that simulates the behavior of an EventSource object, which is used to receive server-sent events (SSE) over HTTP. The class should handle the connection, reception of events, and error handling.\n\nClass Description: The `EventSource` class is designed to establish a persistent connection to a server using HTTP and receive server-sent events. It manages the connection state, handles incoming events, and dispatches them to appropriate event handlers. The class also supports reconnection in case of errors or connection loss.\n\nAttributes:\n\n- `URL`: [String] - The URL to which the EventSource connects to receive server-sent events.\n- `readyState`: [Number] - Represents the current state of the connection. Possible values are `CONNECTING` (0), `OPEN` (1), and `CLOSED` (2).\n- `_pollTimer`: [Object] - A timer object used to manage the polling interval for reconnection attempts.\n- `_xhr`: [Object] - The XMLHttpRequest object used to make HTTP requests to the server.\n\nMethods:\n\n- `poll()`: [Function] -> [Void] - Initiates a new HTTP request to the server to receive events. Handles the response, processes the events, and manages the connection state.\n- `close()`: [Function]() -> [Void] - Closes the connection to the server, sets the `readyState` to `CLOSED`, and stops any ongoing polling.\n- `dispatchEvent(type, event)`: [Function]([String], [Object]) -> [Void] - Dispatches an event to the registered event handlers based on the event type.\n- `addEventListener(type, handler)`: [Function]([String], [Function]) -> [Void] - Registers an event handler for a specific event type.\n- `removeEventListener()`: [Function]() -> [Void] - Placeholder method for removing event listeners (not implemented in the reference code).\n\nAdditional Classes:\n\n- `MessageEvent`: [Class] - Represents an event received from the server. Contains the event data, origin, and last event ID.\n\nAttributes of `MessageEvent`:\n\n- `data`: [String] - The data payload of the event.\n- `type`: [String] - The type of the event, defaulting to 'message'.\n- `lastEventId`: [String] - The ID of the last received event.\n- `origin`: [String] - The origin URL of the event.\n\nMethods of `MessageEvent`:\n\n- `MessageEvent(data, origin, lastEventId)`: [Constructor]([String], [String], [String]) -> [Object] - Initializes a new `MessageEvent` instance with the provided data, origin, and last event ID.",
    "Canonical_solution": "var EventSource = function (url) {\n  var eventsource = this,\n      interval = 500,\n      lastEventId = null,\n      cache = '';\n\n  if (!url || typeof url != 'string') {\n    throw new SyntaxError('Not enough arguments');\n  }\n\n  this.URL = url;\n  this.readyState = this.CONNECTING;\n  this._pollTimer = null;\n  this._xhr = null;\n\n  function poll() {\n    try {\n      if (eventsource.readyState == eventsource.CLOSED) return;\n\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', eventsource.URL, true);\n      xhr.setRequestHeader('Accept', 'text/event-stream');\n      xhr.setRequestHeader('Cache-Control', 'no-cache');\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n      if (lastEventId != null) xhr.setRequestHeader('Last-Event-ID', lastEventId);\n      cache = '';\n\n      xhr.timeout = 50000;\n      xhr.onreadystatechange = function () {\n        var status = 0;\n        try {\n          status = xhr.status;\n        } catch (e) {}\n\n        if ((this.readyState == 3 || this.readyState == 4) && status == 200) {\n          if (eventsource.readyState == eventsource.CONNECTING) {\n            eventsource.readyState = eventsource.OPEN;\n            eventsource.dispatchEvent('open', { type: 'open' });\n          }\n\n          var responseText = '';\n          try {\n            responseText = this.responseText || '';\n          } catch (e) {}\n\n          var parts = responseText.substr(cache.length).split(\"\\n\"),\n              eventType = 'message',\n              data = [],\n              i = 0,\n              line = '';\n\n          cache = responseText;\n\n          for (; i < parts.length; i++) {\n            line = parts[i].replace(reTrim, '');\n            if (line.indexOf('event') == 0) {\n              eventType = line.replace(/event:?\\s*/, '');\n            } else if (line.indexOf('data') == 0) {\n              data.push(line.replace(/data:?\\s*/, ''));\n            } else if (line.indexOf('id:') == 0) {\n              lastEventId = line.replace(/id:?\\s*/, '');\n            } else if (line.indexOf('id') == 0) {\n              lastEventId = null;\n            } else if (line == '') {\n              if (data.length) {\n                var event = new MessageEvent(data.join('\\n'), eventsource.url, lastEventId);\n                eventsource.dispatchEvent(eventType, event);\n                data = [];\n                eventType = 'message';\n              }\n            }\n          }\n\n          if (this.readyState == 4) pollAgain(this);\n        } else if (eventsource.readyState !== eventsource.CLOSED) {\n          if (this.readyState == 4) {\n            eventsource.readyState = eventsource.CONNECTING;\n            eventsource.dispatchEvent('error', { type: 'error' });\n            pollAgain(this);\n          } else if (this.readyState == 0) {\n            pollAgain(this);\n          }\n        }\n      };\n\n      xhr.send();\n\n      setTimeout(function () {\n        if (true || xhr.readyState == 3) xhr.abort();\n      }, xhr.timeout);\n\n      eventsource._xhr = xhr;\n\n    } catch (e) {\n      eventsource.dispatchEvent('error', { type: 'error', data: e.message });\n    }\n  };\n\n  poll();\n};\n\nEventSource.prototype = {\n  close: function () {\n    this.readyState = this.CLOSED;\n    clearInterval(this._pollTimer);\n    this._xhr.abort();\n  },\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  dispatchEvent: function (type, event) {\n    var handlers = this['_' + type + 'Handlers'];\n    if (handlers) {\n      for (var i = 0; i < handlers.length; i++) {\n        handlers[i].call(this, event);\n      }\n    }\n\n    if (this['on' + type]) {\n      this['on' + type].call(this, event);\n    }\n  },\n  addEventListener: function (type, handler) {\n    if (!this['_' + type + 'Handlers']) {\n      this['_' + type + 'Handlers'] = [];\n    }\n    this['_' + type + 'Handlers'].push(handler);\n  },\n  removeEventListener: function () {},\n  onerror: null,\n  onmessage: null,\n  onopen: null,\n  readyState: 0,\n  URL: ''\n};\n\nvar MessageEvent = function (data, origin, lastEventId) {\n  this.data = data;\n  this.origin = origin;\n  this.lastEventId = lastEventId || '';\n};\n\nMessageEvent.prototype = {\n  data: null,\n  type: 'message',\n  lastEventId: '',\n  origin: ''\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nclass EventSource {\n  constructor(url) {\n    this.URL = url;\n    this.readyState = 0;\n    this._pollTimer = null;\n    this._xhr = null;\n    this._messageHandler = null;\n    this._errorHandler = null;\n  }\n\n  poll() {\n    if (this.readyState === 1) {\n      this._xhr = new XMLHttpRequest();\n      this._xhr.open('GET', this.URL, true);\n      this._xhr.timeout = 10000;\n      this._xhr.withCredentials = true;\n      this._xhr.onreadystatechange = () => {\n        if (this._xhr.readyState === 2) {\n          this.readyState = 1;\n        } else if (this._xhr.readyState === 3) {\n          this.readyState = 1;\n        } else if (this._xhr.readyState === 4) {\n          if (this._xhr.status >= 200 && this._xhr.status < 300) {\n            this.readyState = 1;\n            this._processResponse(this._xhr.responseText);\n          } else {\n            this.readyState = 2;\n            if (this._errorHandler) {\n              this._errorHandler(new Error('Server returned status ' + this._xhr.status));\n            }\n            this._startPolling();\n          }\n        }\n      };\n      this._xhr.ontimeout = () => {\n        this.readyState = 2;\n        if (this._errorHandler) {\n          this._errorHandler(new Error('Request timed out'));\n        }\n        this._startPolling();\n      };\n      this._xhr.send();\n    }\n  }\n\n  close() {\n    if (this._xhr) {\n      this._xhr.abort();\n      this._xhr = null;\n    }\n    this.readyState = 2;\n    this._stopPolling();\n  }\n\n  dispatchEvent(type, event) {\n    if (type === 'message' && this._messageHandler) {\n      this._messageHandler(event);\n    }\n  }\n\n  addEventListener(type, handler) {\n    if (type === 'message') {\n      this._messageHandler = handler;\n    } else if (type === 'error') {\n      this._errorHandler = handler;\n    }\n  }\n\n  removeEventListener() {\n    // Not implemented\n  }\n\n  _processResponse(responseText) {\n    const events = responseText.split('\\n\\n');\n    for (let event of events) {\n      const lines = event.split('\\n');\n      let eventType = 'message';\n      let data = '';\n      let lastEventId = '';\n      for (let line of lines) {\n        if (line.startsWith('event: ')) {\n          eventType = line.substring(7);\n        } else if (line.startsWith('data: ')) {\n          data += line.substring(6) + '\\n';\n        } else if (line.startsWith('id: ')) {\n          lastEventId = line.substring(4);\n        }\n      }\n      if (data) {\n        const messageEvent = new MessageEvent(data.trim(), this.URL, lastEventId);\n        this.dispatchEvent(eventType, messageEvent);\n      }\n    }\n  }\n\n  _startPolling() {\n    if (this.readyState === 2) {\n      this.readyState = 0;\n      this._pollTimer = setTimeout(() => {\n        this.poll();\n      }, 1000);\n    }\n  }\n\n  _stopPolling() {\n    if (this._pollTimer) {\n      clearTimeout(this._pollTimer);\n      this._pollTimer = null;\n    }\n  }\n}\n\nclass MessageEvent {\n  constructor(data, origin, lastEventId) {\n    this.data = data;\n    this.type = 'message';\n    this.lastEventId = lastEventId;\n    this.origin = origin;\n  }\n}\n```"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a JavaScript class that handles HTTP requests to fetch data from a URL, with support for different data formats and authentication.\n\nClass Description: The DataManURL class provides methods to interact with remote resources via HTTP, supporting operations like fetching data as a buffer, converting to data URI, creating read streams, and retrieving metadata like content type and size.\n\nAttributes:\n- url: [String] - The URL of the remote resource to access\n- _type: [String] - The content type of the resource (e.g., 'image/png')\n- urlOpts: [Object] - Configuration options for the HTTP request (headers, auth, etc.)\n- _size: [Number] - The size in bytes of the fetched resource (cached after first request)\n\nMethods:\n- constructor(url, type, options) -> [void] - Initializes a new DataManURL instance\n  - url: [String] - The target URL\n  - type: [String] - Expected content type (optional)\n  - options: [Object] - Request options including auth and headers (optional)\n\n- getBuffer(callback) -> [void] - Fetches the resource as a binary buffer\n  - callback: [Function] - Receives (error, buffer) parameters\n\n- getDataUri(callback) -> [void] - Converts the resource to a base64 data URI\n  - callback: [Function] - Receives (error, dataUri) parameters\n\n- createReadStream() -> [Stream] - Creates a readable stream of the resource\n  - Returns: [Stream] - Readable stream of the resource data\n\n- size(callback) -> [void] - Gets the resource size in bytes\n  - callback: [Function] - Receives (error, size) parameters\n\n- type() -> [String] - Gets the content type of the resource\n  - Returns: [String] - The content type (may be null if not fetched yet)",
    "Canonical_solution": "var request = Npm.require(\"request\");\n\nclass DataManURL {\n  constructor(url, type, options) {\n    var self = this;\n    options = options || {};\n\n    self.url = url;\n    self._type = type;\n\n    if (options.auth) {\n      if (options.auth.indexOf(':') < 0)\n        throw new Error('auth option should be of the form \"username:password\"');\n      options.headers = options.headers || {};\n      options.headers['Authorization'] = \"Basic \"+\n        (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n      delete options.auth;\n    }\n\n    self.urlOpts = options;\n  }\n\n  getBuffer(callback) {\n    var self = this;\n\n    request(_.extend({\n      url: self.url,\n      method: \"GET\",\n      encoding: null,\n      jar: false\n    }, self.urlOpts), Meteor.bindEnvironment(function(err, res, body) {\n      if (err) {\n        callback(err);\n      } else {\n        self._type = res.headers['content-type'];\n        callback(null, body);\n      }\n    }, function(err) {\n      callback(err);\n    }));\n  }\n\n  getDataUri(callback) {\n    var self = this;\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        if (!self._type) {\n          callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n        } else {\n          var dataUri = \"data:\" + self._type + \";base64,\" + buffer.toString(\"base64\");\n          callback(null, dataUri);\n        }\n      }\n    });\n  }\n\n  createReadStream() {\n    var self = this;\n    return request(_.extend({\n      url: self.url,\n      method: \"GET\"\n    }, self.urlOpts));\n  }\n\n  size(callback) {\n    var self = this;\n\n    if (typeof self._size === \"number\") {\n      callback(null, self._size);\n      return;\n    }\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        self._size = buffer.length;\n        callback(null, self._size);\n      }\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    // Implementation for fetching the resource as a binary buffer\n  }\n\n  getDataUri(callback) {\n    // Implementation for converting the resource to a base64 data URI\n  }\n\n  createReadStream() {\n    // Implementation for creating a readable stream of the resource\n  }\n\n  size(callback) {\n    // Implementation for getting the resource size in bytes\n  }\n\n  type() {\n    // Implementation for getting the content type of the resource\n  }\n}\n```"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Implement a function to handle form submission asynchronously using XMLHttpRequest in JavaScript. The function should prevent default form submission, process form data, send it to a server via POST request, and handle the server's response to display a thank-you message upon successful submission.\n\nFunction Description: The function `handleFormSubmit` intercepts form submission events, validates the form data (checking for honeypot fields), disables all buttons during submission, sends the form data to a specified URL via POST request, and processes the server's response to update the UI accordingly.\n\nInput: \n- `event`: [Event Object] - The form submission event that triggers this function. The event object contains the target form element and allows prevention of default submission behavior.\n\nOutput: \n- None (void) - The function does not return any value but performs side effects including:\n  - Preventing default form submission\n  - Disabling form buttons during submission\n  - Sending form data to the server\n  - Updating the UI based on server response (resetting form and showing thank-you message)",
    "Canonical_solution": "function handleFormSubmit(event) {\n    event.preventDefault();\n    var form = event.target;\n    var formData = getFormData(form);\n    var data = formData.data;\n\n    if (formData.honeypot) {\n        return false;\n    }\n\n    disableAllButtons(form);\n    var url = form.action;\n    var xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n    xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            form.reset();\n            var formElements = form.querySelector(\".form-elements\")\n            if (formElements) {\n                formElements.style.display = \"none\";\n            }\n            var thankYouMessage = form.querySelector(\".thankyou_message\");\n            if (thankYouMessage) {\n                thankYouMessage.style.display = \"block\";\n            }\n        }\n    };\n    var encoded = Object.keys(data).map(function(k) {\n        return encodeURIComponent(k) + \"=\" + encodeURIComponent(data[k]);\n    }).join('&');\n    xhr.send(encoded);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const formData = new FormData(form);\n  const honeypot = formData.get('honeypot');\n  if (honeypot) return;\n  disableButtons(form);\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.getAttribute('action'), true);\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      enableButtons(form);\n      form.reset();\n      const response = JSON.parse(xhr.responseText);\n      if (response.success) {\n        showThankYouMessage(response.message);\n      } else {\n        showErrorMessage(response.message);\n      }\n    }\n  };\n  xhr.send(formData);\n}\n\nfunction disableButtons(form) {\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n}\n\nfunction enableButtons(form) {\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = false);\n}\n\nfunction showThankYouMessage(message) {\n  // Implementation to show thank-you message\n}\n\nfunction showErrorMessage(message) {\n  // Implementation to show error message\n}\n```"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function that sends a POST request to a specified URL with form-urlencoded data and handles the response asynchronously.\n\nFunction Description: The function `sendPostRequest` constructs and sends an HTTP POST request to a given endpoint. It sets the appropriate content type header for form-urlencoded data, includes credentials if needed, and logs the server's response upon completion. This is useful for submitting form data or making authenticated API requests.\n\nInput: None (The URL and data are hardcoded in this example, but could be parameterized in a real implementation)\n\nOutput: None (The function logs the response to the console, but doesn't return anything)",
    "Canonical_solution": "function sendPostRequest() {\n    const data = 'secret=*%5*!';\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/post');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nasync function sendPostRequest() {\n  const url = 'https://example.com/api';\n  const data = new URLSearchParams();\n  data.append('key1', 'value1');\n  data.append('key2', 'value2');\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: data,\n    credentials: 'include', // Include cookies for cross-origin requests\n  });\n\n  console.log(await response.text());\n}\n\nsendPostRequest();\n```"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a JavaScript class that handles AJAX requests using XMLHttpRequest, supporting cross-origin requests, custom headers, and various response handling scenarios.\n\nClass Description: The AjaxTransport class provides a wrapper around XMLHttpRequest for making asynchronous HTTP requests. It handles request creation, header management, response processing, and cleanup. The class supports CORS, maintains request state, and provides error handling capabilities.\n\nAttributes:\n\nxhrId: [Number] - Counter for generating unique IDs for each XMLHttpRequest instance\nxhrCallbacks: [Object] - Stores callback functions for active requests\nxhrSuccessStatus: [Object] - Maps certain HTTP status codes to standard success codes\nxhrSupported: [XMLHttpRequest|Boolean] - Stores the created XMLHttpRequest instance or false if not supported\n\nMethods:\n\ncreateXHR: () -> [XMLHttpRequest|undefined] - Creates and returns a new XMLHttpRequest instance or undefined if creation fails\n\nsendRequest: (options: Object, headers: Object, complete: Function) -> [undefined] - \n  Sends an AJAX request with the given configuration\n  options: Contains request parameters (type, url, async, etc.)\n  headers: Key-value pairs of request headers\n  complete: Callback function to handle response\n\nabortRequest: (callback: Function) -> [undefined] - \n  Aborts an active request and executes the given callback\n  callback: Function to execute after aborting\n\ngetTransport: (options: Object) -> [Object|undefined] - \n  Returns a transport object if the request can be handled\n  options: Configuration object for the request\n  Returns an object with send and abort methods or undefined if request can't be handled",
    "Canonical_solution": "var jQuery = require(\"../core\");\nvar support = require(\"../var/support\");\n\nclass AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = {\n      0: 200,\n      1223: 204\n    };\n    this.xhrSupported = this.createXHR();\n    \n    if (window.ActiveXObject) {\n      jQuery(window).on(\"unload\", () => {\n        for (var key in this.xhrCallbacks) {\n          this.xhrCallbacks[key]();\n        }\n      });\n    }\n    \n    support.cors = !!this.xhrSupported && (\"withCredentials\" in this.xhrSupported);\n    support.ajax = !!this.xhrSupported;\n  }\n\n  createXHR() {\n    try {\n      return new XMLHttpRequest();\n    } catch(e) {}\n  }\n\n  sendRequest(options, headers, complete) {\n    var xhr = options.xhr();\n    var id = ++this.xhrId;\n\n    xhr.open(options.type, options.url, options.async, options.username, options.password);\n\n    if (options.xhrFields) {\n      for (var i in options.xhrFields) {\n        xhr[i] = options.xhrFields[i];\n      }\n    }\n\n    if (options.mimeType && xhr.overrideMimeType) {\n      xhr.overrideMimeType(options.mimeType);\n    }\n\n    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n      headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n    }\n\n    for (var i in headers) {\n      xhr.setRequestHeader(i, headers[i]);\n    }\n\n    var callback = (type) => {\n      return () => {\n        if (callback) {\n          delete this.xhrCallbacks[id];\n          callback = xhr.onload = xhr.onerror = null;\n\n          if (type === \"abort\") {\n            xhr.abort();\n          } else if (type === \"error\") {\n            complete(xhr.status, xhr.statusText);\n          } else {\n            complete(\n              this.xhrSuccessStatus[xhr.status] || xhr.status,\n              xhr.statusText,\n              typeof xhr.responseText === \"string\" ? { text: xhr.responseText } : undefined,\n              xhr.getAllResponseHeaders()\n            );\n          }\n        }\n      };\n    };\n\n    xhr.onload = callback();\n    xhr.onerror = callback(\"error\");\n    callback = this.xhrCallbacks[id] = callback(\"abort\");\n\n    try {\n      xhr.send(options.hasContent && options.data || null);\n    } catch (e) {\n      if (callback) {\n        throw e;\n      }\n    }\n  }\n\n  abortRequest(callback) {\n    if (callback) {\n      callback();\n    }\n  }\n\n  getTransport(options) {\n    if (support.cors || this.xhrSupported && !options.crossDomain) {\n      return {\n        send: (headers, complete) => this.sendRequest(options, headers, complete),\n        abort: () => this.abortRequest(callback)\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nclass AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = { 1223: 204 };\n    this.xhrSupported = this.createXHR();\n  }\n\n  createXHR() {\n    try {\n      return new XMLHttpRequest();\n    } catch (e) {\n      return undefined;\n    }\n  }\n\n  sendRequest(options, headers, complete) {\n    const xhr = this.createXHR();\n    if (!xhr) {\n      return;\n    }\n\n    const id = ++this.xhrId;\n    this.xhrCallbacks[id] = complete;\n\n    xhr.open(options.type, options.url, options.async);\n    xhr.onreadystatechange = () => this.onStateChange(id, xhr, options);\n    xhr.withCredentials = options.withCredentials;\n\n    if (options.mimeType && xhr.overrideMimeType) {\n      xhr.overrideMimeType(options.mimeType);\n    }\n\n    for (const key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n\n    xhr.send(options.hasContent && options.data || null);\n  }\n\n  onStateChange(id, xhr, options) {\n    if (xhr.readyState === 4) {\n      const status = xhr.status;\n      let isSuccess = status >= 200 && status < 300 || status === 304 || (status === 0 && options.isLocal && !options.crossDomain);\n      if (!isSuccess) {\n        isSuccess = status === 1223 && this.xhrSuccessStatus[status];\n      }\n\n      const responseHeaders = xhr.getAllResponseHeaders();\n      const responseData = !options.isLocal && !options.crossDomain ? xhr.response : xhr.responseText;\n      const response = {\n        data: responseData,\n        textStatus: isSuccess ? \"success\" : \"error\",\n        jqXHR: xhr\n      };\n\n      if (isSuccess) {\n        responseHeaders = responseHeaders ? this.parseHeaders(responseHeaders) : {};\n        response.headers = responseHeaders;\n      }\n\n      this.xhrCallbacks[id](response, response.textStatus, xhr);\n      delete this.xhrCallbacks[id];\n    }\n  }\n\n  abortRequest(callback) {\n    if (callback) {\n      callback();\n    }\n  }\n\n  getTransport(options) {\n    if (!this.xhrSupported) {\n      return undefined;\n    }\n\n    return {\n      send: (headers, complete) => this.sendRequest(options, headers, complete),\n      abort: () => this.abortRequest()\n    };\n  }\n\n  parseHeaders(headers) {\n    const parsed = {};\n    const headerRegex = /(\\w+):\\s*(.*)/;\n    const headerArray = headers.split(\"\\n\");\n    for (let i = 0; i < headerArray.length; i++) {\n      const result = headerRegex.exec(headerArray[i]);\n      if (result) {\n        parsed[result[1].toLowerCase()] = result[2];\n      }\n    }\n    return parsed;\n  }\n}\n```"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a function that handles different types of HTTP requests and script imports, then communicates the results back to a sender.\n\nFunction Description: The function `run_test` processes incoming data to determine which type of request or script import to execute. It supports XMLHttpRequest (XHR), Fetch API, and `importScripts` methods. Based on the input data, it initiates the corresponding operation and sends the result or error message back to the sender via the `postMessage` method.\n\nInput:  \n- `data` [String] - A string indicating the type of operation to perform. Valid values are 'xhr', 'fetch', or 'importScripts'.  \n- `sender` [Object] - An object with a `postMessage` method used to send the response or error message back to the caller.\n\nOutput:  \n- No direct return value. The function communicates results asynchronously via `sender.postMessage()`, sending either the response data (for successful operations) or an error message (for failures).  \n\nThe function handles the following cases:  \n1. If `data` is 'xhr', it performs an XMLHttpRequest GET operation and sends the response text or an error message.  \n2. If `data` is 'fetch', it uses the Fetch API to retrieve data and sends the response text or an error message.  \n3. If `data` is 'importScripts', it imports a script and sends a predefined message from the imported script.  \n4. For any other `data` value, it sends an \"Unexpected message\" response.",
    "Canonical_solution": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'synthesized-response.txt', true);\n    xhr.responseType = 'text';\n    xhr.send();\n    xhr.onload = evt => sender.postMessage(xhr.responseText);\n    xhr.onerror = () => sender.postMessage('XHR failed!');\n  } else if (data === 'fetch') {\n    fetch('synthesized-response.txt')\n        .then(response => response.text())\n        .then(data => sender.postMessage(data))\n        .catch(error => sender.postMessage('Fetch failed!'));\n  } else if (data === 'importScripts') {\n    importScripts('synthesized-response.js');\n    sender.postMessage(message);\n  } else {\n    sender.postMessage('Unexpected message! ' + data);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nfunction run_test(data, sender) {\n  if (data === 'xhr') {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://jsonplaceholder.typicode.com/posts/1', true);\n    xhr.onload = function () {\n      if (xhr.status >= 200 && xhr.status < 400) {\n        sender.postMessage(xhr.responseText);\n      } else {\n        sender.postMessage('Error: ' + xhr.status);\n      }\n    };\n    xhr.onerror = function () {\n      sender.postMessage('Request failed');\n    };\n    xhr.send();\n  } else if (data === 'fetch') {\n    fetch('https://jsonplaceholder.typicode.com/posts/1')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok ' + response.statusText);\n        }\n        return response.text();\n      })\n      .then(data => sender.postMessage(data))\n      .catch(error => sender.postMessage('Fetch error: ' + error.message));\n  } else if (data === 'importScripts') {\n    importScripts('https://example.com/script.js');\n    sender.postMessage('Message from imported script');\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n}\n```"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a function that asynchronously loads YAML content from a specified URL and processes it using a callback function.\n\nFunction Description: The function `loadYamlUrl` initiates an HTTP GET request to fetch YAML content from a given URL. It handles the response asynchronously, checking for a successful status code (200) before passing the YAML text to a processing function (`yamlToForm`) and logging the response to the console.\n\nInput: \n- `url` [String] - The URL from which to fetch the YAML content.\n\nOutput: \n- None (The function does not return a value directly but processes the YAML content via the `yamlToForm` callback and logs the response to the console.)",
    "Canonical_solution": "function loadYamlUrl(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'text';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            yamlToForm(this.response);\n            console.log(this.response);\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nasync function loadYamlUrl(url) {\n  const response = await fetch(url);\n  if (response.status === 200) {\n    const yamlText = await response.text();\n    yamlToForm(yamlText);\n    console.log(response);\n  }\n}\n```"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs from multiple services (is.gd, goo.gl, budurl.com, snipurl.com, etc.) by making HTTP requests to their APIs or following HTTP redirects. It handles recursive expansion with depth control and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening services to their domain names\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration\n- expand(args: [Object], callback: [Function]) -> [void] - Recursively expands a shortened URL\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to call with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n      - err: [Error] - Any error that occurred (optional)\n      - headers: [Object] - Response headers (optional)\n      - urlp: [Object] - Parsed URL object (optional)",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }.bind(this)\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass URLExpander {\n  constructor() {\n    this.map = {\n      'is.gd': 'is.gd',\n      'goo.gl': 'goo.gl',\n      'budurl.com': 'budurl.com',\n      'snipurl.com': 'snipurl.com',\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      isgd: (url, callback) => {\n        const req = http.request({\n          host: 'is.gd',\n          path: `/get.php?format=simple&url=${encodeURIComponent(url)}`,\n          timeout: this.timeout,\n        }, res => {\n          if (res.statusCode === 200) {\n            let data = '';\n            res.on('data', chunk => data += chunk);\n            res.on('end', () => callback(null, data));\n          } else {\n            callback(new Error(`HTTP ${res.statusCode}`));\n          }\n        });\n        req.on('error', err => callback(err));\n        req.end();\n      },\n      googl: (url, callback) => {\n        const req = http.request({\n          host: 'www.googleapis.com',\n          path: `/urlshortener/v1/url?key=${GOOGLE_API_KEY}&shortUrl=${encodeURIComponent(url)}`,\n          timeout: this.timeout,\n        }, res => {\n          if (res.statusCode === 200) {\n            let data = '';\n            res.on('data', chunk => data += chunk);\n            res.on('end', () => {\n              try {\n                const json = JSON.parse(data);\n                callback(null, json.longUrl);\n              } catch (err) {\n                callback(err);\n              }\n            });\n          } else {\n            callback(new Error(`HTTP ${res.statusCode}`));\n          }\n        });\n        req.on('error', err => callback(err));\n        req.end();\n      },\n      budurl: (url, callback) => {\n        const req = http.request({\n          host: 'budurl.com',\n          path: `/api/expand?url=${encodeURIComponent(url)}`,\n          timeout: this.timeout,\n        }, res => {\n          if (res.statusCode === 200) {\n            let data = '';\n            res.on('data', chunk => data += chunk);\n            res.on('end', () => {\n              try {\n                const json = JSON.parse(data);\n                callback(null, json.url);\n              } catch (err) {\n                callback(err);\n              }\n            });\n          } else {\n            callback(new Error(`HTTP ${res.statusCode}`));\n          }\n        });\n        req.on('error', err => callback(err));\n        req.end();\n      },\n      snipurl: (url, callback) => {\n        const req = http.request({\n          host: 'snipurl.com',\n          path: `/api/expand?url=${encodeURIComponent(url)}`,\n          timeout: this.timeout,\n        }, res => {\n          if (res.statusCode === 200) {\n            let data = '';\n            res.on('data', chunk => data += chunk);\n            res.on('end', () => {\n              try {\n                const json = JSON.parse(data);\n                callback(null, json.url);\n              } catch (err) {\n                callback(err);\n              }\n            });\n          } else {\n            callback(new Error(`HTTP ${res.statusCode}`));\n          }\n        });\n        req.on('error', err => callback(err));\n        req.end();\n      },\n    };\n  }\n  expand(args, callback) {\n    const { url, depth = 0, seen = {} } = args;\n    if (depth > 10) {\n      return callback(new Error('Max depth exceeded'));\n    }\n    if (seen[url]) {\n      return callback(new Error('Cycle detected'));\n    }\n    seen[url] = true;\n    const domain = url.match(/^(?:https?:\\/\\/)?(?:[^@\\n]+@)?(?:www\\.)?([^:\\/\\n]+)/im)[1];\n    if (this.map[domain]) {\n      this.APIs[this.map[domain]](url, (err, expanded) => {\n        if (err) {\n          return callback(err);\n        }\n        this.expand({ url: expanded, depth: depth + 1, seen }, callback);\n      });\n    } else {\n      const req = http.request({ url, timeout: this.timeout }, res => {\n        if (res.statusCode === 301 || res.statusCode === 302) {\n          const location = res.headers.location;\n          this.expand({ url: location, depth: depth + 1, seen }, callback);\n        } else {\n          callback(null, url, depth, seen, res.headers, url.parse(url));\n        }\n      });\n      req.on('error', err => callback(err));\n      req.end();\n    }\n  }\n}\n```\n"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a reusable HTTP server class in JavaScript using the Express framework that can handle various HTTP methods, middleware configuration, and file uploads.\n\nClass Description: The HTTPServer class encapsulates an Express application with configurable routes, middleware, and file upload capabilities. It provides methods to start/stop the server and add route handlers for different HTTP methods.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number the server listens on\n- server: [Object|null] - The HTTP server instance (null before starting)\n\nMethods:\n- constructor(port) -> [HTTPServer] - Initializes the Express app with middleware and file upload handling\n- start() -> [Promise] - Starts the server on the specified port\n- stop() -> [void] - Stops the server if running\n- addRoute(method, path, handler) -> [void] - Adds a route handler for a specific HTTP method\n- get(path, handler) -> [void] - Adds a GET route handler\n- post(path, handler) -> [void] - Adds a POST route handler\n- put(path, handler) -> [void] - Adds a PUT route handler\n- delete(path, handler) -> [void] - Adds a DELETE route handler\n- patch(path, handler) -> [void] - Adds a PATCH route handler\n- options(path, handler) -> [void] - Adds an OPTIONS route handler\n- trace(path, handler) -> [void] - Adds a TRACE route handler\n- head(path, handler) -> [void] - Adds a HEAD route handler",
    "Canonical_solution": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst multer = require(\"multer\");\n\nclass HTTPServer {\n    constructor(port) {\n        this.app = express();\n        this.port = port;\n        this.server = null;\n        \n        // Configure middleware\n        this.app.use(bodyParser.raw({type:\"*/*\"}));\n        this.app.use(cookieParser(undefined,{decode:String}));\n        \n        // File upload handling\n        const fileUploadApp = express();\n        const mp = multer({ storage: multer.memoryStorage() }).any();\n        fileUploadApp.post(\"/file-upload\",function(req,res,next) {\n            mp(req,res,function(err) {\n                req._body = true;\n                next(err);\n            })\n        },bodyParser.json(),function(req,res) {\n            res.json({\n                body: req.body,\n                files: req.files\n            })\n        });\n        this.app.use(fileUploadApp);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            this.server = this.app.listen(this.port, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n\n    addRoute(method, path, handler) {\n        this.app[method.toLowerCase()](path, handler);\n    }\n\n    get(path, handler) {\n        this.addRoute('get', path, handler);\n    }\n\n    post(path, handler) {\n        this.addRoute('post', path, handler);\n    }\n\n    put(path, handler) {\n        this.addRoute('put', path, handler);\n    }\n\n    delete(path, handler) {\n        this.addRoute('delete', path, handler);\n    }\n\n    patch(path, handler) {\n        this.addRoute('patch', path, handler);\n    }\n\n    options(path, handler) {\n        this.addRoute('options', path, handler);\n    }\n\n    trace(path, handler) {\n        this.addRoute('trace', path, handler);\n    }\n\n    head(path, handler) {\n        this.addRoute('head', path, handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n\n    this.app.use(express.json());\n    this.app.use(express.urlencoded({ extended: true }));\n    this.app.use(express.static('public'));\n    this.app.use(upload.array());\n  }\n\n  async start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.port, () => {\n        console.log(`Server running on port ${this.port}`);\n        resolve();\n      });\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close();\n      this.server = null;\n      console.log('Server stopped');\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Implement a Twitter HTTP client class in JavaScript that handles API requests to Twitter, including request construction, execution, and response processing with error handling and clock synchronization.\n\nClass Description: The TwitterHTTPClient class provides methods to interact with Twitter's REST API. It handles HTTP requests (GET/POST), manages authentication, processes responses, and maintains clock synchronization with Twitter's servers.\n\nAttributes:\n- config: [Object] - Configuration object containing API credentials and settings\n- _twitter_time_minus_local_time_ms: [Number] - Time difference between Twitter's server time and local time in milliseconds\n\nMethods:\n- constructor(config) -> [TwitterHTTPClient] - Initializes the client with configuration\n- request(method, path, params, callback) -> [Promise] - Makes HTTP requests to Twitter API\n- _doRestApiRequest(reqOpts, twitOptions, method, callback) -> [void] - Executes the actual HTTP request\n- _updateClockOffsetFromResponse(resp) -> [void] - Updates the clock offset based on Twitter's server time\n\nMethod Details:\n1. request(method, path, params, callback)\n   - Input:\n     - method: [String] - HTTP method ('GET' or 'POST')\n     - path: [String] - API endpoint path\n     - params: [Object] - Request parameters\n     - callback: [Function] - Callback function for handling response\n   - Output: [Promise] - Resolves with response data or rejects with error\n\n2. _doRestApiRequest(reqOpts, twitOptions, method, callback)\n   - Input:\n     - reqOpts: [Object] - Request options including URL and headers\n     - twitOptions: [Object] - Twitter-specific options\n     - method: [String] - HTTP method\n     - callback: [Function] - Callback for handling response\n   - Output: [void] - Calls callback with response data or error\n\n3. _updateClockOffsetFromResponse(resp)\n   - Input:\n     - resp: [Object] - HTTP response object\n   - Output: [void] - Updates internal clock offset value",
    "Canonical_solution": "var request = require('request');\nvar helpers = require('./helpers');\n\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    var self = this;\n    assert(method == 'GET' || method == 'POST');\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      var _returnErrorToUser = function (err) {\n        if (callback && typeof callback === 'function') {\n          callback(err, null, null);\n        }\n        reject(err);\n      }\n\n      self._buildReqOpts(method, path, params, false, function (err, reqOpts) {\n        if (err) {\n          _returnErrorToUser(err);\n          return;\n        }\n\n        var twitOptions = (params && params.twit_options) || {};\n\n        process.nextTick(function () {\n          self._doRestApiRequest(reqOpts, twitOptions, method, function (err, parsedBody, resp) {\n            self._updateClockOffsetFromResponse(resp);\n\n            if (self.config.trusted_cert_fingerprints) {\n              if (!resp.socket.authorized) {\n                var authErrMsg = resp.socket.authorizationError.toString();\n                var err = helpers.makeTwitError('The peer certificate was not signed; ' + authErrMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n              var fingerprint = resp.socket.getPeerCertificate().fingerprint;\n              var trustedFingerprints = self.config.trusted_cert_fingerprints;\n              if (trustedFingerprints.indexOf(fingerprint) === -1) {\n                var errMsg = util.format('Certificate untrusted. Trusted fingerprints are: %s. Got fingerprint: %s.',\n                                         trustedFingerprints.join(','), fingerprint);\n                var err = new Error(errMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n            }\n\n            if (callback && typeof callback === 'function') {\n              callback(err, parsedBody, resp);\n            }\n\n            resolve({ data: parsedBody, resp: resp });\n            return;\n          });\n        });\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    var request_method = request[method.toLowerCase()];\n    var req = request_method(reqOpts);\n\n    var body = '';\n    var response = null;\n\n    var onRequestComplete = function () {\n      if (body !== '') {\n        try {\n          body = JSON.parse(body);\n        } catch (jsonDecodeError) {\n          var err = helpers.makeTwitError('JSON decode error: Twitter HTTP response body was not valid JSON');\n          err.statusCode = response ? response.statusCode: null;\n          err.allErrors.concat({error: jsonDecodeError.toString()});\n          callback(err, body, response);\n          return;\n        }\n      }\n\n      if (typeof body === 'object' && (body.error || body.errors)) {\n        var err = helpers.makeTwitError('Twitter API Error');\n        err.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n\n      callback(err, body, response);\n    }\n\n    req.on('response', function (res) {\n      response = res;\n      req.on('data', function (chunk) {\n        body += chunk.toString('utf8');\n      });\n      req.on('end', function () {\n        onRequestComplete();\n      });\n    });\n\n    req.on('error', function (err) {\n      if (twitOptions.retry &&\n          STATUS_CODES_TO_ABORT_ON.indexOf(err.statusCode) !== -1\n      ) {\n        self.request(method, path, params, callback);\n        return;\n      } else {\n        err.statusCode = null;\n        err.code = null;\n        err.allErrors = [];\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    var self = this;\n    if (resp && resp.headers && resp.headers.date &&\n        new Date(resp.headers.date).toString() !== 'Invalid Date'\n    ) {\n      var twitterTimeMs = new Date(resp.headers.date).getTime();\n      self._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        headers: {\n          Authorization: `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json',\n        },\n        method,\n        qs: params,\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, resp) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(resp);\n          resolve(resp);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    request(reqOpts, (err, resp, body) => {\n      if (err) {\n        callback(err);\n      } else {\n        try {\n          const data = JSON.parse(body);\n          callback(null, data);\n        } catch (e) {\n          callback(e);\n        }\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const twitterTime = new Date(resp.headers.date).getTime();\n    const localTime = new Date().getTime();\n    this._twitter_time_minus_local_time_ms = twitterTime - localTime;\n  }\n}\n```"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Create a class that implements a simple HTTP server using Express.js framework to provide a FOAAS (F*** Off As A Service) style API, which generates humorous responses to HTTP requests.\n\nClass Description: The FOAAS class creates an Express application that handles various HTTP requests and returns humorous responses in a standardized format. It includes middleware configuration, route handling, and server management capabilities.\n\nAttributes:\n- app: [Object] - The Express application instance\n- operations: [Object] - A dictionary storing available API operations\n- operationsArray: [Array] - An array containing information about available operations\n\nMethods:\n- constructor(options) -> [void] - Initializes the Express application, configures middleware, and sets up default routes\n  - options: [Object] - Configuration options for the application (currently unused in reference implementation)\n  \n- sendIndex(req, res) -> [void] - Sends the index.html file as response\n  - req: [Object] - Express request object\n  - res: [Object] - Express response object\n  \n- start(port) -> [void] - Starts the HTTP server on the specified port and performs initialization checks\n  - port: [Number] - The port number to listen on\n  \n- output(req, res, message, subtitle) -> [void] - Formats and sends the response message\n  - req: [Object] - Express request object\n  - res: [Object] - Express response object\n  - message: [String] - The main response message\n  - subtitle: [String] - The secondary response message (typically containing the requester's name)",
    "Canonical_solution": "const express = require('express');\nconst request = require('request');\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.app.disable('x-powered-by');\n    \n    // Standard Middleware\n    this.app.use(express.json());\n    this.app.use(express.urlencoded({ extended: true }));\n    \n    // Operations\n    this.operations = {};\n    this.operationsArray = [];\n    \n    // Define routes\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/operations', (req, res) => {\n      res.send(this.operationsArray);\n    });\n    \n    // Default Operation\n    this.app.get('/:thing/:from', (req, res) => {\n      const message = `Fuck ${req.params.thing}.`;\n      const subtitle = `- ${req.params.from}`;\n      this.output(req, res, message, subtitle);\n    });\n  }\n\n  sendIndex(req, res) {\n    res.sendFile('./public/index.html');\n  }\n\n  start(port) {\n    this.app.listen(port);\n    console.log(`FOAAS Started on port ${port}`);\n    \n    request(`http://localhost:${port}/operations`, (error, response, body) => {\n      if (error) return console.log('Could not retrieve operations');\n      const ops = JSON.parse(body);\n      \n      ops.forEach((op) => {\n        request({\n          url: `http://localhost:${port}${op.url}`,\n          headers: { Accept: 'text/plain' }\n        }, (error, response, body) => {\n          if (error) return console.log('Could not retrieve operation ' + op.url);\n        });\n      });\n    });\n  }\n\n  output(req, res, message, subtitle) {\n    req.message = message;\n    req.subtitle = subtitle;\n    \n    // Process output\n    res.send(`${message} ${subtitle}`);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n    this.operations = {};\n    this.operationsArray = [];\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/operations', this.sendOperations.bind(this));\n    this.app.get('/:name', this.sendOperation.bind(this));\n    this.app.get('/:name/:from', this.sendOperation.bind(this));\n    this.app.get('/:name/:from/:what', this.sendOperation.bind(this));\n    this.app.get('/:name/:from/:what/:reason', this.sendOperation.bind(this));\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(path.join(__dirname, 'index.html'));\n  }\n\n  start(port) {\n    this.app.listen(port, () => {\n      console.log(`Server listening on port ${port}`);\n      this.checkOperations();\n    });\n  }\n\n  output(req, res, message, subtitle) {\n    res.json({\n      message: message,\n      subtitle: subtitle || req.params.from\n    });\n  }\n\n  checkOperations() {\n    for (let operation of this.operationsArray) {\n      if (!this.operations[operation.name]) {\n        console.log(`Operation ${operation.name} is missing`);\n      }\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 79,
    "Instruction": "Task Description: Create a function that initializes and starts an Express.js HTTP server with REST API capabilities, static file serving, and error handling.\n\nFunction Description: The function `startServer` creates and configures an Express.js application, sets up middleware for static file serving and request body parsing, configures REST API routes with error handling, and starts the HTTP server on a specified port. The server handles both regular web traffic and API requests through virtual hosting.\n\nInput: None (uses environment variable PORT if available)\n\nOutput: Returns the HTTP server instance that was created and started.\n\nTask Description: ...\n\nFunction Description: ...\n\nInput: ...\n\nOutput: ...",
    "Canonical_solution": "function startServer() {\n    var http = require('http'),\n        express = require('express'),\n        app = express();\n\n    app.set('port', process.env.PORT || 3000);\n\n    app.use(express.static(__dirname + '/public'));\n    app.use(require('body-parser')());\n\n    var rest = require('connect-rest');\n    var apiOptions = {\n        context: '/',\n        domain: require('domain').create(),\n    };\n\n    apiOptions.domain.on('error', function(err){\n        console.log('API domain error.\\n', err.stack);\n        setTimeout(function(){\n            console.log('Server shutting down after API domain error.');\n            process.exit(1);\n        }, 5000);\n        server.close();\n        var worker = require('cluster').worker;\n        if(worker) worker.disconnect();\n    });\n\n    app.use(vhost('api.*', rest.rester(apiOptions)));\n\n    var server = http.createServer(app).listen(app.get('port'), function(){\n        console.log('Express started in ' + app.get('env') +\n            ' mode on http://localhost:' + app.get('port') +\n            '; press Ctrl-C to terminate.');\n    });\n\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nfunction startServer() {\n  const app = express();\n\n  app.use(bodyParser.json());\n  app.use(bodyParser.urlencoded({ extended: true }));\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.use('/api', require('./routes/api'));\n\n  app.use((err, req, res, next) => {\n    console.error(err.stack);\n    res.status(500).send('Something broke!');\n  });\n\n  const port = process.env.PORT || 3000;\n  const server = app.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n\n  return server;\n}\n\nmodule.exports = startServer;\n```"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by detecting the shortening service and using the appropriate API or HTTP HEAD request to follow redirects. It handles recursive expansion with depth limiting and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening service names to their associated domains\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration including known URL shortening services and timeout\n- expand(args: [Object], callback: [Function]) -> [void] - The main method that initiates URL expansion\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to be called with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - err: [Error] - Any error encountered (optional)\n      - headers: [Object] - Response headers (optional)\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n\nThe class includes several internal API methods (isgd, googl, budurl, snipurl, generic) that handle specific URL shortening services or generic URL expansion through HTTP HEAD requests. These methods are not meant to be called directly but are used internally by the expand method.",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass URLExpander {\n  constructor() {\n    this.map = {\n      'is.gd': 'is.gd',\n      'goo.gl': 'goo.gl',\n      'budurl.com': 'budurl.com',\n      'snipurl.com': 'snipurl.com',\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      isgd: this.isgd,\n      googl: this.googl,\n      budurl: this.budurl,\n      snipurl: this.snipurl,\n      generic: this.generic,\n    };\n  }\n\n  expand(args, callback) {\n    const { url, depth = 0, seen = {} } = args;\n    if (depth > 10) {\n      return callback({ ...args, err: new Error('Max depth exceeded') });\n    }\n    if (seen[url]) {\n      return callback({ ...args, err: new Error('Cycle detected') });\n    }\n    seen[url] = true;\n    const domain = url.match(/:\\/\\/(www[0-9]?\\.)?(.[^/:]+)/i)[2];\n    const api = this.map[domain];\n    if (api) {\n      this.APIs[api](args, callback);\n    } else {\n      this.generic(args, callback);\n    }\n  }\n\n  isgd(args, callback) {\n    const { url } = args;\n    const apiUrl = `http://is.gd/api.php?uri=${encodeURIComponent(url)}`;\n    this.request(apiUrl, (err, res) => {\n      if (err) {\n        return callback({ ...args, err });\n      }\n      callback({ ...args, url: res });\n    });\n  }\n\n  googl(args, callback) {\n    const { url } = args;\n    const apiUrl = `https://www.googleapis.com/urlshortener/v1/url?key=AIzaSyC4QoXt0t4yX6pWQ9sQXgjQjQXgjQjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQXgjQ"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that makes an HTTP request to a specified URL with custom headers and handles the response.\n\nFunction Description: The function `makeHttpRequest` performs an HTTP GET request to a specified URL with custom headers and decompresses gzip-encoded responses. It uses the `request` module to send the request and handles the response through a callback function that checks for errors and logs the response body if successful.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function logs the response body to the console if the request is successful.)",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Accept-Encoding': 'gzip, deflate, sdch',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Referer': 'http://www.wikipedia.org/',\n        'Cookie': 'GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14',\n        'Connection': 'keep-alive'\n    };\n\n    var options = {\n        url: 'http://localhost:28139/',\n        headers: headers,\n        gzip: true\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'https://example.com';\n  const headers = {\n    'Accept-Encoding': 'gzip, deflate',\n    'User-Agent': 'node.js'\n  };\n\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response Body:', body);\n    }\n  });\n}\n\nmakeHttpRequest();\n```"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Create a function that sets up an Express server to handle file uploads, process images by resizing and adding a watermark, and serve the processed images back to the client.\n\nFunction Description: The function `setupServer` initializes an Express application, configures middleware for handling file uploads and static file serving, defines routes for the root path and file uploads, and starts the server on port 3000. The upload route processes the uploaded image by resizing it to a width of 800 pixels, adding a logo watermark, and saving it as a JPEG with 80% quality. The temporary upload file is deleted after processing.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an Express server listening on port 3000.)",
    "Canonical_solution": "function setupServer() {\n    var fs = require('fs'),\n        path = require('path'),\n        express = require('express'),\n        images = require('../index');\n\n    var app = express();\n\n    app.use(express.bodyParser({\n        uploadDir: __dirname + '/upload'\n    }));\n\n    app.use(express.static(__dirname + '/upload'));\n\n    app.get('/', function(req, res) {\n        res.send('<form method=\"post\" enctype=\"multipart/form-data\" action=\"/upload\"><input type=\"file\" name=\"photo\" /><input type=\"submit\" /></form>');\n    });\n\n    app.post('/upload', function(req, res) {\n        var tmp_path = req.files.photo.path,\n            out_path = tmp_path + '.jpg',\n            photo;\n\n        photo = images(tmp_path);\n        photo.size(800)\n            .draw(images('./logo.png'), 800 - 421, photo.height() - 117)\n            .save(out_path, {\n            quality: 80\n        });\n\n        fs.unlink(tmp_path, function(err) {\n            if (err) throw err;\n            res.send('<a href=\"/\" title=\"upload\"><img src=\"/' + path.basename(out_path) + '\" /></a>');\n        });\n    });\n\n    app.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\nconst upload = multer({ dest: 'uploads/' });\n\napp.get('/', (req, res) => {\n  res.send('File upload server');\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  try {\n    const imagePath = req.file.path;\n    const resizedImagePath = path.join('uploads', 'resized-' + req.file.filename + '.jpeg');\n\n    await sharp(imagePath)\n      .resize(800)\n      .composite([{ input: 'logo.png', gravity: 'southeast' }])\n      .jpeg({ quality: 80 })\n      .toFile(resizedImagePath);\n\n    fs.unlinkSync(imagePath);\n\n    res.send('Image processed and saved');\n  } catch (error) {\n    res.status(500).send(error.message);\n  }\n});\n\napp.use(express.static('uploads'));\n\napp.listen(3000, () => {\n  console.log('Server started on port 3000');\n});\n```"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, and integrate it with Next.js for server-side rendering.\n\nFunction Description: The function `setupServer` initializes an Express server with session management configured to use MongoDB for session storage. It integrates with Next.js for handling server-side rendering and routes all requests to the Next.js request handler. The server listens on a specified port and logs the root URL when ready.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Port number to listen on (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that listens on the specified port and handles requests. It logs the root URL to the console when the server is ready.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    const next = require('next');\n    const mongoose = require('mongoose');\n\n    const dev = process.env.NODE_ENV !== 'production';\n    const MONGO_URL = process.env.MONGO_URL_TEST;\n    const port = process.env.PORT || 8000;\n    const ROOT_URL = `http://localhost:${port}`;\n\n    const app = next({ dev });\n    const handle = app.getRequestHandler();\n\n    const server = express();\n\n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: MONGO_URL,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => handle(req, res));\n\n    server.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on ${ROOT_URL}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\n\nconst mongoUrl = process.env.MONGO_URL_TEST;\n\nconst sessionName = process.env.SESSION_NAME || 'sid';\nconst sessionSecret = process.env.SESSION_SECRET || 'secret';\n\nconst store = new MongoDBStore({\n  uri: mongoUrl,\n  collection: 'sessions',\n});\n\nstore.on('error', (error) => {\n  console.log(error);\n});\n\nconst sessionMiddleware = session({\n  secret: sessionSecret,\n  resave: false,\n  saveUninitialized: false,\n  cookie: {\n    httpOnly: true,\n    secure: !dev,\n    maxAge: 1000 * 60 * 60 * 24 * 7, // 1 week\n  },\n  store,\n});\n\nconst setupServer = async () => {\n  await app.prepare();\n  const server = express();\n  server.use(sessionMiddleware);\n  server.all('*', (req, res) => handle(req, res));\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n};\n\nsetupServer();\n```"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a function that initializes and configures an Express.js web application with middleware, route handlers, and server listening capabilities, including optional HTTPS support.\n\nFunction Description: The function `createExpressApp` creates and configures an Express.js application instance with various middleware (CORS, security headers, caching), route handlers for API endpoints and static files, and error handling. It starts an HTTP server (and optionally an HTTPS server) listening on specified ports. The function returns the configured Express application instance.\n\nInput: None (The function uses global configuration variables like CONFIG and process.env for settings)\n\nOutput: Express.Application - Returns the fully configured Express.js application instance after setting up all middleware, routes, and server listeners.",
    "Canonical_solution": "function createExpressApp() {\n    var express = require('express');\n    var app = express();\n\n    app.use(express.bodyParser());\n    app.set('view engine', 'ejs');\n\n    if (CONFIG.allowedOrigins) {\n        app.use(function(req, res, next) {\n            var origin = req.headers[\"origin\"];\n            if (origin) {\n                if (CONFIG.allowedOrigins.indexOf('*') > -1) {\n                    res.setHeader('Access-Control-Allow-Origin', '*');\n                } else {\n                    if (CONFIG.allowedOrigins.indexOf(origin) > -1) {\n                        res.setHeader('Access-Control-Allow-Origin', origin);\n                    }\n                }\n            }\n            next();\n        });\n    }\n\n    app.disable('x-powered-by');\n    app.use(function(req, res, next) {\n        res.setHeader('X-Powered-By', 'Iframely');\n        next();\n    });\n\n    app.use(sysUtils.cacheMiddleware);\n\n    require('./modules/api/views')(app);\n    require('./modules/debug/views')(app);\n    require('./modules/tests-ui/views')(app);\n\n    app.use(logErrors);\n    app.use(errorHandler);\n\n    app.get(CONFIG.relativeStaticUrl + '/*', function(req, res, next) {\n        var url = '/' + req.url.split('/').splice(2).join('/');\n        sysUtils.static(path.resolve(__dirname, 'static'), {path: url})(req, res, next);\n    });\n\n    app.get('/', function(req, res) {\n        res.writeHead(302, { Location: 'http://iframely.com'});\n        res.end();\n    });\n\n    var listener = app.listen(process.env.PORT || CONFIG.port, process.env.HOST || CONFIG.host, function(){\n        console.log('\\niframely is listening on ' + listener.address().address + ':' + listener.address().port + '\\n');\n    });\n\n    if (CONFIG.ssl) {\n        var options = { key: CONFIG.ssl.key, cert: CONFIG.ssl.cert };\n        require('https').createServer(options, app).listen(CONFIG.ssl.port);\n    }\n\n    return app;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst compression = require('compression');\nconst fs = require('fs');\nconst https = require('https');\nconst http = require('http');\nconst CONFIG = require('../config');\nconst apiRoutes = require('../routes/api');\nconst staticRoutes = require('../routes/static');\nconst errorHandler = require('../middleware/errorHandler');\n\nfunction createExpressApp() {\n  const app = express();\n\n  // Middleware\n  app.use(cors());\n  app.use(helmet());\n  app.use(morgan('dev'));\n  app.use(compression());\n\n  // Routes\n  app.use('/api', apiRoutes);\n  app.use('/', staticRoutes);\n\n  // Error handling\n  app.use(errorHandler);\n\n  // Server\n  const httpServer = http.createServer(app);\n  httpServer.listen(CONFIG.server.port, () => {\n    console.log(`HTTP server running on port ${CONFIG.server.port}`);\n  });\n\n  if (CONFIG.server.https) {\n    const httpsOptions = {\n      key: fs.readFileSync(CONFIG.server.https.key),\n      cert: fs.readFileSync(CONFIG.server.https.cert),\n    };\n    const httpsServer = https.createServer(httpsOptions, app);\n    httpsServer.listen(CONFIG.server.https.port, () => {\n      console.log(`HTTPS server running on port ${CONFIG.server.https.port}`);\n    });\n  }\n\n  return app;\n}\n\nmodule.exports = createExpressApp;\n```"
  }
]