[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that makes an HTTP request using the 'request' module in JavaScript and handles the response via a callback.\n\nFunction Description: The function 'makeHttpRequest' is designed to simplify making HTTP requests by wrapping the 'request' module's functionality. It takes an options object and a callback function, makes the HTTP request, and invokes the callback with the response body if the request is successful (status code 200 and no errors).\n\nInput:  \n- options: [Object] - Configuration object for the HTTP request, including properties like URL, headers, and data.  \n- callback: [Function] - A function to be called with the response body upon successful request completion.  \n\nOutput:  \n- None (The result is handled asynchronously via the callback function).",
    "Canonical_solution": "var request = require('request');\n\nfunction makeHttpRequest(options, callback) {\n    request(options, function(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            callback(body);\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "right_result": "function makeHttpRequest(options, callback) {\n  require('request')(options, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(body);\n    }\n  });\n}"
  },
  {
    "Task_id": 100,
    "Instruction": "Task Description: Create a function that sets up an Express server with various route handlers for handling HTTP requests related to email functionality, including authentication, sending test emails, and managing email server configurations.\n\nFunction Description: The function `setupExpressServer` initializes an Express server with middleware for parsing request bodies and cookies. It defines several route handlers for different HTTP methods (GET, POST) that handle email-related operations such as authentication, sending test emails, and saving email server configurations. The server listens on a specified port.\n\nInput: None (The function uses module-level variables like `processInfo.port` for configuration)\n\nOutput: None (The function starts a server that listens on the specified port and handles incoming HTTP requests)\n\nNote: The function relies on several external modules and variables that should be available in the scope:\n- `express`: The Express framework\n- `connect`: Middleware for Express\n- `fs`: File system module\n- `nodemailer`: For sending emails\n- `lcrypto`: For encryption\n- `lutil`: For file operations\n- `auth`: A variable storing authentication details\n- `processInfo`: An object containing server configuration (like port number)\n- `locker`: An object containing base URL for locker service\n- `request`: For making HTTP requests",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var connect = require('connect');\n    var app = express.createServer(connect.bodyParser(), connect.cookieParser());\n    \n    app.set('views', __dirname);\n    \n    app.get('/', function(req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!auth || req.param(\"change\")) return res.end(fs.readFileSync(__dirname + '/auth.html'));\n        res.write(\"<p>Using \"+auth.host+\":\"+auth.port+\" \");\n        if(auth.ssl) res.write(\"(ssl)\");\n        if(auth.user) res.write(\"authenticating as \"+auth.user);\n        res.write(\"<br><a href='?change=1'>change</a> or <a href='javascript:window.location=\\\"test?to=\\\"+window.prompt(\\\"recipient email address\\\")'>send test message</a>\");\n        res.end();\n    });\n    \n    app.post('/save', function(req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!req.body || !req.body.host || !req.body.port) return res.end(\"missing minimum required host/port :(\");\n        nodemailer.SMTP = auth = {host:req.body.host, port:req.body.port, ssl:false};\n        if(req.body.ssl) auth.ssl = true;\n        if(req.body.user && req.body.pass) {\n            auth.use_authentication = true;\n            auth.user = req.body.user;\n            auth.pass = lcrypto.encrypt(req.body.pass);\n        }\n        lutil.atomicWriteFileSync(\"auth.json\", JSON.stringify(auth, null, 4));\n        if(auth.pass) auth.pass = req.body.pass;\n        res.end(\"saved! <a href='./'>continue</a>\");\n    });\n    \n    app.get('/state', function (req, res) {\n        var ready = (auth) ? 1 : 0;\n        res.send({ready:ready});\n    });\n    \n    app.get('/test', function (req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!req.param(\"to\") || req.param(\"to\").indexOf(\"@\") <= 0) return res.end(\"invalid recipient\")\n        var message = {\n            sender: 'Testificate <42@awesome.com>',\n            to: req.param(\"to\"),\n            subject: 'test message  \u2714',\n            body: 'Hello to you!',\n            html:'<p>it <b>WORKED</b></p>',\n            debug: true\n        };\n        request.post({url:locker.lockerBase + \"/Me/smtp/send\", json:message}, function(err, r, body){\n            if(err || !body) return res.end(\"failed \"+err);\n            return res.end(\"sent!\");\n        });\n    });\n    \n    app.post('/send', function (req, res) {\n        if(!auth) return res.send(false);\n        if (!req.body || !req.body.to) return res.send(false);\n        console.error(\"DEBUG SMTP: \"+JSON.stringify(req.body));\n        var sent = false;\n        nodemailer.send_mail(req.body, function(err, ok){\n            if(sent) return;\n            sent=true;\n            if(err || !ok){\n                console.error('Error occured: '+err);\n                return res.send(false);\n            }\n            res.send(true);\n        })\n    });\n    \n    app.listen(processInfo.port,function() {\n        var returnedInfo = {};\n        console.log(JSON.stringify(returnedInfo));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst connect = require('connect');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\nconst lcrypto = require('lcrypto');\nconst lutil = require('lutil');\nconst auth = require('./auth');\nconst processInfo = require('./processInfo');\nconst locker = require('./locker');\nconst request = require('request');\n\nfunction setupExpressServer() {\n  const app = express();\n  app.use(connect.bodyParser());\n  app.use(connect.cookieParser());\n\n  // Authentication route\n  app.post('/api/auth/email', (req, res) => {\n    const { email, password } = req.body;\n    if (auth.authenticate(email, password)) {\n      res.status(200).json({ success: true });\n    } else {\n      res.status(401).json({ success: false, message: 'Invalid credentials' });\n    }\n  });\n\n  // Test email sending route\n  app.post('/api/email/test', (req, res) => {\n    const transporter = nodemailer.createTransport({\n      service: 'smtp',\n      host: 'smtp.example.com',\n      port: 587,\n      secure: false,\n      auth: {\n        user: 'user@example.com',\n        pass: 'password'\n      }\n    });\n\n    const mailOptions = {\n      from: 'user@example.com',\n      to: 'recipient@example.com',\n      subject: 'Test Email',\n      text: 'This is a test email sent from the server.'\n    };\n\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        res.status(500).json({ success: false, message: error.message });\n      } else {\n        res.status(200).json({ success: true, message: 'Email sent successfully' });\n      }\n    });\n  });\n\n  // Save email server configuration route\n  app.post('/api/email/config', (req, res) => {\n    const { smtpHost, smtpPort, smtpUser, smtpPass } = req.body;\n    // Save configuration to file or database\n    fs.writeFileSync('email-config.json', JSON.stringify({\n      smtpHost,\n      smtpPort,\n      smtpUser,\n      smtpPass\n    }, null, 2));\n    res.status(200).json({ success: true });\n  });\n\n  // Get email server configuration route\n  app.get('/api/email/config', (req, res) => {\n    const config = fs.readFileSync('email-config.json', 'utf8');\n    res.status(200).json(JSON.parse(config));\n  });\n\n  app.listen(processInfo.port, () => {\n    console.log(`Server running on port ${processInfo.port}`);\n  });\n}\n\nsetupExpressServer();"
  },
  {
    "Task_id": 102,
    "Instruction": "Task Description: Create a function that sets up an Express server with specific route handlers and middleware to demonstrate various aspects of request handling, error processing, and route termination in Express.js.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures middleware and route handlers to illustrate different scenarios in HTTP request processing including:\n- Basic middleware execution\n- Route termination\n- Error handling middleware\n- Unhandled routes\nThe server listens on port 3000 and logs various events to the console during operation.\n\nInput: None\n\nOutput: None (The function's effect is creating and starting an Express server that listens on port 3000)",
    "Canonical_solution": "function setupExpressServer() {\n    var app = require('express')();\n\n    app.use(function(req, res, next){ \n        console.log('\\n\\nALLWAYS');\n        next(); \n    });\n\n    app.get('/a', function(req, res){ \n        console.log('/a: route terminated'); \n        res.send('a'); \n    });\n    app.get('/a', function(req, res){ \n        console.log('/a: never called'); \n    });\n    app.get('/b', function(req, res, next){ \n        console.log('/b: route not terminated');\n        next();\n    });\n    app.use(function(req, res, next){\n        console.log('SOMETIMES');\n        next();\n    });\n    app.get('/b', function(req, res, next){\n        console.log('/b (part 2): error thrown' );\n        throw new Error('b failed');\n    });\n    app.use('/b', function(err, req, res, next){\n        console.log('/b error detected and passed on');\n        next(err);\n    });\n    app.get('/c', function(err, req){\n        console.log('/c: error thrown');\n        throw new Error('c failed');\n    });\n    app.use('/c', function(err, req, res, next){\n        console.log('/c: error deteccted but not passed on');\n        next();\n    });\n\n    app.use(function(err, req, res, next){\n        console.log('unhandled error detected: ' + err.message);\n        res.send('500 - server error');\n    });\n\n    app.use(function(req, res){\n        console.log('route not handled');\n        res.send('404 - not found');\n    });\n\n    app.listen(3000, function(){ \n        console.log('listening on 3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "function setupExpressServer() {\n  const express = require('express');\n  const app = express();\n\n  // Basic middleware\n  app.use((req, res, next) => {\n    console.log('Basic middleware executed');\n    next();\n  });\n\n  // Route termination\n  app.get('/hello', (req, res) => {\n    console.log('Route /hello executed');\n    res.send('Hello, World!');\n  });\n\n  // Error handling middleware\n  app.use((err, req, res, next) => {\n    console.error('Error handling middleware executed');\n    res.status(500).send('An error occurred');\n  });\n\n  // Unhandled route\n  app.use((req, res) => {\n    console.log('Unhandled route executed');\n    res.status(404).send('Not Found');\n  });\n\n  // Event listeners\n  app.on('request', (req, res) => {\n    console.log(`Request received for ${req.url}`);\n  });\n\n  app.on('error', (err) => {\n    console.error(`Server error: ${err.message}`);\n  });\n\n  app.on('listening', () => {\n    console.log('Server is listening on port 3000');\n  });\n\n  // Start the server\n  app.listen(3000);\n}"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Implement a function to set up an Express server that demonstrates different methods of file handling (streaming vs non-streaming) for serving large files, with performance monitoring capabilities.\n\nFunction Description: The function `setupExpressServer` creates an Express.js server that serves a large image file through four different endpoints, comparing streaming and non-streaming approaches. It includes response time monitoring middleware to measure performance. The server listens on port 3000 by default.\n\nInput: None (The function takes no parameters. All paths and configurations are internally defined.)\n\nOutput: None (The function doesn't return anything but starts an Express server that continues running until manually stopped.)\n\nNote: The function internally uses:\n1. Express framework for HTTP server\n2. Node.js filesystem module for file operations\n3. Path module for file path resolution\n4. response-time middleware for performance monitoring\n5. Predefined port (3000) and image path (CapitalOne_Digital_Skills_Infographic_BW.jpg in same directory)",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var fs = require('fs');\n    var path = require('path');\n    var port = 3000;\n    var app = express();\n    var responseTime = require('response-time');\n    var largeImagePath = path.join(__dirname,'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\n    app.use(responseTime());\n\n    app.get('/non-stream', function(req, res) {\n        var file = fs.readFile(largeImagePath, function(error, data){\n            res.end(data);\n        });\n    });\n\n    app.get('/non-stream2', function(req, res) {\n        var file = fs.readFileSync(largeImagePath);\n        res.end(file);\n    });\n\n    app.get('/stream', function(req, res) {\n        var stream = fs.createReadStream(largeImagePath);\n        stream.pipe(res);\n    });\n\n    app.get('/stream2', function(req, res) {\n        var stream = fs.createReadStream(largeImagePath);\n        stream.on('data', function(data) {\n            res.write(data);\n        });\n        stream.on('end', function() {\n            res.end();\n        });\n    });\n\n    app.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\nconst responseTime = require('response-time');\nconst fs = require('fs');\n\nconst app = express();\nconst port = 3000;\nconst imagePath = path.join(__dirname, 'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\napp.use(responseTime());\n\napp.get('/non-streaming', (req, res) => {\n  const stats = fs.statSync(imagePath);\n  const fileSize = stats.size;\n  const fileStream = fs.createReadStream(imagePath);\n  res.setHeader('Content-Type', 'image/jpeg');\n  res.setHeader('Content-Length', fileSize);\n  fileStream.pipe(res);\n});\n\napp.get('/streaming', (req, res) => {\n  res.setHeader('Content-Type', 'image/jpeg');\n  fs.createReadStream(imagePath).pipe(res);\n});\n\napp.get('/streaming-range', (req, res) => {\n  res.setHeader('Content-Type', 'image/jpeg');\n  res.setHeader('Accept-Ranges', 'bytes');\n  const range = req.headers.range;\n  if (!range) {\n    res.status(400).send('Unsupported request');\n    return;\n  }\n\n  const bytes = range.split('=');\n  const start = Math.max(0, bytes[1].split('-')[0]);\n  const end = bytes[1].split('-')[1] || start + 1024 * 1024 * 10; // 10MB\n  const fileSize = fs.statSync(imagePath).size;\n  const chunkSize = 1024 * 1024; // 1MB\n  const startByte = parseInt(start, 10);\n  const endByte = parseInt(end, 10);\n  const remaining = fileSize - endByte;\n\n  res.statusCode = 206;\n  res.setHeader('Content-Range', `bytes ${startByte}-${endByte}/${fileSize}`);\n  res.setHeader('Content-Length', endByte - startByte + 1);\n\n  const stream = fs.createReadStream(imagePath, { start: startByte, end: endByte });\n  stream.on('error', (err) => {\n    res.status(500).send(err.message);\n  });\n  stream.pipe(res);\n});\n\napp.get('/streaming-range-multiple', (req, res) => {\n  res.setHeader('Content-Type', 'image/jpeg');\n  res.setHeader('Accept-Ranges', 'bytes');\n  const range = req.headers.range;\n  if (!range) {\n    res.status(400).send('Unsupported request');\n    return;\n  }\n\n  const bytes = range.split('=');\n  const start = Math.max(0, bytes[1].split('-')[0]);\n  const end = bytes[1].split('-')[1] || start + 1024 * 1024 * 10; // 10MB\n  const fileSize = fs.statSync(imagePath).size;\n  const chunkSize = 1024 * 1024; // 1MB\n  const startByte = parseInt(start, 10);\n  const endByte = parseInt(end, 10);\n  const remaining = fileSize - endByte;\n\n  res.statusCode = 206;\n  res.setHeader('Content-Range', `bytes ${startByte}-${endByte}/${fileSize}`);\n  res.setHeader('Content-Length', endByte - startByte + 1);\n\n  const stream = fs.createReadStream(imagePath, { start: startByte, end: endByte });\n  stream.on('error', (err) => {\n    res.status(500).send(err.message);\n  });\n  stream.pipe(res);\n});\n\napp.listen(port, () => {\n  console.log(`Server is running on http://localhost:${port}`);\n});"
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Create a function that sets up an Express server to serve static files and handle API requests for product data.\n\nFunction Description: The function sets up an Express server that serves static files from the current directory and provides two API endpoints: one to retrieve all products and another to retrieve a specific product by ID. The server listens on port 3000.\n\nInput: None\n\nOutput: None (The function starts a server that listens on port 3000 and does not return any value)",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var app = express();\n\n    app.use(\"/\", express.static(__dirname));\n\n    var products = [\n        {id: 0, title: 'Paint pots', description: 'Pots full of paint', price: 3.95},\n        {id: 1, title: 'Polka dots', description: 'Dots with that polka groove', price: 12.95},\n        {id: 2, title: 'Pebbles', description: 'Just little rocks, really', price: 6.95}\n    ];\n\n    app.get('/products', function(req, res) {\n        res.send(products);\n    });\n\n    app.get('/products/:id', function(req, res) {\n        res.send(products[req.params.id]);\n    });\n\n    app.listen(3000);\n    console.log('Listening on port 3000');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\n\nfunction setupServer() {\n  const app = express();\n  const PORT = 3000;\n\n  // Serve static files from the current directory\n  app.use(express.static(path.join(__dirname)));\n\n  // Mock product data\n  const products = [\n    { id: 1, name: 'Product 1', price: 10.99 },\n    { id: 2, name: 'Product 2', price: 19.99 },\n    { id: 3, name: 'Product 3', price: 29.99 }\n  ];\n\n  // API endpoint to retrieve all products\n  app.get('/api/products', (req, res) => {\n    res.json(products);\n  });\n\n  // API endpoint to retrieve a specific product by ID\n  app.get('/api/products/:id', (req, res) => {\n    const productId = parseInt(req.params.id);\n    const product = products.find(p => p.id === productId);\n    if (product) {\n      res.json(product);\n    } else {\n      res.status(404).json({ error: 'Product not found' });\n    }\n  });\n\n  // Start the server\n  app.listen(PORT, () => {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  });\n}\n\nsetupServer();"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a function that sets up an Express server with Socket.IO for real-time communication, including CORS support, route handling, and socket event management for chat room functionality.\n\nFunction Description: The function `setupServer` initializes an Express application with HTTP and WebSocket support. It configures CORS middleware, handles socket connections for chat room operations (joining, messaging, disconnecting), and starts the server on a specified port. The function integrates Express routing and Socket.IO events to manage real-time communication between clients in different rooms.\n\nInput: None (The function uses environment variables for port configuration, with a default fallback to port 5000)\n\nOutput: None (The function starts a server process that listens for incoming HTTP and WebSocket connections, but doesn't return any value)",
    "Canonical_solution": "function setupServer() {\n    const http = require('http');\n    const express = require('express');\n    const socketio = require('socket.io');\n    const cors = require('cors');\n    \n    const app = express();\n    const server = http.createServer(app);\n    const io = socketio(server);\n    \n    app.use(cors());\n    app.use(router);\n    \n    io.on('connect', (socket) => {\n        socket.on('join', ({ name, room }, callback) => {\n            const { error, user } = addUser({ id: socket.id, name, room });\n            if(error) return callback(error);\n            socket.join(user.room);\n            socket.emit('message', { user: 'admin', text: `${user.name}, welcome to room ${user.room}.`});\n            socket.broadcast.to(user.room).emit('message', { user: 'admin', text: `${user.name} has joined!` });\n            io.to(user.room).emit('roomData', { room: user.room, users: getUsersInRoom(user.room) });\n            callback();\n        });\n        \n        socket.on('sendMessage', (message, callback) => {\n            const user = getUser(socket.id);\n            io.to(user.room).emit('message', { user: user.name, text: message });\n            callback();\n        });\n        \n        socket.on('disconnect', () => {\n            const user = removeUser(socket.id);\n            if(user) {\n                io.to(user.room).emit('message', { user: 'Admin', text: `${user.name} has left.` });\n                io.to(user.room).emit('roomData', { room: user.room, users: getUsersInRoom(user.room)});\n            }\n        });\n    });\n    \n    server.listen(process.env.PORT || 5000, () => console.log(`Server has started.`));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "```javascript\nfunction setupServer() {\n  const express = require('express');\n  const http = require('http');\n  const socketIO = require('socket.io');\n  const cors = require('cors');\n\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIO(server, {\n    cors: {\n      origin: '*',\n      methods: ['GET', 'POST']\n    }\n  });\n\n  app.use(cors());\n\n  app.get('/', (req, res) => {\n    res.send('Chat Server is running');\n  });\n\n  io.on('connection', (socket) => {\n    console.log('A user connected:', socket.id);\n\n    socket.on('joinRoom', (room) => {\n      socket.join(room);\n      console.log(`User ${socket.id} joined room ${room}`);\n    });\n\n    socket.on('sendMessage', (message, room) => {\n      io.to(room).emit('receiveMessage', { message, sender: socket.id });\n    });\n\n    socket.on('disconnect', () => {\n      console.log('User disconnected:', socket.id);\n    });\n  });\n\n  const port = process.env.PORT || 5000;\n  server.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n\nsetupServer();\n```"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a function that sets up a proxy server using Express and http-proxy-middleware to forward requests to a specified target URL.\n\nFunction Description: The function `createProxyServer` initializes an Express application, configures a proxy middleware to forward requests to a specified target URL (in this case, 'http://jsonplaceholder.typicode.com/users'), and starts the server on port 3000. It also handles graceful shutdown on receiving SIGINT or SIGTERM signals.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts a server and logs messages to the console.)",
    "Canonical_solution": "function createProxyServer() {\n    const express = require('express');\n    const { createProxyMiddleware } = require('../../dist');\n    \n    const jsonPlaceholderProxy = createProxyMiddleware({\n        target: 'http://jsonplaceholder.typicode.com/users',\n        changeOrigin: true,\n        logger: console,\n    });\n\n    const app = express();\n    app.use('/users', jsonPlaceholderProxy);\n    \n    const server = app.listen(3000);\n    console.log('[DEMO] Server: listening on port 3000');\n    console.log('[DEMO] Opening: http://localhost:3000/users');\n    \n    require('open')('http://localhost:3000/users');\n    \n    process.on('SIGINT', () => server.close());\n    process.on('SIGTERM', () => server.close());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "```javascript\nconst express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\n\nfunction createProxyServer() {\n  const app = express();\n  const target = 'http://jsonplaceholder.typicode.com/users';\n\n  app.use(createProxyMiddleware({\n    target,\n    changeOrigin: true,\n    pathRewrite: {\n      '^/users': '/users'\n    }\n  }));\n\n  app.listen(3000, () => {\n    console.log(`Proxy server running at http://localhost:3000`);\n  });\n\n  process.on('SIGINT', () => {\n    console.log('Shutting down proxy server...');\n    process.exit(0);\n  });\n\n  process.on('SIGTERM', () => {\n    console.log('Shutting down proxy server...');\n    process.exit(0);\n  });\n}\n\ncreateProxyServer();\n```"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server with WebSocket support using Express and Socket.IO, implementing a particle simulation system with cluster and client event handling.\n\nFunction Description: The function `startServer` initializes an Express application, sets up static file serving, integrates Socket.IO for real-time communication, and configures a particle simulation system with collision detection and cluster management. It handles particle movement, boundary collisions, and client interactions through defined event handlers.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function starts a server listening on port 3000 but doesn't return any value)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const app = express();\n    const server = require('http').Server(app);\n    const io = require('socket.io')(server);\n    const swip = require('../../../src/server/index.js');\n\n    app.use(express.static(__dirname + './../static'));\n\n    swip(io, {\n        cluster: {\n            events: {\n                update: (cluster) => {\n                    const blobs = cluster.data.blobs;\n                    const clients = cluster.clients;\n\n                    const updatedBlobs = blobs.map((blob) => {\n                        const boundaryOffset = blob.size;\n                        const client = clients.find((c) => isParticleInClient(blob, c));\n\n                        let nextPosX = blob.x + blob.speedX;\n                        let nextPosY = blob.y + blob.speedY;\n                        let nextSpeedX = blob.speedX;\n                        let nextSpeedY = blob.speedY;\n\n                        if (client) {\n                            if (((blob.speedX < 0) &&\n                                ((nextPosX - boundaryOffset) < client.transform.x)\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.left, nextPosY))) {\n                                nextPosX = client.transform.x + boundaryOffset;\n                                nextSpeedX = blob.speedX * -1;\n                            } else if (((blob.speedX > 0) &&\n                                ((nextPosX + boundaryOffset) > (client.transform.x + client.size.width))\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.right, nextPosY))) {\n                                nextPosX = client.transform.x + (client.size.width - boundaryOffset);\n                                nextSpeedX = blob.speedX * -1;\n                            }\n\n                            if (((blob.speedY < 0) &&\n                                ((nextPosY - boundaryOffset) < client.transform.y\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.top, nextPosX)))) {\n                                nextPosY = client.transform.y + boundaryOffset;\n                                nextSpeedY = blob.speedY * -1;\n                            } else if (((blob.speedY > 0) &&\n                                ((nextPosY + boundaryOffset) > (client.transform.y + client.size.height))\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.bottom, nextPosX))\n                            ) {\n                                nextPosY = client.transform.y + (client.size.height - boundaryOffset);\n                                nextSpeedY = blob.speedY * -1;\n                            }\n                        } else {\n                            const firstClient = clients[0];\n                            nextPosX = firstClient.transform.x + (firstClient.size.width / 2);\n                            nextPosY = firstClient.transform.y + (firstClient.size.height / 2);\n                            nextSpeedX = 0;\n                            nextSpeedY = 0;\n                        }\n\n                        blob.x = nextPosX;\n                        blob.y = nextPosY;\n                        blob.speedX = nextSpeedX;\n                        blob.speedY = nextSpeedY;\n\n                        return blob;\n                    });\n\n                    return {\n                        blobs: { $set: updatedBlobs },\n                    };\n                },\n                merge: (cluster1, cluster2, transform) => ({\n                    blobs: { $set: getNewParticleDist(cluster1, cluster2, transform) },\n                    backgroundColor: { $set: cluster1.data.backgroundColor },\n                }),\n            },\n            init: () => ({ blobs: [], backgroundColor: getRandomColor() }),\n        },\n\n        client: {\n            init: () => ({}),\n            events: {\n                addBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $push: blobs } },\n                        },\n                    };\n                },\n                updateBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $set: blobs } },\n                        },\n                    };\n                },\n            },\n        },\n    });\n\n    server.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\n\nfunction startServer() {\n  if (cluster.isMaster) {\n    const numCpus = os.cpus().length;\n    for (let i = 0; i < numCpus; i++) {\n      cluster.fork();\n    }\n  } else {\n    const app = express();\n    const server = http.createServer(app);\n    const io = socketIo(server);\n\n    app.use(express.static(__dirname + '/public'));\n\n    let particles = [];\n\n    io.on('connection', (socket) => {\n      socket.on('createParticle', (data) => {\n        particles.push(data);\n        io.emit('updateParticles', particles);\n      });\n\n      socket.on('updateParticle', (data) => {\n        const index = particles.findIndex(p => p.id === data.id);\n        if (index !== -1) {\n          particles[index] = data;\n          io.emit('updateParticles', particles);\n        }\n      });\n\n      socket.on('deleteParticle', (id) => {\n        particles = particles.filter(p => p.id !== id);\n        io.emit('updateParticles', particles);\n      });\n\n      socket.on('disconnect', () => {\n        console.log('Client disconnected');\n      });\n    });\n\n    server.listen(3000, () => {\n      console.log('Server is running on port 3000');\n    });\n  }\n}\n\nstartServer();\n```"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server using the Express framework, defines a route to handle GET requests for user data, and renders a view with the user data.\n\nFunction Description: The function `startServer` sets up an Express application, configures a route to respond to GET requests at the '/users' endpoint, and starts the server on port 3000. When the '/users' route is accessed, it sends a response containing a list of user objects to be rendered in a view.\n\nInput: None\n\nOutput: None (The function starts a server that listens on port 3000 and logs a message to the console when the server is running.)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const app = express();\n    \n    app.get('/users', function (req, res) {\n        const users = [\n            { name: 'Suissa' },\n            { name: 'Itacir' },\n            { name: 'Caio' }\n        ];\n        res.render('users/views/list', {users});\n    });\n\n    app.listen(3000, function () {\n        console.log('Servidor rodando em localhost:3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst app = express();\n\napp.get('/users', (req, res) => {\n  const users = [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' }\n  ];\n  res.render('users', { users });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a function that sets up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB, integrates with Next.js for server-side rendering, and sets up basic route handling. It prepares the Next.js application, configures middleware, and starts the server on a specified port.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret for session encryption)\n\nOutput: Returns a Promise that resolves to the configured Express server instance when the Next.js app is prepared and the server is listening on the specified port.",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  return app.prepare().then(async () => {\n    const server = express();\n\n    server.use(express.json());\n\n    const sessionOptions = {\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: mongoSessionStore.create({\n        mongoUrl: MONGO_URL,\n        ttl: 14 * 24 * 60 * 60,\n      }),\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        httpOnly: true,\n        maxAge: 14 * 24 * 60 * 60 * 1000,\n        domain: 'localhost',\n      },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => {\n      const url = URL_MAP[req.path];\n      if (url) {\n        app.render(req, res, url);\n      } else {\n        handle(req, res);\n      }\n    });\n\n    server.listen(port, (err) => {\n      if (err) throw err;\n      console.log(`> Ready on ${ROOT_URL}`);\n    });\n\n    return server;\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst { MongoClient } = require('mongodb');\n\nconst dev = process.env.NODE_ENV === 'development';\nconst app = next({ dev });\nconst server = express();\n\nconst mongoUrl = process.env.MONGO_URL_TEST;\nconst port = process.env.PORT || 8000;\nconst sessionName = process.env.SESSION_NAME || 'session';\nconst sessionSecret = process.env.SESSION_SECRET || 'secret';\n\nconst store = new MongoDBStore({\n  uri: mongoUrl,\n  collection: 'sessions'\n});\n\nstore.on('error', function (error) {\n  console.error('MongoDB Session Store Error:', error);\n});\n\nserver.use(session({\n  name: sessionName,\n  secret: sessionSecret,\n  resave: false,\n  saveUninitialized: true,\n  store: store,\n  cookie: {\n    maxAge: 60 * 60 * 1000, // 1 hour\n    sameSite: 'lax',\n    secure: false\n  }\n}));\n\napp.prepare().then(() => {\n  server.use(express.static('public'));\n  server.use('/_next', express.static(app.nextDataDirectory));\n\n  server.get('/', (req, res) => {\n    return app.render(req, res, '/');\n  });\n\n  server.get('/api/test', (req, res) => {\n    res.json({ message: 'Hello from API route!' });\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});\n```"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Create a function to set up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB as the session store. It integrates Next.js for server-side rendering and sets up a catch-all route handler. The server listens on a specified port and connects to MongoDB using environment variables for configuration.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that:\n- Listens on the specified port\n- Outputs the server URL to console when ready\n- Maintains persistent connections to MongoDB for session storage)",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  mongoose.connect(MONGO_URL);\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  const server = express();\n\n  const sessionOptions = {\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    store: mongoSessionStore.create({\n      mongoUrl: MONGO_URL,\n      ttl: 14 * 24 * 60 * 60,\n    }),\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n      httpOnly: true,\n      maxAge: 14 * 24 * 60 * 60 * 1000,\n      domain: 'localhost',\n    },\n  };\n\n  const sessionMiddleware = session(sessionOptions);\n  server.use(sessionMiddleware);\n\n  server.get('*', (req, res) => handle(req, res));\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on ${ROOT_URL}`);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBSessionStore = require('connect-mongodb-session')(session);\nconst app = next();\nconst handle = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const port = process.env.PORT || 8000;\n  const mongoUrl = process.env.MONGO_URL_TEST;\n  const sessionName = process.env.SESSION_NAME || 'session';\n  const sessionSecret = process.env.SESSION_SECRET || 'secret';\n\n  const store = new MongoDBSessionStore({\n    uri: mongoUrl,\n    collection: 'sessions'\n  });\n\n  const server = express();\n\n  server.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { maxAge: 60000000 }\n  }));\n\n  server.use(express.static('./public'));\n\n  server.get('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`Server is running on http://localhost:${port}`);\n  });\n});\n```"
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a function that sets up an Express server with rate limiting, CORS support, and route handlers for querying webpage elements and retrieving full HTML content using Chrome DevTools Protocol.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js server with middleware configuration and defines three routes:\n1. `/query` - Extracts specified elements' innerText and href attributes from a given URL\n2. `/fullHtml` - Retrieves the complete HTML of a given URL\n3. `/` - Serves a static index.html file\n\nThe function implements rate limiting, CORS, and proper error handling while using Chrome DevTools Protocol to interact with web pages programmatically.\n\nInput: None (The function doesn't take any parameters. Configuration is loaded from external files.)\n\nOutput: None (The function's output is the running Express server listening on the specified port, which defaults to 3000 if not provided via environment variables.)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express');\n    const path = require('path');\n    const cors = require('cors');\n    const rateLimit = require('express-rate-limit');\n    const config = require('./config');\n\n    const app = express();\n    app.enable('trust proxy');\n    const limiter = rateLimit(config.rateLimit);\n    app.use('/fullHtml', limiter);\n    app.use('/query', limiter);\n    app.use(cors());\n    app.set('json replacer', null);\n    app.set('json spaces', 2);\n\n    app.get('/query', async (req, res) => {\n        const { url, selectors } = req.query;\n        if (!url || typeof url !== 'string' || !url.startsWith('http')) {\n            res.status(400).send('must provide a url');\n            throw new Error('throwing as url not valid');\n        }\n        if (!selectors) {\n            res.status(400).send('must provide selectors');\n            throw new Error('throwing as selectors not valid');\n        }\n        const selectorArr = selectors.split(',');\n        await launchChrome({\n            flags: ['--window-size=1280,1696', '--hide-scrollbars'],\n        });\n        let client;\n        try {\n            client = await CDP();\n            const { Network, Page, Runtime } = client;\n            await Network.enable();\n            await Page.enable();\n            await Network.setCacheDisabled({ cacheDisabled: true });\n            await Page.navigate({ url });\n            const requestCounterMinWaitMs = 1500;\n            const requestCounterMaxWaitMs = 20000;\n            let numSent = 0;\n            let numReceived = 0;\n            const startTime = new Date().getTime();\n            function minWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMinWaitMs;\n            }\n            function maxWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMaxWaitMs;\n            }\n            Network.requestWillBeSent((params) => {\n                if (params.type === 'XHR') {\n                    ++numSent;\n                }\n            });\n            Network.responseReceived((params) => {\n                if (params.type === 'XHR') {\n                    ++numReceived;\n                }\n            });\n            await new Promise((resolve, reject) => {\n                Page.loadEventFired(() => {\n                    const ajaxDoneInterval = setInterval(() => {\n                        if (numSent === numReceived && minWaitTimeExceeded()) {\n                            clearInterval(ajaxDoneInterval);\n                            resolve();\n                        } else if (maxWaitTimeExceeded()) {\n                            reject(new Error('ajax timeout after 20 seconds'));\n                        }\n                    }, 300);\n                });\n            });\n            const promiseArr = selectorArr.map(async (selector) => {\n                const innerTextRes = await Runtime.evaluate({\n                    expression: `document.querySelector('${selector}').innerText`,\n                });\n                const hrefRes = await Runtime.evaluate({\n                    expression: `document.querySelector('${selector}').href`,\n                });\n                return {\n                    innerText: innerTextRes.result.value,\n                    href: hrefRes.result.value,\n                };\n            });\n            const queryRes = await Promise.all(promiseArr.map(p => p.catch(e => e.message)));\n            res.json({\n                url,\n                selectors,\n                contents: queryRes,\n            });\n        } catch (err) {\n            res.status(503).send({\n                msg: 'request error',\n                emsg: err.message,\n            });\n        } finally {\n            if (client) {\n                await client.close();\n            }\n        }\n    });\n\n    app.get('/fullHtml', async (req, res) => {\n        const { url } = req.query;\n        if (!url || typeof url !== 'string' || !url.startsWith('http')) {\n            res.status(400).send('must provide a url');\n            throw new Error('throwing as url not valid');\n        }\n        await launchChrome({\n            flags: ['--window-size=1280,1696', '--hide-scrollbars'],\n        });\n        let client;\n        try {\n            client = await CDP();\n            const { Network, Page, Runtime } = client;\n            await Network.enable();\n            await Page.enable();\n            await Network.setCacheDisabled({ cacheDisabled: true });\n            await Page.navigate({ url });\n            const requestCounterMinWaitMs = 1500;\n            const requestCounterMaxWaitMs = 20000;\n            let numSent = 0;\n            let numReceived = 0;\n            const startTime = new Date().getTime();\n            function minWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMinWaitMs;\n            }\n            function maxWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMaxWaitMs;\n            }\n            Network.requestWillBeSent((params) => {\n                if (params.type === 'XHR') {\n                    ++numSent;\n                }\n            });\n            Network.responseReceived((params) => {\n                if (params.type === 'XHR') {\n                    ++numReceived;\n                }\n            });\n            await new Promise((resolve, reject) => {\n                Page.loadEventFired(() => {\n                    const ajaxDoneInterval = setInterval(() => {\n                        if (numSent === numReceived && minWaitTimeExceeded()) {\n                            clearInterval(ajaxDoneInterval);\n                            resolve();\n                        } else if (maxWaitTimeExceeded()) {\n                            reject(new Error('ajax timeout after 20 seconds'));\n                        }\n                    }, 300);\n                });\n            });\n            const result = await Runtime.evaluate({\n                expression: 'document.documentElement.outerHTML',\n            });\n            const html = result.result.value;\n            res.send({\n                url,\n                html,\n            });\n        } catch (err) {\n            res.status(503).send({\n                msg: 'request error',\n                emsg: err.message,\n            });\n        } finally {\n            if (client) {\n                await client.close();\n            }\n        }\n    });\n\n    app.get('/', function(req, res) {\n        res.sendFile(path.join(__dirname, '../public/index.html'));\n    });\n\n    const { PORT = 3000 } = process.env;\n    app.listen(PORT);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst cors = require('cors');\nconst rateLimit = require('express-rate-limit');\nconst { chromium } = require('puppeteer');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per window\n  message: 'Too many requests from this IP, please try again later.',\n});\n\n// CORS middleware\napp.use(cors());\n\n// Apply rate limiting to all routes\napp.use(limiter);\n\n// Serve static files\napp.use(express.static(path.join(__dirname, 'public')));\n\n// Route for querying webpage elements\napp.post('/query', async (req, res) => {\n  try {\n    const { url, selectors } = req.body;\n    const browser = await chromium.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n\n    const results = {};\n    for (const selector of selectors) {\n      const element = await page.$(selector);\n      if (element) {\n        results[selector] = {\n          innerText: await element.evaluate(el => el.innerText),\n          href: await element.evaluate(el => el.getAttribute('href'))\n        };\n      } else {\n        results[selector] = null;\n      }\n    }\n\n    await browser.close();\n    res.json(results);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: 'An error occurred while querying the webpage.' });\n  }\n});\n\n// Route for retrieving full HTML content\napp.get('/fullHtml', async (req, res) => {\n  try {\n    const { url } = req.query;\n    const browser = await chromium.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: 'An error occurred while retrieving the HTML content.' });\n  }\n});\n\n// Root route\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a JavaScript function that initializes and configures an Express server with middleware, route handling, and environment-specific settings, then starts the server on a specified port.\n\nFunction Description: The function `createAndConfigureServer` initializes an Express server, configures middleware for request processing, sets up view engines, defines route handlers, and applies environment-specific configurations. The function `startServer` takes the configured server instance and starts it on the specified port.\n\nInput: \n- `port` (Number) - The port number on which the server should listen.\n\nOutput: \n- `app` (Object) - The configured Express server instance (returned by `createAndConfigureServer`).\n- Server startup log message (output by `startServer`).\n\nMethods:\n- `createAndConfigureServer()` -> Object - Creates and configures an Express server with middleware, routes, and environment settings.\n- `startServer(app, port)` -> undefined - Starts the Express server on the specified port and logs the server status.",
    "Canonical_solution": "var express = require('express');\nvar routes = require('./routes');\n\nfunction createAndConfigureServer() {\n    var app = express.createServer();\n    \n    app.configure(function(){\n        app.set('views', __dirname + '/views');\n        app.set('view engine', 'jade');\n        app.use(express.bodyParser());\n        app.use(express.methodOverride());\n        app.use(app.router);\n        app.use(express.static(__dirname + '/public'));\n    });\n\n    app.configure('development', function(){\n        app.use(express.errorHandler({ dumpExceptions: true, showStack: true })); \n    });\n\n    app.configure('production', function(){\n        app.use(express.errorHandler()); \n    });\n\n    app.get('/', routes.index);\n    \n    return app;\n}\n\nfunction startServer(app, port) {\n    app.listen(port);\n    console.log(\"Express server listening on port %d in %s mode\", app.address().port, app.settings.env);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "function createAndConfigureServer() {\n  const app = require('express')();\n  const path = require('path');\n  const env = process.env.NODE_ENV || 'development';\n\n  // Middleware\n  app.use(require('morgan')('dev'));\n  app.use(require('body-parser').json());\n  app.use(require('body-parser').urlencoded({ extended: true }));\n  app.use((req, res, next) => {\n    console.log(`Request URL: ${req.url}`);\n    next();\n  });\n\n  // View engine\n  app.set('views', path.join(__dirname, 'views'));\n  app.set('view engine', 'ejs');\n\n  // Routes\n  app.get('/', (req, res) => {\n    res.render('index', { title: 'Express App' });\n  });\n\n  app.get('/about', (req, res) => {\n    res.send('About page');\n  });\n\n  // Environment-specific settings\n  if (env === 'production') {\n    app.use((req, res) => {\n      res.header('Content-Type', 'text/plain');\n      res.send('Production mode');\n    });\n  } else {\n    app.use((req, res) => {\n      res.header('Content-Type', 'text/html');\n      res.send('<h1>Development mode</h1>');\n    });\n  }\n\n  return app;\n}\n\nfunction startServer(app, port) {\n  app.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}\n\nmodule.exports = { createAndConfigureServer, startServer };"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a function to set up an Express.js server with middleware configuration, route handling, and database synchronization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with CORS support, request body parsing, and database synchronization. It configures middleware, defines basic routes, and starts the server on a specified port. The server integrates authentication and user management routes from external modules.\n\nInput: None (The function takes no parameters as it's self-contained for server setup)\n\nOutput: None (The function doesn't return anything but starts a server process that listens on the specified port)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require(\"express\");\n    const bodyParser = require(\"body-parser\");\n    const cors = require(\"cors\");\n\n    const app = express();\n\n    var corsOptions = {\n        origin: \"http://localhost:8081\"\n    };\n\n    app.use(cors(corsOptions));\n    app.use(bodyParser.json());\n    app.use(bodyParser.urlencoded({ extended: true }));\n\n    const db = require(\"./app/models\");\n    const Role = db.role;\n\n    db.sequelize.sync();\n\n    app.get(\"/\", (req, res) => {\n        res.json({ message: \"Welcome to bezkoder application.\" });\n    });\n\n    require('./app/routes/auth.routes')(app);\n    require('./app/routes/user.routes')(app);\n\n    const PORT = process.env.PORT || 8080;\n    app.listen(PORT, () => {\n        console.log(`Server is running on port ${PORT}.`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst db = require('./database'); // Assuming a database module is available\n\nconst app = express();\n\n// Middleware configuration\napp.use(cors());\napp.use(bodyParser.json());\n\n// Database synchronization\ndb.sync().then(() => {\n  console.log('Database synchronized successfully');\n});\n\n// Route handling\napp.get('/', (req, res) => {\n  res.send('Express server is running');\n});\n\n// Import and use authentication routes\nconst authRoutes = require('./routes/auth');\napp.use('/auth', authRoutes);\n\n// Import and use user management routes\nconst userRoutes = require('./routes/users');\napp.use('/users', userRoutes);\n\n// Start the server\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a function that sets up a proxy server using Express and http-proxy-middleware to forward requests to a target API while modifying request and response headers.\n\nFunction Description: The function `createProxyServer` initializes an Express application that acts as a proxy server. It configures middleware to forward all incoming requests to a specified target API (https://api.openai.com in this case), removes certain headers from outgoing requests, and adds CORS headers to responses. The server listens on port 9000 by default.\n\nInput: None (The function takes no parameters as all configurations are hardcoded)\n\nOutput: None (The function doesn't return anything but starts a server process that continues running)",
    "Canonical_solution": "function createProxyServer() {\n    const express = require('express');\n    const { createProxyMiddleware } = require('http-proxy-middleware');\n    const app = express();\n    const port = 9000;\n\n    app.use('/', createProxyMiddleware({\n        target: 'https://api.openai.com',\n        changeOrigin: true,\n        onProxyReq: (proxyReq, req, res) => {\n            proxyReq.removeHeader('x-forwarded-for');\n            proxyReq.removeHeader('x-real-ip');\n        },\n        onProxyRes: function (proxyRes, req, res) {\n            proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n        }\n    }));\n\n    app.listen(port, () => {\n        console.log(`Example app listening at http://localhost:${port}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "```javascript\nconst express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\n\nfunction createProxyServer() {\n  const app = express();\n  const target = 'https://api.openai.com';\n\n  app.use((req, res, next) => {\n    // Remove specific headers from the request\n    delete req.headers['x-forwarded-for'];\n    delete req.headers['x-real-ip'];\n    next();\n  });\n\n  app.use(\n    '/api',\n    createProxyMiddleware({\n      target,\n      changeOrigin: true,\n      pathRewrite: { '^/api': '' },\n      onProxyReq: (proxyReq, req, res, options) => {\n        // Optionally modify proxy request here\n      },\n      onProxyRes: (proxyRes, req, res) => {\n        // Add CORS headers to the response\n        res.header('Access-Control-Allow-Origin', '*');\n        res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n        res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n        res.header('Access-Control-Allow-Credentials', 'true');\n        res.header('Vary', 'Origin');\n        res.header('Cache-Control', 'no-cache');\n        res.header('Content-Type', 'application/json');\n        res.header('X-Content-Type-Options', 'nosniff');\n        res.header('X-Frame-Options', 'DENY');\n        res.header('X-XSS-Protection', '1; mode=block');\n      }\n    })\n  );\n\n  app.listen(9000, () => {\n    console.log('Proxy server is running on port 9000');\n  });\n}\n\ncreateProxyServer();\n```"
  },
  {
    "Task_id": 117,
    "Instruction": "Task Description: Create a function to set up an Express server with middleware configuration, route handling, and server initialization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with static file serving, request body parsing middleware, and route handlers for GET and POST requests. It starts the server on a specified port and logs the server's startup information.\n\nInput: None (The function doesn't take any explicit parameters. Port configuration would typically be set via `app.set('port', ...)` before calling this function.)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server that listens on the specified port.)",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var app = express();\n\n    // Configure middleware\n    app.use(express.static(__dirname + '/public'));\n    app.use(require('body-parser')());\n\n    // Define routes\n    app.get('/', function(req, res) {\n        res.render('home');\n    });\n\n    app.post('/process', function(req, res) {\n        if(req.xhr || req.accepts('json,html')==='json'){\n            res.send({ success: true });\n        } else {\n            res.redirect(303, '/thank-you');\n        }\n    });\n\n    // Start server\n    app.listen(app.get('port'), function() {\n        console.log('Express started on http://localhost:' + app.get('port'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\napp.post('/data', (req, res) => {\n  res.send('Received data: ' + JSON.stringify(req.body));\n});\n\nconst port = process.env.PORT || 3000;\napp.set('port', port);\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});"
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a function that starts an HTTP server using Express to serve static files and provide JSON data, while also opening the default browser to the server's URL.\n\nFunction Description: The function `startServer` initializes an Express application, configures middleware for serving static files, sets up route handlers for the root path and a data endpoint, and starts the server on a specified port. It also opens the server URL in the default browser and logs status messages to the console.\n\nInput:\n- `data`: [Object] - The JSON data to be served at the '/getstats' endpoint\n- `port`: [Number] - The port number on which the server should listen\n- `update`: [Function] - (Optional) A callback function to be executed when the server starts\n\nOutput:\n- None (The function starts a server process and does not return a value)",
    "Canonical_solution": "function startServer(data, port, update) {\n    const express = require('express');\n    const path = require('path');\n    const opener = require('opener');\n    const colors = require('colors');\n\n    const app = express();\n    const url = `http://localhost:${port}/`;\n    const options = {\n        root: path.join(__dirname, '..', 'build')\n    };\n\n    app.use(express.static(options.root));\n    app.use('/css', express.static(path.join(__dirname, '..', 'build', 'css')));\n\n    app.get('/', (req, res) => {\n        res.sendFile('index.html', options);\n    });\n\n    app.get('/getstats', (req, res) => {\n        res.json(data);\n    });\n\n    app.listen(port, () => {\n        opener(url);\n        console.log(\n            colors.bold('\\nWebpack-Monitor'),\n            `is running on port ${port}!`\n        );\n        console.log(colors.italic.red('Press ctrl C to exit'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst http = require('http');\nconst { open } = require('utils');\nconst app = express();\nconst server = http.createServer(app);\n\nfunction startServer(data, port, update) {\n  app.use(express.static(__dirname + '/public'));\n\n  app.get('/', (req, res) => {\n    res.sendFile(__dirname + '/public/index.html');\n  });\n\n  app.get('/getstats', (req, res) => {\n    res.json(data);\n  });\n\n  server.listen(port, () => {\n    const url = `http://localhost:${port}`;\n    console.log(`Server running at ${url}`);\n    open(url);\n    if (update) update();\n  });\n}"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a function to set up an Express server that handles HTTP requests for Wikipedia summaries, including CORS configuration and route handling.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures CORS middleware with specific options, defines a route handler for GET requests to '/wikipedia_summaries', and starts the server on a specified port. The route handler retrieves Wikipedia links based on a keyword, fetches summaries and categories for those links, and returns them as JSON.\n\nInput: None (The function does not take any direct input parameters, but the route handler within the function processes query parameters from the HTTP request.)\n\nOutput: None (The function does not return a value, but it starts an HTTP server that listens on the specified port and responds to requests with JSON data.)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express');\n    const cors = require('cors');\n    const axios = require('axios');\n    \n    const app = express();\n    \n    const corsOptions = {\n        origin: ['https://neurite.network', 'http://localhost:8080'],\n        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',\n        credentials: true,\n        optionsSuccessStatus: 204\n    };\n    \n    app.use(cors(corsOptions));\n    \n    app.get('/wikipedia_summaries', async (req, res) => {\n        const keyword = req.query.keyword;\n        const topNLinks = parseInt(req.query.top_n_links) || 2;\n        const srwhat = req.query.srwhat || null;\n        const srsort = req.query.srsort || 'relevance';\n        const exsentences = parseInt(req.query.exsentences) || 3;\n        const topExsentences = parseInt(req.query.top_exsentences) || 6;\n        const topNCategories = parseInt(req.query.top_n_categories) || 5;\n        \n        const topLinks = await getWikipediaLinks(keyword, topNLinks, srwhat, srsort);\n        const selectedLinks = topLinks.slice(0, topNLinks);\n        \n        const summaries = await Promise.all(\n            selectedLinks.map(async (link, i) => {\n                const summaryExsentences = i === 0 ? topExsentences : exsentences;\n                const summary = await getWikipediaSummary(link, summaryExsentences);\n                const cleanSummary = removeHtmlTags(summary);\n                const categories = await getWikipediaCategories(link, keyword, topNCategories);\n                return { title: link, summary: cleanSummary, categories };\n            })\n        );\n        \n        res.json(summaries);\n    });\n    \n    const port = process.env.PORT || 5000;\n    app.listen(port, () => {\n        console.log(`Server is running on port ${port}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst cors = require('cors');\nconst axios = require('axios');\n\nconst setupExpressServer = () => {\n  const app = express();\n  const PORT = 3000;\n\n  const wikipediaRouteHandler = async (req, res) => {\n    try {\n      const keyword = req.query.keyword;\n      if (!keyword) {\n        return res.status(400).json({ error: 'Keyword is required' });\n      }\n\n      // Example: Fetch Wikipedia links based on keyword\n      const response = await axios.get(`https://en.wikipedia.org/w/api.php?action=opensearch&format=json&search=${encodeURIComponent(keyword)}`);\n      const results = response.data[1]; // Wikipedia search results\n\n      const summaries = [];\n      for (const link of results) {\n        const summaryResponse = await axios.get(`https://en.wikipedia.org/w/api.php?action=parse&format=json&prop=extracts&titles=${encodeURIComponent(link)}`);\n        const page = summaryResponse.data.parse;\n        summaries.push({\n          link,\n          summary: page.extract || 'No summary available',\n          category: 'General Knowledge' // Placeholder category\n        });\n      }\n\n      res.json(summaries);\n    } catch (error) {\n      console.error('Error fetching Wikipedia data:', error);\n      res.status(500).json({ error: 'Failed to fetch Wikipedia data' });\n    }\n  };\n\n  app.use(cors());\n  app.get('/wikipedia_summaries', wikipediaRouteHandler);\n  app.listen(PORT, () => {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  });\n};\n\nsetupExpressServer();"
  },
  {
    "Task_id": 121,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server using Express.js, which serves a predefined list of spells and handles CORS (Cross-Origin Resource Sharing) to allow requests from different origins.\n\nFunction Description: The function `startServer` sets up an Express.js server that listens on port 1234. It configures CORS middleware to enable cross-origin requests and defines a single route (`/spell`) that returns a JSON array of spell names. The server starts listening once all configurations are complete.\n\nInput: None. The function does not take any input parameters.\n\nOutput: None. The function does not return any value but starts an HTTP server that logs a message to the console when it begins listening on the specified port.",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const cors = require('cors');\n    \n    const spells = [\n        'Avada Kedavra',\n        'Crucio',\n        'Vulnera Sanentur',\n        'Vingardium Leviosa',\n        'Alohomora'\n    ];\n    \n    const app = express();\n    app.use(cors());\n    app.options('*', cors());\n    \n    app.get('/spell', (req, res) => {\n        res.json(spells);\n    });\n    \n    app.listen(1234, () => {\n        console.log('Listening on port 1234');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst cors = require('cors');\n\nfunction startServer() {\n  const app = express();\n  const spells = ['Fireball', 'Lightning', 'Ice Storm', 'Heal', 'Invisibility'];\n\n  app.use(cors());\n\n  app.get('/spell', (req, res) => {\n    res.json(spells);\n  });\n\n  app.listen(1234, () => {\n    console.log('Server is running on port 1234');\n  });\n}\n\nstartServer();"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to efficiently handle large files.\n\nFunction Description: The function `uploadFileViaPipe` streams a file from the local filesystem to an HTTP server using Node.js's built-in `fs` and `http` modules. It utilizes the pipe mechanism to efficiently transfer data without loading the entire file into memory, making it suitable for large files. The function assumes a predefined server port and file path.\n\nInput: \n- None (The function uses hardcoded values for demonstration purposes. In a real implementation, these would typically be parameters.)\n\nOutput: \n- None (The function performs a side effect of uploading a file. Success or failure would typically be handled via callbacks or events in a production implementation.)",
    "Canonical_solution": "function uploadFileViaPipe() {\n    var http = require('http');\n    var fs = require('fs');\n    var path = require('path');\n    \n    var testFilePath = path.join(__dirname, '../fixture/file/binaryfile.tar.gz');\n    var port = common.port;\n\n    var request = http.request({\n        port: port,\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/octet-stream'\n        }\n    });\n\n    fs.createReadStream(testFilePath).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "right_result": "const fs = require('fs');\nconst http = require('http');\n\nfunction uploadFileViaPipe() {\n  const serverPort = 3000;\n  const filePath = './example.txt';\n  const fileStream = fs.createReadStream(filePath);\n\n  const request = http.request({\n    hostname: 'localhost',\n    port: serverPort,\n    path: '/upload',\n    method: 'POST'\n  }, (response) => {\n    response.on('data', (chunk) => {\n      console.log(`Received ${chunk.length} bytes of data.`);\n    });\n    response.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  request.on('error', (error) => {\n    console.error(`Problem with request: ${error.message}`);\n  });\n\n  fileStream.on('error', (error) => {\n    console.error(`Problem with file stream: ${error.message}`);\n  });\n\n  fileStream.pipe(request);\n}"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to handle large files efficiently.\n\nFunction Description: The function uploads a specified file to a server using Node.js's filesystem and HTTP modules. It streams the file content directly to the HTTP request using pipe(), avoiding loading the entire file into memory. The function sets appropriate headers including content-type (multipart/form-data) and content-length.\n\nInput:\n- FIXTURE: [String] - Path to the file to be uploaded\n- TEST_PORT: [Number] - Port number of the server to upload to\n- BOUNDARY: [String] - Boundary string for multipart form data\n\nOutput: None (The function makes an HTTP request but doesn't return any value. The actual upload result would be handled by the server's response, which isn't captured in this function.)",
    "Canonical_solution": "function uploadFile() {\n  const fs = require('fs');\n  const http = require('http');\n  \n  const stat = fs.statSync(FIXTURE);\n  const request = http.request({\n    port: TEST_PORT,\n    path: '/',\n    method: 'POST',\n    headers: {\n      'content-type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'content-length': stat.size,\n    },\n  });\n  \n  fs.createReadStream(FIXTURE).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "right_result": "const fs = require('fs');\nconst http = require('http');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const filePath = FIXTURE;\n  const port = TEST_PORT;\n  const boundary = BOUNDARY;\n\n  const fileStream = fs.createReadStream(filePath);\n  const request = http.request({\n    hostname: 'localhost',\n    port: port,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${boundary}`,\n      'Content-Length': fileStream.length\n    }\n  }, (response) => {\n    let data = '';\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n    response.on('end', () => {\n      console.log('Upload complete');\n    });\n  });\n\n  fileStream.on('error', (err) => {\n    console.error('Error reading file:', err);\n  });\n\n  fileStream.pipe(request);\n\n  request.on('error', (err) => {\n    console.error('Error making request:', err);\n  });\n\n  // End the request\n  request.end();\n}"
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Implement a function to upload a file to a server using HTTP POST request with streaming capability to handle large files efficiently.\n\nFunction Description: The function should create a readable stream from a specified file and pipe it directly to an HTTP POST request. This approach avoids loading the entire file into memory, making it suitable for large files. The function should set appropriate headers including content type (multipart/form-data) and content length.\n\nInput:\n- FIXTURE: [String] - Path to the file to be uploaded\n- TEST_PORT: [Number] - Port number of the server to upload to\n- BOUNDARY: [String] - Boundary string for multipart/form-data content type\n\nOutput: None (The function streams the file directly to the HTTP request without returning any value)",
    "Canonical_solution": "function uploadFile() {\n  var fs = require('fs'),\n      http = require('http'),\n      stat = fs.statSync(FIXTURE),\n      request = http.request({\n        port: TEST_PORT,\n        path: '/',\n        method: 'POST',\n        headers: {\n          'content-type': 'multipart/form-data; boundary='+BOUNDARY,\n          'content-length': stat.size,\n        },\n      });\n  fs.createReadStream(FIXTURE).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "right_result": "function uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const fs = require('fs');\n  const https = require('https');\n  const path = require('path');\n\n  const filePath = path.resolve(FIXTURE);\n  const fileStream = fs.createReadStream(filePath);\n\n  const postData = `--${BOUNDARY}\\r\\nContent-Disposition: form-data; name=\"file\"; filename=\"${path.basename(filePath)\"}\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n`;\n\n  const request = https.request({\n    hostname: 'localhost',\n    port: TEST_PORT,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fileStream.length\n    }\n  }, (response) => {\n    response.on('data', (chunk) => {\n      console.log('Response:', chunk.toString());\n    });\n    response.on('end', () => {\n      console.log('Upload completed.');\n    });\n  });\n\n  request.on('error', (error) => {\n    console.error('Error:', error.message);\n  });\n\n  fileStream.on('error', (error) => {\n    console.error('File stream error:', error.message);\n  });\n\n  request.write(postData);\n  fileStream.pipe(request);\n  request.end();\n}"
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a function that sends a file over HTTP using a readable stream and pipes it to an HTTP request.\n\nFunction Description: The function `sendFileViaHTTP` is designed to stream a file from the local filesystem and send it as binary data via an HTTP POST request. It uses Node.js's `fs` module to create a readable stream from the file and pipes this stream directly to an HTTP request created with the `http` module. This approach is efficient for handling large files as it avoids loading the entire file into memory.\n\nInput: \n- `testFilePath` (string): The path to the file to be sent. Defaults to a predefined path in the fixture directory.\n- `port` (number): The port number on which the HTTP server is listening. Defaults to a common port defined elsewhere in the code.\n\nOutput: None. The function sends the file via HTTP but does not return any value. The result of the HTTP request (success or failure) would typically be handled via event listeners on the request object, which are not shown in this basic example.",
    "Canonical_solution": "function sendFileViaHTTP() {\n    var fs = require('fs');\n    var http = require('http');\n    var path = require('path');\n    \n    var testFilePath = path.join(__dirname, '../fixture/file/binaryfile.tar.gz');\n    var port = common.port;\n\n    var request = http.request({\n        port: port,\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/octet-stream'\n        }\n    });\n\n    fs.createReadStream(testFilePath).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "right_result": "function sendFileViaHTTP(testFilePath = 'fixture/testfile.txt', port = 3000) {\n  const fs = require('fs');\n  const http = require('http');\n\n  const filePath = testFilePath;\n  const fileStream = fs.createReadStream(filePath);\n\n  const options = {\n    hostname: 'localhost',\n    port: port,\n    path: '/upload',\n    method: 'POST'\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('response', (res) => {\n      console.log(`Status Code: ${res.statusCode}`);\n    });\n  });\n\n  fileStream.pipe(req);\n}"
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to record incoming connections and handle file uploads, using Node.js's `fs` and `http` modules. The server should log connection details and save request data to files.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming connections. It handles requests by piping the socket data to a file stream and provides a simple HTML form for file uploads. Each connection is assigned a unique filename for logging purposes.\n\nInput: None (The function does not take any input parameters)\n\nOutput: None (The function does not return any value but creates a running HTTP server that logs to the console and writes to files)",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "function createServer() {\n  const http = require('http');\n  const fs = require('fs');\n  const path = require('path');\n\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(`\n        <html>\n          <body>\n            <h1>File Upload</h1>\n            <form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n              <input type=\"file\" name=\"file\"><br>\n              <input type=\"submit\" value=\"Upload\">\n            </form>\n          </body>\n        </html>\n      `);\n    } else if (req.method === 'POST') {\n      const filePath = path.join(__dirname, 'uploads', `${Date.now()}.txt`);\n      const writeStream = fs.createWriteStream(filePath);\n\n      req.pipe(writeStream);\n\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('File uploaded successfully.');\n    }\n  });\n\n  server.listen(3000, () => {\n    console.log('Server is running on port 3000');\n  });\n}\n\ncreateServer();"
  },
  {
    "Task_id": 127,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle incoming requests and pipe the request data directly back as the response.\n\nFunction Description: The function `setupServer` creates an HTTP server that listens on an available port. When a request is received, the server responds with a 202 status code and pipes the incoming request data directly back to the response. The server's URL is stored in the `url` property of the server instance once it starts listening.\n\nInput: None\n\nOutput: Returns an HTTP server instance that is actively listening for requests. The server instance has a `url` property containing the server's address (e.g., 'http://localhost:PORT') once the server starts listening.",
    "Canonical_solution": "function setupServer() {\n  var http = require('http');\n  var server = http.createServer();\n  server.on('request', function (req, res) {\n    res.writeHead(202);\n    req.pipe(res);\n  });\n  server.listen(0, function () {\n    server.url = 'http://localhost:' + this.address().port;\n  });\n  return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "function setupServer() {\n  const http = require('http');\n  return new Promise((resolve, reject) => {\n    const server = http.createServer((req, res) => {\n      res.statusCode = 202;\n      res.setHeader('Content-Type', 'application/octet-stream');\n      req.pipe(res);\n    });\n\n    server.on('listening', () => {\n      const address = server.address();\n      server.url = `http://${address.address}:${address.port}`;\n      resolve(server);\n    });\n\n    server.listen(0, () => {\n      // Handle error if server fails to listen\n      server.on('error', (err) => reject(err));\n    });\n  });\n}"
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transform the incoming data to uppercase, and send it back as the response.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for POST requests. When a POST request is received, it pipes the request data through a transformation stream that converts the data to uppercase, then pipes the transformed data back to the response. The server listens on a port specified by the user or defaults to 0 if not provided.\n\nInput: \n- `process.argv[2]` (optional): [Number] - The port number on which the server should listen. If not provided, defaults to 0.\n\nOutput: \n- None (The function sets up a server that runs indefinitely, listening for requests and sending responses.)",
    "Canonical_solution": "function createServer() {\n    require('http').createServer(function (req, res) {\n        if (req.method !== 'POST') {\n            return res.end('POST only!\\n')\n        }\n        req.pipe(require('through2-map')(function (chunk) {\n            return chunk.toString().toUpperCase()\n        })).pipe(res)\n    }).listen(process.argv[2] | 0)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "```javascript\nfunction createServer(port = 0) {\n  const http = require('http');\n  const transformStream = require('stream').Transform;\n\n  class UpperCaseTransform extends transformStream {\n    _transform(chunk, encoding, callback) {\n      this.push(chunk.toString().toUpperCase());\n      callback();\n    }\n  }\n\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const stream = new UpperCaseTransform();\n      req.pipe(stream);\n      stream.pipe(res);\n    } else {\n      res.end('Use POST method');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}\n```"
  },
  {
    "Task_id": 130,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve a static HTML file by piping the file's content directly to the response stream.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 8080. When a request is received, it reads the specified HTML file (`index.html`) and pipes its content to the response object, efficiently streaming the file to the client.\n\nInput: None\n\nOutput: None (The function starts an HTTP server that continues to run and serve requests indefinitely.)",
    "Canonical_solution": "function createServer() {\n    var http = require(\"http\");\n    var fs = require(\"fs\");\n\n    http.createServer(function (req, res) {\n        fs.createReadStream(\"index.html\").pipe(res);\n    }).listen(8080);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "function createServer() {\n  const http = require('http');\n  const fs = require('fs');\n  const path = require('path');\n\n  http.createServer((req, res) => {\n    const filePath = path.join(__dirname, 'index.html');\n    const fileStream = fs.createReadStream(filePath);\n\n    fileStream.on('error', (err) => {\n      res.statusCode = 500;\n      res.end('Internal Server Error');\n    });\n\n    fileStream.pipe(res);\n  }).listen(8080, () => {\n    console.log('Server running on port 8080');\n  });\n}\n\ncreateServer();"
  },
  {
    "Task_id": 131,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transform the incoming data to uppercase, and send it back as the response.\n\nFunction Description: The function `createPipeServer` creates an HTTP server that listens on a specified port. It handles incoming POST requests by piping the request data through a transformation stream that converts the data to uppercase, and then pipes the transformed data back to the response. Non-POST requests are responded to with a message indicating that a POST request is required.\n\nInput:  \n- `port` (Number): The port number on which the HTTP server should listen.\n\nOutput:  \n- None (The function sets up the server but does not return any value).",
    "Canonical_solution": "const http = require('http');\nconst map = require('through2-map');\n\nfunction createPipeServer(port) {\n    const server = http.createServer(function (req, res) {\n        if (req.method !== 'POST') {\n            return res.end('send me a POST\\n');\n        }\n        req.pipe(map(function (chunk) {\n            return chunk.toString().toUpperCase();\n        })).pipe(res);\n    });\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "function createPipeServer(port) {\n  const http = require('http');\n  const transform = require('stream').Transform;\n\n  class UppercaseTransform extends transform {\n    _transform(chunk, encoding, callback) {\n      this.push(chunk.toString().toUpperCase());\n      callback();\n    }\n  }\n\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.statusCode = 405;\n      res.setHeader('Content-Type', 'text/plain');\n      res.end('Method Not Allowed: POST request is required.');\n      return;\n    }\n\n    const stream = new UppercaseTransform();\n    req.pipe(stream);\n    stream.pipe(res);\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running at http://localhost:${port}/`);\n  });\n}"
  },
  {
    "Task_id": 133,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to stream video content to clients using Node.js.\n\nFunction Description: The function `createVideoServer` initializes an HTTP server that streams a specified video file to clients when they connect. It uses Node.js's built-in `http` and `fs` modules to handle HTTP requests and read the video file, respectively. The video content is piped directly from the file system to the HTTP response, enabling efficient streaming.\n\nInput: None (The function does not take any parameters. The video file path is hardcoded as 'assets/NASA.mp4'.)\n\nOutput: None (The function does not return any value. It starts an HTTP server listening on port 3000 and the localhost address '127.0.0.1'.)",
    "Canonical_solution": "function createVideoServer() {\n    const http = require('http');\n    const fs = require('fs');\n    \n    let app = http.createServer((req, res) => {\n        res.writeHead(200, { 'Content-Type': 'video/mp4' });\n        let vidstream = fs.createReadStream('assets/NASA.mp4');\n        vidstream.pipe(res);\n    });\n    \n    app.listen(3000, '127.0.0.1');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "```javascript\nfunction createVideoServer() {\n  const http = require('http');\n  const fs = require('fs');\n  const path = require('path');\n\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const filePath = path.join(__dirname, 'assets', 'NASA.mp4');\n      const stats = fs.statSync(filePath);\n      const fileSize = stats.size;\n      const range = req.headers.range;\n\n      if (range) {\n        const chunks = fileSize.toString().split('.');\n        const start = Math.max(0, range.replace(/[^0-9]/g, '') - 1);\n        const end = Math.min(fileSize - 1, parseInt(chunks[0]) - 1);\n        const contentLength = end - start + 1;\n\n        res.statusCode = 206;\n        res.setHeader('Content-Range', `bytes ${start}-${end}/${fileSize}`);\n        res.setHeader('Content-Length', contentLength);\n        res.setHeader('Content-Type', 'video/mp4');\n        res.setHeader('Accept-Ranges', 'bytes');\n\n        const fileStream = fs.createReadStream(filePath, { start, end });\n        fileStream.pipe(res);\n      } else {\n        res.statusCode = 200;\n        res.setHeader('Content-Type', 'video/mp4');\n        res.setHeader('Content-Length', fileSize);\n\n        const fileStream = fs.createReadStream(filePath);\n        fileStream.pipe(res);\n      }\n    }\n  });\n\n  server.listen(3000, '127.0.0.1', () => {\n    console.log('HTTP server listening on http://127.0.0.1:3000');\n  });\n}\n\ncreateVideoServer();\n```"
  },
  {
    "Task_id": 134,
    "Instruction": "Task Description: Create a function that sets up a simple HTTP server to pipe the contents of a file as a response to incoming requests.\n\nFunction Description: The function creates an HTTP server that listens on a specified port. When a request is received, it responds by streaming the contents of a specified file to the client using the `pipe()` method. This is useful for efficiently serving file contents without loading the entire file into memory.\n\nInput: \n- port: [number] - The port number on which the HTTP server should listen. This is passed as the first command-line argument (process.argv[2]).\n- filePath: [string] - The path to the file whose contents should be piped to the response. This is passed as the second command-line argument (process.argv[3]).\n\nOutput: \n- None (The function does not return a value but starts an HTTP server that runs indefinitely.)",
    "Canonical_solution": "function createPipeServer() {\n    require('http').createServer(function (req, res) {\n        res.writeHead(200, 'content-type: text/plain');\n        require('fs').createReadStream(process.argv[3]).pipe(res);\n    }).listen(process.argv[2] | 0);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction startHttpServer(port, filePath) {\n  const server = http.createServer((req, res) => {\n    const fileStream = fs.createReadStream(path.resolve(filePath));\n    fileStream.pipe(res);\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running at http://localhost:${port}/`);\n  });\n}\n\nstartHttpServer(process.argv[2], process.argv[3]);"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to generate PDFs from HTML templates and serve them as streams.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 8080. It serves PDF files generated from an HTML template, replacing placeholders with actual image paths, and streams the PDF output to the client. The server handles incoming requests, checks for favicon requests, and responds with either a 404 error or the generated PDF.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on port 8080 and logs the server address to the console.)",
    "Canonical_solution": "function createServer() {\n    const fs = require('fs');\n    const http = require('http');\n    const pdf = require('../../');\n    const tmpl = fs.readFileSync(require.resolve('../businesscard/businesscard.html'), 'utf8');\n\n    const server = http.createServer(function (req, res) {\n        if (req.url === '/favicon.ico') return res.end('404');\n        const html = tmpl.replace('{{image}}', `file://${require.resolve('../businesscard/image.png')}`);\n        pdf.create(html, {width: '50mm', height: '90mm'}).toStream((err, stream) => {\n            if (err) return res.end(err.stack);\n            res.setHeader('Content-type', 'application/pdf');\n            stream.pipe(res);\n        });\n    });\n\n    server.listen(8080, function (err) {\n        if (err) throw err;\n        console.log('Listening on http://localhost:%s', server.address().port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst pdf = require('pdfkit');\nconst { exec } = require('child_process');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/favicon.ico') {\n      res.statusCode = 404;\n      res.end();\n      return;\n    }\n\n    const htmlTemplate = `\n      <html>\n        <body>\n          <h1>Generated PDF</h1>\n          <p>This is a generated PDF from an HTML template.</p>\n          <img src=\"image1.jpg\" alt=\"Image 1\">\n          <img src=\"image2.jpg\" alt=\"Image 2\">\n        </body>\n      </html>\n    `;\n\n    const doc = new pdf.Document();\n    doc.fontSize(24).text('Generated PDF', { align: 'center' });\n    doc.fontSize(12).text('This is a generated PDF from an HTML template.', { align: 'center' });\n    doc.image('image1.jpg', { align: 'center', fit: [300, 200] });\n    doc.image('image2.jpg', { align: 'center', fit: [300, 200] });\n\n    doc.pipe(res);\n    doc.write(htmlTemplate);\n    doc.end();\n  });\n\n  server.listen(8080, () => {\n    console.log('Server running at http://localhost:8080/');\n  });\n}\n\ncreateServer();\n```"
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a JavaScript function that sets up an HTTP server to serve an HTML file using Node.js's built-in modules (http and fs). The function should handle incoming requests by piping the file content directly to the response.\n\nFunction Description: The function creates an HTTP server that listens for incoming requests. When a request is received, it reads an HTML file from the specified path and pipes its content to the response object, setting the appropriate content-type header.\n\nInput: \n- __dirname (string): The directory path where the HTML file is located.\n- '/index.html' (string): The path to the HTML file to be served, relative to __dirname.\n\nOutput: \n- An HTTP server instance that serves the specified HTML file for all incoming requests. The server does not explicitly return a value but starts listening on a default port (typically 80 or a specified port).",
    "Canonical_solution": "var server = require('http').createServer(function incoming(req, res) {\n  res.setHeader('Content-Type', 'text/html');\n  require('fs').createReadStream(__dirname + '/index.html').pipe(res);\n});",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer(__dirname) {\n  const filePath = path.join(__dirname, '/index.html');\n\n  const server = http.createServer((req, res) => {\n    fs.createReadStream(filePath).pipe(res);\n    res.setHeader('Content-Type', 'text/html');\n  });\n\n  server.listen(80, () => {\n    console.log('Server is running on port 80');\n  });\n\n  return server;\n}"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Retrieve and process TV channel information from multiple providers via HTTP requests, then extract and deduplicate channel details.\n\nFunction Description: The function makes HTTP POST requests to a TV guide service for each provider, extracts channel information from the HTML response, and returns a deduplicated list of channels. It uses axios for HTTP requests, cheerio for HTML parsing, and lodash for deduplication.\n\nInput: None (The function uses hardcoded providers array and automatically determines the current date)\n\nOutput: Array of objects containing unique TV channel information with the following structure:\n[\n    {\n        lang: string,       // Language code ('it' for Italian)\n        name: string,       // Channel name\n        site_id: string     // Unique identifier combining channel number and slug\n    },\n    ...\n]",
    "Canonical_solution": "function async channels() {\n    const axios = require('axios')\n    const _ = require('lodash')\n\n    const providers = ['-1', '-2', '-3']\n\n    const channels = []\n    for (let provider of providers) {\n        const data = await axios\n            .post('https://www.guida.tv/guide/schedule', null, {\n                params: {\n                    provider,\n                    region: 'Italy',\n                    TVperiod: 'Night',\n                    date: dayjs().format('YYYY-MM-DD'),\n                    st: 0,\n                    u_time: 1429,\n                    is_mobile: 1\n                }\n            })\n            .then(r => r.data)\n            .catch(console.log)\n\n        const $ = cheerio.load(data)\n        $('.channelname').each((i, el) => {\n            const name = $(el).find('center > a:eq(1)').text()\n            const url = $(el).find('center > a:eq(1)').attr('href')\n            const [, number, slug] = url.match(/\\/(\\d+)\\/(.*)\\.html$/)\n\n            channels.push({\n                lang: 'it',\n                name,\n                site_id: `${number}/${slug}`\n            })\n        })\n    }\n\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "right_result": "const axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    { url: 'https://example.tv/provider1/guide', lang: 'it' },\n    { url: 'https://example.tv/provider2/guide', lang: 'it' }\n];\n\nasync function getChannels() {\n    const channels = [];\n\n    for (const provider of providers) {\n        try {\n            const response = await axios.post(provider.url, { date: new Date().toISOString().split('T')[0] });\n            const $ = cheerio.load(response.data);\n            const channelElements = $('channel'); // Adjust selector based on actual HTML structure\n\n            channelElements.each((i, element) => {\n                const name = $(element).find('name').text();\n                const number = $(element).find('number').text();\n                const slug = $(element).find('slug').text();\n                const siteId = `${number}-${slug}`;\n                channels.push({ lang: provider.lang, name, site_id: siteId });\n            });\n        } catch (error) {\n            console.error(`Error fetching channels from ${provider.url}:`, error.message);\n        }\n    }\n\n    return _.uniqBy(channels, 'site_id');\n}\n\nmodule.exports = { getChannels };"
  },
  {
    "Task_id": 141,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transform the incoming data to uppercase, and send it back as the response.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for POST requests on a specified port. When a POST request is received, it pipes the request data through a transformation stream that converts the data to uppercase, then pipes the transformed data back to the response. For non-POST requests, it simply ends the response.\n\nInput:  \n- `port` (Number) - The port number on which the HTTP server should listen.\n\nOutput:  \n- None (The function sets up the server but does not return any value).",
    "Canonical_solution": "const http = require('http');\nconst through = require('through2');\n\nfunction createServer(port) {\n  const server = http.createServer(function (req, res) {\n    if (req.method === 'POST') {\n      req.pipe(through(function (buf, _, next) {\n        this.push(buf.toString().toUpperCase());\n        next();\n      })).pipe(res);\n    } else res.end();\n  });\n  server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "```javascript\nfunction createServer(port) {\n  const http = require('http');\n  const transform = require('stream').Transform;\n\n  class UppercaseTransform extends transform {\n    _transform(chunk, encoding, callback) {\n      this.push(chunk.toString().toUpperCase());\n      callback();\n    }\n  }\n\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const stream = new UppercaseTransform();\n      req.pipe(stream);\n      stream.pipe(res);\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running at http://localhost:${port}/`);\n  });\n}\n```"
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve a ReDoc documentation interface, including handling requests for the ReDoc JavaScript file and rendering the documentation page with the provided specification.\n\nFunction Description: The function creates an HTTP server that serves two main routes: (1) '/redoc.standalone.js' which streams the ReDoc JavaScript file to the client, and (2) '/' which renders a complete HTML page with the ReDoc interface hydrated with the provided OpenAPI specification. The server handles other routes with a 404 response.\n\nInput:\n- port: [number] - The port number on which the HTTP server should listen\n- filePath: [string] - The file path to the 'redoc.standalone.js' file to be served\n- specPath: [string] - The file path to the OpenAPI specification file (YAML format)\n\nOutput: None (The function starts an HTTP server that continues running until manually stopped)\n\nNote: The function assumes the availability of certain external dependencies (yaml, fs, http, React, ServerStyleSheet, Redoc) which should be imported/required in the actual implementation. The function also uses async/await for handling asynchronous operations related to the Redoc store creation.",
    "Canonical_solution": "const http = require('http');\nconst fs = require('fs');\n\nfunction createServer(port, filePath, specPath) {\n    const server = http.createServer(async (request, response) => {\n        if (request.url === '/redoc.standalone.js') {\n            fs.createReadStream(filePath, 'utf8').pipe(response);\n        } else if (request.url === '/') {\n            const spec = yaml.load(readFileSync(resolve(__dirname, specPath), 'utf-8'));\n            const store = await createStore(spec, 'path/to/spec.yaml');\n\n            const sheet = new ServerStyleSheet();\n            const html = renderToString(sheet.collectStyles(React.createElement(Redoc, { store })));\n            const css = sheet.getStyleTags();\n\n            const res = `<html>\n            <head>\n                <meta charset=\"utf8\" />\n                <title>ReDoc</title>\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n                <style>\n                    body {\n                        padding: 0;\n                        margin: 0;\n                    }\n                </style>\n                <script src=\"redoc.standalone.js\"></script>\n                <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n                ${css}\n            </head>\n            <body>\n            <script>\n                document.addEventListener('DOMContentLoaded', function() {\n                    const state = ${JSON.stringify(await store.toJS())};\n                    Redoc.hydrate(state, document.getElementById('redoc'));\n                });\n                </script>\n                <div id=\"redoc\">${html}</div>\n            </body>\n            </html>`;\n            response.writeHead(200, { 'Content-Length': res.length });\n            response.write(res);\n            response.end();\n        } else {\n            response.writeHead(404);\n            response.write('Not found');\n            response.end();\n        }\n    });\n\n    server.listen(port, () => console.log(`Server started: http://127.0.0.1:${port}`));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('yaml');\nconst { Redoc } = require('redoc');\n\nfunction startRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      const fileStream = fs.createReadStream(filePath);\n      fileStream.pipe(res);\n      return;\n    } else if (req.url === '/') {\n      try {\n        const spec = await yaml.parse(fs.readFileSync(specPath, 'utf8'));\n        const redoc = new Redoc(spec);\n        const html = redoc.toHTML();\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end(html);\n      } catch (err) {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Error loading OpenAPI specification');\n      }\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not found');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running at http://localhost:${port}/`);\n  });\n}\n```"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle various routes and perform different operations based on the request method and URL, including piping data between requests.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming requests and routes them based on the URL path. It supports GET and PUT methods, proxies requests, and pipes data between different endpoints. The server responds differently depending on the route accessed, such as returning content, processing uploaded data, or proxying requests.\n\nInput: None\n\nOutput: Returns an HTTP server instance configured to handle specific routes and methods. The server responds to the following URLs:\n- `/get`: Handles GET requests and returns 'content'.\n- `/put`: Handles PUT requests, checks the uploaded data, and returns 'success' if the data matches 'content'.\n- `/proxy`: Proxies PUT requests to the `/put` endpoint and pipes the response back to the client.\n- `/test`: Chains requests by piping data from `/get` to `/proxy` and then to the client.\n- Any other URL results in an error.",
    "Canonical_solution": "var http = require('http');\nvar request = require('../index');\n\nfunction createServer() {\n    var server = http.createServer(function (req, resp) {\n        resp.statusCode = 200;\n        if (req.url === '/get') {\n            assert.equal(req.method, 'GET');\n            resp.write('content');\n            resp.end();\n            return;\n        }\n        if (req.url === '/put') {\n            var x = '';\n            assert.equal(req.method, 'PUT');\n            req.on('data', function (chunk) {\n                x += chunk;\n            });\n            req.on('end', function () {\n                assert.equal(x, 'content');\n                resp.write('success');\n                resp.end();\n            });\n            return;\n        }\n        if (req.url === '/proxy') {\n            assert.equal(req.method, 'PUT');\n            req.pipe(request(server.url + '/put')).pipe(resp);\n            return;\n        }\n        if (req.url === '/test') {\n            request(server.url + '/get').pipe(request.put(server.url + '/proxy')).pipe(resp);\n            return;\n        }\n        throw new Error('Unknown url', req.url);\n    });\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "const http = require('http');\nconst url = require('url');\n\nfunction createServer() {\n  return http.createServer((req, res) => {\n    const { pathname } = url.parse(req.url);\n\n    if (pathname === '/get') {\n      res.statusCode = 200;\n      res.setHeader('Content-Type', 'text/plain');\n      res.end('content');\n    } else if (pathname === '/put') {\n      let data = '';\n      req.on('data', chunk => {\n        data += chunk.toString();\n      });\n      req.on('end', () => {\n        if (data === 'content') {\n          res.statusCode = 200;\n          res.end('success');\n        } else {\n          res.statusCode = 400;\n          res.end('invalid data');\n        }\n      });\n    } else if (pathname === '/proxy') {\n      req.method === 'PUT' && req.pipe(req.socket).on('error', err => {\n        res.statusCode = 500;\n        res.end(`Error: ${err.message}`);\n      });\n    } else if (pathname === '/test') {\n      req.method === 'GET' && req.pipe(req.socket).on('error', err => {\n        res.statusCode = 500;\n        res.end(`Error: ${err.message}`);\n      });\n    } else {\n      res.statusCode = 404;\n      res.end('Not Found');\n    }\n  });\n}\n\nmodule.exports = createServer;"
  },
  {
    "Task_id": 144,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to stream the contents of a file to the client using Node.js's `fs` and `http` modules. The server should handle file streaming efficiently using pipes and manage errors appropriately.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 5000. When a request is received, it reads a specified file (`big.txt`) as a stream and pipes the data directly to the response object. This approach is memory-efficient for large files. The function handles both successful file streaming and errors during the process.\n\nInput: None (The function does not take any input parameters; the file path is hardcoded as `./content/big.txt`.)\n\nOutput: None (The function does not return any value; it creates an HTTP server that runs indefinitely until stopped externally.)",
    "Canonical_solution": "function createServer() {\n    const http = require('http');\n    const fs = require('fs');\n\n    http.createServer(function (req, res) {\n        const fileStream = fs.createReadStream('./content/big.txt', 'utf8');\n        fileStream.on('open', () => {\n            fileStream.pipe(res);\n        });\n        fileStream.on('error', (err) => {\n            res.end(err);\n        });\n    }).listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "const http = require('http');\nconst fs = require('fs');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = './content/big.txt';\n    const fileStream = fs.createReadStream(filePath);\n\n    fileStream.on('error', (err) => {\n      console.error('Error reading file:', err);\n      res.statusCode = 500;\n      res.end('Internal Server Error');\n    });\n\n    res.setHeader('Content-Type', 'text/plain');\n    fileStream.pipe(res);\n  });\n\n  server.listen(5000, () => {\n    console.log('Server running on port 5000');\n  });\n}\n\ncreateServer();"
  },
  {
    "Task_id": 145,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transforming the incoming data to uppercase and sending it back as the response.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for POST requests on a specified port. When a POST request is received, it pipes the request data through a transformation stream that converts the data to uppercase, then pipes the result back to the response. For non-POST requests, it responds with a message prompting a POST request.\n\nInput:  \n- `port` [Number] - The port number on which the HTTP server should listen.\n\nOutput:  \n- None (The function sets up a server that runs indefinitely, handling incoming requests.)",
    "Canonical_solution": "const http = require('http');\nconst through = require('through2');\n\nfunction createServer(port) {\n  const server = http.createServer(function (req, res) {\n    if (req.method === 'POST') {\n      req.pipe(through(function (buf, _, next) {\n        this.push(buf.toString().toUpperCase());\n        next();\n      })).pipe(res);\n    } else {\n      res.end('send me a POST\\n');\n    }\n  });\n  server.listen(parseInt(port));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "function createServer(port) {\n  const http = require('http');\n  const transforms = require('stream').Transform;\n\n  class UppercaseTransform extends transforms {\n    _transform(chunk, encoding, callback) {\n      this.push(chunk.toString().toUpperCase());\n      callback();\n    }\n  }\n\n  http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const transform = new UppercaseTransform();\n      req.pipe(transform);\n      transform.pipe(res);\n    } else {\n      res.statusCode = 400;\n      res.end('Please use POST method.');\n    }\n  }).listen(port, () => {\n    console.log(`Server running at http://localhost:${port}/`);\n  });\n}"
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a function that sets up a simple HTTP server to handle POST requests, piping the incoming request data to a response after converting it to a string.\n\nFunction Description: The function `createPipeServer` initializes an HTTP server that listens for POST requests. When a POST request is received, it pipes the request data through a transformation stream (converting chunks to strings) and then pipes the result back to the response. Non-POST requests are rejected with a message.\n\nInput:  \n- `port` (Number, optional): The port number on which the server will listen. If not provided or 0, the OS will assign an available port.\n\nOutput:  \n- None (The function starts an HTTP server that runs indefinitely, handling incoming requests.)",
    "Canonical_solution": "function createPipeServer(port) {\n  require('http').createServer(function (req, res) {\n    if (req.method !== 'POST') {\n      return res.end('POST only!\\n')\n    }\n    req.pipe(require('through2-map')(function (chunk) {\n      return chunk.toString()\n    })).pipe(res)\n  }).listen(port | 0)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "function createPipeServer(port = 0) {\n  const http = require('http');\n  const transform = require('stream').Transform;\n\n  class StringifyTransform extends transform {\n    _transform(chunk, encoding, callback) {\n      this.push(chunk.toString());\n      callback();\n    }\n  }\n\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.statusCode = 405;\n      res.setHeader('Content-Type', 'text/plain');\n      res.end('Method Not Allowed');\n      return;\n    }\n\n    const stream = new StringifyTransform();\n    req.pipe(stream);\n\n    stream.on('data', (chunk) => {\n      res.write(chunk);\n    });\n\n    stream.on('end', () => {\n      res.end();\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running on port ${server.address().port}`);\n  });\n}"
  },
  {
    "Task_id": 147,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to pipe the contents of a specified file to incoming HTTP responses.\n\nFunction Description: The function `createPipeServer` creates an HTTP server that listens on a specified port. When a request is received, it streams the contents of a specified file directly to the response object using the `pipe` method. This is useful for efficiently serving file contents without loading the entire file into memory.\n\nInput:\n- `port` (Number): The port number on which the HTTP server should listen.\n- `filePath` (String): The path to the file whose contents should be piped to the response.\n\nOutput: None. The function creates and starts an HTTP server that runs indefinitely until stopped externally.",
    "Canonical_solution": "const http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n    const server = http.createServer(function (req, res) {\n        res.writeHead(200, { 'content-type': 'text/plain' });\n        fs.createReadStream(filePath).pipe(res);\n    });\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "function createPipeServer(port, filePath) {\n  const http = require('http');\n  const fs = require('fs');\n  const path = require('path');\n\n  const server = http.createServer((req, res) => {\n    const fileStream = fs.createReadStream(path.resolve(filePath));\n    fileStream.pipe(res);\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running at http://localhost:${port}/`);\n  });\n}"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files and handle dynamic JavaScript file concatenation, with support for piping binary files.\n\nFunction Description: The `createServer` function initializes an HTTP server that serves static files from specified directories, handles dynamic concatenation of JavaScript files, and pipes binary files directly to the response. It supports virtual paths, content type detection, and redirection.\n\nInput: \n- Optional command line argument [string] - The port number to listen on (defaults to 90 if not provided)\n\nOutput: \n- None (directly creates and starts an HTTP server)\n- Console output indicating server startup and loaded files\n\nAttributes: (N/A - This is a function, not a class)\n\nMethods: (N/A - This is a function, not a class)\n\nAdditional Implementation Details:\n1. Reads and caches static files from '../src' and '../dist' directories at startup\n2. Handles binary files separately from text files\n3. Supports special handling for core JavaScript files and plugins\n4. Implements virtual path redirection\n5. Uses file extension to determine content type\n6. Provides fallback behavior for undefined routes\n7. Listens on localhost (127.0.0.1) only\n8. Outputs loaded file list to console at startup",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require(\"fs\");\n    var url = require(\"url\");\n\n    var BASE_URL=\"http://www.servicestack.net\", \n        VIRTUAL_PATH=\"/jqbuilder\"; \n\n    var getExt = function(path) {\n        return path.substring(path.lastIndexOf('.')+1);\n    };\n    String.prototype.startsWith = function (str){\n        return this.indexOf(str) === 0;\n    };\n\n    var contentTypes = { \"htm\": \"text/html\", \"js\": \"text/javascript\", \"gif\": \"image/gif\" };\n\n    var srcDir = '../src', targetDir = '../dist';\n    var webFiles = fs.readdirSync(targetDir);\n    var staticFiles = {}, binaryFiles = {};\n    fs.readdirSync(srcDir).forEach(function(file) { \n        var filePath = srcDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(targetDir).forEach(function(file) { \n        var filePath = targetDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(\"./\").forEach(function(file) {\n        var isText = (contentTypes[getExt(file)]||\"\").startsWith(\"text\");\n        if (isText)\n            staticFiles[\"/\" + file] = fs.readFileSync(file).toString('utf-8');\n        else \n            binaryFiles[\"/\" + file] = file;\n    });\n\n    staticFiles[\"/\"] = staticFiles[\"/default.htm\"];\n\n    console.log(\"loaded: \", Object.keys(staticFiles));\n\n    var isCore = { \"/jquip.js\": true, \"/jquip.min.js\": true };\n\n    var port = process.argv[2] || 90;\n\n    http.createServer(function (req, res) {\n        var reqUrl = url.parse(req.url), path = reqUrl.pathname.replace(VIRTUAL_PATH,'');\n        if (reqUrl.pathname == VIRTUAL_PATH){\n            res.writeHead(302,BASE_URL+VIRTUAL_PATH+\"/\");\n            res.end();\n            return;\n        }\n\n        var fileContents = staticFiles[path];\n\n        if (fileContents) {\n            var ext = path == \"/\" ? \"htm\" : getExt(path);\n            var contentType = contentTypes[ext];\n            res.writeHead(200, {'Content-Type': contentType });\n            var isPlugin = ext == \"js\" && path.startsWith(\"/jquip.\") && !isCore[path];\n            if (isPlugin) {\n                var coreJs = path.indexOf(\"min\") != -1 \n                    ? staticFiles[\"/jquip.min.js\"]\n                    : staticFiles[\"/jquip.js\"];\n                fileContents = coreJs + \";\" + fileContents;\n            }\n\n            res.end(fileContents);\n        }\n        else if (binaryFiles[path]) { \n            var filePath = binaryFiles[path]; \n            fs.createReadStream(filePath, {\n              'bufferSize': 4 * 1024\n            }).pipe(res);\n        }\n        else\n        {\n            var isDynamic = path.startsWith(\"/jquip.\");\n            if (isDynamic) {\n                var parts = path.substring(1).split('.');\n                var isMin = parts.indexOf(\"min\") >= 0;\n                var js = isMin ? staticFiles[\"/jquip.min.js\"] : staticFiles[\"/jquip.js\"];\t\t\t\n                parts.forEach(function(part){\n                    if (part == \"jquip\" || part == \"min\" || part == \"js\") return;\n                    var path = \"/jquip.\" + part + (isMin ? \".min.js\" : \".js\");\n                    var jsFile = staticFiles[path];\n                    if (jsFile)\n                        js += \";\" + jsFile;\n                });\n                res.writeHead(200, {'Content-Type': 'text/javascript' });\n                res.end(js);\t\t\n                return;\n            }\n\n            res.writeHead(200, {'Content-Type': 'text/plain'});\n            var sb = \"\";\n            for (var i in reqUrl) {\n                if (sb) sb += \"\\n\";\n                sb += i + \": \" + reqUrl[i];\n            }\n            res.end(\"Path not found:\\n\" + sb);\n        }\n    })\n    .listen(port, \"127.0.0.1\");\n    console.log('Server running at http://127.0.0.1:'+port+'/');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "right_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst mime = require('mime');\n\nconst srcDir = path.join(__dirname, '../src');\nconst distDir = path.join(__dirname, '../dist');\nconst staticDirs = [srcDir, distDir];\nconst staticFiles = {};\n\nfunction createServer(port = 90) {\n  // Load static files at startup\n  staticDirs.forEach(dir => {\n    fs.readdirSync(dir).forEach(file => {\n      const filePath = path.join(dir, file);\n      if (fs.statSync(filePath).isFile()) {\n        staticFiles[path.relative(dir, filePath)] = filePath;\n      }\n    });\n  });\n\n  console.log(`Server started on port ${port}`);\n  console.log(`Loaded static files: ${Object.keys(staticFiles).join(', ')}`);\n\n  const server = http.createServer((req, res) => {\n    let filePath = decodeURIComponent(req.url).toLowerCase();\n\n    // Virtual path redirection\n    if (filePath === '/js') {\n      filePath = '/js/core.js';\n    } else if (filePath.startsWith('/js/')) {\n      filePath = `/js/${filePath.slice(3)}`;\n    }\n\n    // Handle binary files\n    if (filePath.endsWith('.bin') || filePath.endsWith('.bin')) {\n      const filePath = path.join(staticDirs[0], filePath);\n      fs.createReadStream(filePath).pipe(res);\n      return;\n    }\n\n    // Determine content type\n    const ext = path.extname(filePath);\n    const contentType = mime.getType(filePath) || 'text/plain';\n\n    // Check if file exists in static files\n    let file = filePath;\n    if (file in staticFiles) {\n      const fullPath = staticFiles[file];\n      fs.createReadStream(fullPath).pipe(res);\n      res.setHeader('Content-Type', contentType);\n      return;\n    }\n\n    // Fallback for undefined routes\n    res.writeHead(404, { 'Content-Type': 'text/plain' });\n    res.end('404 Not Found');\n  });\n\n  server.listen(port, '127.0.0.1', () => {\n    console.log(`Server listening on http://127.0.0.1:${port}`);\n  });\n}\n\ncreateServer();\n```"
  },
  {
    "Task_id": 153,
    "Instruction": "Task Description: Create a TCP server that handles client connections with authentication and provides a random quote service upon successful authentication.\n\nFunction Description: The function `createServer` establishes a TCP server that listens on a specified port. It uses the `dnode` library for remote procedure calls (RPC) and implements an authentication mechanism. Upon successful authentication, clients gain access to a `randomQuote` service. The server logs connection and disconnection events.\n\nInput:  \n- `port` (Number): The port number on which the TCP server should listen for incoming connections.\n\nOutput:  \n- None (The function creates and starts a server instance but doesn't return anything. Side effects include logging connection events to the console.)  \n\nNote: The function relies on an undefined `randomQuote` function which should be implemented elsewhere to provide quote generation functionality. The authentication hardcodes credentials (user: 'moo', pass: 'hax') for demonstration purposes.",
    "Canonical_solution": "var dnode = require('dnode');\nvar fs = require('fs');\nvar net = require('net');\n\nfunction createServer(port) {\n    var server = net.createServer(function (stream) {\n        var d = dnode({ auth : auth });\n        d.pipe(stream).pipe(d);\n        \n        function auth (user, pass, cb) {\n            if (typeof cb !== 'function') return;\n            \n            if (user === 'moo' && pass === 'hax') {\n                console.log('signed in: ' + user);\n                d.on('end', function () {\n                    console.log('disconnected: ' + user);\n                });\n                \n                cb(null, { quote : randomQuote });\n            }\n            else cb('ACCESS DENIED')\n        }\n    });\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "right_result": "const dnode = require('dnode');\nconst net = require('net');\nconst fs = require('fs');\n\nfunction createServer(port) {\n  const server = net.createServer();\n\n  server.on('connection', (socket) => {\n    console.log('Client connected');\n\n    const auth = Buffer.from('moo:hax', 'base64');\n    socket.write(auth);\n\n    socket.on('data', (data) => {\n      const authResponse = data.toString('base64');\n      if (authResponse === 'dXNlcm5hbWU6IGhheQ==') {\n        console.log('Authentication successful');\n        socket.write('{\"service\": \"randomQuote\"}');\n      } else {\n        console.log('Authentication failed');\n        socket.end();\n      }\n    });\n\n    socket.on('end', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  return server;\n}\n\n// Example usage:\n// createServer(3000);"
  },
  {
    "Task_id": 156,
    "Instruction": "Task Description: Create a TCP server using Node.js's built-in 'net' module to handle client connections, parse incoming JSON data streams, and manage server lifecycle events.\n\nFunction Description: The function `createTCPServer` initializes a TCP server that listens on port 9999. It handles client connections by piping incoming data through a JSON stream parser. The server closes after processing a specified number of data events or when the parser emits an 'end' event. The function demonstrates basic TCP server setup, client connection handling, and event-driven server management.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function does not return a value but creates a running TCP server instance)",
    "Canonical_solution": "function createTCPServer() {\n    var net = require('net');\n    var server = net.createServer(function(client) {\n        var parser = JSONStream.parse([]);\n        parser.on('end', function() {\n            console.log('close');\n            console.error('PASSED');\n            server.close();\n        });\n        client.pipe(parser);\n        var n = 4;\n        client.on('data', function() {\n            if(--n) return;\n            client.end();\n        });\n    });\n    server.listen(9999);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "right_result": "function createTCPServer() {\n  const net = require('net');\n  const JSONStream = require('json-stream');\n\n  const server = net.createServer();\n\n  let dataCount = 0;\n  const maxDataEvents = 5;\n\n  server.on('connection', (socket) => {\n    const parser = new JSONStream.Parser();\n    parser.on('data', (data) => {\n      console.log('Received data:', data);\n      dataCount++;\n      if (dataCount === maxDataEvents) {\n        server.close();\n      }\n    });\n\n    parser.on('end', () => {\n      server.close();\n    });\n\n    socket.pipe(parser);\n    parser.pipe(socket);\n  });\n\n  server.on('error', (err) => {\n    console.error('Server error:', err);\n    process.exit(1);\n  });\n\n  server.on('listening', () => {\n    console.log('Server is listening on port 9999');\n  });\n\n  server.listen(9999);\n}"
  },
  {
    "Task_id": 157,
    "Instruction": "Task Description: Create a TCP proxy server that handles client connections, processes incoming data, and responds with HTTP-formatted messages. The server should be able to start and stop dynamically, track whether it was called, and store received data.\n\nFunction Description: The function creates and manages a TCP proxy server instance. It handles client connections, processes incoming data in two phases (initial connection and subsequent data), and responds with predefined HTTP responses. The server tracks all received data and whether any client has connected to it.\n\nInput: None (The function takes no parameters but returns an object with methods that can be called)\n\nOutput: Returns an object with the following methods:\n- start(callback): Starts the server on a random available port and executes the callback when ready\n- stop(callback): Stops the server and executes the callback when complete\n- getData(): Returns all data received from clients\n- wasCalled(): Returns a boolean indicating whether the server received any client connections\n\nThe server responds to client connections with:\n1. Initial response: 'HTTP/1.1 200 OK\\r\\n\\r\\n'\n2. Subsequent response: 'HTTP/1.1 200 OK\\r\\ncontent-type: text/plain\\r\\ncontent-length: 5\\r\\n\\r\\nderp\\n'",
    "Canonical_solution": "function createProxyServer() {\n    var called = false;\n    var proxiedHost = 'google.com';\n    var data = '';\n\n    var s = require('net').createServer(function (sock) {\n        called = true;\n        sock.once('data', function (c) {\n            data += c;\n\n            sock.write('HTTP/1.1 200 OK\\r\\n\\r\\n');\n\n            sock.once('data', function (c) {\n                data += c;\n\n                sock.write('HTTP/1.1 200 OK\\r\\n');\n                sock.write('content-type: text/plain\\r\\n');\n                sock.write('content-length: 5\\r\\n');\n                sock.write('\\r\\n');\n                sock.end('derp\\n');\n            });\n        });\n    });\n\n    return {\n        start: function(callback) {\n            s.listen(0, function () {\n                s.url = 'http://localhost:' + this.address().port;\n                callback();\n            });\n        },\n        stop: function(callback) {\n            s.close(function () {\n                callback();\n            });\n        },\n        getData: function() {\n            return data;\n        },\n        wasCalled: function() {\n            return called;\n        }\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "right_result": "const net = require('net');\n\nclass TcpProxyServer {\n  constructor() {\n    this.server = null;\n    this.dataReceived = '';\n    this.wasCalled = false;\n  }\n\n  start(callback) {\n    return new Promise((resolve, reject) => {\n      const server = net.createServer();\n      this.server = server;\n      this.dataReceived = '';\n      this.wasCalled = false;\n\n      server.on('error', (err) => {\n        reject(err);\n      });\n\n      server.on('connection', (socket) => {\n        this.wasCalled = true;\n        socket.on('data', (data) => {\n          this.dataReceived += data.toString();\n          if (socket.readable === false) {\n            socket.end();\n          }\n        });\n\n        if (socket.writeable) {\n          socket.write('HTTP/1.1 200 OK\\r\\n\\r\\n');\n        }\n      });\n\n      server.listen(() => {\n        const port = server.address().port;\n        callback && callback(port);\n        resolve({ port });\n      });\n    });\n  }\n\n  stop(callback) {\n    return new Promise((resolve, reject) => {\n      if (!this.server) {\n        callback && callback();\n        resolve();\n        return;\n      }\n\n      this.server.close(() => {\n        callback && callback();\n        resolve();\n      });\n    });\n  }\n\n  getData() {\n    return this.dataReceived;\n  }\n\n  wasCalled() {\n    return this.wasCalled;\n  }\n}\n\nmodule.exports = TcpProxyServer;"
  },
  {
    "Task_id": 159,
    "Instruction": "Task Description: Create a TCP server class that handles authentication requests for Git or SSH operations, generating dynamic listening paths and managing server lifecycle events.\n\nClass Description: The ResponseServer class is designed to create a TCP server that responds to authentication prompts from Git or SSH clients. It generates platform-specific listening paths, handles incoming connection requests, and provides appropriate authentication credentials based on the server type.\n\nAttributes:\n- auth: [Object] - Contains authentication credentials (username, password, passphrase)\n- serverType: [String] - Specifies the server type ('git' or 'ssh')\n\nMethods:\n- constructor(auth, serverType = 'git') -> [void] - Initializes the server with authentication credentials and server type\n- getListenPath() -> [String] - Generates a platform-specific listening path with a random component for security\n- start() -> [Promise<Object>] - Starts the TCP server and returns a promise that resolves to an object containing the listening path and a close method\n\nMethods Details:\n1. constructor(auth, serverType = 'git'):\n   - auth: [Object] - Authentication credentials object\n   - serverType: [String] - Type of server ('git' or 'ssh'), defaults to 'git'\n   - Returns: [void]\n\n2. getListenPath():\n   - Returns: [String] - Platform-specific listening path (Windows named pipe or Unix domain socket path)\n\n3. start():\n   - Returns: [Promise<Object>] - Resolves to an object with:\n     - path: [String] - The listening path\n     - close: [Function] - Method to close the server\n   - The promise may reject with an error if server startup fails",
    "Canonical_solution": "var net = require(\"net\");\nvar fs = require(\"fs-extra\");\nvar path = require(\"path\");\nvar os = require(\"os\");\nconst crypto = require(\"crypto\");\n\nclass ResponseServer {\n    constructor(auth, serverType = 'git') {\n        this.auth = auth;\n        this.serverType = serverType;\n    }\n\n    getListenPath() {\n        var seed = crypto.randomBytes(8).toString('hex');\n        var fn = 'node-red-git-askpass-'+seed+'-sock';\n        var listenPath;\n        if (process.platform === 'win32') {\n            listenPath = '\\\\\\\\.\\\\pipe\\\\'+fn;\n        } else {\n            listenPath = path.join(process.env['XDG_RUNTIME_DIR'] || os.tmpdir(), fn);\n        }\n        return listenPath;\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            var server = net.createServer((connection) => {\n                connection.setEncoding('utf8');\n                var parts = [];\n                connection.on('data', (data) => {\n                    var m = data.indexOf(\"\\n\");\n                    if (m !== -1) {\n                        parts.push(data.substring(0, m));\n                        data = data.substring(m);\n                        var line = parts.join(\"\");\n                        parts = [];\n                        if (this.serverType === 'git') {\n                            if (line === 'Username') {\n                                connection.end(this.auth.username);\n                            } else if (line === 'Password') {\n                                connection.end(this.auth.password);\n                                server.close();\n                            }\n                        } else if (this.serverType === 'ssh') {\n                            if (line === 'The') {\n                                connection.end('yes');\n                            } else if (line === 'Enter') {\n                                connection.end(this.auth.passphrase);\n                            }\n                        }\n                    }\n                    if (data.length > 0) {\n                        parts.push(data);\n                    }\n                });\n            });\n\n            var listenPath = this.getListenPath();\n\n            server.listen(listenPath, (ready) => {\n                resolve({\n                    path: listenPath,\n                    close: () => { server.close(); }\n                });\n            });\n\n            server.on('close', () => {\n                fs.removeSync(listenPath);\n            });\n\n            server.on('error', (err) => {\n                console.log(\"ResponseServer unexpectedError:\", err.toString());\n                server.close();\n                reject(err);\n            });\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "right_result": "class ResponseServer {\n  constructor(auth, serverType = 'git') {\n    this.auth = auth;\n    this.serverType = serverType;\n    this.server = null;\n  }\n\n  getListenPath() {\n    const os = require('os');\n    const path = require('path');\n    const randomString = Math.random().toString(36).substring(2, 10);\n    const platform = os.platform();\n\n    if (platform === 'win32') {\n      return `\\\\pipe\\\\git-ssh-auth-${randomString}`;\n    } else {\n      return path.join('/tmp', `git-ssh-auth-${randomString}.sock`);\n    }\n  }\n\n  async start() {\n    try {\n      const listenPath = this.getListenPath();\n      const net = require('net');\n\n      this.server = net.createServer((socket) => {\n        socket.on('data', (data) => {\n          if (this.serverType === 'git') {\n            // Handle Git authentication\n            const authResponse = `${this.auth.username}:${this.auth.password}\\r\\n`;\n            socket.write(authResponse);\n          } else if (this.serverType === 'ssh') {\n            // Handle SSH authentication\n            const authResponse = `${this.auth.username} ${this.auth.passphrase}\\r\\n`;\n            socket.write(authResponse);\n          }\n        });\n\n        socket.on('end', () => {\n          console.log('Connection ended');\n        });\n      });\n\n      this.server.on('error', (err) => {\n        console.error('Server error:', err);\n        throw err;\n      });\n\n      await new Promise((resolve, reject) => {\n        this.server.listen(listenPath, () => {\n          resolve();\n        });\n      });\n\n      return { path: listenPath, close: () => this.server.close() };\n    } catch (error) {\n      throw error;\n    }\n  }\n}"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a POP3 server class in Node.js that handles secure and non-secure connections, manages client connections, and provides event-driven communication.\n\nClass Description: The POP3Server class extends EventEmitter to create a TCP server that can handle both regular and TLS-secured POP3 connections. It manages client connections and emits events for server lifecycle and errors.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- connections: [Set] - Tracks active client connections\n- server: [net.Server|tls.Server] - The underlying TCP/TLS server instance\n\nMethods:\n- constructor(options) -> [void] - Initializes the server with optional configuration\n- _setListeners() -> [void] - Sets up event listeners for the server\n- _onListening() -> [void] - Handles the 'listening' event\n- _onClose() -> [void] - Handles the 'close' event\n- _onError(err) -> [void] - Handles the 'error' event\n- connect(socket, socketOptions) -> [void] - Creates and manages a new client connection\n- listen(...args) -> [void] - Starts the server listening on specified port\n- close(callback) -> [void] - Stops the server and invokes callback when closed",
    "Canonical_solution": "const EventEmitter = require('events');\nconst net = require('net');\nconst tls = require('tls');\n\nclass POP3Server extends EventEmitter {\n    constructor(options) {\n        super();\n\n        this.options = options || {};\n        this.connections = new Set();\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    this.connect(socket, socketOptions);\n                });\n            });\n        }\n\n        this._setListeners();\n    }\n\n    _setListeners() {\n        this.server.on('listening', () => this._onListening());\n        this.server.on('close', () => this._onClose());\n        this.server.on('error', err => this._onError(err));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new POP3Connection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.once('error', err => {\n            this.connections.delete(connection);\n            this._onError(err);\n        });\n        connection.once('close', () => {\n            this.connections.delete(connection);\n        });\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            if (typeof callback === 'function') {\n                return callback();\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "right_result": "const net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options || {};\n    this.connections = new Set();\n    this.server = this.options.secure ? tls.createServer(this.options, this._setListeners.bind(this)) : net.createServer(this._setListeners.bind(this));\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    const client = new POP3Client(socket, socketOptions);\n    this.connections.add(client);\n    client.on('close', () => {\n      this.connections.delete(client);\n      this.emit('clientClose', client);\n    });\n    client.on('data', (data) => {\n      this.emit('clientData', client, data);\n    });\n    client.on('error', (err) => {\n      this.emit('clientError', client, err);\n    });\n  }\n\n  listen(...args) {\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n\nclass POP3Client {\n  constructor(socket, socketOptions) {\n    this.socket = socket;\n    this.socketOptions = socketOptions;\n    this.parser = new POP3Parser(this.socket);\n  }\n\n  on(event, callback) {\n    this.parser.on(event, callback);\n  }\n\n  emit(event, ...args) {\n    this.parser.emit(event, ...args);\n  }\n\n  destroy() {\n    this.socket.destroy();\n  }\n}\n\nclass POP3Parser {\n  constructor(socket) {\n    this.socket = socket;\n    this.buffer = '';\n    this.state = 'INIT';\n    this.commands = [];\n    this.currentCommand = '';\n    this.currentLine = '';\n    this.lineNumber = 0;\n    this.parser = new POP3CommandParser(this);\n  }\n\n  on(event, callback) {\n    this.socket.on(event, callback);\n  }\n\n  emit(event, ...args) {\n    this.socket.emit(event, ...args);\n  }\n\n  data(chunk) {\n    this.buffer += chunk.toString();\n    while (this.buffer.length > 0) {\n      const line = this.buffer.split('\\r\\n', 1)[0];\n      if (line) {\n        this.currentLine = line;\n        this.buffer = this.buffer.substring(line.length);\n        this.parseLine();\n      } else {\n        break;\n      }\n    }\n  }\n\n  end() {\n    this.socket.end();\n  }\n\n  parseLine() {\n    if (this.currentLine.trim() === '') {\n      return;\n    }\n\n    if (this.state === 'INIT') {\n      this.state = 'COMMAND';\n      this.currentCommand = this.currentLine;\n    } else if (this.state === 'COMMAND') {\n      this.parser.parse(this.currentCommand);\n      this.currentCommand = '';\n      this.state = 'RESPONSE';\n    } else if (this.state === 'RESPONSE') {\n      this.parser.parse(this.currentLine);\n      this.lineNumber++;\n      this.currentLine = '';\n      this.state = 'COMMAND';\n    }\n  }\n}\n\nclass POP3CommandParser {\n  constructor(parser) {\n    this.parser = parser;\n  }\n\n  parse(command) {\n    if (command.startsWith('USER')) {\n      this.parser.emit('user', command);\n    } else if (command.startsWith('PASS')) {\n      this.parser.emit('pass', command);\n    } else if (command.startsWith('LIST')) {\n      this.parser.emit('list', command);\n    } else if (command.startsWith('DELE')) {\n      this.parser.emit('dele', command);\n    } else if (command.startsWith('QUIT')) {\n      this.parser.emit('quit', command);\n    } else {\n      this.parser.emit('unknownCommand', command);\n    }\n  }\n}"
  },
  {
    "Task_id": 163,
    "Instruction": "Task Description: Create a TCP server in Node.js that serves Flash cross-domain policy files to clients, handling connections, errors, and policy file generation dynamically.\n\nClass Description: The Server class implements a TCP server that listens for Flash policy file requests and responds with an appropriate cross-domain policy XML. It handles server lifecycle events, client connections, and dynamic policy configuration.\n\nAttributes:\n- origins: [Array] - List of allowed domains and ports in \"domain:port\" format\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [net.Server] - The TCP server instance\n- server: [Object] - Optional fallback HTTP server\n- buffer: [Buffer] - Compiled policy file in binary format\n\nMethods:\n- constructor(options, origins) -> [Server] - Initializes the server with configuration options and allowed origins\n- listen(port, server, cb) -> [Server] - Starts listening on specified port, with optional fallback server and callback\n- responder(socket) -> [void] - Responds to client connections with policy file\n- compile() -> [Server] - Generates the policy file XML and converts it to buffer\n- add() -> [Server] - Adds one or more allowed origins to the policy\n- remove(origin) -> [Server] - Removes a specific origin from the policy\n- close() -> [Server] - Closes the server and cleans up resources",
    "Canonical_solution": "var net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => {\n        this.responder.call(this, socket);\n      });\n      this.responder.call(this, socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges. ' +\n          (\n            this.server\n            ? 'The Flash Policy File requests will only be served inline over the supplied HTTP server. Inline serving is slower than a dedicated server instance.'\n            : 'No fallback server supplied, we will be unable to answer Flash Policy File requests.'\n          )\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n      if (this.server && this.server['@'] && this.server.online) {\n        this.server.removeListener('connection', this.server['@']);\n      }\n      delete this.server?.online;\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (\n            data &&\n            data[0] === 60 &&\n            data.toString() === '<policy-file-request/>\\0' &&\n            socket &&\n            (socket.readyState === 'open' || socket.readyState === 'writeOnly')\n          ) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    if (this.port >= 0) {\n      this.socket.listen(this.port, () => {\n        this.socket.online = true;\n        callback?.call(this);\n      });\n    }\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = Buffer.from(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "right_result": "class Server {\n  constructor(options, origins) {\n    this.options = options || {};\n    this.origins = origins || [];\n    this.port = this.options.port || 843;\n    this.log = this.options.log || console.log;\n    this.socket = null;\n    this.server = this.options.server;\n    this.buffer = null;\n  }\n\n  listen(port, server, cb) {\n    if (!this.socket) {\n      this.socket = require('net').createServer();\n      this.socket.on('error', (err) => {\n        this.log(`Server error: ${err.message}`);\n        if (cb) cb(err);\n      });\n      this.socket.on('connection', (socket) => this.responder(socket));\n    }\n\n    if (server) {\n      this.server = server;\n      this.server.on('error', (err) => {\n        this.log(`Fallback server error: ${err.message}`);\n        if (cb) cb(err);\n      });\n    }\n\n    if (cb) this.socket.listen(port, cb);\n    else this.socket.listen(port);\n    return this;\n  }\n\n  responder(socket) {\n    if (!this.buffer) this.compile();\n    socket.write(this.buffer);\n    socket.end();\n  }\n\n  compile() {\n    const policy = `<policyFile><allow-origin>http://*</allow-origin></policyFile>`;\n    this.buffer = Buffer.from(policy, 'utf8');\n    return this;\n  }\n\n  add(...origins) {\n    this.origins = [...this.origins, ...origins];\n    return this;\n  }\n\n  remove(origin) {\n    this.origins = this.origins.filter(o => o !== origin);\n    return this;\n  }\n\n  close() {\n    if (this.socket) this.socket.close();\n    if (this.server) this.server.close();\n    this.socket = null;\n    this.server = null;\n    this.buffer = null;\n    return this;\n  }\n}"
  },
  {
    "Task_id": 165,
    "Instruction": "Task Description: Create a function that sets up a TCP server with WebSocket support, handling client connections and message routing.\n\nFunction Description: The function `createTCPServer` initializes a TCP server using Node.js's `net` module, integrates WebSocket functionality, and manages client connections. It sets up event handlers for connection establishment, message piping, and error handling. The server listens on the specified port for incoming connections.\n\nInput:  \n- `port` (Number): The port number on which the TCP server should listen for incoming connections.\n\nOutput:  \n- None (The function starts a TCP server but does not return any value).  \n\n---\n\n**Note**: The function internally uses the `net` module to create the server, the `websocket` library for WebSocket support, and `permessage-deflate` for compression. It pipes data between the TCP connection and WebSocket driver for bidirectional communication.",
    "Canonical_solution": "function createTCPServer(port) {\n    var net = require('net'),\n        websocket = require('..'),\n        deflate = require('permessage-deflate');\n\n    var server = net.createServer(function(connection) {\n        var driver = websocket.server();\n        driver.addExtension(deflate);\n\n        driver.on('connect', function() {\n            if (websocket.isWebSocket(driver)) driver.start();\n        });\n\n        driver.on('close', function() { connection.end() });\n        connection.on('error', function() {});\n\n        connection.pipe(driver.io);\n        driver.io.pipe(connection);\n\n        driver.messages.pipe(driver.messages);\n    });\n\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "right_result": "const net = require('net');\nconst WebSocket = require('ws');\nconst permessagedeflate = require('permessage-deflate');\n\nfunction createTCPServer(port) {\n  const server = net.createServer();\n  const wss = new WebSocket.Server({ noServer: true });\n\n  server.on('connection', (socket) => {\n    const ws = new WebSocket(socket, {\n      permessageDeflate: permessagedeflate,\n      host: 'localhost',\n      port: port\n    });\n\n    ws.on('message', (message) => {\n      console.log(`Received message: ${message}`);\n      // Handle message routing here\n    });\n\n    ws.on('error', (err) => {\n      console.error(`WebSocket error: ${err.message}`);\n    });\n\n    ws.on('close', () => {\n      console.log('WebSocket connection closed');\n    });\n  });\n\n  wss.on('connection', (ws, request) => {\n    console.log(`New WebSocket connection from ${request.url}`);\n    ws.on('message', (message) => {\n      console.log(`Received message: ${message}`);\n      // Handle message routing here\n    });\n\n    ws.on('error', (err) => {\n      console.error(`WebSocket error: ${err.message}`);\n    });\n\n    ws.on('close', () => {\n      console.log('WebSocket connection closed');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`TCP server listening on port ${port}`);\n  });\n\n  server.on('error', (err) => {\n    console.error(`TCP server error: ${err.message}`);\n  });\n}"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a TCP server connector class in JavaScript using Node.js's 'net' module that handles server creation, connection events, and lifecycle management.\n\nClass Description: The Connector class is an EventEmitter that creates and manages a TCP server. It handles server connections, errors, and provides methods to start and stop the server.\n\nAttributes:\n- opts: [Object] - Optional configuration options for the server\n- host: [String] - The host address the server will bind to\n- port: [Number] - The port number the server will listen on\n- tcpServer: [Object] - The underlying TCP server instance\n\nMethods:\n- constructor: [Connector](port, host, opts) -> [Connector] - Initializes a new Connector instance with specified port, host, and options\n- start: [start](cb) -> [undefined] - Starts the TCP server and sets up connection and error event handlers. Calls the callback when server is ready\n- stop: [stop](force, cb) -> [undefined] - Stops the TCP server and calls the callback when complete. The force parameter determines whether to force close connections",
    "Canonical_solution": "var net = require('net');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nvar Connector = function(port, host, opts) {\n  if (!(this instanceof Connector)) {\n    return new Connector(port, host, opts);\n  }\n\n  EventEmitter.call(this);\n  this.opts = opts || {};\n  this.host = host;\n  this.port = port;\n};\n\nutil.inherits(Connector, EventEmitter);\n\nConnector.prototype.start = function(cb) {\n  var self = this;\n  this.tcpServer = net.createServer();\n  \n  this.tcpServer.on('connection', function(socket) {\n    self.emit('connection', socket);\n  });\n\n  this.tcpServer.on('error', function(err) {\n    self.emit('error', err);\n  });\n\n  this.tcpServer.listen(this.port, this.host);\n  process.nextTick(cb);\n};\n\nConnector.prototype.stop = function(force, cb) {\n  this.tcpServer.close();\n  process.nextTick(cb);\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "right_result": "class Connector extends require('events') {\n  constructor(port, host, opts) {\n    super();\n    this.opts = opts || {};\n    this.host = host || '127.0.0.1';\n    this.port = port;\n    this.tcpServer = null;\n  }\n\n  start(cb) {\n    this.tcpServer = require('net').createServer((socket) => {\n      socket.on('data', (data) => {\n        this.emit('message', data);\n      });\n      socket.on('end', () => {\n        this.emit('end');\n      });\n      socket.on('error', (err) => {\n        this.emit('error', err);\n      });\n    });\n\n    this.tcpServer.on('error', (err) => {\n      this.emit('error', err);\n    });\n\n    this.tcpServer.on('listening', () => {\n      this.emit('listening');\n      if (cb) cb();\n    });\n\n    this.tcpServer.listen(this.port, this.host, () => {\n      this.emit('server-started');\n    });\n  }\n\n  stop(force, cb) {\n    if (this.tcpServer) {\n      if (force) {\n        this.tcpServer.close(() => {\n          if (cb) cb();\n        });\n      } else {\n        this.tcpServer.destroy(() => {\n          if (cb) cb();\n        });\n      }\n    } else {\n      if (cb) cb();\n    }\n  }\n}"
  },
  {
    "Task_id": 167,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's 'net' module to listen for incoming connections, handle client messages, and emit events for commands received.\n\nClass Description: TCPListener is a class that creates a TCP server to listen for incoming connections on a specified port. It handles client connections, processes incoming data, and emits events when commands are received. The class extends Node.js's EventEmitter to provide event-driven functionality.\n\nAttributes:\n- port: [Number] - The port number on which the TCP server will listen\n- server: [Object] - The TCP server instance created by the 'net' module\n\nMethods:\n- constructor(port) -> [TCPListener] - Initializes the TCPListener instance with the specified port\n- start() -> [void] - Creates and starts the TCP server, sets up event handlers for client connections, data reception, and errors. Emits 'command' events when valid messages are received and 'log' events for server status updates\n\nThe class emits the following events:\n- 'command': (command, params, options, callback) - Emitted when a valid command message is received from a client\n- 'log': (message) - Emitted for logging server status and errors",
    "Canonical_solution": "var events = require('events');\nvar net = require('net');\n\nclass TCPListener {\n    constructor(port) {\n        this.port = port;\n        this.server = null;\n    }\n\n    start() {\n        this.server = net.createServer((c) => {\n            var data = '';\n            try {\n                c.on('data', (d) => {\n                    data += d;\n                    if (data.slice(-1) === '\\n') {\n                        var message = JSON.parse(data);\n                        this.emit('command', message.command, message.params, message.options, (message) => {\n                            c.end(message);\n                        });\n                    }\n                });\n                c.on('end', () => {});\n                c.on('error', () => {});\n            }\n            catch(e) {\n                this.emit('log', 'CLI listener failed to parse message ' + data);\n            }\n        }).listen(this.port, '127.0.0.1', () => {\n            this.emit('log', 'CLI listening on port ' + this.port);\n        });\n    }\n}\n\nTCPListener.prototype.__proto__ = events.EventEmitter.prototype;",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "right_result": "class TCPListener extends require('events').EventEmitter {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server = null;\n  }\n\n  start() {\n    this.server = require('net').createServer((socket) => {\n      socket.on('data', (data) => {\n        try {\n          const message = data.toString();\n          if (message.startsWith('CMD:')) {\n            const command = message.substring(4);\n            const parts = command.split(':');\n            const cmd = parts[0];\n            const params = parts.slice(1).join(':');\n            this.emit('command', cmd, params);\n          }\n          this.emit('log', `Received: ${message}`);\n        } catch (err) {\n          this.emit('log', `Error parsing message: ${err.message}`);\n        }\n      });\n\n      socket.on('end', () => {\n        this.emit('log', 'Client disconnected');\n      });\n\n      socket.on('error', (err) => {\n        this.emit('log', `Socket error: ${err.message}`);\n      });\n    });\n\n    this.server.on('error', (err) => {\n      this.emit('log', `Server error: ${err.message}`);\n    });\n\n    this.server.on('listening', () => {\n      this.emit('log`, `Server listening on port ${this.port}`);\n    });\n\n    this.server.listen(this.port);\n  }\n}"
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Implement a TCP server class in JavaScript using Node.js's 'net' module to handle client connections, manage sockets, and provide event-driven communication.\n\nClass Description: The Socket class represents a TCP server that can bind to a specific port/host, manage client connections, handle socket errors, and emit events for various connection states. It extends EventEmitter for event handling capabilities.\n\nAttributes:\n- server: [net.Server] - The underlying TCP server instance\n- socks: [Array] - Array of connected client sockets\n- settings: [Object] - Configuration settings for the server\n- type: [String] - Indicates whether the instance is acting as a server or client\n\nMethods:\n- constructor() -> [void] - Initializes the socket instance with default settings\n- bind(port, host, fn) -> [Socket] - Binds the server to a specified port and host (supports both TCP and Unix sockets)\n- onconnect(sock) -> [void] - Handles new client connections\n- addSocket(sock) -> [void] - Adds a new socket to the connection pool and sets up message parsing\n- removeSocket(sock) -> [void] - Removes a socket from the connection pool\n- handleErrors(sock) -> [void] - Sets up error handling for a socket\n- closeServer(fn) -> [void] - Closes the server and all client connections",
    "Canonical_solution": "var Emitter = require('events').EventEmitter;\nvar net = require('net');\nvar debug = require('debug')('axon:sock');\n\nclass Socket {\n  constructor() {\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.set('hwm', Infinity);\n    this.set('identity', String(process.pid));\n    this.set('retry timeout', 100);\n    this.set('retry max timeout', 5000);\n  }\n\n  bind(port, host, fn) {\n    var self = this;\n    if ('client' == this.type) throw new Error('cannot bind() after connect()');\n    if ('function' == typeof host) {\n      fn = host;\n      host = undefined;\n    }\n\n    var unixSocket = false;\n\n    if ('string' == typeof port) {\n      port = url.parse(port);\n\n      if ('unix:' == port.protocol) {\n        host = fn;\n        fn = undefined;\n        port = port.pathname;\n        unixSocket = true;\n      } else {\n        host = port.hostname || '0.0.0.0';\n        port = parseInt(port.port, 10);\n      }\n    } else {\n      host = host || '0.0.0.0';\n    }\n\n    this.type = 'server';\n\n    this.server = net.createServer(this.onconnect.bind(this));\n\n    debug('%s bind %s:%s', this.type, host, port);\n    this.server.on('listening', this.emit.bind(this, 'bind'));\n\n    if (unixSocket) {\n      this.server.on('error', function(e) {\n        if (e.code == 'EADDRINUSE') {\n          var clientSocket = new net.Socket();\n\n          clientSocket.on('error', function(e2) {\n            if (e2.code == 'ECONNREFUSED') {\n              fs.unlink(port);\n              self.server.listen(port, host, fn);\n            }\n          });\n\n          clientSocket.connect({path: port}, function() {\n            throw e;\n          });\n        }\n      });\n    }\n\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    var self = this;\n    var addr = sock.remoteAddress + ':' + sock.remotePort;\n    debug('%s accept %s', self.type, addr);\n    this.addSocket(sock);\n    this.handleErrors(sock);\n    this.emit('connect', sock);\n    sock.on('close', function() {\n      debug('%s disconnect %s', self.type, addr);\n      self.emit('disconnect', sock);\n      self.removeSocket(sock);\n    });\n  }\n\n  addSocket(sock) {\n    var parser = new Parser;\n    var i = this.socks.push(sock) - 1;\n    debug('%s add socket %d', this.type, i);\n    sock.pipe(parser);\n    parser.on('data', this.onmessage(sock));\n  }\n\n  removeSocket(sock) {\n    var i = this.socks.indexOf(sock);\n    if (!~i) return;\n    debug('%s remove socket %d', this.type, i);\n    this.socks.splice(i, 1);\n  }\n\n  handleErrors(sock) {\n    var self = this;\n    sock.on('error', function(err) {\n      debug('%s error %s', self.type, err.code || err.message);\n      self.emit('socket error', err);\n      self.removeSocket(sock);\n      if (!~ignore.indexOf(err.code)) return self.emit('error', err);\n      debug('%s ignored %s', self.type, err.code);\n      self.emit('ignored error', err);\n    });\n  }\n\n  closeServer(fn) {\n    debug('%s closing server', this.type);\n    this.server.on('close', this.emit.bind(this, 'close'));\n    this.server.close();\n    fn && fn();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "right_result": "class Socket extends require('events').EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    if (this.server) return this.server;\n    this.server = require('net').createServer();\n    this.server.on('connection', (sock) => this.onconnect(sock));\n    this.server.on('error', (err) => this.handleErrors(err));\n    this.server.on('close', () => this.closeServer());\n    this.server.on('listening', () => fn && fn());\n    if (host) {\n      this.server.listen(port, host, fn);\n    } else {\n      this.server.listen(port, fn);\n    }\n    return this;\n  }\n\n  onconnect(sock) {\n    this.addSocket(sock);\n    sock.on('data', (data) => {\n      this.emit('message', data);\n    });\n    sock.on('end', () => {\n      this.removeSocket(sock);\n      this.emit('end');\n    });\n    sock.on('error', (err) => {\n      this.handleErrors(err);\n    });\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    this.emit('connect', sock);\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n      this.emit('disconnect', sock);\n    }\n  }\n\n  handleErrors(sock) {\n    sock.on('error', (err) => {\n      this.emit('error', err);\n    });\n  }\n\n  closeServer(fn) {\n    if (this.server) {\n      this.server.close(() => {\n        this.socks.forEach((sock) => {\n          sock.end();\n        });\n        this.emit('close');\n        fn && fn();\n      });\n    }\n  }\n}"
  },
  {
    "Task_id": 172,
    "Instruction": "Task Description: Create a TCP server using Node.js's built-in 'net' module to handle client connections and manage server lifecycle events.\n\nFunction Description: The function creates a TCP server that listens for incoming client connections. When a client connects, the server immediately sends a 'goodbye' message and closes the connection. The server also handles errors by throwing them. Upon successful startup, it logs the server address.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but creates a server instance that listens for connections)",
    "Canonical_solution": "function createTCPServer() {\n    const net = require('net');\n    var server = net.createServer((socket) => {  \n        socket.end('goodbye\\n');  \n    }).on('error', (err) => {  \n        throw err;  \n    });  \n    server.listen(() => {  \n        address = server.address();  \n        console.log('opened server on %j', address);  \n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "right_result": "const net = require('net');\n\nfunction createTcpServer() {\n  const server = net.createServer((socket) => {\n    console.log('Client connected');\n    socket.write('goodbye');\n    socket.end();\n  });\n\n  server.on('error', (err) => {\n    throw err;\n  });\n\n  server.listen(8000, () => {\n    console.log(`Server listening at ${server.address().address}:${server.address().port}`);\n  });\n\n  return server;\n}\n\ncreateTcpServer();"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Create a TCP server implementation for handling IMAP (Internet Message Access Protocol) connections with optional TLS/SSL security support.\n\nClass Description: IMAPServer is a class that implements a TCP server for IMAP protocol connections. It supports both plain and TLS/SSL encrypted connections, handles client connections, and manages server lifecycle events.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- server: [net.Server] - The underlying TCP server instance\n- connections: [Set] - Active client connections\n- _closeTimeout: [Timeout] - Timer for server shutdown operations\n\nMethods:\n- constructor(options) -> [IMAPServer] - Initializes the server with configuration options and sets up event listeners\n- connect(socket, socketOptions) -> [void] - Creates a new IMAPConnection for a client socket\n- listen(...args) -> [void] - Starts the server listening on specified port/address\n- close(callback) -> [void] - Gracefully shuts down the server\n- _setListeners() -> [void] - Sets up server event listeners\n- _onListening() -> [void] - Handles server 'listening' event\n- _onClose() -> [void] - Handles server 'close' event\n- _onError(err) -> [void] - Handles server 'error' event\n- _handleProxy(socket, callback) -> [void] - Handles proxy protocol if needed\n- _upgrade(socket, callback) -> [void] - Upgrades a connection to TLS/SSL",
    "Canonical_solution": "const net = require('net');\nconst tls = require('tls');\n\nclass IMAPServer {\n    constructor(options) {\n        this.options = options || {};\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                socket.setKeepAlive(true, 5 * 1000);\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket =>\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    socket.setKeepAlive(true, 5 * 1000);\n                    this.connect(socket, socketOptions);\n                })\n            );\n        }\n\n        this._setListeners();\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new IMAPConnection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.on('error', this._onError.bind(this));\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            clearTimeout(this._closeTimeout);\n            callback();\n        });\n    }\n\n    _setListeners() {\n        this.server.on('listening', this._onListening.bind(this));\n        this.server.on('close', this._onClose.bind(this));\n        this.server.on('error', this._onError.bind(this));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    _handleProxy(socket, callback) {\n        let socketOptions = {\n            id: base32.encode(crypto.randomBytes(10)).toLowerCase()\n        };\n        return setImmediate(() => callback(null, socketOptions));\n    }\n\n    _upgrade(socket, callback) {\n        let socketOptions = {\n            secureContext: this.secureContext.get('*'),\n            isServer: true,\n            server: this.server\n        };\n\n        let tlsSocket = new tls.TLSSocket(socket, socketOptions);\n        tlsSocket.on('secure', () => {\n            return callback(null, tlsSocket);\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "right_result": "class IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = require('net').createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n    this._setListeners();\n  }\n\n  connect(socket, socketOptions) {\n    const connection = new IMAPConnection(socket, socketOptions, this);\n    this.connections.add(connection);\n    connection.on('error', (err) => {\n      console.error(`IMAP connection error: ${err.message}`);\n      connection.end();\n    });\n    connection.on('end', () => {\n      this.connections.delete(connection);\n    });\n  }\n\n  listen(...args) {\n    this.server.listen(...args, () => {\n      this._onListening();\n    });\n  }\n\n  close(callback) {\n    if (this._closeTimeout) {\n      clearTimeout(this._closeTimeout);\n    }\n    this.server.close(() => {\n      if (callback) callback();\n    });\n  }\n\n  _setListeners() {\n    this.server.on('connection', (socket) => {\n      this.connect(socket, {});\n    });\n\n    this.server.on('listening', () => this._onListening());\n    this.server.on('close', () => this._onClose());\n    this.server.on('error', (err) => this._onError(err));\n  }\n\n  _onListening() {\n    console.log('IMAP server listening');\n  }\n\n  _onClose() {\n    console.log('IMAP server closed');\n  }\n\n  _onError(err) {\n    console.error(`IMAP server error: ${err.message}`);\n  }\n\n  _handleProxy(socket, callback) {\n    // Handle proxy protocol if needed\n    // This is a placeholder for actual proxy protocol handling logic\n    callback(null, socket);\n  }\n\n  _upgrade(socket, callback) {\n    // Upgrade to TLS/SSL if needed\n    // This is a placeholder for actual TLS/SSL upgrade logic\n    callback(null, socket);\n  }\n}"
  },
  {
    "Task_id": 177,
    "Instruction": "Task Description: Create a TCP server in Node.js that listens on a specified port and handles incoming client connections, data, and disconnections.\n\nFunction Description: The function `createTCPServer` initializes a TCP server using Node.js's built-in `net` module. It sets up event handlers for incoming data and client disconnections, and starts listening on the specified port. The server pipes incoming data to the provided data handler.\n\nInput:\n- `port` [Number] - The port number on which the TCP server should listen.\n- `dataHandler` [Function] - A callback function to handle incoming data from clients. It receives the data as its argument.\n- `endHandler` [Function] - A callback function to handle client disconnections. It is called when a client disconnects.\n\nOutput:\n- Returns the TCP server instance [Object] - The created TCP server object, which can be used to further control the server (e.g., close it).",
    "Canonical_solution": "var net = require('net');\n\nfunction createTCPServer(port, dataHandler, endHandler) {\n    var server = net.createServer(function(client) {\n        client.on('data', dataHandler);\n        client.on('end', endHandler);\n        client.pipe(dataHandler);\n    });\n    server.listen(port);\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "right_result": "const net = require('net');\n\nfunction createTCPServer(port, dataHandler, endHandler) {\n  const server = net.createServer();\n\n  server.on('connection', (socket) => {\n    socket.on('data', (data) => {\n      dataHandler(data);\n    });\n\n    socket.on('end', () => {\n      endHandler();\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  return server;\n}"
  },
  {
    "Task_id": 178,
    "Instruction": "Task Description: Create a Node class that implements a TCP-based peer-to-peer communication system using Node.js's net module. The class should handle server creation, client connections, message passing, and peer management.\n\nClass Description: The Node class represents a network node that can both accept incoming connections and establish outgoing connections to other peers. It uses TCP sockets for communication and implements basic peer discovery and message broadcasting capabilities.\n\nAttributes:\n\nid_: [Number] - Unique identifier for this node\npeers_: [Object] - Dictionary mapping peer IDs to their socket connections\nPORT: [Number] - Base port number for node communication (actual port is PORT + id)\nserver_: [net.Server] - TCP server instance for accepting incoming connections\n\nMethods:\n\nconstructor(id) -> [void] - Initializes the node with given ID, sets up event emitter, and creates TCP server\nstart() -> [Promise] - Attempts to connect to random peers (up to 5) for network formation\non_data(data, socket) -> [void] - Handles incoming data from sockets, parses messages and emits events\nsend(socket, data) -> [void] - Sends data to a peer (either via socket object or peer ID)\nbroadcast(data) -> [void] - Sends data to all connected peers\nadd_peer(socket, remote_id) -> [void] - Adds a peer connection to the peers dictionary\nremove_peer(socket) -> [void] - Removes a peer connection from the peers dictionary\nlist_peers() -> [Array] - Returns an array of connected peer IDs",
    "Canonical_solution": "var net = require(\"net\");\nvar Msg = require(\"./message\");\nvar EventEmitter = require('events').EventEmitter;\nvar Promise = require(\"bluebird\");\n\nclass Node extends EventEmitter {\n    constructor(id) {\n        super();\n        this.id_ = id;\n        this.peers_ = {};\n        this.PORT = 8000;\n\n        let self = this;\n        this.server_ = net.createServer((socket) => {\n            socket.setEncoding('utf8');\n            socket.on('data', (data) => { self.on_data(data, socket); });\n            socket.on('end', () => { self.remove_peer(socket); });\n        });\n        this.server_.listen(this.PORT + id);\n    }\n\n    async start() {\n        for (var i = 0; i < 5; ++i) {\n            var remote_id = Math.floor(Math.random() * 20);\n            if (remote_id !== this.id_ && !this.peers_[remote_id]) {\n                let self = this;\n                var socket = net.createConnection({ port: (this.PORT + remote_id) });\n                await new Promise((resolve, reject) => {\n                    socket.on('connect', () => {\n                        resolve();\n                    });\n                    socket.on('error', function (e) {\n                        resolve();\n                    });\n                    socket.setEncoding('utf8');\n                    socket.on('data', (data) => { self.on_data(data, socket); });\n                });\n                let data = Msg.connection(self.id_);\n                self.send(socket, data);\n                self.add_peer(socket, remote_id);\n            }\n        }\n    }\n\n    on_data(data, socket) {\n        try {\n            var arr = data.split(\"\\r\\n\");\n            for (var i = 0; i < arr.length; ++i) {\n                if (arr[i] == '') continue;\n                let obj = JSON.parse(arr[i]);\n                if (obj.type == Msg.type.Connection) {\n                    let remote_id = obj.data;\n                    this.add_peer(socket, remote_id);\n                } else {\n                    this.emit(\"message\", obj);\n                }\n            }\n        } catch (err) {\n            console.log(\"=========================\");\n            console.log(`node: ${this.id_}\\t receive msg error`);\n            console.log(err);\n            console.log(err.message);\n            console.log(data);\n            console.log(arr.length);\n            console.log(\"=========================\");\n            throw new Error();\n        }\n    }\n\n    send(socket, data) {\n        if (typeof socket === 'number') {\n            socket = this.peers_[socket];\n        }\n        if (typeof data === 'object') {\n            data = JSON.stringify(data);\n        }\n        socket.write(data + \"\\r\\n\");\n    }\n\n    broadcast(data) {\n        for (var index in this.peers_) {\n            let socket = this.peers_[index];\n            this.send(socket, data);\n        }\n    }\n\n    add_peer(socket, remote_id) {\n        if (!this.peers_[remote_id]) {\n            this.peers_[remote_id] = socket;\n        }\n    }\n\n    remove_peer(socket) {\n        for (var index in this.peers_) {\n            if (this.peers_[index] == socket) {\n                delete this.peers_[index];\n                break;\n            }\n        }\n    }\n\n    list_peers() {\n        let peer_ids = [];\n        for (var index in this.peers_) {\n            peer_ids.push(index);\n        }\n        return peer_ids;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "right_result": "class Node {\n  constructor(id) {\n    this.id = id;\n    this.peers_ = {};\n    this.PORT = 8000 + id;\n    this.server_ = null;\n    this.emitter_ = require('events').EventEmitter.prototype._events || {};\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server_ = require('net').createServer((socket) => {\n        this.on_data(socket);\n      });\n\n      this.server_.on('error', (err) => {\n        reject(err);\n      });\n\n      this.server_.on('listening', () => {\n        resolve();\n      });\n\n      this.server_.listen(this.PORT);\n    });\n  }\n\n  on_data(socket) {\n    socket.on('data', (data) => {\n      const message = data.toString();\n      this.emitter_('data', message, socket);\n    });\n\n    socket.on('end', () => {\n      this.remove_peer(socket);\n    });\n  }\n\n  send(socket, data) {\n    if (socket) {\n      socket.write(data);\n    } else {\n      const peer = this.peers_[data];\n      if (peer) {\n        peer.socket.write(data);\n      }\n    }\n  }\n\n  broadcast(data) {\n    for (const peer of Object.values(this.peers_)) {\n      peer.socket.write(data);\n    }\n  }\n\n  add_peer(socket, remote_id) {\n    this.peers_[remote_id] = { socket: socket, remote_id: remote_id };\n  }\n\n  remove_peer(socket) {\n    for (const peer in this.peers_) {\n      if (this.peers_[peer].socket === socket) {\n        delete this.peers_[peer];\n        break;\n      }\n    }\n  }\n\n  list_peers() {\n    return Object.keys(this.peers_);\n  }\n}"
  },
  {
    "Task_id": 179,
    "Instruction": "Task Description: Create a function that sets up a TCP server using Node.js's built-in 'net' module to handle client connections and respond with the current timestamp.\n\nFunction Description: The function creates a TCP server that listens on a specified port. When a client connects, the server sends the current timestamp and immediately closes the connection. The server continues to listen for new connections after handling each client.\n\nInput: \n- port: [number] - The port number on which the TCP server should listen for incoming connections.\n\nOutput: \n- None (The function creates and starts the server but doesn't return anything. The server continues running to handle connections.)",
    "Canonical_solution": "function createTCPServer(port) {\n    const net = require('net');\n    const server = net.createServer(function (socket) {\n        socket.end(now() + '\\n');\n    });\n    server.listen(Number(port));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "right_result": "function startTcpServer(port) {\n  const net = require('net');\n\n  const server = net.createServer((socket) => {\n    const timestamp = new Date().toISOString();\n    socket.write(`Timestamp: ${timestamp}\\n`);\n    socket.end();\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n}"
  },
  {
    "Task_id": 180,
    "Instruction": "Task Description: Create a TCP server using Node.js's built-in 'net' module to handle client connections, parse incoming JSON data streams, and manage server lifecycle events.\n\nFunction Description: The function creates a TCP server that listens on a specified port for incoming client connections. It sets up a JSON stream parser to handle incoming data, with error handling and server cleanup on parser errors or stream end. The server automatically closes when parsing fails or the stream ends.\n\nInput: None (The port number 9999 is hardcoded in the implementation)\n\nOutput: None (The function creates and manages a server instance but doesn't return anything)",
    "Canonical_solution": "function createTcpServer() {\n    var net = require('net');\n    var server = net.createServer(function(client) {\n        var data_calls = 0;\n        var parser = JSONStream.parse();\n        parser.on('error', function(err) {\n            console.log(err);\n            server.close();\n        });\n\n        parser.on('end', function() {\n            console.log('END');\n            server.close();\n        });\n        client.pipe(parser);\n    });\n    server.listen(9999);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "right_result": "const net = require('net');\nconst JSONStream = require('JSONStream');\n\nfunction createTcpServer() {\n  const server = net.createServer();\n\n  server.on('error', (err) => {\n    console.error('Server error:', err);\n    server.close();\n  });\n\n  server.on('listening', () => {\n    console.log('Server is listening on port 9999');\n  });\n\n  server.on('connection', (socket) => {\n    const parser = JSONStream.parse(['object']);\n\n    parser.on('data', (data) => {\n      console.log('Received data:', data);\n      // Handle parsed JSON data here\n    });\n\n    parser.on('error', (err) => {\n      console.error('Parser error:', err);\n      socket.end();\n      server.close();\n    });\n\n    parser.on('end', () => {\n      console.log('Stream ended');\n      server.close();\n    });\n\n    socket.on('error', (err) => {\n      console.error('Socket error:', err);\n      server.close();\n    });\n\n    socket.on('data', (chunk) => {\n      parser.write(chunk);\n    });\n\n    socket.on('end', () => {\n      parser.end();\n    });\n  });\n\n  server.listen(9999);\n}\n\ncreateTcpServer();"
  },
  {
    "Task_id": 182,
    "Instruction": "Task Description: Create a UDP server using Node.js's dgram module to listen for incoming messages on a specified port.\n\nFunction Description: The function `createUDPServer` initializes a UDP server socket, binds it to a specified port, and listens for incoming messages. When a message is received, it logs the message content and the sender's address and port.\n\nInput: None\n\nOutput: None (The function does not return any value but logs incoming messages to the console.)",
    "Canonical_solution": "function createUDPServer() {\n    const dgram = require('dgram');\n    const socket = dgram.createSocket('udp4');\n\n    socket.on('message', (msg, rinfo) => {\n        console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n    });\n\n    socket.bind(8081);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 98,
    "right_result": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nfunction createUDPServer() {\n  server.on('message', (msg, rinfo) => {\n    console.log(`Received: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  });\n\n  server.bind(12345);\n}\n\ncreateUDPServer();"
  },
  {
    "Task_id": 183,
    "Instruction": "Task Description: Create a function that sets up a UDP server to listen for incoming messages on a specified port and handles them using a provided callback function.\n\nFunction Description: The function `createUDPServer` initializes a UDP server using Node.js's `dgram` module. It creates a socket, sets up event handlers for errors, incoming messages, and listening status, and binds the socket to the specified port. The server processes incoming messages as UTF-8 strings and passes them to the provided callback function along with the remote address information.\n\nInput:\n- `port` (Number) - The port number on which the UDP server should listen.\n- `messageHandler` (Function) - A callback function that handles incoming messages. It receives two parameters: the message data (String) and the remote address information (Object).\n\nOutput:\n- Returns the created UDP server (dgram.Socket) instance.\n\nNote: The server will automatically start listening once created and will log its listening address to the console. Errors will be logged and will cause the server to close.",
    "Canonical_solution": "const dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n    const server = dgram.createSocket('udp4');\n\n    server.on('error', err => {\n        console.error(err);\n        server.close();\n    });\n\n    server.on('message', (msg, rinfo) => {\n        const data = msg.toString('utf8').trim();\n        if (messageHandler) {\n            messageHandler(data, rinfo);\n        }\n    });\n\n    server.on('listening', () => {\n        const address = server.address();\n        console.log(`server listening ${address.address}:${address.port}`);\n    });\n\n    server.bind(port);\n\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 98,
    "right_result": "const dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n  const server = dgram.createSocket('udp4');\n  \n  server.on('error', (err) => {\n    console.error(`UDP server error: ${err.message}`);\n    server.close();\n  });\n\n  server.on('message', (msg, remote) => {\n    try {\n      const data = msg.toString('utf8');\n      messageHandler(data, remote);\n    } catch (e) {\n      console.error(`Error handling message: ${e.message}`);\n    }\n  });\n\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP server listening on ${address.address}:${address.port}`);\n  });\n\n  server.bind(port);\n  \n  return server;\n}"
  },
  {
    "Task_id": 184,
    "Instruction": "Task Description: Create a UDP server using Node.js's dgram module to handle incoming messages and respond to clients.\n\nFunction Description: The function creates a UDP server that listens for incoming messages on a specified port. When a message is received, it parses the message (assuming JSON format), logs the sender's information, and sends a response back to the client. The server also logs its binding status once it starts listening.\n\nInput: None (The port number is hardcoded as 41234 in the function.)\n\nOutput: None (The function logs messages to the console and sends responses to clients but does not return any value.)",
    "Canonical_solution": "function createUDPServer() {\n    var server = require('dgram').createSocket(\"udp4\");\n\n    server.on(\"message\", function (msg, rinfo) {\n        try {\n            msg = JSON.parse(msg);\n        } catch (e) {\n            console.dir(e);\n        }\n        console.log(\"server got message: from \" + rinfo.address + \":\" + rinfo.port);\n        console.dir(msg);\n\n        var pong = new Buffer(JSON.stringify({'command': 'pong'}));\n        server.send(pong, 0, pong.length, rinfo.port, rinfo.address, function () {\n            console.log('sent message to ' + rinfo.address + ':' + rinfo.port);\n        });\n    });\n\n    server.on(\"listening\", function () {\n        var address = server.address();\n        console.log(\"server listening \" + address.address + \":\" + address.port);\n    });\n\n    server.bind(41234);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 98,
    "right_result": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  try {\n    const data = JSON.parse(msg.toString());\n    console.log(`Received message from ${rinfo.address}:${rinfo.port}:`, data);\n    const response = { status: 'success', received: data };\n    server.send(JSON.stringify(response), 0, Buffer.byteLength(JSON.stringify(response)), rinfo.port, rinfo.address);\n  } catch (err) {\n    console.error('Error parsing message:', err);\n    server.send('{\"status\": \"error\", \"message\": \"Invalid JSON\"}', 0, Buffer.byteLength('{\"status\": \"error\", \"message\": \"Invalid JSON\"}'), rinfo.port, rinfo.address);\n  }\n});\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP server listening on ${address.address}:${address.port}`);\n});\n\nserver.bind(41234);"
  },
  {
    "Task_id": 185,
    "Instruction": "Task Description: Create a UDP server that listens for incoming messages, processes them, and emits events to connected clients via WebSocket. The server should handle JSON-formatted messages, manage streams of data, and maintain a history of recent messages for each stream.\n\nFunction Description: The function `setupUDPServer` initializes a UDP server using Node.js's `dgram` module. It listens for incoming messages, parses them as JSON, and manages a collection of data streams. Each message is stored in its respective stream, with a limit of 100 messages per stream. The server also emits WebSocket events to notify clients of new messages and updates to the available streams.\n\nInput: \n- `argv.udpPort` [Number] - The port number on which the UDP server should listen.\n- `argv.udpHost` [String] - The host address on which the UDP server should bind (optional, defaults to all interfaces if not specified).\n- `io` [Object] - A WebSocket server instance (e.g., from `socket.io`) used to emit events to connected clients.\n- `debug` [Function] - A logging function used to output debug information.\n\nOutput: None (The function sets up the UDP server and binds it to the specified port and host, but does not return any value.)",
    "Canonical_solution": "function setupUDPServer() {\n    const dgram = require('dgram');\n    let streams = {};\n    let socket = dgram.createSocket('udp4');\n\n    socket.on('message', function (data, remote) {\n        try { data = JSON.parse(data); }\n        catch (err) { return debug('invalid data sent'); }\n\n        if (!streams[data.id]) {\n            streams[data.id] = [];\n            io.sockets.emit('streams', Object.keys(streams));\n        }\n\n        let message = {\n            timestamp: data.timestamp,\n            streamid: data.id,\n            host: remote.address,\n            port: remote.port,\n            content: data.content,\n            type: typeof data.content\n        };\n\n        streams[data.id].length >= 100 && streams[data.id].shift();\n        streams[data.id].push(message);\n\n        debug(JSON.stringify(message));\n        io.sockets.to(data.id).emit('line', message);\n    });\n\n    socket.bind(argv.udpPort, argv.udpHost);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 98,
    "right_result": "const dgram = require('dgram');\nconst { io } = require('socket.io');\n\nfunction setupUDPServer(argv, io, debug) {\n  const udpPort = argv.udpPort;\n  const udpHost = argv.udpHost || '0.0.0.0';\n  const server = dgram.createSocket('udp4');\n\n  const streams = {};\n\n  server.on('message', (msg, rinfo) => {\n    try {\n      const data = JSON.parse(msg);\n      const streamId = data.streamId;\n\n      // Ensure the stream exists\n      if (!streams[streamId]) {\n        streams[streamId] = { messages: [], history: [] };\n      }\n\n      // Add new message to the stream\n      streams[streamId].messages.push(data);\n\n      // Keep only the last 100 messages\n      if (streams[streamId].messages.length > 100) {\n        streams[streamId].history.push(...streams[streamId].messages.slice(0, streams[streamId].messages.length - 100));\n        streams[streamId].messages = streams[streamId].messages.slice(-100);\n      }\n\n      // Emit event to connected clients\n      io.emit('udpMessage', { streamId, message: data });\n\n      // Emit event for stream updates\n      io.emit('udpStreamUpdate', { streamId, messages: streams[streamId].messages, history: streams[streamId].history });\n    } catch (err) {\n      debug(`Error parsing UDP message: ${err.message}`);\n    }\n  });\n\n  server.on('error', (err) => {\n    debug(`UDP server error: ${err.message}`);\n  });\n\n  server.on('listening', () => {\n    debug(`UDP server listening on ${udpHost}:${udpPort}`);\n  });\n\n  server.bind(udpPort, udpHost);\n}"
  },
  {
    "Task_id": 187,
    "Instruction": "Task Description: Implement a UDP-based server discovery system that allows servers to broadcast their presence and receive information about other nearby servers on the network.\n\nClass Description: The class provides functionality for UDP-based server discovery, including broadcasting server presence (heartbeats) and listening for broadcasts from other servers. It maintains a list of discovered servers and handles network communication errors.\n\nAttributes:\n- nearbyServers: [Object] - A dictionary storing information about discovered nearby servers, keyed by hostname.\n- lastDiscoveryBroadcast: [Number] - Timestamp of the last broadcast sent by this server.\n- broadcastIP: [String] - The broadcast IP address used for sending discovery messages.\n- discoveryListener: [Object] - The UDP socket instance used for listening to discovery messages.\n\nMethods:\n- setupDiscovery([callback: Function]) -> [void] - Initializes the UDP listener socket and binds it to the configured port. The optional callback is executed when binding is complete.\n- discoveryBroadcast([type: String, message: Object, callback: Function]) -> [void] - Creates a UDP client to broadcast a message of the specified type. The message should be an object that will be stringified to JSON. The optional callback is executed after the message is sent.\n- discoveryReceive([msg: Buffer, rinfo: Object]) -> [void] - Handles incoming UDP messages, parsing them as JSON and processing different message types (currently only 'heartbeat' is implemented). Updates the nearbyServers list when valid messages are received.\n- shutdownDiscovery() -> [void] - Closes the UDP listener socket if it exists, cleaning up network resources.\n- calcBroadcastIP() -> [String] - (Implied but not shown) Calculates the broadcast IP address based on network interfaces.",
    "Canonical_solution": "var dgram = require(\"dgram\");\nvar os = require('os');\nvar Netmask = require('netmask').Netmask;\n\nvar Class = require(\"pixl-class\");\nvar Tools = require(\"pixl-tools\");\n\nmodule.exports = Class.create({\n\t\n\tnearbyServers: null,\n\tlastDiscoveryBroadcast: 0,\n\t\n\tsetupDiscovery: function(callback) {\n\t\tvar self = this;\n\t\t\n\t\tthis.nearbyServers = {};\n\t\tthis.lastDiscoveryBroadcast = 0;\n\t\t\n\t\tif (!this.server.config.get('udp_broadcast_port')) {\n\t\t\tif (callback) callback();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.broadcastIP = this.server.config.get('broadcast_ip') || this.calcBroadcastIP();\n\t\t\n\t\tvar listener = this.discoveryListener = dgram.createSocket(\"udp4\");\n\t\t\n\t\tlistener.on(\"message\", function (msg, rinfo) {\n\t\t\tself.discoveryReceive( msg, rinfo );\n\t\t} );\n\t\t\n\t\tlistener.on(\"error\", function (err) {\n\t\t\tself.logError('udp', \"UDP socket listener error: \" + err);\n\t\t\tself.discoveryListener = null;\n\t\t} );\n\t\t\n\t\tlistener.bind( this.server.config.get('udp_broadcast_port'), function() {\n\t\t\tif (callback) callback();\n\t\t} );\n\t},\n\t\n\tdiscoveryBroadcast: function(type, message, callback) {\n\t\tvar self = this;\n\t\t\n\t\tmessage.action = type;\n\t\t\n\t\tvar client = dgram.createSocket('udp4');\n\t\tvar message = Buffer.from( JSON.stringify(message) + \"\\n\" );\n\t\tclient.bind( 0, function() {\n\t\t\tclient.setBroadcast( true );\t\t\t\n\t\t\tclient.send(message, 0, message.length, self.server.config.get('udp_broadcast_port'), self.broadcastIP, function(err) {\n\t\t\t\tif (err) self.logDebug(9, \"UDP broadcast failed: \" + err);\n\t\t\t\tclient.close();\n\t\t\t\tif (callback) callback();\n\t\t\t} );\n\t\t} );\n\t},\n\t\n\tdiscoveryReceive: function(msg, rinfo) {\n\t\tvar text = msg.toString();\n\t\tif (text.match(/^\\{/)) {\n\t\t\tvar json = null;\n\t\t\ttry { json = JSON.parse(text); }\n\t\t\tcatch (e) {\n\t\t\t\tthis.logError(9, \"Failed to parse UDP JSON message: \" + e);\n\t\t\t}\n\t\t\tif (json && json.action) {\n\t\t\t\tswitch (json.action) {\n\t\t\t\t\tcase 'heartbeat':\n\t\t\t\t\t\tif (json.hostname && (json.hostname != this.server.hostname)) {\n\t\t\t\t\t\t\tjson.now = Tools.timeNow();\n\t\t\t\t\t\t\tdelete json.action;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!this.nearbyServers[ json.hostname ]) {\n\t\t\t\t\t\t\t\tthis.nearbyServers[ json.hostname ] = json;\n\t\t\t\t\t\t\t\tif (this.multi.master) {\n\t\t\t\t\t\t\t\t\tthis.logDebug(6, \"Discovered nearby server: \" + json.hostname, json);\n\t\t\t\t\t\t\t\t\tthis.authSocketEmit( 'update', { nearby: this.nearbyServers } );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.nearbyServers[ json.hostname ] = json;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\n\tshutdownDiscovery: function() {\n\t\tif (this.discoveryListener) {\n\t\t\tthis.discoveryListener.close();\n\t\t}\n\t}\n});",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "right_result": "const dgram = require('dgram');\nconst net = require('net');\n\nclass ServerDiscovery {\n  constructor() {\n    this.nearbyServers = {};\n    this.lastDiscoveryBroadcast = Date.now();\n    this.broadcastIP = '255.255.255.255';\n    this.discoveryListener = null;\n  }\n\n  setupDiscovery(callback) {\n    this.discoveryListener = dgram.createSocket('udp4');\n    this.discoveryListener.on('message', (msg, rinfo) => this.discoveryReceive(msg, rinfo));\n    this.discoveryListener.on('error', (err) => {\n      console.error('Discovery socket error:', err);\n      if (callback) callback(err);\n    });\n    this.discoveryListener.bind(3000, () => {\n      if (callback) callback(null);\n    });\n  }\n\n  discoveryBroadcast(type, message, callback) {\n    const client = dgram.createSocket('udp4');\n    const data = JSON.stringify({ type, message });\n    client.send(data, 0, data.length, 3000, this.broadcastIP, (err) => {\n      if (err) {\n        console.error('Discovery broadcast error:', err);\n        if (callback) callback(err);\n        return;\n      }\n      client.close();\n      if (callback) callback(null);\n    });\n  }\n\n  discoveryReceive(msg, rinfo) {\n    try {\n      const data = JSON.parse(msg);\n      if (data.type === 'heartbeat') {\n        this.nearbyServers[rinfo.address] = data.message;\n      }\n    } catch (e) {\n      console.error('Invalid discovery message:', e);\n    }\n  }\n\n  shutdownDiscovery() {\n    if (this.discoveryListener) {\n      this.discoveryListener.close(() => {\n        this.discoveryListener = null;\n      });\n    }\n  }\n\n  calcBroadcastIP() {\n    return '255.255.255.255';\n  }\n}"
  },
  {
    "Task_id": 190,
    "Instruction": "Task Description: Create a function that sets up a UDP server using Node.js's dgram module to listen for incoming messages on a specified port and IP address.\n\nFunction Description: The function `setupUDPServer` initializes a UDP server socket, configures event handlers for errors and incoming messages, and binds the socket to a specified port and IP address. The server logs errors and received messages to the console.\n\nInput: None\n\nOutput: Returns the created UDP server socket object.",
    "Canonical_solution": "function setupUDPServer() {\n    const IP_ADDR = '127.0.0.1';\n    const UDP_PORT = 49161;\n    \n    const dgram = require('dgram');\n    const udpserver = dgram.createSocket('udp4');\n\n    udpserver.on('error', (err) => {\n        console.log(`UDP server:\\n${err.stack}`);\n        udpserver.close();\n    });\n\n    udpserver.on('message', (msg, rinfo) => {\n        console.log(`UDP server: ${msg} from ${rinfo.address}:${rinfo.port}`);\n    });\n\n    udpserver.bind(UDP_PORT);\n\n    return udpserver;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 98,
    "right_result": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('error', (err) => {\n  console.error(`Server error: ${err.stack}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received message: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n\nserver.bind(12345, '0.0.0.0');\n\nmodule.exports = server;"
  },
  {
    "Task_id": 192,
    "Instruction": "Task Description: Create a WebSocket client class in Node.js that manages connections, sends commands, and handles responses asynchronously.\n\nClass Description: The CustomEnvironment class provides a WebSocket client implementation that establishes and manages a connection to a WebSocket server. It handles command execution with unique IDs, callback management for responses, and connection lifecycle.\n\nAttributes:\n- callbacks: [Map] - Stores pending callbacks mapped by unique IDs for command responses\n- idSeq: [Number] - Sequence counter for generating unique command IDs\n- ws: [WebSocket] - The active WebSocket connection instance\n\nMethods:\n- initWs(): [Promise<void>] - Initializes WebSocket connection and sets up message handler. Resolves when connection is open.\n- runCommand(type: [String], data: [Any]): [Promise<Any>] - Sends a command to the server and returns a promise that resolves with response data or rejects with error\n- teardown(): [void] - Closes the WebSocket connection if it exists\n\nThe implementation should:\n1. Use the 'ws' library for WebSocket functionality\n2. Maintain connection state and automatically reconnect if needed\n3. Handle message parsing and callback execution\n4. Manage command IDs and response correlation\n5. Provide proper error handling for connection and command execution",
    "Canonical_solution": "const WebSocket = require(\"ws\");\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 1;\n  }\n\n  async initWs() {\n    this.ws = new WebSocket(\"ws://127.0.0.1:8080\");\n\n    await new Promise((resolve) => this.ws.on(\"open\", resolve));\n\n    this.ws.on(\"message\", (message) => {\n      const { id, data, error } = JSON.parse(message);\n      const cb = this.callbacks.get(id);\n      if (cb) {\n        this.callbacks.delete(id);\n        cb(error, data);\n      }\n    });\n  }\n\n  async runCommand(type, data) {\n    if (!this.ws) {\n      await this.initWs();\n    }\n\n    return new Promise((resolve, reject) => {\n      const id = String(this.idSeq++);\n\n      this.callbacks.set(id, (error, data) => {\n        if (error) {\n          reject(new Error(error));\n        } else {\n          resolve(data);\n        }\n      });\n\n      this.ws.send(JSON.stringify({ id, type, data }));\n    });\n  }\n\n  async teardown() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "right_result": "const WebSocket = require('ws');\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 0;\n    this.ws = null;\n  }\n\n  async initWs() {\n    this.ws = new WebSocket('wss://example.com/socket');\n    \n    this.ws.on('open', () => {\n      console.log('WebSocket connection established');\n    });\n\n    this.ws.on('message', (message) => {\n      try {\n        const data = JSON.parse(message);\n        if (data.id && this.callbacks.has(data.id)) {\n          const callback = this.callbacks.get(data.id);\n          callback(data.result);\n          this.callbacks.delete(data.id);\n        }\n      } catch (error) {\n        console.error('Error parsing message:', error);\n      }\n    });\n\n    this.ws.on('error', (error) => {\n      console.error('WebSocket error:', error);\n    });\n\n    this.ws.on('close', (code, reason) => {\n      console.log(`WebSocket closed with code ${code} and reason: ${reason}`);\n      // Auto-reconnect logic can be added here\n    });\n  }\n\n  async runCommand(type, data) {\n    const id = this.idSeq++;\n    const payload = { id, type, data };\n    \n    return new Promise((resolve, reject) => {\n      this.callbacks.set(id, (result) => {\n        if (result.error) {\n          reject(result.error);\n        } else {\n          resolve(result.data);\n        }\n      });\n\n      this.ws.send(JSON.stringify(payload));\n    });\n  }\n\n  teardown() {\n    if (this.ws && this.ws.readyState === this.ws.OPEN) {\n      this.ws.close();\n    }\n  }\n}"
  },
  {
    "Task_id": 193,
    "Instruction": "Task Description: Implement a WebSocket client class in Node.js that connects to a speech synthesis service, sends SSML requests, and handles the audio response streams.\n\nClass Description: WebSocketClient is a class that manages WebSocket connections to Microsoft's Bing Speech API for text-to-speech synthesis. It handles connection lifecycle, request/response mapping, and binary audio data streaming.\n\nAttributes:\n- ws: [WebSocket|null] - Active WebSocket connection instance\n- executorMap: [Map] - Stores promise resolvers/rejectors mapped by request IDs\n- bufferMap: [Map] - Accumulates binary audio data chunks mapped by request IDs\n- timer: [Timeout|null] - Connection timeout handler\n\nMethods:\n- connect() -> [Promise<WebSocket>] - Establishes WebSocket connection with proper headers and returns a promise that resolves when connected\n- sendRequest(ssml: [String], format: [String]) -> [Promise<Buffer>] - Sends SSML request with specified audio format and returns promise resolving to audio buffer\n\nInput:\n- For connect(): None\n- For sendRequest():\n  - ssml: [String] - SSML markup for speech synthesis\n  - format: [String] - Desired audio output format (e.g., \"audio-24khz-48kbitrate-mono-mp3\")\n\nOutput:\n- For connect(): Resolves with WebSocket instance or rejects with error\n- For sendRequest(): Resolves with audio buffer or rejects with error",
    "Canonical_solution": "const { WebSocket } = require(\"ws\");\nconst { randomBytes } = require(\"crypto\");\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  async connect() {\n    const connectionId = randomBytes(16).toString(\"hex\").toLowerCase();\n    let url = `wss://speech.platform.bing.com/consumer/speech/synthesize/readaloud/edge/v1?TrustedClientToken=6A5AA1D4EAFF4E9FB37E23D68491D6F4&ConnectionId=${connectionId}`;\n    let ws = new WebSocket(url, {\n      host: \"speech.platform.bing.com\",\n      origin: \"chrome-extension://jdiccldimpdaibmpdkjnbmckianbfold\",\n      headers: {\n        \"User-Agent\":\n          \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.66 Safari/537.36 Edg/103.0.1264.44\",\n      },\n    });\n    \n    return new Promise((resolve, reject) => {\n      ws.on(\"open\", () => {\n        resolve(ws);\n      });\n      \n      ws.on(\"close\", (code, reason) => {\n        this.ws = null;\n        if (this.timer) {\n          clearTimeout(this.timer);\n          this.timer = null;\n        }\n        for (let [key, value] of this.executorMap) {\n          value.reject(`\u8fde\u63a5\u5df2\u5173\u95ed: ${reason} ${code}`);\n        }\n        this.executorMap.clear();\n        this.bufferMap.clear();\n      });\n\n      ws.on(\"message\", (message, isBinary) => {\n        let pattern = /X-RequestId:(?<id>[a-z|0-9]*)/;\n        if (!isBinary) {\n          let data = message.toString();\n          if (data.includes(\"Path:turn.start\")) {\n            let matches = data.match(pattern);\n            let requestId = matches.groups.id;\n            this.bufferMap.set(requestId, Buffer.from([]));\n          } else if (data.includes(\"Path:turn.end\")) {\n            let matches = data.match(pattern);\n            let requestId = matches.groups.id;\n            let executor = this.executorMap.get(requestId);\n            if (executor) {\n              this.executorMap.delete(matches.groups.id);\n              let result = this.bufferMap.get(requestId);\n              executor.resolve(result);\n            }\n          }\n        } else if (isBinary) {\n          let separator = \"Path:audio\\r\\n\";\n          let data = message;\n          let contentIndex = data.indexOf(separator) + separator.length;\n          let headers = data.slice(2, contentIndex).toString();\n          let matches = headers.match(pattern);\n          let requestId = matches.groups.id;\n          let content = data.slice(contentIndex);\n          let buffer = this.bufferMap.get(requestId);\n          if (buffer) {\n            buffer = Buffer.concat([buffer, content], buffer.length+content.length);\n            this.bufferMap.set(requestId, buffer);\n          }\n        }\n      });\n      \n      ws.on(\"error\", (error) => {\n        reject(`\u8fde\u63a5\u5931\u8d25\uff1a ${error}`);\n      });\n    });\n  }\n\n  async sendRequest(ssml, format) {\n    if (this.ws == null || this.ws.readyState != WebSocket.OPEN) {\n      let connection = await this.connect();\n      this.ws = connection;\n    }\n    \n    const requestId = randomBytes(16).toString(\"hex\").toLowerCase();\n    let result = new Promise((resolve, reject) => {\n      this.executorMap.set(requestId, { resolve, reject });\n      \n      let configData = {\n        context: {\n          synthesis: {\n            audio: {\n              metadataoptions: {\n                sentenceBoundaryEnabled: \"false\",\n                wordBoundaryEnabled: \"false\",\n              },\n              outputFormat: format,\n            },\n          },\n        },\n      };\n      \n      let configMessage =\n        `X-Timestamp:${Date()}\\r\\n` +\n        \"Content-Type:application/json; charset=utf-8\\r\\n\" +\n        \"Path:speech.config\\r\\n\\r\\n\" +\n        JSON.stringify(configData);\n        \n      this.ws.send(configMessage, (configError) => {\n        if (configError) return;\n        \n        let ssmlMessage =\n          `X-Timestamp:${Date()}\\r\\n` +\n          `X-RequestId:${requestId}\\r\\n` +\n          `Content-Type:application/ssml+xml\\r\\n` +\n          `Path:ssml\\r\\n\\r\\n` +\n          ssml;\n        this.ws.send(ssmlMessage);\n      });\n    });\n\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    \n    this.timer = setTimeout(() => {\n      if (this.ws && this.ws.readyState == WebSocket.OPEN) {\n        this.ws.close(1000);\n        this.timer = null;\n      }\n    }, 10000);\n\n    return await Promise.race([\n      result,\n      new Promise((resolve, reject) => {\n        setTimeout(() => {\n          this.executorMap.delete(requestId);\n          this.bufferMap.delete(requestId);\n          reject(\"\u8bf7\u6c42\u8d85\u65f6\");\n        }, 10000);\n      }),\n    ]);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "right_result": "const WebSocket = require('ws');\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  async connect() {\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket('wss://speech.platform.bing.com/speech/recognize');\n      \n      this.ws.on('open', () => {\n        this.timer = setTimeout(() => {\n          this.ws.close();\n          reject(new Error('Connection timeout'));\n        }, 10000);\n        resolve(this.ws);\n      });\n\n      this.ws.on('error', (err) => {\n        clearTimeout(this.timer);\n        reject(err);\n      });\n\n      this.ws.on('close', (code, reason) => {\n        clearTimeout(this.timer);\n        if (code === 1000) {\n          reject(new Error('Connection closed normally'));\n        } else {\n          reject(new Error(`Connection closed with code ${code}: ${reason}`));\n        }\n      });\n\n      this.ws.on('message', (message) => {\n        const data = Buffer.from(message);\n        const response = JSON.parse(data.toString());\n        \n        if (response.status === 'success') {\n          const requestId = response.requestId;\n          const buffer = this.bufferMap.get(requestId);\n          if (buffer) {\n            buffer.push(data);\n            if (buffer.length === response.totalBytes) {\n              this.bufferMap.delete(requestId);\n              this.executorMap.delete(requestId);\n              this.executorMap.get(requestId)(Buffer.concat(buffer));\n            }\n          }\n        } else {\n          const requestId = response.requestId;\n          this.executorMap.get(requestId)(new Error(response.message));\n          this.bufferMap.delete(requestId);\n          this.executorMap.delete(requestId);\n        }\n      });\n    });\n  }\n\n  async sendRequest(ssml, format) {\n    return new Promise((resolve, reject) {\n      const requestId = Date.now().toString();\n      const buffer = [];\n      const executor = { resolve, reject };\n      this.executorMap.set(requestId, executor);\n      this.bufferMap.set(requestId, buffer);\n\n      this.ws.send(JSON.stringify({\n        \"text\": ssml,\n        \"format\": format,\n        \"requestId\": requestId\n      }));\n\n      const timeout = setTimeout(() => {\n        reject(new Error('Request timeout'));\n        this.executorMap.delete(requestId);\n        this.bufferMap.delete(requestId);\n      }, 30000);\n\n      this.ws.on('close', () => {\n        clearTimeout(timeout);\n        reject(new Error('Connection closed'));\n        this.executorMap.delete(requestId);\n        this.bufferMap.delete(requestId);\n      });\n    });\n  }\n}"
  },
  {
    "Task_id": 195,
    "Instruction": "Task Description: Create a function to test WebSocket communication between a client and server, verifying the ability to send and receive empty payload messages.\n\nFunction Description: The function sets up a WebSocket server and client, where the server echoes back an empty message when it receives any message from the client. The test verifies that the client can successfully receive this empty message.\n\nInput: None (The function is self-contained and doesn't require external parameters)\n\nOutput: None (The function performs assertions internally and doesn't return any value)",
    "Canonical_solution": "function testWebSocketCommunication() {\n  const { test } = require('node:test');\n  const { WebSocketServer } = require('ws');\n  const { WebSocket } = require('../..');\n  const { tspl } = require('@matteo.collina/tspl');\n\n  test('Receiving frame with payload length 0 works', async (t) => {\n    const { ok, completed } = tspl(t, { plan: 1 });\n\n    const server = new WebSocketServer({ port: 0 });\n\n    server.on('connection', (socket) => {\n      socket.on('message', () => {\n        socket.send('');\n      });\n    });\n\n    t.after(() => {\n      server.close();\n      ws.close();\n    });\n\n    const ws = new WebSocket(`ws://127.0.0.1:${server.address().port}`);\n\n    ws.addEventListener('open', () => {\n      ws.send('Hi');\n    });\n\n    ws.addEventListener('message', () => {\n      ok(true);\n    });\n\n    await completed;\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "right_result": "(async () => {\n  const WebSocket = require('ws');\n\n  // Create a WebSocket server\n  const wss = new WebSocket.Server({ port: 8080 });\n\n  let client;\n\n  wss.on('connection', (ws) => {\n    client = ws;\n    client.on('message', (message) => {\n      if (message === '') {\n        client.send('');\n      }\n    });\n  });\n\n  // Create a WebSocket client\n  const ws = new WebSocket('ws://localhost:8080');\n\n  ws.on('open', () => {\n    ws.send('');\n  });\n\n  ws.on('message', (message) => {\n    if (message === '') {\n      console.log('Received empty message');\n      ws.close();\n    }\n  });\n\n  ws.on('close', () => {\n    console.log('Test completed');\n  });\n})();"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a JavaScript class for interacting with the Cryptsy cryptocurrency exchange API, handling both public and private endpoints with proper authentication and request management.\n\nClass Description: The Cryptsy class provides a wrapper for the Cryptsy API, enabling users to make authenticated requests to private endpoints and public data requests. It handles API authentication, request signing, and response processing.\n\nAttributes:\n- key: string - API key for authentication\n- secret: string - API secret for request signing\n- PUBLIC_API_URL: string - Base URL for public API endpoints (default: 'http://pubapi.cryptsy.com/api.php')\n- PRIVATE_API_URL: string - Base URL for private API endpoints (default: 'https://api.cryptsy.com/api')\n- USER_AGENT: string - User agent string for requests (default: 'nomp/node-open-mining-portal')\n- STRICT_SSL: boolean - Static flag for SSL verification (default: true)\n\nMethods:\n- constructor(key, secret) -> Cryptsy - Initializes the API client with credentials\n- _getPrivateHeaders(parameters: object) -> object - Generates authentication headers for private requests\n- _request(options: object, callback: function) -> Cryptsy - Base request method with common configuration\n- _public(parameters: object, callback: function) -> Cryptsy - Makes public API requests\n- _private(parameters: object, callback: function) -> Cryptsy - Makes authenticated private API requests\n- getTicker(callback: function) -> Cryptsy - Gets market ticker data\n- getOrderBook(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets order book for a currency pair\n- getTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets public trade history\n- myBalances(callback: function) -> Cryptsy - Gets user's account balances\n- myOpenOrders(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's open orders\n- myTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's trade history\n- buy(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a buy order\n- sell(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a sell order\n- cancelOrder(currencyA: string, currencyB: string, orderNumber: string, callback: function) -> Cryptsy - Cancels an order\n- withdraw(currency: string, amount: number, address: string, callback: function) -> Cryptsy - Withdraws funds\n- _joinCurrencies(currencyA: string, currencyB: string) -> string - Helper to format currency pairs",
    "Canonical_solution": "var request = require('request');\nvar nonce = require('nonce');\nvar crypto = require('crypto');\n\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n    }\n\n    static STRICT_SSL = true;\n\n    _getPrivateHeaders(parameters) {\n        if (!this.key || !this.secret) {\n            throw 'Cryptsy: Error. API key and secret required';\n        }\n\n        let paramString = Object.keys(parameters).sort().map(function(param) {\n            return encodeURIComponent(param) + '=' + encodeURIComponent(parameters[param]);\n        }).join('&');\n\n        let signature = crypto.createHmac('sha512', this.secret).update(paramString).digest('hex');\n\n        return {\n            Key: this.key,\n            Sign: signature\n        };\n    }\n\n    _request(options, callback) {\n        if (!('headers' in options)) {\n            options.headers = {};\n        }\n\n        options.headers['User-Agent'] = this.USER_AGENT;\n        options.json = true;\n        options.strictSSL = Cryptsy.STRICT_SSL;\n\n        request(options, function(err, response, body) {\n            callback(err, body);\n        });\n\n        return this;\n    }\n\n    _public(parameters, callback) {\n        let options = {\n            method: 'GET',\n            url: this.PUBLIC_API_URL,\n            qs: parameters\n        };\n\n        return this._request(options, callback);\n    }\n\n    _private(parameters, callback) {\n        parameters.nonce = nonce();\n        let options = {\n            method: 'POST',\n            url: this.PRIVATE_API_URL,\n            form: parameters,\n            headers: this._getPrivateHeaders(parameters)\n        };\n\n        return this._request(options, callback);\n    }\n\n    getTicker(callback) {\n        let parameters = {\n            method: 'marketdatav2'\n        };\n        return this._public(parameters, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOrderBook',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    myBalances(callback) {\n        let parameters = {\n            command: 'returnBalances'\n        };\n        return this._private(parameters, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOpenOrders',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'buy',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'sell',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        let parameters = {\n            command: 'cancelOrder',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            orderNumber: orderNumber\n        };\n        return this._private(parameters, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        let parameters = {\n            command: 'withdraw',\n            currency: currency,\n            amount: amount,\n            address: address\n        };\n        return this._private(parameters, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return currencyA + '_' + currencyB;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "right_result": "class Cryptsy {\n  constructor(key, secret) {\n    this.key = key;\n    this.secret = secret;\n    this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n    this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n    this.USER_AGENT = 'nomp/node-open-mining-portal';\n    this.STRICT_SSL = true;\n  }\n\n  _getPrivateHeaders(parameters) {\n    const timestamp = Math.floor(Date.now() / 1000);\n    const sortedParams = Object.keys(parameters).sort().reduce((acc, key) => {\n      acc[key] = parameters[key];\n      return acc;\n    }, {});\n    const querystring = new URLSearchParams(sortedParams).toString();\n    const signature = crypto.createHmac('sha512', this.secret)\n      .update(querystring + this.key + timestamp + this.secret)\n      .digest('hex');\n    return {\n      'API-Key': this.key,\n      'API-Signature': signature,\n      'Timestamp': timestamp,\n      'User-Agent': this.USER_AGENT\n    };\n  }\n\n  _request(options, callback) {\n    const req = require('request');\n    const headers = options.headers || {};\n    const url = options.url || this.PUBLIC_API_URL;\n    const method = options.method || 'GET';\n    const data = options.data;\n\n    req({\n      url: url,\n      method: method,\n      headers: {\n        ...headers,\n        'User-Agent': this.USER_AGENT\n      },\n      json: true,\n      strictSSL: this.STRICT_SSL\n    }, (error, response, body) => {\n      if (error) {\n        return callback(error);\n      }\n      if (response.statusCode !== 200) {\n        return callback(new Error(`API request failed with status code ${response.statusCode}: ${body}`));\n      }\n      callback(null, body);\n    });\n  }\n\n  _public(parameters, callback) {\n    this._request({\n      url: this.PUBLIC_API_URL,\n      method: 'POST',\n      data: parameters\n    }, callback);\n  }\n\n  _private(parameters, callback) {\n    this._request({\n      url: this.PRIVATE_API_URL,\n      method: 'POST',\n      headers: this._getPrivateHeaders(parameters),\n      data: parameters\n    }, callback);\n  }\n\n  getTicker(callback) {\n    this._public({\n      method: 'getticker'\n    }, callback);\n  }\n\n  getOrderBook(currencyA, currencyB, callback) {\n    this._public({\n      method: 'getorderbook',\n      currencyA: currencyA,\n      currencyB: currencyB\n    }, callback);\n  }\n\n  getTradeHistory(currencyA, currencyB, callback) {\n    this._public({\n      method: 'gettradehistory',\n      currencyA: currencyA,\n      currencyB: currencyB\n    }, callback);\n  }\n\n  myBalances(callback) {\n    this._private({\n      method: 'mybalances'\n    }, callback);\n  }\n\n  myOpenOrders(currencyA, currencyB, callback) {\n    this._private({\n      method: 'myopenorders',\n      currencyA: currencyA,\n      currencyB: currencyB\n    }, callback);\n  }\n\n  myTradeHistory(currencyA, currencyB, callback) {\n    this._private({\n      method: 'mytrades',\n      currencyA: currencyA,\n      currencyB: currencyB\n    }, callback);\n  }\n\n  buy(currencyA, currencyB, rate, amount, callback) {\n    this._private({\n      method: 'buy',\n      currencyA: currencyA,\n      currencyB: currencyB,\n      rate: rate,\n      amount: amount\n    }, callback);\n  }\n\n  sell(currencyA, currencyB, rate, amount, callback) {\n    this._private({\n      method: 'sell',\n      currencyA: currencyA,\n      currencyB: currencyB,\n      rate: rate,\n      amount: amount\n    }, callback);\n  }\n\n  cancelOrder(currencyA, currencyB, orderNumber, callback) {\n    this._private({\n      method: 'cancelorder',\n      currencyA: currencyA,\n      currencyB: currencyB,\n      orderNumber: orderNumber\n    }, callback);\n  }\n\n  withdraw(currency, amount, address, callback) {\n    this._private({\n      method: 'withdraw',\n      currency: currency,\n      amount: amount,\n      address: address\n    }, callback);\n  }\n\n  _joinCurrencies(currencyA, currencyB) {\n    return `${currencyA}${currencyB}`;\n  }\n}"
  },
  {
    "Task_id": 203,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with automatic reconnection capabilities and event handling.\n\nClass Description: The WebSocketClient class provides a wrapper around the browser's native WebSocket API, adding features like automatic reconnection with exponential backoff, connection state management, and customizable event handlers for connection events.\n\nAttributes:\n- URI: string - The WebSocket server URI to connect to\n- _socket: WebSocket - The underlying WebSocket connection instance\n- _isOpen: boolean - Tracks whether the connection is currently open\n- _shouldClose: boolean - Flag indicating if the connection was intentionally closed\n- _delayUntilReconnect: number - Current delay before attempting reconnection (in milliseconds)\n- openHandler: function - Callback for connection open events\n- messageHandler: function - Callback for incoming message events\n- closeHandler: function - Callback for connection close events\n\nMethods:\n- constructor(uri: string) -> void - Initializes the WebSocket client with the given URI\n- open() -> void - Establishes a new WebSocket connection and sets up event handlers\n- send(message: string) -> void - Sends a message through the WebSocket if connected\n- close() -> void - Closes the WebSocket connection intentionally\n- reconnect() -> void - Forces a reconnection by closing the current connection\n- getReconnectDelay() -> number - Returns the current reconnection delay\n- _onopen() -> void - Internal handler for WebSocket open events\n- _resetDelay() -> void - Resets the reconnection delay to initial value\n- _onmessage(e: MessageEvent) -> void - Internal handler for WebSocket message events\n- _onclose() -> void - Internal handler for WebSocket close events\n- _reconnect() -> void - Handles reconnection logic with exponential backoff",
    "Canonical_solution": "class WebSocketClient {\n  constructor(uri) {\n    this.URI = uri;\n    this._resetDelay();\n    this._socket = null;\n    this._isOpen = false;\n    this._shouldClose = false;\n    this._delayUntilReconnect = null;\n    this.openHandler = null;\n    this.messageHandler = null;\n    this.closeHandler = null;\n  }\n\n  open() {\n    if (!window.WebSocket) {\n      return;\n    }\n\n    this._shouldClose = false;\n\n    this._socket = new WebSocket(this.URI);\n    this._socket.onopen = this._onopen.bind(this);\n    this._socket.onmessage = this._onmessage.bind(this);\n    this._socket.onclose = this._onclose.bind(this);\n  }\n\n  send(message) {\n    if (this._isOpen) {\n      this._socket.send(message);\n    }\n  }\n\n  close() {\n    if (!this._isOpen) {\n      return;\n    }\n    this._shouldClose = true;\n    this._socket.close();\n  }\n\n  reconnect() {\n    if (!this._isOpen) {\n      return;\n    }\n    this._socket.close();\n  }\n\n  getReconnectDelay() {\n    return this._delayUntilReconnect;\n  }\n\n  _onopen() {\n    this._isOpen = true;\n    this._delayUntilReconnect = 0;\n\n    if (this.openHandler) {\n      this.openHandler();\n    }\n  }\n\n  _resetDelay() {\n    this._delayUntilReconnect = 2000;\n  }\n\n  _onmessage(e) {\n    var data = e.data;\n    if (this.messageHandler) {\n      this.messageHandler(data);\n    }\n  }\n\n  _onclose() {\n    this._isOpen = false;\n    var done = false;\n\n    if (this.closeHandler) {\n      done = this.closeHandler();\n    }\n\n    if (!done && !this._shouldClose) {\n      setTimeout(this._reconnect.bind(this), this._delayUntilReconnect);\n    }\n  }\n\n  _reconnect() {\n    if (!this._delayUntilReconnect) {\n      this._resetDelay();\n    } else {\n      this._delayUntilReconnect = this._delayUntilReconnect * 2;\n    }\n\n    this._delayUntilReconnect = Math.min(this._delayUntilReconnect, 300000);\n    this.open();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class WebSocketClient {\n  constructor(uri) {\n    this.URI = uri;\n    this._socket = new WebSocket(this.URI);\n    this._isOpen = false;\n    this._shouldClose = false;\n    this._delayUntilReconnect = 1000;\n    this.openHandler = null;\n    this.messageHandler = null;\n    this.closeHandler = null;\n    this._setupEventListeners();\n  }\n\n  open() {\n    if (this._socket.readyState === this._socket.OPEN) {\n      return;\n    }\n    this._socket.addEventListener('open', this._onopen.bind(this));\n    this._socket.addEventListener('message', this._onmessage.bind(this));\n    this._socket.addEventListener('close', this._onclose.bind(this));\n    this._socket.addEventListener('error', this._onerror.bind(this));\n    this._socket.connect();\n  }\n\n  send(message) {\n    if (this._socket.readyState === this._socket.OPEN) {\n      this._socket.send(message);\n    }\n  }\n\n  close() {\n    this._shouldClose = true;\n    this._socket.close();\n  }\n\n  reconnect() {\n    this._shouldClose = true;\n    this._socket.close();\n    this._reconnect();\n  }\n\n  getReconnectDelay() {\n    return this._delayUntilReconnect;\n  }\n\n  _onopen() {\n    this._isOpen = true;\n    this._shouldClose = false;\n    if (this.openHandler) {\n      this.openHandler();\n    }\n  }\n\n  _resetDelay() {\n    this._delayUntilReconnect = 1000;\n  }\n\n  _onmessage(e) {\n    if (this.messageHandler) {\n      this.messageHandler(e.data);\n    }\n  }\n\n  _onclose() {\n    this._isOpen = false;\n    this._shouldClose = false;\n    if (this.closeHandler) {\n      this.closeHandler();\n    }\n    this._reconnect();\n  }\n\n  _onerror(e) {\n    console.error('WebSocket error:', e);\n    this._reconnect();\n  }\n\n  _reconnect() {\n    if (this._shouldClose) {\n      return;\n    }\n    setTimeout(() => {\n      this._delayUntilReconnect *= 2;\n      this._socket = new WebSocket(this.URI);\n      this._setupEventListeners();\n    }, this._delayUntilReconnect);\n  }\n\n  _setupEventListeners() {\n    this._socket.addEventListener('open', this._onopen.bind(this));\n    this._socket.addEventListener('message', this._onmessage.bind(this));\n    this._socket.addEventListener('close', this._onclose.bind(this));\n    this._socket.addEventListener('error', this._onerror.bind(this));\n  }\n}"
  },
  {
    "Task_id": 204,
    "Instruction": "Task Description: Create a WebSocket client in JavaScript that automatically reconnects to a server upon disconnection and triggers a page reload when receiving a message from the server.\n\nFunction Description: The function establishes a WebSocket connection to a specified URL. It handles connection closure by attempting to reconnect after a delay and reloads the page upon receiving any message from the server.\n\nInput: \n- a (String): The WebSocket server URL to connect to (e.g., \"ws://localhost:12450/reload\")\n\nOutput: None (The function's effects are side effects: establishing connection, handling messages, and attempting reconnections)",
    "Canonical_solution": "function b(a) {\n    var c = new WebSocket(a);\n    c.onclose = function() {\n        setTimeout(function() {\n            b(a)\n        }, 2E3)\n    };\n    c.onmessage = function() {\n        location.reload()\n    }\n}\ntry {\n    if (window.WebSocket) {\n        try {\n            b(\"ws://localhost:12450/reload\")\n        } catch (a) {\n            console.error(a)\n        }\n    } else {\n        console.log(\"Your browser does not support WebSockets.\")\n    }\n} catch (a) {\n    console.error(\"Exception during connecting to Reload:\", a)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function connectWebSocket(a) {\n  const ws = new WebSocket(a);\n\n  ws.onmessage = function(event) {\n    window.location.reload();\n  };\n\n  ws.onclose = function() {\n    setTimeout(() => {\n      connectWebSocket(a);\n    }, 2000);\n  };\n}"
  },
  {
    "Task_id": 205,
    "Instruction": "Task Description: Create a JavaScript function that manages parallel execution of tests using WebSocket communication to coordinate test runs and report results.\n\nFunction Description: The function establishes a WebSocket connection to a test server, manages a queue of tests to run in parallel (with configurable parallelism), opens test cases in separate windows, and processes test results and status updates received through the WebSocket connection. It handles test queuing, parallel execution, status tracking, and result reporting.\n\nInput: None (The function operates on DOM elements and uses a hardcoded WebSocket URL)\n\nOutput: None (The function modifies the DOM to display test statuses and results)\n\nAttributes (internal variables used by the function):\n- socket: WebSocket - The WebSocket connection to the test server\n- maxParallelRuns: Number - Maximum number of tests to run simultaneously\n- subscriptionKey: Number - Unique identifier for this test session\n- queue: Array - Queue of tests waiting to be executed\n- numRunning: Number - Count of currently running tests\n\nMethods (internal functions):\n- processQueue() -> void - Processes the test queue by opening test windows up to the maximum parallel limit\n- WebSocket.onopen handler -> void - Handles WebSocket connection establishment\n- WebSocket.onmessage handler -> void - Processes incoming WebSocket messages (test results and status updates)",
    "Canonical_solution": "function runAllTests() {\n    var socket = null;\n    var maxParallelRuns = 4;\n    var subscriptionKey = Date.now();\n    var queue = [];\n    var numRunning = 0;\n\n    function processQueue() {\n        var toRun = queue.splice(0, Math.min(maxParallelRuns - numRunning, queue.length));\n        toRun.forEach(function (linkDiv) {\n            linkDiv.querySelector(\".status\").textContent = \"- Running...\";\n            window.open(linkDiv.querySelector(\".testLink\").href + \"&autostart=true&subscriptionKey=\" + subscriptionKey, \"\", \"width=800, height=800, top=0, left=400\")\n            numRunning++;\n        });\n    }\n\n    socket = new WebSocket(\"ws://localhost:9998\");\n    socket.onopen = function () {\n        socket.send(JSON.stringify({ \n            id: \"Dashboard\", \n            type: \"registerSubscriber\", \n            args: { subscriptionKey: subscriptionKey } \n        }));\n\n        var linkDivs = document.querySelectorAll(\".testLinkDiv\");\n        for (var i = 0, l = linkDivs.length; i < l; i++) {\n            var linkDiv = linkDivs[i];\n            linkDiv.querySelector(\".status\").textContent = \"- Queued to run\";\n            queue.push(linkDiv);\n        }\n        processQueue();\n    };\n    socket.onmessage = function (m) {\n        var message = JSON.parse(m.data);\n\n        switch (message.type) {\n            case \"osinfo\":\n                processQueue();\n                break;\n\n            case \"report\":\n                var li = document.querySelector(\"#id_\" + message.id);\n                var data = message.args.data;\n                switch (data.type) {\n                    case \"singleFailure\":\n                        li.classList.add(\"failed\");\n                        break;\n                    case \"finished\":\n                        li.classList.add(\"reported\");\n                        li.querySelector(\".status\").textContent = \"- \" + (((+data.runtime / 1000) + 1) | 0) + \"s\";\n                        if (data.failures) {\n                            li.classList.add(\"failed\");\n                        } else {\n                            li.classList.add(\"passed\");\n                        }\n                        break;\n                }\n                break;\n\n            case \"reporterDisconnected\":\n                var li = document.querySelector(\"#id_\" + message.id);\n                if (!li.classList.contains(\"reported\")) {\n                    li.classList.add(\"reported\");\n                    li.classList.add(\"failed\");\n                    var status = li.querySelector(\".status\");\n                    status.textContent = \"- Canceled\";\n                }\n                numRunning--;\n                processQueue();\n                break;\n        }\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function runTests() {\n  const socket = new WebSocket('ws://test-server.com/socket');\n  let maxParallelRuns = 5;\n  let subscriptionKey = Math.random();\n  let queue = [];\n  let numRunning = 0;\n\n  function processQueue() {\n    while (numRunning < maxParallelRuns && queue.length > 0) {\n      const test = queue.shift();\n      openTestWindow(test);\n      numRunning++;\n    }\n  }\n\n  socket.onopen = function() {\n    socket.send(JSON.stringify({ type: 'subscribe', key: subscriptionKey }));\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === 'result') {\n      updateTestResult(data.id, data.status, data.message);\n    } else if (data.type === 'status') {\n      updateTestStatus(data.id, data.status);\n    }\n  };\n\n  function openTestWindow(test) {\n    const window = window.open('');\n    window.onload = function() {\n      window.location.href = `test.html?test=${encodeURIComponent(test)}`;\n    };\n  }\n\n  function updateTestResult(id, status, message) {\n    const element = document.getElementById(`result-${id}`);\n    if (element) {\n      element.textContent = `${status}: ${message}`;\n    }\n  }\n\n  function updateTestStatus(id, status) {\n    const element = document.getElementById(`status-${id}`);\n    if (element) {\n      element.textContent = status;\n    }\n  }\n}"
  },
  {
    "Task_id": 206,
    "Instruction": "The provided reference code is at the function level, so I'll structure the instruction accordingly:\n\nTask Description: Implement a WebSocket client that automatically reconnects on connection loss and triggers a page reload when receiving a message.\n\nFunction Description: The function establishes a WebSocket connection to the specified URL. It handles connection closure by automatically attempting to reconnect after a delay (2 seconds). When a message is received through the WebSocket, it triggers a full page reload. This is useful for implementing live-reload functionality during development or for real-time updates in web applications.\n\nInput: \n- a: [String] - The WebSocket server URL to connect to (e.g., \"ws://localhost:8080\")\n\nOutput: \n- None (the function doesn't return anything, but has side effects of managing WebSocket connection and page reloading)",
    "Canonical_solution": "function b(a) {\n    var c = new WebSocket(a);\n    c.onclose = function() {\n        setTimeout(function() {\n            b(a)\n        }, 2E3)\n    };\n    c.onmessage = function() {\n        location.reload()\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function connectWebSocket(a) {\n  const ws = new WebSocket(a);\n\n  ws.onopen = () => {\n    console.log('WebSocket connected');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Received message:', event.data);\n    window.location.reload();\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket closed, attempting to reconnect...');\n    setTimeout(() => {\n      connectWebSocket(a);\n    }, 2000);\n  };\n}"
  },
  {
    "Task_id": 207,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that handles real-time communication with a server, including connection management, message handling, and error recovery.\n\nClass Description: The WebSocketClient class manages WebSocket connections to a server, providing methods to open/close connections, send messages, and handle various WebSocket events. It includes automatic reconnection logic and heartbeat mechanism to maintain connection.\n\nAttributes:\n- websocket: [WebSocket] - The WebSocket connection instance\n- wxErrorCount: [Number] - Counter for tracking connection errors\n- updateUrl: [String] - Base URL for WebSocket connection\n- gridKey: [String] - Identifier for the grid/session\n- retryTimer: [Number] - Timer ID for the heartbeat interval\n\nMethods:\n- constructor(updateUrl, gridKey) -> [WebSocketClient] - Initializes the WebSocket client with connection URL and grid key\n- openWebSocket() -> [void] - Establishes WebSocket connection and sets up event handlers\n- sendMessage(data) -> [void] - Sends compressed data through the WebSocket connection\n- closeConnection() -> [void] - Properly closes the WebSocket connection\n\nEvent Handlers:\n- onopen: [Function] - Handles connection establishment\n- onmessage: [Function] - Processes incoming messages from server\n- onerror: [Function] - Manages connection errors with retry logic\n- onclose: [Function] - Handles connection closure scenarios",
    "Canonical_solution": "import pako from 'pako';\n\nclass WebSocketClient {\n    constructor(updateUrl, gridKey) {\n        this.websocket = null;\n        this.wxErrorCount = 0;\n        this.updateUrl = updateUrl;\n        this.gridKey = gridKey;\n    }\n\n    openWebSocket() {\n        let _this = this;\n\n        if('WebSocket' in window) {\n            let wxUrl = _this.updateUrl + \"?t=111&g=\" + encodeURIComponent(_this.gridKey);\n            if(_this.updateUrl.indexOf('?') > -1) {\n                wxUrl = _this.updateUrl + \"&t=111&g=\" + encodeURIComponent(_this.gridKey);\n            }\n\n            _this.websocket = new WebSocket(wxUrl);\n\n            // Connection established\n            _this.websocket.onopen = function() {\n                console.info(locale().websocket.success);\n                hideloading();\n                _this.wxErrorCount = 0;\n\n                // Prevent WebSocket from disconnecting due to inactivity\n                _this.retryTimer = setInterval(function() {\n                    _this.websocket.send(\"rub\");\n                }, 60000);\n            }\n\n            // Client receives server data\n            _this.websocket.onmessage = function(result) {\n                Store.result = result;\n                let data = new Function(\"return \" + result.data)();\n                method.createHookFunction('cooperativeMessage', data);\n                console.info(data);\n                let type = data.type;\n                let {message, id} = data;\n                \n                // Handle different message types\n                if(message === '\u7528\u6237\u9000\u51fa') {\n                    $(\"#luckysheet-multipleRange-show-\" + id).hide();\n                    Store.cooperativeEdit.changeCollaborationSize = Store.cooperativeEdit.changeCollaborationSize.filter(value => {\n                        return value.id != id\n                    });\n                    Store.cooperativeEdit.checkoutData = Store.cooperativeEdit.checkoutData.filter(value => {\n                        return value.id != id\n                    });\n                }\n                \n                // Handle different message types (1: send success/failure, 2: update data, etc.)\n                // ... (rest of the message handling logic)\n            }\n\n            // Communication error occurred\n            _this.websocket.onerror = function() {\n                _this.wxErrorCount++;\n\n                if(_this.wxErrorCount > 3) {\n                    showloading(locale().websocket.refresh);\n                } else {\n                    showloading(locale().websocket.wait);\n                    _this.openWebSocket();\n                }\n            }\n\n            // Connection closed\n            _this.websocket.onclose = function(e) {\n                console.info(locale().websocket.close);\n                if(e.code === 1000) {\n                    clearInterval(_this.retryTimer);\n                    _this.retryTimer = null;\n                } else {\n                    alert(locale().websocket.contact);\n                }\n            }\n        } else {\n            alert(locale().websocket.support);\n        }\n    }\n\n    sendMessage(data) {\n        if(this.websocket != null) {\n            let msg = pako.gzip(encodeURIComponent(JSON.stringify(data)), {to: \"string\"});\n            this.websocket.send(msg);\n        }\n    }\n\n    closeConnection() {\n        if(this.websocket != null) {\n            this.websocket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class WebSocketClient {\n  constructor(updateUrl, gridKey) {\n    this.websocket = null;\n    this.wxErrorCount = 0;\n    this.updateUrl = updateUrl;\n    this.gridKey = gridKey;\n    this.retryTimer = null;\n  }\n\n  openWebSocket() {\n    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    const url = `${this.updateUrl}?gridKey=${encodeURIComponent(this.gridKey)}`;\n    this.websocket = new WebSocket(url);\n\n    this.websocket.onopen = this.onopen.bind(this);\n    this.websocket.onmessage = this.onmessage.bind(this);\n    this.websocket.onerror = this.onerror.bind(this);\n    this.websocket.onclose = this.onclose.bind(this);\n  }\n\n  onopen(event) {\n    console.log('WebSocket connection opened');\n    this.wxErrorCount = 0;\n    this.startHeartbeat();\n  }\n\n  onmessage(event) {\n    if (this.onmessage) {\n      this.onmessage(event.data);\n    }\n  }\n\n  onerror(event) {\n    console.error('WebSocket error:', event);\n    this.wxErrorCount++;\n    if (this.wxErrorCount < 3) {\n      setTimeout(() => {\n        this.openWebSocket();\n      }, 1000 * this.wxErrorCount);\n    } else {\n      console.error('Maximum retry attempts exceeded');\n    }\n  }\n\n  onclose(event) {\n    console.log('WebSocket connection closed', event);\n    this.wxErrorCount = 0;\n    this.startHeartbeat();\n  }\n\n  startHeartbeat() {\n    if (this.retryTimer) clearTimeout(this.retryTimer);\n    this.retryTimer = setTimeout(() => {\n      this.openWebSocket();\n    }, 30000);\n  }\n\n  sendMessage(data) {\n    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n      this.websocket.send(data);\n    } else {\n      console.warn('Cannot send message: connection is not open');\n    }\n  }\n\n  closeConnection() {\n    if (this.websocket) {\n      this.websocket.close();\n      this.websocket = null;\n    }\n  }\n}"
  },
  {
    "Task_id": 209,
    "Instruction": "Task Description: Implement a WebSocket-based RPC (Remote Procedure Call) client class in JavaScript that supports establishing connections, sending requests, handling responses, and managing event listeners.\n\nClass Description: The RPCWebSocket class provides a WebSocket client implementation for JSON-RPC 2.0 communication. It handles connection management, request/response patterns, and event-based notifications with automatic reconnection capabilities.\n\nAttributes:\n_namespace: String - The namespace prefix for all RPC methods\n_listeners: Object - Stores registered event listeners as key-value pairs\n_handles: Object - Tracks pending requests and their callbacks\n_socket: WebSocket - The underlying WebSocket connection instance\n\nMethods:\nconstructor(address, encryption, namespace) -> void - Initializes the WebSocket connection with the given address, encryption flag, and namespace prefix\n\nsetAddress(address, encryption) -> void - Sets or resets the WebSocket connection URL with optional encryption (wss/ws)\n\naddListener(method, callback) -> void - Registers a callback function for a specific method name\n\nremoveListener(method) -> void - Removes the listener for a specific method name\n\nrequest(method, params, id, successCallback, errorCallback) -> void - Sends a single JSON-RPC request with the given method, parameters, and callbacks\n\nbatchRequest(requests, successCallback, errorCallback) -> void - Sends multiple JSON-RPC requests in a batch with shared callbacks\n\n_formatData(method, params, id) -> Object - Formats the data into JSON-RPC 2.0 compliant structure\n\n_send(data) -> void - Internal method for sending data through the WebSocket connection with state handling\n\n_onerror(error, handles) -> void - Internal error handler that triggers all pending error callbacks\n\n_onmessage(message, handles, listeners) -> void - Internal message handler that processes responses and notifications",
    "Canonical_solution": "class RPCWebSocket {\n  constructor (address, encryption = false, namespace) {\n    this.namespace = namespace\n    this._listeners = {}\n    this.setAddress(address, encryption)\n  }\n\n  setAddress (address, encryption) {\n    this._handles = {}\n    if (typeof WebSocket !== 'function') throw Error('This client does not support WebSocket.')\n    else {\n      let url = (encryption ? 'wss://' : 'ws://') + address\n      try {\n        this._socket = new WebSocket(url)\n        let that = this\n        this._socket.onclose = event => {\n          setTimeout(() => {\n            if (that._socket.readyState > 1) that.setAddress(address, encryption)\n          }, 10000)\n        }\n        this._socket.onerror = error => that._onerror(error, that._handles)\n        this._socket.onmessage = message => that._onmessage(message, that._handles, that._listeners)\n      } catch (error) {\n        console.error(error.message)\n      }\n    }\n  }\n\n  addListener (method, callback) {\n    if (typeof callback === 'function') this._listeners[this.namespace + '.' + method] = callback\n  }\n\n  removeListener (method) {\n    delete this._listeners[this.namespace + '.' + method]\n  }\n\n  request (method, params = [], id, successCallback, errorCallback) {\n    this._handles[id] = {\n      success: successCallback,\n      error: errorCallback\n    }\n    let data = this._formatData(method, params, id)\n    this._send(data)\n  }\n\n  batchRequest (requests, successCallback, errorCallback) {\n    if (requests.constructor !== Array) requests = [requests]\n    requests.forEach(request => {\n      this._handles[request.id] = {\n        success: successCallback,\n        error: errorCallback\n      }\n    })\n    let data = requests.map(request => this._formatData(request.method, request.params, request.id))\n    this._send(data)\n  }\n\n  _formatData (method, params = [], id = '') {\n    return {\n      jsonrpc: '2.0',\n      id: id,\n      method: this.namespace + '.' + method,\n      params: params.constructor === Array ? params : [params]\n    }\n  }\n\n  _send (data) {\n    let that = this\n    let socket = this._socket\n    if (socket.readyState > 1) socket.onerror(Error('WebSocket is in state ' + socket.readyState + '.'))\n    else if (socket.readyState === 0) setTimeout(() => that._send(data), 1000)\n    else socket.send(JSON.stringify(data))\n  }\n\n  _onerror (error, handles) {\n    if (error.hasOwnProperty('message')) console.error(error.message)\n    Object.keys(handles).forEach(id => {\n      if (typeof handles[id].error === 'function') handles[id].error(error)\n      delete handles[id]\n    })\n  }\n\n  _onmessage (message, handles, listeners) {\n    let data = JSON.parse(message.data)\n    if (data.constructor === Array) {\n      data = data.reduce((last, cur) => {\n        if (last.hasOwnProperty(cur.id)) last[cur.id].push(cur)\n        else last[cur.id] = [cur]\n        return last\n      }, {})\n      for (let id in data) {\n        if (handles.hasOwnProperty(id)) {\n          if (typeof handles[id].success === 'function') handles[id].success(data[id])\n          delete handles[id]\n        }\n      }\n    } else if (data.hasOwnProperty('id')) {\n      if (handles.hasOwnProperty(data.id)) {\n        if (typeof handles[data.id].success === 'function') handles[data.id].success(data)\n        delete handles[data.id]\n      }\n    } else if (data.hasOwnProperty('method')) {\n      if (listeners.hasOwnProperty(data.method)) {\n        if (typeof listeners[data.method] === 'function') listeners[data.method](data)\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class RPCWebSocket {\n  constructor(address, encryption, namespace) {\n    this._namespace = namespace || '';\n    this._listeners = {};\n    this._handles = {};\n    this._socket = new WebSocket(encryption ? 'wss://' + address : 'ws://' + address);\n    this._socket.onopen = () => this._onOpen();\n    this._socket.onmessage = (event) => this._onMessage(event.data);\n    this._socket.onerror = (error) => this._onError(error);\n    this._socket.onclose = (event) => this._onClose(event);\n  }\n\n  setAddress(address, encryption) {\n    this._socket.close();\n    this._socket = new WebSocket(encryption ? 'wss://' + address : 'ws://' + address);\n    this._socket.onopen = () => this._onOpen();\n    this._socket.onmessage = (event) => this._onMessage(event.data);\n    this._socket.onerror = (error) => this._onError(error);\n    this._socket.onclose = (event) => this._onClose(event);\n  }\n\n  addListener(method, callback) {\n    this._listeners[method] = callback;\n  }\n\n  removeListener(method) {\n    delete this._listeners[method];\n  }\n\n  request(method, params, id, successCallback, errorCallback) {\n    const formatted = this._formatData(method, params, id);\n    this._handles[id] = { success: successCallback, error: errorCallback };\n    this._send(JSON.stringify(formatted));\n  }\n\n  batchRequest(requests, successCallback, errorCallback) {\n    const formatted = requests.map(req => this._formatData(req.method, req.params, req.id));\n    this._handles[requests[0].id] = { success: successCallback, error: errorCallback };\n    this._send(JSON.stringify(formatted));\n  }\n\n  _formatData(method, params, id) {\n    return {\n      jsonrpc: '2.0',\n      method: this._namespace + method,\n      params: params || [],\n      id: id\n    };\n  }\n\n  _send(data) {\n    if (this._socket.readyState === this._socket.OPEN) {\n      this._socket.send(data);\n    } else {\n      setTimeout(() => this._send(data), 100);\n    }\n  }\n\n  _onOpen() {\n    console.log('WebSocket connection established');\n  }\n\n  _onMessage(message) {\n    try {\n      const response = JSON.parse(message);\n      if (response.result) {\n        this._onSuccess(response.id, response.result);\n      } else if (response.error) {\n        this._onError(response.id, response.error);\n      } else if (response.id === undefined) {\n        this._onNotification(response.method, response.params);\n      }\n    } catch (e) {\n      console.error('Error parsing message:', e);\n    }\n  }\n\n  _onError(error, handles) {\n    for (const handle of handles) {\n      handle.error(error);\n    }\n  }\n\n  _onSuccess(id, result) {\n    const handle = this._handles[id];\n    if (handle) {\n      handle.success(result);\n    }\n  }\n\n  _onNotification(method, params) {\n    for (const listener of this._listeners[method]) {\n      listener(params);\n    }\n  }\n\n  _onError(error) {\n    console.error('WebSocket error:', error);\n    this._reconnect();\n  }\n\n  _onClose(event) {\n    if (event.code === 1006 || event.code === 1011) {\n      this._reconnect();\n    }\n  }\n\n  _reconnect() {\n    setTimeout(() => {\n      this._socket.close();\n      this._socket = new WebSocket(this._socket.url);\n      this._socket.onopen = () => this._onOpen();\n      this._socket.onmessage = (event) => this._onMessage(event.data);\n      this._socket.onerror = (error) => this._onError(error);\n      this._socket.onclose = (event) => this._onClose(event);\n    }, 5000);\n  }\n}"
  },
  {
    "Task_id": 210,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that handles WebSocket connections, message processing, and connection lifecycle events. The class should support sending and receiving JSON messages, handling different commands, and managing connection states.\n\nClass Description: The `Client` class represents a WebSocket client that connects to a server, processes incoming messages, and sends commands. It handles connection events, message parsing, and provides methods for common operations like sending hello messages and triggering reloads.\n\nAttributes:\n- `ws`: [WebSocket] - The WebSocket connection instance.\n- `options`: [Object] - Configuration options for the client.\n- `id`: [String] - Unique identifier for the client instance.\n- `plugins`: [Array] - List of plugins received from the server.\n- `url`: [String] - URL received from the server.\n\nMethods:\n- `constructor(req, socket, head, options)` -> [Client] - Initializes a new WebSocket client instance with the given request, socket, head, and options.\n- `message(event)` -> [void] - Handles incoming WebSocket messages, parses them, and routes to appropriate command handlers.\n- `close(event)` -> [void] - Closes the WebSocket connection and emits an 'end' event.\n- `hello()` -> [void] - Sends a 'hello' command to the server with supported protocols and server name.\n- `info(data)` -> [void] - Processes 'info' command data from the server, storing plugins and URL.\n- `reload(files)` -> [void] - Sends 'reload' commands for each file in the provided list, with live reload options.\n- `_data(event)` -> [Object] - Parses incoming message data from JSON string to object.\n- `send(data)` -> [void] - Sends data as a JSON string over the WebSocket connection.\n- `uniqueId(prefix)` -> [String] - Generates a unique ID with an optional prefix.",
    "Canonical_solution": "var WebSocket = require('faye-websocket');\n\nclass Client {\n  constructor(req, socket, head, options) {\n    options = this.options = options || {};\n    this.ws = new WebSocket(req, socket, head);\n    this.ws.onmessage = this.message.bind(this);\n    this.ws.onclose = this.close.bind(this);\n    this.id = this.uniqueId('ws');\n  }\n\n  message(event) {\n    var data = this.data(event);\n    if(this[data.command]) return this[data.command](data);\n  }\n\n  close(event) {\n    if(this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.emit('end', event);\n  }\n\n  hello() {\n    this.send({\n      command: 'hello',\n      protocols: [\n        'http://livereload.com/protocols/official-7'\n      ],\n      serverName: 'tiny-lr'\n    });\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(function(file) {\n      this.send({\n        command: 'reload',\n        path: file,\n        liveCss: this.options.liveCss !== false,\n        liveJs: this.options.liveJs !== false,\n        liveImg: this.options.liveImg !== false\n      });\n    }, this);\n  }\n\n  _data(event) {\n    var data = {};\n    try {\n      data = JSON.parse(event.data);\n    } catch (e) {}\n    return data;\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  }\n}\n\nvar idCounter = 0;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class Client {\n  constructor(req, socket, head, options) {\n    this.ws = new WebSocket(socket);\n    this.options = options;\n    this.id = uniqueId('client');\n    this.plugins = [];\n    this.url = '';\n    this.ws.onmessage = (event) => this.message(event);\n    this.ws.onclose = (event) => this.close(event);\n  }\n\n  message(event) {\n    const data = this._data(event);\n    if (data && data.command) {\n      switch (data.command) {\n        case 'info':\n          this.info(data);\n          break;\n        // Add more command handlers as needed\n      }\n    }\n  }\n\n  close(event) {\n    this.emit('end');\n  }\n\n  hello() {\n    this.send({ command: 'hello', protocols: ['json'], server: 'my-server' });\n  }\n\n  info(data) {\n    this.plugins = data.plugins || [];\n    this.url = data.url || '';\n  }\n\n  reload(files) {\n    files.forEach(file => this.send({ command: 'reload', file, live: true }));\n  }\n\n  _data(event) {\n    try {\n      return JSON.parse(event.data);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  send(data) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(data));\n    }\n  }\n\n  uniqueId(prefix) {\n    return prefix ? `${prefix}-${Math.random().toString(36).substr(2, 9)}` : Math.random().toString(36).substr(2, 9);\n  }\n}"
  },
  {
    "Task_id": 211,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with support for reconnection, message handling, and connection lifecycle events.\n\nClass Description: The `N` class represents a WebSocket client that connects to a specified URL, handles incoming messages, manages connection state, and provides automatic reconnection capabilities. It supports event callbacks for connection establishment and completion, and can pipe received data to a destination.\n\nAttributes:\n- url: [String] - The WebSocket server URL to connect to\n- options: [Object] - Configuration options including protocols, reconnect interval, and callbacks\n- socket: [WebSocket|null] - The active WebSocket connection instance\n- streaming: [Boolean] - Flag indicating if the connection is active\n- callbacks: [Object] - Collection of event callback arrays (connect, data)\n- destination: [Object|null] - Target to pipe received data to\n- reconnectInterval: [Number] - Time in seconds between reconnection attempts\n- shouldAttemptReconnect: [Boolean] - Flag controlling reconnection behavior\n- completed: [Boolean] - Connection completion state\n- established: [Boolean] - Connection establishment state\n- progress: [Number] - Connection progress indicator\n- reconnectTimeoutId: [Number] - Timer ID for reconnection attempts\n- onEstablishedCallback: [Function|null] - Called when connection is established\n- onCompletedCallback: [Function|null] - Called when connection completes\n- hookOnEstablished: [Function|null] - Optional hook for connection establishment\n\nMethods:\n- constructor(url, options) -> [N] - Initializes the WebSocket client with URL and options\n- connect(destination) -> [void] - Sets the destination for received data\n- destroy() -> [void] - Cleans up resources and closes the connection\n- start() -> [void] - Initiates the WebSocket connection with optional protocols\n- resume() -> [void] - Placeholder for resuming functionality (currently empty)\n- onOpen() -> [void] - Handles WebSocket open event, updates progress\n- onClose() -> [void] - Handles WebSocket close/error events, manages reconnection\n- onMessage(message) -> [void] - Handles incoming messages, triggers establishment callbacks",
    "Canonical_solution": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = true;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = void 0 !== options.reconnectInterval ? options.reconnectInterval : 5;\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = options.onSourceEstablished;\n    this.onCompletedCallback = options.onSourceCompleted;\n    options.hookOnEstablished && (this.hookOnEstablished = options.hookOnEstablished);\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.shouldAttemptReconnect = false;\n    this.socket.close();\n  }\n\n  start() {\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.progress = 0;\n    this.established = false;\n    this.options.protocols\n      ? this.socket = new WebSocket(this.url, this.options.protocols)\n      : this.socket = new WebSocket(this.url);\n    this.socket.binaryType = \"arraybuffer\";\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n  }\n\n  onClose() {\n    const reconnect = () => {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, 1000 * this.reconnectInterval);\n    };\n    this.shouldAttemptReconnect && reconnect();\n  }\n\n  onMessage(message) {\n    const wasEstablished = this.established;\n    this.established = true;\n    wasEstablished || this.hookOnEstablished?.();\n    wasEstablished || this.onEstablishedCallback?.(this);\n    this.destination?.write(message.data);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options || {};\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      connect: [],\n      data: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options?.reconnectInterval || 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n    this.start();\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.streaming = false;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    clearTimeout(this.reconnectTimeoutId);\n  }\n\n  start() {\n    if (!this.socket || this.socket.readyState === WebSocket.CLOSED || this.socket.readyState === WebSocket.CLOSING) {\n      this.reconnect();\n    }\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.established = true;\n    this.progress = 100;\n    if (this.onEstablishedCallback) this.onEstablishedCallback();\n    if (this.hookOnEstablished) this.hookOnEstablished();\n  }\n\n  onClose(event) {\n    if (event.reason === 'WebSocket connection closed') {\n      this.completed = true;\n      if (this.onCompletedCallback) this.onCompletedCallback();\n      if (this.shouldAttemptReconnect) {\n        this.reconnectTimeoutId = setTimeout(() => {\n          this.reconnect();\n        }, this.reconnectInterval * 1000);\n      }\n    } else {\n      this.destroy();\n    }\n  }\n\n  onMessage(message) {\n    if (this.destination) {\n      this.destination.write(message.data);\n    }\n    this.callbacks.data.forEach(callback => callback(message));\n  }\n\n  reconnect() {\n    this.socket = new WebSocket(this.url, this.options.protocols);\n    this.socket.onopen = () => this.onOpen();\n    this.socket.onclose = (event) => this.onClose(event);\n    this.socket.onmessage = (message) => this.onMessage(message);\n    this.socket.onerror = (error) => this.onClose(error);\n  }\n}"
  },
  {
    "Task_id": 212,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes a connection to a WebSocket server, handles communication events (open, message, close, error), and provides methods to send messages and close the connection. The class should integrate with a listener interface to notify about connection events and received messages.\n\nClass Description: The WebSocketClient class is an implementation of the AiClient interface that manages WebSocket connections in a browser environment. It handles the WebSocket lifecycle, including connection establishment, message exchange, and error handling, while notifying a listener about these events.\n\nAttributes:\n- isStop: boolean - Indicates whether the connection has been stopped.\n- url: string - The WebSocket server URL to connect to.\n- webSocket: WebSocket | undefined - The WebSocket instance.\n- isOpen: boolean - Indicates whether the WebSocket connection is open.\n- payload: string | undefined - The initial message payload to send after connection.\n- listener: AiClientListener - The listener interface for event notifications.\n\nMethods:\n- constructor(url: string, listener: AiClientListener) -> void - Initializes the WebSocketClient with the server URL and a listener.\n- start(payload: string) -> void - Starts the WebSocket connection and sets up event handlers. Sends the initial payload once connected.\n- stop() -> void - Closes the WebSocket connection and notifies the listener.\n- send(message: string) -> void - Sends a message through the WebSocket if the connection is open.\n- onOpen(_: Event) -> void - Handles the WebSocket 'open' event, sets the connection state, and sends the initial payload.\n- onMessage(event: MessageEvent) -> void - Handles incoming messages and notifies the listener.\n- onClose(_: CloseEvent) -> void - Handles the WebSocket 'close' event, updates the connection state, and notifies the listener.\n- onError(_: Event) -> void - Handles WebSocket errors, updates the connection state, and notifies the listener.",
    "Canonical_solution": "import {AiClientListener} from \"../../AiClientListener.ts\";\nimport {AiClient} from \"../../AiClient.ts\";\n\nexport class WebSocketClient implements AiClient {\n    isStop: boolean = false\n    url: string;\n    webSocket?: WebSocket;\n    isOpen: boolean = false;\n    payload?: string;\n    listener: AiClientListener;\n\n    constructor(url: string, listener: AiClientListener) {\n        this.url = url;\n        this.listener = listener;\n    }\n\n    start(payload: string) {\n        this.listener.onStart(this);\n        this.payload = payload;\n        this.webSocket = new WebSocket(this.url);\n        this.webSocket.onopen = (e) => this.onOpen(e)\n        this.webSocket.onmessage = (e) => this.onMessage(e)\n        this.webSocket.onclose = (e) => this.onClose(e)\n        this.webSocket.onerror = (e) => this.onError(e)\n    }\n\n    stop() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = void 0;\n\n            if (!this.isStop) {\n                this.listener.onStop();\n                this.isStop = true;\n            }\n        }\n    }\n\n    send(message: string) {\n        if (this.webSocket && this.isOpen) {\n            this.webSocket.send(message);\n        }\n    }\n\n    protected onOpen(_: Event) {\n        this.isOpen = true;\n        this.send(this.payload!);\n    }\n\n    protected onMessage(event: MessageEvent) {\n        this.listener.onMessage(event.data)\n    }\n\n    protected onClose(_: CloseEvent) {\n        this.isOpen = false;\n        if (!this.isStop) {\n            this.listener.onStop();\n            this.isStop = true;\n        }\n    }\n\n    protected onError(_: Event) {\n        this.isOpen = false;\n        if (!this.isStop) {\n            this.listener.onStop();\n            this.isStop = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class WebSocketClient {\n  isStop: boolean;\n  url: string;\n  webSocket: WebSocket | undefined;\n  isOpen: boolean;\n  payload: string | undefined;\n  listener: AiClientListener;\n\n  constructor(url: string, listener: AiClientListener) {\n    this.isStop = false;\n    this.url = url;\n    this.webSocket = undefined;\n    this.isOpen = false;\n    this.payload = undefined;\n    this.listener = listener;\n  }\n\n  start(payload: string): void {\n    this.payload = payload;\n    this.webSocket = new WebSocket(this.url);\n    this.webSocket.onopen = this.onOpen.bind(this);\n    this.webSocket.onmessage = this.onMessage.bind(this);\n    this.webSocket.onclose = this.onClose.bind(this);\n    this.webSocket.onerror = this.onError.bind(this);\n  }\n\n  stop(): void {\n    if (this.webSocket) {\n      this.webSocket.close();\n    }\n    this.isStop = true;\n    this.listener.onStop();\n  }\n\n  send(message: string): void {\n    if (this.webSocket && this.isOpen) {\n      this.webSocket.send(message);\n    }\n  }\n\n  onOpen(_: Event): void {\n    this.isOpen = true;\n    this.listener.onOpen();\n    if (this.payload) {\n      this.send(this.payload);\n    }\n  }\n\n  onMessage(event: MessageEvent): void {\n    this.listener.onMessage(event.data);\n  }\n\n  onClose(_: CloseEvent): void {\n    this.isOpen = false;\n    this.listener.onClose();\n  }\n\n  onError(_: Event): void {\n    this.isOpen = false;\n    this.listener.onError();\n  }\n}"
  },
  {
    "Task_id": 213,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that connects to a server for real-time speech-to-text (STT) transcription, handles incoming messages, and updates the UI accordingly.\n\nFunction Description: The function `connectToDataSocket` establishes a WebSocket connection to a specified URL, sets up event handlers for connection status, incoming messages, errors, and connection closure. It processes real-time transcription data and full sentence updates, displaying them in designated HTML elements while handling errors gracefully.\n\nInput: None (The function uses the global variable `dataURL` for WebSocket endpoint and assumes predefined HTML elements: `statusDiv`, `transcriptionDiv`, `fullTextDiv`, `transcriptionContainer`, `fullTextContainer`)\n\nOutput: None (The function's effects are side-effects: updates UI elements and logs to console)",
    "Canonical_solution": "function connectToDataSocket() {\n    dataSocket = new WebSocket(dataURL);\n\n    dataSocket.onopen = () => {\n        statusDiv.textContent = \"Connected to STT server.\";\n        console.log(\"Connected to data WebSocket.\");\n    };\n\n    dataSocket.onmessage = (event) => {\n        try {\n            const message = JSON.parse(event.data);\n\n            if (message.type === \"realtime\") {\n                let words = message.text.split(\" \");\n                let lastWord = words.pop();\n                transcriptionDiv.innerHTML = `${words.join(\" \")} <span class=\"last-word\">${lastWord}</span>`;\n\n                const transcriptionContainer = document.getElementById(\"transcriptionContainer\");\n                transcriptionContainer.scrollTop = transcriptionContainer.scrollHeight;\n            } else if (message.type === \"fullSentence\") {\n                fullTextDiv.innerHTML += message.text + \" \";\n                transcriptionDiv.innerHTML = message.text;\n\n                const fullTextContainer = document.getElementById(\"fullTextContainer\");\n                fullTextContainer.scrollTop = fullTextContainer.scrollHeight;\n            }\n        } catch (e) {\n            console.error(\"Error parsing message:\", e);\n        }\n    };\n\n    dataSocket.onclose = () => {\n        statusDiv.textContent = \"Disconnected from STT server.\";\n    };\n\n    dataSocket.onerror = (error) => {\n        console.error(\"WebSocket error:\", error);\n        statusDiv.textContent = \"Error connecting to the STT server.\";\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function connectToDataSocket() {\n  const socket = new WebSocket(dataURL);\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established.');\n    statusDiv.textContent = 'Connected';\n  };\n\n  socket.onmessage = function(event) {\n    try {\n      const data = JSON.parse(event.data);\n      if (data.type === 'transcription') {\n        transcriptionDiv.textContent = data.text;\n        transcriptionContainer.scrollTop = transcriptionContainer.scrollHeight;\n      } else if (data.type === 'full_text') {\n        fullTextDiv.textContent = data.text;\n        fullTextContainer.scrollTop = fullTextContainer.scrollHeight;\n      }\n    } catch (error) {\n      console.error('Error parsing message:', error);\n    }\n  };\n\n  socket.onerror = function(error) {\n    console.error('WebSocket error:', error);\n    statusDiv.textContent = 'Error';\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed.', event);\n    statusDiv.textContent = 'Disconnected';\n  };\n}"
  },
  {
    "Task_id": 214,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript to establish a connection with a server, send a command, and handle connection events.\n\nFunction Description: The code establishes a WebSocket connection to a specified URL with a custom protocol. It sends a \"REBOOT\" command upon successful connection and provides empty handlers for incoming messages and connection closure. Error handling is included for connection issues.\n\nInput: None (The WebSocket URL is obtained internally via get_appropriate_ws_url() function)\n\nOutput: None (The function establishes a WebSocket connection and sends a command, but doesn't return any value)\n\nKey Steps:\n1. Initialize WebSocket connection with appropriate browser API (MozWebSocket or standard WebSocket)\n2. Set up event handlers for connection opening, message reception, and connection closing\n3. Implement error handling for connection attempts\n4. Send \"REBOOT\" command upon successful connection\n5. Provide empty handlers for message reception and connection closing events",
    "Canonical_solution": "function init_command() {\n    socket_command.send(\"REBOOT\\n\");\n}\n\nvar socket_command;\n\nif (typeof MozWebSocket != \"undefined\") {\n    socket_command = new MozWebSocket(get_appropriate_ws_url(), \"yi-hack-v3_command\");\n} else {\n    socket_command = new WebSocket(get_appropriate_ws_url(), \"yi-hack-v3_command\");\n}\n\ntry {\n    socket_command.onopen = function() {\n        init_command();\n    }\n\n    socket_command.onmessage = function got_packet(msg) {\n    }\n\n    socket_command.onclose = function(){\n    }\n} catch(exception) {\n    alert('<p>Error' + exception);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "new WebSocket(get_appropriate_ws_url() || 'ws://example.com/socket').onopen = function() { this.send('REBOOT'); }.onmessage = function() {}; onclose = function() {}; onerror = function() { console.error('WebSocket error'); };"
  },
  {
    "Task_id": 215,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, handles incoming messages, errors, and sends messages to the server.\n\nFunction Description: The WebSocket client will initialize a connection to a specified WebSocket server URI, define event handlers for connection opening, incoming messages, and errors, and provide a function to send messages to the server.\n\nInput:\n- wsUri: [String] - The WebSocket server URI to connect to.\n- username: [String] - The username of the client sending messages.\n- textField: [HTMLInputElement] - The input field containing the message to send.\n- userField: [HTMLElement] - The HTML element to display the list of connected users.\n- chatlogField: [HTMLElement] - The HTML element to display the chat log.\n\nOutput:\n- None (The functions handle events and update the DOM directly).\n\nMethods:\n- send_message(): [Function]() -> [void] - Sends a message to the WebSocket server in the format \"username: message\".\n- onMessage(): [Function](evt: [MessageEvent]) -> [void] - Handles incoming messages, updating the user list or chat log based on the message content.\n- onError(): [Function](evt: [ErrorEvent]) -> [void] - Logs errors to the console and displays them in the DOM.\n- onOpen(): [Function](evt: [Event]) -> [void] - Handles the WebSocket connection opening event (implementation not shown in reference code).",
    "Canonical_solution": "function send_message() {\n    websocket.send(username + \": \" + textField.value);\n}\n\nfunction onMessage(evt) {\n    console.log(\"onMessage: \" + evt.data);\n    if (evt.data.indexOf(\"joined\") != -1) {\n        userField.innerHTML += evt.data.substring(0, evt.data.indexOf(\" joined\")) + \"\\n\";\n    } else {\n        chatlogField.innerHTML += evt.data + \"\\n\";\n    }\n}\n\nfunction onError(evt) {\n    writeToScreen('<span style=\"color: red;\">ERROR:</span> ' + evt.data);\n}\n\nvar websocket = new WebSocket(wsUri);\nwebsocket.onopen = function(evt) { onOpen(evt) };\nwebsocket.onmessage = function(evt) { onMessage(evt) };\nwebsocket.onerror = function(evt) { onError(evt) };",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "new WebSocket(wsUri).onopen = function(evt) {\n  onOpen(evt);\n}.onmessage = function(evt) {\n  onMessage(evt);\n}.onerror = function(evt) {\n  onError(evt);\n};\n\nfunction send_message() {\n  const message = textField.value;\n  if (message) {\n    const username = username;\n    const formattedMessage = `${username}: ${message}`;\n    ws.send(formattedMessage);\n    textField.value = '';\n  }\n}\n\nfunction onMessage(evt) {\n  const data = evt.data;\n  if (data.startsWith('user_list:')) {\n    const userList = data.substring(9);\n    userField.innerHTML = userList;\n  } else if (data.startsWith('chat_log:')) {\n    const chatLog = data.substring(9);\n    chatlogField.innerHTML = chatLog;\n  }\n}\n\nfunction onError(evt) {\n  console.error('WebSocket error:', evt);\n  const errorElement = document.createElement('div');\n  errorElement.textContent = 'WebSocket error: ' + evt;\n  document.body.appendChild(errorElement);\n}"
  },
  {
    "Task_id": 216,
    "Instruction": "Task Description: Create a WebSocket client function in JavaScript that establishes a connection to a server, handles incoming messages, and manages connection events.\n\nFunction Description: The `connectServer` function initializes a WebSocket connection to a specified port on localhost. It sets up event handlers for connection opening, incoming messages, and connection closing. The function processes different types of messages (config, checkResult, moduleStart, moduleEnd, mobileAppInfo) and triggers appropriate actions including notifications and event emissions.\n\nInput:\n- port: Number - The port number to connect to on localhost (127.0.0.1)\n\nOutput: None (The function establishes a WebSocket connection and sets up event handlers but doesn't return any value)\n\nNote: The function maintains connection state through the global variable `wsSocket` and interacts with other parts of the system through the `GlobalEvents` emitter and Chrome notifications API.",
    "Canonical_solution": "function connectServer(port) {\n    if (!wsSocket) {\n        wsSocket = new WebSocket('ws://127.0.0.1:' + port, \"protocolOne\");\n        wsSocket.onopen = function(event) {\n            console.log('ws connected!');\n        }\n        wsSocket.onmessage = function(message) {\n            message = message.data;\n            try {\n                message = JSON.parse(message);\n            } catch (e) {}\n            var type = message.type;\n            var data = message.data;\n            switch (type) {\n                case 'config':\n                    recordConfig = data;\n                    i18n = recordConfig.i18n;\n                    GlobalEvents.emit('updateConfig', recordConfig);\n                    break;\n                case 'checkResult':\n                    chrome.notifications.create({\n                        type: 'basic',\n                        iconUrl: 'img/' + (data.success ? 'success' : 'fail') + '.png',\n                        title: data.success ? __('exec_succeed') : __('exec_failed'),\n                        message: data.title\n                    });\n                    GlobalEvents.emit('checkResult', data);\n                    break;\n                case 'moduleStart':\n                    isModuleLoading = true;\n                    recordConfig.isModuleLoading = true;\n                    chrome.notifications.create({\n                        type: 'basic',\n                        iconUrl: 'img/warn.png',\n                        title: __('module_start_title'),\n                        message: __('module_start_message', data.file)\n                    });\n                    GlobalEvents.emit('moduleStart');\n                    break;\n                case 'moduleEnd':\n                    isModuleLoading = false;\n                    recordConfig.isModuleLoading = false;\n                    chrome.notifications.create({\n                        type: 'basic',\n                        iconUrl: 'img/' + (data.success ? 'success' : 'fail') + '.png',\n                        title: __('module_end_title'),\n                        message: __('module_end_message', data.success ? __('succeed') : __('failed'), data.file)\n                    });\n                    GlobalEvents.emit('moduleEnd');\n                    break;\n                case 'mobileAppInfo':\n                    GlobalEvents.emit('mobileAppInfo', data);\n                    break;\n            }\n        }\n        wsSocket.onclose = function() {\n            wsSocket = null;\n            console.log('ws closed!');\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function connectServer(port) {\n  const wsSocket = new WebSocket(`ws://127.0.0.1:${port}`);\n  global.wsSocket = wsSocket;\n\n  wsSocket.onopen = function(event) {\n    GlobalEvents.emit('connectionOpen', { port: port });\n  };\n\n  wsSocket.onmessage = function(event) {\n    const message = event.data;\n    if (message.startsWith('config:')) {\n      const config = JSON.parse(message.substring(6));\n      GlobalEvents.emit('configReceived', config);\n    } else if (message.startsWith('checkResult:')) {\n      const result = JSON.parse(message.substring(12));\n      GlobalEvents.emit('checkResult', result);\n    } else if (message.startsWith('moduleStart:')) {\n      const module = JSON.parse(message.substring(11));\n      GlobalEvents.emit('moduleStart', module);\n    } else if (message.startsWith('moduleEnd:')) {\n      const module = JSON.parse(message.substring(10));\n      GlobalEvents.emit('moduleEnd', module);\n    } else if (message.startsWith('mobileAppInfo:')) {\n      const info = JSON.parse(message.substring(14));\n      GlobalEvents.emit('mobileAppInfo', info);\n    }\n  };\n\n  wsSocket.onclose = function(event) {\n    GlobalEvents.emit('connectionClose', { code: event.code, reason: event.reason });\n  };\n\n  wsSocket.onerror = function(error) {\n    console.error('WebSocket error:', error);\n    GlobalEvents.emit('connectionError', error);\n  };\n}"
  },
  {
    "Task_id": 217,
    "Instruction": "Task Description: Implement a WebSocket client class that manages WebSocket connections with automatic reconnection capabilities, message handling, and connection state management.\n\nClass Description: The WebSocketClient class provides a wrapper around the browser's native WebSocket API with additional features for connection management. It handles connection establishment, automatic reconnection on failure, message processing, and clean disconnection.\n\nAttributes:\n- DISCONNECT_TIMEOUT: [Number] - Timeout duration (in milliseconds) before disconnecting\n- RECONNECT_TIMEOUT: [Number] - Timeout duration (in milliseconds) before attempting to reconnect\n- wsState: [Number] - Current state of the WebSocket connection (CLOSED, CONNECTING, OPEN)\n- ws: [WebSocket|null] - The active WebSocket connection instance\n- wsURL: [String] - URL for the WebSocket server connection\n- connectTS: [Number] - Timestamp of the last connection attempt\n- disconnectTID: [Number] - Timeout ID for disconnection\n- reconnectTID: [Number] - Timeout ID for reconnection\n- onmessage: [Object|null] - Callback functions for incoming messages\n\nMethods:\n- onconnect() -> [Boolean] - Initiates a new WebSocket connection. Returns true if connection attempt was made.\n- ondisconnect() -> [void] - Closes the current WebSocket connection and cleans up resources.\n- onopen([Event] e) -> [void] - Handles WebSocket connection open event and sets up message listeners.\n- onclose() -> [Boolean] - Handles WebSocket connection close event and schedules reconnection. Returns true if reconnection was scheduled.\n- send([Object] e) -> [void] - Sends a JSON-serialized message through the WebSocket connection.\n- reconnect() -> [void] - Forces reconnection by closing existing connection (if any) and initiating a new one.",
    "Canonical_solution": "class b extends HTMLElement {\n  constructor() {\n    super();\n    this.DISCONNECT_TIMEOUT = 5e3;\n    this.RECONNECT_TIMEOUT = 15e3;\n    this.wsState = WebSocket.CLOSED;\n    this.ws = null;\n    this.wsURL = \"\";\n    this.connectTS = 0;\n    this.disconnectTID = 0;\n    this.reconnectTID = 0;\n    this.onmessage = null;\n  }\n\n  onconnect() {\n    if (!this.isConnected || !this.wsURL || this.ws || this.pc) return false;\n    this.wsState = WebSocket.CONNECTING;\n    this.connectTS = Date.now();\n    this.ws = new WebSocket(this.wsURL);\n    this.ws.binaryType = \"arraybuffer\";\n    this.ws.addEventListener(\"open\", (e) => this.onopen(e));\n    this.ws.addEventListener(\"close\", (e) => this.onclose(e));\n    return true;\n  }\n\n  ondisconnect() {\n    this.wsState = WebSocket.CLOSED;\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.disconnectTID = 0;\n  }\n\n  onopen() {\n    this.wsState = WebSocket.OPEN;\n    this.ws.addEventListener(\"message\", (e) => {\n      if (\"string\" == typeof e.data) {\n        const t = JSON.parse(e.data);\n        for (const e in this.onmessage) this.onmessage[e](t);\n      }\n    });\n    this.onmessage = {};\n  }\n\n  onclose() {\n    if (this.wsState === WebSocket.CLOSED) return false;\n    this.wsState = WebSocket.CONNECTING;\n    this.ws = null;\n    const e = Math.max(this.RECONNECT_TIMEOUT - (Date.now() - this.connectTS), 0);\n    this.reconnectTID = setTimeout(() => {\n      this.reconnectTID = 0;\n      this.onconnect();\n    }, e);\n    return true;\n  }\n\n  send(e) {\n    this.ws && this.ws.send(JSON.stringify(e));\n  }\n\n  reconnect() {\n    if (this.wsState !== WebSocket.CLOSED) {\n      this.ws?.addEventListener(\"close\", () => this.onconnect());\n      this.ondisconnect();\n    } else {\n      this.ondisconnect();\n      this.onconnect();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class WebSocketClient {\n  constructor(url) {\n    this.DISCONNECT_TIMEOUT = 5000;\n    this.RECONNECT_TIMEOUT = 3000;\n    this.wsState = 0; // 0: CLOSED, 1: CONNECTING, 2: OPEN\n    this.ws = null;\n    this.wsURL = url;\n    this.connectTS = 0;\n    this.disconnectTID = 0;\n    this.reconnectTID = 0;\n    this.onmessage = {};\n  }\n\n  onconnect() {\n    if (this.ws) return true;\n    this.ws = new WebSocket(this.wsURL);\n    this.ws.onopen = () => this.onopen();\n    this.ws.onmessage = (event) => this.onmessage.handle(event.data);\n    this.ws.onclose = () => this.onclose();\n    this.ws.onerror = (error) => console.error('WebSocket error:', error);\n    this.connectTS = Date.now();\n    return true;\n  }\n\n  ondisconnect() {\n    if (!this.ws) return;\n    clearTimeout(this.disconnectTID);\n    this.ws.close();\n    this.ws = null;\n    this.wsState = 0;\n  }\n\n  onopen(e) {\n    this.wsState = 2;\n    this.onmessage.handle = (data) => {\n      if (this.onmessage.message) this.onmessage.message(data);\n      if (this.onmessage.text) this.onmessage.text(data);\n    };\n  }\n\n  onclose() {\n    this.wsState = 0;\n    this.disconnectTID = setTimeout(() => {\n      this.ondisconnect();\n    }, this.DISCONNECT_TIMEOUT);\n    this.reconnectTID = setTimeout(() => {\n      this.onconnect();\n    }, this.RECONNECT_TIMEOUT);\n    return true;\n  }\n\n  send(data) {\n    if (this.ws && this.ws.readyState === this.ws.OPEN) {\n      this.ws.send(JSON.stringify(data));\n    }\n  }\n\n  reconnect() {\n    this.ondisconnect();\n    this.onconnect();\n  }\n}"
  },
  {
    "Task_id": 218,
    "Instruction": "Task Description: Create a WebSocket client in JavaScript that automatically reconnects to a server upon connection loss and triggers a page reload when receiving a message from the server.\n\nFunction Description: The function establishes a WebSocket connection to a specified URL. It handles connection closure by attempting to reconnect after a delay (2 seconds) and automatically reloads the page when a message is received from the server. This is particularly useful for development environments where live-reloading of web pages is desired.\n\nInput: \n- a [String] - The WebSocket server URL to connect to (e.g., \"ws://localhost:12450/reload\")\n\nOutput: None (This function establishes a persistent connection and handles events asynchronously)",
    "Canonical_solution": "function b(a) {\n    var c = new WebSocket(a);\n    c.onclose = function() {\n        setTimeout(function() {\n            b(a)\n        }, 2E3)\n    };\n    c.onmessage = function() {\n        location.reload()\n    }\n}\ntry {\n    if (window.WebSocket) {\n        try {\n            b(\"ws://localhost:12450/reload\")\n        } catch (a) {\n            console.error(a)\n        }\n    } else {\n        console.log(\"Your browser does not support WebSockets.\")\n    }\n} catch (a) {\n    console.error(\"Exception during connecting to Reload:\", a)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function connectWebSocket(url) {\n  const ws = new WebSocket(url);\n\n  ws.onopen = function() {\n    console.log('Connected to WebSocket server');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Received message from server:', event.data);\n    window.location.reload();\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = function(event) {\n    console.log('WebSocket connection closed, attempting to reconnect...');\n    setTimeout(() => {\n      connectWebSocket(url);\n    }, 2000);\n  };\n}\n\nconnectWebSocket(\"ws://localhost:12450/reload\");"
  },
  {
    "Task_id": 219,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a WebSocket server, handles incoming messages, and sends messages from a form input.\n\nFunction Description: The `initializeWebSocket` function sets up a WebSocket client that connects to a specified WebSocket server URL. It manages the WebSocket connection lifecycle, including opening, message handling, and closing events. It also provides a form submission handler for sending messages through the WebSocket connection and displays all messages in a log area.\n\nInput:\n- None (The function uses DOM elements with IDs \"msg\", \"log\", and \"form\" from the HTML document)\n- Implicitly uses a WebSocket server URL (\"ws://{{$}}/ws\")\n\nOutput:\n- None (The function's effects are visible through DOM manipulation and WebSocket communication)\n- Side effects:\n  - Creates a WebSocket connection\n  - Modifies the DOM to display connection status and messages\n  - Handles form submission to send messages through WebSocket\n\nNote: The function assumes the presence of jQuery for DOM manipulation and requires the following HTML elements:\n- An input field with ID \"msg\" for message input\n- A container with ID \"log\" for displaying messages\n- A form with ID \"form\" for message submission",
    "Canonical_solution": "function initializeWebSocket() {\n    var conn;\n    var msg = $(\"#msg\");\n    var log = $(\"#log\");\n\n    function appendLog(msg) {\n        var d = log[0]\n        var doScroll = d.scrollTop == d.scrollHeight - d.clientHeight;\n        msg.appendTo(log)\n        if (doScroll) {\n            d.scrollTop = d.scrollHeight - d.clientHeight;\n        }\n    }\n\n    $(\"#form\").submit(function() {\n        if (!conn) {\n            return false;\n        }\n        if (!msg.val()) {\n            return false;\n        }\n        conn.send(msg.val());\n        msg.val(\"\");\n        return false\n    });\n\n    if (window[\"WebSocket\"]) {\n        conn = new WebSocket(\"ws://{{$}}/ws\");\n        conn.onclose = function(evt) {\n            appendLog($(\"<div><b>Connection closed.</b></div>\"))\n        }\n        conn.onmessage = function(evt) {\n            appendLog($(\"<div/>\").text(evt.data))\n        }\n    } else {\n        appendLog($(\"<div><b>Your browser does not support WebSockets.</b></div>\"))\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function initializeWebSocket() {\n  const wsUrl = \"ws://{{$}}/ws\";\n  const msgInput = $(\"#msg\");\n  const logArea = $(\"#log\");\n  const form = $(\"#form\");\n\n  const socket = new WebSocket(wsUrl);\n\n  socket.onopen = function() {\n    logArea.append(\"<p>Connected to WebSocket server</p>\");\n  };\n\n  socket.onmessage = function(event) {\n    logArea.append(\"<p>Received: \" + event.data + \"</p>\");\n  };\n\n  socket.onclose = function() {\n    logArea.append(\"<p>Disconnected from WebSocket server</p>\");\n  };\n\n  form.submit(function(event) {\n    event.preventDefault();\n    const message = msgInput.val();\n    if (message) {\n      socket.send(message);\n      logArea.append(\"<p>Sent: \" + message + \"</p>\");\n      msgInput.val(\"\");\n    }\n  });\n}"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a client for interacting with Quqi.com's API to perform daily tasks, manage group operations, and track rewards.\n\nClass Description: The QuqiClient class provides methods to interact with Quqi.com's web services including task management, group operations, file uploads, and reward collection. It handles HTTP requests using Axios with proper headers and error handling.\n\nAttributes:\n- headers: [Object] - Contains HTTP headers including cookies and referer for API authentication\n- config: [Object] - Configuration object containing user credentials and settings\n\nMethods:\n- constructor(config) -> [void] - Initializes the client with configuration including authentication cookies\n- _sleep(ms) -> [Promise] - Utility method for delaying execution\n- getDailyTask() -> [Promise<Array|null>] - Retrieves list of incomplete daily tasks\n- getReward(id) -> [Promise<void>] - Claims reward for a specific task ID\n- visit(id) -> [Promise<void>] - Visits a specified group to complete visit tasks\n- getQuqiId() -> [Promise<Object|null>] - Gets group information and handles group joining if needed\n- uploadImg(id) -> [Promise<void>] - Uploads and deletes a dummy image to complete upload tasks\n- executeTasks() -> [Promise<String>] - Executes all available tasks and returns wallet information",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass QuqiClient {\n    constructor(config) {\n        this.headers = {\n            cookie: config.quqi.cookie,\n            referer: \"https://quqi.com/\"\n        };\n    }\n\n    async _sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    async getDailyTask() {\n        try {\n            let res = await axios.get(`https://exp.quqi.com/v1/dailyTask/state?_=1${Date.now()}`, {headers: this.headers});\n            if(res.data.err == 0) {\n                let list = res.data.data.filter(x => x.status != 2);\n                console.log(`\u5269\u4f59${list.length}\u4efb\u52a1\u672a\u5b8c\u6210`);\n                return list;\n            }\n        } catch (err) {\n            console.log(err);\n        }\n        return null;\n    }\n\n    async getReward(id) {\n        try {\n            let res = await axios.get(`https://exp.quqi.com/v1/dailyTask/sendAward/${id}`, {headers: this.headers});\n            console.log(\"\u9886\u53d6\u5956\u52b1\uff1a\" + res.data.msg);\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async visit(id) {\n        try {\n            this.headers[\"User-Agent\"] = \"Mozilla/5.0 (Linux; Android 11; Redmi K30) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36\";\n            let res = await axios.post(`https://quqi.com/api/dir/ls?quqi_id=${id}`, `quqi_id=${id}&tree_id=1&node_id=0`, {headers: this.headers});\n            let res1 = await axios.post(`https://quqi.com/auth/updateVisit?quqi_id=${id}`, `quqi_id=${id}`, {headers: this.headers});\n            console.log(\"\u6d4f\u89c8\u591a\u4eba\u7fa4\u7ec4\uff1a\" + res1.data.msg);\n            await this._sleep(1000);\n            await this.getReward(14);\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async getQuqiId() {\n        try {\n            let res = await axios.get(\"https://group.quqi.com/v1/group/list\", {headers: this.headers});\n            if (res.data.msg == \"success\") {\n                let gplist = res.data.data.filter(x => x.type == 14);\n                let quqid = gplist.length == 0 ? res.data.data[0].quqi_id : gplist[0].quqi_id;\n                let gtype = gplist.length == 0 ? 1 : 2;\n                if (gtype == 1) {\n                    console.log(\"\ud83c\ude1a\ufe0f\u591a\u4eba\u7fa4\u7ec4,\u8bf7\u81ea\u884c\u521b\u5efa\u4e00\u4e2a\u591a\u4eba\u7fa4\u7ec4,\u6216\u8005\u7533\u8bf7\u52a0\u5165https://quqi.avyeld.com/join/company/team.html?jointarget=ed521eef-7ed1-486f-a903-2457ebe5704f\");\n                    let sqres = await axios.post(\"https://group.quqi.com/v1/application\", \"credential=ed521eef-7ed1-486f-a903-2457ebe5704f\", {headers: this.headers});\n                    console.log(\"\u7533\u8bf7\u52a0\u5165\u591a\u4eba\u7fa4\u7ec4\uff1a\" + sqres.data.msg);\n                }\n                return {\n                    qid: quqid,\n                    gtype: gtype\n                };\n            }\n        } catch (err) {\n            console.log(err);\n        }\n        return null;\n    }\n\n    async uploadImg(id) {\n        try {\n            let name = `\u6bcf\u65e5\u7b7e\u5230${Date.now()}`;\n            this.headers[\"User-Agent\"] = \"Mozilla/5.0 (Linux; Android 11; Redmi K30) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36\";\n            let res = await axios.post(`https://quqi.com/api/upload/v1/file/init?quqi_id=${id}`, `file_name=${name}.jpg&is_slice=false&md5=507cf982c5db90bc35f9c6c8179c292f&parent_id=0&quqi_id=${id}&sha=4b4afc24113d86d0afd9be21b6841d9c627cdabf01317e3e760308b05f8bdd81&sign=617db783e0ba01343338ee9887dfdb18&size=331665&tree_id=1`, {headers: this.headers});\n            if (res.data.msg == \"ok\") {\n                console.log(`\u4e0a\u4f20\u56fe\u7247 ${name} \u6210\u529f`);\n                let nid = res.data.data.node_id;\n                if (nid) await axios.post(`https://quqi.com/api/node/batchDel?quqi_id=${id}`, `quqi_id=${id}&tree_id=1&node_ids=${nid}`, {headers: this.headers});\n                await this._sleep(1000);\n                await this.getReward(15);\n            } else {\n                console.log(\"\u4e0a\u4f20\u5931\u8d25\uff1a\" + res.data.msg);\n            }\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async executeTasks() {\n        let quqinfo = \"\";\n        let dailyTaskList = await this.getDailyTask();\n        let qgp = await this.getQuqiId();\n        \n        if (dailyTaskList) {\n            for (let task of dailyTaskList) {\n                console.log(task.task_decreption);\n                if (task.status == 1) {\n                    await this.getReward(task.task_type);\n                } else if (task.task_type == 14 && task.status == 0 && qgp.gtype == 2) {\n                    await this.visit(qgp.qid);\n                } else if (task.task_type == 15 && task.status == 0) {\n                    await this.uploadImg(qgp.qid);\n                }\n            }\n        }\n        \n        let ires = await axios.get(\"https://api.quqi.com/vipWallet/v1/vipAndWallet\", {headers: this.headers});\n        if (ires.data.msg == \"success\") {\n            quqinfo = `\u66f2\u5947\u997c\uff1a${ires.data.data.wallet_info.cookie}  \u66f2\u5947\u8c46\uff1a${ires.data.data.wallet_info.bean}`;\n        } else {\n            quqinfo = ires.data.msg;\n        }\n        console.log(quqinfo);\n        return \"\u3010\u66f2\u5947\u7f51\u76d8\u3011\uff1a\" + quqinfo;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "right_result": "const axios = require('axios');\n\nclass QuqiClient {\n  constructor(config) {\n    this.headers = {\n      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n      'Referer': 'https://www.quqi.com/',\n      'Cookie': config.cookies || ''\n    };\n\n    this.config = {\n      username: config.username,\n      password: config.password,\n      ...config\n    };\n  }\n\n  async _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async getDailyTask() {\n    try {\n      const response = await axios.get('https://www.quqi.com/api/task/list', { headers: this.headers });\n      return response.data.tasks || null;\n    } catch (error) {\n      console.error('Error fetching daily tasks:', error);\n      return null;\n    }\n  }\n\n  async getReward(id) {\n    try {\n      await axios.post(`https://www.quqi.com/api/task/reward/${id}`, {}, { headers: this.headers });\n    } catch (error) {\n      console.error('Error claiming reward:', error);\n    }\n  }\n\n  async visit(id) {\n    try {\n      await axios.get(`https://www.quqi.com/api/group/visit/${id}`, { headers: this.headers });\n    } catch (error) {\n      console.error('Error visiting group:', error);\n    }\n  }\n\n  async getQuqiId() {\n    try {\n      const response = await axios.get('https://www.quqi.com/api/user/info', { headers: this.headers });\n      return response.data.user || null;\n    } catch (error) {\n      console.error('Error getting Quqi ID:', error);\n      return null;\n    }\n  }\n\n  async uploadImg(id) {\n    try {\n      const response = await axios.post(`https://www.quqi.com/api/upload/${id}`, { file: 'dummy.jpg' }, { headers: this.headers });\n      if (response.data.url) {\n        await axios.delete(response.data.url, { headers: this.headers });\n      }\n    } catch (error) {\n      console.error('Error uploading image:', error);\n    }\n  }\n\n  async executeTasks() {\n    try {\n      const tasks = await this.getDailyTask();\n      if (!tasks || tasks.length === 0) {\n        return 'No tasks available';\n      }\n\n      for (const task of tasks) {\n        if (task.type === 'reward') {\n          await this.getReward(task.id);\n        } else if (task.type === 'visit') {\n          await this.visit(task.id);\n        } else if (task.type === 'upload') {\n          await this.uploadImg(task.id);\n        }\n      }\n\n      const walletInfo = await this.getQuqiId();\n      return `Tasks executed successfully. Wallet info: ${JSON.stringify(walletInfo, null, 2)}`;\n    } catch (error) {\n      console.error('Error executing tasks:', error);\n      return 'Error executing tasks';\n    }\n  }\n}"
  },
  {
    "Task_id": 220,
    "Instruction": "Task Description: Implement a WebSocket client initialization function that establishes a connection to a server, handles incoming messages, manages connection events, and provides reconnection logic upon disconnection.\n\nFunction Description: The function initializes a WebSocket connection to the specified URL and sets up event handlers for connection opening, message reception, and connection closing. It also provides a callback mechanism to expose the WebSocket instance to the caller and implements automatic reconnection when the connection is lost.\n\nInput:\n- handleFunctionCall: Function - A callback function to handle incoming messages from the WebSocket server\n- url: string - The WebSocket server URL to connect to\n- cb: Function - A callback function that receives the initialized WebSocket instance\n\nOutput: None (The function's effects are through callbacks and event handlers)\n- The function doesn't return anything directly but:\n  - Calls the provided callback with the WebSocket instance\n  - Posts messages via postMessage for connection status changes\n  - Automatically attempts reconnection on close\n  - Handles incoming messages through the provided handleFunctionCall",
    "Canonical_solution": "export const initWs = (\n  handleFunctionCall: Function,\n  url: string,\n  cb: (_ws: WebSocket) => void\n) => {\n  const ws = new WebSocket(url);\n  ws.onopen = () => {\n    console.log(\"Connected to server\");\n    postMessage(\"msg:Connected to server\");\n    postMessage({\n      id: getUuid(),\n      data: null,\n      type: MsgType.WebSocketConnected,\n    });\n  };\n  ws.onmessage = (e) => {\n    const channel = new MessageChannel();\n    const msg = deserializedMsg(e.data);\n    handleFunctionCall(msg.data, msg.id, channel.port1);\n    channel.port2.onmessage = (e) => {\n      ws.send(JSON.stringify(e.data));\n    };\n  };\n  ws.onclose = () => {\n    console.log(\"Disconnected from server\");\n    postMessage({\n      id: getUuid(),\n      data: null,\n      type: MsgType.WebSocketDisconnected,\n    });\n    setTimeout(() => {\n      initWs(handleFunctionCall, url, cb);\n    }, 1000);\n  };\n  cb(ws);\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function initWebSocketClient(handleFunctionCall, url, cb) {\n  let ws;\n  function reconnect() {\n    ws = new WebSocket(url);\n    ws.onopen = () => {\n      console.log('WebSocket reconnected');\n      cb(ws);\n      ws.onmessage = (event) => {\n        handleFunctionCall(event.data);\n      };\n      ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        setTimeout(reconnect, 5000);\n      };\n    };\n    ws.onclose = (event) => {\n      console.log('WebSocket closed', event);\n      setTimeout(reconnect, 5000);\n    };\n    ws.onmessage = (event) => {\n      handleFunctionCall(event.data);\n    };\n  }\n  reconnect();\n}"
  },
  {
    "Task_id": 222,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that handles WebSocket connections, message transmission, and error handling.\n\nClass Description: The WS class provides a WebSocket client implementation with configurable connection parameters, event handling, and message transmission capabilities. It supports both secure (wss) and non-secure (ws) connections, binary data transmission, and connection lifecycle management.\n\nAttributes:\n- secure: [Boolean] - Indicates whether to use a secure WebSocket connection (wss)\n- hostname: [String] - The hostname to connect to\n- port: [Number] - The port number for the connection\n- path: [String] - The path for the WebSocket endpoint\n- query: [Object] - Additional query parameters for the connection\n- timestampParam: [String] - Parameter name for timestamp in requests\n- timestampRequests: [Boolean] - Whether to include timestamps in requests\n- readyState: [String] - Current state of the WebSocket connection\n- ws: [WebSocket] - The underlying WebSocket instance\n- binaryType: [String] - Type of binary data to use ('buffer' or 'arraybuffer')\n- perMessageDeflate: [Object|Boolean] - Configuration for per-message deflate extension\n\nMethods:\n- constructor(opts): [Object] -> [void] - Initializes the WebSocket client with configuration options\n- doOpen(): [void] -> [void] - Establishes the WebSocket connection\n- addEventListeners(): [void] -> [void] - Sets up event handlers for the WebSocket\n- write(packets): [Array] -> [void] - Sends multiple packets through the WebSocket\n- doClose(): [void] -> [void] - Closes the WebSocket connection\n- uri(): [void] -> [String] - Generates the WebSocket connection URI\n- check(): [void] -> [Boolean] - Verifies WebSocket availability and initialization status",
    "Canonical_solution": "var WebSocket = global.WebSocket || global.MozWebSocket;\n\nclass WS {\n  constructor(opts) {\n    this.secure = null != opts.secure ? opts.secure : (global.location && 'https:' == location.protocol);\n    this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');\n    this.port = opts.port || (global.location && location.port ? location.port : (this.secure ? 443 : 80));\n    this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n    this.query = opts.query || {};\n    this.timestampParam = opts.timestampParam || 't';\n    this.timestampRequests = opts.timestampRequests;\n    this.readyState = '';\n    this.ws = null;\n    this.binaryType = null;\n    this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n  }\n\n  doOpen() {\n    if (!this.check()) return;\n\n    var uri = this.uri();\n    var protocols = void(0);\n    var opts = {\n      agent: this.agent,\n      perMessageDeflate: this.perMessageDeflate\n    };\n\n    this.ws = new WebSocket(uri, protocols, opts);\n\n    if (this.ws.binaryType === undefined) {\n      this.supportsBinary = false;\n    }\n\n    if (this.ws.supports && this.ws.supports.binary) {\n      this.supportsBinary = true;\n      this.ws.binaryType = 'buffer';\n    } else {\n      this.ws.binaryType = 'arraybuffer';\n    }\n\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    var self = this;\n\n    this.ws.onopen = function() {\n      self.onOpen();\n    };\n    this.ws.onclose = function() {\n      self.onClose();\n    };\n    this.ws.onmessage = function(ev) {\n      self.onData(ev.data);\n    };\n    this.ws.onerror = function(e) {\n      self.onError('websocket error', e);\n    };\n  }\n\n  write(packets) {\n    var self = this;\n    this.writable = false;\n\n    for (var i = 0, l = packets.length; i < l; i++) {\n      (function(packet) {\n        parser.encodePacket(packet, self.supportsBinary, function(data) {\n          try {\n            self.ws.send(data);\n          } catch(e) {\n            debug('websocket closed before onclose event');\n          }\n        });\n      })(packets[i]);\n    }\n\n    setTimeout(function() {\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n\n  doClose() {\n    if (typeof this.ws !== 'undefined') {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    var query = this.query || {};\n    var schema = this.secure ? 'wss' : 'ws';\n    var port = '';\n\n    if (this.port && (('wss' == schema && this.port != 443) || ('ws' == schema && this.port != 80))) {\n      port = ':' + this.port;\n    }\n\n    if (this.timestampRequests) {\n      query[this.timestampParam] = yeast();\n    }\n\n    if (!this.supportsBinary) {\n      query.b64 = 1;\n    }\n\n    query = parseqs.encode(query);\n\n    if (query.length) {\n      query = '?' + query;\n    }\n\n    var ipv6 = this.hostname.indexOf(':') !== -1;\n    return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n  }\n\n  check() {\n    return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class WS {\n  constructor(opts) {\n    this.secure = opts.secure || false;\n    this.hostname = opts.hostname || 'example.com';\n    this.port = opts.port || 80;\n    this.path = opts.path || '/';\n    this.query = opts.query || {};\n    this.timestampParam = opts.timestampParam || 't';\n    this.timestampRequests = opts.timestampRequests || false;\n    this.readyState = 'closed';\n    this.ws = null;\n    this.binaryType = opts.binaryType || 'arraybuffer';\n    this.perMessageDeflate = opts.perMessageDeflate || false;\n  }\n\n  doOpen() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    const uri = this.uri();\n    this.ws = new WebSocket(uri, this.perMessageDeflate ? 'permessage-deflate' : undefined);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.readyState = 'open';\n      this.emit('open');\n    };\n\n    this.ws.onmessage = (event) => {\n      this.emit('message', event.data);\n    };\n\n    this.ws.onerror = (error) => {\n      this.readyState = 'closed';\n      this.emit('error', error);\n    };\n\n    this.ws.onclose = (event) => {\n      this.readyState = 'closed';\n      this.emit('close', event);\n    };\n  }\n\n  write(packets) {\n    if (this.readyState !== 'open') {\n      throw new Error('WebSocket is not open');\n    }\n\n    packets.forEach(packet => {\n      if (typeof packet === 'string') {\n        this.ws.send(packet);\n      } else if (Buffer.isBuffer(packet)) {\n        this.ws.send(packet);\n      } else if (typeof packet === 'object' && packet instanceof ArrayBuffer) {\n        this.ws.send(packet);\n      }\n    });\n  }\n\n  doClose() {\n    if (this.ws && this.ws.readyState === 'open') {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    let uri = `${this.secure ? 'wss' : 'ws'}://${this.hostname}`;\n    if (this.port !== 80 && this.port !== 443) {\n      uri += `:${this.port}`;\n    }\n    uri += this.path;\n\n    if (Object.keys(this.query).length > 0) {\n      const queryStr = new URLSearchParams(this.query).toString();\n      uri += '?' + queryStr;\n    }\n\n    return uri;\n  }\n\n  check() {\n    return this.ws && this.ws.readyState === 'open';\n  }\n\n  emit(event, data) {\n    if (this._events && this._events[event]) {\n      this._events[event].forEach(cb => cb(data));\n    }\n  }\n}"
  },
  {
    "Task_id": 223,
    "Instruction": "Task Description: Implement a WebSocket client class for handling real-time communication with a redirect API service, managing connection events, message processing, and various monetization workflows.\n\nClass Description: Workink is a WebSocket client implementation that extends BypassDefinition. It establishes a WebSocket connection to a specified URL, handles different message types from the server, and executes appropriate actions including social media interactions, captcha handling, and monetization processes.\n\nAttributes:\n- websocketUrl: String - The WebSocket server URL to connect to (default: 'wss://redirect-api.work.ink/v1/ws')\n- ws: WebSocket - The active WebSocket connection instance\n- interval: Number - Interval ID for the periodic ping message\n- socials: Array - Stores social media URLs received from the server\n- activeMonetizationTypes: Array - Tracks active monetization methods ('readArticles', 'browserExtension')\n\nMethods:\n- constructor() -> void - Initializes the class instance and inherits from BypassDefinition\n- execute() -> Promise<void> - Main execution method that:\n  1. Creates WebSocket connection\n  2. Sets up event handlers\n  3. Manages message processing workflow\n  4. Handles different server message types including:\n     * s_link_info: Processes social media and monetization data\n     * s_start_recaptcha_check: Initiates captcha process\n     * s_recaptcha_okay: Executes social media and monetization actions\n     * s_monetization: Handles browser extension monetization\n     * s_link_destination: Processes final destination URL",
    "Canonical_solution": "import BypassDefinition from './BypassDefinition.js';\n\nclass Workink extends BypassDefinition {\n    constructor() {\n        super();\n    }\n\n    async execute() {\n        const websocketUrl = 'wss://redirect-api.work.ink/v1/ws';\n        let ws = new WebSocket(websocketUrl);\n        let interval;\n\n        ws.onopen = () => {\n            ws.send(payloads.announce);\n            interval = setInterval(() => ws.send(payloads.ping), 10 * 1000);\n        };\n\n        ws.onmessage = async (e) => {\n            const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n            const data = JSON.parse(e.data);\n            if (data.error) return;\n            const payload = data.payload;\n\n            switch (data.type) {\n                case 's_link_info':\n                    if (payload.socials) socials.push(...payload.socials);\n                    const monetizationTypes = ['readArticles', 'browserExtension'];\n                    for (const type of monetizationTypes) {\n                        if (payload.monetizationScript.includes(type)) {\n                            activeMonetizationTypes.push(type);\n                        }\n                    }\n                    break;\n                case 's_start_recaptcha_check':\n                    ws.send(payloads.captcha);\n                    break;\n                case 's_recaptcha_okay':\n                    if (socials.length) {\n                        for (const [index, social] of socials.entries()) {\n                            ws.send(payloads.social(social.url));\n                            await sleep(3 * 1000);\n                        }\n                    }\n\n                    if (activeMonetizationTypes.length) {\n                        for (const type of activeMonetizationTypes) {\n                            switch (type) {\n                                case 'readArticles':\n                                    ws.send(payloads.readArticles['1']);\n                                    ws.send(payloads.readArticles['2']);\n                                    break;\n                                case 'browserExtension':\n                                    if (activeMonetizationTypes.includes('readArticles'))\n                                        await sleep(16 * 1000);\n                                    ws.send(payloads.browserExtension['1']);\n                                    break;\n                            }\n                        }\n                    }\n                    break;\n                case 's_monetization':\n                    if (payload.type !== 'browserExtension') break;\n                    ws.send(payloads.browserExtension['2'](payload.payload.token));\n                    break;\n                case 's_link_destination': {\n                    const url = new URL(payload.url);\n                    if (url.searchParams.has('duf')) {\n                        payload.url = window.atob(\n                            url.searchParams.get('duf').split('').reverse().join('')\n                        );\n                    }\n                    this.helpers.safelyNavigate(payload.url);\n                    break;\n                }\n            }\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class Workink extends BypassDefinition {\n  constructor() {\n    super();\n    this.websocketUrl = 'wss://redirect-api.work.ink/v1/ws';\n    this.ws = null;\n    this.interval = null;\n    this.socials = [];\n    this.activeMonetizationTypes = [];\n  }\n\n  async execute() {\n    try {\n      this.ws = new WebSocket(this.websocketUrl);\n      this.ws.onopen = () => {\n        console.log('WebSocket connection established');\n        this.sendPing();\n      };\n\n      this.ws.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        if (data.type === 's_link_info') {\n          this.handleSocialAndMonetization(data);\n        } else if (data.type === 's_start_recaptcha_check') {\n          this.startCaptchaCheck();\n        } else if (data.type === 's_recaptcha_okay') {\n          this.executeSocialAndMonetizationActions();\n        } else if (data.type === 's_monetization') {\n          this.handleBrowserExtensionMonetization(data);\n        } else if (data.type === 's_link_destination') {\n          this.processFinalDestination(data.url);\n        }\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        this.reconnect();\n      };\n\n      this.ws.onclose = () => {\n        console.log('WebSocket connection closed');\n        this.reconnect();\n      };\n    } catch (error) {\n      console.error('WebSocket initialization failed:', error);\n      this.reconnect();\n    }\n  }\n\n  sendPing() {\n    this.interval = setInterval(() => {\n      this.ws.send(JSON.stringify({ type: 'ping' }));\n    }, 30000);\n  }\n\n  reconnect() {\n    setTimeout(() => {\n      new Workink().execute();\n    }, 5000);\n  }\n\n  handleSocialAndMonetization(data) {\n    this.socials = data.socials || [];\n    this.activeMonetizationTypes = data.monetization || [];\n  }\n\n  startCaptchaCheck() {\n    // Implement captcha check logic here\n    console.log('Starting captcha check');\n  }\n\n  executeSocialAndMonetizationActions() {\n    // Implement social media and monetization actions here\n    console.log('Executing social and monetization actions');\n  }\n\n  handleBrowserExtensionMonetization(data) {\n    // Implement browser extension monetization logic here\n    console.log('Handling browser extension monetization', data);\n  }\n\n  processFinalDestination(url) {\n    // Implement final destination processing logic here\n    console.log('Processing final destination', url);\n  }\n}"
  },
  {
    "Task_id": 224,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with reconnection capabilities and event handling.\n\nClass Description: The N class represents a WebSocket client that connects to a specified URL, handles messages, errors, and connection events, and supports automatic reconnection. It provides methods to start, destroy, and manage the WebSocket connection, along with callbacks for connection events.\n\nAttributes:\n- url: [String] - The WebSocket server URL to connect to.\n- options: [Object] - Configuration options for the WebSocket connection, including protocols, reconnect interval, and callbacks.\n- socket: [WebSocket] - The WebSocket connection instance.\n- streaming: [Boolean] - Indicates if the connection is in streaming mode.\n- callbacks: [Object] - Contains arrays of callback functions for connection and data events.\n- destination: [Object] - The destination to write received data to.\n- reconnectInterval: [Number] - The interval (in seconds) between reconnection attempts.\n- shouldAttemptReconnect: [Boolean] - Indicates if reconnection should be attempted.\n- completed: [Boolean] - Indicates if the connection is completed.\n- established: [Boolean] - Indicates if the connection is established.\n- progress: [Number] - Tracks the connection progress.\n- reconnectTimeoutId: [Number] - The timeout ID for reconnection attempts.\n- onEstablishedCallback: [Function] - Callback function triggered when the connection is established.\n- onCompletedCallback: [Function] - Callback function triggered when the connection is completed.\n- hookOnEstablished: [Function] - Optional hook function triggered when the connection is established.\n\nMethods:\n- constructor(url, options) -> [N] - Initializes the WebSocket client with the given URL and options.\n- connect(destination) -> [void] - Sets the destination for received data.\n- destroy() -> [void] - Closes the WebSocket connection and stops reconnection attempts.\n- start() -> [void] - Starts the WebSocket connection and sets up event handlers.\n- resume() -> [void] - Placeholder for resuming the connection (currently empty).\n- onOpen() -> [void] - Handles the WebSocket 'open' event and updates progress.\n- onClose() -> [void] - Handles the WebSocket 'close' and 'error' events and initiates reconnection if enabled.\n- onMessage(event) -> [void] - Handles the WebSocket 'message' event, writes data to the destination, and triggers callbacks.",
    "Canonical_solution": "class N {\n  constructor(A, t) {\n    this.url = A;\n    this.options = t;\n    this.socket = null;\n    this.streaming = !0;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = void 0 !== t.reconnectInterval ? t.reconnectInterval : 5;\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.completed = !1;\n    this.established = !1;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = t.onSourceEstablished;\n    this.onCompletedCallback = t.onSourceCompleted;\n    t.hookOnEstablished && (this.hookOnEstablished = t.hookOnEstablished);\n  }\n\n  connect(A) {\n    this.destination = A;\n  }\n\n  destroy() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.shouldAttemptReconnect = !1;\n    this.socket.close();\n  }\n\n  start() {\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.progress = 0;\n    this.established = !1;\n    this.options.protocols\n      ? (this.socket = new WebSocket(this.url, this.options.protocols))\n      : (this.socket = new WebSocket(this.url));\n    this.socket.binaryType = \"arraybuffer\";\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n  }\n\n  onClose() {\n    var A = this;\n    this.shouldAttemptReconnect &&\n      (clearTimeout(this.reconnectTimeoutId),\n      (this.reconnectTimeoutId = setTimeout(function () {\n        A.start();\n      }, 1e3 * this.reconnectInterval)));\n  }\n\n  onMessage(A) {\n    var t = !this.established;\n    this.established = !0;\n    t && this.hookOnEstablished && this.hookOnEstablished();\n    t && this.onEstablishedCallback && this.onEstablishedCallback(this);\n    this.destination && this.destination.write(A.data);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options || {};\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      connection: [],\n      data: []\n    };\n    this.destination = null;\n    this.reconnectInterval = this.options.reconnectInterval || 5;\n    this.shouldAttemptReconnect = this.options.shouldAttemptReconnect || true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = this.options.onEstablished;\n    this.onCompletedCallback = this.options.onCompleted;\n    this.hookOnEstablished = this.options.hookOnEstablished;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = null;\n    }\n  }\n\n  start() {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      this.connectToWebSocket();\n    }\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.established = true;\n    this.progress = 100;\n    this.completed = true;\n    this.onEstablishedCallback && this.onEstablishedCallback();\n    this.hookOnEstablished && this.hookOnEstablished();\n    this.callbacks.connection.forEach(cb => cb());\n  }\n\n  onClose(event) {\n    if (event.reason === 'WebSocket connection closed') {\n      this.established = false;\n      this.completed = false;\n      this.progress = 0;\n      if (this.shouldAttemptReconnect) {\n        this.reconnectTimeoutId = setTimeout(() => {\n          this.connectToWebSocket();\n        }, this.reconnectInterval * 1000);\n      }\n    } else {\n      this.onCompletedCallback && this.onCompletedCallback();\n    }\n  }\n\n  onMessage(event) {\n    this.destination.write(event.data);\n    this.callbacks.data.forEach(cb => cb(event.data));\n  }\n\n  connectToWebSocket() {\n    this.socket = new WebSocket(this.url, this.options.protocols);\n    this.socket.onopen = () => this.onOpen();\n    this.socket.onclose = (event) => this.onClose(event);\n    this.socket.onmessage = (event) => this.onMessage(event);\n  }\n}"
  },
  {
    "Task_id": 225,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a server, sends a message, and handles incoming messages.\n\nFunction Description: The function `echo` creates a WebSocket connection to a specified URI, sends a message from an input field upon successful connection, and logs received messages. It also provides visual feedback for connection status and message exchange.\n\nInput: \n- None (implicitly uses `myField.value` from the DOM as the message to send)\n- The WebSocket URI is constructed from the current document's host and path\n\nOutput: \n- No direct return value\n- Side effects:\n  - Logs connection status to console\n  - Writes connection status to screen\n  - Sends message from input field\n  - Writes sent message to screen\n  - Writes received messages to screen",
    "Canonical_solution": "function echo() {\n    var wsUri = \"ws://\" + document.location.host + document.location.pathname + \"websocket\";\n    console.log(\"Connecting to \" + wsUri);\n    var websocket = new WebSocket(wsUri);\n    websocket.onopen = function() { \n        writeToScreen(\"CONNECTED\");\n        websocket.send(myField.value);\n        writeToScreen(\"SENT: \" + myField.value);\n    };\n    websocket.onmessage = function(evt) { \n        writeToScreen(\"RECEIVED: \" + evt.data); \n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function echo() {\n  const uri = window.location.protocol + '//' + window.location.host + window.location.pathname;\n  const ws = new WebSocket(uri);\n\n  ws.onopen = function() {\n    console.log('Connected to server');\n    document.getElementById('status').innerText = 'Connected to server';\n    const message = myField.value;\n    ws.send(message);\n    console.log('Message sent:', message);\n    document.getElementById('output').innerText = 'Message sent: ' + message;\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Received message:', event.data);\n    document.getElementById('output').innerText = 'Received message: ' + event.data;\n  };\n\n  ws.onerror = function(error) {\n    console.error('Error:', error);\n    document.getElementById('status').innerText = 'Error: ' + error;\n  };\n\n  ws.onclose = function() {\n    console.log('Connection closed');\n    document.getElementById('status').innerText = 'Connection closed';\n  };\n}"
  },
  {
    "Task_id": 226,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a specified path on a server and returns the WebSocket object if the connection is successfully opened.\n\nFunction Description: The function `apiWebSocket` attempts to create a WebSocket connection to a given path on a secure WebSocket server. It waits for the connection to be established or fail (due to error or closure) and returns the WebSocket object only if the connection is successfully opened. If the connection fails or an error occurs, the function returns `undefined`.\n\nInput: \n- `path` (string): The path on the server to which the WebSocket connection should be established. This is appended to the base URL `wss://services.bonjourr.fr/`.\n\nOutput: \n- `Promise<WebSocket | undefined>`: A promise that resolves to the WebSocket object if the connection is successfully opened, or `undefined` if the connection fails or an error occurs.",
    "Canonical_solution": "export async function apiWebSocket(path: string): Promise<WebSocket | undefined> {\n\ttry {\n\t\tconst socket = new WebSocket(`wss://services.bonjourr.fr/${path}`)\n\t\tconst isOpened = await new Promise((resolve) => {\n\t\t\tsocket.onopen = () => resolve(true)\n\t\t\tsocket.onerror = () => resolve(false)\n\t\t\tsocket.onclose = () => resolve(false)\n\t\t})\n\n\t\tif (isOpened) {\n\t\t\treturn socket\n\t\t}\n\t} catch (_error) {\n\t\t// ...\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function apiWebSocket(path) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(`wss://services.bonjourr.fr/${path}`);\n    \n    ws.onopen = () => {\n      resolve(ws);\n    };\n    \n    ws.onerror = (error) => {\n      reject(error);\n    };\n    \n    ws.onclose = (event) => {\n      if (event.reason === 'Unexpected closure') {\n        reject(new Error('Connection closed unexpectedly'));\n      }\n      resolve(undefined);\n    };\n  });\n}"
  },
  {
    "Task_id": 227,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that connects to a server to receive and display image data in real-time on an HTML canvas element. The client should handle connection events, process incoming image messages, and properly manage resources.\n\nFunction Description: The `loadLiveScreen` function establishes a WebSocket connection to a specified server, listens for incoming image data (JPEG format), and renders each received image onto a canvas element. It handles connection events, processes binary image data, manages memory by cleaning up resources, and adjusts the canvas size to match incoming images.\n\nInput: None (The function uses hardcoded WebSocket URL and accesses DOM elements directly)\n\nOutput: None (The function's side effects are rendering images to canvas and logging connection status)\n\nNote: The function relies on these external elements:\n1. A canvas element with ID 'bgCanvas' must exist in the DOM\n2. The function assumes the existence of an `imagePool` object with a `next()` method\n3. The function assumes the existence of a `resizeScreen` method on the containing object",
    "Canonical_solution": "function loadLiveScreen() {\n    var self = this;\n    var BLANK_IMG = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n    var ws = new WebSocket('ws://10.240.184.233:9002');\n    var canvas = document.getElementById('bgCanvas');\n    var ctx = canvas.getContext('2d');\n\n    ws.onopen = function(ev) {\n        console.log('screen websocket connected');\n    };\n    ws.onmessage = function(message) {\n        console.log(\"New message\");\n        var blob = new Blob([message.data], {\n            type: 'image/jpeg'\n        });\n        var img = self.imagePool.next();\n        img.onload = function() {\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, img.width, img.height);\n            self.resizeScreen(img);\n\n            img.onload = img.onerror = null;\n            img.src = BLANK_IMG;\n            img = null;\n            blob = null;\n\n            URL.revokeObjectURL(url);\n            url = null;\n        };\n\n        img.onerror = function() {\n            img.onload = img.onerror = null;\n            img.src = BLANK_IMG;\n            img = null;\n            blob = null;\n\n            URL.revokeObjectURL(url);\n            url = null;\n        };\n        var url = URL.createObjectURL(blob);\n        img.src = url;\n    };\n\n    ws.onclose = function(ev) {\n        console.log(\"screen websocket closed\");\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function loadLiveScreen() {\n  const ws = new WebSocket('ws://example.com/socket');\n  const canvas = document.getElementById('bgCanvas');\n  const ctx = canvas.getContext('2d');\n  let imagePool = {};\n  let image;\n\n  ws.onopen = function () {\n    console.log('Connected to WebSocket server');\n    resizeScreen();\n  };\n\n  ws.onmessage = function (event) {\n    if (event.data instanceof Blob) {\n      imagePool.next().then(poolItem => {\n        image = new Image();\n        image.onload = function () {\n          canvas.width = image.width;\n          canvas.height = image.height;\n          ctx.drawImage(image, 0, 0);\n        };\n        image.src = URL.createObjectURL(event.data);\n      });\n    }\n  };\n\n  ws.onclose = function () {\n    console.log('WebSocket connection closed');\n    if (image) {\n      URL.revokeObjectURL(image.src);\n      image = null;\n    }\n  };\n\n  ws.onerror = function (error) {\n    console.error('WebSocket error:', error);\n  };\n}"
  },
  {
    "Task_id": 228,
    "Instruction": "Task Description: Implement a WebSocket client with automatic reconnection capabilities for robust browser-based communication. The solution should handle connection drops, implement exponential backoff for reconnection attempts, and provide event-based notification of connection states.\n\nClass Description: ReconnectingWebSocket is a WebSocket wrapper class that automatically reconnects when the connection is lost, with configurable reconnection timing and event handling. It maintains connection state and provides standard WebSocket-like interface.\n\nAttributes:\n- url: [String] - The WebSocket server URL to connect to\n- protocols: [Array/String] - Optional subprotocols for WebSocket\n- debug: [Boolean] - Whether to enable debug logging (default: false)\n- automaticOpen: [Boolean] - Whether to automatically open connection (default: true)\n- reconnectInterval: [Number] - Initial delay before reconnection in ms (default: 1000)\n- maxReconnectInterval: [Number] - Maximum delay between reconnections in ms (default: 30000)\n- reconnectDecay: [Number] - Multiplier for reconnection delay (default: 1.5)\n- timeoutInterval: [Number] - Connection timeout in ms (default: 2000)\n- reconnectAttempts: [Number] - Count of reconnection attempts\n- readyState: [Number] - Current connection state (matching WebSocket constants)\n- protocol: [String] - Selected subprotocol (set after connection)\n\nMethods:\n- constructor(url, protocols, options) -> [ReconnectingWebSocket] - Initializes new instance with connection parameters and options\n- addEventListener(type, listener) -> [void] - Adds event listener for connection events\n- removeEventListener(type, listener) -> [void] - Removes event listener\n- dispatchEvent(event) -> [void] - Triggers event handlers\n- open(reconnecting) -> [void] - Opens WebSocket connection (internal use)\n- send(data) -> [void] - Sends data through WebSocket connection\n- close(code, reason) -> [void] - Closes connection (no automatic reconnection)\n- refresh() -> [void] - Forces reconnection by closing current connection\n- onopen() -> [void] - Placeholder for open event handler\n- onclose() -> [void] - Placeholder for close event handler\n- onconnecting() -> [void] - Placeholder for connecting event handler\n- onmessage() -> [void] - Placeholder for message event handler\n- onerror() -> [void] - Placeholder for error event handler",
    "Canonical_solution": "class ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    const defaults = {\n      debug: false,\n      automaticOpen: true,\n      reconnectInterval: 1000,\n      maxReconnectInterval: 30000,\n      reconnectDecay: 1.5,\n      timeoutInterval: 2000\n    };\n    \n    options = options || {};\n    for (let key in defaults) {\n      this[key] = typeof options[key] !== 'undefined' ? options[key] : defaults[key];\n    }\n\n    this.url = url;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = null;\n\n    let forcedClose = false;\n    let timedOut = false;\n    let eventTarget = document.createElement('div');\n\n    this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n    this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n    this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n\n    this.open = function(reconnecting) {\n      let ws = new WebSocket(this.url, protocols || []);\n      if (!reconnecting) {\n        this.dispatchEvent(new Event('connecting'));\n      }\n\n      let timeout = setTimeout(() => {\n        timedOut = true;\n        ws.close();\n        timedOut = false;\n      }, this.timeoutInterval);\n\n      ws.onopen = () => {\n        clearTimeout(timeout);\n        this.protocol = ws.protocol;\n        this.readyState = WebSocket.OPEN;\n        this.reconnectAttempts = 0;\n        let event = new Event('open');\n        event.isReconnect = reconnecting;\n        this.dispatchEvent(event);\n      };\n\n      ws.onclose = (event) => {\n        clearTimeout(timeout);\n        ws = null;\n        if (forcedClose) {\n          this.readyState = WebSocket.CLOSED;\n          this.dispatchEvent(new Event('close'));\n        } else {\n          this.readyState = WebSocket.CONNECTING;\n          let connectingEvent = new Event('connecting');\n          Object.assign(connectingEvent, {\n            code: event.code,\n            reason: event.reason,\n            wasClean: event.wasClean\n          });\n          this.dispatchEvent(connectingEvent);\n\n          if (!reconnecting && !timedOut) {\n            this.dispatchEvent(new Event('close'));\n          }\n\n          let timeout = this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts);\n          setTimeout(() => {\n            this.reconnectAttempts++;\n            this.open(true);\n          }, Math.min(timeout, this.maxReconnectInterval));\n        }\n      };\n\n      ws.onmessage = (event) => {\n        let messageEvent = new Event('message');\n        messageEvent.data = event.data;\n        this.dispatchEvent(messageEvent);\n      };\n\n      ws.onerror = (event) => {\n        this.dispatchEvent(new Event('error'));\n      };\n    };\n\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n\n    this.send = function(data) {\n      if (ws) {\n        return ws.send(data);\n      }\n      throw new Error('INVALID_STATE_ERR : Pausing to reconnect websocket');\n    };\n\n    this.close = function(code, reason) {\n      forcedClose = true;\n      if (ws) {\n        ws.close(code || 1000, reason);\n      }\n    };\n\n    this.refresh = function() {\n      if (ws) {\n        ws.close();\n      }\n    };\n  }\n\n  onopen() {}\n  onclose() {}\n  onconnecting() {}\n  onmessage() {}\n  onerror() {}\n}\n\nReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\nReconnectingWebSocket.OPEN = WebSocket.OPEN;\nReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\nReconnectingWebSocket.CLOSED = WebSocket.CLOSED;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class ReconnectingWebSocket {\n  constructor(url, protocols, options = {}) {\n    this.url = url;\n    this.protocols = protocols || [];\n    this.debug = options.debug !== false;\n    this.automaticOpen = options.automaticOpen !== false;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 2000;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = '';\n    this._ws = null;\n    this._eventListeners = {};\n    this._reconnectTimer = null;\n    this._connecting = false;\n    this._onopen = this.onopen.bind(this);\n    this._onclose = this.onclose.bind(this);\n    this._onmessage = this.onmessage.bind(this);\n    this._onerror = this.onerror.bind(this);\n    this._onconnecting = this.onconnecting.bind(this);\n    if (this.automaticOpen) {\n      this.open();\n    }\n  }\n\n  addEventListener(type, listener) {\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n    this._eventListeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this._eventListeners[type]) {\n      const index = this._eventListeners[type].indexOf(listener);\n      if (index !== -1) {\n        this._eventListeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this._eventListeners[event.type]) {\n      for (const listener of this._eventListeners[event.type]) {\n        listener.call(this, event);\n      }\n    }\n  }\n\n  open(reconnecting = false) {\n    if (this._connecting || this.readyState !== WebSocket.CLOSED) {\n      return;\n    }\n    this._connecting = true;\n    this.reconnectAttempts = 0;\n    this._ws = new WebSocket(this.url, this.protocols);\n    this._ws.binaryType = 'arraybuffer';\n    this._ws.onopen = this._onopen;\n    this._ws.onclose = this._onclose;\n    this._ws.onmessage = this._onmessage;\n    this._ws.onerror = this._onerror;\n    this._ws.onabort = this._onclose;\n    this._ws.onclose = this._onclose;\n\n    if (this.debug) {\n      console.log('Connecting to:', this.url);\n    }\n\n    this._ws.setTimeout(this.timeoutInterval);\n    this._ws.ontimeout = () => {\n      this._onclose({ code: 1002, reason: 'Timeout' });\n    };\n\n    this._ws.onopen = () => {\n      this._connecting = false;\n      this.readyState = WebSocket.OPEN;\n      this.protocol = this._ws.protocol;\n      this.dispatchEvent(new Event('open'));\n      this.dispatchEvent(new Event('connecting'));\n    };\n\n    this._ws.onclose = (event) => {\n      this._connecting = false;\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(new Event('close', { bubbles: true, cancelable: true }));\n      this.dispatchEvent(new Event('connecting'));\n      if (event.code === 1006 || event.code === 1011) {\n        this._reconnect();\n      } else {\n        this._reconnect();\n      }\n    };\n\n    this._ws.onerror = (event) => {\n      this._connecting = false;\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(new Event('error'));\n      this._reconnect();\n    };\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    }\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  refresh() {\n    if (this._ws) {\n      this._ws.close();\n    }\n    this.open();\n  }\n\n  onopen() {\n    this.dispatchEvent(new CustomEvent('open'));\n  }\n\n  onclose(event) {\n    this.dispatchEvent(new CustomEvent('close', { detail: event }));\n  }\n\n  onconnecting() {\n    this.dispatchEvent(new CustomEvent('connecting'));\n  }\n\n  onmessage(event) {\n    this.dispatchEvent(new CustomEvent('message', { detail: event }));\n  }\n\n  onerror(event) {\n    this.dispatchEvent(new CustomEvent('error', { detail: event }));\n  }\n\n  _reconnect() {\n    if (this.reconnectAttempts >= 10) {\n      return;\n    }\n    const interval = Math.min(this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts), this.maxReconnectInterval);\n    this.reconnectAttempts++;\n    this._reconnectTimer = setTimeout(() => {\n      this.open(true);\n    }, interval);\n  }\n}"
  },
  {
    "Task_id": 230,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, handles incoming messages (including PING-PONG mechanism), manages connection errors, and automatically reconnects when the connection is closed.\n\nFunction Description: The `connect` function initializes a WebSocket connection to a specified server URL and sets up event handlers for various WebSocket events. It handles connection opening, incoming messages (with special handling for PING messages and JSON data), connection errors, and automatic reconnection when the connection closes. Received text data is displayed in a textarea element and stored in localStorage.\n\nInput: None (The WebSocket URL is hardcoded as \"ws://127.0.0.1:8266/\" in the function)\n\nOutput: None (The function's effects are through side effects: establishing WebSocket connection, updating UI elements, and storing data in localStorage)",
    "Canonical_solution": "function connect() {\n    ws = new WebSocket(\"ws://127.0.0.1:8266/\");\n\n    ws.onopen = function () {\n        myLog('ws connected')\n    };\n\n    ws.onmessage = function (e) {\n        var d = e.data\n        if (d == '[PING]')\n            ws.send('[PONG]')\n        else {\n            if (d[0] == '{') {\n                d = JSON.parse(d)\n                document.getElementById(\"textArea\").value += d.txt\n                localStorage.setItem('txt_stored', document.getElementById(\"textArea\").value);\n            }\n        }\n    }\n\n    ws.onclose = function (e) {\n        setTimeout(function () {\n            connect();\n        }, 2000);\n    };\n\n    ws.onerror = function (e) {\n        myLog('ws error', e.message);\n        ws.close();\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function connect() {\n  const url = \"ws://127.0.0.1:8266/\";\n  let ws;\n\n  function reconnect() {\n    ws = new WebSocket(url);\n    ws.onopen = () => {\n      console.log(\"Reconnected to WebSocket server\");\n      ws.send(JSON.stringify({ type: \"subscribe\", data: {} }));\n    };\n    ws.onmessage = (event) => {\n      const message = event.data;\n      if (message.startsWith('PING')) {\n        ws.send('PONG');\n      } else {\n        try {\n          const data = JSON.parse(message);\n          document.getElementById('chat').value += data.message + '\\n';\n          localStorage.setItem('chatHistory', document.getElementById('chat').value);\n        } catch (e) {\n          document.getElementById('chat').value += 'Error parsing message: ' + e.message + '\\n';\n          localStorage.setItem('chatHistory', document.getElementById('chat').value);\n        }\n      }\n    };\n    ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n      setTimeout(reconnect, 5000);\n    };\n    ws.onclose = () => {\n      console.log('WebSocket connection closed, attempting to reconnect...');\n      setTimeout(reconnect, 5000);\n    };\n  }\n\n  reconnect();\n}"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that connects to a server, sends messages, and displays received messages in a chat interface.\n\nFunction Description: The function `setupWebSocket` initializes a WebSocket connection to a server when a button is clicked. It handles connection events (open, close, message) and allows sending messages via an input field. The function disables the join button during active connection and re-enables it when closed.\n\nInput: \n- None (the function uses DOM elements internally: username input, join button, chat textarea, and message input field)\n\nOutput: \n- None (the function sets up event listeners and modifies DOM elements directly)\n\nAttributes: N/A (function-level implementation)\n\nMethods: N/A (function-level implementation)",
    "Canonical_solution": "function setupWebSocket() {\n    const username = document.querySelector(\"#username\");\n    const join_btn = document.querySelector(\"#join-chat\");\n    const textarea = document.querySelector(\"#chat\");\n    const input = document.querySelector(\"#input\");\n\n    join_btn.addEventListener(\"click\", function(e) {\n        this.disabled = true;\n\n        const websocket = new WebSocket(\"ws://localhost:3000/websocket\");\n\n        websocket.onopen = function() {\n            console.log(\"connection opened\");\n            websocket.send(username.value);\n        }\n\n        const btn = this;\n\n        websocket.onclose = function() {\n            console.log(\"connection closed\");\n            btn.disabled = false;\n        }\n\n        websocket.onmessage = function(e) {\n            console.log(\"received message: \"+e.data);\n            textarea.value += e.data+\"\\r\\n\";\n        }\n\n        input.onkeydown = function(e) {\n            if (e.key == \"Enter\") {\n                websocket.send(input.value);\n                input.value = \"\";\n            }\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function setupWebSocket() {\n  const usernameInput = document.getElementById('username');\n  const joinButton = document.getElementById('join-button');\n  const chatTextArea = document.getElementById('chat');\n  const messageInput = document.getElementById('message');\n\n  let socket;\n\n  joinButton.addEventListener('click', () => {\n    const username = usernameInput.value.trim();\n    if (username) {\n      socket = new WebSocket(`ws://localhost:8080?username=${encodeURIComponent(username)}`);\n      joinButton.disabled = true;\n      usernameInput.disabled = true;\n      messageInput.disabled = false;\n      chatTextArea.disabled = false;\n\n      socket.onopen = () => {\n        console.log('Connected to server');\n        chatTextArea.value += 'Connected to server\\n';\n      };\n\n      socket.onclose = () => {\n        console.log('Disconnected from server');\n        chatTextArea.value += 'Disconnected from server\\n';\n        joinButton.disabled = false;\n        usernameInput.disabled = false;\n        messageInput.disabled = true;\n        chatTextArea.disabled = true;\n      };\n\n      socket.onmessage = (event) => {\n        const message = event.data;\n        chatTextArea.value += message + '\\n';\n      };\n\n      messageInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          sendMessage();\n        }\n      });\n    }\n  });\n\n  function sendMessage() {\n    const message = messageInput.value.trim();\n    if (message) {\n      socket.send(message);\n      chatTextArea.value += 'You: ' + message + '\\n';\n      messageInput.value = '';\n    }\n  }\n}"
  },
  {
    "Task_id": 232,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, handles incoming messages, sends periodic ping messages, and manages connection events.\n\nFunction Description: The `initWebSocket` function initializes a WebSocket connection to a specified URL. It sets up event handlers for connection events (`onopen`, `onclose`, `onerror`) and message reception (`onmessage`). Upon successful connection, it sends periodic ping messages to the server. Incoming messages are parsed and processed based on their type (e.g., binding a user, displaying new messages, or showing login messages).\n\nInput: None (The function uses `window.websocket.connect_url` and `window.websocket.ping_interval` from the global scope for configuration.)\n\nOutput: None (The function logs events to the console and triggers other functions like `bindUser`, `showNewMessage`, and `showLoginMessage` based on incoming messages.)",
    "Canonical_solution": "function initWebSocket() {\n    var socket = new WebSocket(window.websocket.connect_url);\n    \n    socket.onopen = function () {\n        console.log('socket connect success');\n        setInterval(function () {\n            socket.send('ping');\n            console.log('ping...');\n        }, 1000 * parseInt(window.websocket.ping_interval));\n    };\n\n    socket.onclose = function () {\n        console.log('socket connect close');\n    };\n\n    socket.onerror = function () {\n        console.log('socket connect error');\n    };\n\n    socket.onmessage = function (e) {\n        var data = JSON.parse(e.data);\n        console.log(data);\n        if (data.type === 'bind_user') {\n            bindUser(data.client_id);\n        } else if (data.type === 'new_message') {\n            showNewMessage(data);\n        } else if (data.type === 'new_user') {\n            showLoginMessage(data);\n        }\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function initWebSocket() {\n  const url = window.websocket.connect_url;\n  const pingInterval = window.websocket.ping_interval || 30000;\n\n  const socket = new WebSocket(url);\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established');\n    sendPing();\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed', event);\n  };\n\n  socket.onerror = function(error) {\n    console.error('WebSocket error', error);\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    console.log('Received message:', data);\n\n    switch (data.type) {\n      case 'bind_user':\n        bindUser(data.user);\n        break;\n      case 'new_message':\n        showNewMessage(data.message);\n        break;\n      case 'login_message':\n        showLoginMessage(data.message);\n        break;\n      default:\n        console.log('Unknown message type:', data.type);\n    }\n  };\n\n  function sendPing() {\n    socket.send(JSON.stringify({ type: 'ping' }));\n    setTimeout(sendPing, pingInterval);\n  }\n}"
  },
  {
    "Task_id": 236,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections, handles events (connection, messages, errors, closing), and provides methods to start listening and close the connection.\n\nClass Description: The WebSocketStore class manages WebSocket connections for real-time communication. It handles connection lifecycle events, automatically reconnects on failure, and provides clean connection closure. It integrates with authentication and notification systems.\n\nAttributes:\n- wsActive: boolean - Tracks whether a WebSocket connection is currently active.\n- ws: WebSocket | null - Holds the active WebSocket connection instance.\n\nMethods:\n- constructor(snack: SnackReporter, currentUser: CurrentUser) -> void - Initializes the WebSocketStore with notification and user authentication dependencies.\n- listen(callback: (msg: IMessage) => void) -> void - Establishes a WebSocket connection and sets up event handlers. Takes a callback function for incoming messages.\n- close() -> void - Properly closes the WebSocket connection with status code 1000 (normal closure).",
    "Canonical_solution": "import {SnackReporter} from '../snack/SnackManager';\nimport {CurrentUser} from '../CurrentUser';\nimport * as config from '../config';\nimport {AxiosError} from 'axios';\nimport {IMessage} from '../types';\n\nexport class WebSocketStore {\n    private wsActive = false;\n    private ws: WebSocket | null = null;\n\n    public constructor(\n        private readonly snack: SnackReporter,\n        private readonly currentUser: CurrentUser\n    ) {}\n\n    public listen = (callback: (msg: IMessage) => void) => {\n        if (!this.currentUser.token() || this.wsActive) {\n            return;\n        }\n        this.wsActive = true;\n\n        const wsUrl = config.get('url').replace('http', 'ws').replace('https', 'wss');\n        const ws = new WebSocket(wsUrl + 'stream?token=' + this.currentUser.token());\n\n        ws.onerror = (e) => {\n            this.wsActive = false;\n            console.log('WebSocket connection errored', e);\n        };\n\n        ws.onmessage = (data) => callback(JSON.parse(data.data));\n\n        ws.onclose = () => {\n            this.wsActive = false;\n            this.currentUser\n                .tryAuthenticate()\n                .then(() => {\n                    this.snack('WebSocket connection closed, trying again in 30 seconds.');\n                    setTimeout(() => this.listen(callback), 30000);\n                })\n                .catch((error: AxiosError) => {\n                    if (error?.response?.status === 401) {\n                        this.snack('Could not authenticate with client token, logging out.');\n                    }\n                });\n        };\n\n        this.ws = ws;\n    };\n\n    public close = () => this.ws?.close(1000, 'WebSocketStore#close');\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class WebSocketStore {\n  wsActive: boolean;\n  ws: WebSocket | null;\n\n  constructor(snack: SnackReporter, currentUser: CurrentUser) {\n    this.wsActive = false;\n    this.ws = null;\n  }\n\n  listen(callback: (msg: IMessage) => void): void {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      this.connect(callback);\n    } else {\n      this.ws.onmessage = (event) => {\n        const message = JSON.parse(event.data);\n        callback(message);\n      };\n    }\n  }\n\n  close(): void {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.close(1000, \"Normal closure\");\n      this.ws = null;\n      this.wsActive = false;\n    }\n  }\n\n  private connect(callback: (msg: IMessage) => void): void {\n    this.ws = new WebSocket('wss://example.com/socket');\n\n    this.ws.onopen = () => {\n      this.wsActive = true;\n      this.ws.onmessage = (event) => {\n        const message = JSON.parse(event.data);\n        callback(message);\n      };\n    };\n\n    this.ws.onclose = () => {\n      this.wsActive = false;\n      setTimeout(() => this.connect(callback), 5000);\n    };\n\n    this.ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n      this.wsActive = false;\n      setTimeout(() => this.connect(callback), 5000);\n    };\n  }\n}"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a WebSocketRPC class that handles WebSocket communication for JSON-RPC 2.0 protocol, including connection management, message handling, and error recovery.\n\nClass Description: The WebSocketRPC class provides a wrapper around browser WebSocket API to facilitate JSON-RPC 2.0 communication. It manages WebSocket connections, handles message serialization/deserialization, and provides callback mechanisms for RPC operations.\n\nAttributes:\n- _: [Object] - Lodash/underscore utility library\n- JSON: [Object] - JSON object for serialization/deserialization\n- utils: [Object] - Utility functions including UUID generation\n- alerts: [Object] - Alert/notification system\n- initialized: [Boolean] - Connection status flag\n- handles: [Array] - Pending RPC request handlers\n- sock: [WebSocket|null] - WebSocket connection instance\n- conf: [Object|null] - Connection configuration\n- scheme: [String] - WebSocket protocol scheme (ws/wss)\n- onready: [Function|null] - Callback when connection is ready\n\nMethods:\n- onerror(ev): [Function]([Event]) -> [void] - Handles WebSocket errors and cleans up pending requests\n- onclose(ev): [Function]([Event]) -> [void] - Handles WebSocket connection closure\n- onopen(): [Function]() -> [void] - Handles successful WebSocket connection\n- onmessage(message): [Function]([MessageEvent]) -> [void] - Processes incoming WebSocket messages\n- invoke(opts): [Function]([Object]) -> [void] - Sends JSON-RPC request\n  - opts: [Object] - Request options containing:\n    - name: [String] - RPC method name\n    - params: [Array] - RPC parameters\n    - success: [Function] - Success callback\n    - error: [Function] - Error callback\n- init(conf, onready): [Function]([Object], [Function]) -> [void] - Initializes WebSocket connection\n  - conf: [Object] - Connection configuration containing:\n    - host: [String] - Server host\n    - port: [Number] - Server port\n    - path: [String] - Optional path\n    - encrypt: [Boolean] - Use SSL/TLS\n    - auth: [Object] - Optional authentication credentials\n      - user: [String] - Username\n      - pass: [String] - Password\n  - onready: [Function] - Callback when initialization completes",
    "Canonical_solution": "import angular from \"angular\";\n\nclass WebSocketRPC {\n  constructor(_, JSON, name, utils, alerts) {\n    this._ = _;\n    this.JSON = JSON;\n    this.utils = utils;\n    this.alerts = alerts;\n    \n    this.initialized = false;\n    this.handles = [];\n    this.sock = null;\n    this.conf = null;\n    this.scheme = \"ws\";\n    this.onready = null;\n  }\n\n  onerror(ev) {\n    this._.each(this.handles, function(h) {\n      h.error();\n    });\n    this.handles = [];\n    this.initialized = false;\n    if (this.onready) {\n      this.onready();\n      this.onready = null;\n    }\n  }\n\n  onclose(ev) {\n    if (this.handles && this.handles.length)\n      this.onerror(\"Connection reset while calling aria2\");\n    this.initialized = false;\n    if (this.onready) {\n      this.onready();\n      this.onready = null;\n    }\n  }\n\n  onopen() {\n    console.log(\"websocket initialized!!!\");\n    this.initialized = true;\n    if (this.onready) {\n      this.onready();\n      this.onready = null;\n    }\n  }\n\n  onmessage(message) {\n    var data = this.JSON.parse(message.data);\n\n    for (var i = this.handles.length - 1; i >= 0; i--) {\n      if (this.handles[i].id === data.id) {\n        this.handles[i].success(data);\n        this.handles.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  invoke(opts) {\n    var data = {\n      jsonrpc: 2.0,\n      id: this.utils.uuid(),\n      method: opts.name,\n      params: opts.params && opts.params.length ? opts.params : undefined\n    };\n\n    if (data.params && !data.params.length) data.params = undefined;\n\n    this.handles.push({\n      success: opts.success || angular.noop,\n      error: opts.error || angular.noop,\n      id: data.id\n    });\n    this.sock.send(this.JSON.stringify(data));\n  }\n\n  init(conf, onready) {\n    this.initialized = false;\n    if (this.onready) {\n      this.onready();\n      this.onready = null;\n    }\n\n    if (typeof WebSocket == \"undefined\") {\n      this.alerts.addAlert(\"Web sockets are not supported! Falling back to JSONP.\", \"info\");\n      onready();\n      return;\n    }\n    this.conf = conf || this.conf;\n    this.scheme = this.conf.encrypt ? \"wss\" : \"ws\";\n\n    if (this.sock) {\n      this.sock.onopen = this.sock.onmessage = this.sock.onerror = this.sock.onclose = null;\n      this.onerror({ message: \"Changing the websocket aria2 server details\" });\n    }\n\n    try {\n      var authUrl =\n        this.scheme + \"://\" + conf.host + \":\" + conf.port + (conf.path || \"/jsonrpc\");\n      if (this.conf.auth && this.conf.auth.user && this.conf.auth.pass) {\n        authUrl =\n          this.scheme +\n          \"://\" +\n          this.conf.auth.user +\n          \":\" +\n          this.conf.auth.pass +\n          \"@\" +\n          this.conf.host +\n          \":\" +\n          this.conf.port +\n          (conf.path || \"/jsonrpc\");\n      }\n\n      this.sock = new WebSocket(authUrl);\n      this.sock.onopen = this.onopen.bind(this);\n      this.sock.onclose = this.onclose.bind(this);\n      this.sock.onerror = this.onerror.bind(this);\n      this.sock.onmessage = this.onmessage.bind(this);\n      this.onready = onready;\n    } catch (ex) {\n      console.log(\"not using websocket for aria2 rpc due to: \", ex);\n      this.alerts.addAlert(\"Web sockets not working due to \" + ex.message, \"info\");\n      onready();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class WebSocketRPC {\n  constructor() {\n    this._ = {};\n    this.JSON = {};\n    this.utils = {};\n    this.alerts = {};\n    this.initialized = false;\n    this.handles = [];\n    this.sock = null;\n    this.conf = null;\n    this.scheme = 'ws';\n    this.onready = null;\n  }\n\n  onerror(ev) {\n    this.alerts.error('WebSocket error', ev);\n    this.close();\n  }\n\n  onclose(ev) {\n    this.alerts.info('WebSocket closed', ev);\n    this.initialized = false;\n    if (this.onready) this.onready();\n  }\n\n  onopen() {\n    this.initialized = true;\n    if (this.onready) this.onready();\n  }\n\n  onmessage(message) {\n    try {\n      const data = this.JSON.parse(message.data);\n      if (data.jsonrpc === '2.0') {\n        const id = data.id;\n        const handle = this.handles.find(h => h.id === id);\n        if (handle) {\n          if (data.result) {\n            handle.success(data.result);\n          } else if (data.error) {\n            handle.error(data.error.message);\n          }\n          this.handles = this.handles.filter(h => h.id !== id);\n        }\n      }\n    } catch (e) {\n      this.alerts.error('Message parsing error', e);\n    }\n  }\n\n  invoke(opts) {\n    const id = this.utils.uuid();\n    const request = {\n      jsonrpc: '2.0',\n      method: opts.name,\n      params: opts.params,\n      id\n    };\n    this.handles.push({ id, success: opts.success, error: opts.error });\n    this.sock.send(this.JSON.stringify(request));\n  }\n\n  init(conf, onready) {\n    this.conf = conf;\n    this.onready = onready;\n    this.sock = new WebSocket(this.scheme + '://' + conf.host + (conf.port ? ':' + conf.port : '') + (conf.path || '/'));\n    this.sock.onopen = () => this.onopen();\n    this.sock.onclose = (ev) => this.onclose(ev);\n    this.sock.onerror = (ev) => this.onerror(ev);\n    this.sock.onmessage = (message) => this.onmessage(message);\n  }\n}"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a WebSocket client class in JavaScript that establishes a connection to a server, handles communication events, and provides methods for sending data.\n\nClass Description: The NetWork class encapsulates WebSocket functionality for connecting to a server at a specified IP and port. It manages connection events (open, close, message) through configurable callbacks and provides methods for sending both structured and raw data.\n\nAttributes:\n- ip: string - The IP address of the WebSocket server\n- port: string|number - The port number of the WebSocket server\n- webSocket: WebSocket - The underlying WebSocket connection instance\n\nMethods:\n- constructor(ip, port) -> void - Initializes the NetWork instance with server connection details\n- connect(config) -> void - Establishes WebSocket connection and sets up event handlers\n  - config: object - Configuration object containing callback functions\n    - onopen: function - Called when connection is established\n    - onclose: function - Called when connection is closed\n    - onmessage: function - Called when message is received (receives message data)\n- request(name, argobj) -> void - Sends structured data to server in \"name://{json}\" format\n  - name: string - The message identifier/type\n  - argobj: object|null - Optional arguments to be sent as JSON\n- send(str) -> void - Sends raw string data to server\n  - str: string - The raw message to send",
    "Canonical_solution": "class NetWork {\n    constructor(ip, port) {\n        this.ip = ip\n        this.port = port\n    }\n\n    connect(config) {\n        let webSocket = new WebSocket(\"ws://\" + this.ip + \":\" + this.port)\n        webSocket.onopen = function() {\n            config.onopen()\n        }\n        webSocket.onclose = function() {\n            config.onclose()\n        }\n        webSocket.onmessage = function(data) { \n            config.onmessage(data)\n        }\n        this.webSocket = webSocket\n    }\n\n    request(name, argobj) {\n        let ss = name + \"://\" + (argobj ? JSON.stringify(argobj) : \"{}\");\n        this.webSocket.send(ss);\n    }\n\n    send(str) {\n        this.webSocket.send(str)\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class NetWork {\n  constructor(ip, port) {\n    this.ip = ip;\n    this.port = port;\n    this.webSocket = new WebSocket(`ws://${ip}:${port}`);\n  }\n\n  connect(config) {\n    this.webSocket.onopen = config.onopen;\n    this.webSocket.onclose = config.onclose;\n    this.webSocket.onmessage = (event) => {\n      if (config.onmessage) {\n        config.onmessage(event.data);\n      }\n    };\n  }\n\n  request(name, argobj) {\n    const data = `name://${JSON.stringify(argobj)}`;\n    this.webSocket.send(data);\n  }\n\n  send(str) {\n    this.webSocket.send(str);\n  }\n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a WebSocket client connection class for browser environments that handles connection lifecycle, message events, and window focus state tracking.\n\nClass Description: The BrowserConnection class manages a WebSocket connection in a browser environment, including connection setup, event handling, and window visibility tracking. It extends a base connection class (BaseConnection) and adds browser-specific functionality.\n\nAttributes:\n- focusDetectorTimer: [Number] - Timer ID for the focus detection interval\n- windowVisible: [Boolean] - Tracks whether the browser window is currently visible\n- socket: [WebSocket] - The WebSocket connection instance\n\nMethods:\n- constructor(opts: Object) -> void - Initializes the connection with options and sets up event listeners for 'ready' and 'disconnect' events\n- setupSocket() -> WebSocket - Creates and configures a new WebSocket connection with event handlers for open, close, and message events\n- startFocusLoop() -> void - Starts tracking window visibility by setting up event listeners for focus/blur events and periodic checks\n- stopFocusLoop() -> void - Stops the window visibility tracking by clearing the interval timer and removing event listeners\n- handleOpen() -> void - Inherited from BaseConnection, called when WebSocket connection opens\n- handleClose(code: Number, reason: String) -> void - Inherited from BaseConnection, called when WebSocket connection closes\n- handleData(data: String) -> void - Inherited from BaseConnection, called when WebSocket receives a message\n- reportFocus(isVisible: Boolean) -> void - Inherited from BaseConnection, reports current window focus state",
    "Canonical_solution": "var WebSocket = require(\"ws\");\nvar _ = require(\"underscore\");\n\nclass BrowserConnection {\n  constructor(opts) {\n    BaseConnection.call(this, opts);\n    var connection = this;\n    this.on(\"ready\", function() {\n      connection.startFocusLoop()\n    });\n    this.on(\"disconnect\", function() {\n      connection.stopFocusLoop()\n    });\n  }\n\n  setupSocket() {\n    var connection = this;\n    var socket = new WebSocket(this.getUrl());\n    socket.onopen = function() {\n      connection.handleOpen()\n    };\n    socket.onclose = function(data) {\n      connection.handleClose(data[\"code\"], data[\"reason\"])\n    };\n    socket.onmessage = function(message) {\n      connection.handleData(message.data)\n    };\n    return socket;\n  }\n\n  startFocusLoop() {\n    if (this.focusDetectorTimer) return;\n    var connection = this;\n    var propertyName = null;\n    if (typeof document.hidden !== \"undefined\") {\n      propertyName = \"hidden\"\n    } else if (typeof document.mozHidden !== \"undefined\") {\n      propertyName = \"mozHidden\"\n    } else if (typeof document.msHidden !== \"undefined\") {\n      propertyName = \"msHidden\"\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n      propertyName = \"webkitHidden\"\n    } else {\n      propertyName = undefined\n    }\n    if (connection.windowVisible === undefined) {\n      connection.windowVisible = propertyName === undefined ? true : document[propertyName] === false\n    }\n    var focusListener = window.addEventListener(\"focus\", function(e) {\n      connection.windowVisible = true;\n      updateFocusState()\n    });\n    var blurListener = window.addEventListener(\"blur\", function(e) {\n      connection.windowVisible = false;\n      updateFocusState()\n    });\n    this.on(\"disconnect\", function() {\n      window.removeEventListener(\"focus\", focusListener);\n      window.removeEventListener(\"blur\", blurListener)\n    });\n    var updateFocusState = function() {\n      var isVisible = propertyName === undefined ? true : document[propertyName] === false;\n      connection.reportFocus(isVisible && connection.windowVisible)\n    };\n    this.focusDetectorTimer = setInterval(updateFocusState, 100)\n  }\n\n  stopFocusLoop() {\n    if (!this.focusDetectorTimer) return;\n    clearTimeout(this.focusDetectorTimer);\n    delete this.focusDetectorTimer;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class BrowserConnection extends BaseConnection {\n  focusDetectorTimer = 0;\n  windowVisible = true;\n  socket = null;\n\n  constructor(opts) {\n    super(opts);\n    this.setupSocket();\n    this.startFocusLoop();\n  }\n\n  setupSocket() {\n    this.socket = new WebSocket(this.opts.url);\n    this.socket.onopen = () => this.handleOpen();\n    this.socket.onclose = (event) => this.handleClose(event.code, event.reason);\n    this.socket.onmessage = (event) => this.handleData(event.data);\n  }\n\n  startFocusLoop() {\n    this.focusDetectorTimer = setInterval(() => {\n      this.windowVisible = document.hasFocus();\n      this.reportFocus(this.windowVisible);\n    }, 1000);\n  }\n\n  stopFocusLoop() {\n    clearInterval(this.focusDetectorTimer);\n    this.focusDetectorTimer = 0;\n  }\n\n  handleOpen() {\n    super.handleOpen();\n    this.reportFocus(this.windowVisible);\n  }\n\n  handleClose(code, reason) {\n    super.handleClose(code, reason);\n    this.stopFocusLoop();\n  }\n\n  handleData(data) {\n    super.handleData(data);\n  }\n\n  reportFocus(isVisible) {\n    super.reportFocus(isVisible);\n  }\n}"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Create a function to establish and manage a WebSocket connection in a browser environment, including handling connection events, sending messages, and closing the connection.\n\nFunction Description: The function `setupWebSocketConnection` initializes a WebSocket connection to a specified URL and provides methods to interact with the connection. It sets up event handlers for connection events (`open`, `message`, `close`, `error`) and returns an object with methods to send data, close the connection, and set the binary type of the WebSocket.\n\nInput: \n- `url` [String] - The URL to which the WebSocket connection will be established.\n\nOutput: \n- Returns an object with the following methods:\n  - `send(data)` - Sends data through the WebSocket connection.\n  - `close()` - Closes the WebSocket connection.\n  - `setBinaryType(type)` - Sets the binary type of the WebSocket connection (`blob` or `arraybuffer`).",
    "Canonical_solution": "function setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  \n  ws.onopen = function() {\n    alert('open');\n  };\n  \n  ws.onmessage = function(message) {\n    alert(message.data);\n  };\n  \n  ws.onclose = function() {\n    alert('close');\n  };\n  \n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    send: function(data) {\n      ws.send(data);\n    },\n    close: function() {\n      ws.close();\n    },\n    setBinaryType: function(type) {\n      ws.binaryType = type;\n    }\n  };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "{\n  setupWebSocketConnection: function(url) {\n    const ws = new WebSocket(url);\n    const connection = {\n      send: function(data) {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(data);\n        }\n      },\n      close: function() {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.close();\n        }\n      },\n      setBinaryType: function(type) {\n        if (type === 'blob' || type === 'arraybuffer') {\n          ws.binaryType = type;\n        }\n      }\n    };\n\n    ws.onopen = function(event) {\n      console.log('Connection opened:', event);\n    };\n\n    ws.onmessage = function(event) {\n      console.log('Message received:', event.data);\n    };\n\n    ws.onclose = function(event) {\n      console.log('Connection closed:', event);\n    };\n\n    ws.onerror = function(error) {\n      console.error('Error occurred:', error);\n    };\n\n    return connection;\n  }\n}"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, listens for incoming messages, and sends user input from a text box when the Enter key is pressed.\n\nFunction Description: The function `setupWebSocket` initializes a WebSocket connection to a specified server URL. It sets up an event listener for incoming messages to display them in a designated HTML element. Additionally, it listens for the Enter key press in a text box to send the input text via the WebSocket connection and clears the text box afterward.\n\nInput: None (The function uses DOM elements with IDs \"txt\" and \"divOut\" for text input and message display, respectively.)\n\nOutput: None (The function's side effects include establishing a WebSocket connection, displaying received messages in the \"divOut\" element, and sending user input to the server.)",
    "Canonical_solution": "function setupWebSocket() {\n    const txtBox = document.getElementById(\"txt\");\n    const divOut = document.getElementById(\"divOut\");\n    const ws = new WebSocket(\"ws://localhost/wsapp/\");\n    \n    ws.onmessage = function(e) {\n        divOut.innerHTML += e.data + \"<br/>\";\n    };\n    \n    txtBox.addEventListener(\"keypress\", function(e) {\n        if (e.keyCode === 13) {\n            ws.send(txtBox.value);\n            txtBox.value = \"\";\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function setupWebSocket() {\n  const ws = new WebSocket('ws://example.com/socket');\n  \n  ws.onmessage = function(event) {\n    document.getElementById('divOut').innerText += event.data + '\\n';\n  };\n  \n  document.getElementById('txt').addEventListener('keydown', function(event) {\n    if (event.key === 'Enter') {\n      const input = this.value;\n      ws.send(input);\n      this.value = '';\n    }\n  });\n}"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, sends messages, and handles incoming messages, connection events, and errors.\n\nFunction Description: The WebSocket client connects to a specified URI using a custom protocol, provides functions to send messages, and includes event handlers for connection opening, message reception, and errors.\n\nInput:\n- `wsUri` (String): The WebSocket server URI to connect to (e.g., \"ws://example.com/socket\").\n- `myProtocol` (String): The subprotocol to use for the WebSocket connection (e.g., \"myProtocol\").\n- `myField.value` (String): The message to be sent to the server (provided via an input field in the UI).\n\nOutput:\n- Console/log output indicating connection status, sent messages, received messages, and errors.\n- No explicit return value; side effects include WebSocket communication and logging.\n\nMethods (implicit in the reference code):\n- `echoText()` -> undefined - Sends the value of `myField` to the WebSocket server and logs the sent message.\n- `onOpen(evt)` -> undefined - Logs when the WebSocket connection is successfully established.\n- `onMessage(evt)` -> undefined - Logs messages received from the WebSocket server.\n- `onError(evt)` -> undefined - Logs errors encountered during WebSocket communication.",
    "Canonical_solution": "function echoText() {\n    websocket.send(myField.value);\n    writeToScreen(\"SENT: \" + myField.value);\n}\n\nfunction onOpen() {\n    writeToScreen(\"CONNECTED\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen(\"RECEIVED: \" + evt.data);\n}\n\nfunction onError(evt) {\n    writeToScreen('<span style=\"color: red;\">ERROR:</span> ' + evt.data);\n}\n\nvar websocket = new WebSocket(wsUri, \"myProtocol\");\nwebsocket.onopen = function(evt) { onOpen(evt) };\nwebsocket.onmessage = function(evt) { onMessage(evt) };\nwebsocket.onerror = function(evt) { onError(evt) };",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "ws = new WebSocket(wsUri, myProtocol);\n\nws.onopen = function(evt) {\n  console.log(\"Connection opened\");\n  echoText();\n};\n\nws.onmessage = function(evt) {\n  console.log(\"Received message:\", evt.data);\n};\n\nws.onerror = function(evt) {\n  console.error(\"Error occurred:\", evt.message);\n};\n\nfunction echoText() {\n  var message = myField.value;\n  ws.send(message);\n  console.log(\"Sent message:\", message);\n}"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a WebSocket client class in JavaScript that manages WebSocket connections, including connection establishment, message handling, error handling, and reconnection logic.\n\nClass Description: The S class is a custom HTMLElement that encapsulates WebSocket functionality. It handles WebSocket connection lifecycle events, message processing (both text and binary), automatic reconnection, and provides methods for sending data.\n\nAttributes:\n- wsState: [Number] - Tracks the current state of the WebSocket connection (CLOSED, CONNECTING, OPEN)\n- ws: [WebSocket|null] - The active WebSocket connection instance\n- wsURL: [String] - The URL for the WebSocket server connection\n- onmessage: [Object|null] - Callback functions for handling incoming messages\n- connectTS: [Number] - Timestamp of when the connection was initiated\n- reconnectTID: [Number] - Timeout ID for reconnection attempts\n- RECONNECT_TIMEOUT: [Number] - Constant for reconnection delay (implied but not shown in code)\n- ondata: [Function|null] - Callback for binary data handling\n\nMethods:\n- onconnect() -> [Boolean] - Initiates a WebSocket connection. Returns true if connection attempt started.\n- onopen() -> [void] - Handles WebSocket open event, sets up message listeners.\n- onclose() -> [Boolean] - Handles WebSocket close event, initiates reconnection. Returns true if reconnection scheduled.\n- ondisconnect() -> [void] - Closes the WebSocket connection and cleans up resources.\n- send(e: [Object]) -> [void] - Sends a JSON-serialized message through the WebSocket connection.",
    "Canonical_solution": "class S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = WebSocket.CLOSED;\n    this.ws = null;\n    this.wsURL = \"\";\n    this.onmessage = null;\n  }\n\n  onconnect() {\n    if (!this.isConnected || !this.wsURL || this.ws || this.pc) return false;\n    \n    this.wsState = WebSocket.CONNECTING;\n    this.connectTS = Date.now();\n    this.ws = new WebSocket(this.wsURL);\n    this.ws.binaryType = \"arraybuffer\";\n    \n    this.ws.addEventListener(\"open\", (e) => this.onopen(e));\n    this.ws.addEventListener(\"close\", (e) => this.onclose(e));\n    \n    return true;\n  }\n\n  onopen() {\n    this.wsState = WebSocket.OPEN;\n    \n    this.ws.addEventListener(\"message\", (e) => {\n      if (\"string\" == typeof e.data) {\n        const t = JSON.parse(e.data);\n        for (const e in this.onmessage) this.onmessage[e](t);\n      } else {\n        this.ondata(e.data);\n      }\n    });\n    \n    this.ondata = null;\n    this.onmessage = {};\n  }\n\n  onclose() {\n    if (this.wsState === WebSocket.CLOSED) return false;\n    \n    this.wsState = WebSocket.CONNECTING;\n    this.ws = null;\n    \n    const e = Math.max(this.RECONNECT_TIMEOUT - (Date.now() - this.connectTS), 0);\n    this.reconnectTID = setTimeout(() => {\n      this.reconnectTID = 0;\n      this.onconnect();\n    }, e);\n    \n    return true;\n  }\n\n  ondisconnect() {\n    this.wsState = WebSocket.CLOSED;\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n\n  send(e) {\n    this.ws && this.ws.send(JSON.stringify(e));\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = 0; // 0: CLOSED, 1: CONNECTING, 2: OPEN\n    this.ws = null;\n    this.wsURL = '';\n    this.onmessage = null;\n    this.connectTS = 0;\n    this.reconnectTID = 0;\n    this.RECONNECT_TIMEOUT = 5000;\n    this.ondata = null;\n  }\n\n  onconnect() {\n    if (this.wsState !== 0) return false;\n    this.connectTS = Date.now();\n    this.ws = new WebSocket(this.wsURL);\n    this.ws.onopen = () => this.onopen();\n    this.ws.onmessage = (event) => {\n      if (this.onmessage) this.onmessage(event);\n      if (this.ondata && event.data instanceof ArrayBuffer) this.ondata(event);\n    };\n    this.ws.onerror = (error) => this.onclose();\n    this.ws.onclose = () => this.onclose();\n    return true;\n  }\n\n  onopen() {\n    this.wsState = 2;\n    if (this.onmessage) this.onmessage({ data: 'Connection established' });\n  }\n\n  onclose() {\n    this.wsState = 0;\n    if (this.reconnectTID) clearTimeout(this.reconnectTID);\n    this.reconnectTID = setTimeout(() => {\n      if (this.onconnect()) this.onopen();\n    }, this.RECONNECT_TIMEOUT);\n    if (this.onmessage) this.onmessage({ data: 'Connection closed' });\n    return true;\n  }\n\n  ondisconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n\n  send(e) {\n    if (this.ws && this.ws.readyState === this.ws.OPEN) {\n      this.ws.send(JSON.stringify(e));\n    }\n  }\n}"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Implement a WebSocket client class for streaming timeline data from a server, handling connection events, message parsing, and connection cleanup.\n\nClass Description: The TimelineStream class establishes and manages a WebSocket connection to stream timeline data from a specified API endpoint. It handles connection setup, message reception, error handling, and proper connection closure.\n\nAttributes:\n- _streamingApi: [String] - The base URL of the streaming API server\n- _accessToken: [String] - Authentication token for the API connection\n- _timeline: [String] - Identifier for the specific timeline stream\n- _ws: [WebSocketClient] - Instance of the WebSocket connection\n- _opened: [Boolean] - Flag indicating if the connection is established\n\nMethods:\n- constructor(streamingApi, accessToken, timeline) -> [TimelineStream] - Initializes a new TimelineStream instance with API details and sets up the WebSocket connection\n- _setupWebSocket() -> [void] - Creates a new WebSocket connection, configures event handlers for open, message, and close events\n- _closeWebSocket() -> [void] - Properly closes the WebSocket connection and cleans up event handlers\n- sendMessage(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Public method to close the WebSocket connection",
    "Canonical_solution": "import { WebSocketClient } from '../../_thirdparty/websocket/websocket.js'\nimport { getStreamUrl } from './getStreamUrl.js'\nimport { safeParse } from '../../_utils/safeParse.js'\n\nclass TimelineStream {\n  constructor (streamingApi, accessToken, timeline) {\n    this._streamingApi = streamingApi\n    this._accessToken = accessToken\n    this._timeline = timeline\n    this._setupWebSocket()\n  }\n\n  _setupWebSocket () {\n    const url = getStreamUrl(this._streamingApi, this._accessToken, this._timeline)\n    const ws = new WebSocketClient(url)\n\n    ws.onopen = () => {\n      if (!this._opened) {\n        this._opened = true\n      }\n    }\n    ws.onmessage = (e) => safeParse(e.data)\n    ws.onclose = () => {}\n\n    this._ws = ws\n  }\n\n  _closeWebSocket () {\n    if (this._ws) {\n      this._ws.onopen = null\n      this._ws.onmessage = null\n      this._ws.onclose = null\n      this._ws.close()\n      this._ws = null\n    }\n  }\n\n  sendMessage (message) {\n    if (this._ws && this._ws.readyState === WebSocketClient.OPEN) {\n      this._ws.send(message)\n    }\n  }\n\n  close () {\n    this._closeWebSocket()\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class TimelineStream {\n  constructor(streamingApi, accessToken, timeline) {\n    this._streamingApi = streamingApi;\n    this._accessToken = accessToken;\n    this._timeline = timeline;\n    this._ws = null;\n    this._opened = false;\n    this._setupWebSocket();\n  }\n\n  _setupWebSocket() {\n    this._ws = new WebSocket(this._streamingApi);\n    this._ws.onopen = () => {\n      this._opened = true;\n      this._ws.send(JSON.stringify({ access_token: this._accessToken, timeline: this._timeline }));\n    };\n\n    this._ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      // Handle incoming message\n      console.log('Received message:', data);\n    };\n\n    this._ws.onclose = () => {\n      this._opened = false;\n      console.log('WebSocket connection closed');\n    };\n\n    this._ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n  }\n\n  _closeWebSocket() {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN) {\n      this._ws.close();\n    }\n  }\n\n  sendMessage(message) {\n    if (this._opened) {\n      this._ws.send(JSON.stringify(message));\n    } else {\n      console.warn('Cannot send message: connection is not open');\n    }\n  }\n\n  close() {\n    this._closeWebSocket();\n  }\n}"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Implement a WebSocket client class for managing connections, sending messages, and handling events in a browser environment using JavaScript.\n\nClass Description: MonitorManagerProxyClientImpl is a WebSocket client implementation that manages WebSocket connections, handles incoming messages, and provides methods for sending data and changing settings. It uses event emitters to notify about received messages and settings changes.\n\nAttributes:\n- webSocket: WebSocket | undefined - The active WebSocket connection instance\n- wsPort: number | undefined - The port number used for the WebSocket connection\n\nMethods:\n- connect(addressPort: number) -> Promise<void> - Establishes a WebSocket connection to the specified port. Returns a promise that resolves when connected or rejects on error.\n- disconnect() -> void - Closes the active WebSocket connection if it exists.\n- send(message: string) -> void - Sends a message through the WebSocket connection after formatting it with a command structure.\n- changeSettings(settings: MonitorSettings) -> void - Sends settings changes through the WebSocket connection.\n- isWSConnected() -> Promise<boolean> - Checks if the WebSocket connection is active.\n- getWebSocketPort() -> number | undefined - Returns the port number used for the current WebSocket connection.",
    "Canonical_solution": "@injectable()\nexport class MonitorManagerProxyClientImpl implements MonitorManagerProxyClient {\n  private webSocket?: WebSocket;\n  private wsPort?: number;\n\n  async connect(addressPort: number): Promise<void> {\n    if (this.webSocket) {\n      if (this.wsPort === addressPort) {\n        return;\n      }\n      this.disconnect();\n    }\n    try {\n      this.webSocket = new WebSocket(`ws://localhost:${addressPort}`);\n    } catch {\n      throw new Error('Unable to connect to websocket');\n    }\n\n    const opened = new Deferred<void>();\n    this.webSocket.onopen = () => opened.resolve();\n    this.webSocket.onerror = () => opened.reject();\n    this.webSocket.onmessage = (message) => {\n      const parsedMessage = JSON.parse(message.data);\n      if (Array.isArray(parsedMessage)) {\n        this.onMessagesReceivedEmitter.fire({ messages: parsedMessage });\n      } else if (\n        parsedMessage.command === Monitor.MiddlewareCommand.ON_SETTINGS_DID_CHANGE\n      ) {\n        this.onMonitorSettingsDidChangeEmitter.fire(parsedMessage.data);\n      }\n    };\n    this.wsPort = addressPort;\n    return opened.promise;\n  }\n\n  disconnect(): void {\n    if (!this.webSocket) {\n      return;\n    }\n    try {\n      this.webSocket.close();\n      this.webSocket = undefined;\n    } catch (err) {\n      console.error('Could not close the websocket connection for the monitor.', err);\n      throw new Error('Unable to close websocket');\n    }\n  }\n\n  send(message: string): void {\n    if (!this.webSocket) {\n      return;\n    }\n    this.webSocket.send(\n      JSON.stringify({\n        command: Monitor.ClientCommand.SEND_MESSAGE,\n        data: message,\n      })\n    );\n  }\n\n  changeSettings(settings: MonitorSettings): void {\n    if (!this.webSocket) {\n      return;\n    }\n    this.webSocket.send(\n      JSON.stringify({\n        command: Monitor.ClientCommand.CHANGE_SETTINGS,\n        data: settings,\n      })\n    );\n  }\n\n  async isWSConnected(): Promise<boolean> {\n    return !!this.webSocket;\n  }\n\n  getWebSocketPort(): number | undefined {\n    return this.wsPort;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class MonitorManagerProxyClientImpl {\n  webSocket: WebSocket | undefined;\n  wsPort: number | undefined;\n\n  connect(addressPort: number): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.wsPort = addressPort;\n      this.webSocket = new WebSocket(`ws://localhost:${addressPort}`);\n      \n      this.webSocket.onopen = () => {\n        resolve();\n      };\n\n      this.webSocket.onerror = (error) => {\n        reject(error);\n      };\n    });\n  }\n\n  disconnect(): void {\n    if (this.webSocket) {\n      this.webSocket.close();\n      this.webSocket = undefined;\n      this.wsPort = undefined;\n    }\n  }\n\n  send(message: string): void {\n    if (this.webSocket) {\n      this.webSocket.send(message);\n    }\n  }\n\n  changeSettings(settings: MonitorSettings): void {\n    if (this.webSocket) {\n      this.webSocket.send(JSON.stringify({ type: 'settings', data: settings }));\n    }\n  }\n\n  isWSConnected(): Promise<boolean> {\n    return new Promise((resolve) => {\n      if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n        resolve(true);\n      } else {\n        resolve(false);\n      }\n    });\n  }\n\n  getWebSocketPort(): number | undefined {\n    return this.wsPort;\n  }\n}"
  },
  {
    "Task_id": 246,
    "Instruction": "Task Description: Implement a WebSocket client for audio streaming and transcription that connects to a server, handles real-time audio capture, and processes server responses for transcription and status updates.\n\nFunction Description: The `startRecording` function initializes a WebSocket connection to a specified server, configures audio capture from the user's microphone, and handles bidirectional communication with the server for audio streaming and transcription services. It manages connection events, server status updates, and transcription results while handling errors and disconnections gracefully.\n\nInput:\n- `data`: [Object] - Configuration object containing:\n  - `host`: [String] - WebSocket server host address\n  - `port`: [String|Number] - WebSocket server port\n  - `language`: [String] - Preferred language for transcription\n  - `task`: [String] - Task type (e.g., \"transcription\")\n  - `modelSize`: [String] - Model size specification\n  - `useVad`: [Boolean] - Flag for voice activity detection\n\nOutput:\n- None (Void) - The function establishes persistent connections and event handlers but doesn't return a value. Results are handled through:\n  - Browser runtime messages (via `browser.runtime.sendMessage`)\n  - WebSocket events (onmessage, onerror, etc.)\n  - Audio processing callbacks\n\nSide Effects:\n- Creates a WebSocket connection to the specified server\n- Requests microphone permissions and initializes audio capture\n- Modifies browser state through runtime messages\n- Maintains connection state internally through variables (`isServerReady`, `isCapturing`, etc.)",
    "Canonical_solution": "function startRecording(data) {\n    socket = new WebSocket(`ws://${data.host}:${data.port}/`);\n    language = data.language;\n\n    const uuid = generateUUID();\n    socket.onopen = function(e) { \n      socket.send(\n        JSON.stringify({\n            uid: uuid,\n            language: data.language,\n            task: data.task,\n            model: data.modelSize,\n            use_vad: data.useVad\n        })\n      );\n    };\n\n    let isServerReady = false;\n    socket.onmessage = async (event) => {\n      const data = JSON.parse(event.data);\n      if (data[\"uid\"] !== uuid)\n        return;\n      \n      if (data[\"status\"] === \"WAIT\"){\n        await browser.runtime.sendMessage({ action: \"showPopup\", data: data[\"message\"] })\n        return;\n      }\n      \n      if (!isServerReady && data[\"message\"] === \"SERVER_READY\"){\n        isServerReady = true;\n        return;\n      }\n\n      if (language === null ){\n        language = data[\"language\"];\n        await browser.runtime.sendMessage({ action: \"updateSelectedLanguage\", data: language })      \n        return\n      }\n\n      if (data[\"message\"] === \"DISCONNECT\"){\n        await browser.runtime.sendMessage({ action: \"toggleCaptureButtons\", data: false })        \n        return\n      }\n\n      await browser.runtime.sendMessage({ action: \"transcript\", data: event.data })\n          .catch(function(error) {\n            console.error(\"Error sending message:\", error);\n          });\n    };\n\n  navigator.mediaDevices.getUserMedia({ audio: true })\n    .then(function(stream) {\n      const audioDataCache = [];\n      audioContext = new AudioContext();\n      mediaStream = audioContext.createMediaStreamSource(stream);\n      recorder = audioContext.createScriptProcessor(4096, 1, 1);\n\n      recorder.onaudioprocess = async (event) => {\n        if (!audioContext || !isCapturing || !isServerReady || isPaused) return;\n\n        const inputData = event.inputBuffer.getChannelData(0);\n        const audioData16kHz = resampleTo16kHZ(inputData, audioContext.sampleRate);\n\n        audioDataCache.push(inputData);\n        \n        socket.send(audioData16kHz);\n      };\n\n      mediaStream.connect(recorder);\n      recorder.connect(audioContext.destination);\n    })\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function startRecording(data) {\n  const { host, port, language, task, modelSize, useVad } = data;\n  let isServerReady = false;\n  let isCapturing = false;\n  let mediaStream = null;\n  let audioContext = null;\n  let audioSource = null;\n  let audioBuffer = null;\n\n  navigator.mediaDevices.getUserMedia({ audio: true })\n    .then(stream => {\n      mediaStream = stream;\n      audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      audioSource = audioContext.createMediaStreamSource(stream);\n      audioSource.connect(audioContext.destination);\n      isCapturing = true;\n      browser.runtime.sendMessage({ type: 'microphone_permitted' });\n    })\n    .catch(err => {\n      console.error('Microphone access denied:', err);\n      browser.runtime.sendMessage({ type: 'microphone_denied' });\n    });\n\n  const ws = new WebSocket(`ws://${host}:${port}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    isServerReady = true;\n    if (isCapturing) {\n      startAudioStreaming();\n    }\n  };\n\n  ws.onmessage = event => {\n    const response = JSON.parse(event.data);\n    if (response.type === 'transcription') {\n      browser.runtime.sendMessage({ type: 'transcription_result', text: response.text });\n    } else if (response.type === 'status') {\n      browser.runtime.sendMessage({ type: 'server_status', status: response.status });\n    }\n  };\n\n  ws.onerror = error => {\n    console.error('WebSocket error:', error);\n    browser.runtime.sendMessage({ type: 'websocket_error', error: error.message });\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n    isServerReady = false;\n    if (isCapturing) {\n      stopAudioStreaming();\n    }\n  };\n\n  function startAudioStreaming() {\n    const options = {\n      language,\n      task,\n      modelSize,\n      useVad\n    };\n\n    ws.send(JSON.stringify({ type: 'start_streaming', options }));\n  }\n\n  function stopAudioStreaming() {\n    ws.send(JSON.stringify({ type: 'stop_streaming' }));\n  }\n\n  function pauseAudioStreaming() {\n    ws.send(JSON.stringify({ type: 'pause_streaming' }));\n  }\n\n  function resumeAudioStreaming() {\n    ws.send(JSON.stringify({ type: 'resume_streaming' }));\n  }\n\n  function sendAudioChunk(chunk) {\n    ws.send(JSON.stringify({ type: 'audio_chunk', chunk }));\n  }\n\n  function sendTranscriptionRequest() {\n    ws.send(JSON.stringify({ type: 'transcription_request' }));\n  }\n\n  function sendStatusUpdate(status) {\n    ws.send(JSON.stringify({ type: 'status_update', status }));\n  }\n}"
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Implement a WebSocket client class for managing connections to a chat service, handling message exchange, and maintaining connection state.\n\nClass Description: The `BingChatWebSocket` class provides functionality to establish, maintain, and close WebSocket connections to a chat service. It manages multiple connections through unique socket IDs and supports sending messages, receiving responses, and connection health checks.\n\nAttributes:\n- `webSockets`: Record<string, WebSocket | null> - A dictionary mapping socket IDs to their corresponding WebSocket connections, allowing management of multiple connections.\n\nMethods:\n- `getSocketId()`: () -> Promise<string> - Establishes a new WebSocket connection, initializes it with a handshake message, and returns a unique socket ID for the connection. Handles connection errors and validation.\n- `ping(socketId: string)`: (string) -> Promise<void> - Sends a ping message to the WebSocket connection identified by `socketId` to maintain or check the connection.\n- `send(socketId: string, msg: object, onMessage: (data: any) => void)`: (string, object, function) -> Promise<any> - Sends a message through the WebSocket connection identified by `socketId` and sets up a callback `onMessage` to handle incoming messages. Resolves when a type 2 message is received.\n- `close(socketId: string)`: (string) -> Promise<void> - Closes the WebSocket connection identified by `socketId` and cleans up its reference in the `webSockets` dictionary.",
    "Canonical_solution": "import { v4 as uuidv4 } from 'uuid';\n\nclass BingChatWebSocket {\n  private webSockets: Record<string, WebSocket | null> = {};\n\n  async getSocketId(): Promise<string> {\n    const socketUrl = 'wss://sydney.bing.com/sydney/ChatHub';\n    return await new Promise((resolve, reject) => {\n      try {\n        const ws = new WebSocket(socketUrl);\n        const socketId = uuidv4();\n        \n        ws.onopen = (_e) => {\n          const hello = JSON.stringify({ protocol: 'json', version: 1 }) + '\\x1e';\n          ws.send(hello);\n        };\n\n        ws.onclose = () => {\n          this.webSockets[socketId] = null;\n        };\n        \n        ws.onerror = (e) => {\n          if (e.type === 'error') {\n            reject(new Error(`WebSocket \\`${socketUrl}\\` did not connect successfully.`));\n            return;\n          }\n          reject(e);\n        };\n\n        ws.onmessage = (e) => {\n          const msg = e.data;\n          if (msg === '{}\\x1e') {\n            this.webSockets[socketId] = ws;\n            resolve(socketId);\n            return;\n          }\n          ws.close();\n          this.webSockets[socketId] = null;\n          reject(new Error('WebSocket did not connect successfully'));\n        };\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  async ping(socketId: string): Promise<void> {\n    return await new Promise((resolve, _reject) => {\n      const ws = this.webSockets[socketId];\n      if (ws == null) throw new Error(`WebSocket ${socketId} not found`);\n\n      ws.send(JSON.stringify({ type: 6 }) + '\\x1e');\n      resolve(null);\n    });\n  }\n\n  async send(\n    socketId: string,\n    msg: object,\n    onMessage: (data: any) => void\n  ): Promise<any> {\n    return await new Promise((resolve, _reject) => {\n      const ws = this.webSockets[socketId];\n      if (ws == null) throw new Error(`WebSocket ${socketId} not found`);\n\n      ws.onmessage = (e) => {\n        const msg = e.data;\n        for (const item of msg.split('\\x1e').filter(Boolean)) {\n          const data = JSON.parse(item.replaceAll('\\n', '\\\\n'));\n          onMessage(data);\n\n          if (data.type === 2) {\n            setTimeout(() => {\n              resolve(data);\n            });\n          }\n        }\n      };\n      ws.send(JSON.stringify(msg) + '\\x1e');\n    });\n  }\n\n  async close(socketId: string): Promise<void> {\n    const ws = this.webSockets[socketId];\n    ws?.close();\n    this.webSockets[socketId] = null;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class BingChatWebSocket {\n  webSockets: Record<string, WebSocket | null> = {};\n\n  async getSocketId(): Promise<string> {\n    const socketId = this.generateSocketId();\n    try {\n      const ws = new WebSocket(`wss://chat.example.com`);\n      ws.onopen = () => {\n        this.webSockets[socketId] = ws;\n        ws.send(JSON.stringify({ type: 'handshake' }));\n      };\n      ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        this.webSockets[socketId] = null;\n      };\n      ws.onclose = () => {\n        this.webSockets[socketId] = null;\n      };\n      return socketId;\n    } catch (error) {\n      throw new Error('Failed to establish WebSocket connection');\n    }\n  }\n\n  generateSocketId(): string {\n    return Math.random().toString(36).substr(2, 9);\n  }\n\n  ping(socketId: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!this.webSockets[socketId]) {\n        reject(new Error('No active connection for the given socket ID'));\n        return;\n      }\n      const ws = this.webSockets[socketId];\n      ws.ping(() => {\n        resolve();\n      });\n    });\n  }\n\n  send(socketId: string, msg: object, onMessage: (data: any) => void): Promise<any> {\n    return new Promise((resolve, reject) => {\n      if (!this.webSockets[socketId]) {\n        reject(new Error('No active connection for the given socket ID'));\n        return;\n      }\n      const ws = this.webSockets[socketId];\n      ws.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        if (data.type === 2) {\n          onMessage(data);\n          resolve(data);\n        }\n      };\n      ws.send(JSON.stringify(msg));\n    });\n  }\n\n  close(socketId: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!this.webSockets[socketId]) {\n        reject(new Error('No active connection for the given socket ID'));\n        return;\n      }\n      const ws = this.webSockets[socketId];\n      ws.close();\n      this.webSockets[socketId] = null;\n      resolve();\n    });\n  }\n}"
  },
  {
    "Task_id": 248,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages communication with a Python backend server for executing and debugging Python code, handling console output, and managing kernel operations.\n\nClass Description: The PythonWebSocket class provides functionality to establish a WebSocket connection to a Python backend, execute Python code, handle debugging operations, manage console output, and control the Python kernel (restarting/interrupting). It maintains state about the current execution and provides methods to interact with the WebSocket server.\n\nAttributes:\n- running: [Boolean] - Indicates whether Python code is currently being executed\n- restarting: [Boolean] - Indicates whether the kernel is currently restarting\n- consoleData: [Array] - Stores console output messages with line numbers\n- wsOpen: [Boolean] - Indicates whether the WebSocket connection is open\n- ws: [WebSocket|null] - The WebSocket connection instance\n- lineno: [Object] - Tracks line numbers during debugging (offset and current)\n- editor: [Object] - Reference to the code editor instance (assumed to be set externally)\n\nMethods:\n- initPythonWebSocket() -> [void] - Initializes the WebSocket connection and sets up event handlers for open, message, and close events\n- runPython(code: String) -> [Promise] - Sends Python code to the backend for execution and returns a Promise\n- restartKernel() -> [void] - Sends a request to restart the Python kernel\n- stopDebugging() -> [void] - Sends an interrupt signal to stop current execution\n- appendConsole(text: String) -> [void] - Adds text to the console output and auto-scrolls\n- resetConsole() -> [void] - Clears the console output buffer\n- resetEditor() -> [void] - Resets editor state by clearing breakpoints\n- setLineGoThrough(lineno: Number) -> [void] - Marks a line as executed in the editor",
    "Canonical_solution": "const WebSocket = window.WebSocket;\n\nclass PythonWebSocket {\n  constructor() {\n    this.running = false;\n    this.restarting = false;\n    this.consoleData = [];\n    this.wsOpen = false;\n    this.ws = null;\n    this.lineno = {\n      offset: 0,\n      current: -1,\n    };\n  }\n\n  initPythonWebSocket() {\n    this.running = false;\n    this.restarting = false;\n\n    this.ws = new WebSocket(\"ws://\" + location.host + \"/ws/v1/python\");\n    this.ws.onopen = () => {\n      this.wsOpen = true;\n      this.resetConsole();\n      console.log(\"websocket opened\");\n    };\n    this.ws.onmessage = (message) => {\n      const data = JSON.parse(message.data);\n      switch (data.method) {\n        case \"gotoLine\":\n          let lineNumber = data.value + this.lineno.offset;\n          this.setLineGoThrough(this.lineno.current);\n          this.lineno.current = lineNumber;\n          this.editor.session.setBreakpoint(lineNumber);\n          break;\n        case \"resetContent\":\n          this.editor.setValue(data.value);\n          break;\n        case \"output\":\n          this.appendConsole(data.value);\n          break;\n        case \"finish\":\n          this.setLineGoThrough(this.lineno.current);\n          this.running = false;\n          let timeUsed = (data.value / 1000) + \"s\";\n          this.appendConsole(\"[Finished \" + timeUsed + \"]\");\n          break;\n        case \"restarted\":\n          this.restarting = false;\n          this.running = false;\n          this.resetEditor();\n          this.notifySuccess(\"\u91cd\u542f\u5185\u6838\", \"\u6210\u529f\");\n          this.runPython(this.generatePreloadCode());\n          break;\n        default:\n          console.error(\"Unknown method\", data.method);\n      }\n    };\n    this.ws.onclose = () => {\n      this.wsOpen = false;\n      this.ws = null;\n      this.running = false;\n      this.resetEditor();\n      console.log(\"websocket closed\");\n    };\n  }\n\n  runPython(code) {\n    return new Promise((resolve, reject) => {\n      this.resetConsole();\n      this.resetEditor();\n      this.running = true;\n      this.ws.send(JSON.stringify({ method: \"input\", value: code }));\n      resolve();\n    });\n  }\n\n  restartKernel() {\n    this.ws.send(JSON.stringify({ method: \"restartKernel\" }));\n    this.restarting = true;\n    setTimeout(() => {\n      this.restarting = false;\n    }, 500);\n  }\n\n  stopDebugging() {\n    this.ws.send(JSON.stringify({ method: \"keyboardInterrupt\" }));\n  }\n\n  appendConsole(text) {\n    this.consoleData.push({ lineno: this.lineno.current, value: text });\n    setTimeout(() => {\n      let c = this.$refs.console;\n      c.scrollTop = c.scrollHeight - c.clientHeight;\n    }, 1);\n  }\n\n  resetConsole() {\n    this.consoleData = [];\n  }\n\n  resetEditor() {\n    this.editor.session.clearBreakpoints();\n    this.lineno.current = -1;\n  }\n\n  setLineGoThrough(lineno) {\n    if (lineno >= 0) {\n      this.editor.session.setBreakpoint(lineno, \"ace_code_exercised\");\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class PythonWebSocket {\n  constructor() {\n    this.running = false;\n    this.restarting = false;\n    this.consoleData = [];\n    this.wsOpen = false;\n    this.ws = null;\n    this.lineno = { offset: 0, current: 0 };\n    this.editor = null;\n  }\n\n  initPythonWebSocket() {\n    this.ws = new WebSocket('ws://localhost:8765');\n    this.ws.onopen = () => {\n      this.wsOpen = true;\n      console.log('WebSocket connection established');\n    };\n\n    this.ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      if (data.type === 'console') {\n        this.appendConsole(data.output);\n      } else if (data.type === 'error') {\n        this.appendConsole(`Error: ${data.message}`);\n      }\n    };\n\n    this.ws.onclose = () => {\n      this.wsOpen = false;\n      console.log('WebSocket connection closed');\n    };\n  }\n\n  async runPython(code) {\n    return new Promise((resolve, reject) => {\n      if (!this.wsOpen) {\n        reject('WebSocket connection is not open');\n        return;\n      }\n\n      this.ws.send(JSON.stringify({ type: 'run', code }));\n      this.running = true;\n\n      this.ws.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        if (data.type === 'result') {\n          resolve(data.result);\n          this.running = false;\n        } else if (data.type === 'error') {\n          reject(data.message);\n          this.running = false;\n        }\n      };\n    });\n  }\n\n  restartKernel() {\n    if (this.wsOpen) {\n      this.ws.send(JSON.stringify({ type: 'restart' }));\n      this.restarting = true;\n    }\n  }\n\n  stopDebugging() {\n    if (this.wsOpen) {\n      this.ws.send(JSON.stringify({ type: 'interrupt' }));\n    }\n  }\n\n  appendConsole(text) {\n    this.consoleData.push(text);\n    this.editor.updateConsole(this.consoleData);\n  }\n\n  resetConsole() {\n    this.consoleData = [];\n    this.editor.updateConsole(this.consoleData);\n  }\n\n  resetEditor() {\n    this.editor.clearBreakpoints();\n  }\n\n  setLineGoThrough(lineno) {\n    this.editor.setLineGoThrough(lineno);\n  }\n}"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with reconnection capabilities and event handling.\n\nClass Description: The N class represents a WebSocket client that connects to a specified URL, handles connection events, manages reconnection logic, and forwards received messages to a destination. It provides methods to start, destroy, and manage the WebSocket connection.\n\nAttributes:\n\nurl: [String] - The WebSocket server URL to connect to.\noptions: [Object] - Configuration options for the WebSocket connection.\nsocket: [WebSocket|null] - The WebSocket connection instance.\nstreaming: [Boolean] - Indicates if the connection is actively streaming.\ncallbacks: [Object] - Stores event callbacks for connect and data events.\ndestination: [Object|null] - The target to forward received messages to.\nreconnectInterval: [Number] - Time interval (in seconds) between reconnection attempts.\nshouldAttemptReconnect: [Boolean] - Flag to control reconnection behavior.\ncompleted: [Boolean] - Indicates if the connection has completed its purpose.\nestablished: [Boolean] - Indicates if the connection is successfully established.\nprogress: [Number] - Tracks connection progress (0-1).\nreconnectTimeoutId: [Number] - Timeout ID for reconnection attempts.\nonEstablishedCallback: [Function|null] - Callback when connection is established.\nonCompletedCallback: [Function|null] - Callback when connection is completed.\nhookOnEstablished: [Function|null] - Additional hook for established event.\n\nMethods:\n\nconstructor(url, options) -> [N] - Initializes the WebSocket client with the given URL and options.\nconnect(destination) -> [void] - Sets the destination for received messages.\ndestroy() -> [void] - Closes the WebSocket connection and stops reconnection attempts.\nstart() -> [void] - Initiates the WebSocket connection with event handlers.\nresume() -> [void] - Placeholder for resuming functionality (currently empty).\nonOpen() -> [void] - Handles WebSocket open event, sets progress to 1.\nonClose() -> [void] - Handles WebSocket close/error events, initiates reconnection if enabled.\nonMessage(event) -> [void] - Handles incoming messages, triggers established callbacks, and forwards data to destination.",
    "Canonical_solution": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = true;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = void 0 !== options.reconnectInterval ? options.reconnectInterval : 5;\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = options.onSourceEstablished;\n    this.onCompletedCallback = options.onSourceCompleted;\n    options.hookOnEstablished && (this.hookOnEstablished = options.hookOnEstablished);\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.shouldAttemptReconnect = false;\n    this.socket.close();\n  }\n\n  start() {\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.progress = 0;\n    this.established = false;\n    this.options.protocols \n      ? this.socket = new WebSocket(this.url, this.options.protocols)\n      : this.socket = new WebSocket(this.url);\n    \n    this.socket.binaryType = \"arraybuffer\";\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n  }\n\n  onClose() {\n    if (this.shouldAttemptReconnect) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, 1000 * this.reconnectInterval);\n    }\n  }\n\n  onMessage(event) {\n    const wasFirstMessage = !this.established;\n    this.established = true;\n    \n    if (wasFirstMessage && this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n    \n    if (wasFirstMessage && this.onEstablishedCallback) {\n      this.onEstablishedCallback(this);\n    }\n    \n    if (this.destination) {\n      this.destination.write(event.data);\n    }\n  }\n}\n\n// External dependencies\nconst WebSocket = window.WebSocket;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options || {};\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = 5; // Default reconnection interval in seconds\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = null;\n    }\n  }\n\n  start() {\n    if (this.socket) {\n      return;\n    }\n    this.socket = new WebSocket(this.url, this.options.protocols);\n    this.socket.binaryType = 'arraybuffer';\n    this.socket.onopen = () => this.onOpen();\n    this.socket.onclose = () => this.onClose();\n    this.socket.onmessage = (event) => this.onMessage(event);\n    this.socket.onerror = () => this.onClose();\n  }\n\n  onOpen() {\n    this.established = true;\n    this.progress = 1;\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.established = false;\n    this.progress = 0;\n    if (this.shouldAttemptReconnect && !this.completed) {\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, this.reconnectInterval * 1000);\n    }\n    if (this.onCompletedCallback) {\n      this.onCompletedCallback();\n    }\n  }\n\n  onMessage(event) {\n    if (this.destination) {\n      this.destination.onMessage(event.data);\n    }\n    if (this.callbacks.data) {\n      this.callbacks.data(event.data);\n    }\n  }\n}"
  },
  {
    "Task_id": 250,
    "Instruction": "Task Description: \nCreate a WebSocket-based control class for managing connections and communication between a client and a local server, including authorization, message handling, and API invocation.\n\nClass Description: \nThe `CocogoatWebControl` class provides functionality to establish and manage WebSocket connections to a local server, handle authorization, send/receive messages, and invoke API methods through WebSocket communication.\n\nAttributes:\n- port: number - The port number for the local server connection (default: 32333)\n- token: string - The authorization token for authenticated requests\n- hwnd: number - A window handle identifier (default: 0)\n- version: string - Version information (currently unused in the reference code)\n- ev: Mitt - An event emitter for handling WebSocket messages\n- client: FlyType - An HTTP client for initial authorization\n- ws: WebSocket | undefined - The active WebSocket connection instance\n\nMethods:\n- constructor(_port?: number) -> void - Initializes the control instance with optional port specification\n- authorize() -> Promise<boolean> - Establishes WebSocket connection and obtains authorization token\n- wsInvoke(method: string, path: string, querystring?: Record<string, any>) -> Promise<{status: number, body: any}> - Invokes an API method through WebSocket connection",
    "Canonical_solution": "import mitt from 'mitt'\nimport { stringify } from 'qs'\nimport Fly from 'flyio/dist/npm/fly'\nimport type { Fly as FlyType, FlyError } from 'flyio'\n\nexport class CocogoatWebControl {\n    port = 32333\n    token = ''\n    hwnd = 0\n    version = ''\n    ev = mitt()\n    client: FlyType = new Fly()\n    ws: WebSocket | undefined\n\n    constructor(_port = 32333) {\n        this.port = _port\n        this.client.config.baseURL = `http://localhost:${this.port}`\n        this.client.interceptors.request.use((request) => {\n            if (this.token) {\n                request.headers['Authorization'] = `Bearer ${this.token}`\n            }\n            if (request.headers['Content-Type'] === '') {\n                delete request.headers['Content-Type']\n            }\n            return request\n        })\n        this.client.interceptors.response.use(undefined, (e) => {\n            const er = e as unknown as FlyError\n            if (er.status === 410) {\n                console.warn('Control stopped by user')\n                return new Error('ECANCEL')\n            }\n            return e\n        })\n    }\n\n    async authorize() {\n        if (this.ws) {\n            return true\n        }\n        try {\n            const { data } = await this.client.post('/token')\n            this.token = data.token\n            this.hwnd = data.hwnd || 0\n            const ws = new WebSocket(`ws://localhost:${this.port}/ws/${this.token}`)\n            ws.onmessage = (e) => {\n                const data = JSON.parse(e.data)\n                this.ev.emit(data.id || data.action, data.data)\n            }\n            ws.onclose = () => {\n                this.ws = undefined\n            }\n            await new Promise((resolve) => {\n                ws.onopen = resolve\n            })\n            this.ws = ws\n            return true\n        } catch (e) {\n            const er = e as FlyError\n            if (er.status === 401) {\n                return false\n            }\n            throw e\n        }\n    }\n\n    wsInvoke(method: string, path: string, querystring?: Record<string, any>) {\n        if (!this.ws) throw new Error('WebSocket not connected')\n        const url = path + (querystring ? `?${stringify(querystring)}` : '')\n        const id = Math.round(Date.now() * 1000 + Math.random() * 1000).toString(16)\n        const reqjson = {\n            id,\n            action: 'api',\n            data: {\n                url,\n                method,\n            },\n        }\n        const resp = new Promise((resolve) => {\n            this.ev.on(id, resolve)\n        })\n        this.ws.send(JSON.stringify(reqjson))\n        return resp as Promise<{\n            status: number\n            body: any\n        }>\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class CocogoatWebControl {\n  port: number;\n  token: string;\n  hwnd: number;\n  version: string;\n  ev: Mitt;\n  client: FlyType;\n  ws: WebSocket | undefined;\n\n  constructor(_port?: number) {\n    this.port = _port || 32333;\n    this.token = '';\n    this.hwnd = 0;\n    this.version = '1.0.0';\n    this.ev = new Mitt();\n    this.client = new FlyType();\n    this.ws = undefined;\n  }\n\n  async authorize(): Promise<boolean> {\n    try {\n      this.ws = new WebSocket(`ws://localhost:${this.port}`);\n      this.ws.onopen = () => {\n        this.ws.send(JSON.stringify({ method: 'authorize', params: { token: this.token } }));\n      };\n      this.ws.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        if (data.status === 200) {\n          this.token = data.body.token;\n          this.ev.emit('authorized');\n        } else {\n          this.ev.emit('authorizationFailed', data.body.message);\n        }\n      };\n      this.ws.onerror = (error) => {\n        this.ev.emit('websocketError', error.message);\n      };\n      this.ws.onclose = () => {\n        this.ev.emit('websocketClosed');\n      };\n      return true;\n    } catch (error) {\n      this.ev.emit('websocketError', error.message);\n      return false;\n    }\n  }\n\n  async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{ status: number, body: any }> {\n    try {\n      if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n        await this.authorize();\n      }\n      const payload = {\n        method,\n        path,\n        querystring\n      };\n      this.ws.send(JSON.stringify(payload));\n      return new Promise((resolve, reject) => {\n        this.ev.on('wsResponse', (response: { status: number, body: any }) => {\n          resolve(response);\n        });\n      });\n    } catch (error) {\n      this.ev.emit('websocketError', error.message);\n      throw error;\n    }\n  }\n}"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections, handles message queuing, automatic reconnection, and provides event callbacks for connection status changes and incoming messages.\n\nClass Description: The WebSocketClient class provides a robust WebSocket client implementation with connection management, message queuing, automatic reconnection capabilities, and event callbacks. It maintains connection state and handles various WebSocket events while providing methods for sending messages and checking connection status.\n\nAttributes:\n- wsClient: [WebSocket] - The underlying WebSocket connection instance\n- sendQueue: [Array] - Queue of messages to be sent when connection is available\n- pendingReconnect: [Timeout] - Timer handle for pending reconnection attempts\n\nMethods:\n- constructor() -> [void] - Initializes a new WebSocketClient instance\n- fireSendQueue() -> [void] - Sends all queued messages when connection is open\n- clearSendQueue() -> [void] - Clears all queued messages and rejects their promises\n- planToReconnect(rpcUrl: String, options: Object) -> [void] - Schedules a reconnection attempt\n- init() -> [void] - Cleans up existing connection and message queue\n- connect(rpcUrl: String, options: Object, onOpenCallback: Function, onCloseCallback: Function, onMessageCallback: Function) -> [void] - Establishes new WebSocket connection with event handlers\n- reconnect(rpcUrl: String, options: Object) -> [void] - Re-establishes connection using existing callbacks\n- send(requestContext: Object) -> [Promise] - Queues a message for sending and returns a promise\n- getReadyState() -> [Number|null] - Returns current WebSocket readyState or null if no connection",
    "Canonical_solution": "const WebSocket = require('ws');\nconst ipcRender = require('../ipc/render-proecss');\n\nclass WebSocketClient {\n    constructor() {\n        this.wsClient = null;\n        this.sendQueue = [];\n        this.pendingReconnect = null;\n    }\n\n    fireSendQueue() {\n        while (this.sendQueue.length && this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n            const request = this.sendQueue.shift();\n            this.wsClient.send(request.data);\n            request.deferred.resolve();\n        }\n    }\n\n    clearSendQueue() {\n        for (let i = this.sendQueue.length - 1; i >= 0; i--) {\n            this.sendQueue[i].deferred.reject();\n            this.sendQueue.splice(i, 1);\n        }\n    }\n\n    planToReconnect(rpcUrl, options) {\n        if (this.pendingReconnect) {\n            ipcRender.notifyRenderProcessLogWarn('[lib/websocket.planToReconnect] another reconnection is pending');\n            return;\n        }\n\n        this.pendingReconnect = setTimeout(() => {\n            if (this.wsClient == null) {\n                ipcRender.notifyRenderProcessLogWarn('[lib/websocket.planToReconnect] websocket is null');\n                this.pendingReconnect = null;\n                return;\n            }\n\n            if (this.wsClient.readyState === WebSocket.CONNECTING || this.wsClient.readyState === WebSocket.OPEN) {\n                ipcRender.notifyRenderProcessLogWarn('[lib/websocket.planToReconnect] websocket current state is already ' + this.wsClient.readyState);\n                this.pendingReconnect = null;\n                return;\n            }\n\n            this.reconnect(rpcUrl, options);\n            this.pendingReconnect = null;\n        }, options.reconnectInterval);\n\n        ipcRender.notifyRenderProcessLogDebug('[lib/websocket.planToReconnect] next reconnection is pending in ' + options.reconnectInterval + \"ms\");\n    }\n\n    init() {\n        if (this.sendQueue.length) {\n            this.clearSendQueue();\n        }\n\n        if (this.wsClient) {\n            this.wsClient.onopen = null;\n            this.wsClient.onclose = null;\n            this.wsClient.onmessage = null;\n            this.wsClient.terminate();\n            this.wsClient = null;\n        }\n    }\n\n    connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n        this.init();\n\n        this.wsClient = new WebSocket(rpcUrl);\n\n        this.wsClient.onopen = () => {\n            onOpenCallback({\n                client: this.wsClient,\n                url: rpcUrl\n            });\n            this.fireSendQueue();\n        };\n\n        this.wsClient.onclose = () => {\n            let autoReconnect = false;\n\n            if (options.reconnectInterval > 0) {\n                autoReconnect = true;\n                this.planToReconnect(rpcUrl, options);\n            }\n\n            onCloseCallback({\n                client: this.wsClient,\n                url: rpcUrl,\n                autoReconnect: autoReconnect\n            });\n        };\n\n        this.wsClient.onmessage = (event) => {\n            let message = null;\n\n            if (event) {\n                message = event.data;\n            }\n\n            onMessageCallback({\n                client: this.wsClient,\n                url: rpcUrl,\n                success: true,\n                message: message\n            });\n        };\n\n        this.wsClient.onerror = (event) => {\n            // Do Nothing\n        };\n    }\n\n    reconnect(rpcUrl, options) {\n        if (!this.wsClient) {\n            return;\n        }\n\n        const onOpenFn = this.wsClient.onopen;\n        const onCloseFn = this.wsClient.onclose;\n        const onMessageFn = this.wsClient.onmessage;\n        const onErrorFn = this.wsClient.onerror;\n\n        this.init();\n\n        this.wsClient = new WebSocket(rpcUrl);\n        this.wsClient.onopen = onOpenFn;\n        this.wsClient.onclose = onCloseFn;\n        this.wsClient.onmessage = onMessageFn;\n        this.wsClient.onerror = onErrorFn;\n    }\n\n    send(requestContext) {\n        const deferred = {};\n        deferred.promise = new Promise((resolve, reject) => {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n\n        this.sendQueue.push({\n            url: requestContext.url,\n            data: requestContext.data,\n            deferred: deferred\n        });\n\n        if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n            this.fireSendQueue();\n        }\n\n        return deferred.promise;\n    }\n\n    getReadyState() {\n        if (!this.wsClient) {\n            return null;\n        }\n\n        return this.wsClient.readyState;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class WebSocketClient {\n  constructor() {\n    this.wsClient = null;\n    this.sendQueue = [];\n    this.pendingReconnect = null;\n  }\n\n  fireSendQueue() {\n    if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n      for (const message of this.sendQueue) {\n        this.wsClient.send(message);\n      }\n      this.sendQueue = [];\n    }\n  }\n\n  clearSendQueue() {\n    this.sendQueue = [];\n  }\n\n  planToReconnect(rpcUrl, options) {\n    if (this.pendingReconnect) {\n      clearTimeout(this.pendingReconnect);\n    }\n    this.pendingReconnect = setTimeout(() => {\n      this.reconnect(rpcUrl, options);\n    }, 5000);\n  }\n\n  init() {\n    if (this.wsClient) {\n      this.wsClient.close();\n    }\n    this.clearSendQueue();\n    this.pendingReconnect = null;\n  }\n\n  connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n    this.init();\n    this.wsClient = new WebSocket(rpcUrl, options);\n    this.wsClient.onopen = () => {\n      onOpenCallback && onOpenCallback();\n      this.fireSendQueue();\n    };\n    this.wsClient.onclose = () => {\n      onCloseCallback && onCloseCallback();\n      this.planToReconnect(rpcUrl, options);\n    };\n    this.wsClient.onmessage = (event) => {\n      onMessageCallback && onMessageCallback(event.data);\n    };\n    this.wsClient.onerror = (error) => {\n      console.error('WebSocket error:', error);\n      this.planToReconnect(rpcUrl, options);\n    };\n  }\n\n  reconnect(rpcUrl, options) {\n    this.connect(rpcUrl, options, this.wsClient.onopen, this.wsClient.onclose, this.wsClient.onmessage);\n  }\n\n  send(requestContext) {\n    return new Promise((resolve, reject) => {\n      this.sendQueue.push(requestContext);\n      if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n        this.wsClient.send(requestContext);\n        resolve();\n      } else {\n        this.pendingReconnect = setTimeout(() => {\n          this.reconnect(rpcUrl, options);\n        }, 5000);\n      }\n    });\n  }\n\n  getReadyState() {\n    return this.wsClient ? this.wsClient.readyState : null;\n  }\n}"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a WebSocket server, handles connection events, sends messages, and manages errors and closures.\n\nFunction Description: The function `connectWebSocket` initializes a WebSocket client connection to a specified server. It sets up event handlers for connection opening, incoming messages, and connection closing. The function also sends an initial message upon successful connection and logs all events to the console.\n\nInput: \n- Optional command line arguments:\n  - `port` (number): The port number to connect to (default: 7000).\n  - `secure` (boolean): Whether to use a secure WebSocket connection (wss) (default: false, uses ws).\n\nOutput: \n- No explicit return value. The function logs connection status, received messages, and closure events to the console.\n- Side effects: Establishes a WebSocket connection and sends/receives messages.",
    "Canonical_solution": "function connectWebSocket() {\n    var WebSocket = require('../lib/faye/websocket'),\n        port = process.argv[2] || 7000,\n        secure = process.argv[3] === 'ssl',\n        scheme = secure ? 'wss' : 'ws',\n        ws = new WebSocket.Client(scheme + '://localhost:' + port + '/');\n\n    console.log('Connecting to ' + ws.url);\n\n    ws.onopen = function(event) {\n        console.log('open');\n        ws.send('Hello, WebSocket!');\n    };\n\n    ws.onmessage = function(event) {\n        console.log('message', event.data);\n    };\n\n    ws.onclose = function(event) {\n        console.log('close', event.code, event.reason);\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function connectWebSocket(port = 7000, secure = false) {\n  const protocol = secure ? 'wss' : 'ws';\n  const url = `${protocol}://localhost:${port}`;\n\n  const ws = new WebSocket(url);\n\n  ws.onopen = () => {\n    console.log('Connected to WebSocket server');\n    ws.send('Hello Server');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Received message:', event.data);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed', event.reason);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n}"
  },
  {
    "Task_id": 253,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a WebSocket server, handles connection events, sends and receives messages, and manages errors and connection closure.\n\nFunction Description: The code consists of several functions that work together to create and manage a WebSocket connection. The main function `testWebSocket` initializes the connection, while other functions handle specific events like opening/closing the connection, receiving messages, and handling errors. The `doSend` function is used to send messages through the WebSocket connection.\n\nInput:\n- `wsUri` (String): The WebSocket server URI to connect to (e.g., \"ws://example.com/socket\")\n\nOutput:\n- No direct return values, but the functions perform the following actions:\n  - Establish a WebSocket connection\n  - Send messages to the server\n  - Display connection status and messages in the UI\n  - Handle errors and connection closure\n\nFunctions:\n1. `testWebSocket()`: Initializes a new WebSocket connection and sets up event handlers\n2. `onOpen(evt)`: Handles the connection open event, sends a test message\n3. `onClose(evt)`: Handles the connection close event\n4. `onMessage(evt)`: Handles incoming messages and closes the connection\n5. `onError(evt)`: Handles connection errors\n6. `doSend(message)`: Sends a message through the WebSocket connection\n\nNote: The implementation assumes the existence of a `writeToScreen` function for displaying messages in the UI.",
    "Canonical_solution": "function testWebSocket() {\n    websocket = new WebSocket(wsUri);\n    websocket.onopen = function (evt) {\n        onOpen(evt)\n    };\n    websocket.onclose = function (evt) {\n        onClose(evt)\n    };\n    websocket.onmessage = function (evt) {\n        onMessage(evt)\n    };\n    websocket.onerror = function (evt) {\n        onError(evt)\n    };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"CONNECTED\");\n    doSend(\"WebSocket rocks\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"DISCONNECTED\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen('<span style=\"color: blue;\">RESPONSE: ' + evt.data + '</span>');\n    websocket.close();\n}\n\nfunction onError(evt) {\n    writeToScreen('<span style=\"color: red;\">ERROR:</span> ' + evt.data);\n}\n\nfunction doSend(message) {\n    writeToScreen(\"SENT: \" + message);\n    websocket.send(message);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function testWebSocket() {\n  const ws = new WebSocket(\"ws://example.com/socket\");\n  ws.onopen = function(evt) {\n    writeToScreen(\"Connection established.\");\n    doSend(\"Connection established.\");\n  };\n  ws.onclose = function(evt) {\n    writeToScreen(\"Connection closed.\");\n  };\n  ws.onmessage = function(evt) {\n    writeToScreen(\"Received: \" + evt.data);\n    ws.close();\n  };\n  ws.onerror = function(evt) {\n    writeToScreen(\"Error occurred:\");\n    writeToScreen(evt.data);\n  };\n}\n\nfunction doSend(message) {\n  if (ws && ws.readyState === WebSocket.OPEN) {\n    ws.send(message);\n  } else {\n    writeToScreen(\"Failed to send message.\");\n  }\n}\n\nfunction writeToScreen(message) {\n  const screen = document.getElementById(\"screen\");\n  screen.innerHTML += message + \"<br>\";\n}"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes and manages a WebSocket connection, handles events (open, message, error, close), and provides methods for sending data and disconnecting.\n\nClass Description: The WsProvider class encapsulates WebSocket functionality, providing a clean interface for WebSocket communication. It handles connection lifecycle events and ensures proper cleanup when disconnecting.\n\nAttributes:\n#websocket: WebSocket | null - Private field storing the active WebSocket connection instance\n\nMethods:\nconstructor(endpoint: string) -> void - Initializes the WebSocket connection to the specified endpoint\n#connect(endpoint: string) -> void - Private method that establishes the WebSocket connection and sets up event handlers\n#onSocketClose(event: CloseEvent) -> void - Private method handling WebSocket close events\n#onSocketError(error: Event) -> void - Private method handling WebSocket error events\n#onSocketMessage(message: MessageEvent<string>) -> void - Private method handling incoming WebSocket messages\n#onSocketOpen() -> boolean - Private method handling WebSocket open events\nsend(body: string) -> void - Public method for sending data through the WebSocket connection\ndisconnect() -> void - Public method for properly closing the WebSocket connection",
    "Canonical_solution": "import type { Class } from '@polkadot/util/types';\nimport type { JsonRpcResponse, ProviderInterfaceCallback } from '../types.js';\nimport { EventEmitter } from 'eventemitter3';\nimport { isChildClass, isNull, isUndefined } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\n\nclass WsProvider {\n  #websocket: WebSocket | null;\n\n  constructor(endpoint: string) {\n    this.#websocket = null;\n    this.#connect(endpoint);\n  }\n\n  #connect(endpoint: string): void {\n    try {\n      this.#websocket = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket as unknown as Class<WebSocket>, WebSocket)\n        ? new WebSocket(endpoint)\n        : new WebSocket(endpoint, undefined, {});\n\n      if (this.#websocket) {\n        this.#websocket.onclose = this.#onSocketClose;\n        this.#websocket.onerror = this.#onSocketError;\n        this.#websocket.onmessage = this.#onSocketMessage;\n        this.#websocket.onopen = this.#onSocketOpen;\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  #onSocketClose(event: CloseEvent): void {\n    this.#websocket = null;\n  }\n\n  #onSocketError(error: Event): void {\n    // Handle error\n  }\n\n  #onSocketMessage(message: MessageEvent<string>): void {\n    const response = JSON.parse(message.data) as JsonRpcResponse<string>;\n    // Process message\n  }\n\n  #onSocketOpen(): boolean {\n    return true;\n  }\n\n  public send(body: string): void {\n    if (!this.#websocket) {\n      throw new Error('WebSocket is not connected');\n    }\n    this.#websocket.send(body);\n  }\n\n  public disconnect(): void {\n    if (this.#websocket) {\n      this.#websocket.close(1000);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class WsProvider {\n  #websocket = null;\n\n  constructor(endpoint) {\n    this.connect(endpoint);\n  }\n\n  #connect(endpoint) {\n    this.#websocket = new WebSocket(endpoint);\n    this.#websocket.onopen = () => this.#onSocketOpen();\n    this.#websocket.onmessage = (event) => this.#onSocketMessage(event);\n    this.#websocket.onerror = (event) => this.#onSocketError(event);\n    this.#websocket.onclose = (event) => this.#onSocketClose(event);\n  }\n\n  #onSocketOpen() {\n    return true;\n  }\n\n  #onSocketMessage(event) {\n    // Handle incoming message\n  }\n\n  #onSocketError(event) {\n    // Handle error\n  }\n\n  #onSocketClose(event) {\n    // Handle close event\n  }\n\n  send(body) {\n    if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n      this.#websocket.send(body);\n    }\n  }\n\n  disconnect() {\n    if (this.#websocket) {\n      this.#websocket.close();\n      this.#websocket = null;\n    }\n  }\n}"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a server, handles various connection events, and processes incoming messages for a reload service.\n\nFunction Description: The `connect` function initializes and manages a WebSocket connection to a specified server. It handles connection events (open, error, message, close) and processes incoming messages to trigger appropriate actions, such as requesting initial load data or reloading extensions when file changes are detected. The function ensures only one active connection exists at a time.\n\nInput: None (The WebSocket URL is hardcoded as 'ws://localhost:__RELOAD_PORT__')\n\nOutput: None (The function primarily manages side effects: establishing connections, logging events, and triggering other functions based on received messages)",
    "Canonical_solution": "function connect() {\n  if (webSocket) {\n    return;\n  }\n\n  webSocket = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  webSocket.onerror = (event) => {\n    console.error(`[Reload Service] Connection error: ${JSON.stringify(event)}`);\n    webSocket.close();\n  };\n\n  webSocket.onopen = () => {\n    console.info(`[Reload Service] Connection opened.`);\n  };\n\n  webSocket.onmessage = async (event) => {\n    const message = JSON.parse(event.data);\n\n    if (message.status === 'serverReady') {\n      console.info('[Reload Service] Connection ready.');\n      await requestInitialLoadData();\n    }\n\n    if (message.changedFile) {\n      console.info(\n        `[Reload Service] Changes detected on ${message.changedFile}. Reloading extension...`\n      );\n      await messageAllExtensions(message.changedFile);\n    }\n  };\n\n  webSocket.onclose = () => {\n    console.info('[Reload Service] Connection closed.');\n    webSocket = null;\n  };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function connect() {\n  if (window.__reloadWebSocket) {\n    window.__reloadWebSocket.close();\n  }\n\n  const url = 'ws://localhost:__RELOAD_PORT__';\n  window.__reloadWebSocket = new WebSocket(url);\n\n  window.__reloadWebSocket.onopen = function(event) {\n    console.log('WebSocket connection opened');\n    // Send initial load data request\n    window.__reloadWebSocket.send(JSON.stringify({ type: 'initial_load' }));\n  };\n\n  window.__reloadWebSocket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    switch (data.type) {\n      case 'reload_extension':\n        console.log('Triggering extension reload');\n        // Add your reload logic here\n        break;\n      case 'load_data':\n        console.log('Loading data:', data.payload);\n        // Add your data loading logic here\n        break;\n      default:\n        console.log('Unknown message type:', data.type);\n    }\n  };\n\n  window.__reloadWebSocket.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  window.__reloadWebSocket.onclose = function(event) {\n    console.log('WebSocket connection closed', event.reason);\n    // Attempt to reconnect after a delay\n    setTimeout(connect, 5000);\n  };\n}"
  },
  {
    "Task_id": 256,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a LiveReload server and handles reload commands for browser extensions.\n\nFunction Description: The function `setupWebSocketReload` creates a WebSocket connection to a LiveReload server running on localhost. It sets up event handlers to manage connection errors and incoming messages. When a reload command is received, it triggers the browser extension's reload functionality.\n\nInput: None (The function uses predefined constants for host and port)\n\nOutput: None (The function's side effects are establishing a WebSocket connection and setting up event handlers that may trigger a browser extension reload)\n\nNote: The actual WebSocket URL is constructed using the constants LIVERELOAD_HOST and LIVERELOAD_PORT, with the path '/livereload'. The function handles JSON messages where a 'reload' command triggers the extension reload.",
    "Canonical_solution": "function setupWebSocketReload() {\n    var LIVERELOAD_HOST = 'localhost:';\n    var LIVERELOAD_PORT = 35729;\n    var connection = new WebSocket('ws://' + LIVERELOAD_HOST + LIVERELOAD_PORT + '/livereload');\n\n    connection.onerror = function (error) {\n        console.log('reload connection got error:', error);\n    };\n\n    connection.onmessage = function (e) {\n        if (e.data) {\n            var data = JSON.parse(e.data);\n            if (data && data.command === 'reload') {\n                ext.runtime.reload();\n            }\n        }\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "right_result": "function setupWebSocketReload() {\n  const LIVERELOAD_HOST = 'localhost';\n  const LIVERELOAD_PORT = 35729;\n  const ws = new WebSocket(`ws://${LIVERELOAD_HOST}:${LIVERELOAD_PORT}/livereload`);\n\n  ws.onopen = () => {\n    console.log('Connected to LiveReload server');\n  };\n\n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.command === 'reload') {\n      // Trigger browser extension reload\n      chrome.runtime.reload();\n    }\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n}"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes a connection to a server, handles incoming messages, manages connection errors, and provides functionality to close the connection.\n\nClass Description: The WebSocketClient class encapsulates WebSocket functionality for establishing and managing a WebSocket connection. It handles connection events, message reception, and error scenarios, while providing a clean interface for external message handling through a callback.\n\nAttributes:\n- url: [String] - The server URL to connect to (without protocol)\n- actionId: [String] - An identifier for the specific WebSocket action/channel\n- onMessageCallback: [Function] - Callback function to handle incoming messages\n- socket: [WebSocket|null] - Reference to the WebSocket connection instance\n- initData: [Boolean] - Flag indicating whether initial data has been received\n- WebSocket: [WebSocket|null] - Alias for the socket instance (set after successful connection)\n\nMethods:\n- constructor(url, actionId, onMessageCallback) -> [void] - Initializes the WebSocketClient with connection URL, action ID, and message callback\n- connect() -> [void] - Establishes the WebSocket connection and sets up event handlers\n- close() -> [void] - Closes the WebSocket connection if it exists",
    "Canonical_solution": "import axios from 'axios';\n\nclass WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n  }\n\n  connect() {\n    try {\n      this.socket = new WebSocket(\n        `${location.protocol === 'https:' ? 'wss' : 'ws'}://${this.url}/api/interface/solve_conflict?id=${this.actionId}`\n      );\n\n      this.socket.onopen = () => {\n        this.WebSocket = this.socket;\n      };\n\n      this.socket.onmessage = (e) => {\n        this.initData = true;\n        const result = JSON.parse(e.data);\n        this.onMessageCallback(result);\n      };\n\n      this.socket.onerror = () => {\n        console.warn('websocket \u8fde\u63a5\u5931\u8d25\uff0c\u5c06\u5bfc\u81f4\u591a\u4eba\u7f16\u8f91\u540c\u4e00\u4e2a\u63a5\u53e3\u51b2\u7a81\u3002');\n      };\n\n    } catch (e) {\n      console.error('websocket \u8fde\u63a5\u5931\u8d25\uff0c\u5c06\u5bfc\u81f4\u591a\u4eba\u7f16\u8f91\u540c\u4e00\u4e2a\u63a5\u53e3\u51b2\u7a81\u3002');\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "right_result": "class WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n    this.WebSocket = null;\n  }\n\n  connect() {\n    if (this.socket) return;\n\n    this.socket = new WebSocket(`ws://${this.url}`);\n    this.WebSocket = this.socket;\n\n    this.socket.onopen = () => {\n      console.log('WebSocket connection established');\n    };\n\n    this.socket.onmessage = (event) => {\n      this.onMessageCallback(event.data);\n    };\n\n    this.socket.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n\n    this.socket.onclose = () => {\n      console.log('WebSocket connection closed');\n    };\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n      this.WebSocket = null;\n    }\n  }\n}"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Create a function that sets up a WebSocket server using Node.js to handle client connections and message exchanges.\n\nFunction Description: The function initializes a WebSocket server on a specified port, listens for incoming client connections, and handles message events. When a message is received from a client, the server logs the message and sends a predefined response back to the client.\n\nInput: None (The port number is hardcoded as 3000 in the function.)\n\nOutput: None (The function sets up the WebSocket server and event handlers but does not return any value.)",
    "Canonical_solution": "function handleWebSocketConnection() {\n    let WebSocket = require('ws');\n    let wss = new WebSocket.Server({port:3000});\n    wss.on('connection',function(ws) {\n        ws.on('message', function (data) {\n            console.log(data);\n            ws.send('\u6211\u4e0d\u7231\u4f60');\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "right_result": "const WebSocket = require('ws');\n\nfunction setupWebSocketServer() {\n  const wss = new WebSocket.Server({ port: 3000 });\n\n  wss.on('connection', (ws) => {\n    console.log('Client connected');\n\n    ws.on('message', (message) => {\n      console.log(`Received message: ${message}`);\n      ws.send('Message received and echoed back');\n    });\n\n    ws.on('close', () => {\n      console.log('Client disconnected');\n    });\n}\n\nsetupWebSocketServer();"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a WebSocket server in Node.js that handles client connections, tracks connection counts, and provides broadcast functionality to all connected clients.\n\nFunction Description: The function creates and configures a WebSocket server instance. It maintains a count of active connections, logs connection/disconnection events, and provides a broadcast method to send data to all connected clients. The server handles WebSocket connections on the specified port.\n\nInput: \n- port: [Number] - The port number on which the WebSocket server should listen for connections\n\nOutput:\n- Returns: [WebSocket.Server] - An instance of WebSocket server with additional connection tracking and broadcast functionality\n\nAttributes:\n- connectionCount: [Number] - Tracks the number of active WebSocket connections\n\nMethods:\n- broadcast: [Name](data) -> [void] - Sends the provided data to all connected clients that are in OPEN state\n- on: [Name](event, callback) -> [void] - Inherited from WebSocket.Server to handle server events ('connection', 'error', etc.)",
    "Canonical_solution": "function createWebSocketServer(port) {\n    var WebSocket = require('ws');\n    var socketServer = new WebSocket.Server({port: port, perMessageDeflate: false});\n    socketServer.connectionCount = 0;\n    socketServer.on('connection', function(socket, upgradeReq) {\n        socketServer.connectionCount++;\n        console.log(\n            'New WebSocket Connection: ',\n            (upgradeReq || socket.upgradeReq).socket.remoteAddress,\n            (upgradeReq || socket.upgradeReq).headers['user-agent'],\n            '('+socketServer.connectionCount+' total)'\n        );\n        socket.on('close', function(code, message){\n            socketServer.connectionCount--;\n            console.log(\n                'Disconnected WebSocket ('+socketServer.connectionCount+' total)'\n            );\n        });\n    });\n    socketServer.broadcast = function(data) {\n        socketServer.clients.forEach(function each(client) {\n            if (client.readyState === WebSocket.OPEN) {\n                client.send(data);\n            }\n        });\n    };\n    return socketServer;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "right_result": "const WebSocket = require('ws');\n\nfunction createWebSocketServer(port) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.connectionCount = 0;\n\n  wss.on('connection', function connection(socket) {\n    wss.connectionCount++;\n    console.log(`Client connected, total connections: ${wss.connectionCount}`);\n\n    socket.on('close', function close() {\n      wss.connectionCount--;\n      console.log(`Client disconnected, total connections: ${wss.connectionCount}`);\n    });\n  });\n\n  wss.broadcast = function broadcast(data) {\n    wss.clients.forEach(function each(client) {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(data);\n      }\n    });\n  };\n\n  return wss;\n}\n\nmodule.exports = createWebSocketServer;"
  },
  {
    "Task_id": 262,
    "Instruction": "Task Description: Implement a WebSocket server using Node.js that facilitates real-time communication between clients and initializes sample data for a collaborative application.\n\nFunction Description: The function `setupWebSocketServer` creates a WebSocket server integrated with ShareDB for real-time data synchronization. It sets up an Express server to serve static files, initializes a WebSocket server, and populates the database with sample player data if empty. The server listens on port 8080.\n\nInput: None\n\nOutput: None (The function sets up a server and initializes data but does not return any value)",
    "Canonical_solution": "function setupWebSocketServer() {\n    var http = require('http');\n    var ShareDB = require('sharedb');\n    var express = require('express');\n    var ShareDBMingoMemory = require('sharedb-mingo-memory');\n    var WebSocketJSONStream = require('@teamwork/websocket-json-stream');\n    var WebSocket = require('ws');\n\n    var share = new ShareDB({db: new ShareDBMingoMemory()});\n\n    var app = express();\n    app.use(express.static('static'));\n    var server = http.createServer(app);\n    var wss = new WebSocket.Server({server: server});\n    server.listen(8080);\n    console.log('Listening on http://localhost:8080');\n\n    wss.on('connection', function(ws) {\n        var stream = new WebSocketJSONStream(ws);\n        share.listen(stream);\n    });\n\n    var connection = share.connect();\n    connection.createFetchQuery('players', {}, {}, function(err, results) {\n        if (err) {\n            throw err;\n        }\n\n        if (results.length === 0) {\n            var names = ['Ada Lovelace', 'Grace Hopper', 'Marie Curie',\n                'Carl Friedrich Gauss', 'Nikola Tesla', 'Claude Shannon'];\n\n            names.forEach(function(name, index) {\n                var doc = connection.get('players', ''+index);\n                var data = {name: name, score: Math.floor(Math.random() * 10) * 5};\n                doc.create(data);\n            });\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "right_result": "const express = require('express');\nconst WebSocket = require('ws');\nconst { sharedDB } = require('shared-db');\n\nconst app = express();\nconst server = express.createServer();\nconst wss = new WebSocket.Server({ server });\n\nsharedDB({\n  db: {\n    players: []\n  }\n});\n\nwss.on('connection', (ws) => {\n  ws.send(JSON.stringify(sharedDB.db.players));\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});"
  },
  {
    "Task_id": 264,
    "Instruction": "Task Description: Create a WebSocket server that handles client connections, messages, and errors, while managing an isolated inspector session for each connection.\n\nFunction Description: The function `createWebSocketServer` initializes a WebSocket server on a specified port. For each client connection, it creates an isolated inspector session, sets up event handlers for messages, errors, and connection closure, and manages protocol message dispatching between the client and the inspector session.\n\nInput:  \n- `port` (Number): The port number on which the WebSocket server will listen for incoming connections.\n\nOutput:  \n- None (The function does not return a value but sets up a WebSocket server with the specified configuration and event handlers.)",
    "Canonical_solution": "let WebSocket = require('ws');\n\nfunction createWebSocketServer(port) {\n    let wss = new WebSocket.Server({ port: port });\n\n    wss.on('connection', function(ws) {\n        let channel = isolate.createInspectorSession();\n        function dispose() {\n            try {\n                channel.dispose();\n            } catch (err) {}\n        }\n        ws.on('error', dispose);\n        ws.on('close', dispose);\n\n        ws.on('message', function(message) {\n            console.log('<', message.toString())\n            try {\n                channel.dispatchProtocolMessage(String(message));\n            } catch (err) {\n                ws.close();\n            }\n        });\n\n        function send(message) {\n            console.log('>', message.toString())\n            try {\n                ws.send(message);\n            } catch (err) {\n                dispose();\n            }\n        }\n        channel.onResponse = (callId, message) => send(message);\n        channel.onNotification = send;\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "right_result": "const WebSocket = require('ws');\n\nfunction createWebSocketServer(port) {\n  const server = new WebSocket.Server({ port });\n\n  server.on('connection', (socket) => {\n    const inspectorSession = {\n      messages: [],\n      errors: [],\n      closed: false\n    };\n\n    socket.on('message', (message) => {\n      if (!inspectorSession.closed) {\n        inspectorSession.messages.push(message);\n        // Handle message dispatching logic here\n      }\n    });\n\n    socket.on('error', (error) => {\n      if (!inspectorSession.closed) {\n        inspectorSession.errors.push(error);\n        // Handle error handling logic here\n      }\n    });\n\n    socket.on('close', () => {\n      inspectorSession.closed = true;\n      // Handle connection closure logic here\n    });\n  });\n}"
  },
  {
    "Task_id": 267,
    "Instruction": "Task Description: Create a WebSocket server that handles MQTT protocol messages using the Aedes broker, with event listeners for various client interactions and message handling.\n\nFunction Description: The function `createWebSocketServer` initializes and starts a WebSocket server that integrates with the Aedes MQTT broker. It sets up event handlers for client connections, errors, message publishing, subscriptions, and client disconnections. The server listens on a specified port for WebSocket connections and routes MQTT messages through the Aedes broker.\n\nInput: None (The function does not take any input parameters; port and configuration are hardcoded within the function.)\n\nOutput: None (The function does not return any value; it creates and maintains a running WebSocket server with event listeners.)",
    "Canonical_solution": "function createWebSocketServer() {\n    const aedes = require('aedes')();\n    const httpServer = require('http').createServer();\n    const WebSocket = require('ws');\n    const wsPort = 8080;\n\n    const wss = new WebSocket.Server({ server: httpServer });\n    wss.on('connection', function connection(ws) {\n        const duplex = WebSocket.createWebSocketStream(ws);\n        aedes.handle(duplex);\n    });\n\n    httpServer.listen(wsPort, () => {\n        console.log('websocket server listening on port', wsPort);\n    });\n\n    aedes.on('clientError', (client, err) => {\n        console.log('client error', client.id, err.message, err.stack);\n    });\n\n    aedes.on('connectionError', (client, err) => {\n        console.log('client error', client, err.message, err.stack);\n    });\n\n    aedes.on('publish', (packet, client) => {\n        if (packet && packet.payload) {\n            console.log('publish packet:', packet.payload.toString());\n        }\n        if (client) {\n            console.log('message from client', client.id);\n        }\n    });\n\n    aedes.on('subscribe', (subscriptions, client) => {\n        if (client) {\n            console.log('subscribe from client', subscriptions, client.id);\n        }\n    });\n\n    aedes.on('client', (client) => {\n        console.log('new client', client.id);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "right_result": "const Aedes = require('aedes');\nconst WebSocket = require('ws');\n\nfunction createWebSocketServer() {\n  const aedes = new Aedes();\n  const server = new WebSocket.Server({ port: 1883 });\n\n  server.on('connection', (ws) => {\n    aedes.clientConnect(ws);\n    ws.on('message', (message) => {\n      aedes.publish(message);\n    });\n    ws.on('close', () => {\n      aedes.clientDisconnect(ws);\n    });\n  });\n\n  server.on('error', (err) => {\n    console.error('WebSocket server error:', err);\n  });\n\n  aedes.on('publish', (packet, client) => {\n    console.log(`Message published to ${packet.topic}: ${packet.payload}`);\n  });\n\n  aedes.on('subscribe', (packet, client) => {\n    console.log(`Client ${client.id} subscribed to ${packet.topic}`);\n  });\n\n  aedes.on('unsubscribe', (packet, client) => {\n    console.log(`Client ${client.id} unsubscribed from ${packet.topic}`);\n  });\n\n  aedes.on('clientDisconnect', (client) => {\n    console.log(`Client ${client.id} disconnected`);\n  });\n\n  console.log('WebSocket server started on port 1883');\n}\n\ncreateWebSocketServer();"
  },
  {
    "Task_id": 268,
    "Instruction": "Task Description: Create a WebSocket server in Node.js that listens for incoming connections, handles messages, and responds to specific initialization messages.\n\nFunction Description: The function `setupWebSocketServer` initializes a WebSocket server on a specified port. It sets up event handlers for connections and incoming messages. When a message is received, it echoes the message back to the client. If the received message matches a predefined initialization message, it sends a specific response message before closing the connection.\n\nInput: \n- `callback`: [Function] - A callback function to be executed once the server starts listening.\n- `initMsg`: [String] - The initialization message that triggers a specific response.\n- `responseMsg`: [String] - The response message to be sent when the initialization message is received.\n\nOutput: \n- None (The function sets up the server and event handlers but does not return any value).",
    "Canonical_solution": "function setupWebSocketServer() {\n  const http = require('http');\n  const WebSocket = require('ws');\n\n  this.server = http.createServer();\n  this.server.listen(8099, function() {\n    callback();\n  });\n\n  this.wss = new WebSocket.Server({ server: this.server });\n  this.wss.on('connection', (ws) => {\n    ws.on('message', (data) => {\n      const received = data.toString();\n      ws.send(received);\n      if (received === initMsg) {\n        ws.send(responseMsg);\n      }\n      ws.close();\n    });\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "right_result": "function setupWebSocketServer(callback, initMsg, responseMsg) {\n  const WebSocket = require('ws');\n  const wss = new WebSocket.Server({ port: 8080 });\n\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      if (message === initMsg) {\n        ws.send(responseMsg);\n        ws.close();\n      } else {\n        ws.send(message);\n      }\n    });\n\n    ws.on('close', function close() {\n      console.log('Client disconnected');\n    });\n  });\n\n  callback();\n}"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript to handle real-time bidirectional communication between clients and the server.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io. It sets up event listeners for client connections, messages, and disconnections. The server broadcasts received messages to all connected clients.\n\nInput:\n- `port` (Number): The port number on which the WebSocket server will listen for incoming connections.\n\nOutput:\n- Returns the `socketServer` instance (Object) which can be used to further configure or interact with the WebSocket server.\n\nNote: The function internally uses the `http` module to create an HTTP server and binds socket.io to it for WebSocket communication. The server logs connection, message, and disconnection events to the console.",
    "Canonical_solution": "const http = require(\"http\");\nconst socketIo = require(\"socket.io\");\n\nfunction setupWebSocketServer(port) {\n    const app = express();\n    const webServer = http.createServer(app);\n    const socketServer = socketIo(webServer, {\"log level\": 1});\n\n    socketServer.on(\"connection\", (socket) => {\n        console.log(\"New client connected\");\n\n        socket.on(\"message\", (data) => {\n            console.log(\"Message received: \", data);\n            socketServer.emit(\"message\", data);\n        });\n\n        socket.on(\"disconnect\", () => {\n            console.log(\"Client disconnected\");\n        });\n    });\n\n    webServer.listen(port, () => {\n        console.log(\"WebSocket server listening on port: \" + port);\n    });\n\n    return socketServer;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "right_result": "function setupWebSocketServer(port) {\n  const http = require('http');\n  const socketIo = require('socket.io');\n\n  const server = http.createServer();\n  const socketServer = socketIo(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected');\n\n    socket.on('message', (message) => {\n      console.log('Received message:', message);\n      socketServer.emit('message', message);\n    });\n\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`WebSocket server listening on port ${port}`);\n  });\n\n  return socketServer;\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript that handles real-time communication between clients and integrates with an Express application and Deployd backend.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io, integrates it with an Express application, and attaches a Deployd backend. It sets up event listeners for server operations and handles custom Express routes.\n\nInput: None (The function uses environment variables for configuration: `process.env.NODE_ENV` for environment setting and `process.env.PORT` for port number)\n\nOutput: None (The function starts a server that listens on the specified port and logs server status to the console)\n\nNote: The function internally uses:\n- Express for HTTP server functionality\n- Socket.io for WebSocket communication\n- Deployd for backend services\n- MongoDB (configured to connect to localhost:27017 with database name 'test-app')",
    "Canonical_solution": "function setupWebSocketServer() {\n    var express = require('express');\n    var app = express();\n    var server = require('http').createServer(app);\n    var io = require('socket.io').listen(server, {'log level': 0});\n\n    require('deployd').attach(server, {\n        socketIo: io,\n        env: process.env.NODE_ENV || 'development',\n        db: {host:'localhost', port:27017, name:'test-app'}\n    });\n    app.use(server.handleRequest);\n\n    app.get('/express-custom-handler', function(req, res) {\n        res.send('Ok');\n    });\n\n    server.listen(process.env.PORT || 2403, function() {\n        console.log({ ENV: process.env.NODE_ENV || 'development', PORT: process.env.PORT || 2403 });\n    });\n    server.on('error', function(err) {\n        console.log(err.stack);\n        process.nextTick(function() {\n            process.exit();\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "right_result": "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst deployd = require('deployd');\nconst mongoose = require('mongoose');\n\nfunction setupWebSocketServer() {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIo(server);\n\n  // Connect to MongoDB\n  mongoose.connect(`mongodb://localhost:27017/test-app`, { useNewUrlParser: true, useUnifiedTopology: true });\n\n  // Initialize Deployd backend\n  const deployd = new deployd({\n    port: process.env.PORT || 3000,\n    host: 'localhost',\n    db: 'test-app',\n    secret: 'your-secret-key'\n  });\n\n  deployd.start((err) => {\n    if (err) {\n      console.error('Error starting Deployd:', err);\n      return;\n    }\n    console.log('Deployd backend started successfully');\n  });\n\n  // Handle WebSocket connections\n  io.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  // Start the server\n  server.listen(process.env.PORT || 3000, () => {\n    console.log(`Server running on port ${process.env.PORT || 3000}`);\n  });\n}\n\nsetupWebSocketServer();"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Write a function that retrieves TV channel information from multiple regions, processes the data, and returns a unique list of channels based on their site IDs.\n\nFunction Description: The function `channels` makes HTTP GET requests to a TV channel API for multiple regions, collects channel data from all available pages for each region, and returns a deduplicated list of channels. It uses axios for HTTP requests and lodash for data processing.\n\nInput: None (The function uses hardcoded region IDs internally)\n\nOutput: An array of objects representing unique TV channels, where each object contains:\n- lang: string - Language code ('ru' for Russian)\n- name: string - Name of the TV channel\n- site_id: string/number - Unique identifier for the channel on the site\n\nThe output is deduplicated based on the site_id field using lodash's uniqBy function.",
    "Canonical_solution": "async function channels() {\n    const _ = require('lodash')\n    const axios = require('axios')\n\n    const regions = [5506, 1096, 1125, 285]\n    let channels = []\n    for (let region of regions) {\n        const totalPages = await getTotalPageCount(region)\n        const pages = Array.from(Array(totalPages).keys())\n        for (let page of pages) {\n            const data = await axios\n                .get('https://tv.mail.ru/ajax/channel/list/', {\n                    params: { page },\n                    headers: {\n                        cookie: `s=fver=0|geo=${region};`\n                    }\n                })\n                .then(r => r.data)\n                .catch(console.log)\n\n            data.channels.forEach(item => {\n                channels.push({\n                    lang: 'ru',\n                    name: item.name,\n                    site_id: item.id\n                })\n            })\n        }\n    }\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "right_result": "const axios = require('axios');\nconst _ = require('lodash');\n\nasync function channels() {\n  const regions = ['RU', 'US', 'UK']; // Example hardcoded region IDs\n  const allChannels = [];\n\n  for (const region of regions) {\n    let page = 1;\n    let morePages = true;\n\n    while (morePages) {\n      try {\n        const response = await axios.get(`https://api.example.com/channels?region=${region}&page=${page}`);\n        const channelsData = response.data.channels;\n\n        if (channelsData.length === 0) {\n          morePages = false;\n          continue;\n        }\n\n        allChannels.push(...channelsData);\n        page++;\n      } catch (error) {\n        console.error(`Error fetching channels for region ${region}:`, error.message);\n        morePages = false;\n      }\n    }\n  }\n\n  return _.uniqBy(allChannels, 'site_id');\n}"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Create a function that downloads icons from a specified URL, processes them, and handles potential duplicates while maintaining error handling and callback functionality.\n\nFunction Description: The `downloadIcons` function downloads icon data from a given URL, processes the icons to extract relevant information, checks for duplicate names, and downloads the SVG files. It handles errors appropriately and uses a callback to return the processed data or errors. The function also supports configuration for handling duplicates and customizing the download process.\n\nInput:  \n- `url` [String] - The URL from which to download the icon data.  \n- `style` [String] - The style of the icons (e.g., \"solid\", \"outline\").  \n- `callback` [Function] - A callback function that handles the processed data or errors. The callback signature is `(error, data)`.  \n\nOutput:  \n- The function does not return a value directly but invokes the `callback` with either:  \n  - An error object if an error occurs during the process.  \n  - An array of processed icon data objects sorted by name if successful. Each object includes details like `name`, `svg`, `category`, `style`, `tags`, `code`, `unicode`, and `pro` status.  \n\nAdditional Notes:  \n- The function uses Axios for HTTP requests and includes default headers for JSON acceptance and credentials.  \n- Duplicate handling is optional and can be controlled via the `breakOnError` flag (not shown in inputs but implied by the reference code).  \n- Downloaded SVGs are saved to a specified directory (`targetImagePath`), and metadata is compiled into an array for the callback.  \n- Error handling includes logging and callback invocation with errors, as well as file operations for duplicate tracking.",
    "Canonical_solution": "const axios = require('axios')\n\nfunction downloadIcons(url, style, callback) {\n  axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest'\n  axios.defaults.headers.common['Accept'] = 'application/json'\n  axios.defaults.withCredentials = true\n\n  axios.get(url).then((response) => {\n    const data = []\n    const icons = response.data.response.unicons.map((item) => ({\n      ...item,\n      allTags: item.name,\n      name: item.tags[item.tags.length - 1],\n    }))\n\n    const names = icons.map((icon) => icon.name)\n    const uniqueNames = uniq(names)\n    const repeated = countDuplicates(names)\n    const duplicates = filter(repeated, (item) => item.count > 1)\n\n    if (duplicates.length && breakOnError) {\n      console.log(\n        `Total Icons: ${names.length}, Unique Names: ${uniqueNames.length}`\n      )\n\n      console.log(`${style} Duplicates:`, duplicates)\n\n      let dupFiles = []\n      duplicates.forEach((d) => {\n        dupFiles = [...dupFiles, ...filter(icons, { name: d.value })]\n      })\n\n      fs.writeFileSync(\n        `${style}-duplicates.json`,\n        JSON.stringify(dupFiles),\n        'utf-8'\n      )\n\n      throw new Error('There are duplicate files')\n    }\n\n    eachLimit(\n      icons,\n      50,\n      async (row) => {\n        const url = row.svg\n        const name = row.name\n        const fileName = `${name}.svg`\n        const filePath = path.resolve(targetImagePath, fileName)\n\n        try {\n          await downloadImage(url, filePath)\n\n          const charCodeExists = existingConfig.find((i) => i.name === name)\n          const charCode =\n            charCodeExists && charCodeExists.code\n              ? charCodeExists.code\n              : startCharCode++\n\n          data.push({\n            uuid: row.uuid,\n            id: row.id,\n            name: name,\n            svg: `svg/${style}/${fileName}`,\n            category: row.category,\n            style: upperFirst(style),\n            tags: row.tags,\n            code: charCode,\n            unicode: charCode.toString(16),\n            pro: Boolean(row.price),\n          })\n        } catch (error) {\n          console.error(error)\n          console.log('Error Downloading:', name)\n        }\n      },\n      (err, results) => {\n        if (err) {\n          console.log(results)\n          throw err\n        }\n\n        console.log(`${data.length} Images Downloaded!`)\n        callback(null, sortBy(data, 'name'))\n      }\n    )\n  }).catch(err => {\n    callback(err)\n  })\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "right_result": "const axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction downloadIcons(url, style, callback) {\n  const targetImagePath = path.join(__dirname, 'icons');\n  fs.mkdirSync(targetImagePath, { recursive: true });\n\n  let icons = [];\n  let seen = new Set();\n\n  async function fetchIconData() {\n    try {\n      const response = await axios.get(url, {\n        headers: {\n          'Accept': 'application/json',\n          'Authorization': 'Bearer your_token_here'\n        }\n      });\n\n      if (response.status !== 200) {\n        return callback(new Error(`Failed to fetch icon data: ${response.status}`));\n      }\n\n      const data = response.data;\n      for (const icon of data.icons) {\n        const name = icon.name;\n        if (seen.has(name)) {\n          if (process.env.BREAK_ON_ERROR) {\n            return callback(new Error(`Duplicate icon name: ${name}`));\n          }\n          continue;\n        }\n        seen.add(name);\n\n        const svg = icon.svg;\n        const category = icon.category;\n        const tags = icon.tags || [];\n        const code = icon.code;\n        const unicode = icon.unicode;\n        const pro = icon.pro;\n\n        const filePath = path.join(targetImagePath, `${name}.svg`);\n        fs.writeFileSync(filePath, svg);\n\n        icons.push({\n          name,\n          svg,\n          category,\n          style,\n          tags,\n          code,\n          unicode,\n          pro\n        });\n      }\n\n      icons.sort((a, b) => a.name.localeCompare(b.name));\n      callback(null, icons);\n    } catch (error) {\n      console.error('Error during icon download or processing:', error.message);\n      callback(error);\n    }\n  }\n\n  fetchIconData();\n}"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Create a function that retrieves TV channel information from multiple providers and returns a list of unique channels.\n\nFunction Description: The function makes HTTP POST requests to a TV guide service for each provider, extracts channel information from the HTML response, and returns a deduplicated list of channels. It uses axios for HTTP requests, cheerio for HTML parsing, and lodash for deduplication.\n\nInput: None (The function uses hardcoded providers and parameters)\n\nOutput: Array of objects - Returns an array of channel objects containing language, name, and site_id (deduplicated by site_id). Each channel object has the following structure:\n{\n    lang: string,    // Language code ('fr' for French)\n    name: string,    // Channel name\n    site_id: string  // Unique identifier combining channel number and slug\n}",
    "Canonical_solution": "function async channels() {\n    const axios = require('axios')\n    const _ = require('lodash')\n\n    const providers = ['-1', '-2', '-3', '-4', '-5']\n\n    const channels = []\n    for (let provider of providers) {\n        const data = await axios\n            .post('https://www.tvcesoir.fr/guide/schedule', null, {\n                params: {\n                    provider,\n                    region: 'France',\n                    TVperiod: 'Night',\n                    date: dayjs().format('YYYY-MM-DD'),\n                    st: 0,\n                    u_time: 2155,\n                    is_mobile: 1\n                }\n            })\n            .then(r => r.data)\n            .catch(console.log)\n\n        const $ = cheerio.load(data)\n        $('.channelname').each((i, el) => {\n            const name = $(el).find('center > a:eq(1)').text()\n            const url = $(el).find('center > a:eq(1)').attr('href')\n            const [, number, slug] = url.match(/\\/(\\d+)\\/(.*)\\.html$/)\n\n            channels.push({\n                lang: 'fr',\n                name,\n                site_id: `${number}/${slug}`\n            })\n        })\n    }\n\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "right_result": "const axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getUniqueChannels() {\n  const providers = [\n    { url: 'https://provider1.com/guide', params: { format: 'xml' } },\n    { url: 'https://provider2.com/TV', params: { type: 'channels' } }\n  ];\n\n  const channels = [];\n\n  for (const provider of providers) {\n    try {\n      const response = await axios.post(provider.url, provider.params);\n      const $ = cheerio.load(response.data);\n      // Example parsing logic - adjust based on actual HTML structure\n      $('channel').each((i, element) => {\n        const name = $(element).find('name').text();\n        const lang = $(element).find('language').attr('code') || 'en';\n        const channelNumber = $(element).find('number').text();\n        const slug = $(element).find('slug').text();\n        const siteId = `${channelNumber}-${slug}`;\n        channels.push({ lang, name, site_id: siteId });\n      });\n    } catch (error) {\n      console.error(`Error fetching from ${provider.url}:`, error.message);\n    }\n  }\n\n  return _.uniqBy(channels, 'site_id');\n}"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Create a function that uses XMLHttpRequest to asynchronously fetch data from a specified URL and returns a Promise that resolves on successful request completion or rejects on failure.\n\nFunction Description: The function `getDataXhr` initiates an HTTP GET request to the provided URL using XMLHttpRequest. It sets appropriate headers for JSON content, handles the response asynchronously through Promise callbacks, and manages both successful and failed request scenarios.\n\nInput: \n- url [String] - The URL from which data should be fetched\n\nOutput: \n- [Promise] - A Promise that resolves when the request completes successfully (onload) or rejects when the request fails (onerror)",
    "Canonical_solution": "function getDataXhr(url) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Content-Type', 'application/json');\n    req.setRequestHeader('Accept', 'application/json');\n    req.onload = () => {\n      resolve();\n    };\n    req.onerror = () => {\n      reject();\n    };\n    req.send();\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "right_result": "function getDataXhr(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = function () {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(new Error('Request failed with status: ' + xhr.status));\n      }\n    };\n    xhr.onerror = function () {\n      reject(new Error('Request failed'));\n    };\n    xhr.send();\n  });\n}"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Implement an asynchronous function that makes an HTTP request using XMLHttpRequest with timeout handling, customizable request options, and proper error management.\n\nFunction Description: The function `_xhrRequestWithTimeout` performs an HTTP request using XMLHttpRequest with configurable method, URL, and request options. It includes timeout handling, response type configuration, custom headers, and proper cleanup of resources. The function returns a Promise that resolves with the XMLHttpRequest object on success or rejects with an error or timeout message.\n\nInput:\n- `method` (string): The HTTP method to use for the request (e.g., 'GET', 'POST').\n- `url` (string): The URL to which the request is sent.\n- `options` (RequestOptions): An object containing additional request configurations:\n  - `responseType` (optional, string): The expected response type (e.g., 'json', 'arraybuffer').\n  - `headers` (optional, object): Key-value pairs representing request headers.\n  - `body` (optional, any): The request payload to send.\n\nOutput:\n- Returns a Promise that:\n  - Resolves with the XMLHttpRequest object if the request succeeds.\n  - Rejects with an error object if the request fails.\n  - Rejects with the string 'timeout' if the request times out.",
    "Canonical_solution": "async function _xhrRequestWithTimeout(method: string, url: string, options: RequestOptions): Promise<XMLHttpRequest> {\n    return new Promise((resolve, reject) => {\n        log('[requests XHR]', method, url);\n        let timedOut = false;\n        const timer = setTimeout(() => {\n            timedOut = true;\n            reject('timeout');\n        }, config.requestTimeout);\n        const xhr = new XMLHttpRequest();\n        xhr.open(method, url, true);\n        if (options.responseType) {\n            xhr.responseType = options.responseType;\n        }\n        if (options.headers) {\n            for (const key in options.headers) {\n                xhr.setRequestHeader(key, options.headers[key]);\n            }\n        }\n        xhr.onload = (): void => {\n            if (timedOut) {\n                return;\n            }\n            clearTimeout(timer);\n            resolve(xhr);\n        };\n        xhr.onerror = (error): void => {\n            if (timedOut) {\n                return;\n            }\n            clearTimeout(timer);\n            reject(error);\n        };\n        let body = options.body;\n        if (typeof (body) === 'object' && !isArrayBufferView(body) && body instanceof ArrayBuffer) {\n            body = new Uint8Array(body);\n        }\n        xhr.send(body);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "right_result": "function _xhrRequestWithTimeout(method, url, options = {}) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const timeoutId = setTimeout(() => {\n      xhr.abort();\n      reject('timeout');\n    }, options.timeout || 5000);\n\n    xhr.open(method, url, true);\n\n    if (options.headers) {\n      Object.entries(options.headers).forEach(([key, value]) => {\n        xhr.setRequestHeader(key, value);\n      });\n    }\n\n    if (options.responseType) {\n      xhr.responseType = options.responseType;\n    }\n\n    xhr.onload = function () {\n      clearTimeout(timeoutId);\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error(`HTTP error! status: ${xhr.status}, response: ${xhr.responseText}`));\n      }\n    };\n\n    xhr.onerror = function () {\n      clearTimeout(timeoutId);\n      reject(new Error('Network error'));\n    };\n\n    if (options.body) {\n      xhr.send(options.body);\n    } else {\n      xhr.send();\n    }\n  });\n}"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Implement a class for handling chunked data loading via XMLHttpRequest with support for range requests, progress tracking, and error handling.\n\nClass Description: The MozChunkedLoader class is designed to handle asynchronous loading of chunked binary data from a server using XMLHttpRequest with 'moz-chunked-arraybuffer' response type. It supports range requests, tracks loading progress, handles redirects, and provides comprehensive error handling.\n\nAttributes:\n- _seekHandler: [Object] - Handler for URL and range configuration\n- _config: [Object] - Configuration object for the loader\n- _needStash: [Boolean] - Flag indicating whether data needs to be stashed\n- _xhr: [XMLHttpRequest|null] - The XMLHttpRequest instance\n- _requestAbort: [Boolean] - Flag indicating if the request was aborted\n- _contentLength: [Number|null] - Total content length of the resource\n- _receivedLength: [Number] - Number of bytes received so far\n- _dataSource: [Object] - Data source configuration\n- _range: [Object] - Request range parameters\n- _requestURL: [String] - The URL used for the request\n\nMethods:\n- constructor(seekHandler, config) -> [MozChunkedLoader] - Initializes the loader with seek handler and configuration\n- open(dataSource, range) -> [void] - Opens a connection to the specified data source with range parameters\n- abort() -> [void] - Aborts the current request\n- _onReadyStateChange(e) -> [void] - Handles XMLHttpRequest ready state changes\n- _onProgress(e) -> [void] - Handles progress events during data loading\n- _onLoadEnd(e) -> [void] - Handles request completion\n- _onXhrError(e) -> [void] - Handles XMLHttpRequest errors\n\nEvent Callbacks (to be set externally):\n- _onURLRedirect: [Function] - Called when URL redirection occurs\n- _onError: [Function] - Called when an error occurs\n- _onContentLengthKnown: [Function] - Called when content length is determined\n- _onDataArrival: [Function] - Called when new data chunk arrives\n- _onComplete: [Function] - Called when loading completes successfully",
    "Canonical_solution": "class MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = true;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n\n        let sourceURL = dataSource.url;\n        if (this._config.reuseRedirectedURL && dataSource.redirectedURL != undefined) {\n            sourceURL = dataSource.redirectedURL;\n        }\n\n        let seekConfig = this._seekHandler.getConfig(sourceURL, range);\n        this._requestURL = seekConfig.url;\n\n        let xhr = this._xhr = new XMLHttpRequest();\n        xhr.open('GET', seekConfig.url, true);\n        xhr.responseType = 'moz-chunked-arraybuffer';\n        xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n        xhr.onprogress = this._onProgress.bind(this);\n        xhr.onloadend = this._onLoadEnd.bind(this);\n        xhr.onerror = this._onXhrError.bind(this);\n\n        if (dataSource.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        if (typeof seekConfig.headers === 'object') {\n            let headers = seekConfig.headers;\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        if (typeof this._config.headers === 'object') {\n            let headers = this._config.headers;\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        xhr.send();\n    }\n\n    abort() {\n        this._requestAbort = true;\n        if (this._xhr) {\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        let xhr = e.target;\n        if (xhr.readyState === 2) {\n            if (xhr.responseURL != undefined && xhr.responseURL !== this._requestURL) {\n                if (this._onURLRedirect) {\n                    let redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n                    this._onURLRedirect(redirectedURL);\n                }\n            }\n\n            if (xhr.status !== 0 && (xhr.status < 200 || xhr.status > 299)) {\n                if (this._onError) {\n                    this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {code: xhr.status, msg: xhr.statusText});\n                }\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (this._contentLength === null) {\n            if (e.total !== null && e.total !== 0) {\n                this._contentLength = e.total;\n                if (this._onContentLengthKnown) {\n                    this._onContentLengthKnown(this._contentLength);\n                }\n            }\n        }\n\n        let chunk = e.target.response;\n        let byteStart = this._range.from + this._receivedLength;\n        this._receivedLength += chunk.byteLength;\n\n        if (this._onDataArrival) {\n            this._onDataArrival(chunk, byteStart, this._receivedLength);\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (this._requestAbort === true) {\n            this._requestAbort = false;\n            return;\n        }\n\n        if (this._onComplete) {\n            this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);\n        }\n    }\n\n    _onXhrError(e) {\n        let type = 0;\n        let info = null;\n\n        if (this._contentLength && e.loaded < this._contentLength) {\n            type = LoaderErrors.EARLY_EOF;\n            info = {code: -1, msg: 'Moz-Chunked stream meet Early-Eof'};\n        } else {\n            type = LoaderErrors.EXCEPTION;\n            info = {code: -1, msg: e.constructor.name + ' ' + e.type};\n        }\n\n        if (this._onError) {\n            this._onError(type, info);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "right_result": "class MozChunkedLoader {\n  constructor(seekHandler, config) {\n    this._seekHandler = seekHandler;\n    this._config = config;\n    this._needStash = false;\n    this._xhr = null;\n    this._requestAbort = false;\n    this._contentLength = null;\n    this._receivedLength = 0;\n    this._dataSource = {};\n    this._range = {};\n    this._requestURL = '';\n  }\n\n  open(dataSource, range) {\n    this._dataSource = dataSource;\n    this._range = range;\n    this._requestURL = dataSource.url;\n    this._xhr = new XMLHttpRequest();\n    this._xhr.open('GET', this._requestURL, true);\n    this._xhr.responseType = 'moz-chunked-arraybuffer';\n    this._xhr.onprogress = this._onProgress.bind(this);\n    this._xhr.ontimeout = this._onXhrError.bind(this);\n    this._xhr.onloadend = this._onLoadEnd.bind(this);\n    this._xhr.onerror = this._onXhrError.bind(this);\n    this._xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n    this._xhr.setRequestHeader('Range', 'bytes=' + this._range.start + '-' + this._range.end);\n    this._xhr.send();\n  }\n\n  abort() {\n    if (this._xhr) {\n      this._xhr.abort();\n      this._requestAbort = true;\n    }\n  }\n\n  _onReadyStateChange(e) {\n    if (this._xhr.readyState === 4) {\n      if (this._xhr.status === 206) {\n        this._onDataArrival(this._xhr.response);\n      } else if (this._xhr.status === 302) {\n        this._onURLRedirect(this._xhr.responseURL);\n      } else {\n        this._onError(new Error('Request failed with status: ' + this._xhr.status));\n      }\n    }\n  }\n\n  _onProgress(e) {\n    if (e.lengthComputable) {\n      this._receivedLength = e.loaded;\n      if (this._onDataArrival) {\n        this._onDataArrival(e.loaded);\n      }\n    }\n  }\n\n  _onLoadEnd(e) {\n    if (!this._requestAbort) {\n      if (this._xhr.status === 200 || this._xhr.status === 206) {\n        this._onComplete();\n      } else {\n        this._onError(new Error('Request failed with status: ' + this._xhr.status));\n      }\n    }\n  }\n\n  _onXhrError(e) {\n    this._onError(new Error('XMLHttpRequest error: ' + e.message));\n  }\n}"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a JavaScript class that implements HTTP client functionality for making JSON-based requests (GET, POST, DELETE) with token-based authorization.\n\nClass Description: The JSONHttpClient class provides methods for making HTTP requests to interact with JSON APIs. It handles request configuration, authorization headers, response parsing, and error handling. The class maintains an authorization token that is automatically included in all requests.\n\nAttributes:\ntoken: [String] - An authorization token stored in localStorage or generated randomly if not available\n\nMethods:\nconstructor: [] -> [void] - Initializes the client instance and sets/retrieves the authorization token\n\nsetToken: [req: XMLHttpRequest] -> [void] - Sets the authorization header on the given request object\n\ngetJSON: [url: String, callback: Function] -> [void] - Makes a GET request to the specified URL and invokes the callback with parsed JSON response or error\n\npostJSON: [url: String, obj: Object, callback: Function] -> [void] - Makes a POST request with JSON payload to the specified URL and invokes the callback with parsed response\n\ndeleteJSON: [url: String, callback: Function] -> [void] - Makes a DELETE request to the specified URL and invokes the callback with response text or error after a random delay",
    "Canonical_solution": "const XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\n\nclass JSONHttpClient {\n  constructor() {\n    this.token = localStorage.token || Date.now() * Math.random();\n    localStorage.token = this.token;\n  }\n\n  setToken(req) {\n    req.setRequestHeader(\"authorization\", this.token);\n  }\n\n  getJSON(url, callback) {\n    const req = new XMLHttpRequest();\n    req.onload = function() {\n      if (req.status === 404) {\n        callback(new Error(\"not found\"));\n      } else {\n        callback(null, JSON.parse(req.response));\n      }\n    };\n    req.open(\"GET\", url);\n    this.setToken(req);\n    req.send();\n  }\n\n  postJSON(url, obj, callback) {\n    const req = new XMLHttpRequest();\n    req.onload = function() {\n      callback(JSON.parse(req.response));\n    };\n    req.open(\"POST\", url);\n    req.setRequestHeader(\n      \"Content-Type\",\n      \"application/json;charset=UTF-8\"\n    );\n    this.setToken(req);\n    req.send(JSON.stringify(obj));\n  }\n\n  deleteJSON(url, callback) {\n    const req = new XMLHttpRequest();\n    req.onload = function() {\n      setTimeout(() => {\n        if (req.status === 500) {\n          callback(new Error(req.responseText));\n        } else {\n          callback(null, req.responseText);\n        }\n      }, Math.random() * 5000);\n    };\n    req.open(\"DELETE\", url);\n    this.setToken(req);\n    req.send();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "right_result": "class JSONHttpClient {\n  constructor() {\n    this.token = localStorage.getItem('authToken') || this.generateToken();\n    this.setToken = (req) => {\n      if (this.token) {\n        req.setRequestHeader('Authorization', `Bearer ${this.token}`);\n      }\n    };\n  }\n\n  generateToken() {\n    return Math.random().toString(36).substr(2, 9);\n  }\n\n  getJSON(url, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    this.setToken(xhr);\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(null, JSON.parse(xhr.responseText));\n      } else {\n        callback(xhr.statusText, null);\n      }\n    };\n    xhr.onerror = () => {\n      callback('Network Error', null);\n    };\n    xhr.send();\n  }\n\n  postJSON(url, obj, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', url, true);\n    this.setToken(xhr);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(null, JSON.parse(xhr.responseText));\n      } else {\n        callback(xhr.statusText, null);\n      }\n    };\n    xhr.onerror = () => {\n      callback('Network Error', null);\n    };\n    xhr.send(JSON.stringify(obj));\n  }\n\n  deleteJSON(url, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('DELETE', url, true);\n    this.setToken(xhr);\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(null, xhr.responseText);\n      } else {\n        callback(xhr.statusText, null);\n      }\n    };\n    xhr.onerror = () => {\n      callback('Network Error', null);\n    };\n    // Add random delay\n    const delay = Math.random() * 1000;\n    setTimeout(() => {\n      xhr.send();\n    }, delay);\n  }\n}"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a function that asynchronously retrieves JSON data from a specified URL using XMLHttpRequest and handles the response through a callback function.\n\nFunction Description: The function `getJSON` initiates an HTTP GET request to the provided URL, expecting a JSON response. It handles the response asynchronously, passing either the retrieved JSON data or an error status to the callback function. The function uses modern XMLHttpRequest features like responseType='json' for automatic JSON parsing.\n\nInput:\n- `url` [String] - The URL from which to fetch JSON data\n- `callback` [Function] - A function that handles the response, taking two parameters:\n  - First parameter: Error status (null if successful, HTTP status code if error)\n  - Second parameter: Response data (parsed JSON object if successful, raw response if error)\n\nOutput: None (results are handled asynchronously through the callback function)",
    "Canonical_solution": "function getJSON(url, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'json';\n    xhr.onload = function() {\n      var status = xhr.status;\n      if (status === 200) {\n        callback(null, xhr.response);\n      } else {\n        callback(status, xhr.response);\n      }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "right_result": "function getJSON(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.responseType = 'json';\n\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      callback(null, xhr.response);\n    } else {\n      callback(xhr.status, xhr.response);\n    }\n  };\n\n  xhr.onerror = function() {\n    callback(xhr.status, xhr.response);\n  };\n\n  xhr.send();\n}"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a function that makes a cross-origin XMLHttpRequest (XHR) to a specified URL, sets custom headers, and handles the response or error appropriately.\n\nFunction Description: The function `makeXHRRequest` initiates an asynchronous GET request to a cross-origin URL, sets a custom header, and defines callbacks for handling successful responses and errors. The URL is processed by the `corsURL` helper function to ensure proper cross-origin request handling.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function handles the response or error internally via callbacks.)\n\n---\n\nTask Description: Create a helper function that constructs a cross-origin URL from a given path.\n\nFunction Description: The function `corsURL` takes a relative path and constructs a full URL by combining it with the current location's hostname, replacing the hostname with a remote hostname obtained from `get_host_info()`.\n\nInput: \n- `path` [String] - The relative path to the resource.\n\nOutput: \n- [String] - The fully constructed cross-origin URL.",
    "Canonical_solution": "function corsURL(path) {\n    const url = new URL(path, location.href);\n    url.hostname = get_host_info().REMOTE_HOST;\n    return url.href;\n}\n\nfunction makeXHRRequest() {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", corsURL(\"resources/access-control-preflight-request-allow-headers-returns-star.py\"));\n    xhr.setRequestHeader(\"X-Test\", \"foobar\");\n    xhr.onerror = t.unreached_func(\"Error occurred.\");\n    xhr.onload = t.step_func_done(() => {\n        assert_equals(xhr.status, 200);\n        assert_equals(xhr.responseText, \"PASS\");\n    });\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "right_result": "function makeXHRRequest() {\n  var url = corsURL('/api/data');\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.setRequestHeader('Custom-Header', 'Value');\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      console.log('Success:', xhr.responseText);\n    } else {\n      console.error('Error:', xhr.statusText);\n    }\n  };\n  xhr.onerror = function() {\n    console.error('Request failed');\n  };\n  xhr.send();\n}\n\nfunction get_host_info() {\n  return {\n    hostname: 'remote.example.com'\n  };\n}\n\nfunction corsURL(path) {\n  var currentHostname = window.location.hostname;\n  var remoteHostname = get_host_info().hostname;\n  return 'https://' + remoteHostname + path;\n}"
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Create a function that asynchronously loads and decodes audio files for musical instruments using XMLHttpRequest and the Web Audio API, with caching support to avoid redundant requests.\n\nFunction Description: The function `getNote` retrieves an audio file for a specific musical note and instrument from a server, decodes it using the Web Audio API, and caches the result for future use. It returns a Promise that resolves with the decoded audio buffer or rejects with an error if loading or decoding fails.\n\nInput:\n- `url` [String] - Base URL for the audio files\n- `instrument` [String] - Name of the musical instrument\n- `name` [String] - Name of the musical note\n- `audioContext` [AudioContext] - Web Audio API context for decoding audio\n\nOutput:\n- [Promise] - Resolves with an object containing:\n  - `instrument` [String] - The instrument name\n  - `name` [String] - The note name\n  - `status` [String] - Loading status (\"loaded\")\n  - `audioBuffer` [AudioBuffer] - Decoded audio data\n- Rejects with an Error if loading or decoding fails",
    "Canonical_solution": "function getNote(url, instrument, name, audioContext) {\n\tif (!soundsCache[instrument]) soundsCache[instrument] = {};\n\tvar instrumentCache = soundsCache[instrument];\n\n\tif (!instrumentCache[name])\n\t\tinstrumentCache[name] = new Promise(function (resolve, reject) {\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\tlet noteUrl = url + instrument + \"-mp3/\" + name + \".mp3\";\n\t\t\txhr.open(\"GET\", noteUrl, true);\n\t\t\txhr.responseType = \"arraybuffer\";\n\t\t\txhr.onload = function () {\n\t\t\t\tif (xhr.status !== 200) {\n\t\t\t\t\treject(Error(\"Can't load sound at \" + noteUrl + ' status=' + xhr.status));\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tvar noteDecoded = function(audioBuffer) {\n\t\t\t\t\tresolve({instrument: instrument, name: name, status: \"loaded\", audioBuffer: audioBuffer})\n\t\t\t\t}\n\t\t\t\tvar maybePromise = audioContext.decodeAudioData(xhr.response, noteDecoded, function () {\n\t\t\t\t\treject(Error(\"Can't decode sound at \" + noteUrl));\n\t\t\t\t});\n\t\t\t\tif (maybePromise && typeof maybePromise.catch === \"function\") maybePromise.catch(reject);\n\t\t\t};\n\t\t\txhr.onerror = function () {\n\t\t\t\treject(Error(\"Can't load sound at \" + noteUrl));\n\t\t\t};\n\t\t\txhr.send();\n\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tconsole.error(\"Didn't load note\", instrument, name, \":\", err.message);\n\t\t\t\tthrow err;\n\t\t\t});\n\n\treturn instrumentCache[name];\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "right_result": "async function getNote(url, instrument, name, audioContext) {\n  const cacheKey = `${instrument}-${name}`;\n  const cached = localStorage.getItem(cacheKey);\n  if (cached) {\n    const { audioBuffer, status } = JSON.parse(cached);\n    if (status === \"loaded\") {\n      return { instrument, name, status, audioBuffer };\n    }\n  }\n\n  const xhr = new XMLHttpRequest();\n  xhr.open(\"GET\", `${url}/${instrument}/${name}.wav`, true);\n  xhr.responseType = \"arraybuffer\";\n\n  return new Promise((resolve, reject) => {\n    xhr.onload = function () {\n      if (xhr.status === 200) {\n        audioContext.decodeAudioData(xhr.response, function (buffer) {\n          const result = { instrument, name, status: \"loaded\", audioBuffer: buffer };\n          localStorage.setItem(cacheKey, JSON.stringify(result));\n          resolve(result);\n        }, function (error) {\n          reject(new Error(`Failed to decode audio: ${error}`));\n        });\n      } else {\n        reject(new Error(`Failed to load audio: ${xhr.statusText}`));\n      }\n    };\n\n    xhr.onerror = function () {\n      reject(new Error(`XMLHttpRequest error: ${xhr.statusText}`));\n    };\n\n    xhr.send();\n  });\n}"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Implement a request service class that handles HTTP requests including downloading files and performing various HTTP methods (GET, PUT, POST) with proper headers and data handling.\n\nClass Description: The BasicRequestService class implements IRequestService interface to provide HTTP request functionality. It uses XMLHttpRequest for file downloads and umi-request for standard HTTP methods. The class handles permissions checking before downloads and supports configurable request options.\n\nAttributes:\n- requestMethod: RequestMethod - An instance of umi-request's RequestMethod used for standard HTTP requests\n\nMethods:\n- download(url: string) -> Promise<Blob> - Downloads a file from the specified URL after checking permissions. Returns a Promise that resolves with the downloaded Blob.\n  - url: string - The URL of the file to download\n  - Returns: Promise<Blob> - A promise resolving to the downloaded file as a Blob\n\n- request(url: string, options: TRequestOption) -> Promise<any> - Performs an HTTP request based on the specified options (method, headers, data).\n  - url: string - The target URL for the request\n  - options: TRequestOption - Configuration object containing:\n    - method: string - HTTP method ('get', 'put', or 'post')\n    - headers: object - Optional request headers\n    - data: any - Optional request payload\n    - requestType: string - Optional request type for POST requests\n  - Returns: Promise<any> - A promise resolving to the response data\n  - Throws: Error - When an unsupported request method is specified",
    "Canonical_solution": "import { IPermissionsService } from './../../common/permissions';\nimport { extend, RequestMethod } from 'umi-request';\nimport { IRequestService, IBasicRequestService, TRequestOption } from '@/service/common/request';\nimport Container, { Service } from 'typedi';\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n  constructor() {\n    this.requestMethod = extend({});\n  }\n\n  async download(url: string) {\n    const permissionsService = Container.get(IPermissionsService);\n    await permissionsService.request({ origins: [`${new URL(url).origin}/*`] });\n    return new Promise<Blob>(resolve => {\n      let oReq = new XMLHttpRequest();\n      oReq.open('GET', url, true);\n      oReq.responseType = 'blob';\n      oReq.onload = function() {\n        let blob = oReq.response;\n        resolve(blob);\n      };\n      oReq.send();\n    });\n  }\n\n  request(url: string, options: TRequestOption) {\n    switch (options.method) {\n      case 'get': {\n        return this.requestMethod.get(url, {\n          headers: options.headers,\n        });\n      }\n      case 'put': {\n        return this.requestMethod.put(url, {\n          headers: options.headers,\n          data: options.data,\n        });\n      }\n      case 'post': {\n        return this.requestMethod.post(url, {\n          headers: options.headers,\n          data: options.data,\n          requestType: options.requestType,\n        });\n      }\n      default: {\n        throw new Error('Unsupported request method');\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "right_result": "```javascript\nclass BasicRequestService {\n  constructor() {\n    this.requestMethod = new (require('umi-request').RequestMethod)();\n  }\n\n  async download(url) {\n    if (!this.checkPermission(url)) {\n      throw new Error('Download permission denied');\n    }\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = 'blob';\n      xhr.onload = () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          resolve(new Blob([xhr.response]));\n        } else {\n          reject(new Error(`Download failed: ${xhr.status} ${xhr.statusText}`));\n        }\n      };\n      xhr.onerror = () => {\n        reject(new Error('Download failed: Network error'));\n      };\n      xhr.send();\n    });\n  }\n\n  request(url, options) {\n    if (!['get', 'put', 'post'].includes(options.method)) {\n      throw new Error(`Unsupported request method: ${options.method}`);\n    }\n\n    return new Promise((resolve, reject) => {\n      this.requestMethod.request({\n        url,\n        method: options.method,\n        headers: options.headers,\n        data: options.data,\n        responseType: 'json',\n        timeout: 10000\n      }).then(response => {\n        resolve(response.data);\n      }).catch(error => {\n        reject(error);\n      });\n    });\n  }\n\n  checkPermission(url) {\n    // Placeholder for permission checking logic\n    return true;\n  }\n}\n```"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Implement a function to handle form submission asynchronously using XMLHttpRequest in JavaScript. The function should prevent default form submission, process form data, send it to a server via POST request, and handle the server's response to display a thank-you message upon successful submission.\n\nFunction Description: The function `handleFormSubmit` intercepts form submission events, validates the form data (checking for honeypot fields), disables all buttons during submission, sends the form data to a specified URL via POST request, and processes the server's response to update the UI accordingly.\n\nInput: \n- `event`: [Event Object] - The form submission event that triggers this function. The event object contains the target form element and allows prevention of default submission behavior.\n\nOutput: \n- None (void) - The function does not return any value but performs side effects including:\n  - Preventing default form submission\n  - Disabling form buttons during submission\n  - Sending form data to the server\n  - Updating the UI based on server response (resetting form and showing thank-you message)",
    "Canonical_solution": "function handleFormSubmit(event) {\n    event.preventDefault();\n    var form = event.target;\n    var formData = getFormData(form);\n    var data = formData.data;\n\n    if (formData.honeypot) {\n        return false;\n    }\n\n    disableAllButtons(form);\n    var url = form.action;\n    var xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n    xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            form.reset();\n            var formElements = form.querySelector(\".form-elements\")\n            if (formElements) {\n                formElements.style.display = \"none\";\n            }\n            var thankYouMessage = form.querySelector(\".thankyou_message\");\n            if (thankYouMessage) {\n                thankYouMessage.style.display = \"block\";\n            }\n        }\n    };\n    var encoded = Object.keys(data).map(function(k) {\n        return encodeURIComponent(k) + \"=\" + encodeURIComponent(data[k]);\n    }).join('&');\n    xhr.send(encoded);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "right_result": "function handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n\n  const formData = new FormData(form);\n  const data = {};\n  for (let [key, value] of formData.entries()) {\n    data[key] = value;\n  }\n\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState === 4) {\n      if (xhr.status === 200) {\n        const response = JSON.parse(xhr.responseText);\n        if (response.success) {\n          form.reset();\n          const thankYouMessage = document.getElementById('thank-you-message');\n          thankYouMessage.style.display = 'block';\n        } else {\n          alert('Submission failed. Please try again.');\n        }\n      }\n    }\n  };\n\n  xhr.send(JSON.stringify(data));\n}"
  },
  {
    "Task_id": 52,
    "Instruction": "Task Description: Create a function that toggles the featured status of a project by sending an asynchronous HTTP POST request to a server and updates the UI accordingly.\n\nFunction Description: The function `setFeatured` sends a POST request to a server endpoint to toggle the featured status of a specified project. It handles the response asynchronously and updates the UI to reflect the new featured status. The function uses XMLHttpRequest for the HTTP communication and expects a JSON response from the server.\n\nInput: \n- `projectId` [String/Number] - The unique identifier of the project whose featured status is to be toggled.\n- `featured` [Boolean] - The current featured status of the project (true if featured, false otherwise).\n\nOutput: \n- None (void) - The function does not return a value but updates the UI element (div) to display a star (\u2605) if the project is featured or an empty star (\u2606) if it is not. The actual toggling is handled by the server response.",
    "Canonical_solution": "function setFeatured(projectId, featured) {\n    let session = getSessionInfo();\n    var xhr = new XMLHttpRequest()\n    xhr.open(\"POST\", 'featured/' + projectId, true);\n    xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n\n    xhr.onreadystatechange = function() {\n        if (this.readyState == 4 && this.status == 200) {\n            featured = JSON.parse(this.responseText);\n            div.innerHTML = featured? '\u2605':'\u2606';\n        }\n    };\n\n    let request = {\n        userId: session.userId,\n        sessionId: session.sessionId,\n        featured: !featured\n    };\n    xhr.send(JSON.stringify(request));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "right_result": "function setFeatured(projectId, featured) {\n  const xhr = new XMLHttpRequest();\n  const url = `https://api.example.com/projects/${projectId}/toggle-featured`;\n  const data = JSON.stringify({ featured });\n\n  xhr.open('POST', url, true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n\n  xhr.onload = function () {\n    if (xhr.status === 200) {\n      const response = JSON.parse(xhr.responseText);\n      const starElement = document.getElementById(`star-${projectId}`);\n      starElement.innerHTML = response.featured ? '\u2605' : '\u2606';\n    } else {\n      console.error('Error toggling featured status:', xhr.statusText);\n    }\n  };\n\n  xhr.onerror = function () {\n    console.error('Request failed');\n  };\n\n  xhr.send(data);\n}"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a JavaScript class that handles AJAX requests using XMLHttpRequest, supporting cross-origin requests, custom headers, and various response handling scenarios.\n\nClass Description: The AjaxTransport class provides a wrapper around XMLHttpRequest for making asynchronous HTTP requests. It handles request creation, header management, response processing, and cleanup. The class supports CORS, maintains request state, and provides error handling capabilities.\n\nAttributes:\n\nxhrId: [Number] - Counter for generating unique IDs for each XMLHttpRequest instance\nxhrCallbacks: [Object] - Stores callback functions for active requests\nxhrSuccessStatus: [Object] - Maps certain HTTP status codes to standard success codes\nxhrSupported: [XMLHttpRequest|Boolean] - Stores the created XMLHttpRequest instance or false if not supported\n\nMethods:\n\ncreateXHR: () -> [XMLHttpRequest|undefined] - Creates and returns a new XMLHttpRequest instance or undefined if creation fails\n\nsendRequest: (options: Object, headers: Object, complete: Function) -> [undefined] - \n  Sends an AJAX request with the given configuration\n  options: Contains request parameters (type, url, async, etc.)\n  headers: Key-value pairs of request headers\n  complete: Callback function to handle response\n\nabortRequest: (callback: Function) -> [undefined] - \n  Aborts an active request and executes the given callback\n  callback: Function to execute after aborting\n\ngetTransport: (options: Object) -> [Object|undefined] - \n  Returns a transport object if the request can be handled\n  options: Configuration object for the request\n  Returns an object with send and abort methods or undefined if request can't be handled",
    "Canonical_solution": "var jQuery = require(\"../core\");\nvar support = require(\"../var/support\");\n\nclass AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = {\n      0: 200,\n      1223: 204\n    };\n    this.xhrSupported = this.createXHR();\n    \n    if (window.ActiveXObject) {\n      jQuery(window).on(\"unload\", () => {\n        for (var key in this.xhrCallbacks) {\n          this.xhrCallbacks[key]();\n        }\n      });\n    }\n    \n    support.cors = !!this.xhrSupported && (\"withCredentials\" in this.xhrSupported);\n    support.ajax = !!this.xhrSupported;\n  }\n\n  createXHR() {\n    try {\n      return new XMLHttpRequest();\n    } catch(e) {}\n  }\n\n  sendRequest(options, headers, complete) {\n    var xhr = options.xhr();\n    var id = ++this.xhrId;\n\n    xhr.open(options.type, options.url, options.async, options.username, options.password);\n\n    if (options.xhrFields) {\n      for (var i in options.xhrFields) {\n        xhr[i] = options.xhrFields[i];\n      }\n    }\n\n    if (options.mimeType && xhr.overrideMimeType) {\n      xhr.overrideMimeType(options.mimeType);\n    }\n\n    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n      headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n    }\n\n    for (var i in headers) {\n      xhr.setRequestHeader(i, headers[i]);\n    }\n\n    var callback = (type) => {\n      return () => {\n        if (callback) {\n          delete this.xhrCallbacks[id];\n          callback = xhr.onload = xhr.onerror = null;\n\n          if (type === \"abort\") {\n            xhr.abort();\n          } else if (type === \"error\") {\n            complete(xhr.status, xhr.statusText);\n          } else {\n            complete(\n              this.xhrSuccessStatus[xhr.status] || xhr.status,\n              xhr.statusText,\n              typeof xhr.responseText === \"string\" ? { text: xhr.responseText } : undefined,\n              xhr.getAllResponseHeaders()\n            );\n          }\n        }\n      };\n    };\n\n    xhr.onload = callback();\n    xhr.onerror = callback(\"error\");\n    callback = this.xhrCallbacks[id] = callback(\"abort\");\n\n    try {\n      xhr.send(options.hasContent && options.data || null);\n    } catch (e) {\n      if (callback) {\n        throw e;\n      }\n    }\n  }\n\n  abortRequest(callback) {\n    if (callback) {\n      callback();\n    }\n  }\n\n  getTransport(options) {\n    if (support.cors || this.xhrSupported && !options.crossDomain) {\n      return {\n        send: (headers, complete) => this.sendRequest(options, headers, complete),\n        abort: () => this.abortRequest(callback)\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "right_result": "class AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = {\n      '200': 200,\n      '201': 201,\n      '202': 202,\n      '203': 203,\n      '204': 204,\n      '205': 205,\n      '206': 206\n    };\n    this.xhrSupported = false;\n  }\n\n  createXHR() {\n    try {\n      return new XMLHttpRequest();\n    } catch (e) {\n      return undefined;\n    }\n  }\n\n  sendRequest(options, headers, complete) {\n    const xhr = this.createXHR();\n    if (!xhr) return;\n\n    this.xhrId++;\n    const id = this.xhrId;\n    const callbackKey = `onreadystatechange_${id}`;\n    this.xhrCallbacks[id] = complete;\n\n    xhr.open(options.type, options.url, options.async);\n    xhr.withCredentials = options.withCredentials || false;\n\n    for (const key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        const status = xhr.status;\n        const isSuccessful = this.xhrSuccessStatus[status] !== undefined;\n        const response = xhr.responseText;\n\n        if (isSuccessful) {\n          this.xhrCallbacks[id](null, response, status);\n        } else {\n          this.xhrCallbacks[id](new Error(`HTTP error: ${status}`), null, status);\n        }\n        delete this.xhrCallbacks[id];\n      }\n    };\n\n    xhr.send(options.data);\n  }\n\n  abortRequest(callback) {\n    for (const id in this.xhrCallbacks) {\n      const xhr = window.XMLHttpRequest && window[xhr].prototype[id];\n      if (xhr) {\n        xhr.abort();\n        callback();\n        break;\n      }\n    }\n  }\n\n  getTransport(options) {\n    if (!this.xhrSupported) {\n      return undefined;\n    }\n\n    return {\n      send: (headers, complete) => this.sendRequest(options, headers, complete),\n      abort: (callback) => this.abortRequest(callback)\n    };\n  }\n}"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create a function that makes an HTTP GET request to a specified URL with custom headers and query parameters, then handles the response asynchronously.\n\nFunction Description: The function `makeHttpRequest` initiates an HTTP GET request to a given endpoint with query parameters and an API key in the header. It uses XMLHttpRequest to handle the request and response asynchronously. The response is logged to the console upon successful completion.\n\nInput: None (The URL, query parameters, and headers are hardcoded in this example, but could be parameterized in a more flexible implementation.)\n\nOutput: None (The function logs the response to the console but does not return any value.)",
    "Canonical_solution": "function makeHttpRequest() {\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('GET', 'http://localhost:28139/synthetics/api/v3/monitors?test=2&limit=100&w=4');\n    xhr.setRequestHeader('X-Api-Key', '123456789');\n\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "right_result": "function makeHttpRequest() {\n  const url = 'https://api.example.com/data';\n  const queryParams = new URLSearchParams({\n    limit: '10',\n    offset: '0'\n  });\n  const headers = {\n    'Authorization': 'Bearer YOUR_API_KEY',\n    'Content-Type': 'application/json'\n  };\n\n  const fullUrl = `${url}?${queryParams.toString()}`;\n  const xhr = new XMLHttpRequest();\n\n  xhr.open('GET', fullUrl, true);\n  for (const [key, value] of Object.entries(headers)) {\n    xhr.setRequestHeader(key, value);\n  }\n\n  xhr.onload = function () {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      console.log('Response:', xhr.responseText);\n    } else {\n      console.error('Request failed. Status:', xhr.status);\n    }\n  };\n\n  xhr.onerror = function () {\n    console.error('Request failed. Network error.');\n  };\n\n  xhr.send();\n}"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Create a function that performs an HTTP request using XMLHttpRequest and returns a Promise that resolves with a response object containing various utility methods for processing the response data.\n\nFunction Description: The function `fetchRequest` is a Promise-based wrapper around XMLHttpRequest that simplifies making HTTP requests. It handles request configuration, headers, credentials, and response processing. The response object provides methods to access the response data in different formats (text, JSON, blob) and inspect response headers.\n\nInput: \n- `e` [String] - The URL to which the request is sent\n- `n` [Object] - (Optional) Configuration object for the request with the following possible properties:\n  - `method` [String] - HTTP method (default: \"get\")\n  - `headers` [Object] - Key-value pairs of request headers\n  - `credentials` [String] - Controls credentials inclusion (e.g., \"include\")\n  - `body` [Any] - Data to be sent with the request\n\nOutput: [Promise] - A Promise that resolves to a response object with the following methods:\n- `ok` [Boolean] - Indicates if the request was successful (status 2xx)\n- `statusText` [String] - HTTP status text\n- `status` [Number] - HTTP status code\n- `url` [String] - Final URL after any redirects\n- `text()` [Function] - Returns a Promise resolving to response text\n- `json()` [Function] - Returns a Promise resolving to parsed JSON\n- `blob()` [Function] - Returns a Promise resolving to a Blob object\n- `clone()` [Function] - Returns a copy of the response object\n- `headers` [Object] - Provides methods to inspect response headers:\n  - `keys()` - Returns array of header names\n  - `entries()` - Returns array of [name, value] pairs\n  - `get(name)` - Returns value for a specific header\n  - `has(name)` - Checks if a header exists",
    "Canonical_solution": "function fetchRequest(e, n) {\n    n = n || {};\n    return new Promise((function(t, r) {\n        var s = new XMLHttpRequest,\n            o = [],\n            u = [],\n            i = {},\n            a = function() {\n                return {\n                    ok: 2 == (s.status / 100 | 0),\n                    statusText: s.statusText,\n                    status: s.status,\n                    url: s.responseURL,\n                    text: function() {\n                        return Promise.resolve(s.responseText)\n                    },\n                    json: function() {\n                        return Promise.resolve(s.responseText).then(JSON.parse)\n                    },\n                    blob: function() {\n                        return Promise.resolve(new Blob([s.response]))\n                    },\n                    clone: a,\n                    headers: {\n                        keys: function() {\n                            return o\n                        },\n                        entries: function() {\n                            return u\n                        },\n                        get: function(e) {\n                            return i[e.toLowerCase()]\n                        },\n                        has: function(e) {\n                            return e.toLowerCase() in i\n                        }\n                    }\n                }\n            };\n        for (var l in s.open(n.method || \"get\", e, !0), s.onload = function() {\n                s.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, (function(e, n, t) {\n                    o.push(n = n.toLowerCase()), u.push([n, t]), i[n] = i[n] ? i[n] + \",\" + t : t\n                })), t(a())\n            }, s.onerror = r, s.withCredentials = \"include\" == n.credentials, n.headers) s.setRequestHeader(l, n.headers[l]);\n        s.send(n.body || null)\n    }))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "right_result": "(function() {\n  return new Promise(function(resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(e, null);\n    if (n) {\n      xhr.method = n.method || \"get\";\n      xhr.headers = n.headers || {};\n      xhr.credentials = n.credentials || \"include\";\n      xhr.body = n.body;\n    }\n    xhr.onload = function() {\n      var response = {\n        ok: xhr.status >= 200 && xhr.status < 300,\n        statusText: xhr.statusText,\n        status: xhr.status,\n        url: xhr.responseURL,\n        text: function() {\n          return new Promise(function(resolveText, rejectText) {\n            if (xhr.readyState === 4) {\n              resolveText(xhr.responseText);\n            } else {\n              xhr.onload = function() {\n                resolveText(xhr.responseText);\n              };\n            }\n          });\n        },\n        json: function() {\n          return new Promise(function(resolveJson, rejectJson) {\n            if (xhr.readyState === 4) {\n              try {\n                resolveJson(JSON.parse(xhr.responseText));\n              } catch (e) {\n                rejectJson(e);\n              }\n            } else {\n              xhr.onload = function() {\n                try {\n                  resolveJson(JSON.parse(xhr.responseText));\n                } catch (e) {\n                  rejectJson(e);\n                }\n              };\n            }\n          });\n        },\n        blob: function() {\n          return new Promise(function(resolveBlob, rejectBlob) {\n            if (xhr.readyState === 4) {\n              resolveBlob(new Blob([xhr.responseText], { type: 'text/plain' }));\n            } else {\n              xhr.onload = function() {\n                resolveBlob(new Blob([xhr.responseText], { type: 'text/plain' }));\n              };\n            }\n          });\n        },\n        clone: function() {\n          var clone = new XMLHttpRequest();\n          clone.open(xhr.method, xhr.url, false);\n          clone.setRequestHeader = function(name, value) {\n            this.setRequestHeader(name, value);\n          };\n          clone.responseType = xhr.responseType;\n          clone.overrideMimeType = function(type) {\n            this.overrideMimeType(type);\n          };\n          clone.send(xhr.body);\n          return {\n            ok: clone.status >= 200 && clone.status < 300,\n            statusText: clone.statusText,\n            status: clone.status,\n            url: clone.responseURL,\n            text: function() {\n              return new Promise(function(resolveText, rejectText) {\n                if (clone.readyState === 4) {\n                  resolveText(clone.responseText);\n                } else {\n                  clone.onload = function() {\n                    resolveText(clone.responseText);\n                  };\n                }\n              });\n            },\n            json: function() {\n              return new Promise(function(resolveJson, rejectJson) {\n                if (clone.readyState === 4) {\n                  try {\n                    resolveJson(JSON.parse(clone.responseText));\n                  } catch (e) {\n                    rejectJson(e);\n                  }\n                } else {\n                  clone.onload = function() {\n                    try {\n                      resolveJson(JSON.parse(clone.responseText));\n                    } catch (e) {\n                      rejectJson(e);\n                    }\n                  };\n                }\n              });\n            },\n            blob: function() {\n              return new Promise(function(resolveBlob, rejectBlob) {\n                if (clone.readyState === 4) {\n                  resolveBlob(new Blob([clone.responseText], { type: 'text/plain' }));\n                } else {\n                  clone.onload = function() {\n                    resolveBlob(new Blob([clone.responseText], { type: 'text/plain' }));\n                  };\n                }\n              });\n            },\n            headers: {\n              keys: function() {\n                var keys = [];\n                for (var key in clone.getResponseHeader) {\n                  if (clone.getResponseHeader.hasOwnProperty(key)) {\n                    keys.push(key);\n                  }\n                }\n                return keys;\n              },\n              entries: function() {\n                var entries = [];\n                for (var key in clone.getResponseHeader) {\n                  if (clone.getResponseHeader.hasOwnProperty(key)) {\n                    entries.push([key, clone.getResponseHeader(key)]);\n                  }\n                }\n                return entries;\n              },\n              get: function(name) {\n                return clone.getResponseHeader(name);\n              },\n              has: function(name) {\n                return clone.getResponseHeader(name) !== null;\n              }\n            }\n          };\n        },\n        headers: {\n          keys: function() {\n            var keys = [];\n            for (var key in xhr.getResponseHeader) {\n              if (xhr.getResponseHeader.hasOwnProperty(key)) {\n                keys.push(key);\n              }\n            }\n            return keys;\n          },\n          entries: function() {\n            var entries = [];\n            for (var key in xhr.getResponseHeader) {\n              if (xhr.getResponseHeader.hasOwnProperty(key)) {\n                entries.push([key, xhr.getResponseHeader(key)]);\n              }\n            }\n            return entries;\n          },\n          get: function(name) {\n            return xhr.getResponseHeader(name);\n          },\n          has: function(name) {\n            return xhr.getResponseHeader(name) !== null;\n          }\n        }\n      };\n      resolve(response);\n    };\n    xhr.onerror = function() {\n      reject(new Error(\"Network error\"));\n    };\n    xhr.send(n.body);\n  });\n})();"
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with form data and custom headers, then handles the response asynchronously.\n\nFunction Description: The function `sendRequest` constructs and sends an HTTP POST request using XMLHttpRequest. It packages form data as URL-encoded parameters, sets various request headers for authentication and content negotiation, and processes the server's response asynchronously. The function is designed to interact with a real estate listing API, sending search criteria and receiving property listings in return.\n\nInput: None (The function uses hardcoded values for demonstration, but in practice these could be parameterized)\n\nOutput: None (The function logs the response to console, but could be modified to return a Promise or use callbacks for response handling)",
    "Canonical_solution": "function sendRequest() {\n    const data = new URLSearchParams({\n        'CultureId': '1',\n        'ApplicationId': '1',\n        'RecordsPerPage': '200',\n        'MaximumResults': '200',\n        'PropertyTypeId': '300',\n        'TransactionTypeId': '2',\n        'StoreyRange': '0-0',\n        'BuildingTypeId': '1',\n        'BedRange': '0-0',\n        'BathRange': '0-0',\n        'LongitudeMin': '-79.3676805496215',\n        'LongitudeMax': '-79.27300930023185',\n        'LatitudeMin': '43.660358732823845',\n        'LatitudeMax': '43.692390574029936',\n        'SortOrder': 'A',\n        'SortBy': '1',\n        'viewState': 'm',\n        'Longitude': '-79.4107246398925',\n        'Latitude': '43.6552047278685',\n        'ZoomLevel': '13',\n        'CurrentPage': '1'\n    });\n\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/api/Listing.svc/PropertySearch_Post');\n    xhr.setRequestHeader('Origin', 'http://www.realtor.ca');\n    xhr.setRequestHeader('Accept-Encoding', 'gzip, deflate');\n    xhr.setRequestHeader('Accept-Language', 'en-US,en;q=0.8');\n    xhr.setRequestHeader('User-Agent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\n    xhr.setRequestHeader('Accept', '*/*');\n    xhr.setRequestHeader('Referer', 'http://www.realtor.ca/Residential/Map.aspx');\n    xhr.setRequestHeader('Connection', 'keep-alive');\n\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "right_result": "var sendRequest = function() {\n  var url = 'https://api.example.com/real estate/listings';\n  var formData = new FormData();\n  formData.append('searchCriteria', 'downtown');\n  formData.append('radius', '5');\n  formData.append('priceRange', '500000-700000');\n\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', url, true);\n  xhr.setRequestHeader('Authorization', 'Bearer your_token_here');\n  xhr.setRequestHeader('Accept', 'application/json');\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      console.log('Response:', JSON.parse(xhr.responseText));\n    } else {\n      console.error('Error:', xhr.statusText);\n    }\n  };\n\n  xhr.send(new URLSearchParams(formData));\n};"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a function that performs an asynchronous HTTP GET request to a specified URL and returns a Promise that resolves when the request is successful or rejects when it fails.\n\nFunction Description: The function `getData` initiates an HTTP GET request using XMLHttpRequest. It sets appropriate headers for JSON content, handles the response asynchronously through Promise callbacks, and manages both successful and failed request scenarios.\n\nInput: \n- url [String] - The URL to which the HTTP GET request will be made\n\nOutput: \n- [Promise] - A Promise object that resolves when the request succeeds and rejects when it fails. The Promise doesn't return any specific value upon resolution/rejection in this basic implementation, but can be extended to return response data or error information.",
    "Canonical_solution": "function getData(url) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Content-Type', 'application/json');\n    req.setRequestHeader('Accept', 'application/json');\n    req.onload = () => {\n      resolve();\n    };\n    req.onerror = () => {\n      reject();\n    };\n    req.send();\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "right_result": "function getData(url) {\n  return new Promise(function(resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve();\n      } else {\n        reject(new Error('Request failed with status ' + xhr.status));\n      }\n    };\n    xhr.onerror = function() {\n      reject(new Error('Request failed'));\n    };\n    xhr.send();\n  });\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a function that sets up an Express server to handle HTTP requests, including serving static files, processing form data, and executing external commands to generate PDF files.\n\nFunction Description: The function `startServer` initializes an Express application, configures middleware for request processing, defines route handlers for specific endpoints, and starts the server on a specified port. It serves static files, handles JSON and URL-encoded form data, and provides endpoints for rendering pages and generating PDFs via an external command.\n\nInput: None (The function does not take any input parameters)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on the specified port)",
    "Canonical_solution": "function startServer() {\n    var express = require('express');\n    var app = express();\n    const execFile = require('child_process').execFile;\n\n    app.set('port', (process.env.PORT || 5000));\n    app.use(bodyParser.json());\n    app.use(bodyParser.urlencoded({ extended: false }));\n    app.use(cookieParser());\n    app.use(express.static(__dirname + '/'));\n\n    app.get('/', function(request, response) {\n        response.render('pages/index');\n    });\n\n    app.get('/path_to_pdf', function(request, response) {\n        const child = execFile('unoconv', ['-f', 'pdf', 'generate-wifi.odt'], function(error, stdout, stderr) {\n            if (error) {\n                throw error;\n            }\n            response.json({ message: stdout });\n        });\n    });\n\n    app.listen(app.get('port'), function() {\n        console.log('Node app is running on port', app.get('port'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\nconst fs = require('fs');\nconst { exec } = require('child_process');\n\nconst app = express();\nconst PORT = 3000;\n\n// Serve static files from the 'public' directory\napp.use(express.static(path.join(__dirname, 'public')));\n\n// Middleware to parse JSON and URL-encoded form data\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Route to render the main page\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\n// Route to handle form submission and generate PDF\napp.post('/generate-pdf', (req, res) => {\n  const { content } = req.body;\n  \n  // Example: Use a command-line tool to generate PDF (e.g., wkhtmltopdf)\n  const pdfFilePath = path.join(__dirname, 'output.pdf');\n  \n  exec(`wkhtmltopdf --text \"${content}\" \"${pdfFilePath}\"`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error generating PDF: ${error.message}`);\n      return res.status(500).send('Error generating PDF');\n    }\n    \n    res.download(pdfFilePath, 'output.pdf', (err) => {\n      if (err) {\n        console.error(`Error sending PDF: ${err.message}`);\n        res.status(500).send('Error sending PDF');\n      } else {\n        fs.unlink(pdfFilePath, (err) => {\n          if (err) console.error(`Error deleting PDF: ${err.message}`);\n        });\n      }\n    });\n  });\n});\n\n// Start the server\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create an HTTP server using Express.js that handles various routes for data processing, API endpoints, and event handling. The server should dynamically generate API endpoints based on available utility functions and provide basic route handling for updates, embedding, and event processing.\n\nFunction Description: The `createServer` function initializes an Express.js server with middleware configuration, defines route handlers for specific endpoints, dynamically creates API routes based on utility functions, and starts the server on a random available port. It outputs the server's port information as JSON to stdout.\n\nInput: None (The function takes no parameters but relies on external modules and variables like `express`, `connect`, `dataIn`, `locker`, `oembed`, `async`, `logger`, and `util` being available in scope)\n\nOutput: \n- The function doesn't return anything directly\n- Writes server port information to stdout as JSON: `{port: [number]}`\n- Creates a running HTTP server listening on localhost\n- Provides the following endpoints:\n  - GET /update - Triggers reindexing\n  - GET /embed - Handles oEmbed requests\n  - POST /events - Processes queued events\n  - Dynamic GET routes based on utility functions",
    "Canonical_solution": "function createServer() {\n    var express = require('express'),\n        connect = require('connect');\n    var app = express.createServer(connect.bodyParser());\n    app.use(require(\"express-jsonstream\")());\n    app.set('views', __dirname);\n    app.get('/update', function (req, res) {\n        dataIn.reIndex(locker, function () {\n            res.writeHead(200);\n            res.end('Extra mince!');\n        });\n    });\n    app.get('/embed', function (req, res) {\n        if (!dataIn.process) return res.send({});\n        oembed.fetch({url:req.query.url}, function (e) {\n            if(e) return res.send(e);\n            res.send({});\n        });\n    });\n    app.post('/events', function (req, res) {\n        var q = async.queue(dataIn.processEvent, 1);\n        req.jsonStream(q.push, function (error) {\n            if(error) logger.error(error);\n            res.send(200);\n        });\n    });\n    function genericApi(name,f) {\n        app.get(name, function (req,res) {\n            var results = [];\n            f(req.query, function (item) { results.push(item); }, function (err) {\n                if(err) {\n                    res.writeHead(500, {'Content-Type': 'text/plain'});\n                    res.end(err);\n                } else {\n                    res.writeHead(200, {'Content-Type': 'application/json'});\n                    res.end(JSON.stringify(results));\n                }\n            });\n        });\n    }\n    for (var f in util) {\n        if (f == 'init') continue;\n        genericApi('/'+f,util[f]);\n    }\n    app.listen(0, 'localhost', function () {\n        var returnedInfo = {port: app.address().port};\n        process.stdout.write(JSON.stringify(returnedInfo));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst app = express();\nconst http = require('http');\nconst server = http.createServer(app);\nconst port = Math.floor(Math.random() * 65535) + 1;\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/update', (req, res) => {\n  dataIn.reindex();\n  res.send('Reindexing triggered');\n});\n\napp.get('/embed', (req, res) => {\n  oembed.handleRequest(req, res);\n});\n\napp.post('/events', (req, res) => {\n  async.processEvents(req.body, (error, results) => {\n    if (error) {\n      logger.error(error);\n      res.status(500).send('Error processing events');\n    } else {\n      res.send(results);\n    }\n  });\n});\n\nObject.keys(util).forEach(key => {\n  if (key.startsWith('api_')) {\n    const route = key.replace('api_', '');\n    app.get(`/${route}`, (req, res) => {\n      util[key](req, res);\n    });\n  }\n});\n\nserver.listen(port, () => {\n  logger.info(`Server running on port ${port}`);\n  console.log({ port });\n});"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a function that sets up an Express server with webpack middleware for development purposes, serves a main HTML file, and listens on a specified port.\n\nFunction Description: The function `setupServer` initializes an Express application, configures webpack middleware for development (including hot module replacement), defines a route to serve the main HTML file, and starts the server on the specified port. It handles errors during server startup and logs success messages.\n\nInput: None (The function does not take any explicit parameters. It relies on external variables `compiler` and `config` for webpack configuration.)\n\nOutput: None (The function does not return any value. It starts the server process and logs messages to the console.)",
    "Canonical_solution": "function setupServer() {\n    var app = new require('express')();\n    var port = 4001;\n\n    app.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }));\n    app.use(webpackHotMiddleware(compiler));\n\n    app.get(\"/\", function(req, res) {\n        res.sendFile(__dirname + '/index.html');\n    });\n\n    app.listen(port, function(error) {\n        if (error) {\n            console.error(error);\n        } else {\n            console.info(\"==> \ud83c\udf0e  Listening on port %s. Open up http://localhost:%s/ in your browser.\", port, port);\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst webpack = require('webpack');\nconst path = require('path');\n\nfunction setupServer() {\n  const app = express();\n  const compiler = require('./webpack.config').compiler;\n\n  app.use(express.static(path.join(__dirname, 'dist')));\n\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'dist', 'index.html'));\n  });\n\n  app.use(webpackHotMiddleware(compiler, {\n    path: __dirname + '/sockjs-node',\n    logLevel: 'info'\n  }));\n\n  const port = process.env.PORT || 3000;\n  app.listen(port, (err) => {\n    if (err) {\n      console.error(`Error starting server: ${err.message}`);\n      return;\n    }\n    console.log(`Server running on http://localhost:${port}`);\n  });\n}\n\nsetupServer();"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a function to start an HTTP server using Express that serves static files from a specified directory and handles all routes by returning the static files.\n\nFunction Description: The function `startServer` initializes an Express application, configures it to serve static files from a predefined directory, and sets up a catch-all route to return the static files for any HTTP GET request. The server listens on a specified port and host.\n\nInput: None (The function uses predefined constants for port, host, and static file directory.)\n\nOutput: None (The function starts the server but does not return any value.)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const path = require('path');\n    \n    const PORT = process.env.PORT || 8080;\n    const HOST = '0.0.0.0';\n    const WWW = path.join(__dirname, '..', '/www/');\n\n    const app = express();\n    app.use(express.static(WWW));\n    app.get('*', function (req, res) {\n        res.sendFile(WWW);\n    });\n\n    app.listen(PORT, HOST);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\n\nconst PORT = 3000;\nconst HOST = 'localhost';\nconst STATIC_DIR = path.join(__dirname, 'public');\n\nfunction startServer() {\n  const app = express();\n\n  app.use(express.static(STATIC_DIR));\n\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(STATIC_DIR, 'index.html'));\n  });\n\n  app.listen(PORT, HOST, () => {\n    console.log(`Server running at http://${HOST}:${PORT}`);\n  });\n}\n\nstartServer();"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a function that sets up and configures an Express server with webpack middleware, proxy support, and static file serving capabilities.\n\nFunction Description: The function `createServer` initializes an Express application, configures it with webpack development and hot-reload middleware, sets up proxy routes based on a proxy table, enables history API fallback for single-page applications, serves static files, and starts the server on a specified port.\n\nInput: \n- None (The function relies on external configurations like `webpackConfig`, `proxyTable`, `config.dev`, and `port` which should be defined in the scope where the function is called)\n\nOutput: \n- Returns an HTTP server instance that is listening on the specified port, configured with all the middleware and routes.\n\nNote: The function assumes the following external dependencies are available:\n- `express`: The Express framework\n- `http-proxy-middleware`: For proxy functionality\n- `webpack` and related middlewares (`webpack-dev-middleware`, `webpack-hot-middleware`)\n- `connect-history-api-fallback`: For SPA history API fallback\n- `path`: Node.js path module\n- External configuration objects: `webpackConfig`, `proxyTable`, `config.dev`, `port`",
    "Canonical_solution": "const express = require('express')\nconst proxyMiddleware = require('http-proxy-middleware')\n\nfunction createServer() {\n  const app = express()\n  const compiler = webpack(webpackConfig)\n\n  const devMiddleware = require('webpack-dev-middleware')(compiler, {\n    publicPath: webpackConfig.output.publicPath,\n    quiet: true,\n  })\n\n  const hotMiddleware = require('webpack-hot-middleware')(compiler, {\n    log: false,\n    heartbeat: 2000,\n  })\n\n  app.use(hotMiddleware)\n\n  Object.keys(proxyTable).forEach(function(context) {\n    let options = proxyTable[context]\n    if (typeof options === 'string') {\n      options = {target: options}\n    }\n    app.use(proxyMiddleware(options.filter || context, options))\n  })\n\n  app.use(require('connect-history-api-fallback')()))\n  app.use(devMiddleware)\n\n  const staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n  app.use(staticPath, express.static('./static'))\n\n  var server = app.listen(port)\n  return server\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst http = require('http');\nconst webpack = require('webpack');\nconst { webpackDevMiddleware } = require('webpack');\nconst { hot } = require('webpack-hot-middleware');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\nconst history = require('connect-history-api-fallback');\nconst path = require('path');\n\nfunction createServer() {\n  const app = express();\n  const server = http.createServer(app);\n  const compiler = webpack(webpackConfig);\n\n  app.use(history());\n\n  app.use(\n    webpackDevMiddleware(compiler, {\n      publicPath: webpackConfig.output.publicPath,\n      stats: 'minimal'\n    })\n  );\n\n  app.use(hot(webpackConfig.entry['hot']));\n\n  Object.entries(proxyTable).forEach(([context, options]) => {\n    app.use(context, createProxyMiddleware(options));\n  });\n\n  app.use(express.static(path.join(__dirname, 'dist')));\n\n  server.listen(port, () => {\n    console.log(`Server running at http://localhost:${port}`);\n  });\n\n  return server;\n}"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Create a function to start an HTTP server using Express framework that serves static files and handles specific routes, with logging upon server startup.\n\nFunction Description: The function initializes an Express server with middleware for request processing, sets up static file serving, defines a route handler for CSV data, and starts listening on a specified port. Upon successful startup, it logs server information.\n\nInput: \n- None (uses module-level `processInfo.port` for port configuration)\n- Implicitly uses `csv` variable for the CSV endpoint response\n\nOutput: \n- No direct return value\n- Side effects:\n  - Creates and starts an HTTP server\n  - Logs server information to console upon successful startup\n  - Serves static files from './static' directory\n  - Responds to GET requests at '/csv' endpoint with CSV data",
    "Canonical_solution": "function startServer() {\n    var express = require('express'),\n        connect = require('connect');\n    var app = express.createServer(connect.bodyParser(), connect.cookieParser());\n    \n    app.set('views', __dirname);\n    app.use(express.static(__dirname + '/static'));\n    \n    app.get('/csv', function(req, res) {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end(csv);\n    });\n    \n    app.listen(processInfo.port, function() {\n        var returnedInfo = {};\n        console.log(JSON.stringify(returnedInfo));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\nconst app = express();\n\n// Serve static files from the 'static' directory\napp.use(express.static(path.join(__dirname, 'static')));\n\n// Route handler for CSV data\napp.get('/csv', (req, res) => {\n  res.csv(csv);\n});\n\n// Start the server\nconst port = processInfo.port;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});"
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Create a function to start an Express.js server that handles HTTP requests, serves static files, implements custom middleware, and manages error handling.\n\nFunction Description: The function initializes an Express application, configures it with necessary settings and middleware, defines route handlers, and starts listening on a specified port. It includes:\n1. Static file serving from a 'public' directory\n2. Custom middleware for test mode detection\n3. Route handling for the home page\n4. 404 and 500 error handlers\n5. Server startup with port configuration\n\nInput: None (The function takes no parameters as it's self-contained)\n\nOutput: None (The function doesn't return anything but starts a server process that listens for HTTP requests)",
    "Canonical_solution": "function startServer() {\n    var express = require('express');\n    var app = express();\n\n    app.set('port', process.env.PORT || 3000);\n\n    app.use(express.static(__dirname + '/public'));\n\n    app.use(function(req, res, next){\n        res.locals.showTests = app.get('env') !== 'production' && \n            req.query.test === '1';\n        next();\n    });\n\n    app.get('/', function(req, res) {\n        res.render('home');\n    });\n\n    app.use(function(req, res, next){\n        res.status(404);\n        res.render('404');\n    });\n\n    app.use(function(err, req, res, next){\n        console.error(err.stack);\n        res.status(500);\n        res.render('500');\n    });\n\n    app.listen(app.get('port'), function(){\n        console.log('Express started on http://localhost:' + \n            app.get('port') + '; press Ctrl-C to terminate.');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\n\nconst app = express();\nconst PORT = 3000;\n\n// Custom middleware for test mode detection\napp.use((req, res, next) => {\n  const isTestMode = process.env.TEST_MODE === 'true';\n  req.isTestMode = isTestMode;\n  next();\n});\n\n// Static file serving from 'public' directory\napp.use(express.static(path.join(__dirname, 'public')));\n\n// Route handler for home page\napp.get('/', (req, res) => {\n  res.send('Welcome to the Home Page!');\n});\n\n// 404 error handler\napp.use((req, res, next) => {\n  res.status(404).send('404 - Page Not Found');\n});\n\n// 500 error handler\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('500 - Internal Server Error');\n});\n\n// Start the server\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});"
  },
  {
    "Task_id": 68,
    "Instruction": "Task Description: Create a function to set up an Express server with routes for managing todo items, including creating, retrieving, and deleting todos.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures JSON middleware, and defines route handlers for HTTP methods (GET, POST, DELETE) to manage todo items. The server listens on port 8080.\n\nInput: None\n\nOutput: None (The function starts an Express server but does not return any value.)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require(\"express\");\n    const app = express();\n    app.use(express.json());\n\n    app.delete(\"/todos\", async (req, res) => {\n        const {id} = req.body;  \n        const result = await deleteTodo(id);\n        res.setHeader(\"content-type\", \"application/json\");\n        res.send(JSON.stringify({result: result}));\n    });\n\n    app.post(\"/todos\", async (req, res) => {\n        const todoText = req.body;\n        const result = await create(todoText.todoText);\n        res.setHeader(\"content-type\", \"application/json\");\n        res.send(JSON.stringify({result: result}));\n    });\n\n    app.get(\"/todos\", async (req,res) => {\n        res.setHeader(\"content-type\", \"application/json\");\n        const result = await pool.query(\"select id, text from todos\");\n        res.send(JSON.stringify({result}));\n    });\n\n    app.listen(8080, () => console.log(\"listening\"));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\nlet todos = [];\n\napp.get('/todos', (req, res) => {\n  res.json(todos);\n});\n\napp.post('/todos', (req, res) => {\n  const { text } = req.body;\n  todos.push({ id: Date.now(), text });\n  res.status(201).json(todos[todos.length - 1]);\n});\n\napp.delete('/todos/:id', (req, res) => {\n  const { id } = req.params;\n  todos = todos.filter(todo => todo.id !== parseInt(id));\n  res.status(200).json({});\n});\n\napp.listen(8080, () => {\n  console.log('Server is running on port 8080');\n});"
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Create a function that sets up an HTTP server using Express.js to handle POST requests and serve static files.\n\nFunction Description: The function `setupServer` initializes an Express application, configures middleware for handling file uploads and static files, defines route handlers for POST requests, and starts the server on port 3000. It handles two POST endpoints: `/post` and `/post-get`. The `/post` endpoint returns a JSON string of the request body, while the `/post-get` endpoint redirects to a specified HTML file.\n\nInput: None\n\nOutput: None (The function starts an HTTP server that listens on port 3000 and does not return any value.)",
    "Canonical_solution": "function setupServer() {\n    var express = require('express');\n    var multer = require('multer');\n    var app = express();\n    var upload = multer();\n\n    app.use(express.static('../../'));\n\n    app.post('/post', upload.array(), function(req, res, next) {\n        var content = '<div id=\"result1\">';\n        content += JSON.stringify(req.body, 5);\n        content += '</div>';\n        res.end(content);\n    });\n\n    app.post('/post-get', upload.array(), function(req, res, next) {\n        res.redirect('/examples/form/redirect.html');\n    });\n\n    app.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\n\nfunction setupServer() {\n  const app = express();\n  const upload = multer({ dest: 'uploads/' });\n\n  // Serve static files from the 'public' directory\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  // Handle POST requests to /post\n  app.post('/post', (req, res) => {\n    res.json(req.body);\n  });\n\n  // Handle POST requests to /post-get\n  app.post('/post-get', (req, res) => {\n    res.redirect(`./${req.body.filename}`);\n  });\n\n  // Start the server on port 3000\n  app.listen(3000, () => {\n    console.log('Server is running on port 3000');\n  });\n}\n\nsetupServer();"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Implement a Twitter HTTP client class in JavaScript that handles API requests to Twitter, including request construction, execution, and response processing with error handling and clock synchronization.\n\nClass Description: The TwitterHTTPClient class provides methods to interact with Twitter's REST API. It handles HTTP requests (GET/POST), manages authentication, processes responses, and maintains clock synchronization with Twitter's servers.\n\nAttributes:\n- config: [Object] - Configuration object containing API credentials and settings\n- _twitter_time_minus_local_time_ms: [Number] - Time difference between Twitter's server time and local time in milliseconds\n\nMethods:\n- constructor(config) -> [TwitterHTTPClient] - Initializes the client with configuration\n- request(method, path, params, callback) -> [Promise] - Makes HTTP requests to Twitter API\n- _doRestApiRequest(reqOpts, twitOptions, method, callback) -> [void] - Executes the actual HTTP request\n- _updateClockOffsetFromResponse(resp) -> [void] - Updates the clock offset based on Twitter's server time\n\nMethod Details:\n1. request(method, path, params, callback)\n   - Input:\n     - method: [String] - HTTP method ('GET' or 'POST')\n     - path: [String] - API endpoint path\n     - params: [Object] - Request parameters\n     - callback: [Function] - Callback function for handling response\n   - Output: [Promise] - Resolves with response data or rejects with error\n\n2. _doRestApiRequest(reqOpts, twitOptions, method, callback)\n   - Input:\n     - reqOpts: [Object] - Request options including URL and headers\n     - twitOptions: [Object] - Twitter-specific options\n     - method: [String] - HTTP method\n     - callback: [Function] - Callback for handling response\n   - Output: [void] - Calls callback with response data or error\n\n3. _updateClockOffsetFromResponse(resp)\n   - Input:\n     - resp: [Object] - HTTP response object\n   - Output: [void] - Updates internal clock offset value",
    "Canonical_solution": "var request = require('request');\nvar helpers = require('./helpers');\n\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    var self = this;\n    assert(method == 'GET' || method == 'POST');\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      var _returnErrorToUser = function (err) {\n        if (callback && typeof callback === 'function') {\n          callback(err, null, null);\n        }\n        reject(err);\n      }\n\n      self._buildReqOpts(method, path, params, false, function (err, reqOpts) {\n        if (err) {\n          _returnErrorToUser(err);\n          return;\n        }\n\n        var twitOptions = (params && params.twit_options) || {};\n\n        process.nextTick(function () {\n          self._doRestApiRequest(reqOpts, twitOptions, method, function (err, parsedBody, resp) {\n            self._updateClockOffsetFromResponse(resp);\n\n            if (self.config.trusted_cert_fingerprints) {\n              if (!resp.socket.authorized) {\n                var authErrMsg = resp.socket.authorizationError.toString();\n                var err = helpers.makeTwitError('The peer certificate was not signed; ' + authErrMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n              var fingerprint = resp.socket.getPeerCertificate().fingerprint;\n              var trustedFingerprints = self.config.trusted_cert_fingerprints;\n              if (trustedFingerprints.indexOf(fingerprint) === -1) {\n                var errMsg = util.format('Certificate untrusted. Trusted fingerprints are: %s. Got fingerprint: %s.',\n                                         trustedFingerprints.join(','), fingerprint);\n                var err = new Error(errMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n            }\n\n            if (callback && typeof callback === 'function') {\n              callback(err, parsedBody, resp);\n            }\n\n            resolve({ data: parsedBody, resp: resp });\n            return;\n          });\n        });\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    var request_method = request[method.toLowerCase()];\n    var req = request_method(reqOpts);\n\n    var body = '';\n    var response = null;\n\n    var onRequestComplete = function () {\n      if (body !== '') {\n        try {\n          body = JSON.parse(body);\n        } catch (jsonDecodeError) {\n          var err = helpers.makeTwitError('JSON decode error: Twitter HTTP response body was not valid JSON');\n          err.statusCode = response ? response.statusCode: null;\n          err.allErrors.concat({error: jsonDecodeError.toString()});\n          callback(err, body, response);\n          return;\n        }\n      }\n\n      if (typeof body === 'object' && (body.error || body.errors)) {\n        var err = helpers.makeTwitError('Twitter API Error');\n        err.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n\n      callback(err, body, response);\n    }\n\n    req.on('response', function (res) {\n      response = res;\n      req.on('data', function (chunk) {\n        body += chunk.toString('utf8');\n      });\n      req.on('end', function () {\n        onRequestComplete();\n      });\n    });\n\n    req.on('error', function (err) {\n      if (twitOptions.retry &&\n          STATUS_CODES_TO_ABORT_ON.indexOf(err.statusCode) !== -1\n      ) {\n        self.request(method, path, params, callback);\n        return;\n      } else {\n        err.statusCode = null;\n        err.code = null;\n        err.allErrors = [];\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    var self = this;\n    if (resp && resp.headers && resp.headers.date &&\n        new Date(resp.headers.date).toString() !== 'Invalid Date'\n    ) {\n      var twitterTimeMs = new Date(resp.headers.date).getTime();\n      self._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "right_result": "class TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  async request(method, path, params, callback) {\n    try {\n      const reqOpts = {\n        url: `https://api.twitter.com/${path}`,\n        method: method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json'\n        },\n        json: true\n      };\n\n      if (method === 'POST') {\n        reqOpts.body = params;\n      }\n\n      await this._doRestApiRequest(reqOpts, { ...params }, method, (err, resp) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        if (resp.statusCode >= 400) {\n          callback(new Error(`Twitter API error: ${resp.statusMessage}`));\n          return;\n        }\n\n        this._updateClockOffsetFromResponse(resp);\n\n        callback(null, resp.body);\n      });\n    } catch (error) {\n      callback(error);\n    }\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    require('request')(reqOpts, function (error, response, body) {\n      if (error) {\n        callback(error);\n        return;\n      }\n\n      if (response.statusCode >= 400) {\n        callback(new Error(`Twitter API error: ${response.statusMessage}`));\n        return;\n      }\n\n      callback(null, { status: response.statusCode, body: JSON.parse(body) });\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    if (resp.body && resp.body.xtz) {\n      const twitterTime = new Date(0).getTime() + resp.body.xtz;\n      const localTime = new Date().getTime();\n      this._twitter_time_minus_local_time_ms = twitterTime - localTime;\n    }\n  }\n}"
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a function to set up an HTTP server using Express.js that evaluates JavaScript expressions sent via POST requests and returns the results.\n\nFunction Description: The function `setupServer` initializes an Express.js server with middleware for JSON parsing and CORS. It listens on port 3948 and provides a POST endpoint at the root path ('/') that evaluates JavaScript expressions sent in the request body using Node.js's `vm` module. The server logs its startup information to the console.\n\nInput: None (The function takes no parameters; configuration is hardcoded.)\n\nOutput: None (The function doesn't return anything; it starts a server that continues running and handles incoming requests.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const bodyParser = require('body-parser');\n    const cors = require('cors');\n    const path = require('path');\n    const vm = require('vm');\n\n    const app = express();\n    app.use(bodyParser.json());\n    app.use(cors());\n    app.post('/', function (request, response) {\n        try {\n            response.json({result: vm.runInThisContext(request.body.expression)});\n        } catch (error) {\n            response.json(error);\n        }\n    });\n    app.listen(3948, 'localhost', function () {\n        console.log('Devtron server listening on http://localhost:3948');\n        console.log(`Open file://${path.join(__dirname, '..', 'static', 'index.html')} to view`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst cors = require('cors');\nconst { vm } = require('vm');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  try {\n    const result = vm.runInThisContext(req.body);\n    res.json({ result });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.listen(3948, () => {\n  console.log('Server is running on port 3948');\n});"
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a function to set up an Express server with Bottender integration for handling HTTP requests, including specific routes for sending an ID and serving a LIFF page.\n\nFunction Description: The function `setupServer` initializes an Express server with Bottender framework integration. It configures middleware for JSON body parsing, sets up route handlers for '/send-id' and '/liff' endpoints, and provides a catch-all handler for other routes. The server listens on a specified port (default 5000) and serves both API responses and static files.\n\nInput: None (The function uses environment variables: PORT for server port and LINE_LIFF_ID for the ID to be sent)\n\nOutput: None (The function starts an HTTP server that listens on the specified port and handles incoming requests)\n\nNote: The function requires the following npm packages to be installed: express, body-parser, path, bottender",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const bodyParser = require('body-parser');\n    const path = require('path');\n    const { bottender } = require('bottender');\n\n    const app = bottender({\n        dev: process.env.NODE_ENV !== 'production',\n    });\n\n    const port = Number(process.env.PORT) || 5000;\n    const handle = app.getRequestHandler();\n\n    app.prepare().then(() => {\n        const server = express();\n\n        server.use(\n            bodyParser.json({\n                verify: (req, _, buf) => {\n                    req.rawBody = buf.toString();\n                },\n            })\n        );\n\n        server.get('/send-id', (req, res) => {\n            res.json({ id: process.env.LINE_LIFF_ID });\n        });\n\n        server.get('/liff', (req, res) => {\n            const filename = path.join(`${__dirname}/liff.html`);\n            res.sendFile(filename);\n        });\n\n        server.all('*', (req, res) => {\n            return handle(req, res);\n        });\n\n        server.listen(port, (err) => {\n            if (err) throw err;\n            console.log(`> Ready on http://localhost:${port}`);\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst Bottender = require('bottender');\n\nconst app = express();\nconst bot = new Bottender();\n\n// Middleware for JSON body parsing\napp.use(bodyParser.json());\n\n// Route handler for '/send-id'\napp.post('/send-id', (req, res) => {\n  const id = process.env.LINE_LIFF_ID;\n  res.json({ id });\n});\n\n// Route handler for '/liff'\napp.get('/liff', (req, res) => {\n  res.sendFile(path.join(__dirname, 'liff.html'));\n});\n\n// Catch-all handler for other routes\napp.all('*', (req, res) => {\n  res.status(404).json({ error: 'Route not found' });\n});\n\n// Initialize Bottender\nbot.init(app);\n\n// Server setup\nconst port = process.env.PORT || 5000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Create a function to set up an Express server with webpack middleware for development purposes, serving a single-page application.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures webpack development and hot-reload middleware, sets up a catch-all route to serve the main HTML file, and starts the server on localhost port 3000. This is typically used in development environments for frontend applications bundled with webpack.\n\nInput: None (The function doesn't take any explicit parameters, but assumes the existence of `compiler` and `config` variables in its scope, which would typically be webpack compiler instance and configuration object respectively)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that listens on port 3000)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express');\n    const app = express();\n    \n    app.use(require('webpack-dev-middleware')(compiler, {\n        noInfo: true,\n        publicPath: config.output.publicPath,\n    }));\n    \n    app.use(require('webpack-hot-middleware')(compiler));\n    \n    app.get('*', (req, res) => {\n        res.sendFile(path.join(__dirname, '../index.html'));\n    });\n    \n    app.listen(3000, 'localhost', (err) => {\n        if (err) {\n            console.log(err);\n            return;\n        }\n        console.log('Listening at http://localhost:3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst webpack = require('webpack');\nconst path = require('path');\n\nfunction setupExpressServer() {\n  const app = express();\n  const compiler = webpack(require('./webpack.config')); // Assuming webpack config is in the same directory\n\n  // Webpack middleware for hot-reload\n  app.use(webpackHotMiddlewares(compiler, {\n    path: path.join(__dirname, 'dist'),\n    publicPath: '/__webpack_public_path__'\n  }));\n\n  // Serve static files from the dist directory\n  app.use(express.static(path.join(__dirname, 'dist')));\n\n  // Catch-all route to serve the main HTML file\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'dist', 'index.html'));\n  });\n\n  // Start the server\n  const port = 3000;\n  app.listen(port, () => {\n    console.log(`Server is running on http://localhost:${port}`);\n  });\n}\n\nmodule.exports = setupExpressServer;"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a function that sets up an Express server with session management and WebSocket capabilities using Primus, and handles basic routing.\n\nFunction Description: The function `setupExpressServer` initializes an Express application with session management using `express-session` and `cookie-parser`, sets up a basic route, and integrates Primus for WebSocket communication. It also includes session handling for WebSocket connections.\n\nInput: None (This function does not take any input parameters.)\n\nOutput: None (This function does not return any value but starts an HTTP server listening on port 8080 and logs a message to the console.)",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var expressSession = require('express-session');\n    var cookieParser = require('cookie-parser');\n    var http = require('http');\n    var Primus = require('../..');\n    var primusSession = require('./session');\n\n    var app = express();\n    var secret = 'shhhh, very secret';\n    var cookies = cookieParser(secret);\n    var store = new expressSession.MemoryStore();\n\n    app.use(cookies);\n    app.use(expressSession({\n        saveUninitialized: true,\n        secret: secret,\n        resave: true,\n        store: store\n    }));\n\n    app.get('/', function index(req, res) {\n        req.session.timestamp = Date.now();\n        res.sendFile(__dirname + '/index.html');\n    });\n\n    var server = http.createServer(app);\n    var primus = new Primus(server);\n\n    primus.use('cookies', cookies);\n    primus.use('session', primusSession, { store: store });\n\n    primus.on('connection', function connection(spark) {\n        spark.write(JSON.stringify(spark.request.session, null, '  '));\n    });\n\n    server.listen(8080, function listening() {\n        console.log('Open http://localhost:8080 in your browser');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst Primus = require('primus');\nconst http = require('http');\n\nfunction setupExpressServer() {\n  const app = express();\n  const server = http.createServer(app);\n  const primus = new Primus(server, { transformer: 'polling' });\n\n  // Session setup\n  app.use(cookieParser());\n  app.use(session({\n    secret: 'your_secret_key',\n    resave: false,\n    saveUninitialized: true\n  }));\n\n  // Basic route\n  app.get('/', (req, res) => {\n    res.send('Hello from Express with session and Primus!');\n  });\n\n  // WebSocket integration with session handling\n  primus.on('connection', (spark) => {\n    const session = spark.handshake.session;\n    console.log('WebSocket connection established with session:', session);\n    spark.on('data', (data) => {\n      console.log('Received data:', data);\n    });\n  });\n\n  // Start the server\n  server.listen(8080, () => {\n    console.log('Server is running on port 8080');\n  });\n}\n\nsetupExpressServer();\n```"
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a function to start an Express server that serves static files and handles client requests.\n\nFunction Description: The function `startServer` initializes an Express application, configures middleware for compression and static file serving, sets up a catch-all route to serve the main HTML file, and starts the server on a specified port.\n\nInput: None\n\nOutput: None (The function starts a server that listens on the specified port and logs the server status to the console.)",
    "Canonical_solution": "function startServer() {\n    var express = require('express');\n    var path = require('path');\n    var compression = require('compression');\n\n    var app = express();\n\n    app.use(compression());\n    app.use(express.static(path.join(__dirname, 'public')));\n\n    app.get('*', function (req, res) {\n        res.sendFile(path.join(__dirname, 'public', 'index.html'));\n    });\n\n    var PORT = process.env.PORT || 8080;\n    app.listen(PORT, function() {\n        console.log('Production Express server running at localhost:' + PORT);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst compress = require('compression');\nconst path = require('path');\n\nfunction startServer() {\n  const app = express();\n  const port = 3000;\n\n  // Configure compression middleware\n  app.use(compress());\n\n  // Serve static files from the 'public' directory\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  // Catch-all route to serve the main HTML file\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'public', 'index.html'));\n  });\n\n  // Start the server\n  app.listen(port, () => {\n    console.log(`Server is running on http://localhost:${port}`);\n  });\n}\n\nstartServer();"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a function to set up an Express server that connects to a PostgreSQL database and provides an endpoint to retrieve employee data.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, establishes a connection pool to a PostgreSQL database, and defines a GET endpoint '/employees' that queries employee data from the database. It measures the query execution time and returns the results along with the elapsed time.\n\nInput: None (The function takes no parameters as all configuration is hardcoded within the function)\n\nOutput: None (The function doesn't return anything but starts an Express server listening on port 2015 and provides an endpoint that sends JSON responses)",
    "Canonical_solution": "function setupExpressServer() {\n    const app = require(\"express\")();\n    const {Pool} = require(\"pg\");\n\n    const pool = new Pool({\n        \"host\": \"husseinmac.local\",\n        \"port\": 5432,\n        \"user\":\"postgres\",\n        \"password\" : \"postgres\",\n        \"database\" : \"husseindb\",\n        \"max\": 20,\n        \"connectionTimeoutMillis\" : 0,\n        \"idleTimeoutMillis\": 0\n    });\n\n    app.get(\"/employees\", async (req, res) => {\n        const fromDate = new Date();\n        const results = await pool.query(\"select employeeid eid,firstname,ssn from employees\");\n        console.table(results.rows);\n        console.log(new Date());\n        const toDate = new Date();\n        const elapsed = toDate.getTime() - fromDate.getTime();\n        res.send({\"rows\": results.rows, \"elapsed\": elapsed, \"method\": \"pool\"});\n    });\n\n    app.listen(2015, () => console.log(\"Listening on port 2015\"));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst pg = require('pg');\n\nconst setupExpressServer = () => {\n  const app = express();\n  const pool = new pg.Pool({\n    user: 'your_username',\n    host: 'localhost',\n    database: 'your_database',\n    password: 'your_password',\n    port: 5432,\n  });\n\n  app.get('/employees', async (req, res) => {\n    const start = Date.now();\n    try {\n      const { rows } = await pool.query('SELECT * FROM employees');\n      const elapsed = Date.now() - start;\n      res.json({ employees: rows, query_time: elapsed });\n    } catch (err) {\n      console.error(err);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  });\n\n  app.listen(2015, () => {\n    console.log('Server is running on port 2015');\n  });\n};\n\nsetupExpressServer();"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a function to start an Express server with webpack middleware for development purposes, serving an HTML file as the main entry point.\n\nFunction Description: The function initializes an Express application, configures webpack middleware for development (including hot module replacement), sets up a catch-all route to serve the main HTML file, and starts the server on a specified port. It includes error handling for server startup.\n\nInput: None (The function doesn't take any parameters as input)\n\nOutput: None (The function doesn't return any value but starts a server process and logs messages to the console)",
    "Canonical_solution": "function startServer() {\n    var app = new (require('express'))();\n    var port = 3000;\n    \n    app.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }));\n    app.use(webpackHotMiddleware(compiler));\n    \n    app.use(function(req, res) {\n        res.sendFile(__dirname + '/index.html');\n    });\n    \n    app.listen(port, function(error) {\n        if (error) {\n            console.error(error);\n        } else {\n            console.info(\"==> \ud83c\udf0e  Listening on port %s. Open up http://localhost:%s/ in your browser.\", port, port);\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst webpack = require('webpack');\nconst { resolve } = require('path');\nconst { createServer } = require('http');\nconst { app, BrowserWindow } = require('electron');\n\nconst config = require('./webpack.config.js');\n\nconst server = express();\nconst compiler = webpack(config);\n\nserver.use(webpackHotMiddlewares(compiler, {\n  path: __dirname + '/dist',\n  publicPath: config.output.publicPath,\n  filename: 'bundle.js'\n}));\n\nserver.get('*', (req, res) => {\n  res.sendFile(resolve(__dirname, 'dist', 'index.html'));\n});\n\nserver.listen(3000, (err) => {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  console.log('Server is running on port 3000');\n});"
  },
  {
    "Task_id": 79,
    "Instruction": "Task Description: Create a function that initializes and starts an Express.js HTTP server with REST API capabilities, static file serving, and error handling.\n\nFunction Description: The function `startServer` creates and configures an Express.js application, sets up middleware for static file serving and request body parsing, configures REST API routes with error handling, and starts the HTTP server on a specified port. The server handles both regular web traffic and API requests through virtual hosting.\n\nInput: None (uses environment variable PORT if available)\n\nOutput: Returns the HTTP server instance that was created and started.\n\nTask Description: ...\n\nFunction Description: ...\n\nInput: ...\n\nOutput: ...",
    "Canonical_solution": "function startServer() {\n    var http = require('http'),\n        express = require('express'),\n        app = express();\n\n    app.set('port', process.env.PORT || 3000);\n\n    app.use(express.static(__dirname + '/public'));\n    app.use(require('body-parser')());\n\n    var rest = require('connect-rest');\n    var apiOptions = {\n        context: '/',\n        domain: require('domain').create(),\n    };\n\n    apiOptions.domain.on('error', function(err){\n        console.log('API domain error.\\n', err.stack);\n        setTimeout(function(){\n            console.log('Server shutting down after API domain error.');\n            process.exit(1);\n        }, 5000);\n        server.close();\n        var worker = require('cluster').worker;\n        if(worker) worker.disconnect();\n    });\n\n    app.use(vhost('api.*', rest.rester(apiOptions)));\n\n    var server = http.createServer(app).listen(app.get('port'), function(){\n        console.log('Express started in ' + app.get('env') +\n            ' mode on http://localhost:' + app.get('port') +\n            '; press Ctrl-C to terminate.');\n    });\n\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst port = process.env.PORT || 3000;\n\n// Middleware for static file serving\napp.use(express.static(path.join(__dirname, 'public')));\n\n// Middleware for parsing JSON request bodies\napp.use(express.json());\n\n// Error handling middleware\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something went wrong!');\n});\n\n// REST API routes (example)\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'Hello from the API!' });\n});\n\n// Start the server\nconst server = app.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nserver;"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by detecting the shortening service and using the appropriate API or HTTP HEAD request to follow redirects. It handles recursive expansion with depth limiting and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening service names to their associated domains\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration including known URL shortening services and timeout\n- expand(args: [Object], callback: [Function]) -> [void] - The main method that initiates URL expansion\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to be called with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - err: [Error] - Any error encountered (optional)\n      - headers: [Object] - Response headers (optional)\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n\nThe class includes several internal API methods (isgd, googl, budurl, snipurl, generic) that handle specific URL shortening services or generic URL expansion through HTTP HEAD requests. These methods are not meant to be called directly but are used internally by the expand method.",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "right_result": "class URLExpander {\n  constructor() {\n    this.map = {\n      isgd: 'is.gd',\n      googl: 'goo.gl',\n      budurl: 'budurl.com',\n      snipurl: 'snipurl.com',\n      generic: 'generic'\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      isgd: (url, callback) => {\n        const req = require('request');\n        req.get({\n          url: `https://${this.map.isgd}/${url}`,\n          timeout: this.timeout\n        }, (err, res, body) => {\n          if (err) return callback(err);\n          if (res.statusCode === 302) {\n            callback(null, res.headers.location);\n          } else {\n            callback(new Error('Failed to expand URL'));\n          }\n        });\n      },\n      googl: (url, callback) => {\n        const req = require('request');\n        req.get({\n          url: `https://${this.map.googl}/${url}`,\n          timeout: this.timeout\n        }, (err, res, body) => {\n          if (err) return callback(err);\n          if (res.statusCode === 302) {\n            callback(null, res.headers.location);\n          } else {\n            callback(new Error('Failed to expand URL'));\n          }\n        });\n      },\n      budurl: (url, callback) => {\n        const req = require('request');\n        req.get({\n          url: `https://${this.map.budurl}/${url}`,\n          timeout: this.timeout\n        }, (err, res, body) => {\n          if (err) return callback(err);\n          if (res.statusCode === 302) {\n            callback(null, res.headers.location);\n          } else {\n            callback(new Error('Failed to expand URL'));\n          }\n        });\n      },\n      snipurl: (url, callback) => {\n        const req = require('request');\n        req.get({\n          url: `https://${this.map.snipurl}/${url}`,\n          timeout: this.timeout\n        }, (err, res, body) => {\n          if (err) return callback(err);\n          if (res.statusCode === 302) {\n            callback(null, res.headers.location);\n          } else {\n            callback(new Error('Failed to expand URL'));\n          }\n        });\n      },\n      generic: (url, callback) => {\n        const req = require('request');\n        req.head({\n          url,\n          timeout: this.timeout\n        }, (err, res) => {\n          if (err) return callback(err);\n          if (res.statusCode === 302) {\n            callback(null, res.headers.location);\n          } else {\n            callback(new Error('Failed to expand URL'));\n          }\n        });\n      }\n    };\n  }\n\n  expand(args, callback) {\n    const { url, depth = 0, seen = {} } = args;\n    const key = `${url}-${depth}`;\n    if (seen[key]) {\n      return callback(null, { ...args, err: new Error('Cycle detected') });\n    }\n    seen[key] = true;\n\n    const service = this.determineService(url);\n    const api = this.APIs[service];\n\n    if (!api) {\n      return callback(null, { ...args, err: new Error('Unknown shortening service') });\n    }\n\n    api(url, (err, expandedUrl) => {\n      if (err) {\n        return callback(null, { ...args, err });\n      }\n\n      if (expandedUrl && expandedUrl !== url) {\n        return this.expand({ url: expandedUrl, depth: depth + 1, seen }, callback);\n      }\n\n      callback(null, { ...args, url, depth, seen });\n    });\n  }\n\n  determineService(url) {\n    const domain = new URL(url).hostname;\n    for (const service in this.map) {\n      if (domain.includes(this.map[service])) {\n        return service;\n      }\n    }\n    return 'generic';\n  }\n}"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a function that sets up an HTTP server using Express.js framework, configures middleware for logging, and defines route handlers for various endpoints.\n\nFunction Description: The function `setupServer` initializes an Express application, adds request logging middleware using Morgan, defines route handlers for the root path ('/'), about page ('/about'), and two API endpoints ('/api/products' and '//api/items'), and starts the server listening on port 5000.\n\nInput: None\n\nOutput: None (The function's effect is to start an HTTP server that listens on port 5000 and responds to defined routes)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const app = express();\n    const morgan = require('morgan');\n    \n    app.use(morgan('tiny'));\n    \n    app.get('/', (req, res) => {\n        res.send('Home');\n    });\n    app.get('/about', (req, res) => {\n        res.send('About');\n    });\n    app.get('/api/products', (req, res) => {\n        res.send('Products');\n    });\n    app.get('/api/items', (req, res) => {\n        console.log(req.user);\n        res.send('Items');\n    });\n    \n    app.listen(5000, () => {\n        console.log('Server is listening on port 5000....');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst morgan = require('morgan');\n\nfunction setupServer() {\n  const app = express();\n\n  // Request logging middleware\n  app.use(morgan('dev'));\n\n  // Route handler for root path\n  app.get('/', (req, res) => {\n    res.send('Welcome to the homepage!');\n  });\n\n  // Route handler for about page\n  app.get('/about', (req, res) => {\n    res.send('This is the about page.');\n  });\n\n  // Route handler for API products\n  app.get('/api/products', (req, res) => {\n    res.json({ message: 'Products API endpoint' });\n  });\n\n  // Route handler for API items\n  app.get('/api/items', (req, res) => {\n    res.json({ message: 'Items API endpoint' });\n  });\n\n  // Start the server\n  const PORT = 5000;\n  app.listen(PORT, () => {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  });\n}\n\nsetupServer();"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a function that sets up an Express server with various middleware configurations for static file serving, API proxying, HTML5 history API fallback, and webpack development tools.\n\nFunction Description: The function `setupExpressServer` initializes an Express application and configures it with multiple middleware layers. It serves static files from a specified directory, proxies API requests to a mock server, enables HTML5 History API fallback for single-page applications, and integrates Webpack's development and hot-reload middleware. Finally, it starts the server on a specified port.\n\nInput: \n- None (The function relies on external constants/variables: PATHS.STATIC, PORTS.MOCK_SERVER, PORTS.DEV_SERVER, compiler, and config)\n\nOutput: \n- None (The function's side effect is starting an Express server that listens on PORTS.DEV_SERVER)",
    "Canonical_solution": "function setupExpressServer() {\n  var express = require('express');\n  var proxy = require('http-proxy-middleware');\n  var app = express();\n\n  // Provide static resources\n  app.use('/static', express.static(PATHS.STATIC));\n\n  // Mock server proxy\n  app.use('/api', proxy({\n    target: 'http://127.0.0.1:' + PORTS.MOCK_SERVER,\n    changeOrigin: true,\n    pathRewrite: {\n      '^/api': '/'\n    }\n  }));\n\n  // HTML5 History API fallback\n  app.use(require('connect-history-api-fallback')());\n\n  // Webpack middleware\n  app.use(require('webpack-dev-middleware')(compiler, {\n    noInfo: true,\n    publicPath: config.output.publicPath\n  }));\n\n  // Hot reload middleware\n  app.use(require('webpack-hot-middleware')(compiler));\n\n  // Start server\n  app.listen(PORTS.DEV_SERVER);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "function setupExpressServer() {\n  const express = require('express');\n  const path = require('path');\n  const proxy = require('http-proxy-middleware');\n  const { webpack } = require('webpack');\n  const devMiddleware = require('webpack-dev-middleware');\n  const hotMiddleware = require('webpack-hot-middlewares');\n\n  const app = express();\n\n  // Serve static files from the specified directory\n  app.use(express.static(PATHS.STATIC));\n\n  // Proxy API requests to the mock server\n  app.use('/api', proxy(PORTS.MOCK_SERVER));\n\n  // HTML5 History API fallback for single-page applications\n  app.use((req, res) => {\n    res.sendFile(path.join(PATHS.STATIC, 'index.html'));\n  });\n\n  // Webpack development and hot-reload middleware\n  app.use(devMiddleware(compiler, {\n    publicPath: config.output.publicPath,\n    stats: 'minimal'\n  }));\n\n  app.use(hotMiddleware(compiler, {\n    path: config.output.publicPath,\n    heartbeat: 10000\n  }));\n\n  // Start the server on the specified port\n  app.listen(PORTS.DEV_SERVER, () => {\n    console.log(`Server running on http://localhost:${PORTS.DEV_SERVER}`);\n  });\n}"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a function to start an Express server with REST API endpoints for managing tourist attractions, including retrieving approved attractions, adding new attractions, and fetching specific attraction details.\n\nFunction Description: The function initializes an Express application, configures middleware, sets up REST API routes using connect-rest, and starts an HTTP server. It handles GET and POST requests for attractions data, connects to a MongoDB model for data persistence, and implements error handling through domains.\n\nInput: None (The function takes no parameters but relies on environment variables like PORT and requires external modules)\n\nOutput: Returns the HTTP server instance that was created and started.\n\nMethods:\n\n- GET /attractions: Retrieves all approved attractions (returns array of attraction objects)\n- POST /attraction: Creates a new attraction (requires name, description, location, and email in request body, returns new attraction ID)\n- GET /attraction/:id: Retrieves details of a specific attraction (requires ID parameter, returns attraction object)\n\nError Handling:\n- Implements domain-based error handling that logs errors and gracefully shuts down the server\n- Returns appropriate error messages for database operations\n\nDependencies:\n- Requires Express, connect-rest, body-parser, and a MongoDB model (Attraction)\n- Uses cluster module for worker process management in case of errors",
    "Canonical_solution": "function startServer() {\n    var http = require('http'),\n        express = require('express'),\n        app = express();\n\n    app.set('port', process.env.PORT || 3000);\n\n    app.use(express.static(__dirname + '/public'));\n    app.use(require('body-parser')());\n\n    var rest = require('connect-rest');\n    var apiOptions = {\n        context: '/',\n        domain: require('domain').create(),\n    };\n\n    apiOptions.domain.on('error', function(err){\n        console.log('API domain error.\\n', err.stack);\n        setTimeout(function(){\n            console.log('Server shutting down after API domain error.');\n            process.exit(1);\n        }, 5000);\n        server.close();\n        var worker = require('cluster').worker;\n        if(worker) worker.disconnect();\n    });\n\n    var Attraction = require('./models/attraction.js');\n\n    rest.get('/attractions', function(req, content, cb){\n        Attraction.find({ approved: true }, function(err, attractions){\n            if(err) return cb({ error: 'Internal error.' });\n            cb(null, attractions.map(function(a){\n                return {\n                    name: a.name,\n                    description: a.description,\n                    location: a.location,\n                };\n            }));\n        });\n    });\n\n    rest.post('/attraction', function(req, content, cb){\n        var a = new Attraction({\n            name: req.body.name,\n            description: req.body.description,\n            location: { lat: req.body.lat, lng: req.body.lng },\n            history: {\n                event: 'created',\n                email: req.body.email,\n                date: new Date(),\n            },\n            approved: false,\n        });\n        a.save(function(err, a){\n            if(err) return cb({ error: 'Unable to add attraction.' });\n            cb(null, { id: a._id });\n        }); \n    });\n\n    rest.get('/attraction/:id', function(req, content, cb){\n        Attraction.findById(req.params.id, function(err, a){\n            if(err) return cb({ error: 'Unable to retrieve attraction.' });\n            cb(null, { \n                name: a.name,\n                description: a.description,\n                location: a.location,\n            });\n        });\n    });\n\n    var server = http.createServer(app).listen(app.get('port'), function(){\n        console.log( 'Express started in ' + app.get('env') +\n            ' mode on http://localhost:' + app.get('port') +\n            '; press Ctrl-C to terminate.' );\n    });\n\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst connectRest = require('connect-rest');\nconst bodyParser = require('body-parser');\nconst cluster = require('cluster');\nconst os = require('os');\nconst mongoose = require('mongoose');\nconst AppError = require('./AppError'); // Assuming this is a custom error class\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// MongoDB connection\nmongoose.connect('mongodb://localhost:27017/touristAttractions', { useNewUrlParser: true, useUnifiedTopology: true })\n  .then(() => console.log('MongoDB connected'))\n  .catch(err => {\n    console.error('MongoDB connection error:', err);\n    process.exit(1);\n  });\n\n// Define Mongoose model (Assuming it's already defined as 'Attraction')\n// const Attraction = mongoose.model('Attraction');\n\n// REST API routes\nconnectRest(app, {\n  model: 'Attraction',\n  methods: {\n    get: {\n      path: '/attractions',\n      query: { approved: true }\n    },\n    post: {\n      path: '/attraction',\n      body: { name, description, location, email }\n    },\n    getById: {\n      path: '/attraction/:id'\n    }\n  }\n});\n\n// Error handling domain\nconst errorDomain = new Error();\nerrorDomain.on('error', (err) => {\n  console.error('Server error:', err);\n  process.exit(1);\n});\n\n// Start server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n\n// Cluster setup\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died with code ${code} and signal ${signal}`);\n    if (signal === 'SIGTERM' && code === 0) {\n      console.log('Shutting down server...');\n      server.close(() => {\n        process.exit(0);\n      });\n    }\n  });\n}\n\nmodule.exports = server;"
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a function that starts an HTTP server using Express.js to handle POST requests, log user input, and respond with a success message.\n\nFunction Description: The function `startServer` initializes an Express.js server that listens on port 8080. It configures middleware to parse JSON requests and defines a POST route handler at the root path (\"/\"). The handler logs the user-provided number and its square, then sends a JSON response indicating success. The server logs its startup status to the console.\n\nInput: None (The function takes no parameters. Input is received via HTTP POST requests to the server.)\n\nOutput: None (The function does not return a value. It sends an HTTP response with a JSON object `{\"success\": true}` and logs messages to the console.)",
    "Canonical_solution": "function startServer() {\n    const express = require(\"express\");\n    const app = express();\n    app.use(express.json());\n\n    app.post(\"/\", (req, res) => {\n        log(req.body.num);\n        res.send(JSON.stringify({\"success\":true}));\n    });\n\n    app.listen(8080, 'localhost', () => console.log(\"Listening on port 8080\"));\n\n    function log(num) {\n        const message = `User input is ${num} the sqr it ${num*num}`;\n        console.log(`${Date()} : ${message}`);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const number = req.body.number;\n  console.log(`Received number: ${number}, Square: ${number * number}`);\n  res.json({ success: true });\n});\n\napp.listen(8080, () => {\n  console.log('Server is running on port 8080');\n});"
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Create a function that sets up an Express server to serve static files and render a React component on the root route.\n\nFunction Description: The function `setupServer` initializes an Express application, configures middleware to serve static files from a specified directory, defines a route handler for the root path that renders a React component to a string and sends it as an HTML response, and starts the server listening on port 3003.\n\nInput: None\n\nOutput: None (The function starts an Express server but does not return any value)",
    "Canonical_solution": "var express = require('express');\n\nfunction setupServer() {\n    var app = express();\n    app.use('/static', express.static('static'));\n    app.get('/', (req, res) => {\n        const rendered = ReactDOMServer.renderToString(<SimpleEditor />);\n        const page = `<!doctype html>\n<html>\n  <body>\n    <div id=\"react-content\">${ rendered }</div>\n    <script src=\"/static/bundle.js\"></script>\n  </body>\n</html>\n        `;\n        res.send(page);\n    });\n    app.listen(3003);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\n\nfunction setupServer() {\n  const app = express();\n  const staticDir = path.join(__dirname, 'public');\n  app.use(express.static(staticDir));\n\n  app.get('/', (req, res) => {\n    const App = () => <h1>Hello from React!</h1>;\n    const html = ReactDOMServer.renderToString(<App />);\n    res.send(`<!DOCTYPE html>\n<html>\n<head>\n  <title>React App</title>\n</head>\n<body>\n  <div id=\"root\">${html}</div>\n</body>\n</html>`);\n  });\n\n  app.listen(3003, () => {\n    console.log('Server is running on port 3003');\n  });\n}\n\nsetupServer();"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a function that sets up an Express.js server to handle HTTP requests, including GET and POST methods, with route parameters and query string processing.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server that:\n1. Configures middleware for URL-encoded form data\n2. Sets up routes for:\n   - Root path (/) with both GET (returns HTML form) and POST (processes form submission) methods\n   - Dynamic route (/testes/) with optional parameters that can process both route parameters and query strings\n3. Starts the server listening on port 3000\n\nInput: None (the function takes no parameters)\n\nOutput: None (the function doesn't return anything but creates a running web server that:\n   - Logs server start information to console\n   - Responds to HTTP requests as configured\n   - Logs request parameters and body data to console)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require(\"express\");\n    const app = express();\n\n    app.use(express.urlencoded({ extended: true }));\n\n    app.get(\"/\", (req, res) => {\n        res.send(`\n        <form action=\"/\" method=\"POST\">\n        Nome do cliente: <input type=\"text\" name=\"qualquercoisa\"><br>\n        Outro campo: <input type=\"text\" name=\"aquioutrocampo\">\n        <button>Ol\u00e1 mundo</button>\n        </form>\n        `);\n    });\n\n    app.get(\"/testes/:idUsuarios?/:parametro?\", (req, res) => {\n        console.log(req.params);\n        console.log(req.query);\n        res.send(req.query.facebookprofile);\n    });\n\n    app.post(\"/\", (req, res) => {\n        console.log(req.body);\n        res.send(`O que voc\u00ea me enviou foi: ${req.body.qualquercoisa}`);\n    });\n\n    app.listen(3000, () => {\n        console.log(\"Acessar http://localhost:3000\");\n        console.log(\"Servidor executando na porta 3000\");\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <form action=\"/submit\" method=\"post\">\n          Name: <input type=\"text\" name=\"name\"><br>\n          Email: <input type=\"email\" name=\"email\"><br>\n          <input type=\"submit\" value=\"Submit\">\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/submit', (req, res) => {\n  console.log('Received POST request with body:', req.body);\n  res.send(`Received form data: Name - ${req.body.name}, Email - ${req.body.email}`);\n});\n\napp.get('/testes/:id?', (req, res) => {\n  const id = req.params.id;\n  const query = req.query;\n  console.log('Route parameters:', id);\n  console.log('Query string parameters:', query);\n  res.send(`Route parameters: ${id}, Query string: ${JSON.stringify(query)}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a function that sets up an Express server with middleware configuration, route handling, and database interactions for tracking page views and predictions.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js server with CORS support and body parsing middleware. It establishes routes for handling POST requests to track page views, interact with a MongoDB database to store/view predictions, and determine prefetch paths based on user navigation patterns. The server listens on a configured port.\n\nInput: None (The function doesn't take any direct parameters, but relies on external configuration files for database connection and server port)\n\nOutput: Returns the Express application instance (app) that has been configured and started.\n\nNote: The function assumes the existence of several external dependencies:\n- express, body-parser, and cors npm packages\n- MongoDB connection configuration in './config'\n- Mongoose models Prediction and PageView in './src/models'\n- A helper function `shouldPrefetch` (not shown in reference code)\n- A helper function `getPreviousPageId` (not shown in reference code)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express')\n    const bodyParser = require('body-parser')\n    const cors = require('cors')\n    const app = express()\n\n    app.use(bodyParser.json())\n    app.use(bodyParser.urlencoded({ extended: true }))\n    app.use(cors())\n\n    app.all('/', function (req, res, next) {\n        res.header('Access-Control-Allow-Origin', '*')\n        res.header('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS')\n        res.header('Access-Control-Allow-Headers', 'X-Requested-With, Content-Type')\n        next()\n    })\n\n    app.post('/', async (req, res) => {\n        const mongoose = require('mongoose')\n        const Prediction = require('./src/models/prediction')\n        const PageView = require('./src/models/pageView')\n        const config = require('./config')\n\n        mongoose.connect(config.db.mongoURL)\n        const prediction = await Prediction.findOne({'pagePath': req.body['pagePath']})\n        const prefetchPath = shouldPrefetch(req, prediction) ? prediction['nextPagePath'] : ''\n\n        const pageView = await PageView.create({\n            pagePath: req.body['pagePath'],\n            clientInfo: req.body['clientInfo'],\n            userFlow: req.body['userFlow'],\n            prefetchPath: prefetchPath\n        })\n\n        if (req.body.userFlow.length > 0) {\n            const id = getPreviousPageId(req.body.userFlow)\n            await PageView.findByIdAndUpdate(id, {'actualNextPagePath': req.body.pagePath})\n        }\n\n        res.json({\n            'pageViewId': pageView._id,\n            'prefetchPath': prefetchPath\n        })\n    })\n\n    app.listen(config.server.port)\n    return app\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst mongoose = require('mongoose');\nconst app = express();\n\n// Load configuration\nconst config = require('./config');\n\n// Database connection\nmongoose.connect(config.databaseUrl, {\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n});\n\n// Middleware\napp.use(cors());\napp.use(bodyParser.json());\n\n// Routes\napp.post('/track-page-view', async (req, res) => {\n  const { pageId, previousPageId } = req.body;\n  const PageView = require('./src/models/PageView');\n  const Prediction = require('./src/models/Prediction');\n\n  try {\n    // Create and save page view\n    const pageView = new PageView({\n      pageId,\n      previousPageId\n    });\n    await pageView.save();\n\n    // Get predictions for the page\n    const predictions = await Prediction.find({ pageId });\n\n    // Determine if prefetch is needed\n    const shouldPrefetch = require('./src/helpers').shouldPrefetch;\n    const prefetchPath = shouldPrefetch(pageId);\n\n    res.status(200).json({\n      message: 'Page view tracked successfully',\n      predictions,\n      prefetchPath\n    });\n  } catch (error) {\n    res.status(500).json({ error: 'Error tracking page view' });\n  }\n});\n\n// Start server\napp.listen(config.port, () => {\n  console.log(`Server running on port ${config.port}`);\n});\n\nmodule.exports = app;"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a function that sets up an Express server to serve static files and handle specific routes, with different behaviors for production and development environments.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures static file serving, defines route handlers for specific files and a catch-all route, and starts the server on port 3000. In production, it serves files directly, while in development, it redirects to a webpack dev server on port 9090.\n\nInput: None\n\nOutput: None (The function starts an Express server that listens on port 3000 and logs a message when ready)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express');\n    const app = express();\n    const path = require('path');\n    \n    app.use(express.static(path.join(__dirname, './../')));\n    \n    app.get('/app.js', (req, res) => {\n        if (process.env.PRODUCTION) {\n            res.sendFile(__dirname + '/client/app.js');\n        } else {\n            res.redirect('//localhost:9090/client/app.js');\n        }\n    });\n    \n    app.get('/style.css', (req, res) => {\n        if (process.env.PRODUCTION) {\n            res.sendFile(__dirname + '/client/style.css');\n        } else {\n            res.redirect('//localhost:9090/client/style.css');\n        }\n    });\n    \n    app.get('*', (req, res) => {\n        res.sendFile(path.join(__dirname, '../', 'index.html'));\n    });\n    \n    const server = app.listen(3000, () => {\n        console.log('listening on 3000....');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\n\nfunction setupExpressServer() {\n  const app = express();\n  const __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n  // Serve static files\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  // Route for specific files\n  app.get('/file1', (req, res) => {\n    res.sendFile(path.join(__dirname, 'public', 'file1.txt'));\n  });\n\n  app.get('/file2', (req, res) => {\n    res.sendFile(path.join(__dirname, 'public', 'file2.txt'));\n  });\n\n  // Catch-all route\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'public', 'index.html'));\n  });\n\n  // Start server\n  const port = 3000;\n  app.listen(port, () => {\n    console.log(`Server is running on http://localhost:${port}`);\n  });\n\n  // Production vs development environment handling\n  if (process.env.NODE_ENV === 'production') {\n    // Serve files directly\n    app.use(express.static(path.join(__dirname, 'public')));\n  } else {\n    // Redirect to webpack dev server\n    app.use((req, res) => {\n      res.redirect(`http://localhost:9090${req.url}`);\n    });\n  }\n}\n\nif (import.meta.url === fileURLToPath(import.meta.url)) {\n  setupExpressServer();\n}"
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Create an HTTP server using Express.js that serves a JavaScript version endpoint and handles file uploads with configuration options.\n\nFunction Description: The function sets up an Express.js server with middleware for file uploads and JSON body parsing. It defines a route '/version.js' that returns JavaScript code to display a version number in the UI. The server listens on a specified port from environment variables.\n\nInput:\n- process.env.PORT: [String] - The port number on which the server should listen\n- constants.VERSION_NAME: [String] - The version string to be displayed in the UI (used in the version.js endpoint)\n\nOutput:\n- An active HTTP server listening on the specified port\n- The '/version.js' endpoint returns JavaScript code that updates the UI with the version number every second\n\nMethods:\n- app.use(): [Function] - Configures middleware for file uploads and JSON body parsing\n- app.get(): [Function] - Defines a GET route handler for '/version.js'\n- app.listen(): [Function] - Starts the server on the specified port\n\nMiddleware Configuration:\n- fileUpload: [Object] - Configures file upload options (createParentPath: true)\n- bodyParser.json: [Object] - Configures JSON body parsing with a 50MB limit\n\nRoute Handlers:\n- '/version.js': [GET] - Returns JavaScript code that continuously updates an element with id \"uiversion\" with the version string",
    "Canonical_solution": "const express = require('express')\nconst bodyParser = require('body-parser')\nconst fileUpload = require('express-fileupload');\n\nlet app = express()\n\napp.use(fileUpload({\n    createParentPath: true\n}));\napp.use(bodyParser.json({limit: '50mb'}))\n\napp.get('/version.js', (req, res) => {\n    res.writeHead(200, {\n        'Content-Type': 'application/javascript'\n    });\n\n    res.write( `\n        function setUIVersionNow() {\n            setTimeout( setUIVersionNow, 1000);\n            var element = document.getElementById(\"uiversion\");\n            if (element != null) {\n                element.innerHTML = \"${constants.VERSION_NAME}\";\n            }\n        }\n        setTimeout( setUIVersionNow, 1000);\n    ` );\n    res.end();\n});\n\napp.listen(process.env.PORT, () => {\n    console.log(`HTTP server running on port: http://*:${process.env.PORT}`)\n})",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst multer = require('multer');\nconst bodyParser = require('body-parser');\n\nconst app = express();\n\nconst fileUpload = multer({ createParentPath: true });\nconst bodyParserJson = bodyParser.json({ limit: '50mb' });\n\napp.use(fileUpload.array());\napp.use(bodyParserJson);\n\napp.get('/version.js', (req, res) => {\n  res.type('application/javascript');\n  res.send(`\n    setInterval(() => {\n      document.getElementById('uiversion').innerText = '${process.env.VERSION_NAME}';\n    }, 1000);\n  `);\n});\n\napp.listen(process.env.PORT, () => {\n  console.log(`Server is running on port ${process.env.PORT}`);\n});"
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create a function that sets up and starts an Express.js server with middleware configuration and route handling.\n\nFunction Description: The function `setupServer` initializes an Express application, configures necessary middleware for JSON and URL-encoded request parsing, defines route handlers for specific endpoints, and starts the server listening on a specified port and host.\n\nInput:\n- `port` [Number] - The port number on which the server should listen.\n- `config` [Object] - (Optional) Configuration object for additional server settings (not currently used in the reference implementation but included for extensibility).\n\nOutput:\n- Returns the HTTP server instance created by `app.listen()`.\n- The server will log its listening address to the console upon successful startup or log any errors encountered during startup.",
    "Canonical_solution": "var express = require('express')\nvar app = express()\n\nfunction setupServer(port, config) {\n    // Configure middleware\n    app.use(express.json())\n    app.use(express.urlencoded({ extended: true }))\n    \n    // Define routes\n    app.get('/imagebox', require('../server/routes/imagebox').upload)\n    app.get('/readapi', require('../server/routes/api').requestApi)\n    \n    // Start server\n    return app.listen(port, '0.0.0.0', function(err) {\n        if (err) {\n            console.log(err)\n            return\n        }\n        console.log('Listening at http://localhost:' + port + '\\n')\n    })\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "function setupServer(port, config) {\n  const express = require('express');\n  const app = express();\n\n  // Middleware for parsing JSON and URL-encoded request bodies\n  app.use(express.json());\n  app.use(express.urlencoded({ extended: true }));\n\n  // Route handlers\n  app.get('/', (req, res) => {\n    res.send('Hello World!');\n  });\n\n  app.post('/data', (req, res) => {\n    res.send('Received data: ' + JSON.stringify(req.body));\n  });\n\n  // Start the server\n  const server = app.listen(port, () => {\n    console.log(`Server is running on http://localhost:${port}`);\n  });\n\n  server.on('error', (err) => {\n    console.error(`Error starting server: ${err.message}`);\n  });\n\n  return server;\n}"
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, define route handlers, and start the server on a specified port.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures session management with MongoDB storage, defines route handlers for the root path and all other paths, and starts the server on the specified port. It uses environment variables for configuration.\n\nInput: None (The function relies on environment variables for configuration, such as `process.env.SESSION_NAME`, `process.env.SESSION_SECRET`, `process.env.MONGO_URL_TEST`, and `process.env.PORT`.)\n\nOutput: None (The function starts an Express server and logs the server's readiness to the console. It does not return any value.)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express');\n    const app = express();\n    \n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    \n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: process.env.MONGO_URL_TEST,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n    \n    app.use(session(sessionOptions));\n    \n    app.get('/', async (req, res) => {\n        req.session.foo = 'bar';\n        const user = JSON.stringify(await User.findOne({ slug: 'team-builder-book' }));\n        app.render(req, res, '/', { user });\n    });\n    \n    app.get('*', (req, res) => handle(req, res));\n    \n    const port = process.env.PORT || 8000;\n    app.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on http://localhost:${port}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst MongoDBSessionStore = require('connect-mongo')(session);\nconst app = express();\n\nfunction setupExpressServer() {\n  const SESSION_NAME = process.env.SESSION_NAME || 'session';\n  const SESSION_SECRET = process.env.SESSION_SECRET || 'secret_key';\n  const MONGO_URL_TEST = process.env.MONGO_URL_TEST || 'mongodb://localhost:27017/sessiondb';\n  const PORT = process.env.PORT || 3000;\n\n  app.use(session({\n    name: SESSION_NAME,\n    secret: SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: new MongoDBSessionStore({\n      mongooseConnection: null,\n      url: MONGO_URL_TEST,\n      collection: 'sessions'\n    })\n  }));\n\n  app.use(express.json());\n  app.use(express.urlencoded({ extended: true }));\n\n  app.get('/', (req, res) => {\n    res.send('Welcome to the Express server with MongoDB session store!');\n  });\n\n  app.get('*', (req, res) => {\n    res.send('This is a protected route. You need to be authenticated.');\n  });\n\n  app.listen(PORT, () => {\n    console.log(`Server is running on port ${PORT}`);\n  });\n}\n\nsetupExpressServer();\n```"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Create a function that sets up an Express server to handle file uploads, process images by resizing and adding a watermark, and serve the processed images back to the client.\n\nFunction Description: The function `setupServer` initializes an Express application, configures middleware for handling file uploads and static file serving, defines routes for the root path and file uploads, and starts the server on port 3000. The upload route processes the uploaded image by resizing it to a width of 800 pixels, adding a logo watermark, and saving it as a JPEG with 80% quality. The temporary upload file is deleted after processing.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an Express server listening on port 3000.)",
    "Canonical_solution": "function setupServer() {\n    var fs = require('fs'),\n        path = require('path'),\n        express = require('express'),\n        images = require('../index');\n\n    var app = express();\n\n    app.use(express.bodyParser({\n        uploadDir: __dirname + '/upload'\n    }));\n\n    app.use(express.static(__dirname + '/upload'));\n\n    app.get('/', function(req, res) {\n        res.send('<form method=\"post\" enctype=\"multipart/form-data\" action=\"/upload\"><input type=\"file\" name=\"photo\" /><input type=\"submit\" /></form>');\n    });\n\n    app.post('/upload', function(req, res) {\n        var tmp_path = req.files.photo.path,\n            out_path = tmp_path + '.jpg',\n            photo;\n\n        photo = images(tmp_path);\n        photo.size(800)\n            .draw(images('./logo.png'), 800 - 421, photo.height() - 117)\n            .save(out_path, {\n            quality: 80\n        });\n\n        fs.unlink(tmp_path, function(err) {\n            if (err) throw err;\n            res.send('<a href=\"/\" title=\"upload\"><img src=\"/' + path.basename(out_path) + '\" /></a>');\n        });\n    });\n\n    app.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\nconst sharp = require('sharp');\n\nconst app = express();\nconst upload = multer({ dest: 'uploads/' });\n\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  try {\n    const inputPath = path.join(__dirname, 'uploads', req.file.filename);\n    const outputPath = path.join(__dirname, 'processed', req.file.filename);\n\n    await sharp(inputPath)\n      .resize(800)\n      .composite([{ input: path.join(__dirname, 'public', 'watermark.png'), gravity: 'south-east' }])\n      .jpeg({ quality: 80 })\n      .toFile(outputPath);\n\n    fs.unlink(inputPath, (err) => {\n      if (err) console.error(err);\n    });\n\n    res.json({ url: `/processed/${req.file.filename}` });\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('Error processing image');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create a function that starts an HTTP server using Express.js to serve static files and provide a real-time clock update endpoint.\n\nFunction Description: The function `startServer` initializes an Express.js application, configures it to serve static files from the current directory, and sets up a route (`/clock`) that sends real-time clock updates to the client every second. The server listens on port 8080.\n\nInput: None\n\nOutput: None (The function starts a server that runs indefinitely until manually stopped)",
    "Canonical_solution": "function startServer() {\n    let express = require('express');\n    let app = express();\n    app.use(express.static(__dirname));\n    app.get('/clock', function(req, res) {\n        setInterval(function() {\n            let date = new Date().toLocaleString();\n            res.write(`\n                <script type=\"text/javascript\">\n                    parent.document.getElementById('clock').innerHTML = \"${date}\";\n                </script>\n            `);\n        }, 1000);\n    });\n    app.listen(8080);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst port = 8080;\n\napp.use(express.static(path.join(__dirname)));\n\napp.get('/clock', (req, res) => {\n  const interval = setInterval(() => {\n    res.send(new Date().toLocaleTimeString());\n  }, 1000);\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}`);\n});"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, and integrate it with Next.js for server-side rendering.\n\nFunction Description: The function `setupServer` initializes an Express server with session management configured to use MongoDB for session storage. It integrates with Next.js for handling server-side rendering and routes all requests to the Next.js request handler. The server listens on a specified port and logs the root URL when ready.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Port number to listen on (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that listens on the specified port and handles requests. It logs the root URL to the console when the server is ready.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    const next = require('next');\n    const mongoose = require('mongoose');\n\n    const dev = process.env.NODE_ENV !== 'production';\n    const MONGO_URL = process.env.MONGO_URL_TEST;\n    const port = process.env.PORT || 8000;\n    const ROOT_URL = `http://localhost:${port}`;\n\n    const app = next({ dev });\n    const handle = app.getRequestHandler();\n\n    const server = express();\n\n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: MONGO_URL,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => handle(req, res));\n\n    server.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on ${ROOT_URL}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst next = require('next');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\n\nconst mongoUrl = process.env.MONGO_URL_TEST;\nconst port = process.env.PORT || 8000;\nconst sessionName = process.env.SESSION_NAME || 'session';\nconst sessionSecret = process.env.SESSION_SECRET;\n\nconst store = new MongoDBStore({\n  uri: mongoUrl,\n  collection: 'sessions'\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: false,\n    store: store,\n    cookie: { maxAge: 60000000 }\n  }));\n\n  server.use(express.static('public'));\n\n  server.get('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`Ready at http://localhost:${port}/`);\n  });\n});\n```"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Create a function to start an Express server with webpack middleware for development purposes, serving an index.html file at the root route.\n\nFunction Description: The function initializes an Express application, configures webpack middleware for development (including hot module replacement), defines a route handler for the root path (\"/\") to serve an index.html file, and starts the server on a specified port. It also includes error handling for server startup.\n\nInput: \n- None (The function does not take any parameters directly, but relies on external variables `compiler` and `config` for webpack middleware configuration.)\n\nOutput: \n- None (The function does not return a value but starts an Express server that listens on the specified port. It logs success or error messages to the console.)",
    "Canonical_solution": "function startServer() {\n    var app = new require('express')();\n    var port = 4002;\n\n    app.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }));\n    app.use(webpackHotMiddleware(compiler));\n\n    app.get(\"/\", function(req, res) {\n        res.sendFile(__dirname + '/index.html');\n    });\n\n    app.listen(port, function(error) {\n        if (error) {\n            console.error(error);\n        } else {\n            console.info(\"==> \ud83c\udf0e  Listening on port %s. Open up http://localhost:%s/ in your browser.\", port, port);\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst webpack = require('webpack');\nconst path = require('path');\n\nconst app = express();\nconst server = require('http').createServer(app);\nconst io = require('socket.io')(server);\n\nconst compiler = require('./webpack.config'); // Assuming this is the webpack compiler instance\n\napp.use(express.static(path.join(__dirname, 'dist')));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'dist', 'index.html'));\n});\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  socket.on('message', (msg) => {\n    console.log('Received:', msg);\n    socket.emit('response', `Echo: ${msg}`);\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a function to set up an Express server that serves static files for a specific route.\n\nFunction Description: The function `setupServer` initializes an Express application, configures a route to serve a static HTML file, and starts the server on port 3000. It is designed to handle GET requests for the '/users' path by sending the corresponding HTML file.\n\nInput: None\n\nOutput: None (The function starts the server and logs a message to the console when the server is running.)",
    "Canonical_solution": "const express = require('express');\nconst path = require('path');\n\nfunction setupServer() {\n    const app = express();\n    \n    app.get('/users', function (req, res) {\n        res.sendFile(path.join(__dirname, 'modules/users/views/list.html'));\n    });\n\n    app.listen(3000, function () {\n        console.log('Servidor rodando em localhost:3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\n\nfunction setupServer() {\n  const app = express();\n  const staticPath = path.join(__dirname, 'public');\n\n  app.get('/users', (req, res) => {\n    res.sendFile(path.join(staticPath, 'user.html'));\n  });\n\n  app.listen(3000, () => {\n    console.log('Server is running on port 3000');\n  });\n}\n\nsetupServer();"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Create a function that sets up an Express server with custom middleware for header manipulation, route handling for serving JavaScript files with dynamic content, and static file serving.\n\nFunction Description: The function `setupServer` initializes an Express application, configures middleware to filter certain HTTP headers, defines a route to serve a dynamically modified JavaScript file, sets up static file serving for specified directories, and starts the server on port 8080.\n\nInput: None (The function does not take any input parameters)\n\nOutput: None (The function does not return any value but starts an Express server listening on port 8080)",
    "Canonical_solution": "function setupServer() {\n    var express = require('express');\n    var app = express();\n\n    app.use(function(req, res, next) {\n        var setHeader = res.setHeader;\n        res.setHeader = function(name) {\n            switch (name) {\n                case 'Cache-Control':\n                case 'Last-Modified':\n                case 'ETag':\n                    return;\n            }\n            return setHeader.apply(res, arguments);\n        };\n        next();\n    });\n\n    app.get('/test.js', function(req, res, next) {\n        var test = fs.readFileSync(__dirname + '/test.js', 'utf8');\n        var files = load();\n\n        test = test.replace('__TESTS__', JSON.stringify(files));\n        test = test.replace('__MAIN__', runTests + '');\n\n        res.contentType('.js');\n        res.send(test);\n    });\n\n    app.use(express.static(__dirname + '/../../lib'));\n    app.use(express.static(__dirname));\n\n    app.listen(8080);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\n\nfunction setupServer() {\n  const app = express();\n\n  // Middleware to filter certain HTTP headers\n  app.use((req, res, next) => {\n    // Example: Remove 'X-Original-Header' if present\n    if (req.headers['x-original-header']) {\n      delete req.headers['x-original-header'];\n    }\n    next();\n  });\n\n  // Route to serve a dynamically modified JavaScript file\n  app.get('/dynamic.js', (req, res) => {\n    const dynamicContent = `\n      console.log('This JavaScript file is dynamically generated.');\n      window.dynamicVar = 'Dynamic value from server';\n    `;\n    res.set('Content-Type', 'application/javascript');\n    res.send(dynamicContent);\n  });\n\n  // Static file serving for specified directories\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  // Start the server on port 8080\n  const PORT = 8080;\n  app.listen(PORT, () => {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  });\n}\n\nsetupServer();"
  },
  {
    "Task_id": 98,
    "Instruction": "Task Description: Create a function that initializes and configures an Express server for handling regression test components, with customizable port settings and reference mode detection.\n\nFunction Description: The function `getServer` creates and configures an Express.js web server specifically designed for regression testing of UI components. It sets up Handlebars as the view engine, configures static file serving, and defines routes for component testing. The server can operate in either reference mode (port 8000) or development mode (custom port), with different template directories for each mode.\n\nInput:\n- P: [Number|String|undefined] - Optional port number for the server. If not provided, falls back to environment variable PORT or defaults to 8000.\n\nOutput:\n- [Object] - Returns the Express server instance that has been started and is listening on the specified port.\n\nNote: The server includes special configuration for Handlebars templates, static file serving, and a dedicated route for rendering component test pages with associated configuration data. The server also sets the process title based on whether it's running in reference mode or development mode.",
    "Canonical_solution": "function getServer(P) {\n    var PORT = P || process.env.PORT || 8000;\n    var isReference = (PORT === 8000);\n    var partialsDir = isReference ? './reference/dist/templates/handlebars/fuelux' : './templates/handlebars/fuelux';\n\n    process.title = (isReference) ? 'referenceServer' : 'devServer';\n\n    var express = require('express');\n    var app = express();\n    var exphbs  = require('express-handlebars');\n\n    app.disable('view cache');\n\n    app.engine('.hbs',\n        exphbs({\n            extname: '.hbs',\n            defaultLayout: 'main',\n            layoutsDir: './test/regression/',\n            partialsDir: [partialsDir, {namespace: 'lt', dir: './test/regression/components/'}]\n        })\n    );\n\n    app.set('view engine', '.hbs');\n    app.set('views', './test/regression/');\n\n    var path = require('path');\n    app.use(express.static(path.join(__dirname, '../../')));\n\n    app.get('/component/:component', function renderCheckboxPage (req, res) {\n        var component = req.params.component;\n        var data = require('./config/' + component + '.js');\n        data.isReference = isReference;\n        data.components = [\n            'checkbox',\n            'combobox',\n            'datepicker',\n            'loader',\n            'pillbox',\n            'placard',\n            'radio',\n            'repeater',\n            'repeater-single',\n            'repeater-multi',\n            'scheduler',\n            'search',\n            'selectlist',\n            'spinbox',\n            'tree',\n            'wizard'\n        ];\n        res.render('./components/' + component, data);\n    });\n\n    var server = app.listen(PORT, function listen () {\n        console.log('info', 'Regression test server listening on port ' + server.address().port + '. isReference: ' + isReference);\n    });\n\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "const express = require('express');\nconst path = require('path');\nconst handlebars = require('express-handlebars');\nconst os = require('os');\n\nfunction getServer(P) {\n  const app = express();\n  const port = P || process.env.PORT || 8000;\n  let isReferenceMode = false;\n\n  if (port === 8000) {\n    isReferenceMode = true;\n  }\n\n  // Set process title\n  process.title = isReferenceMode ? 'regression-reference' : 'regression-dev';\n\n  // Handlebars configuration\n  app.engine('hbs', handlebars({ extname: '.hbs', defaultLayout: 'layout' }));\n  app.set('view engine', 'hbs');\n  app.set('views', path.join(__dirname, 'views'));\n\n  // Static file serving\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  // Route for component test pages\n  app.get('/test/:component', (req, res) => {\n    const component = req.params.component;\n    const config = { component, mode: isReferenceMode ? 'reference' : 'development' };\n    res.render('test', config);\n  });\n\n  // Start server\n  app.listen(port, () => {\n    console.log(`Server is running on port ${port} in ${isReferenceMode ? 'reference' : 'development'} mode`);\n  });\n\n  return app;\n}"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a function to set up a server using Express.js with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB, integrates Next.js for server-side rendering, and sets up basic route handling. It prepares the server environment, configures middleware, and starts listening on a specified port.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret for session encryption\n)\n\nOutput: None (The function starts a server process that:\n1. Creates an Express server with session management\n2. Integrates Next.js for server-side rendering\n3. Sets up route handling\n4. Listens on the specified port\n5. Logs server readiness to console\n)",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  app.prepare().then(async () => {\n    const server = express();\n\n    server.use(express.json());\n\n    const sessionOptions = {\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: mongoSessionStore.create({\n        mongoUrl: MONGO_URL,\n        ttl: 14 * 24 * 60 * 60,\n      }),\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        httpOnly: true,\n        maxAge: 14 * 24 * 60 * 60 * 1000,\n        domain: 'localhost',\n      },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => {\n      const url = URL_MAP[req.path];\n      if (url) {\n        app.render(req, res, url);\n      } else {\n        handle(req, res);\n      }\n    });\n\n    server.listen(port, (err) => {\n      if (err) throw err;\n      console.log(`> Ready on ${ROOT_URL}`);\n    });\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "right_result": "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBSessionStore = require('connect-mongodb-session')(session);\nconst app = next();\nconst handle = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const port = process.env.PORT || 8000;\n  const mongoUrl = process.env.MONGO_URL_TEST;\n  const sessionName = process.env.SESSION_NAME || 'session';\n  const sessionSecret = process.env.SESSION_SECRET || 'secret';\n\n  const store = new MongoDBSessionStore({\n    uri: mongoUrl,\n    collection: 'sessions'\n  });\n\n  const server = express();\n\n  server.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { maxAge: 60000000 }\n  }));\n\n  server.use(express.static('public'));\n\n  server.get('/api/test', (req, res) => {\n    res.status(200).json({ message: 'Server is running' });\n  });\n\n  server.get('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Server ready on http://localhost:${port}`);\n  });\n});\n```"
  }
]