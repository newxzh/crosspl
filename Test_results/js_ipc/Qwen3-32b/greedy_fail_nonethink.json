[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a class for interacting with the EXMO cryptocurrency exchange API, handling authentication, request signing, and response processing.\n\nClass Description: The Trader class provides methods to authenticate and send signed requests to the EXMO API. It handles nonce generation, request signing using HMAC-SHA512, and response error handling.\n\nAttributes:\n- key: [String] - API key for authentication\n- secret: [String] - API secret for request signing\n- currency: [String] - Base currency for trading pairs\n- asset: [String] - Asset currency for trading pairs\n- pair: [String] - Combined trading pair in format 'asset_currency'\n- name: [String] - Exchange name (fixed as 'EXMO')\n- nonce: [Number] - Counter for API requests to prevent replay attacks\n\nMethods:\n- constructor(config) -> [Void] - Initializes the trader instance with configuration including API keys and currency pairs\n- api_query(method, params, callback) -> [Void] - Makes authenticated POST requests to the EXMO API\n  - method: [String] - API endpoint method\n  - params: [Object] - Request parameters\n  - callback: [Function] - Callback function to handle response (error, data)",
    "Canonical_solution": "const CryptoJS = require(\"crypto-js\");\nconst querystring = require('querystring');\nconst request = require('request');\n\nclass Trader {\n  constructor(config) {\n    this.key = \"\";\n    this.secret = \"\";\n    \n    if(_.isObject(config)) {\n      if(_.isString(config.key)) this.key = config.key;\n      if(_.isString(config.secret)) this.secret = config.secret;\n      this.currency = config.currency;\n      this.asset = config.asset;\n      this.pair = this.asset + '_' + this.currency;\n    };\n\n    this.name = 'EXMO';\n    this.nonce = new Date() * 1000;\n  }\n\n  api_query(method, params, callback) {\n    params.nonce = this.nonce++;\n    var post_data = querystring.stringify(params);\n\n    var options = {\n      url: API_URL + method,\n      headers: {'Key': this.key,'Sign': CryptoJS.HmacSHA512(post_data, this.secret).toString(CryptoJS.enc.hex) },\n      form: params\n    };\n    \n    request.post(options, function (error, response, body) {\n      if (!error && response.statusCode == 200) {\n        data=JSON.parse(body);          \n        if(data.error) error = { message: data.error }\n        else if (data.result!=undefined && data.result==false)  error = { message: '\"result\": false' } ;\n        callback(error, data);\n      } else {\n        console.log('cb request error');\n        console.log(body);\n\n        if(error) {\n          if(includes(error.message, recoverableErrors)) {\n            error.notFatal = true;\n          }\n          console.log(error);\n          callback(error);\n        };\n      };\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst crypto = require('crypto');\n\nclass Trader {\n  constructor(config) {\n    this.key = config.key;\n    this.secret = config.secret;\n    this.currency = config.currency;\n    this.asset = config.asset;\n    this.pair = `${this.asset}_${this.currency}`;\n    this.name = 'EXMO';\n    this.nonce = Date.now();\n  }\n\n  api_query(method, params, callback) {\n    const url = 'https://api.exmo.com/v1.1/';\n    const options = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Key': this.key,\n        'Sign': ''\n      }\n    };\n\n    this.nonce += 1;\n\n    const requestParams = {\n      ...params,\n      nonce: this.nonce\n    };\n\n    const payload = JSON.stringify(requestParams);\n    const sign = crypto.createHmac('sha512', this.secret).update(payload).digest('hex');\n    options.headers.Sign = sign;\n\n    const http = require('https');\n    const req = http.request(url + method, options, (res) => {\n      let data = '';\n      res.on('data', (chunk) => {\n        data += chunk;\n      });\n      res.on('end', () => {\n        try {\n          const result = JSON.parse(data);\n          if (result.error) {\n            callback(result.error, null);\n          } else {\n            callback(null, result);\n          }\n        } catch (e) {\n          callback(e, null);\n        }\n      });\n    });\n\n    req.on('error', (e) => {\n      callback(e, null);\n    });\n\n    req.write(payload);\n    req.end();\n  }\n}\n```"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server with WebSocket support using Express and Socket.IO, implementing a particle simulation system with cluster and client event handling.\n\nFunction Description: The function `startServer` initializes an Express application, sets up static file serving, integrates Socket.IO for real-time communication, and configures a particle simulation system with collision detection and cluster management. It handles particle movement, boundary collisions, and client interactions through defined event handlers.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function starts a server listening on port 3000 but doesn't return any value)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const app = express();\n    const server = require('http').Server(app);\n    const io = require('socket.io')(server);\n    const swip = require('../../../src/server/index.js');\n\n    app.use(express.static(__dirname + './../static'));\n\n    swip(io, {\n        cluster: {\n            events: {\n                update: (cluster) => {\n                    const blobs = cluster.data.blobs;\n                    const clients = cluster.clients;\n\n                    const updatedBlobs = blobs.map((blob) => {\n                        const boundaryOffset = blob.size;\n                        const client = clients.find((c) => isParticleInClient(blob, c));\n\n                        let nextPosX = blob.x + blob.speedX;\n                        let nextPosY = blob.y + blob.speedY;\n                        let nextSpeedX = blob.speedX;\n                        let nextSpeedY = blob.speedY;\n\n                        if (client) {\n                            if (((blob.speedX < 0) &&\n                                ((nextPosX - boundaryOffset) < client.transform.x)\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.left, nextPosY))) {\n                                nextPosX = client.transform.x + boundaryOffset;\n                                nextSpeedX = blob.speedX * -1;\n                            } else if (((blob.speedX > 0) &&\n                                ((nextPosX + boundaryOffset) > (client.transform.x + client.size.width))\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.right, nextPosY))) {\n                                nextPosX = client.transform.x + (client.size.width - boundaryOffset);\n                                nextSpeedX = blob.speedX * -1;\n                            }\n\n                            if (((blob.speedY < 0) &&\n                                ((nextPosY - boundaryOffset) < client.transform.y\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.top, nextPosX)))) {\n                                nextPosY = client.transform.y + boundaryOffset;\n                                nextSpeedY = blob.speedY * -1;\n                            } else if (((blob.speedY > 0) &&\n                                ((nextPosY + boundaryOffset) > (client.transform.y + client.size.height))\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.bottom, nextPosX))\n                            ) {\n                                nextPosY = client.transform.y + (client.size.height - boundaryOffset);\n                                nextSpeedY = blob.speedY * -1;\n                            }\n                        } else {\n                            const firstClient = clients[0];\n                            nextPosX = firstClient.transform.x + (firstClient.size.width / 2);\n                            nextPosY = firstClient.transform.y + (firstClient.size.height / 2);\n                            nextSpeedX = 0;\n                            nextSpeedY = 0;\n                        }\n\n                        blob.x = nextPosX;\n                        blob.y = nextPosY;\n                        blob.speedX = nextSpeedX;\n                        blob.speedY = nextSpeedY;\n\n                        return blob;\n                    });\n\n                    return {\n                        blobs: { $set: updatedBlobs },\n                    };\n                },\n                merge: (cluster1, cluster2, transform) => ({\n                    blobs: { $set: getNewParticleDist(cluster1, cluster2, transform) },\n                    backgroundColor: { $set: cluster1.data.backgroundColor },\n                }),\n            },\n            init: () => ({ blobs: [], backgroundColor: getRandomColor() }),\n        },\n\n        client: {\n            init: () => ({}),\n            events: {\n                addBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $push: blobs } },\n                        },\n                    };\n                },\n                updateBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $set: blobs } },\n                        },\n                    };\n                },\n            },\n        },\n    });\n\n    server.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIO = require('socket.io');\n\nfunction startServer() {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIO(server);\n\n  app.use(express.static(__dirname + '/public'));\n\n  const particles = [];\n\n  class Particle {\n    constructor(id, x, y, vx, vy, radius) {\n      this.id = id;\n      this.x = x;\n      this.y = y;\n      this.vx = vx;\n      this.vy = vy;\n      this.radius = radius;\n    }\n\n    update() {\n      this.x += this.vx;\n      this.y += this.vy;\n\n      if (this.x - this.radius < 0 || this.x + this.radius > 800) {\n        this.vx *= -1;\n      }\n      if (this.y - this.radius < 0 || this.y + this.radius > 600) {\n        this.vy *= -1;\n      }\n    }\n  }\n\n  for (let i = 0; i < 50; i++) {\n    particles.push(\n      new Particle(\n        i,\n        Math.random() * 700 + 50,\n        Math.random() * 500 + 50,\n        (Math.random() - 0.5) * 2,\n        (Math.random() - 0.5) * 2,\n        10\n      )\n    );\n  }\n\n  io.on('connection', (socket) => {\n    console.log('Client connected:', socket.id);\n\n    socket.emit('initParticles', particles);\n\n    socket.on('disconnect', () => {\n      console.log('Client disconnected:', socket.id);\n    });\n\n    socket.on('addParticle', (data) => {\n      const newParticle = new Particle(\n        particles.length,\n        data.x,\n        data.y,\n        (Math.random() - 0.5) * 2,\n        (Math.random() - 0.5) * 2,\n        10\n      );\n      particles.push(newParticle);\n    });\n  });\n\n  setInterval(() => {\n    particles.forEach(particle => particle.update());\n    io.sockets.emit('updateParticles', particles);\n  }, 16);\n\n  server.listen(3000, () => {\n    console.log('Server is running on port 3000');\n  });\n}\n```"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a function that sets up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB, integrates with Next.js for server-side rendering, and sets up basic route handling. It prepares the Next.js application, configures middleware, and starts the server on a specified port.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret for session encryption)\n\nOutput: Returns a Promise that resolves to the configured Express server instance when the Next.js app is prepared and the server is listening on the specified port.",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  return app.prepare().then(async () => {\n    const server = express();\n\n    server.use(express.json());\n\n    const sessionOptions = {\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: mongoSessionStore.create({\n        mongoUrl: MONGO_URL,\n        ttl: 14 * 24 * 60 * 60,\n      }),\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        httpOnly: true,\n        maxAge: 14 * 24 * 60 * 60 * 1000,\n        domain: 'localhost',\n      },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => {\n      const url = URL_MAP[req.path];\n      if (url) {\n        app.render(req, res, url);\n      } else {\n        handle(req, res);\n      }\n    });\n\n    server.listen(port, (err) => {\n      if (err) throw err;\n      console.log(`> Ready on ${ROOT_URL}`);\n    });\n\n    return server;\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```js\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-core')(session.Store);\n\nasync function setupServer() {\n  const dev = process.env.NODE_ENV !== 'production';\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  await app.prepare();\n\n  const server = express();\n\n  const store = new MongoDBStore({\n    url: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  store.on('error', function (e) {\n    console.error('Session store error', e);\n  });\n\n  server.use(\n    session({\n      name: process.env.SESSION_NAME || 'session',\n      secret: process.env.SESSION_SECRET || 'keyboard cat',\n      resave: false,\n      saveUninitialized: false,\n      store: store,\n      cookie: {\n        secure: !dev,\n        maxAge: 1000 * 60 * 60 * 24 * 7, // 7 days\n      },\n    })\n  );\n\n  server.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  return new Promise((resolve) => {\n    server.listen(port, () => {\n      console.log(`> Ready on http://localhost:${port}`);\n      resolve(server);\n    });\n  });\n}\n```"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by:\n1. Maintaining a mapping of known URL shortening services\n2. Using service-specific APIs when available\n3. Falling back to generic HTTP HEAD requests to follow redirects\n4. Preventing infinite loops through depth tracking and URL history\n\nAttributes:\nmap: [Object] - A mapping of URL shortening services to their known domains\ntimeout: [Number] - HTTP request timeout in milliseconds (default: 5000)\n\nMethods:\nconstructor() -> [URLExpander] - Initializes the URL expander with default configuration\n\nexpand: [Function](args: Object, callback: Function) -> [void] - Main method to expand a URL\n- args: Object containing:\n  - url: String - The URL to expand\n  - depth: Number - Current recursion depth (optional)\n  - seen: Object - Map of previously seen URLs (optional)\n- callback: Function to receive the result with expanded args object\n\nAPIs: [Object] - Collection of service-specific expansion methods:\n- isgd: [Function](args: Object, callback: Function) -> [void] - Expands is.gd URLs\n- googl: [Function](args: Object, callback: Function) -> [void] - Expands goo.gl URLs\n- budurl: [Function](args: Object, callback: Function) -> [void] - Expands budurl.com URLs\n- snipurl: [Function](args: Object, callback: Function) -> [void] - Expands snipurl.com and related URLs\n- generic: [Function](args: Object, callback: Function) -> [void] - Generic URL expansion using HTTP HEAD requests",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass URLExpander {\n  constructor() {\n    this.map = {\n      isgd: /https?:\\/\\/(is\\.gd|isd\\.gd|lnkd\\.in)\\/.*/,\n      googl: /https?:\\/\\/goo\\.gl\\/.*/,\n      budurl: /https?:\\/\\/budurl\\.com\\/.*/,\n      snipurl: /https?:\\/\\/(snipurl\\.com|tiny\\.cc|shrinkto\\.me|bitly\\.com)\\/.*/,\n    };\n    this.timeout = 5000;\n  }\n\n  expand(args, callback) {\n    const { url, depth = 0, seen = {} } = args;\n\n    if (depth > 10 || seen[url]) {\n      return callback({ ...args, error: \"Maximum depth reached or cycle detected\" });\n    }\n\n    seen[url] = true;\n\n    for (const [service, regex] of Object.entries(this.map)) {\n      if (regex.test(url)) {\n        return this.APIs[service]({ ...args, seen }, callback);\n      }\n    }\n\n    return this.APIs.generic({ ...args, seen }, callback);\n  }\n\n  APIs = {\n    isgd: (args, callback) => {\n      const { url, depth, seen } = args;\n      const request = new XMLHttpRequest();\n      request.open(\"GET\", `https://is.gd/unshorten?format=json&shorturl=${encodeURIComponent(url)}`, true);\n      request.timeout = this.timeout;\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          try {\n            const response = JSON.parse(request.responseText);\n            const expandedUrl = response.url;\n            callback({ ...args, url: expandedUrl, depth: depth + 1, seen });\n          } catch (e) {\n            callback({ ...args, error: \"Failed to parse ISGD response\" });\n          }\n        }\n      };\n      request.ontimeout = () => callback({ ...args, error: \"Request timeout\" });\n      request.send();\n    },\n\n    googl: (args, callback) => {\n      const { url, depth, seen } = args;\n      const request = new XMLHttpRequest();\n      request.open(\"GET\", `https://www.googleapis.com/urlshortener/v1/url?shortUrl=${encodeURIComponent(url)}&key=YOUR_API_KEY`, true);\n      request.timeout = this.timeout;\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          try {\n            const response = JSON.parse(request.responseText);\n            const expandedUrl = response.longUrl;\n            callback({ ...args, url: expandedUrl, depth: depth + 1, seen });\n          } catch (e) {\n            callback({ ...args, error: \"Failed to parse Google response\" });\n          }\n        }\n      };\n      request.ontimeout = () => callback({ ...args, error: \"Request timeout\" });\n      request.send();\n    },\n\n    budurl: (args, callback) => {\n      const { url, depth, seen } = args;\n      const request = new XMLHttpRequest();\n      request.open(\"GET\", `http://api.budurl.me/expand/${encodeURIComponent(url)}/json`, true);\n      request.timeout = this.timeout;\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          try {\n            const response = JSON.parse(request.responseText);\n            const expandedUrl = response.expand_url;\n            callback({ ...args, url: expandedUrl, depth: depth + 1, seen });\n          } catch (e) {\n            callback({ ...args, error: \"Failed to parse BudURL response\" });\n          }\n        }\n      };\n      request.ontimeout = () => callback({ ...args, error: \"Request timeout\" });\n      request.send();\n    },\n\n    snipurl: (args, callback) => {\n      const { url, depth, seen } = args;\n      const request = new XMLHttpRequest();\n      request.open(\"GET\", `https://api.snipurl.com/expand?url=${encodeURIComponent(url)}`, true);\n      request.setRequestHeader(\"Authorization\", \"Bearer YOUR_API_TOKEN\");\n      request.timeout = this.timeout;\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          try {\n            const response = JSON.parse(request.responseText);\n            const expandedUrl = response.data;\n            callback({ ...args, url: expandedUrl, depth: depth + 1, seen });\n          } catch (e) {\n            callback({ ...args, error: \"Failed to parse SnipURL response\" });\n          }\n        }\n      };\n      request.ontimeout = () => callback({ ...args, error: \"Request timeout\" });\n      request.send();\n    },\n\n    generic: (args, callback) => {\n      const { url, depth, seen } = args;\n      const request = new XMLHttpRequest();\n      request.open(\"HEAD\", url, true);\n      request.timeout = this.timeout;\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          if (request.status >= 300 && request.status < 400 && request.getResponseHeader(\"Location\")) {\n            const redirectedUrl = request.getResponseHeader(\"Location\");\n            this.expand({ url: redirectedUrl, depth: depth + 1, seen }, callback);\n          } else {\n            callback({ ...args, finalUrl: url });\n          }\n        }\n      };\n      request.ontimeout = () => callback({ ...args, error: \"Request timeout\" });\n      request.send();\n    },\n  };\n}\n```"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Create a function to set up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB as the session store. It integrates Next.js for server-side rendering and sets up a catch-all route handler. The server listens on a specified port and connects to MongoDB using environment variables for configuration.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that:\n- Listens on the specified port\n- Outputs the server URL to console when ready\n- Maintains persistent connections to MongoDB for session storage)",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  mongoose.connect(MONGO_URL);\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  const server = express();\n\n  const sessionOptions = {\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    store: mongoSessionStore.create({\n      mongoUrl: MONGO_URL,\n      ttl: 14 * 24 * 60 * 60,\n    }),\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n      httpOnly: true,\n      maxAge: 14 * 24 * 60 * 60 * 1000,\n      domain: 'localhost',\n    },\n  };\n\n  const sessionMiddleware = session(sessionOptions);\n  server.use(sessionMiddleware);\n\n  server.get('*', (req, res) => handle(req, res));\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on ${ROOT_URL}`);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```js\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-native')(session);\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\n\nasync function setupServer() {\n  await app.prepare();\n\n  const server = express();\n  const store = new MongoDBStore({\n    url: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  server.use(\n    session({\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      resave: false,\n      saveUninitialized: false,\n      store,\n      cookie: {\n        secure: !dev,\n        httpOnly: true,\n        maxAge: 1000 * 60 * 60 * 24, // 1 day\n      },\n    })\n  );\n\n  server.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  const PORT = process.env.PORT || 8000;\n  server.listen(PORT, () => {\n    console.log(`> Server is running on http://localhost:${PORT}`);\n  });\n}\n\nsetupServer();\n```"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Twitter Search Client class that handles searching tweets, managing search state, and storing results locally.\n\nClass Description: TSClient is a Twitter search client that performs searches, tracks search state (including pagination and since_id), caches results to local files, and provides synchronization capabilities.\n\nAttributes:\n- search: [Object] - Contains search parameters and state including query (q), since_id, result count (rcount), and a unique search id\n- id: [String] - MD5 hash of the search query used as a unique identifier\n- new_since_id: [String] - Tracks the newest tweet ID retrieved during the current sync\n\nMethods:\n- constructor(query, cb) -> [TSClient] - Initializes a new search client with the given query. Creates a unique ID for the search and loads previous state if available. Calls the callback with the initialized client.\n  - query: [String] - The search query string\n  - cb: [Function] - Callback function that receives the initialized TSClient instance\n\n- syncSearch(callback) -> [void] - Initiates a new synchronization of search results, walking through paginated results.\n  - callback: [Function] - Called with the array of results when sync completes\n\n- set(search) -> [void] - Updates the search state and persists it to disk.\n  - search: [Object] - The search state object to save\n\n- _walker(s) -> [void] - Internal recursive method that handles pagination through search results.\n  - s: [Object] - State object containing:\n    - ts: [TSClient] - Reference to the TSClient instance\n    - search: [Object] - Current search parameters\n    - cb: [Function] - Completion callback\n    - page: [Number] - Current page number\n    - results: [Array] - Accumulated results\n    - new_since_id: [String] - Newest tweet ID in current batch (optional)",
    "Canonical_solution": "var request = require('request');\nvar url = require('url');\n\nclass TSClient {\n    constructor(query, cb) {\n        this.search = {};\n        this.search.q = query;\n        this.search.since_id = 0;\n        this.search.rcount = 0;\n        var hash = crypto.createHash('md5');\n        hash.update(query);\n        this.search.id = hash.digest('hex');\n        var self = this;\n        lfs.readObjectFromFile(self.search.id+'.search', function(data) {\n            if(data && data.id) {\n                self.search = data;            \n            } else {\n                lfs.writeObjectToFile(self.search.id+'.search',self.search);\n            }\n            cb(self);\n        });\n    }\n\n    syncSearch(callback) {\n        console.log(\"new sync \"+JSON.stringify(this.search));\n        this._walker({ts:this, search:this.search, cb:callback, page:1, results:[]});\n    }\n\n    set(search) {\n        this.search = search;\n        lfs.writeObjectToFile(search.id+'.search',search);    \n    }\n\n    _walker(s) {\n        var uri = url.parse(\"http://search.twitter.com/search.json\");\n        uri.query = {q:s.search.q, rpp:100, page:s.page, since_id:s.search.since_id};\n        console.log(\"walking page \"+url.format(uri));\n        request.get({uri:url.format(uri)}, function(err, resp, body) {\n            if(err) {\n                console.log(\"request failed: \"+err);\n                s.cb([]);\n                return;\n            }\n            var data = JSON.parse(body);\n            if(data && data.results && data.results.length > 0) {\n                s.results = s.results.concat(data.results);\n                s.page++;\n                console.log(\"page \"+data.page+\" and max \"+data.max_id_str);\n                if(data.page == 1) s.new_since_id = data.max_id_str;\n            } else {\n                s.page=16;\n            }\n            if(s.page <= 15) {\n                this._walker(s);\n            } else {\n                console.log(\"saving \"+s.results.length+\" tweets\");\n                lfs.writeObjectsToFile(s.search.id+'.tweets',s.results);\n                s.search.rcount += s.results.length;\n                if(s.new_since_id) s.search.since_id = s.new_since_id;\n                s.ts.set(s.search);\n                s.cb(s.results);\n            }\n        }.bind(this));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst path = require('path');\n\nclass TSClient {\n  constructor(query, cb) {\n    this.id = crypto.createHash('md5').update(query).digest('hex');\n    this.search = { q: query, rcount: 100 };\n    this.new_since_id = null;\n    const statePath = this._getStateFilePath();\n\n    if (fs.existsSync(statePath)) {\n      try {\n        const state = JSON.parse(fs.readFileSync(statePath, 'utf8'));\n        this.search = { ...this.search, ...state.search };\n        this.new_since_id = state.new_since_id;\n      } catch (e) {\n        console.error('Error loading state:', e);\n      }\n    }\n\n    cb(this);\n  }\n\n  syncSearch(callback) {\n    const s = {\n      ts: this,\n      search: this.search,\n      cb: callback,\n      page: 1,\n      results: [],\n    };\n\n    this._walker(s);\n  }\n\n  set(search) {\n    this.search = { ...this.search, ...search };\n    this._saveState();\n  }\n\n  _walker(s) {\n    // Simulate Twitter API call\n    setTimeout(() => {\n      const tweets = Array.from({ length: Math.min(20, s.search.rcount) }, (_, i) => ({\n        id_str: (Date.now() + i).toString(),\n        text: `Tweet ${i} for \"${s.search.q}\"`,\n      }));\n\n      if (tweets.length > 0) {\n        s.results.push(...tweets);\n        s.new_since_id = tweets[0].id_str;\n\n        if (s.results.length < s.search.rcount) {\n          s.page++;\n          this._walker(s);\n        } else {\n          s.cb(s.results);\n        }\n      } else {\n        s.cb(s.results);\n      }\n    }, 100);\n  }\n\n  _getStateFilePath() {\n    return path.join(__dirname, `tsclient_state_${this.id}.json`);\n  }\n\n  _saveState() {\n    const state = {\n      search: this.search,\n      new_since_id: this.new_since_id,\n    };\n\n    fs.writeFileSync(this._getStateFilePath(), JSON.stringify(state), 'utf8');\n  }\n}\n```"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a function that sets up and starts an Express server with basic configuration, static file serving, and additional route handlers.\n\nFunction Description: The function `createExpressServer` initializes an Express application, configures it to serve static files from a parent directory, integrates additional route handlers from a separate module, and starts listening on a specified port (either from environment variables or defaulting to 3000).\n\nInput: None (The function takes no parameters but uses environment variables for configuration)\n\nOutput: Returns the HTTP server instance created by `app.listen()`, which is actively listening on the specified port. The function also logs server start information to the console.",
    "Canonical_solution": "function createExpressServer() {\n    const express = require('express');\n    const app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.static('../'));\n\n    require('./src-server/multerImpl')(app);\n\n    return app.listen(app.get('port'), () => {\n        console.log('Express server listening on port ' + app.get('port'));\n        console.log('Visit http://localhost:' + app.get('port') + '/example/ to check out the upload example');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst path = require('path');\nconst routes = require('./routes');\n\nfunction createExpressServer() {\n  const app = express();\n  const port = process.env.PORT || 3000;\n\n  app.use(express.static(path.join(__dirname, '..')));\n  app.use('/', routes);\n\n  const server = app.listen(port, () => {\n    console.log(`Server is running on http://localhost:${port}`);\n  });\n\n  return server;\n}\n\nmodule.exports = createExpressServer;\n```"
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to record incoming connections and handle file uploads, using Node.js's `fs` and `http` modules. The server should log connection details and save request data to files.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming connections. It handles requests by piping the socket data to a file stream and provides a simple HTML form for file uploads. Each connection is assigned a unique filename for logging purposes.\n\nInput: None (The function does not take any input parameters)\n\nOutput: None (The function does not return any value but creates a running HTTP server that logs to the console and writes to files)",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```js\nconst http = require('http');\nconst fs = require('fs');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const filename = `connection-${Date.now()}.log`;\n    console.log(`New connection: ${req.method} ${req.url}`);\n\n    const logStream = fs.createWriteStream(filename);\n    req.on('data', (chunk) => {\n      logStream.write(chunk);\n    });\n\n    req.on('end', () => {\n      logStream.end();\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(`\n        <html>\n          <body>\n            <h1>File uploaded successfully</h1>\n            <form method=\"post\" enctype=\"multipart/form-data\">\n              <input type=\"file\" name=\"file\" />\n              <input type=\"submit\" value=\"Upload\" />\n            </form>\n          </body>\n        </html>\n      `);\n    });\n\n    req.on('error', (err) => {\n      console.error('Request error:', err);\n      res.statusCode = 400;\n      res.end();\n    });\n  });\n\n  server.listen(3000, () => {\n    console.log('Server running on port 3000');\n  });\n}\n```"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that makes an HTTP POST request to a specified URL with custom headers and data, then handles the response.\n\nFunction Description: The function `makeHttpRequest` sends an HTTP POST request to a given URL with specified headers and a data payload. It uses the `request` module to perform the HTTP request and includes a callback function to handle the response or errors. The function is designed to be reusable for making HTTP POST requests with minimal configuration.\n\nInput: \n- None (The URL, headers, and data are hardcoded within the function for simplicity. In a real-world scenario, these could be passed as parameters.)\n\nOutput: \n- None (The function logs the response body to the console if the request is successful. In a real-world scenario, the response could be returned or processed further.)\n\nNote: The function assumes the `request` module is available in the environment. If not, it must be installed via npm or another package manager.",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    };\n\n    var dataString = '18233982904';\n\n    var options = {\n        url: 'http://localhost:28139/CurlToNode',\n        method: 'POST',\n        headers: headers,\n        body: dataString\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n    const url = 'https://example.com/api/endpoint';\n    const headers = {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n    };\n    const data = {\n        key1: 'value1',\n        key2: 'value2'\n    };\n\n    request.post(\n        {\n            url: url,\n            headers: headers,\n            json: data\n        },\n        function (error, response, body) {\n            if (error) {\n                return console.error('Error:', error);\n            }\n            if (response.statusCode !== 200) {\n                return console.error('Status Code:', response.statusCode);\n            }\n            console.log('Response Body:', body);\n        }\n    );\n}\n```"
  },
  {
    "Task_id": 131,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transform the incoming data to uppercase, and send it back as the response.\n\nFunction Description: The function `createPipeServer` creates an HTTP server that listens on a specified port. It handles incoming POST requests by piping the request data through a transformation stream that converts the data to uppercase, and then pipes the transformed data back to the response. Non-POST requests are responded to with a message indicating that a POST request is required.\n\nInput:  \n- `port` (Number): The port number on which the HTTP server should listen.\n\nOutput:  \n- None (The function sets up the server but does not return any value).",
    "Canonical_solution": "const http = require('http');\nconst map = require('through2-map');\n\nfunction createPipeServer(port) {\n    const server = http.createServer(function (req, res) {\n        if (req.method !== 'POST') {\n            return res.end('send me a POST\\n');\n        }\n        req.pipe(map(function (chunk) {\n            return chunk.toString().toUpperCase();\n        })).pipe(res);\n    });\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\n\nfunction createPipeServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('POST request required');\n      return;\n    }\n\n    req.setEncoding('utf8');\n    let data = '';\n\n    req.on('data', chunk => {\n      data += chunk;\n    });\n\n    req.on('end', () => {\n      const upperData = data.toUpperCase();\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end(upperData);\n    });\n  });\n\n  server.listen(port);\n}\n```"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to record incoming connections and requests, piping the request data to individual files for each connection.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming connections. For each connection, it creates a unique file to store the raw HTTP request data. The server handles regular requests by responding with connection information and provides an HTML upload form for the root path. The server tracks active connections and logs connection/disconnection events.\n\nInput: None (The function takes no parameters but uses environment variable `PORT` for configuration)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server that writes to files)\n\nNote: The function maintains internal state including:\n- A connection counter\n- An active HTTP server instance\n- File streams for each connection\n- Logging of connection events to console",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nlet connectionCount = 0;\nlet activeConnections = new Set();\nlet server;\n\nfunction createServer() {\n    const port = process.env.PORT || 3000;\n\n    server = http.createServer((req, res) => {\n        if (req.url === '/') {\n            res.writeHead(200, { 'Content-Type': 'text/html' });\n            res.end(`\n                <h1>Upload File</h1>\n                <form method=\"post\" enctype=\"multipart/form-data\">\n                    <input type=\"file\" name=\"file\" />\n                    <button type=\"submit\">Upload</button>\n                </form>\n            `);\n        } else {\n            res.writeHead(200, { 'Content-Type': 'text/plain' });\n            res.end(`Connection ID: ${connectionId}\\n`);\n        }\n    });\n\n    server.on('connection', (socket) => {\n        const connectionId = ++connectionCount;\n        activeConnections.add(connectionId);\n\n        console.log(`Connection established. Connection ID: ${connectionId}`);\n\n        const logFilePath = path.join(__dirname, `request_${connectionId}.log`);\n        const writeStream = fs.createWriteStream(logFilePath);\n\n        socket.on('data', (data) => {\n            writeStream.write(data);\n        });\n\n        socket.on('end', () => {\n            writeStream.end();\n            console.log(`Connection closed. Connection ID: ${connectionId}`);\n            activeConnections.delete(connectionId);\n        });\n\n        socket.on('error', (err) => {\n            console.error(`Error on connection ${connectionId}:`, err);\n            writeStream.end();\n            activeConnections.delete(connectionId);\n        });\n    });\n\n    server.listen(port, () => {\n        console.log(`Server running at http://localhost:${port}/`);\n    });\n}\n\ncreateServer();\n```"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files, using Node.js's built-in `http` and `fs` modules. The server should handle different MIME types and pipe file contents to the response stream.\n\nFunction Description: The `createServer` function initializes an HTTP server that listens on port 5000. It serves static files from the local file system, automatically determining the appropriate MIME type based on the file extension. If a requested file doesn't exist, it logs a warning. The function uses streaming to efficiently pipe file contents to the HTTP response.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server)",
    "Canonical_solution": "function createServer() {\n  var http = require('http'), fs = require('fs'), mimeTypes = {\n    'html': 'text/html',\n    'css': 'text/css',\n    'js': 'text/javascript',\n    'json': 'application/json',\n    'png': 'image/png',\n    'jpg': 'image/jpg'\n  };\n\n  http.createServer(function (req, res) {\n    var file = (req.url === '/') ? 'index.html' : \".\" + req.url;\n    var ext = require('path').extname(file),\n      type = (mimeTypes[ext] ? mimeTypes[ext] : '');\n\n    fs.exists(file, function (exists) {\n      if (exists) {\n        res.writeHead(200, {'Content-Type': type});\n        fs.createReadStream(file).pipe(res);\n      } else {\n        console.warn(file, ' does not exit');\n      }\n    });\n  }).listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    let filePath = path.join(__dirname, req.url === '/' ? 'index.html' : req.url);\n    let extname = path.extname(filePath);\n    let contentType = 'text/html';\n\n    switch (extname) {\n      case '.js':\n        contentType = 'text/javascript';\n        break;\n      case '.css':\n        contentType = 'text/css';\n        break;\n      case '.json':\n        contentType = 'application/json';\n        break;\n      case '.png':\n        contentType = 'image/png';\n        break;\n      case '.jpg':\n      case '.jpeg':\n        contentType = 'image/jpeg';\n        break;\n      case '.gif':\n        contentType = 'image/gif';\n        break;\n    }\n\n    fs.readFile(filePath, (err, content) => {\n      if (err) {\n        console.warn(`File not found: ${filePath}`);\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n        return;\n      }\n\n      res.writeHead(200, { 'Content-Type': contentType });\n      res.end(content);\n    });\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n}\n```"
  },
  {
    "Task_id": 141,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transform the incoming data to uppercase, and send it back as the response.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for POST requests on a specified port. When a POST request is received, it pipes the request data through a transformation stream that converts the data to uppercase, then pipes the transformed data back to the response. For non-POST requests, it simply ends the response.\n\nInput:  \n- `port` (Number) - The port number on which the HTTP server should listen.\n\nOutput:  \n- None (The function sets up the server but does not return any value).",
    "Canonical_solution": "const http = require('http');\nconst through = require('through2');\n\nfunction createServer(port) {\n  const server = http.createServer(function (req, res) {\n    if (req.method === 'POST') {\n      req.pipe(through(function (buf, _, next) {\n        this.push(buf.toString().toUpperCase());\n        next();\n      })).pipe(res);\n    } else res.end();\n  });\n  server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      let data = '';\n      req.setEncoding('utf8');\n      req.on('data', chunk => {\n        data += chunk;\n      });\n      req.on('end', () => {\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end(data.toUpperCase());\n      });\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}\n```"
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve a ReDoc documentation interface, including handling requests for the ReDoc JavaScript file and rendering the documentation page with the provided specification.\n\nFunction Description: The function creates an HTTP server that serves two main routes: (1) '/redoc.standalone.js' which streams the ReDoc JavaScript file to the client, and (2) '/' which renders a complete HTML page with the ReDoc interface hydrated with the provided OpenAPI specification. The server handles other routes with a 404 response.\n\nInput:\n- port: [number] - The port number on which the HTTP server should listen\n- filePath: [string] - The file path to the 'redoc.standalone.js' file to be served\n- specPath: [string] - The file path to the OpenAPI specification file (YAML format)\n\nOutput: None (The function starts an HTTP server that continues running until manually stopped)\n\nNote: The function assumes the availability of certain external dependencies (yaml, fs, http, React, ServerStyleSheet, Redoc) which should be imported/required in the actual implementation. The function also uses async/await for handling asynchronous operations related to the Redoc store creation.",
    "Canonical_solution": "const http = require('http');\nconst fs = require('fs');\n\nfunction createServer(port, filePath, specPath) {\n    const server = http.createServer(async (request, response) => {\n        if (request.url === '/redoc.standalone.js') {\n            fs.createReadStream(filePath, 'utf8').pipe(response);\n        } else if (request.url === '/') {\n            const spec = yaml.load(readFileSync(resolve(__dirname, specPath), 'utf-8'));\n            const store = await createStore(spec, 'path/to/spec.yaml');\n\n            const sheet = new ServerStyleSheet();\n            const html = renderToString(sheet.collectStyles(React.createElement(Redoc, { store })));\n            const css = sheet.getStyleTags();\n\n            const res = `<html>\n            <head>\n                <meta charset=\"utf8\" />\n                <title>ReDoc</title>\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n                <style>\n                    body {\n                        padding: 0;\n                        margin: 0;\n                    }\n                </style>\n                <script src=\"redoc.standalone.js\"></script>\n                <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n                ${css}\n            </head>\n            <body>\n            <script>\n                document.addEventListener('DOMContentLoaded', function() {\n                    const state = ${JSON.stringify(await store.toJS())};\n                    Redoc.hydrate(state, document.getElementById('redoc'));\n                });\n                </script>\n                <div id=\"redoc\">${html}</div>\n            </body>\n            </html>`;\n            response.writeHead(200, { 'Content-Length': res.length });\n            response.write(res);\n            response.end();\n        } else {\n            response.writeHead(404);\n            response.write('Not found');\n            response.end();\n        }\n    });\n\n    server.listen(port, () => console.log(`Server started: http://127.0.0.1:${port}`));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs').promises;\nconst yaml = require('yaml');\nconst React = require('react');\nconst { renderToStaticMarkup } = require('react-dom/server');\nconst { ServerStyleSheet } = require('styled-components');\nconst Redoc = require('redoc');\n\nasync function startServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      try {\n        const data = await fs.readFile(filePath);\n        res.writeHead(200, { 'Content-Type': 'application/javascript' });\n        res.end(data);\n      } catch (err) {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Internal Server Error');\n      }\n      return;\n    }\n\n    if (req.url === '/') {\n      try {\n        const specData = await fs.readFile(specPath, 'utf-8');\n        const spec = yaml.parse(specData);\n\n        const sheet = new ServerStyleSheet();\n        const App = () => <Redoc spec={spec} />;\n        const html = renderToStaticMarkup(sheet.collectStyles(<App />));\n        const styleTags = sheet.getStyleTags();\n\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.write(`<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>ReDoc</title>\n  ${styleTags}\n</head>\n<body>\n  <div id=\"root\">${html}</div>\n  <script src=\"/redoc.standalone.js\"></script>\n</body>\n</html>`);\n        res.end();\n      } catch (err) {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Internal Server Error');\n      }\n      return;\n    }\n\n    res.writeHead(404, { 'Content-Type': 'text/plain' });\n    res.end('Not Found');\n  });\n\n  server.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n```"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files and handle dynamic JavaScript file concatenation, with support for piping binary files.\n\nFunction Description: The `createServer` function initializes an HTTP server that serves static files from specified directories, handles dynamic concatenation of JavaScript files, and pipes binary files directly to the response. It supports virtual paths, content type detection, and redirection.\n\nInput: \n- Optional command line argument [string] - The port number to listen on (defaults to 90 if not provided)\n\nOutput: \n- None (directly creates and starts an HTTP server)\n- Console output indicating server startup and loaded files\n\nAttributes: (N/A - This is a function, not a class)\n\nMethods: (N/A - This is a function, not a class)\n\nAdditional Implementation Details:\n1. Reads and caches static files from '../src' and '../dist' directories at startup\n2. Handles binary files separately from text files\n3. Supports special handling for core JavaScript files and plugins\n4. Implements virtual path redirection\n5. Uses file extension to determine content type\n6. Provides fallback behavior for undefined routes\n7. Listens on localhost (127.0.0.1) only\n8. Outputs loaded file list to console at startup",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require(\"fs\");\n    var url = require(\"url\");\n\n    var BASE_URL=\"http://www.servicestack.net\", \n        VIRTUAL_PATH=\"/jqbuilder\"; \n\n    var getExt = function(path) {\n        return path.substring(path.lastIndexOf('.')+1);\n    };\n    String.prototype.startsWith = function (str){\n        return this.indexOf(str) === 0;\n    };\n\n    var contentTypes = { \"htm\": \"text/html\", \"js\": \"text/javascript\", \"gif\": \"image/gif\" };\n\n    var srcDir = '../src', targetDir = '../dist';\n    var webFiles = fs.readdirSync(targetDir);\n    var staticFiles = {}, binaryFiles = {};\n    fs.readdirSync(srcDir).forEach(function(file) { \n        var filePath = srcDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(targetDir).forEach(function(file) { \n        var filePath = targetDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(\"./\").forEach(function(file) {\n        var isText = (contentTypes[getExt(file)]||\"\").startsWith(\"text\");\n        if (isText)\n            staticFiles[\"/\" + file] = fs.readFileSync(file).toString('utf-8');\n        else \n            binaryFiles[\"/\" + file] = file;\n    });\n\n    staticFiles[\"/\"] = staticFiles[\"/default.htm\"];\n\n    console.log(\"loaded: \", Object.keys(staticFiles));\n\n    var isCore = { \"/jquip.js\": true, \"/jquip.min.js\": true };\n\n    var port = process.argv[2] || 90;\n\n    http.createServer(function (req, res) {\n        var reqUrl = url.parse(req.url), path = reqUrl.pathname.replace(VIRTUAL_PATH,'');\n        if (reqUrl.pathname == VIRTUAL_PATH){\n            res.writeHead(302,BASE_URL+VIRTUAL_PATH+\"/\");\n            res.end();\n            return;\n        }\n\n        var fileContents = staticFiles[path];\n\n        if (fileContents) {\n            var ext = path == \"/\" ? \"htm\" : getExt(path);\n            var contentType = contentTypes[ext];\n            res.writeHead(200, {'Content-Type': contentType });\n            var isPlugin = ext == \"js\" && path.startsWith(\"/jquip.\") && !isCore[path];\n            if (isPlugin) {\n                var coreJs = path.indexOf(\"min\") != -1 \n                    ? staticFiles[\"/jquip.min.js\"]\n                    : staticFiles[\"/jquip.js\"];\n                fileContents = coreJs + \";\" + fileContents;\n            }\n\n            res.end(fileContents);\n        }\n        else if (binaryFiles[path]) { \n            var filePath = binaryFiles[path]; \n            fs.createReadStream(filePath, {\n              'bufferSize': 4 * 1024\n            }).pipe(res);\n        }\n        else\n        {\n            var isDynamic = path.startsWith(\"/jquip.\");\n            if (isDynamic) {\n                var parts = path.substring(1).split('.');\n                var isMin = parts.indexOf(\"min\") >= 0;\n                var js = isMin ? staticFiles[\"/jquip.min.js\"] : staticFiles[\"/jquip.js\"];\t\t\t\n                parts.forEach(function(part){\n                    if (part == \"jquip\" || part == \"min\" || part == \"js\") return;\n                    var path = \"/jquip.\" + part + (isMin ? \".min.js\" : \".js\");\n                    var jsFile = staticFiles[path];\n                    if (jsFile)\n                        js += \";\" + jsFile;\n                });\n                res.writeHead(200, {'Content-Type': 'text/javascript' });\n                res.end(js);\t\t\n                return;\n            }\n\n            res.writeHead(200, {'Content-Type': 'text/plain'});\n            var sb = \"\";\n            for (var i in reqUrl) {\n                if (sb) sb += \"\\n\";\n                sb += i + \": \" + reqUrl[i];\n            }\n            res.end(\"Path not found:\\n\" + sb);\n        }\n    })\n    .listen(port, \"127.0.0.1\");\n    console.log('Server running at http://127.0.0.1:'+port+'/');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst PORT = process.argv[2] ? parseInt(process.argv[2]) : 90;\nconst STATIC_DIRS = [path.resolve(__dirname, '../src'), path.resolve(__dirname, '../dist')];\nconst BINARY_TYPES = ['image/jpeg', 'image/png', 'application/octet-stream'];\nconst JS_MIME_TYPE = 'application/javascript';\nconst HTML_MIME_TYPE = 'text/html';\nconst CSS_MIME_TYPE = 'text/css';\n\nlet fileCache = {};\nlet binaryFiles = {};\n\nfunction getContentType(filePath) {\n  const ext = path.extname(filePath).toLowerCase();\n  switch (ext) {\n    case '.js': return JS_MIME_TYPE;\n    case '.html': return HTML_MIME_TYPE;\n    case '.css': return CSS_MIME_TYPE;\n    case '.jpg':\n    case '.jpeg': return 'image/jpeg';\n    case '.png': return 'image/png';\n    default: return 'application/octet-stream';\n  }\n}\n\nfunction isBinary(filePath) {\n  return BINARY_TYPES.includes(getContentType(filePath));\n}\n\nfunction loadStaticFiles() {\n  console.log('Loading static files from:', STATIC_DIRS);\n  for (const dir of STATIC_DIRS) {\n    if (!fs.existsSync(dir)) continue;\n    const files = fs.readdirSync(dir);\n    for (const file of files) {\n      const filePath = path.join(dir, file);\n      const virtualPath = '/' + file;\n      const stat = fs.statSync(filePath);\n      if (stat.isDirectory()) continue;\n      if (isBinary(filePath)) {\n        binaryFiles[virtualPath] = filePath;\n      } else {\n        const content = fs.readFileSync(filePath, 'utf8');\n        fileCache[virtualPath] = content;\n        console.log(`Loaded: ${virtualPath}`);\n      }\n    }\n  }\n}\n\nfunction handleConcatenation(req, res, paths) {\n  let result = '';\n  let completed = 0;\n\n  function finishResponse() {\n    res.writeHead(200, { 'Content-Type': JS_MIME_TYPE });\n    res.end(result);\n  }\n\n  if (paths.length === 0) {\n    finishResponse();\n    return;\n  }\n\n  paths.forEach((p) => {\n    if (fileCache[p]) {\n      result += fileCache[p] + '\\n';\n      completed++;\n      if (completed === paths.length) finishResponse();\n    } else {\n      res.writeHead(404, { 'Content-Type': HTML_MIME_TYPE });\n      res.end('<h1>404 - File not found</h1>');\n    }\n  });\n}\n\nfunction requestHandler(req, res) {\n  const url = req.url;\n\n  if (url.startsWith('/concat/')) {\n    const parts = url.split('?')[0].slice(8).split(',');\n    handleConcatenation(req, res, parts);\n    return;\n  }\n\n  if (binaryFiles[url]) {\n    const filePath = binaryFiles[url];\n    const stream = fs.createReadStream(filePath);\n    const contentType = getContentType(filePath);\n    res.writeHead(200, { 'Content-Type': contentType });\n    stream.pipe(res);\n    return;\n  }\n\n  if (fileCache[url]) {\n    res.writeHead(200, { 'Content-Type': getContentType(url) });\n    res.end(fileCache[url]);\n    return;\n  }\n\n  if (url === '/favicon.ico') {\n    res.writeHead(200, { 'Content-Type': 'image/x-icon' });\n    res.end('');\n    return;\n  }\n\n  res.writeHead(404, { 'Content-Type': HTML_MIME_TYPE });\n  res.end('<h1>404 - Not Found</h1>');\n}\n\nfunction createServer() {\n  loadStaticFiles();\n  const server = http.createServer(requestHandler);\n  server.listen(PORT, '127.0.0.1', () => {\n    console.log(`Server running at http://127.0.0.1:${PORT}/`);\n    console.log('Loaded files:');\n    Object.keys(fileCache).forEach((key) => console.log(key));\n  });\n}\n\ncreateServer();\n```"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement an OAuth server class that handles GitHub OAuth authentication flow, including starting a server to receive the authorization code and exchanging it for an access token.\n\nClass Description: The OAuthServer class represents a server that facilitates GitHub OAuth authentication. It creates an Express server to handle the OAuth callback, exchanges the authorization code for an access token using GitHub's API, and provides methods to start and stop the server.\n\nAttributes:\n- options: [Object] - Configuration object containing client credentials and server settings\n- prompt: [Object] - Reference to an external prompt object used to signal completion of authentication\n- app: [Object] - Express application instance for handling HTTP requests\n- server: [Object] - HTTP server instance created by Express\n- token: [String|null] - Stores the obtained OAuth access token\n\nMethods:\n- constructor(options) -> [OAuthServer] - Initializes the OAuth server with configuration options and sets up the Express route for handling OAuth callbacks\n- start() -> [Promise] - Starts the HTTP server on the configured port and returns a promise that resolves when the server is ready or rejects on error\n- stop() -> [void] - Stops the HTTP server and cleans up resources",
    "Canonical_solution": "const express = require('express');\nconst axios = require('axios');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = this.options.prompt;\n    this.app = express();\n    this.app.get('/', (req, res) => {\n      const code = req.query.code;\n      axios\n        .post(\n          `https://github.com/login/oauth/access_token?client_secret=${\n            this.options.client_secret\n          }&client_id=${this.options.client_id}&code=${code}`,\n          {},\n          {\n            headers: {\n              Accept: 'application/json'\n            }\n          }\n        )\n        .then(response => {\n          const accessToken = response.data.access_token;\n          this.token = accessToken;\n          res.send('Enquirer: Github OAuth Server is up');\n          this.prompt.submit();\n        })\n        .catch(e => console.log('axios error', e));\n    });\n    this.token = null;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.options.port, err => {\n        if (err) {\n          return reject(err);\n        }\n        resolve();\n      });\n    });\n  }\n\n  stop() {\n    this.server.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst express = require('express');\nconst http = require('http');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = options.prompt;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n\n    this.app.get('/callback', async (req, res) => {\n      const { code } = req.query;\n      try {\n        const response = await fetch('https://github.com/login/oauth/access_token', {\n          method: 'POST',\n          headers: {\n            Accept: 'application/json',\n          },\n          body: new URLSearchParams({\n            client_id: this.options.clientId,\n            client_secret: this.options.clientSecret,\n            code,\n            redirect_uri: `http://localhost:${this.options.port}/callback`,\n          }),\n        });\n        const data = await response.json();\n        this.token = data.access_token;\n        this.prompt.setPrompt(`Authentication successful. Access token: ${this.token}`);\n        res.send('Authentication successful. You can close this window.');\n      } catch (error) {\n        this.prompt.setPrompt(`Authentication failed: ${error.message}`);\n        res.status(500).send('Authentication failed.');\n      }\n    });\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.options.port, () => {\n        resolve();\n      });\n\n      this.server.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close();\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files from a specified directory, handling different MIME types and responding with 404 errors for non-existent files.\n\nFunction Description: The function `createFileServer` initializes an HTTP server that serves static files (HTML, images, JavaScript, CSS) from a 'static' directory in the current working directory. It handles proper MIME types for different file extensions and responds with 404 errors when files are not found. The server listens on port 1338 by default.\n\nInput: None (The function takes no parameters; all configuration is internal)\n\nOutput: None (The function doesn't return anything; it creates and starts an HTTP server that continues running)",
    "Canonical_solution": "function createFileServer() {\n    var http = require('http'),\n        url = require('url'),\n        path = require('path'),\n        fs = require('fs'),\n        port = 1338;\n    var mimeTypes = {\n        \"html\": \"text/html\",\n        \"jpeg\": \"image/jpeg\",\n        \"jpg\": \"image/jpeg\",\n        \"png\": \"image/png\",\n        \"js\": \"text/javascript\",\n        \"css\": \"text/css\"};\n\n    http.createServer(function(req, res) {\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(process.cwd(),'static', uri);\n        fs.exists(filename, function(exists) {\n            if(!exists) {\n                console.error(\"not exists: \" + filename);\n                res.writeHead(404, {'Content-Type': 'text/plain'});\n                res.write('404 Not Found\\n');\n                res.end();\n                return;\n            }\n            var mimeType = mimeTypes[path.extname(filename).split(\".\")[1]];\n            res.writeHead(200, {'Content-Type':mimeType});\n\n            var fileStream = fs.createReadStream(filename);\n            fileStream.pipe(res);\n        });\n    }).listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createFileServer() {\n  const server = http.createServer((req, res) => {\n    let filePath = path.join(__dirname, 'static', req.url === '/' ? 'index.html' : req.url);\n    let extname = path.extname(filePath);\n    let contentType = 'text/html';\n\n    switch (extname) {\n      case '.js':\n        contentType = 'text/javascript';\n        break;\n      case '.css':\n        contentType = 'text/css';\n        break;\n      case '.json':\n        contentType = 'application/json';\n        break;\n      case '.png':\n        contentType = 'image/png';\n        break;\n      case '.jpg':\n      case '.jpeg':\n        contentType = 'image/jpeg';\n        break;\n      case '.gif':\n        contentType = 'image/gif';\n        break;\n    }\n\n    fs.readFile(filePath, (err, content) => {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          res.writeHead(404, { 'Content-Type': 'text/html' });\n          res.end('<h1>404 Not Found</h1>');\n        } else {\n          res.writeHead(500);\n          res.end(`Server Error: ${err.code}`);\n        }\n      } else {\n        res.writeHead(200, { 'Content-Type': contentType });\n        res.end(content, 'utf-8');\n      }\n    });\n  });\n\n  server.listen(1338, () => {\n    console.log('Server running at http://localhost:1338/');\n  });\n}\n```"
  },
  {
    "Task_id": 154,
    "Instruction": "Task Description: Create a TCP server class in JavaScript that can handle both regular and TLS-encrypted connections, manage client connections, and provide methods to start and destroy the server.\n\nClass Description: The MockServer class is a TCP server implementation that can be configured to use either regular TCP or TLS encryption. It manages server lifecycle, client connections, and provides methods to start and stop the server gracefully.\n\nAttributes:\n- host: [String] - The host address the server binds to\n- port: [Number] - The port number the server listens on\n- family: [String] - The IP address family (e.g., 'ipv4')\n- server: [Object] - The underlying TCP/TLS server instance\n- tlsEnabled: [Boolean] - Flag indicating if TLS is enabled\n- state: [String] - Current server state ('stopped', 'running', or 'destroyed')\n- connections: [Number] - Count of active client connections\n- sockets: [Array] - Array of active client sockets\n\nMethods:\n- constructor(port, host, options) -> [void] - Initializes the server with specified port, host, and options (including TLS configuration)\n- start() -> [Promise] - Starts the server and returns a promise that resolves when listening\n- destroy() -> [Promise] - Gracefully shuts down the server and returns a promise that resolves when complete",
    "Canonical_solution": "const net = require('net');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    // Save the settings\n    this.host = host;\n    this.port = port;\n    this.family = 'ipv4';\n\n    // Create a server socket\n    this.server = options.tls ? tls.createServer(options) : net.createServer(options);\n    this.tlsEnabled = !!options.tls;\n\n    // state\n    this.state = 'stopped';\n\n    // Number of connections\n    this.connections = 0;\n\n    // sockets\n    this.sockets = [];\n  }\n\n  /**\n   * Start the TCP server\n   */\n  start() {\n    const self = this;\n    return new Promise((resolve, reject) => {\n      self.server.on('error', err => {\n        reject(err);\n      });\n\n      const connectionEventName = self.tlsEnabled ? 'secureConnection' : 'connection';\n      self.server.on(connectionEventName, c => {\n        self.connections = self.connections + 1;\n        self.sockets.push(c);\n\n        c.on('error', e => {\n          console.warn('connection error: ', e);\n        });\n\n        c.on('close', () => {\n          self.connections = self.connections - 1;\n          const index = self.sockets.indexOf(c);\n          if (index !== -1) {\n            self.sockets.splice(index, 1);\n          }\n        });\n      });\n\n      self.server.listen(self.port, self.host, () => {\n        // update address information if necessary\n        self.host = self.server.address().address;\n        self.port = self.server.address().port;\n        self.family = self.server.address().family;\n\n        resolve(self);\n      });\n\n      self.state = 'running';\n    });\n  }\n\n  /**\n   * Destroy the TCP server\n   */\n  destroy() {\n    const self = this;\n    if (self.state === 'destroyed') {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      self.sockets.forEach(socket => socket.destroy());\n      self.server.close(err => {\n        if (err) return reject(err);\n        self.state = 'destroyed';\n        resolve();\n      });\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nclass MockServer {\n  constructor(port, host, options = {}) {\n    this.host = host || '127.0.0.1';\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.tlsEnabled = Boolean(options.tls);\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n\n    if (this.tlsEnabled) {\n      const tls = require('tls');\n      this.server = tls.createServer(options.tls);\n    } else {\n      const net = require('net');\n      this.server = new net.Server();\n    }\n\n    this.server.on('connection', (socket) => {\n      this.connections++;\n      this.sockets.push(socket);\n\n      socket.on('close', () => {\n        this.connections--;\n        this.sockets = this.sockets.filter(s => s !== socket);\n      });\n    });\n\n    this.server.on('error', (err) => {\n      this.state = 'stopped';\n      throw err;\n    });\n  }\n\n  async start() {\n    return new Promise((resolve, reject) => {\n      if (this.state !== 'stopped') {\n        reject(new Error('Server is not in a stopped state.'));\n        return;\n      }\n\n      this.state = 'running';\n\n      this.server.listen(this.port, this.host, () => {\n        resolve({\n          address: this.server.address().address,\n          port: this.server.address().port,\n          family: this.server.address().family\n        });\n      });\n\n      this.server.on('listening', () => {\n        console.log(`Server running at ${this.host}:${this.port}`);\n      });\n    });\n  }\n\n  async destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'destroyed') {\n        reject(new Error('Server is already destroyed.'));\n        return;\n      }\n\n      this.state = 'destroyed';\n\n      this.server.close((err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        this.sockets.forEach(socket => socket.destroy());\n        this.sockets = [];\n        this.connections = 0;\n\n        resolve();\n      });\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 155,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's 'net' module that can handle client connections, respond to incoming data, and manage server lifecycle events.\n\nClass Description: The Server class represents a TCP server that listens on a dynamically assigned port. It handles client connections, processes incoming data, and sends appropriate responses. The server can be started, stopped, and connections can be dropped.\n\nAttributes:\n- server: [Object] - The TCP server instance created using the 'net' module\n- socket: [Object] - The current client socket connection\n- response: [Buffer|Object] - The predefined response to send to clients (optional)\n\nMethods:\n- constructor(response) -> [Server] - Initializes a new Server instance with an optional response buffer/object\n- start(cb) -> [void] - Starts the server on a random available port and invokes the callback with connection details (host and port)\n- drop() -> [void] - Terminates the current client connection\n- close(cb) -> [void] - Stops the server and invokes the callback when complete",
    "Canonical_solution": "var net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = undefined;\n    this.socket = undefined;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server = net.createServer(\n      function(socket) {\n        this.socket = socket;\n        if (this.response) {\n          this.socket.on(\n            'data',\n            function(data) {\n              if (data.length == 8) {\n                this.socket.write(Buffer.from('N', 'utf8'));\n              } else if (!data[0]) {\n                this.socket.write(buffers.authenticationOk());\n              } else {\n                this.socket.write(this.response);\n              }\n            }.bind(this)\n          );\n        }\n      }.bind(this)\n    );\n\n    const host = 'localhost';\n    this.server.listen({ host, port: 0 }, () => {\n      const port = this.server.address().port;\n      cb({\n        host,\n        port,\n      });\n    });\n  }\n\n  drop() {\n    this.socket.destroy();\n  }\n\n  close(cb) {\n    this.server.close(cb);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = new net.Server();\n    this.socket = null;\n    this.response = response;\n\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n      socket.on('data', (data) => {\n        if (this.response) {\n          if (Buffer.isBuffer(this.response)) {\n            socket.write(this.response);\n          } else {\n            socket.write(JSON.stringify(this.response));\n          }\n        }\n      });\n    });\n  }\n\n  start(cb) {\n    const server = this.server;\n    server.listen(0, '127.0.0.1', () => {\n      const address = server.address();\n      cb({ host: address.address, port: address.port });\n    });\n  }\n\n  drop() {\n    if (this.socket && !this.socket.destroyed) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    this.server.close(cb);\n  }\n}\n```"
  },
  {
    "Task_id": 156,
    "Instruction": "Task Description: Create a TCP server using Node.js's built-in 'net' module to handle client connections, parse incoming JSON data streams, and manage server lifecycle events.\n\nFunction Description: The function `createTCPServer` initializes a TCP server that listens on port 9999. It handles client connections by piping incoming data through a JSON stream parser. The server closes after processing a specified number of data events or when the parser emits an 'end' event. The function demonstrates basic TCP server setup, client connection handling, and event-driven server management.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function does not return a value but creates a running TCP server instance)",
    "Canonical_solution": "function createTCPServer() {\n    var net = require('net');\n    var server = net.createServer(function(client) {\n        var parser = JSONStream.parse([]);\n        parser.on('end', function() {\n            console.log('close');\n            console.error('PASSED');\n            server.close();\n        });\n        client.pipe(parser);\n        var n = 4;\n        client.on('data', function() {\n            if(--n) return;\n            client.end();\n        });\n    });\n    server.listen(9999);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst { Transform } = require('stream');\n\nfunction createTCPServer() {\n  const server = net.createServer();\n  let connectionCount = 0;\n\n  server.listen(9999, () => {\n    console.log('TCP server listening on port 9999');\n  });\n\n  server.on('connection', (socket) => {\n    connectionCount++;\n    console.log(`Client connected. Total connections: ${connectionCount}`);\n\n    const jsonParser = new Transform({\n      readableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        try {\n          const dataString = this._remainder ? this._remainder + chunk.toString() : chunk.toString();\n          let parsed;\n          try {\n            parsed = JSON.parse(dataString);\n            this.push(parsed);\n            this._remainder = '';\n          } catch (err) {\n            this._remainder = dataString;\n            callback();\n          }\n        } catch (err) {\n          callback(err);\n        }\n      }\n    });\n\n    jsonParser._remainder = '';\n\n    let dataEventCount = 0;\n    const maxDataEvents = 5;\n\n    jsonParser.on('data', (data) => {\n      dataEventCount++;\n      console.log('Received JSON data:', data);\n\n      if (dataEventCount >= maxDataEvents) {\n        console.log('Reached maximum data events. Closing server.');\n        server.close(() => {\n          console.log('Server closed.');\n        });\n      }\n    });\n\n    jsonParser.on('end', () => {\n      console.log('JSON stream ended. Closing server.');\n      server.close(() => {\n        console.log('Server closed.');\n      });\n    });\n\n    socket.pipe(jsonParser).pipe(socket);\n\n    socket.on('close', () => {\n      console.log(`Client disconnected. Remaining connections: ${--connectionCount}`);\n    });\n\n    socket.on('error', (err) => {\n      console.error('Socket error:', err.message);\n    });\n  });\n\n  server.on('error', (err) => {\n    console.error('Server error:', err.message);\n  });\n\n  server.on('close', () => {\n    console.log('All clients disconnected. Server is closing.');\n  });\n}\n```"
  },
  {
    "Task_id": 158,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's built-in 'net' module to handle client connections, data parsing, and server lifecycle events.\n\nClass Description: TcpReader is an EventEmitter-based class that manages a TCP server instance, handles client connections, processes incoming data through a custom parser, and manages server lifecycle events. It's designed to work within a transporter system for inter-process communication.\n\nAttributes:\n- server: [Object] - The TCP server instance created by the net module\n- opts: [Object] - Configuration options including port and maxPacketSize\n- transporter: [Object] - Reference to the parent transporter object\n- Promise: [Object] - Reference to the Promise implementation used by the transporter\n- logger: [Object] - Logger instance for logging events and errors\n- sockets: [Array] - Array of currently connected client sockets\n\nMethods:\n- listen() -> [Promise] - Starts the TCP server on the configured port and resolves with the actual port number when listening\n- onTcpClientConnected(socket: [Object]) -> [void] - Handles new client connections, sets up data parsing and error handling\n- closeSocket(socket: [Object]) -> [void] - Closes and removes a specific client socket\n- close() -> [void] - Stops the server and closes all client connections",
    "Canonical_solution": "const net = require(\"net\");\nconst EventEmitter = require(\"events\");\nconst Parser = require(\"./parser\");\n\nclass TcpReader extends EventEmitter {\n\tconstructor(transporter, opts) {\n\t\tsuper();\n\n\t\tthis.server = null;\n\t\tthis.opts = opts;\n\t\tthis.transporter = transporter;\n\t\tthis.Promise = transporter.broker.Promise;\n\t\tthis.logger = transporter.logger;\n\n\t\tthis.sockets = [];\n\t}\n\n\tlisten() {\n\t\treturn new this.Promise((resolve, reject) => {\n\t\t\tconst server = net.createServer(socket => this.onTcpClientConnected(socket));\n\n\t\t\tserver.on(\"error\", err => {\n\t\t\t\tthis.logger.error(\"Server error.\", err);\n\n\t\t\t\tif (reject) reject(err);\n\t\t\t});\n\n\t\t\tlet h = this.opts.port;\n\n\t\t\tif (process.versions.node.split(\".\")[0] >= 8)\n\t\t\t\th = { port: this.opts.port, exclusive: true };\n\n\t\t\tserver.listen(h, () => {\n\t\t\t\tthis.opts.port = this.server.address().port;\n\t\t\t\tthis.logger.info(`TCP server is listening on port ${this.opts.port}`);\n\t\t\t\tthis.connected = true;\n\n\t\t\t\tresolve(this.opts.port);\n\t\t\t\treject = null;\n\t\t\t});\n\n\t\t\tthis.server = server;\n\t\t});\n\t}\n\n\tonTcpClientConnected(socket) {\n\t\tthis.sockets.push(socket);\n\n\t\tsocket.setNoDelay(true);\n\n\t\tconst address = socket.remoteAddress;\n\t\tthis.logger.debug(`New TCP client connected from '${address}'`);\n\n\t\tconst parser = new Parser(undefined, this.opts.maxPacketSize);\n\t\tsocket.pipe(parser);\n\n\t\tparser.on(\"data\", (type, message) => {\n\t\t\tthis.transporter.onIncomingMessage(type, message, socket);\n\t\t});\n\n\t\tparser.on(\"error\", err => {\n\t\t\tthis.logger.warn(\"Packet parser error!\", err);\n\t\t\tthis.closeSocket(socket, err);\n\t\t});\n\n\t\tsocket.on(\"error\", err => {\n\t\t\tthis.logger.debug(`TCP client '${address}' error!`, err);\n\t\t\tthis.closeSocket(socket, err);\n\t\t});\n\n\t\tsocket.on(\"close\", hadError => {\n\t\t\tthis.logger.debug(`TCP client disconnected from '${address}'! Had error:`, !!hadError);\n\t\t\tthis.closeSocket(socket);\n\t\t});\n\n\t\tthis.emit(\"connect\", socket);\n\t}\n\n\tcloseSocket(socket) {\n\t\tsocket.destroy();\n\n\t\tthis.sockets.splice(this.sockets.indexOf(socket), 1);\n\t}\n\n\tclose() {\n\t\tif (this.server && this.server.listening) {\n\t\t\tthis.server.close();\n\n\t\t\tthis.sockets.forEach(socket => socket.destroy());\n\t\t\tthis.sockets = [];\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```js\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass TcpReader extends EventEmitter {\n  constructor(transporter, opts) {\n    super();\n    this.opts = opts || {};\n    this.transporter = transporter;\n    this.Promise = transporter.Promise;\n    this.logger = transporter.logger;\n    this.sockets = [];\n    this.server = net.createServer((socket) => {\n      this.onTcpClientConnected(socket);\n    });\n  }\n\n  listen() {\n    return new this.Promise((resolve, reject) => {\n      const port = this.opts.port;\n      this.server.listen(port, () => {\n        const address = this.server.address();\n        resolve(address.port);\n      });\n\n      this.server.on('error', (err) => {\n        this.logger.error('TCP server error:', err.message);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.setEncoding('utf8');\n    let buffer = '';\n\n    socket.on('data', (data) => {\n      buffer += data;\n      while (true) {\n        if (buffer.length < 4) break;\n        const length = parseInt(buffer.slice(0, 4), 10);\n        if (isNaN(length)) break;\n        if (buffer.length < length + 4) break;\n\n        const packet = buffer.slice(4, length + 4);\n        this.emit('data', packet);\n        buffer = buffer.slice(length + 4);\n      }\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n    });\n\n    socket.on('error', (err) => {\n      this.logger.error('TCP client error:', err.message);\n      this.closeSocket(socket);\n    });\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n      socket.destroy();\n    }\n  }\n\n  close() {\n    this.server.close(() => {\n      this.sockets.forEach((socket) => this.closeSocket(socket));\n      this.sockets = [];\n    });\n  }\n}\n\nmodule.exports = TcpReader;\n```"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a class that handles HTTP requests with authentication and custom headers for a specific API service. The class should support both GET and POST methods, generate required authentication signatures, and handle request errors appropriately.\n\nClass Description: The TaskRequest class is designed to make authenticated HTTP requests to a specific API endpoint. It handles request signing, header generation, and error management. The class maintains authentication-related attributes and provides a method to execute requests.\n\nAttributes:\n- did: [String] - Device identifier used for authentication\n- finger: [String] - Fingerprint information for the request\n- token: [String] - Authentication token for API access\n- oaid: [String] - OAID (Open Anonymous Identification) for tracking\n\nMethods:\n- constructor(did, finger, token, oaid) -> [None] - Initializes the TaskRequest instance with authentication parameters\n- taskRequest(method, url, body) -> [Promise<Object>] - Executes an HTTP request with the specified method to the given URL, optionally with a request body. Returns the response data or throws an error if the request fails. The method handles request signing and header generation internally.\n\nInput:\n- method: [String] - HTTP method to use ('get' or 'post')\n- url: [String] - Target URL for the request\n- body: [String] (optional) - Request body for POST requests (default: empty string)\n\nOutput:\n- [Promise<Object>] - Resolves with the response data if the request succeeds\n- [Error] - Throws an error if the request fails",
    "Canonical_solution": "const axios = require('axios');\n\nclass TaskRequest {\n    constructor(did, finger, token, oaid) {\n        this.did = did;\n        this.finger = finger;\n        this.token = token;\n        this.oaid = oaid;\n    }\n\n    async taskRequest(method, url, body = \"\") {\n        let re = function (e) {\n            function convertObjectToQueryString(obj) {\n                let queryString = \"\";\n                if (obj) {\n                    const keys = Object.keys(obj).sort();\n                    keys.forEach(key => {\n                        const value = obj[key];\n                        if (value !== null && typeof value !== 'object') {\n                            queryString += `&${key}=${value}`;\n                        }\n                    });\n                }\n                return queryString.slice(1);\n            }\n            return convertObjectToQueryString(e)\n        }\n        \n        function v(e) {\n            const crypto = require(\"crypto\")\n            return crypto.createHash(\"md5\").update(e).digest(\"hex\")\n        }\n        \n        const g = {\n            traceid: v((new Date).getTime().toString() + Math.random().toString()),\n            noncestr: Math.random().toString().slice(2, 10),\n            timestamp: Date.now(),\n            platform: \"h5\",\n            did: this.did,\n            version: \"1.0.0\",\n            finger: this.finger,\n            token: this.token,\n            oaid: this.oaid,\n        }\n        \n        const c = \"\\u7c89\\u8c61\\u597d\\u725b\\u903ca8c19d8267527ea4c7d2f011acf7766f\"\n        let s = method === \"get\" ? void 0 : JSON.parse(body)\n        let e = void 0 === s ? {} : s\n        g.sign = v(re(e) + re(g) + c)\n        \n        let headers = {\n            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; MI 8 Lite Build/QKQ1.190910.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/80.0.3987.99 Mobile Safari/537.36 AgentWeb/5.0.0  UCBrowser/11.6.4.950',\n            'Accept': 'application/json, text/plain, */*',\n            'Accept-Encoding': 'gzip, deflate',\n            'Content-Type': 'application/json',\n            'origin': 'https://m.fenxianglife.com',\n            'sec-fetch-dest': 'empty',\n            'x-requested-with': 'com.n_add.android',\n            'sec-fetch-site': 'same-site',\n            'sec-fetch-mode': 'cors',\n            'referer': 'https://m.fenxianglife.com/h5-lottery/index.html?hideBack=1&sourceType=lottery_tab&token=030e7e9158af06dea2b3d0175a471ada&AppToken=96e06ae9f3cab6784de443015b8d9ad8&uid=515226607&v=5.4.3&did=njia992631e6-b9b2-4383-b67c-86b5d0fe818a&level=1&platform=android&timestamp=1717426249&channel=xiaomi&traFromId=23192687628924991393323633117947',\n            'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\n            \"Content-Type\": \"application/json\"\n        }\n        \n        Object.assign(headers, g)\n        \n        const reqeuestOptions = {\n            url: url,\n            method: method,\n            headers: headers,\n            data: body\n        }\n        \n        try {\n            const response = await axios(reqeuestOptions);\n            return response.data;\n        } catch (error) {\n            console.log('axios error', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass TaskRequest {\n  constructor(did, finger, token, oaid) {\n    this.did = did;\n    this.finger = finger;\n    this.token = token;\n    this.oaid = oaid;\n  }\n\n  async taskRequest(method, url, body = '') {\n    const headers = new Headers({\n      'Content-Type': 'application/json',\n      'X-Device-ID': this.did,\n      'X-Fingerprint': this.finger,\n      'X-Auth-Token': this.token,\n      'X-OAID': this.oaid,\n      'Authorization': this.generateSignature(url),\n    });\n\n    const options = {\n      method: method.toLowerCase(),\n      headers: headers,\n      body: method.toLowerCase() === 'post' ? body : undefined,\n    };\n\n    try {\n      const response = await fetch(url, options);\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! Status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      throw new Error(`Request failed: ${error.message}`);\n    }\n  }\n\n  generateSignature(url) {\n    const key = 'your-secret-key'; // Replace with actual secret key\n    const hmac = require('crypto').createHmac('sha256', key);\n    const signature = hmac.update(url).digest('hex');\n    return `Bearer ${signature}`;\n  }\n}\n```"
  },
  {
    "Task_id": 164,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's built-in 'net' module that can handle both secure (TLS) and non-secure connections, manage client connections, and emit relevant events.\n\nClass Description: The Server class extends Node.js's EventEmitter to create a TCP server that can handle multiple client connections. It supports both secure (TLS) and non-secure (plain TCP) modes, manages connection lifecycle events, and maintains a list of active connections.\n\nAttributes:\n- socket: [Object] - The underlying TCP/TLS server instance\n- connections: [Array] - Array of active Connection objects\n\nMethods:\n- constructor(secure, options, callback) -> [Server Instance] - Initializes the server. 'secure' is a boolean indicating TLS usage, 'options' is an optional configuration object, and 'callback' is an optional function for 'connection' events\n- listen(port, host, callback) -> [Server Instance] - Starts the server listening on specified port and host. 'host' is optional, and 'callback' is an optional function for 'listening' events\n\nEvents:\n- connection: Emitted when a new client connects (passes Connection object)\n- close: Emitted when the server closes\n- error: Emitted when an error occurs (passes error object)\n- listening: Emitted when the server starts listening",
    "Canonical_solution": "var util = require('util'),\n    net = require('net'),\n    tls = require('tls'),\n    events = require('events'),\n    Connection = require('./Connection');\n\nfunction nop() {}\n\nclass Server extends events.EventEmitter {\n    constructor(secure, options, callback) {\n        super();\n        var that = this;\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n\n        var onConnection = function (socket) {\n            var conn = new Connection(socket, that, function () {\n                that.connections.push(conn);\n                conn.removeListener('error', nop);\n                that.emit('connection', conn);\n            });\n            conn.on('close', function () {\n                var pos = that.connections.indexOf(conn);\n                if (pos !== -1) {\n                    that.connections.splice(pos, 1);\n                }\n            });\n\n            // Ignore errors before the connection is established\n            conn.on('error', nop);\n        };\n\n        if (secure) {\n            this.socket = tls.createServer(options, onConnection);\n        } else {\n            this.socket = net.createServer(options, onConnection);\n        }\n\n        this.socket.on('close', function () {\n            that.emit('close');\n        });\n        this.socket.on('error', function (err) {\n            that.emit('error', err);\n        });\n        this.connections = [];\n\n        if (callback) {\n            this.on('connection', callback);\n        }\n    }\n\n    listen(port, host, callback) {\n        var that = this;\n\n        if (typeof host === 'function') {\n            callback = host;\n            host = undefined;\n        }\n\n        if (callback) {\n            this.on('listening', callback);\n        }\n\n        this.socket.listen(port, host, function () {\n            that.emit('listening');\n        });\n\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```js\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass Server extends EventEmitter {\n  constructor(secure, options = {}, callback) {\n    super();\n    this.secure = secure;\n    this.options = options;\n    this.socket = null;\n    this.connections = [];\n\n    if (secure) {\n      this.socket = new tls.TLSServer(options, (socket) => this.handleConnection(socket));\n    } else {\n      this.socket = new net.Server((socket) => this.handleConnection(socket));\n    }\n\n    this.socket.on('error', (err) => this.emit('error', err));\n    this.socket.on('close', () => this.emit('close'));\n    this.socket.on('listening', () => this.emit('listening'));\n\n    if (callback) {\n      this.on('connection', callback);\n    }\n  }\n\n  listen(port, host, callback) {\n    if (typeof host === 'function') {\n      callback = host;\n      host = undefined;\n    }\n    this.socket.listen(port, host, () => {\n      if (callback) callback();\n      this.emit('listening');\n    });\n    return this;\n  }\n\n  handleConnection(socket) {\n    const connection = { socket };\n    this.connections.push(connection);\n\n    socket.on('end', () => {\n      this.connections = this.connections.filter(conn => conn !== connection);\n      socket.destroy();\n    });\n\n    this.emit('connection', connection);\n  }\n\n  close(callback) {\n    this.socket.close(callback);\n  }\n}\n```"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a TCP server connector class in JavaScript using Node.js's 'net' module that handles server creation, connection events, and lifecycle management.\n\nClass Description: The Connector class is an EventEmitter that creates and manages a TCP server. It handles server connections, errors, and provides methods to start and stop the server.\n\nAttributes:\n- opts: [Object] - Optional configuration options for the server\n- host: [String] - The host address the server will bind to\n- port: [Number] - The port number the server will listen on\n- tcpServer: [Object] - The underlying TCP server instance\n\nMethods:\n- constructor: [Connector](port, host, opts) -> [Connector] - Initializes a new Connector instance with specified port, host, and options\n- start: [start](cb) -> [undefined] - Starts the TCP server and sets up connection and error event handlers. Calls the callback when server is ready\n- stop: [stop](force, cb) -> [undefined] - Stops the TCP server and calls the callback when complete. The force parameter determines whether to force close connections",
    "Canonical_solution": "var net = require('net');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nvar Connector = function(port, host, opts) {\n  if (!(this instanceof Connector)) {\n    return new Connector(port, host, opts);\n  }\n\n  EventEmitter.call(this);\n  this.opts = opts || {};\n  this.host = host;\n  this.port = port;\n};\n\nutil.inherits(Connector, EventEmitter);\n\nConnector.prototype.start = function(cb) {\n  var self = this;\n  this.tcpServer = net.createServer();\n  \n  this.tcpServer.on('connection', function(socket) {\n    self.emit('connection', socket);\n  });\n\n  this.tcpServer.on('error', function(err) {\n    self.emit('error', err);\n  });\n\n  this.tcpServer.listen(this.port, this.host);\n  process.nextTick(cb);\n};\n\nConnector.prototype.stop = function(force, cb) {\n  this.tcpServer.close();\n  process.nextTick(cb);\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Connector extends EventEmitter {\n  constructor(port, host = 'localhost', opts = {}) {\n    super();\n    this.opts = opts;\n    this.host = host;\n    this.port = port;\n    this.tcpServer = new net.Server(opts);\n    this._setupEventHandlers();\n  }\n\n  _setupEventHandlers() {\n    this.tcpServer.on('listening', () => {\n      this.emit('listening', this.tcpServer.address());\n    });\n\n    this.tcpServer.on('connection', (socket) => {\n      this.emit('connection', socket);\n    });\n\n    this.tcpServer.on('error', (err) => {\n      this.emit('error', err);\n    });\n\n    this.tcpServer.on('close', () => {\n      this.emit('close');\n    });\n  }\n\n  start(cb) {\n    this.tcpServer.listen({\n      host: this.host,\n      port: this.port\n    }, () => {\n      if (cb) cb();\n    });\n  }\n\n  stop(force, cb) {\n    const server = this.tcpServer;\n    if (force) {\n      server.close(() => {\n        if (cb) cb();\n      });\n    } else {\n      server.close((err) => {\n        if (err) this.emit('error', err);\n        if (cb) cb();\n      });\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 167,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's 'net' module to listen for incoming connections, handle client messages, and emit events for commands received.\n\nClass Description: TCPListener is a class that creates a TCP server to listen for incoming connections on a specified port. It handles client connections, processes incoming data, and emits events when commands are received. The class extends Node.js's EventEmitter to provide event-driven functionality.\n\nAttributes:\n- port: [Number] - The port number on which the TCP server will listen\n- server: [Object] - The TCP server instance created by the 'net' module\n\nMethods:\n- constructor(port) -> [TCPListener] - Initializes the TCPListener instance with the specified port\n- start() -> [void] - Creates and starts the TCP server, sets up event handlers for client connections, data reception, and errors. Emits 'command' events when valid messages are received and 'log' events for server status updates\n\nThe class emits the following events:\n- 'command': (command, params, options, callback) - Emitted when a valid command message is received from a client\n- 'log': (message) - Emitted for logging server status and errors",
    "Canonical_solution": "var events = require('events');\nvar net = require('net');\n\nclass TCPListener {\n    constructor(port) {\n        this.port = port;\n        this.server = null;\n    }\n\n    start() {\n        this.server = net.createServer((c) => {\n            var data = '';\n            try {\n                c.on('data', (d) => {\n                    data += d;\n                    if (data.slice(-1) === '\\n') {\n                        var message = JSON.parse(data);\n                        this.emit('command', message.command, message.params, message.options, (message) => {\n                            c.end(message);\n                        });\n                    }\n                });\n                c.on('end', () => {});\n                c.on('error', () => {});\n            }\n            catch(e) {\n                this.emit('log', 'CLI listener failed to parse message ' + data);\n            }\n        }).listen(this.port, '127.0.0.1', () => {\n            this.emit('log', 'CLI listening on port ' + this.port);\n        });\n    }\n}\n\nTCPListener.prototype.__proto__ = events.EventEmitter.prototype;",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass TCPListener extends EventEmitter {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server = new net.Server();\n  }\n\n  start() {\n    this.emit('log', `Starting TCP server on port ${this.port}`);\n    this.server.listen(this.port, () => {\n      this.emit('log', `TCP server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', (socket) => {\n      this.emit('log', 'Client connected');\n\n      socket.on('data', (data) => {\n        const message = data.toString().trim();\n        this.emit('log', `Received message: ${message}`);\n\n        try {\n          const [command, ...rest] = message.split(' ');\n          let params = [];\n          let options = {};\n          let callback;\n\n          if (rest.length > 0) {\n            const lastItem = rest[rest.length - 1];\n            if (typeof lastItem === 'function') {\n              callback = lastItem;\n              rest.pop();\n            }\n            params = rest;\n            for (let i = 0; i < params.length; i += 2) {\n              if (params[i].startsWith('--')) {\n                const key = params[i].slice(2);\n                const value = params[i + 1];\n                options[key] = value;\n                params.splice(i, 2);\n                i -= 2;\n              }\n            }\n          }\n\n          this.emit('command', command, params, options, callback);\n        } catch (error) {\n          this.emit('log', `Error processing command: ${error.message}`);\n        }\n      });\n\n      socket.on('end', () => {\n        this.emit('log', 'Client disconnected');\n      });\n\n      socket.on('error', (err) => {\n        this.emit('log', `Socket error: ${err.message}`);\n      });\n    });\n\n    this.server.on('error', (err) => {\n      this.emit('log', `Server error: ${err.message}`);\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Implement a TCP server class in JavaScript using Node.js's 'net' module to handle client connections, manage sockets, and provide event-driven communication.\n\nClass Description: The Socket class represents a TCP server that can bind to a specific port/host, manage client connections, handle socket errors, and emit events for various connection states. It extends EventEmitter for event handling capabilities.\n\nAttributes:\n- server: [net.Server] - The underlying TCP server instance\n- socks: [Array] - Array of connected client sockets\n- settings: [Object] - Configuration settings for the server\n- type: [String] - Indicates whether the instance is acting as a server or client\n\nMethods:\n- constructor() -> [void] - Initializes the socket instance with default settings\n- bind(port, host, fn) -> [Socket] - Binds the server to a specified port and host (supports both TCP and Unix sockets)\n- onconnect(sock) -> [void] - Handles new client connections\n- addSocket(sock) -> [void] - Adds a new socket to the connection pool and sets up message parsing\n- removeSocket(sock) -> [void] - Removes a socket from the connection pool\n- handleErrors(sock) -> [void] - Sets up error handling for a socket\n- closeServer(fn) -> [void] - Closes the server and all client connections",
    "Canonical_solution": "var Emitter = require('events').EventEmitter;\nvar net = require('net');\nvar debug = require('debug')('axon:sock');\n\nclass Socket {\n  constructor() {\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.set('hwm', Infinity);\n    this.set('identity', String(process.pid));\n    this.set('retry timeout', 100);\n    this.set('retry max timeout', 5000);\n  }\n\n  bind(port, host, fn) {\n    var self = this;\n    if ('client' == this.type) throw new Error('cannot bind() after connect()');\n    if ('function' == typeof host) {\n      fn = host;\n      host = undefined;\n    }\n\n    var unixSocket = false;\n\n    if ('string' == typeof port) {\n      port = url.parse(port);\n\n      if ('unix:' == port.protocol) {\n        host = fn;\n        fn = undefined;\n        port = port.pathname;\n        unixSocket = true;\n      } else {\n        host = port.hostname || '0.0.0.0';\n        port = parseInt(port.port, 10);\n      }\n    } else {\n      host = host || '0.0.0.0';\n    }\n\n    this.type = 'server';\n\n    this.server = net.createServer(this.onconnect.bind(this));\n\n    debug('%s bind %s:%s', this.type, host, port);\n    this.server.on('listening', this.emit.bind(this, 'bind'));\n\n    if (unixSocket) {\n      this.server.on('error', function(e) {\n        if (e.code == 'EADDRINUSE') {\n          var clientSocket = new net.Socket();\n\n          clientSocket.on('error', function(e2) {\n            if (e2.code == 'ECONNREFUSED') {\n              fs.unlink(port);\n              self.server.listen(port, host, fn);\n            }\n          });\n\n          clientSocket.connect({path: port}, function() {\n            throw e;\n          });\n        }\n      });\n    }\n\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    var self = this;\n    var addr = sock.remoteAddress + ':' + sock.remotePort;\n    debug('%s accept %s', self.type, addr);\n    this.addSocket(sock);\n    this.handleErrors(sock);\n    this.emit('connect', sock);\n    sock.on('close', function() {\n      debug('%s disconnect %s', self.type, addr);\n      self.emit('disconnect', sock);\n      self.removeSocket(sock);\n    });\n  }\n\n  addSocket(sock) {\n    var parser = new Parser;\n    var i = this.socks.push(sock) - 1;\n    debug('%s add socket %d', this.type, i);\n    sock.pipe(parser);\n    parser.on('data', this.onmessage(sock));\n  }\n\n  removeSocket(sock) {\n    var i = this.socks.indexOf(sock);\n    if (!~i) return;\n    debug('%s remove socket %d', this.type, i);\n    this.socks.splice(i, 1);\n  }\n\n  handleErrors(sock) {\n    var self = this;\n    sock.on('error', function(err) {\n      debug('%s error %s', self.type, err.code || err.message);\n      self.emit('socket error', err);\n      self.removeSocket(sock);\n      if (!~ignore.indexOf(err.code)) return self.emit('error', err);\n      debug('%s ignored %s', self.type, err.code);\n      self.emit('ignored error', err);\n    });\n  }\n\n  closeServer(fn) {\n    debug('%s closing server', this.type);\n    this.server.on('close', this.emit.bind(this, 'close'));\n    this.server.close();\n    fn && fn();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    this.server = net.createServer((sock) => this.onconnect(sock));\n    this.server.listen(port, host, () => {\n      if (fn) fn();\n    });\n    this.server.on('error', (err) => this.emit('error', err));\n    return this;\n  }\n\n  onconnect(sock) {\n    this.addSocket(sock);\n    this.emit('connection', sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    this.handleErrors(sock);\n    sock.on('data', (data) => this.emit('message', data, sock));\n    sock.on('end', () => this.removeSocket(sock));\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n      sock.destroy();\n    }\n    this.emit('close', sock);\n  }\n\n  handleErrors(sock) {\n    sock.on('error', (err) => {\n      this.emit('socketError', err, sock);\n      this.removeSocket(sock);\n    });\n  }\n\n  closeServer(fn) {\n    if (!this.server) return;\n    this.server.close(() => {\n      this.socks.forEach((sock) => sock.destroy());\n      this.socks = [];\n      if (fn) fn();\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a class that provides wallpaper retrieval functionality from different APIs (Unsplash or Bing) based on client availability.\n\nClass Description: The WallpaperService class is designed to fetch random wallpapers from either Unsplash (if an API key is provided) or Bing's wallpaper API (as a fallback). It handles API requests, processes responses, and provides a consistent output format regardless of the source.\n\nAttributes: None (This is a static service class with no instance attributes)\n\nMethods:\ngetWallpaper: static async getWallpaper(unsplashClientId: string) -> Promise<Object> - Fetches a random wallpaper from either Unsplash or Bing. \n  - Input: \n    - unsplashClientId: string - The API client ID for Unsplash (optional, if not provided will use Bing)\n  - Output: \n    - Returns a Promise that resolves to an object with:\n      - type: string - Indicates the source ('unsplash' or 'bing')\n      - data: Array/Object - Contains the wallpaper data in the respective API's format\n    - On error, returns a fallback Bing wallpaper object with a default image",
    "Canonical_solution": "const axios = require('axios');\n\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    const wallpaperAPI = unsplashClientId\n      ? 'https://api.unsplash.com/photos/random?orientation=landscape&count=1&client_id=' + unsplashClientId\n      : 'https://cn.bing.com/HPImageArchive.aspx?format=js&n=1';\n\n    try {\n      const res = await axios.get(wallpaperAPI);\n      return unsplashClientId\n        ? { type: 'unsplash', data: res.data }\n        : { type: 'bing', data: res.data.images };\n    } catch (error) {\n      return {\n        type: 'bing',\n        data: [{\n          url: '/az/hprichbg/rb/SWFC_ZH-CN9558503653_1920x1080.jpg',\n          copyrightlink: '/search?q=%e4%b8%8a%e6%b5%b7%e4%b8%96%e7%95%8c%e9%87%91%e8%9e%8d%e4%b8%ad%e5%bf%83&form=hpcapt&mkt=zh-cn'\n        }]\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    try {\n      if (unsplashClientId) {\n        const unsplashResponse = await fetch(\n          `https://api.unsplash.com/photos/random?client_id=${encodeURIComponent(unsplashClientId)}`\n        );\n        if (unsplashResponse.ok) {\n          const data = await unsplashResponse.json();\n          return {\n            type: 'unsplash',\n            data,\n          };\n        }\n      }\n\n      // Fallback to Bing\n      const bingResponse = await fetch('https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1');\n      if (bingResponse.ok) {\n        const data = await bingResponse.json();\n        return {\n          type: 'bing',\n          data,\n        };\n      }\n\n      // Default fallback in case of errors\n      return {\n        type: 'bing',\n        data: {\n          images: [\n            {\n              url: 'https://www.bing.com/th?id=OHR.SymriseEnchantedForest_ZH-CN7534688929_1920x1080.jpg',\n            },\n          ],\n        },\n      };\n    } catch (error) {\n      return {\n        type: 'bing',\n        data: {\n          images: [\n            {\n              url: 'https://www.bing.com/th?id=OHR.SymriseEnchantedForest_ZH-CN7534688929_1920x1080.jpg',\n            },\n          ],\n        },\n      };\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 178,
    "Instruction": "Task Description: Create a Node class that implements a TCP-based peer-to-peer communication system using Node.js's net module. The class should handle server creation, client connections, message passing, and peer management.\n\nClass Description: The Node class represents a network node that can both accept incoming connections and establish outgoing connections to other peers. It uses TCP sockets for communication and implements basic peer discovery and message broadcasting capabilities.\n\nAttributes:\n\nid_: [Number] - Unique identifier for this node\npeers_: [Object] - Dictionary mapping peer IDs to their socket connections\nPORT: [Number] - Base port number for node communication (actual port is PORT + id)\nserver_: [net.Server] - TCP server instance for accepting incoming connections\n\nMethods:\n\nconstructor(id) -> [void] - Initializes the node with given ID, sets up event emitter, and creates TCP server\nstart() -> [Promise] - Attempts to connect to random peers (up to 5) for network formation\non_data(data, socket) -> [void] - Handles incoming data from sockets, parses messages and emits events\nsend(socket, data) -> [void] - Sends data to a peer (either via socket object or peer ID)\nbroadcast(data) -> [void] - Sends data to all connected peers\nadd_peer(socket, remote_id) -> [void] - Adds a peer connection to the peers dictionary\nremove_peer(socket) -> [void] - Removes a peer connection from the peers dictionary\nlist_peers() -> [Array] - Returns an array of connected peer IDs",
    "Canonical_solution": "var net = require(\"net\");\nvar Msg = require(\"./message\");\nvar EventEmitter = require('events').EventEmitter;\nvar Promise = require(\"bluebird\");\n\nclass Node extends EventEmitter {\n    constructor(id) {\n        super();\n        this.id_ = id;\n        this.peers_ = {};\n        this.PORT = 8000;\n\n        let self = this;\n        this.server_ = net.createServer((socket) => {\n            socket.setEncoding('utf8');\n            socket.on('data', (data) => { self.on_data(data, socket); });\n            socket.on('end', () => { self.remove_peer(socket); });\n        });\n        this.server_.listen(this.PORT + id);\n    }\n\n    async start() {\n        for (var i = 0; i < 5; ++i) {\n            var remote_id = Math.floor(Math.random() * 20);\n            if (remote_id !== this.id_ && !this.peers_[remote_id]) {\n                let self = this;\n                var socket = net.createConnection({ port: (this.PORT + remote_id) });\n                await new Promise((resolve, reject) => {\n                    socket.on('connect', () => {\n                        resolve();\n                    });\n                    socket.on('error', function (e) {\n                        resolve();\n                    });\n                    socket.setEncoding('utf8');\n                    socket.on('data', (data) => { self.on_data(data, socket); });\n                });\n                let data = Msg.connection(self.id_);\n                self.send(socket, data);\n                self.add_peer(socket, remote_id);\n            }\n        }\n    }\n\n    on_data(data, socket) {\n        try {\n            var arr = data.split(\"\\r\\n\");\n            for (var i = 0; i < arr.length; ++i) {\n                if (arr[i] == '') continue;\n                let obj = JSON.parse(arr[i]);\n                if (obj.type == Msg.type.Connection) {\n                    let remote_id = obj.data;\n                    this.add_peer(socket, remote_id);\n                } else {\n                    this.emit(\"message\", obj);\n                }\n            }\n        } catch (err) {\n            console.log(\"=========================\");\n            console.log(`node: ${this.id_}\\t receive msg error`);\n            console.log(err);\n            console.log(err.message);\n            console.log(data);\n            console.log(arr.length);\n            console.log(\"=========================\");\n            throw new Error();\n        }\n    }\n\n    send(socket, data) {\n        if (typeof socket === 'number') {\n            socket = this.peers_[socket];\n        }\n        if (typeof data === 'object') {\n            data = JSON.stringify(data);\n        }\n        socket.write(data + \"\\r\\n\");\n    }\n\n    broadcast(data) {\n        for (var index in this.peers_) {\n            let socket = this.peers_[index];\n            this.send(socket, data);\n        }\n    }\n\n    add_peer(socket, remote_id) {\n        if (!this.peers_[remote_id]) {\n            this.peers_[remote_id] = socket;\n        }\n    }\n\n    remove_peer(socket) {\n        for (var index in this.peers_) {\n            if (this.peers_[index] == socket) {\n                delete this.peers_[index];\n                break;\n            }\n        }\n    }\n\n    list_peers() {\n        let peer_ids = [];\n        for (var index in this.peers_) {\n            peer_ids.push(index);\n        }\n        return peer_ids;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\n\nclass Node {\n  constructor(id) {\n    this.id_ = id;\n    this.peers_ = {};\n    this.PORT = 3000;\n    this.server_ = net.createServer();\n    this.server_.on('connection', (socket) => this.handle_connection(socket));\n  }\n\n  async start() {\n    return new Promise((resolve, reject) => {\n      const port = this.PORT + this.id_;\n      this.server_.listen(port, () => {\n        console.log(`Node ${this.id_} listening on port ${port}`);\n        resolve();\n      });\n\n      this.server_.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  handle_connection(socket) {\n    socket.on('data', (data) => this.on_data(data, socket));\n    socket.on('end', () => this.remove_peer(socket));\n    socket.on('error', (err) => {\n      console.error(`Socket error: ${err.message}`);\n      this.remove_peer(socket);\n    });\n  }\n\n  on_data(data, socket) {\n    try {\n      const message = JSON.parse(data.toString());\n      if (message.type === 'handshake') {\n        this.add_peer(socket, message.id);\n        this.send(socket, { type: 'handshake', id: this.id_ });\n      } else {\n        this.emit('message', message);\n      }\n    } catch (e) {\n      console.error(`Failed to parse data: ${e.message}`);\n    }\n  }\n\n  send(socket, data) {\n    if (typeof socket === 'number') {\n      const peerSocket = this.peers_[socket];\n      if (!peerSocket) {\n        console.warn(`No socket found for peer ID ${socket}`);\n        return;\n      }\n      socket = peerSocket;\n    }\n    socket.write(JSON.stringify(data) + '\\n');\n  }\n\n  broadcast(data) {\n    Object.values(this.peers_).forEach((socket) => {\n      this.send(socket, data);\n    });\n  }\n\n  add_peer(socket, remote_id) {\n    if (!this.peers_[remote_id]) {\n      this.peers_[remote_id] = socket;\n      this.emit('peer_connected', remote_id);\n    }\n  }\n\n  remove_peer(socket) {\n    for (const [id, peerSocket] of Object.entries(this.peers_)) {\n      if (peerSocket === socket) {\n        delete this.peers_[id];\n        this.emit('peer_disconnected', id);\n        break;\n      }\n    }\n  }\n\n  list_peers() {\n    return Object.keys(this.peers_);\n  }\n\n  emit(event, data) {\n    if (this[`on${event}`]) {\n      this[`on${event}`](data);\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a Flash Policy Server class in JavaScript using Node.js's net module to handle cross-domain policy requests for socket connections.\n\nClass Description: The FlashPolicyServer class creates a TCP server that responds to Flash socket policy requests. It manages allowed origins/ports, compiles the XML policy file, and handles server lifecycle events.\n\nAttributes:\n- origins: [Array] - List of allowed domain:port combinations\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [Object] - TCP server instance\n- buffer: [Buffer] - Compiled policy file in binary format\n- server: [Object] - Optional existing server instance to attach to\n\nMethods:\n- constructor(options, origins) -> [FlashPolicyServer] - Initializes the server with options and allowed origins\n- listen(port, server, cb) -> [FlashPolicyServer] - Starts listening on specified port, optionally attaching to existing server\n- responder(socket) -> [void] - Responds to policy requests on a socket connection\n- compile() -> [FlashPolicyServer] - Generates the XML policy buffer from allowed origins\n- add() -> [FlashPolicyServer] - Adds new allowed origins to the policy\n- remove(origin) -> [FlashPolicyServer] - Removes an origin from the allowed list\n- close() -> [FlashPolicyServer] - Stops the server and cleans up listeners",
    "Canonical_solution": "var net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => this.responder(socket));\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges.'\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (data && data[0] === 60 && data.toString() === '<policy-file-request/>\\0' &&\n              socket && (socket.readyState === 'open' || socket.readyState === 'writeOnly')) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    this.port >= 0 && this.socket.listen(this.port, () => {\n      this.socket.online = true;\n      if (callback) {\n        callback.call(this);\n        callback = undefined;\n      }\n    });\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = new Buffer(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nclass FlashPolicyServer {\n  constructor(options, origins = []) {\n    this.origins = origins;\n    this.port = options?.port || 843;\n    this.log = options?.log || console.log;\n    this.socket = null;\n    this.buffer = Buffer.from(\"\");\n    this.server = options?.server;\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    if (typeof port === \"function\") {\n      cb = port;\n      port = this.port;\n    } else if (typeof server === \"function\") {\n      cb = server;\n      server = null;\n    }\n\n    this.port = port || this.port;\n    this.socket = net.createServer((conn) => this.responder(conn));\n\n    if (server && typeof server.on === \"function\") {\n      server.on(\"connection\", (conn) => this.responder(conn));\n      if (cb) cb();\n    } else {\n      this.socket.listen(this.port, () => {\n        this.log(`Flash Policy Server listening on port ${this.port}`);\n        if (cb) cb();\n      });\n    }\n    return this;\n  }\n\n  responder(socket) {\n    socket.setNoDelay(true);\n    let data = \"\";\n\n    socket.on(\"data\", (chunk) => {\n      data += chunk.toString();\n      if (data.includes(\"<policy-file-request/>\")) {\n        socket.write(this.buffer);\n        socket.destroy();\n      } else if (data.length > 1024) {\n        socket.destroy();\n      }\n    });\n\n    socket.on(\"error\", (err) => {\n      this.log(`Socket error: ${err.message}`);\n    });\n  }\n\n  compile() {\n    const xml = `<?xml version=\"1.0\"?>\\n<cross-domain-policy>\\n  <allow-access-from domain=\"${this.origins\n      .map((o) => o.split(\":\")[0])\n      .join('\" port=\"')}\" port=\"${this.origins\n      .map((o) => o.split(\":\")[1] || \"*\")\n      .join('\"')}\" />\\n</cross-domain-policy>\\n`;\n    this.buffer = Buffer.from(xml, \"utf-8\");\n    return this;\n  }\n\n  add(...origins) {\n    origins.forEach((origin) => {\n      if (!this.origins.includes(origin)) {\n        this.origins.push(origin);\n      }\n    });\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index !== -1) {\n      this.origins.splice(index, 1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close(cb) {\n    if (this.socket && this.socket.listening) {\n      this.socket.close(cb);\n    }\n    return this;\n  }\n}\n```"
  },
  {
    "Task_id": 186,
    "Instruction": "Task Description: Create a UDP communication class in JavaScript using Node.js's dgram module for bidirectional message handling between processes.\n\nClass Description: The Udp class facilitates UDP-based communication with capabilities for both sending and receiving messages. It manages socket creation, port binding, message queuing, and event handling for network communication.\n\nAttributes:\n- stack: [Array] - Stores outgoing messages in a queue before sending\n- port: [Number|null] - The target port number for outgoing messages\n- socket: [dgram.Socket|null] - UDP socket instance for sending messages\n- listener: [dgram.Socket|null] - UDP socket instance for receiving messages\n- client: [Object] - Reference to the parent client object for message handling\n\nMethods:\n- constructor(client) -> [void] - Initializes the UDP instance with a client reference and creates socket objects\n- start() -> [void] - Begins UDP communication by setting up input and output sockets\n- clear() -> [void] - Clears the message queue\n- run() -> [void] - Processes all messages in the queue\n- push(msg) -> [void] - Adds a message to the outgoing queue (Input: msg [String] - Message to send)\n- play(data) -> [void] - Sends a single message via UDP (Input: data [String] - Message content)\n- selectOutput(port=49161) -> [void] - Configures the output port (Input: port [Number] - Target port number)\n- selectInput(port=49160) -> [void] - Configures and starts the input listener (Input: port [Number] - Listening port number)",
    "Canonical_solution": "const dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = dgram ? dgram.createSocket('udp4') : null;\n    this.listener = dgram ? dgram.createSocket('udp4') : null;\n    this.client = client;\n  }\n\n  start() {\n    if (!dgram || !this.socket || !this.listener) { \n      console.warn('UDP', 'Could not start.'); \n      return; \n    }\n    console.info('UDP', 'Starting..');\n\n    this.selectInput();\n    this.selectOutput();\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    for (const item of this.stack) {\n      this.play(item);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (!this.socket) { return; }\n    this.socket.send(Buffer.from(`${data}`), this.port, this.client.io.ip, (err) => {\n      if (err) { console.warn(err); }\n    });\n  }\n\n  selectOutput(port = 49161) {\n    if (!dgram) { console.warn('UDP', 'Unavailable.'); return; }\n    if (parseInt(port) === this.port) { console.warn('UDP', 'Already selected'); return; }\n    if (isNaN(port) || port < 1000) { console.warn('UDP', 'Unavailable port'); return; }\n\n    console.log('UDP', `Output: ${port}`);\n    this.port = parseInt(port);\n  }\n\n  selectInput(port = 49160) {\n    if (!dgram) { console.warn('UDP', 'Unavailable.'); return; }\n    if (this.listener) { this.listener.close(); }\n\n    console.log('UDP', `Input: ${port}`);\n    this.listener = dgram.createSocket('udp4');\n\n    this.listener.on('message', (msg, rinfo) => {\n      this.client.commander.trigger(`${msg}`);\n    });\n\n    this.listener.on('listening', () => {\n      const address = this.listener.address();\n      console.info('UDP', `Started socket at ${address.address}:${address.port}`);\n    });\n\n    this.listener.on('error', (err) => {\n      console.warn('UDP', `Server error:\\n ${err.stack}`);\n      this.listener.close();\n    });\n\n    this.listener.bind(port);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "wrong_result": "```js\nconst dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = null;\n    this.listener = null;\n    this.client = client;\n  }\n\n  start() {\n    this.selectOutput();\n    this.selectInput();\n  }\n\n  clear() {\n    this.stack.length = 0;\n  }\n\n  run() {\n    while (this.stack.length > 0) {\n      const msg = this.stack.shift();\n      this.play(msg);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (!this.socket || !this.port) return;\n    const message = Buffer.from(data);\n    this.socket.send(message, 0, message.length, this.port, '127.0.0.1', (err) => {\n      if (err) console.error(err);\n    });\n  }\n\n  selectOutput(port = 49161) {\n    this.port = port;\n    this.socket = dgram.createSocket({ type: 'udp4' });\n  }\n\n  selectInput(port = 49160) {\n    this.listener = dgram.createSocket({ type: 'udp4' });\n    this.listener.on('message', (msg, rinfo) => {\n      if (this.client && typeof this.client.handleMessage === 'function') {\n        this.client.handleMessage(msg.toString(), rinfo);\n      }\n    });\n    this.listener.bind(port, () => {\n      console.log(`UDP listener bound to port ${port}`);\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 188,
    "Instruction": "Task Description: Create a UDP-based poller class in JavaScript that can send ping messages to a target UDP server and handle pong responses, with timeout functionality.\n\nClass Description: The UdpPoller class is designed to monitor UDP servers by sending periodic ping messages and listening for pong responses. It inherits from a base poller class and implements UDP communication using Node.js's dgram module.\n\nAttributes:\n- udpServer: [Object] - The UDP socket instance created using dgram module\n- target: [Object/String] - The target server address and port (parsed from input URL)\n- timeout: [Number] - The maximum time to wait for a response before timing out\n- callback: [Function] - The callback function to be executed when a response is received or an error occurs\n\nMethods:\n- constructor(target, timeout, callback) -> [void] - Initializes the poller with target, timeout, and callback\n- static get type() -> [String] - Returns the poller type ('udp')\n- static validateTarget(target) -> [Boolean] - Validates if the target URL matches UDP format\n- initialize() -> [void] - Sets up the UDP socket and parses the target address\n- poll() -> [void] - Sends a ping message to the target server and sets up response listener\n- onResponseCallback(message, sender) -> [void] - Handles incoming messages and processes pong responses\n- timeoutReached() -> [void] - Cleans up socket listeners when timeout occurs",
    "Canonical_solution": "var util = require('util');\nvar dgram = require('dgram');\nvar BasePoller = require('../basePoller');\n\nclass UdpPoller {\n  constructor(target, timeout, callback) {\n    UdpPoller.super_.call(this, target, timeout, callback);\n    this.udpServer = null;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    var reg = new RegExp('udp:\\/\\/(.*):(\\\\d{1,5})');\n    return reg.test(target);\n  }\n\n  initialize() {\n    this.udpServer = dgram.createSocket('udp4');\n    this.udpServer.bind();\n    this.udpServer.on('error', function() {});\n    \n    var reg = new RegExp('udp:\\/\\/(.*):(\\\\d{1,5})');\n    if(!reg.test(this.target)) {\n      console.log(this.target + ' does not seems to be valid udp url');\n    }\n    var host = reg.exec(this.target);\n    this.target = {\n      'address': host[1],\n      'port': host[2]\n    };\n  }\n\n  poll() {\n    var ping = new Buffer(JSON.stringify({'command': 'ping'}));\n    this.udpServer.send(ping, 0, ping.length, this.target.port, this.target.address);\n    this.udpServer.on(\"message\", this.onResponseCallback.bind(this));\n  }\n\n  onResponseCallback(message, sender) {\n    var cmd;\n    try {\n      cmd = JSON.parse(message);\n    } catch (e) {\n      return this.onErrorCallback({ name: \"Unparsable answer\", message: \"server return answer \" + message.toString()});\n    }\n    if (cmd.command === 'pong') {\n      this.timer.stop();\n      this.callback(null, this.getTime(), cmd);\n    }\n  }\n\n  timeoutReached() {\n    this.udpServer.removeAllListeners();\n  }\n}\n\nutil.inherits(UdpPoller, BasePoller);",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "wrong_result": "```javascript\nclass UdpPoller {\n  constructor(target, timeout, callback) {\n    this.udpServer = null;\n    this.target = target;\n    this.timeout = timeout;\n    this.callback = callback;\n    this.initialize();\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    try {\n      const url = new URL(target);\n      return url.protocol === 'udp:';\n    } catch (e) {\n      return false;\n    }\n  }\n\n  initialize() {\n    const { URL } = require('url');\n    const dgram = require('dgram');\n\n    const url = new URL(this.target);\n    this.target = {\n      host: url.hostname,\n      port: parseInt(url.port, 10)\n    };\n\n    this.udpServer = dgram.createSocket('udp4');\n  }\n\n  poll() {\n    const message = Buffer.from('ping');\n    const { host, port } = this.target;\n\n    this.udpServer.send(message, 0, message.length, port, host, (err) => {\n      if (err) {\n        this.callback(err);\n        return;\n      }\n\n      const timer = setTimeout(() => {\n        this.timeoutReached();\n        this.callback(new Error('UDP poll timeout'));\n      }, this.timeout);\n\n      this.udpServer.on('message', (responseMessage, sender) => {\n        clearTimeout(timer);\n        this.onResponseCallback(responseMessage, sender);\n      });\n    });\n  }\n\n  onResponseCallback(message, sender) {\n    if (sender.address === this.target.host && sender.port === this.target.port) {\n      this.callback(null, { data: message.toString(), sender });\n    }\n  }\n\n  timeoutReached() {\n    this.udpServer.removeAllListeners('message');\n  }\n}\n```"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a reusable HTTP client class that simplifies making HTTP requests using Axios, with support for common methods like GET and POST, while handling errors consistently.\n\nClass Description: The HTTPClient class encapsulates Axios functionality to provide a clean interface for making HTTP requests. It maintains headers across requests and provides methods for GET and POST operations with error handling.\n\nAttributes:\n- headers: Object - Contains HTTP headers to be sent with every request\n\nMethods:\n- constructor(headers: Object) -> void - Initializes the HTTP client with default headers\n- get(url: String, params: Object = {}) -> Promise<Object> - Sends a GET request to the specified URL with optional query parameters, returns response data or throws error\n- post(url: String, data: Object = {}, params: Object = {}) -> Promise<Object> - Sends a POST request to the specified URL with optional request body and query parameters, returns response data or throws error",
    "Canonical_solution": "const axios = require('axios');\n\nclass HTTPClient {\n    constructor(headers) {\n        this.headers = headers;\n    }\n\n    async get(url, params = {}) {\n        try {\n            const response = await axios({\n                method: 'get',\n                url: url,\n                headers: this.headers,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('GET request failed:', error);\n            throw error;\n        }\n    }\n\n    async post(url, data = {}, params = {}) {\n        try {\n            const response = await axios({\n                method: 'post',\n                url: url,\n                headers: this.headers,\n                data: data,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('POST request failed:', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass HTTPClient {\n  constructor(headers = {}) {\n    this.headers = headers;\n    this.axiosInstance = axios.create({\n      headers: this.headers\n    });\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await this.axiosInstance.get(url, { params });\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error);\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await this.axiosInstance.post(url, data, { params });\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error);\n    }\n  }\n\n  _handleError(error) {\n    if (error.response) {\n      // The request was made and the server responded with a status code\n      return new Error(`Server responded with status ${error.response.status}: ${error.response.statusText}`);\n    } else if (error.request) {\n      // The request was made but no response was received\n      return new Error('No response received from server');\n    } else {\n      // Something happened in setting up the request that triggered an Error\n      return new Error(`Request error: ${error.message}`);\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a WebSocket-based OrderBook class for managing real-time order book data from a cryptocurrency exchange, with connection management and state handling capabilities.\n\nClass Description: The OrderBook class maintains a real-time order book for a specified trading pair by connecting to a WebSocket feed. It handles connection states, processes incoming messages, and provides event-driven updates. The class inherits from EventEmitter to notify consumers of state changes and order book updates.\n\nAttributes:\n- productID: string - The trading pair identifier (e.g., 'BTC-USD')\n- websocketURI: string - The WebSocket endpoint URL for real-time data\n- restURI: string - The REST API endpoint URL for initial snapshot\n- state: string - Current connection/processing state (from STATES enum)\n- fail_count: number - Count of consecutive connection failures\n- timeProvider: any - Service for timestamp generation\n- socket: WebSocket - The active WebSocket connection instance\n- queue: Array - Buffer for messages received during synchronization\n- book: object - The current order book state with sequence, bids, and asks\n\nMethods:\n- constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) -> OrderBook - Initializes the order book with configuration and starts connection\n- clear_book() -> void - Resets the order book and message queue\n- connect() -> void - Establishes new WebSocket connection with event handlers\n- disconnect() -> void - Closes active WebSocket connection\n- changeState(stateName: string) -> void - Updates state machine and handles transitions (emits statechange event)\n- onOpen() -> void - Handles WebSocket open event (starts synchronization)\n- onClose() -> void - Handles WebSocket close event (updates state)\n- onMessage(datastr: string) -> void - Processes incoming WebSocket messages\n- sync() -> void - Sends subscription message and loads initial snapshot\n- processMessage(message: object, t: Date) -> void - Validates and processes order book updates (emits message-type events)",
    "Canonical_solution": "var WebSocket = require('ws');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nclass OrderBook {\n    constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n        var self = this;\n        EventEmitter.call(self);\n\n        self.productID = productID || 'BTC-USD';\n        self.websocketURI = websocketURI || 'wss://ws-feed.exchange.coinbase.com';\n        self.restURI = restURI;\n        self.state = self.STATES.closed;\n        self.fail_count = 0;\n        self.timeProvider = timeProvider;\n        self.connect();\n    }\n\n    STATES = {\n        'closed': 'closed',\n        'open': 'open',\n        'syncing': 'syncing',\n        'processing': 'processing',\n        'error': 'error',\n    };\n\n    clear_book() {\n        var self = this;\n        self.queue = [];\n        self.book = {\n            'sequence': -1,\n            'bids': {},\n            'asks': {},\n        };\n    };\n\n    connect() {\n        var self = this;\n        if (self.socket) {\n            self.socket.close();\n        }\n        self.clear_book();\n        self.socket = new WebSocket(self.websocketURI);\n        self.socket.on('message', self.onMessage.bind(self));\n        self.socket.on('open', self.onOpen.bind(self));\n        self.socket.on('close', self.onClose.bind(self));\n    };\n\n    disconnect() {\n        var self = this;\n        if (!self.socket) {\n            throw \"Could not disconnect (not connected)\"\n        }\n        self.socket.close();\n        self.onClose();\n    };\n\n    changeState(stateName) {\n        var self = this;\n        var newState = self.STATES[stateName];\n        if (newState === undefined) {\n            throw \"Unrecognized state: \" + stateName;\n        }\n        var oldState = self.state;\n        self.state = newState;\n\n        if (self.fail_count > 3)\n            throw \"Tried to reconnect 4 times. Giving up.\";\n\n        if (self.state === self.STATES.error || self.state === self.STATES.closed) {\n            self.fail_count += 1;\n            self.socket.close();\n            setTimeout(() => self.connect(), 5000);\n        }\n        else if (self.state === self.STATES.processing) {\n            self.fail_count = 0;\n        }\n\n        self.emit('statechange', { 'old': oldState, 'new': newState });\n    };\n\n    onOpen() {\n        var self = this;\n        self.changeState(self.STATES.open);\n        self.sync();\n    };\n\n    onClose() {\n        var self = this;\n        self.changeState(self.STATES.closed);\n    };\n\n    onMessage(datastr: string) {\n        var self = this;\n        var t = self.timeProvider.utcNow();\n        var data = JSON.parse(datastr);\n        if (self.state !== self.STATES.processing) {\n            self.queue.push(data);\n        } else {\n            self.processMessage(data, t);\n        }\n    };\n\n    sync() {\n        var self = this;\n        self.changeState(self.STATES.syncing);\n        var subscribeMessage = {\n            'type': 'subscribe',\n            'product_id': self.productID,\n        };\n        self.socket.send(JSON.stringify(subscribeMessage));\n        self.loadSnapshot();\n    };\n\n    processMessage(message, t: Date) {\n        var self = this;\n        if (message.sequence <= self.book.sequence) {\n            self.emit('ignored', message);\n            return;\n        }\n        if (message.sequence != self.book.sequence + 1) {\n            self.changeState(self.STATES.error);\n        }\n        self.book.sequence = message.sequence;\n\n        self.emit(message.type, new Models.Timestamped(message, t));\n    };\n}\n\nutil.inherits(OrderBook, EventEmitter);",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nconst EventEmitter = require('events');\n\nclass OrderBook extends EventEmitter {\n  static STATES = {\n    DISCONNECTED: 'DISCONNECTED',\n    CONNECTING: 'CONNECTING',\n    SYNCHRONIZING: 'SYNCHRONIZING',\n    SYNCED: 'SYNCED',\n    ERROR: 'ERROR'\n  };\n\n  constructor(productID, websocketURI, restURI, timeProvider) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.timeProvider = timeProvider;\n    this.state = OrderBook.STATES.DISCONNECTED;\n    this.fail_count = 0;\n    this.socket = null;\n    this.queue = [];\n    this.book = {\n      sequence: 0,\n      bids: {},\n      asks: {}\n    };\n    this.connect();\n  }\n\n  clear_book() {\n    this.book = {\n      sequence: 0,\n      bids: {},\n      asks: {}\n    };\n    this.queue = [];\n  }\n\n  connect() {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) return;\n\n    this.changeState(OrderBook.STATES.CONNECTING);\n\n    this.socket = new WebSocket(this.websocketURI);\n\n    this.socket.onopen = () => this.onOpen();\n    this.socket.onclose = () => this.onClose();\n    this.socket.onmessage = (event) => this.onMessage(event.data);\n    this.socket.onerror = (error) => {\n      this.fail_count++;\n      this.changeState(OrderBook.STATES.ERROR);\n      this.emit('error', error);\n    };\n  }\n\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    this.changeState(OrderBook.STATES.DISCONNECTED);\n  }\n\n  changeState(stateName) {\n    const previousState = this.state;\n    this.state = stateName;\n    this.emit('statechange', { previousState, currentState: this.state });\n  }\n\n  onOpen() {\n    this.changeState(OrderBook.STATES.SYNCHRONIZING);\n    this.sync();\n  }\n\n  onClose() {\n    this.changeState(OrderBook.STATES.DISCONNECTED);\n  }\n\n  onMessage(datastr) {\n    try {\n      const message = JSON.parse(datastr);\n      const t = this.timeProvider.now();\n      this.processMessage(message, t);\n    } catch (e) {\n      console.error('Failed to parse or process message:', e);\n    }\n  }\n\n  sync() {\n    // Simulate fetching initial snapshot from REST API\n    fetch(this.restURI)\n      .then(response => response.json())\n      .then(snapshot => {\n        this.book = {\n          ...snapshot,\n          sequence: snapshot.sequence || 0,\n          bids: snapshot.bids || {},\n          asks: snapshot.asks || {}\n        };\n        this.changeState(OrderBook.STATES.SYNCED);\n        this.emit('synced', this.book);\n      })\n      .catch(error => {\n        console.error('Failed to fetch initial snapshot:', error);\n        this.fail_count++;\n        this.changeState(OrderBook.STATES.ERROR);\n        this.emit('error', error);\n      });\n  }\n\n  processMessage(message, t) {\n    if (!message || !message.type) return;\n\n    switch (message.type) {\n      case 'l2update':\n        this.handleL2Update(message, t);\n        break;\n      default:\n        this.emit('unknownMessageType', message);\n    }\n\n    this.emit('message', message, t);\n  }\n\n  handleL2Update(update, timestamp) {\n    if (update.sequence <= this.book.sequence) return;\n\n    for (const [price, size] of Object.entries(update.bids)) {\n      if (size > 0) {\n        this.book.bids[price] = size;\n      } else {\n        delete this.book.bids[price];\n      }\n    }\n\n    for (const [price, size] of Object.entries(update.asks)) {\n      if (size > 0) {\n        this.book.asks[price] = size;\n      } else {\n        delete this.book.asks[price];\n      }\n    }\n\n    this.book.sequence = update.sequence;\n    this.emit('update', this.book, timestamp);\n  }\n}\n```"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a WebSocket-based communication channel class that handles message sending, receiving, and connection management between a client and server.\n\nClass Description: The Channel class manages WebSocket communication by providing methods to send messages, handle incoming messages, and manage connection lifecycle events. It acts as an abstraction layer over raw WebSocket connections.\n\nAttributes:\n- _ws: [WebSocket] - The underlying WebSocket connection instance\n- _handler: [Object|null] - The message handler object that processes incoming messages\n- _messageListener: [Function] - The bound message event listener function\n\nMethods:\n- constructor(ws) -> [void] - Initializes the channel with a WebSocket instance and sets up message listener\n- send(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Closes the WebSocket connection\n- listen(handler) -> [void] - Sets the message handler for incoming messages\n- dispose() -> [void] - Cleans up event listeners\n- _messageReceived(message) -> [void] - Internal method that forwards incoming messages to the handler\n\nTask Description: Create a service class that manages multiple WebSocket connections and sessions for debugging purposes.\n\nClass Description: The NddService class manages multiple debugging sessions through WebSocket connections, handling session creation, connection events, and cleanup.\n\nAttributes:\n- _disconnectPromise: [Promise] - Promise that resolves when the process disconnects\n- _connected: [Set] - Set of currently connected session IDs\n- _frontend: [Object] - Frontend interface for handling session events\n- _pipe: [string] - Path to the named pipe for IPC communication\n\nMethods:\n- constructor(frontend) -> [void] - Initializes the service with frontend interface and sets up IPC server\n- _startSession(info, frontend) -> [Promise<Function>] - Starts a new debugging session and returns a cleanup function\n  - info: [Object] - Session information including inspector URL and ID\n  - frontend: [Object] - Frontend interface for session events\n  - Returns: [Function] - Async cleanup function for the session",
    "Canonical_solution": "const { spawn } = require('child_process');\nconst os = require('os');\nconst path = require('path');\nconst net = require('net');\nconst WebSocket = require('ws');\n\nclass Channel {\n  /**\n   * @param {!WebSocket} ws\n   */\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.on('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  /**\n   * @param {!Object}\n   */\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeListener('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler.dispatchMessage(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => process.once('disconnect', () => resolve()));\n    this._connected = new Set();\n    this._frontend = frontend;\n\n    const pipePrefix = process.platform === 'win32' ? '\\\\\\\\.\\\\pipe\\\\' : os.tmpdir();\n    const pipeName = `node-ndb.${process.pid}.sock`;\n    this._pipe = path.join(pipePrefix, pipeName);\n    const server = net.createServer(socket => {\n      socket.on('data', async d => {\n        const runSession = await this._startSession(JSON.parse(d), frontend);\n        socket.write('run');\n        runSession();\n      });\n      socket.on('error', e => {});\n    }).listen(this._pipe);\n    server.unref();\n  }\n\n  async _startSession(info, frontend) {\n    const ws = new WebSocket(info.inspectorUrl);\n    const openPromise = new Promise(resolve => ws.once('open', () => resolve()));\n    const errorPromise = new Promise(resolve => ws.once('error', () => resolve()));\n    const closePromise = new Promise(resolve => ws.once('close', () => resolve()));\n    let state = await Promise.race([openPromise, errorPromise, closePromise, this._disconnectPromise]);\n    if (state === openPromise) {\n      this._connected.add(info.id);\n      const channel = new Channel(ws);\n      state = await Promise.race([frontend.detected(info, rpc.handle(channel)), this._disconnectPromise]);\n      return async() => {\n        if (state !== this._disconnectPromise)\n          state = await Promise.race([closePromise, errorPromise, this._disconnectPromise]);\n        channel.dispose();\n        this._connected.delete(info.id);\n        if (state !== this._disconnectPromise)\n          frontend.disconnected(info.id);\n        else\n          ws.send(CALL_EXIT_MESSAGE, () => ws.close());\n      };\n    } else {\n      return async function() {};\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nclass Channel {\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._onMessage.bind(this);\n    this._ws.addEventListener('message', this._messageListener);\n  }\n\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(JSON.stringify(message));\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeEventListener('message', this._messageListener);\n    this._handler = null;\n  }\n\n  _onMessage(event) {\n    const message = JSON.parse(event.data);\n    this._messageReceived(message);\n  }\n\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => {\n      this._resolveDisconnect = resolve;\n    });\n    this._connected = new Set();\n    this._frontend = frontend;\n    this._pipe = '';\n    this._setupIPCServer();\n  }\n\n  async _startSession(info, frontend) {\n    const { id: sessionId, inspectorUrl } = info;\n    this._connected.add(sessionId);\n\n    const ws = new WebSocket(inspectorUrl);\n    const channel = new Channel(ws);\n\n    const handleFrontendMessage = (msg) => {\n      if (channel._ws.readyState === WebSocket.OPEN) {\n        channel.send(msg);\n      }\n    };\n\n    frontend.on('message', handleFrontendMessage);\n\n    channel.listen((message) => {\n      frontend.emit('message', message);\n    });\n\n    const cleanup = async () => {\n      frontend.off('message', handleFrontendMessage);\n      channel.dispose();\n      channel.close();\n      this._connected.delete(sessionId);\n      this._resolveDisconnect();\n    };\n\n    return cleanup;\n  }\n\n  _setupIPCServer() {\n    // IPC setup logic goes here\n  }\n}\n```"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a JavaScript class for interacting with the Cryptsy cryptocurrency exchange API, handling both public and private endpoints with proper authentication and request management.\n\nClass Description: The Cryptsy class provides a wrapper for the Cryptsy API, enabling users to make authenticated requests to private endpoints and public data requests. It handles API authentication, request signing, and response processing.\n\nAttributes:\n- key: string - API key for authentication\n- secret: string - API secret for request signing\n- PUBLIC_API_URL: string - Base URL for public API endpoints (default: 'http://pubapi.cryptsy.com/api.php')\n- PRIVATE_API_URL: string - Base URL for private API endpoints (default: 'https://api.cryptsy.com/api')\n- USER_AGENT: string - User agent string for requests (default: 'nomp/node-open-mining-portal')\n- STRICT_SSL: boolean - Static flag for SSL verification (default: true)\n\nMethods:\n- constructor(key, secret) -> Cryptsy - Initializes the API client with credentials\n- _getPrivateHeaders(parameters: object) -> object - Generates authentication headers for private requests\n- _request(options: object, callback: function) -> Cryptsy - Base request method with common configuration\n- _public(parameters: object, callback: function) -> Cryptsy - Makes public API requests\n- _private(parameters: object, callback: function) -> Cryptsy - Makes authenticated private API requests\n- getTicker(callback: function) -> Cryptsy - Gets market ticker data\n- getOrderBook(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets order book for a currency pair\n- getTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets public trade history\n- myBalances(callback: function) -> Cryptsy - Gets user's account balances\n- myOpenOrders(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's open orders\n- myTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's trade history\n- buy(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a buy order\n- sell(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a sell order\n- cancelOrder(currencyA: string, currencyB: string, orderNumber: string, callback: function) -> Cryptsy - Cancels an order\n- withdraw(currency: string, amount: number, address: string, callback: function) -> Cryptsy - Withdraws funds\n- _joinCurrencies(currencyA: string, currencyB: string) -> string - Helper to format currency pairs",
    "Canonical_solution": "var request = require('request');\nvar nonce = require('nonce');\nvar crypto = require('crypto');\n\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n    }\n\n    static STRICT_SSL = true;\n\n    _getPrivateHeaders(parameters) {\n        if (!this.key || !this.secret) {\n            throw 'Cryptsy: Error. API key and secret required';\n        }\n\n        let paramString = Object.keys(parameters).sort().map(function(param) {\n            return encodeURIComponent(param) + '=' + encodeURIComponent(parameters[param]);\n        }).join('&');\n\n        let signature = crypto.createHmac('sha512', this.secret).update(paramString).digest('hex');\n\n        return {\n            Key: this.key,\n            Sign: signature\n        };\n    }\n\n    _request(options, callback) {\n        if (!('headers' in options)) {\n            options.headers = {};\n        }\n\n        options.headers['User-Agent'] = this.USER_AGENT;\n        options.json = true;\n        options.strictSSL = Cryptsy.STRICT_SSL;\n\n        request(options, function(err, response, body) {\n            callback(err, body);\n        });\n\n        return this;\n    }\n\n    _public(parameters, callback) {\n        let options = {\n            method: 'GET',\n            url: this.PUBLIC_API_URL,\n            qs: parameters\n        };\n\n        return this._request(options, callback);\n    }\n\n    _private(parameters, callback) {\n        parameters.nonce = nonce();\n        let options = {\n            method: 'POST',\n            url: this.PRIVATE_API_URL,\n            form: parameters,\n            headers: this._getPrivateHeaders(parameters)\n        };\n\n        return this._request(options, callback);\n    }\n\n    getTicker(callback) {\n        let parameters = {\n            method: 'marketdatav2'\n        };\n        return this._public(parameters, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOrderBook',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    myBalances(callback) {\n        let parameters = {\n            command: 'returnBalances'\n        };\n        return this._private(parameters, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOpenOrders',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'buy',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'sell',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        let parameters = {\n            command: 'cancelOrder',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            orderNumber: orderNumber\n        };\n        return this._private(parameters, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        let parameters = {\n            command: 'withdraw',\n            currency: currency,\n            amount: amount,\n            address: address\n        };\n        return this._private(parameters, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return currencyA + '_' + currencyB;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass Cryptsy {\n  constructor(key, secret) {\n    this.key = key;\n    this.secret = secret;\n    this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n    this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n    this.USER_AGENT = 'nomp/node-open-mining-portal';\n    this.STRICT_SSL = true;\n  }\n\n  _getPrivateHeaders(parameters) {\n    const nonce = Date.now();\n    parameters.nonce = nonce;\n\n    const data = JSON.stringify(parameters);\n    const signature = CryptoJS.HmacSHA512(data, this.secret).toString(CryptoJS.enc.Hex);\n\n    return {\n      'Content-Type': 'application/json',\n      'Key': this.key,\n      'Sign': signature,\n      'User-Agent': this.USER_AGENT\n    };\n  }\n\n  _request(options, callback) {\n    const https = require('https');\n    const http = require('http');\n\n    const lib = options.protocol === 'https:' ? https : http;\n    const req = lib.request(options, (res) => {\n      let data = '';\n      res.on('data', (chunk) => data += chunk);\n      res.on('end', () => {\n        try {\n          const json = JSON.parse(data);\n          callback(null, json);\n        } catch (e) {\n          callback(e, null);\n        }\n      });\n    });\n\n    req.on('error', (e) => callback(e, null));\n\n    if (options.method === 'POST') {\n      req.write(JSON.stringify(options.body));\n    }\n\n    req.end();\n  }\n\n  _public(parameters, callback) {\n    const query = new URLSearchParams(parameters).toString();\n    const options = {\n      protocol: 'http:',\n      hostname: 'pubapi.cryptsy.com',\n      path: `/api.php?${query}`,\n      method: 'GET'\n    };\n\n    this._request(options, callback);\n  }\n\n  _private(parameters, callback) {\n    const headers = this._getPrivateHeaders(parameters);\n    const options = {\n      protocol: 'https:',\n      hostname: 'api.cryptsy.com',\n      path: '/api',\n      method: 'POST',\n      headers: headers\n    };\n\n    options.body = parameters;\n\n    this._request(options, callback);\n  }\n\n  getTicker(callback) {\n    this._public({ method: 'getmarketdata' }, callback);\n  }\n\n  getOrderBook(currencyA, currencyB, callback) {\n    this._public({ method: 'getorderbook', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  getTradeHistory(currencyA, currencyB, callback) {\n    this._public({ method: 'getmarkethistory', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  myBalances(callback) {\n    this._private({ method: 'getinfo' }, callback);\n  }\n\n  myOpenOrders(currencyA, currencyB, callback) {\n    this._private({ method: 'getopenorders', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  myTradeHistory(currencyA, currencyB, callback) {\n    this._private({ method: 'gettradehistory', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  buy(currencyA, currencyB, rate, amount, callback) {\n    this._private({\n      method: 'buylimit',\n      marketid: this._joinCurrencies(currencyA, currencyB),\n      quantity: amount,\n      price: rate\n    }, callback);\n  }\n\n  sell(currencyA, currencyB, rate, amount, callback) {\n    this._private({\n      method: 'selllimit',\n      marketid: this._joinCurrencies(currencyA, currencyB),\n      quantity: amount,\n      price: rate\n    }, callback);\n  }\n\n  cancelOrder(currencyA, currencyB, orderNumber, callback) {\n    this._private({\n      method: 'cancelorder',\n      marketid: this._joinCurrencies(currencyA, currencyB),\n      orderid: orderNumber\n    }, callback);\n  }\n\n  withdraw(currency, amount, address, callback) {\n    this._private({\n      method: 'withdraw',\n      currencyid: currency,\n      amount: amount,\n      address: address\n    }, callback);\n  }\n\n  _joinCurrencies(currencyA, currencyB) {\n    return `${currencyA.toUpperCase()}${currencyB.toUpperCase()}`;\n  }\n}\n```"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a server, sends and receives messages in JSON format, and handles connection events including opening, closing, and errors.\n\nFunction Description: The function `testWebSocketConnection` initiates a WebSocket client connection to a specified server URL. It sends initial messages upon successful connection, listens for incoming messages, and handles connection lifecycle events. The function demonstrates a basic WebSocket interaction pattern including sending/receiving JSON data and proper connection cleanup.\n\nInput: \n- wssUrl: [String] - The WebSocket server URL (without protocol) to connect to (e.g., \"example.com:8080\")\n\nOutput: \n- None (void) - The function doesn't return any value but logs connection status and received messages to the console. All operations are performed through side effects (event handlers and WebSocket operations).",
    "Canonical_solution": "function testWebSocketConnection() {\n  var WebSocket = require('ws');\n  var echoWs = new WebSocket('wss://' + wssUrl + '/examples/echo');\n  \n  echoWs.on('open', function open() {\n    console.log('WebSocket connection established');\n    \n    echoWs.send('hello');\n    echoWs.once('message', function(data, flags) {\n      data = JSON.parse(data);\n      console.log('Received:', data);\n      \n      echoWs.send('{\"foo\": \"bar\"}');\n      echoWs.once('message', function(data, flags) {\n        data = JSON.parse(data);\n        console.log('Received:', data);\n        \n        echoWs.close();\n      });\n    });\n  });\n  \n  echoWs.on('close', function() {\n    console.log('WebSocket connection closed');\n  });\n  \n  echoWs.on('error', function(err) {\n    console.error('WebSocket error:', err);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nfunction testWebSocketConnection(wssUrl) {\n    const socket = new WebSocket(`wss://${wssUrl}`);\n\n    socket.onopen = function(event) {\n        console.log('WebSocket connection opened:', event);\n        const initialMessage = JSON.stringify({ type: 'greeting', content: 'Hello, server!' });\n        socket.send(initialMessage);\n    };\n\n    socket.onmessage = function(event) {\n        try {\n            const messageData = JSON.parse(event.data);\n            console.log('Received message:', messageData);\n        } catch (error) {\n            console.error('Error parsing incoming JSON message:', error);\n        }\n    };\n\n    socket.onclose = function(event) {\n        console.log('WebSocket connection closed:', event);\n    };\n\n    socket.onerror = function(error) {\n        console.error('WebSocket error occurred:', error);\n    };\n}"
  },
  {
    "Task_id": 208,
    "Instruction": "Task Description: Implement a WebSocket transport class for establishing and managing WebSocket connections in a browser or Node.js environment, supporting both binary and text data transmission with configurable options.\n\nClass Description: The WS class extends a base Transport class to provide WebSocket-specific functionality. It handles connection establishment, message transmission, error handling, and connection cleanup, with support for various WebSocket options like binary data, compression, and security settings.\n\nAttributes:\n- supportsBinary: Boolean - Indicates whether the connection supports binary data transmission\n- perMessageDeflate: Object - Configuration for message compression\n- ws: WebSocket - The underlying WebSocket connection instance\n- writable: Boolean - Indicates if the connection is ready to send data\n\nMethods:\n- constructor(opts: Object) -> void - Initializes the WebSocket transport with configuration options\n- doOpen() -> void - Establishes the WebSocket connection and sets up event listeners\n- addEventListeners() -> void - Attaches event handlers for connection events (open, close, message, error)\n- write(packets: Array) -> void - Encodes and sends multiple packets through the WebSocket connection\n- onClose() -> void - Handles connection closure and cleans up resources\n- doClose() -> void - Explicitly closes the WebSocket connection\n- uri() -> String - Generates the WebSocket connection URI with query parameters\n- check() -> Boolean - Verifies WebSocket availability and compatibility\n\nInput:\n- opts: Object - Configuration options including:\n  - forceBase64: Boolean - Forces base64 encoding if binary not supported\n  - perMessageDeflate: Object - Compression settings\n  - agent: Object - Custom HTTP agent\n  - pfx: String - SSL PFX certificate\n  - key: String - SSL key\n  - passphrase: String - SSL passphrase\n  - cert: String - SSL certificate\n  - ca: Array - SSL certificate authorities\n  - ciphers: String - SSL cipher suite\n  - rejectUnauthorized: Boolean - SSL verification setting\n  - extraHeaders: Object - Additional HTTP headers\n  - secure: Boolean - Use secure protocol (wss)\n  - port: Number - Custom port number\n  - timestampRequests: Boolean - Add timestamp to requests\n  - timestampParam: String - Parameter name for timestamp\n  - hostname: String - Server hostname\n  - path: String - WebSocket endpoint path\n  - query: Object - Additional query parameters\n\nOutput:\n- Instance of WS class with established WebSocket connection and configured event handlers",
    "Canonical_solution": "var Transport = require('../transport');\nvar parser = require('engine.io-parser');\nvar parseqs = require('parseqs');\nvar inherit = require('component-inherit');\nvar yeast = require('yeast');\nvar debug = require('debug')('engine.io-client:websocket');\nvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\n\nvar WebSocket = BrowserWebSocket;\nif (!WebSocket && typeof window === 'undefined') {\n  try {\n    WebSocket = require('ws');\n  } catch (e) { }\n}\n\nfunction WS(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  this.perMessageDeflate = opts.perMessageDeflate;\n  Transport.call(this, opts);\n}\n\ninherit(WS, Transport);\n\nWS.prototype.name = 'websocket';\nWS.prototype.supportsBinary = true;\n\nWS.prototype.doOpen = function(){\n  if (!this.check()) {\n    return;\n  }\n\n  var self = this;\n  var uri = this.uri();\n  var protocols = void(0);\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  };\n\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n\n  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'buffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n\nWS.prototype.addEventListeners = function(){\n  var self = this;\n\n  this.ws.onopen = function(){\n    self.onOpen();\n  };\n  this.ws.onclose = function(){\n    self.onClose();\n  };\n  this.ws.onmessage = function(ev){\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function(e){\n    self.onError('websocket error', e);\n  };\n};\n\nWS.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n\n  var total = packets.length;\n  for (var i = 0, l = total; i < l; i++) {\n    (function(packet) {\n      parser.encodePacket(packet, self.supportsBinary, function(data) {\n        if (!BrowserWebSocket) {\n          var opts = {};\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        }\n\n        try {\n          if (BrowserWebSocket) {\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e){\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done(){\n    self.emit('flush');\n    setTimeout(function(){\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n\nWS.prototype.onClose = function(){\n  Transport.prototype.onClose.call(this);\n};\n\nWS.prototype.doClose = function(){\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\nWS.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  if (this.port && (('wss' == schema && this.port != 443)\n    || ('ws' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\nWS.prototype.check = function(){\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nclass WS extends Transport {\n  constructor(opts) {\n    super();\n    this.opts = opts;\n    this.supportsBinary = !opts.forceBase64;\n    this.perMessageDeflate = opts.perMessageDeflate || false;\n    this.writable = false;\n    this.check();\n  }\n\n  doOpen() {\n    if (!this.checked) return;\n    if (typeof WebSocket !== \"undefined\") {\n      this.ws = new WebSocket(this.uri(), this.opts.protocol);\n      this.addEventListeners();\n    } else {\n      this.onError(new Error(\"WebSocket is not supported in this environment\"));\n    }\n  }\n\n  addEventListeners() {\n    this.ws.binaryType = this.supportsBinary ? \"arraybuffer\" : \"base64\";\n    this.onOpen = this.onOpen.bind(this);\n    this.onClose = this.onClose.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n    this.onError = this.onError.bind(this);\n\n    this.ws.addEventListener(\"open\", this.onOpen);\n    this.ws.addEventListener(\"close\", this.onClose);\n    this.ws.addEventListener(\"message\", this.onMessage);\n    this.ws.addEventListener(\"error\", this.onError);\n  }\n\n  write(packets) {\n    for (let i = 0; i < packets.length; i++) {\n      const packet = packets[i];\n      if (!this.writable) {\n        this.once(\"drain\", () => this.write([packet]));\n        break;\n      }\n      if (packet.options && packet.options.compress) {\n        // Implement compression logic here if needed\n      }\n      if (typeof packet.data === \"string\") {\n        this.ws.send(packet.data);\n      } else if (this.supportsBinary) {\n        this.ws.send(packet.data.buffer || packet.data);\n      } else {\n        // Fallback to base64 encoding\n        const binaryData = Array.from(new Uint8Array(packet.data)).map(b => String.fromCharCode(b)).join(\"\");\n        this.ws.send(btoa(binaryData));\n      }\n    }\n    this.writable = this.ws.bufferedAmount === 0;\n    if (this.writable) this.emit(\"drain\");\n  }\n\n  onClose() {\n    this.writable = false;\n    this.emit(\"close\");\n    this.removeAllListeners();\n  }\n\n  doClose() {\n    if (this.ws) {\n      try {\n        this.ws.close();\n      } catch (e) {\n        console.warn(\"Failed to close WebSocket:\", e);\n      }\n    }\n  }\n\n  uri() {\n    let uri = this.opts.secure ? \"wss://\" : \"ws://\";\n    uri += this.opts.hostname;\n    if (this.opts.port && (this.opts.secure && this.opts.port !== 443 || !this.opts.secure && this.opts.port !== 80)) {\n      uri += `:${this.opts.port}`;\n    }\n    uri += this.opts.path;\n    if (this.opts.query) {\n      const query = Object.entries(this.opts.query).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join(\"&\");\n      uri += `?${query}`;\n    }\n    return uri;\n  }\n\n  check() {\n    if (typeof WebSocket === \"undefined\") {\n      this.checked = true;\n      this.emit(\"error\", new Error(\"WebSocket is not supported in this environment\"));\n      return;\n    }\n    this.checked = true;\n    this.doOpen();\n  }\n}\n```"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using HTTP POST request with error handling.\n\nFunction Description: The function `sendWebhook` is an asynchronous function that takes data as input and sends it to a predefined webhook URL using an HTTP POST request. It handles potential errors during the request and logs them to the console.\n\nInput: \n- `data` [Object] - The payload/data to be sent to the webhook URL.\n\nOutput: \n- None (The function does not return any value, but it may log errors to the console if the request fails).",
    "Canonical_solution": "const axios = require('axios');\n\nconst sendWebhook = async (data) => {\n    try {\n        await axios.post(process.env.UPDATE_WEBHOOK, data);\n    } catch (err) {\n        console.log(err);\n    }\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function sendWebhook(data) {\n    const webhookUrl = 'https://example.com/webhook'; // Replace with actual webhook URL\n\n    try {\n        const response = await fetch(webhookUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n    } catch (error) {\n        console.error('Error sending webhook:', error);\n    }\n}\n```"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a function that interacts with Microsoft's Speech API to convert SSML (Speech Synthesis Markup Language) text into speech audio using HTTP requests.\n\nFunction Description: The function `speechApi` sends a POST request to Microsoft's Speech API endpoint with SSML text as input and receives audio data in MP3 format as response. It handles the HTTP communication including request configuration, headers, payload, and error handling.\n\nInput: \n- ssml: [String] - The SSML formatted text to be converted to speech\n\nOutput: \n- [Promise] - Resolves with the audio data in arraybuffer format if successful, rejects with error if the request fails",
    "Canonical_solution": "const axios = require(\"axios\");\nconst { v4: uuidv4 } = require(\"uuid\");\n\nfunction speechApi(ssml) {\n    var data = JSON.stringify({\n        ssml,\n        ttsAudioFormat: \"audio-24khz-160kbitrate-mono-mp3\",\n        offsetInPlainText: 0,\n        properties: {\n            SpeakTriggerSource: \"AccTuningPagePlayButton\",\n        },\n    });\n\n    var config = {\n        method: \"post\",\n        url: \"https://southeastasia.api.speech.microsoft.com/accfreetrial/texttospeech/acc/v3.0-beta1/vcg/speak\",\n        responseType: \"arraybuffer\",\n        headers: {\n            authority: \"southeastasia.api.speech.microsoft.com\",\n            accept: \"*/*\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            customvoiceconnectionid: uuidv4(),\n            origin: \"https://speech.microsoft.com\",\n            \"sec-ch-ua\": '\"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-site\",\n            \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\",\n            \"content-type\": \"application/json\",\n        },\n        data: data,\n    };\n\n    return new Promise((resolve, reject) => {\n        axios(config)\n            .then(function(response) {\n                resolve(response.data);\n            })\n            .catch(function(error) {\n                console.error(error);\n                reject(error);\n            });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nfunction speechApi(ssml) {\n  const subscriptionKey = 'YOUR_SUBSCRIPTION_KEY';\n  const region = 'YOUR_REGION';\n  const endpoint = `https://${region}.tts.speech.microsoft.com/cognitiveservices/v1`;\n\n  const headers = new Headers();\n  headers.append('Ocp-Apim-Subscription-Key', subscriptionKey);\n  headers.append('Content-Type', 'application/ssml+xml');\n  headers.append('X-Microsoft-OutputFormat', 'audio-16khz-128kbitrate-mono-mp3');\n\n  const requestOptions = {\n    method: 'POST',\n    headers: headers,\n    body: ssml,\n    redirect: 'follow'\n  };\n\n  return fetch(endpoint, requestOptions)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return response.arrayBuffer();\n    });\n}\n```"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a WebSocket client connection class for browser environments that handles connection lifecycle, message events, and window focus state tracking.\n\nClass Description: The BrowserConnection class manages a WebSocket connection in a browser environment, including connection setup, event handling, and window visibility tracking. It extends a base connection class (BaseConnection) and adds browser-specific functionality.\n\nAttributes:\n- focusDetectorTimer: [Number] - Timer ID for the focus detection interval\n- windowVisible: [Boolean] - Tracks whether the browser window is currently visible\n- socket: [WebSocket] - The WebSocket connection instance\n\nMethods:\n- constructor(opts: Object) -> void - Initializes the connection with options and sets up event listeners for 'ready' and 'disconnect' events\n- setupSocket() -> WebSocket - Creates and configures a new WebSocket connection with event handlers for open, close, and message events\n- startFocusLoop() -> void - Starts tracking window visibility by setting up event listeners for focus/blur events and periodic checks\n- stopFocusLoop() -> void - Stops the window visibility tracking by clearing the interval timer and removing event listeners\n- handleOpen() -> void - Inherited from BaseConnection, called when WebSocket connection opens\n- handleClose(code: Number, reason: String) -> void - Inherited from BaseConnection, called when WebSocket connection closes\n- handleData(data: String) -> void - Inherited from BaseConnection, called when WebSocket receives a message\n- reportFocus(isVisible: Boolean) -> void - Inherited from BaseConnection, reports current window focus state",
    "Canonical_solution": "var WebSocket = require(\"ws\");\nvar _ = require(\"underscore\");\n\nclass BrowserConnection {\n  constructor(opts) {\n    BaseConnection.call(this, opts);\n    var connection = this;\n    this.on(\"ready\", function() {\n      connection.startFocusLoop()\n    });\n    this.on(\"disconnect\", function() {\n      connection.stopFocusLoop()\n    });\n  }\n\n  setupSocket() {\n    var connection = this;\n    var socket = new WebSocket(this.getUrl());\n    socket.onopen = function() {\n      connection.handleOpen()\n    };\n    socket.onclose = function(data) {\n      connection.handleClose(data[\"code\"], data[\"reason\"])\n    };\n    socket.onmessage = function(message) {\n      connection.handleData(message.data)\n    };\n    return socket;\n  }\n\n  startFocusLoop() {\n    if (this.focusDetectorTimer) return;\n    var connection = this;\n    var propertyName = null;\n    if (typeof document.hidden !== \"undefined\") {\n      propertyName = \"hidden\"\n    } else if (typeof document.mozHidden !== \"undefined\") {\n      propertyName = \"mozHidden\"\n    } else if (typeof document.msHidden !== \"undefined\") {\n      propertyName = \"msHidden\"\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n      propertyName = \"webkitHidden\"\n    } else {\n      propertyName = undefined\n    }\n    if (connection.windowVisible === undefined) {\n      connection.windowVisible = propertyName === undefined ? true : document[propertyName] === false\n    }\n    var focusListener = window.addEventListener(\"focus\", function(e) {\n      connection.windowVisible = true;\n      updateFocusState()\n    });\n    var blurListener = window.addEventListener(\"blur\", function(e) {\n      connection.windowVisible = false;\n      updateFocusState()\n    });\n    this.on(\"disconnect\", function() {\n      window.removeEventListener(\"focus\", focusListener);\n      window.removeEventListener(\"blur\", blurListener)\n    });\n    var updateFocusState = function() {\n      var isVisible = propertyName === undefined ? true : document[propertyName] === false;\n      connection.reportFocus(isVisible && connection.windowVisible)\n    };\n    this.focusDetectorTimer = setInterval(updateFocusState, 100)\n  }\n\n  stopFocusLoop() {\n    if (!this.focusDetectorTimer) return;\n    clearTimeout(this.focusDetectorTimer);\n    delete this.focusDetectorTimer;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nclass BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super();\n    this.opts = opts;\n    this.focusDetectorTimer = null;\n    this.windowVisible = true;\n    this.socket = null;\n\n    this.on('ready', () => this.startFocusLoop());\n    this.on('disconnect', () => this.stopFocusLoop());\n  }\n\n  setupSocket() {\n    const { url } = this.opts;\n    this.socket = new WebSocket(url);\n\n    this.socket.addEventListener('open', () => this.handleOpen());\n\n    this.socket.addEventListener('close', (event) => {\n      this.handleClose(event.code, event.reason);\n    });\n\n    this.socket.addEventListener('message', (event) => {\n      this.handleData(event.data);\n    });\n\n    return this.socket;\n  }\n\n  startFocusLoop() {\n    window.addEventListener('focus', () => this.reportFocus(true));\n    window.addEventListener('blur', () => this.reportFocus(false));\n\n    this.focusDetectorTimer = setInterval(() => {\n      const isVisible = !document.hidden;\n      if (this.windowVisible !== isVisible) {\n        this.windowVisible = isVisible;\n        this.reportFocus(isVisible);\n      }\n    }, 5000);\n  }\n\n  stopFocusLoop() {\n    window.removeEventListener('focus', () => this.reportFocus(true));\n    window.removeEventListener('blur', () => this.reportFocus(false));\n    clearInterval(this.focusDetectorTimer);\n  }\n\n  handleOpen() {\n    super.handleOpen();\n  }\n\n  handleClose(code, reason) {\n    super.handleClose(code, reason);\n  }\n\n  handleData(data) {\n    super.handleData(data);\n  }\n\n  reportFocus(isVisible) {\n    super.reportFocus(isVisible);\n  }\n}\n```"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a class that serves as an HTTP client for interacting with a build service API, handling different types of package-related operations with proper error handling.\n\nClass Description: The BuildService class provides methods to fetch package build statistics, exports, and export sizes from a remote build service. It uses Axios for HTTP requests and implements centralized error handling.\n\nAttributes:\n- operations: [Array] - A predefined list of available API operations, each specifying the operation type, endpoint, and corresponding method name\n\nMethods:\n- _makeHttpRequest: [Name](operation: Object, packageString: String) -> Promise<Object> - Makes an HTTP GET request to the build service with the specified operation and package string, handles the response and errors\n- _handleError: [Name](error: Error, operationType: String) -> Throws CustomError - Centralized error handling that processes different types of errors (response errors, request errors, and other errors) and throws appropriate custom errors\n- getPackageBuildStats: [Name](packageString: String) -> Promise<Object> - Retrieves build statistics for the specified package\n- getPackageExports: [Name](packageString: String) -> Promise<Object> - Retrieves all exports for the specified package\n- getPackageExportSizes: [Name](packageString: String) -> Promise<Object> - Retrieves size information for all exports of the specified package",
    "Canonical_solution": "const axios = require('axios');\nconst CustomError = require('../CustomError');\n\nclass BuildService {\n  constructor() {\n    this.operations = [\n      {\n        type: 'PACKAGE_BUILD_STATS',\n        endpoint: '/size',\n        methodName: 'getPackageStats',\n      },\n      {\n        type: 'PACKAGE_EXPORTS',\n        endpoint: '/exports',\n        methodName: 'getAllPackageExports',\n      },\n      {\n        type: 'PACKAGE_EXPORTS_SIZES',\n        endpoint: '/exports-sizes',\n        methodName: 'getPackageExportSizes',\n      },\n    ];\n  }\n\n  async _makeHttpRequest(operation, packageString) {\n    try {\n      const response = await axios.get(\n        `${process.env.BUILD_SERVICE_ENDPOINT}${operation.endpoint}?p=${encodeURIComponent(packageString)}`\n      );\n      return response.data;\n    } catch (error) {\n      this._handleError(error, operation.type);\n    }\n  }\n\n  _handleError(error, operationType) {\n    if (error.response) {\n      const contents = error.response.data;\n      throw new CustomError(\n        contents.name || 'BuildError',\n        contents.originalError,\n        contents.extra\n      );\n    } else if (error.request) {\n      throw new CustomError('BuildError', {\n        operation: operationType,\n        reason: 'BUILD_SERVICE_UNREACHABLE',\n        url: error.request._currentUrl,\n      });\n    } else {\n      throw new CustomError('BuildError', error.message, {\n        operation: operationType,\n      });\n    }\n  }\n\n  async getPackageBuildStats(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_BUILD_STATS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExports(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExportSizes(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS_SIZES');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass BuildService {\n  constructor() {\n    this.operations = [\n      { type: 'buildStats', endpoint: '/api/packages/build-stats', method: 'getPackageBuildStats' },\n      { type: 'exports', endpoint: '/api/packages/exports', method: 'getPackageExports' },\n      { type: 'exportSizes', endpoint: '/api/packages/export-sizes', method: 'getPackageExportSizes' }\n    ];\n  }\n\n  async _makeHttpRequest(operation, packageString) {\n    const config = { params: { package: packageString } };\n    try {\n      const response = await axios.get(`${operation.endpoint}`, config);\n      return response.data;\n    } catch (error) {\n      this._handleError(error, operation.type);\n    }\n  }\n\n  _handleError(error, operationType) {\n    if (error.response) {\n      throw new CustomError(`Build service API error for ${operationType}: ${error.response.status} - ${error.response.statusText}`, error.response.status);\n    } else if (error.request) {\n      throw new CustomError(`No response received from build service for ${operationType}.`, 504);\n    } else {\n      throw new CustomError(`An error occurred while processing the ${operationType} request: ${error.message}`, 500);\n    }\n  }\n\n  getPackageBuildStats(packageString) {\n    const operation = this.operations.find(op => op.method === 'getPackageBuildStats');\n    return this._makeHttpRequest(operation, packageString);\n  }\n\n  getPackageExports(packageString) {\n    const operation = this.operations.find(op => op.method === 'getPackageExports');\n    return this._makeHttpRequest(operation, packageString);\n  }\n\n  getPackageExportSizes(packageString) {\n    const operation = this.operations.find(op => op.method === 'getPackageExportSizes');\n    return this._makeHttpRequest(operation, packageString);\n  }\n}\n\nclass CustomError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n  }\n}\n```"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with reconnection capabilities and event handling.\n\nClass Description: The N class represents a WebSocket client that connects to a specified URL, handles connection events, manages reconnection logic, and forwards received messages to a destination. It provides methods to start, destroy, and manage the WebSocket connection.\n\nAttributes:\n\nurl: [String] - The WebSocket server URL to connect to.\noptions: [Object] - Configuration options for the WebSocket connection.\nsocket: [WebSocket|null] - The WebSocket connection instance.\nstreaming: [Boolean] - Indicates if the connection is actively streaming.\ncallbacks: [Object] - Stores event callbacks for connect and data events.\ndestination: [Object|null] - The target to forward received messages to.\nreconnectInterval: [Number] - Time interval (in seconds) between reconnection attempts.\nshouldAttemptReconnect: [Boolean] - Flag to control reconnection behavior.\ncompleted: [Boolean] - Indicates if the connection has completed its purpose.\nestablished: [Boolean] - Indicates if the connection is successfully established.\nprogress: [Number] - Tracks connection progress (0-1).\nreconnectTimeoutId: [Number] - Timeout ID for reconnection attempts.\nonEstablishedCallback: [Function|null] - Callback when connection is established.\nonCompletedCallback: [Function|null] - Callback when connection is completed.\nhookOnEstablished: [Function|null] - Additional hook for established event.\n\nMethods:\n\nconstructor(url, options) -> [N] - Initializes the WebSocket client with the given URL and options.\nconnect(destination) -> [void] - Sets the destination for received messages.\ndestroy() -> [void] - Closes the WebSocket connection and stops reconnection attempts.\nstart() -> [void] - Initiates the WebSocket connection with event handlers.\nresume() -> [void] - Placeholder for resuming functionality (currently empty).\nonOpen() -> [void] - Handles WebSocket open event, sets progress to 1.\nonClose() -> [void] - Handles WebSocket close/error events, initiates reconnection if enabled.\nonMessage(event) -> [void] - Handles incoming messages, triggers established callbacks, and forwards data to destination.",
    "Canonical_solution": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = true;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = void 0 !== options.reconnectInterval ? options.reconnectInterval : 5;\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = options.onSourceEstablished;\n    this.onCompletedCallback = options.onSourceCompleted;\n    options.hookOnEstablished && (this.hookOnEstablished = options.hookOnEstablished);\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.shouldAttemptReconnect = false;\n    this.socket.close();\n  }\n\n  start() {\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.progress = 0;\n    this.established = false;\n    this.options.protocols \n      ? this.socket = new WebSocket(this.url, this.options.protocols)\n      : this.socket = new WebSocket(this.url);\n    \n    this.socket.binaryType = \"arraybuffer\";\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n  }\n\n  onClose() {\n    if (this.shouldAttemptReconnect) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, 1000 * this.reconnectInterval);\n    }\n  }\n\n  onMessage(event) {\n    const wasFirstMessage = !this.established;\n    this.established = true;\n    \n    if (wasFirstMessage && this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n    \n    if (wasFirstMessage && this.onEstablishedCallback) {\n      this.onEstablishedCallback(this);\n    }\n    \n    if (this.destination) {\n      this.destination.write(event.data);\n    }\n  }\n}\n\n// External dependencies\nconst WebSocket = window.WebSocket;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nclass N {\n  constructor(url, options = {}) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n    this.start();\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.shouldAttemptReconnect = false;\n    clearTimeout(this.reconnectTimeoutId);\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url, this.options.protocol || undefined);\n\n    this.socket.addEventListener('open', () => this.onOpen());\n    this.socket.addEventListener('message', (event) => this.onMessage(event));\n    this.socket.addEventListener('close', () => this.onClose());\n    this.socket.addEventListener('error', () => this.onClose());\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n    this.established = true;\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.established = false;\n    if (!this.completed && this.shouldAttemptReconnect) {\n      this.reconnectTimeoutId = setTimeout(() => this.start(), this.reconnectInterval * 1000);\n    } else if (this.onCompletedCallback) {\n      this.onCompletedCallback();\n    }\n  }\n\n  onMessage(event) {\n    if (!this.established) {\n      this.onOpen();\n    }\n    const data = event.data;\n    if (this.destination) {\n      this.destination.postMessage(data);\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Write a function that retrieves TV channel data from a specified URL, processes the data to extract relevant channel information, and returns it in a structured format.\n\nFunction Description: The function `getChannels` asynchronously fetches TV channel data from a remote API endpoint using HTTP GET request. It processes the response to extract channel details such as language, site ID, and name, then returns them as an array of objects. Error handling is included to log any issues during the request.\n\nInput: None (The function does not take any input parameters; it uses a hardcoded URL for the API endpoint.)\n\nOutput: An array of objects, where each object represents a TV channel with the following properties:\n- `lang`: [String] - The language of the channel (e.g., 'lv').\n- `site_id`: [String] - The unique identifier/slug for the channel.\n- `name`: [String] - The display name of the channel.\n\nIf an error occurs during the HTTP request, the error will be logged to the console, and the function may return an empty array or undefined depending on the error handling flow.",
    "Canonical_solution": "async function getChannels() {\n    const axios = require('axios');\n    const groups = await axios\n        .get('https://www.tv.lv/data/channels/lvall')\n        .then(r => r.data)\n        .catch(console.log);\n\n    let channels = [];\n\n    groups.forEach(group => {\n        group.channels.forEach(item => {\n            channels.push({\n                lang: 'lv',\n                site_id: item.slug,\n                name: item.name\n            });\n        });\n    });\n\n    return channels;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function getChannels() {\n    const url = 'https://api.example.com/tv-channels';\n\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        const data = await response.json();\n        return data.map(channel => ({\n            lang: channel.lang || '',\n            site_id: channel.site_id || '',\n            name: channel.name || ''\n        }));\n    } catch (error) {\n        console.error('Error fetching TV channels:', error.message);\n        return [];\n    }\n}\n```"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes a connection to a server, handles incoming messages, manages connection errors, and provides functionality to close the connection.\n\nClass Description: The WebSocketClient class encapsulates WebSocket functionality for establishing and managing a WebSocket connection. It handles connection events, message reception, and error scenarios, while providing a clean interface for external message handling through a callback.\n\nAttributes:\n- url: [String] - The server URL to connect to (without protocol)\n- actionId: [String] - An identifier for the specific WebSocket action/channel\n- onMessageCallback: [Function] - Callback function to handle incoming messages\n- socket: [WebSocket|null] - Reference to the WebSocket connection instance\n- initData: [Boolean] - Flag indicating whether initial data has been received\n- WebSocket: [WebSocket|null] - Alias for the socket instance (set after successful connection)\n\nMethods:\n- constructor(url, actionId, onMessageCallback) -> [void] - Initializes the WebSocketClient with connection URL, action ID, and message callback\n- connect() -> [void] - Establishes the WebSocket connection and sets up event handlers\n- close() -> [void] - Closes the WebSocket connection if it exists",
    "Canonical_solution": "import axios from 'axios';\n\nclass WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n  }\n\n  connect() {\n    try {\n      this.socket = new WebSocket(\n        `${location.protocol === 'https:' ? 'wss' : 'ws'}://${this.url}/api/interface/solve_conflict?id=${this.actionId}`\n      );\n\n      this.socket.onopen = () => {\n        this.WebSocket = this.socket;\n      };\n\n      this.socket.onmessage = (e) => {\n        this.initData = true;\n        const result = JSON.parse(e.data);\n        this.onMessageCallback(result);\n      };\n\n      this.socket.onerror = () => {\n        console.warn('websocket \u8fde\u63a5\u5931\u8d25\uff0c\u5c06\u5bfc\u81f4\u591a\u4eba\u7f16\u8f91\u540c\u4e00\u4e2a\u63a5\u53e3\u51b2\u7a81\u3002');\n      };\n\n    } catch (e) {\n      console.error('websocket \u8fde\u63a5\u5931\u8d25\uff0c\u5c06\u5bfc\u81f4\u591a\u4eba\u7f16\u8f91\u540c\u4e00\u4e2a\u63a5\u53e3\u51b2\u7a81\u3002');\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nclass WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n    this.WebSocket = null;\n  }\n\n  connect() {\n    const fullUrl = `wss://${this.url}/?actionId=${this.actionId}`;\n    this.socket = new WebSocket(fullUrl);\n\n    this.socket.addEventListener('open', () => {\n      this.WebSocket = this.socket;\n      console.log('WebSocket connection established.');\n    });\n\n    this.socket.addEventListener('message', (event) => {\n      const message = event.data;\n      if (!this.initData) {\n        this.initData = true;\n      }\n      if (typeof this.onMessageCallback === 'function') {\n        this.onMessageCallback(message);\n      }\n    });\n\n    this.socket.addEventListener('error', (error) => {\n      console.error('WebSocket error:', error);\n    });\n\n    this.socket.addEventListener('close', (event) => {\n      console.log(`WebSocket closed with code ${event.code}: ${event.reason}`);\n      this.socket = null;\n      this.WebSocket = null;\n    });\n  }\n\n  close() {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.close();\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a WebSocket server class in Node.js that handles client connections, message processing, and subscription management for real-time communication.\n\nClass Description: The AphlictClientServer class implements a WebSocket server that manages client connections, processes incoming messages (including subscriptions, replays, and pings), and maintains listener lists for different instances. It's built on top of Node.js's HTTP server and ws WebSocket library.\n\nAttributes:\n- _server: [Object] - The underlying HTTP server instance\n- _lists: [Object] - Dictionary storing listener lists for different instances\n- _adminServers: [Array] - Array containing admin server references\n\nMethods:\n- constructor(server) -> [void] - Initializes the server instance and sets up request handling\n- _onrequest(request, response) -> [void] - Handles HTTP requests (returns 501 as this is a WebSocket server)\n- _parseInstanceFromPath(path) -> [String] - Extracts instance name from URL path\n- listen() -> [void] - Starts the WebSocket server and sets up connection handlers\n- getListenerList(instance) -> [Object] - Returns the listener list for a given instance (implied by usage)\n- log(message) -> [void] - Logs messages (implied by usage)\n- trace(message) -> [void] - Logs trace-level messages (implied by usage)\n- getHistory(min_age) -> [Array] - Returns historical messages (implied by usage in replay handler)\n\nThe class handles WebSocket connections with the following behaviors:\n1. Parses instance names from connection URLs\n2. Manages listener subscriptions/unsubscriptions\n3. Handles message replay requests\n4. Processes ping/pong messages\n5. Logs connection/disconnection events\n6. Maintains separate listener lists for different instances",
    "Canonical_solution": "var url = require('url');\nvar util = require('util');\nvar WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    server.on('request', this._onrequest.bind(this));\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end('HTTP/501 Use Websockets\\n');\n  }\n\n  _parseInstanceFromPath(path) {\n    if (path.indexOf('~') === -1) {\n      return 'default';\n    }\n\n    var instance = path.split('~')[1];\n    instance = instance.replace(/\\//g, '');\n    if (!instance.length) {\n      return 'default';\n    }\n\n    return instance;\n  }\n\n  listen() {\n    var self = this;\n    var server = this._server.listen.apply(this._server, arguments);\n    var wss = new WebSocket.Server({server: server});\n\n    wss.on('connection', function(ws, request) {\n      if ('upgradeReq' in ws) {\n        request = ws.upgradeReq;\n      }\n\n      var path = url.parse(request.url).pathname;\n      var instance = self._parseInstanceFromPath(path);\n\n      var listener = self.getListenerList(instance).addListener(ws);\n\n      function msg(argv) {\n        return util.format('<%s>', listener.getDescription()) +\n          ' ' +\n          util.format.apply(null, argv);\n      }\n\n      function log() {\n        self.log(msg(arguments));\n      }\n\n      function trace() {\n        self.trace(msg(arguments));\n      }\n\n      trace('Connected from %s.', ws._socket.remoteAddress);\n\n      ws.on('message', function(data) {\n        trace('Received message: %s', data);\n\n        var message;\n        try {\n          message = JSON.parse(data);\n        } catch (err) {\n          log('Message is invalid: %s', err.message);\n          return;\n        }\n\n        switch (message.command) {\n          case 'subscribe':\n            trace(\n              'Subscribed to: %s',\n              JSON.stringify(message.data));\n            listener.subscribe(message.data);\n            break;\n\n          case 'unsubscribe':\n            trace(\n              'Unsubscribed from: %s',\n              JSON.stringify(message.data));\n            listener.unsubscribe(message.data);\n            break;\n\n          case 'replay':\n            var age = message.data.age || 60000;\n            var min_age = (new Date().getTime() - age);\n\n            var old_messages = self.getHistory(min_age);\n            for (var ii = 0; ii < old_messages.length; ii++) {\n              var old_message = old_messages[ii];\n\n              if (!listener.isSubscribedToAny(old_message.subscribers)) {\n                continue;\n              }\n\n              try {\n                listener.writeMessage(old_message);\n              } catch (error) {\n                break;\n              }\n            }\n            break;\n\n          case 'ping':\n            var pong = {\n              type: 'pong'\n            };\n\n            try {\n              listener.writeMessage(pong);\n            } catch (error) {\n              // Ignore any issues here, we'll clean up elsewhere.\n            }\n            break;\n\n          default:\n            log(\n              'Unrecognized command \"%s\".',\n              message.command || '<undefined>');\n        }\n      });\n\n      ws.on('close', function() {\n        self.getListenerList(instance).removeListener(listener);\n        trace('Disconnected.');\n      });\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "```js\nclass AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n\n    this._server.on('request', (request, response) => this._onrequest(request, response));\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end();\n  }\n\n  _parseInstanceFromPath(path) {\n    const match = path.match(/^\\/([^\\/?#]+)(?:[\\/?#]|$)/);\n    return match ? decodeURIComponent(match[1]) : null;\n  }\n\n  listen() {\n    const wss = new (require('ws')).Server({ server: this._server });\n\n    wss.on('connection', (ws, request) => {\n      const instance = this._parseInstanceFromPath(request.url);\n      if (!instance) {\n        ws.close(4000, 'Invalid instance');\n        return;\n      }\n\n      const list = this.getListenerList(instance);\n      let clientId = null;\n\n      this.trace(`New connection for instance \"${instance}\"`);\n\n      ws.on('message', (data) => {\n        try {\n          const message = JSON.parse(data);\n          if (message.type === 'subscribe') {\n            clientId = message.clientId;\n            list.add(clientId, ws);\n            this.log(`Subscribed client ${clientId} to instance \"${instance}\"`);\n          } else if (message.type === 'unsubscribe') {\n            list.remove(clientId);\n            this.log(`Unsubscribed client ${clientId} from instance \"${instance}\"`);\n          } else if (message.type === 'replay') {\n            const history = this.getHistory(message.minAge || 0);\n            ws.send(JSON.stringify({ type: 'replay', messages: history }));\n          } else if (message.type === 'ping') {\n            ws.send(JSON.stringify({ type: 'pong' }));\n          }\n        } catch (e) {\n          this.log(`Error processing message: ${e.message}`);\n        }\n      });\n\n      ws.on('close', (code, reason) => {\n        if (clientId) {\n          list.remove(clientId);\n          this.log(`Connection closed for client ${clientId}, code: ${code}, reason: ${reason.toString()}`);\n        }\n      });\n    });\n  }\n\n  getListenerList(instance) {\n    if (!this._lists[instance]) {\n      this._lists[instance] = {\n        listeners: {},\n        add(id, socket) {\n          this.listeners[id] = socket;\n        },\n        remove(id) {\n          delete this.listeners[id];\n        },\n      };\n    }\n    return this._lists[instance];\n  }\n\n  log(message) {\n    console.log(`AphlictClientServer: ${message}`);\n  }\n\n  trace(message) {\n    console.trace(`AphlictClientServer TRACE: ${message}`);\n  }\n\n  getHistory(min_age) {\n    // Implement history retrieval logic here\n    return [];\n  }\n}\n```"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Create a class that implements HTTP client functionality using Axios for making HTTP requests with support for GET and POST methods, including proper header and parameter handling.\n\nClass Description: HTTPClient is a class that provides HTTP request capabilities using Axios as the underlying library. It handles request configuration, parameter serialization, content-type detection, and response processing.\n\nAttributes:\n- requestModule: [String] - Specifies the HTTP library being used (default: 'axios')\n\nMethods:\n- httpRequest: [async](options) -> [Object] - Makes an HTTP request based on provided options\n  - options: [Object] - Configuration object containing:\n    - method: [String] - HTTP method (GET/POST)\n    - url: [String] - Request URL\n    - headers: [Object] - Request headers\n    - params: [Object] - Query parameters\n    - body: [Object|String] - Request payload\n- queryStr: [function](options) -> [String] - Converts an object to URL-encoded query string\n  - options: [Object] - Key-value pairs to serialize\n- isJSONString: [function](str) -> [Boolean] - Checks if a string is valid JSON\n  - str: [String] - String to validate\n- isJson: [function](obj) -> [Boolean] - Checks if an object is a plain JSON object\n  - obj: [Any] - Object to validate",
    "Canonical_solution": "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n    constructor() {\n        this.requestModule = 'axios';\n    }\n\n    async httpRequest(options) {\n        let t = { ...options };\n        t.headers = t.headers || {};\n        if (t.params) {\n            t.url += '?' + this.queryStr(t.params);\n        }\n        t.method = t.method.toLowerCase();\n        if (t.method === 'get') {\n            delete t.headers['Content-Type'];\n            delete t.headers['Content-Length'];\n            delete t.headers['content-type'];\n            delete t.headers['content-length'];\n            delete t.body;\n        } else if (t.method === 'post') {\n            let ContentType;\n            if (!t.body) {\n                t.body = \"\";\n            } else if (typeof t.body === \"string\") {\n                ContentType = this.isJSONString(t.body) ? 'application/json' : 'application/x-www-form-urlencoded';\n            } else if (this.isJson(t.body)) {\n                t.body = JSON.stringify(t.body);\n                ContentType = 'application/json';\n            }\n            if (!t.headers['Content-Type'] && !t.headers['content-type']) {\n                t.headers['Content-Type'] = ContentType;\n            }\n        }\n        if (this.requestModule === \"axios\" && t.method === \"post\") {\n            t.data = t.body;\n            delete t.body;\n        }\n        let httpResult;\n        if (this.requestModule === \"axios\") {\n            httpResult = await axios(t);\n            httpResult.body = httpResult.data;\n        }\n        return httpResult;\n    }\n\n    queryStr(options) {\n        return Object.entries(options).map(([key, value]) => `${key}=${typeof value === 'object' ? JSON.stringify(value) : value}`).join('&');\n    }\n\n    isJSONString(str) {\n        try {\n            return JSON.parse(str) && typeof JSON.parse(str) === 'object';\n        } catch (e) {\n            return false;\n        }\n    }\n\n    isJson(obj) {\n        var isjson = typeof (obj) == \"object\" && Object.prototype.toString.call(obj).toLowerCase() == \"[object object]\" && !obj.length;\n        return isjson;\n    }\n}\n```",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass HTTPClient {\n  constructor() {\n    this.requestModule = 'axios';\n  }\n\n  async httpRequest(options) {\n    const axios = require(this.requestModule);\n    const config = {\n      method: options.method,\n      url: options.url,\n      headers: { ...this.getDefaultHeaders(), ...options.headers },\n      params: options.params || {},\n      data: options.body || undefined,\n    };\n\n    try {\n      const response = await axios(config);\n      return response.data;\n    } catch (error) {\n      throw error.response ? error.response.data : error.message;\n    }\n  }\n\n  getDefaultHeaders() {\n    return {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json',\n    };\n  }\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(options[key]))\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return typeof obj === 'object' && !Array.isArray(obj) && obj !== null;\n  }\n}\n```"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript to handle real-time bidirectional communication between clients and the server.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io. It sets up event listeners for client connections, messages, and disconnections. The server broadcasts received messages to all connected clients.\n\nInput:\n- `port` (Number): The port number on which the WebSocket server will listen for incoming connections.\n\nOutput:\n- Returns the `socketServer` instance (Object) which can be used to further configure or interact with the WebSocket server.\n\nNote: The function internally uses the `http` module to create an HTTP server and binds socket.io to it for WebSocket communication. The server logs connection, message, and disconnection events to the console.",
    "Canonical_solution": "const http = require(\"http\");\nconst socketIo = require(\"socket.io\");\n\nfunction setupWebSocketServer(port) {\n    const app = express();\n    const webServer = http.createServer(app);\n    const socketServer = socketIo(webServer, {\"log level\": 1});\n\n    socketServer.on(\"connection\", (socket) => {\n        console.log(\"New client connected\");\n\n        socket.on(\"message\", (data) => {\n            console.log(\"Message received: \", data);\n            socketServer.emit(\"message\", data);\n        });\n\n        socket.on(\"disconnect\", () => {\n            console.log(\"Client disconnected\");\n        });\n    });\n\n    webServer.listen(port, () => {\n        console.log(\"WebSocket server listening on port: \" + port);\n    });\n\n    return socketServer;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "wrong_result": "```javascript\nconst http = require('http');\nconst { io } = require('socket.io')(0);\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = io(server, {\n    cors: {\n      origin: '*',\n      methods: ['GET', 'POST']\n    }\n  });\n\n  socketServer.on('connection', (socket) => {\n    console.log('A client connected:', socket.id);\n\n    socket.on('message', (message) => {\n      console.log('Message received from client:', message);\n      socketServer.emit('message', message);\n    });\n\n    socket.on('disconnect', () => {\n      console.log('A client disconnected:', socket.id);\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`WebSocket server is running on port ${port}`);\n  });\n\n  return socketServer;\n}\n```"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript that handles real-time communication between clients and integrates with an Express application and Deployd backend.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io, integrates it with an Express application, and attaches a Deployd backend. It sets up event listeners for server operations and handles custom Express routes.\n\nInput: None (The function uses environment variables for configuration: `process.env.NODE_ENV` for environment setting and `process.env.PORT` for port number)\n\nOutput: None (The function starts a server that listens on the specified port and logs server status to the console)\n\nNote: The function internally uses:\n- Express for HTTP server functionality\n- Socket.io for WebSocket communication\n- Deployd for backend services\n- MongoDB (configured to connect to localhost:27017 with database name 'test-app')",
    "Canonical_solution": "function setupWebSocketServer() {\n    var express = require('express');\n    var app = express();\n    var server = require('http').createServer(app);\n    var io = require('socket.io').listen(server, {'log level': 0});\n\n    require('deployd').attach(server, {\n        socketIo: io,\n        env: process.env.NODE_ENV || 'development',\n        db: {host:'localhost', port:27017, name:'test-app'}\n    });\n    app.use(server.handleRequest);\n\n    app.get('/express-custom-handler', function(req, res) {\n        res.send('Ok');\n    });\n\n    server.listen(process.env.PORT || 2403, function() {\n        console.log({ ENV: process.env.NODE_ENV || 'development', PORT: process.env.PORT || 2403 });\n    });\n    server.on('error', function(err) {\n        console.log(err.stack);\n        process.nextTick(function() {\n            process.exit();\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "wrong_result": "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIO = require('socket.io');\nconst dpd = require('deployd');\n\nfunction setupWebSocketServer() {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIO(server);\n\n  const dpdBApp = dpd({\n    port: process.env.PORT || 5000,\n    env: process.env.NODE_ENV || 'development',\n    db: {\n      name: 'test-app',\n      host: 'localhost',\n      port: 27017\n    }\n  });\n\n  // Integrate Express app with Deployd\n  dpdBApp.use('/', app);\n\n  // WebSocket event handling\n  io.on('connection', (socket) => {\n    console.log('A client connected');\n\n    socket.on('message', (data) => {\n      console.log('Received message:', data);\n      io.emit('message', data); // Broadcast to all clients\n    });\n\n    socket.on('disconnect', () => {\n      console.log('A client disconnected');\n    });\n  });\n\n  // Start the server\n  const PORT = process.env.PORT || 3000;\n  server.listen(PORT, () => {\n    console.log(`Server is running on port ${PORT}`);\n  });\n\n  // Start Deployd backend\n  dpdBApp.start();\n}\n```"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Write a function that scrapes TV channel information from a webpage, processes the data, and returns a list of channel objects with their details.\n\nFunction Description: The function `getChannels` asynchronously fetches HTML content from a URL, parses it to extract TV channel information, and returns an array of channel objects. Each channel object contains language, site ID, and name. The function uses Axios for HTTP requests and Cheerio for HTML parsing.\n\nInput: None (The function uses an implicit `this.url()` method to generate the target URL)\n\nOutput: Array<Object> - Returns an array of channel objects with the following structure:\n[\n  {\n    lang: string,      // Language code of the channel (e.g., 'tr')\n    site_id: string,   // Unique identifier for the channel\n    name: string       // Name of the channel\n  },\n  ...\n]",
    "Canonical_solution": "async function getChannels() {\n    const channels = {};\n    const axios = require('axios');\n    const data = await axios\n        .get(this.url({ date: dayjs() }))\n        .then(r => r.data)\n        .catch(console.error);\n\n    const $ = cheerio.load(data);\n    $('.channelContent').toArray()\n        .forEach(el => {\n            const item = $(el);\n            const channelId = item.find('.channelDetail .tvGuideResult-box-wholeDates-title')\n                .first()\n                .attr('onclick');\n            if (channelId) {\n                const site_id = channelId.match(/\\s(\\d+)\\)/)[1];\n                if (channels[site_id] === undefined) {\n                    channels[site_id] = {\n                        lang: 'tr',\n                        site_id,\n                        name: item.find('#channelID').val()\n                    };\n                }\n            }\n        });\n\n    return Object.values(channels);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync getChannels() {\n  const axios = require('axios');\n  const cheerio = require('cheerio');\n\n  const response = await axios.get(this.url());\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('.channel').each((index, element) => {\n    const lang = $(element).data('lang');\n    const siteId = $(element).data('site-id');\n    const name = $(element).find('.channel-name').text().trim();\n\n    channels.push({\n      lang,\n      site_id: siteId,\n      name\n    });\n  });\n\n  return channels;\n}\n```"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a function to send telemetry data to a remote endpoint after a software installation, while respecting user preferences for telemetry collection.\n\nFunction Description: The function `installTelemetry` sends a POST request to a specified telemetry endpoint with installation-related data (Node.js version and platform). It checks an environment variable to determine if telemetry collection is enabled before sending any data. The function handles both success and error cases silently.\n\nInput: None (uses environment variable `TUNNELMOLE_TELEMETRY` and Node.js process information)\n\nOutput: None (the function doesn't return any value, it only performs a side effect of sending telemetry data)",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function installTelemetry() {\n  const telemetryEndpoint = `https://service.tunnelmole.com/tunnelmole-log-telemetry`;\n\n  if (process.env.TUNNELMOLE_TELEMETRY === \"0\") {\n    return;\n  }\n\n  axios\n    .post(telemetryEndpoint, {\n      type: \"post-install\",\n      data: {\n        nodeVersion: process.version ? process.version : \"Unknown\",\n        platform: process.platform ? process.platform : \"Unknown\"\n      }\n    }).then(function () {\n      // Ignore the response\n    }).catch(function () {\n      // Ignore the error\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst https = require('https');\nconst os = require('os');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === '1';\n\n  if (!telemetryEnabled) {\n    return;\n  }\n\n  const payload = {\n    nodeVersion: process.version,\n    platform: os.platform(),\n  };\n\n  const options = {\n    hostname: 'example.com',\n    port: 443,\n    path: '/telemetry/install',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': Buffer.byteLength(JSON.stringify(payload)),\n    },\n  };\n\n  const req = https.request(options, (res) => {\n    res.on('data', () => {}).on('end', () => {});\n  });\n\n  req.on('error', () => {});\n\n  req.write(JSON.stringify(payload));\n  req.end();\n}\n```"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a SauceLabs API client class in JavaScript that handles HTTP requests to the SauceLabs REST API, including authentication and basic GET/POST operations.\n\nClass Description: The SauceLabsClient class provides methods to interact with the SauceLabs REST API. It handles authentication and provides simplified methods for making GET and POST requests to the API endpoints.\n\nAttributes:\n- auth: [Object] - An object containing user authentication credentials (username and access token)\n\nMethods:\n- setAuth: [setAuth](saucelabsUsername: String, saucelabsToken: String) -> Void - Sets the authentication credentials for API requests\n- get: [get](path: String, callback: Function) -> Void - Makes a GET request to the specified API path and handles the response through a callback\n- post: [post](path: String, data: Object, callback: Function) -> Void - Makes a POST request to the specified API path with provided data and handles the response through a callback",
    "Canonical_solution": "var request = require('request');\n\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {\n      user: null,\n      password: null\n    };\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.user = saucelabsUsername;\n    this.auth.password = saucelabsToken;\n  }\n\n  get(path, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + path,\n      auth: this.auth\n    };\n    request.get(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        console.log(params);\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(JSON.parse(body));\n    });\n  }\n\n  post(path, data, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + this.auth.user + '/' + path,\n      auth: { user: this.auth.user, password: this.auth.password },\n      json: data\n    };\n    request.post(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(body);\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {\n      username: '',\n      token: ''\n    };\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.username = saucelabsUsername;\n    this.auth.token = saucelabsToken;\n  }\n\n  get(path, callback) {\n    const options = {\n      hostname: 'api.saucelabs.com',\n      port: 443,\n      path: path,\n      method: 'GET',\n      headers: {\n        'Authorization': 'Basic ' + Buffer.from(this.auth.username + ':' + this.auth.token).toString('base64')\n      }\n    };\n\n    const https = require('https');\n    const req = https.request(options, (res) => {\n      let data = '';\n\n      res.on('data', (chunk) => {\n        data += chunk;\n      });\n\n      res.on('end', () => {\n        callback(null, JSON.parse(data));\n      });\n    });\n\n    req.on('error', (error) => {\n      callback(error, null);\n    });\n\n    req.end();\n  }\n\n  post(path, data, callback) {\n    const options = {\n      hostname: 'api.saucelabs.com',\n      port: 443,\n      path: path,\n      method: 'POST',\n      headers: {\n        'Authorization': 'Basic ' + Buffer.from(this.auth.username + ':' + this.auth.token).toString('base64'),\n        'Content-Type': 'application/json'\n      }\n    };\n\n    const https = require('https');\n    const req = https.request(options, (res) => {\n      let data = '';\n\n      res.on('data', (chunk) => {\n        data += chunk;\n      });\n\n      res.on('end', () => {\n        callback(null, JSON.parse(data));\n      });\n    });\n\n    req.on('error', (error) => {\n      callback(error, null);\n    });\n\n    req.write(JSON.stringify(data));\n    req.end();\n  }\n}\n```"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Create a class that interacts with a bundle size tracking API to get and set file size values for a repository.\n\nClass Description: The BundleSizeAPI class provides methods to retrieve and store file size information from a remote API. It handles authentication, repository name sanitization, and error logging.\n\nAttributes:\n- repo: [String] - The repository name (e.g., \"owner/repo\")\n- token: [String] - Authentication token for API access\n- sha: [String] - Commit SHA associated with the bundle sizes\n- ci: [Any] - CI environment information (usage not shown in reference)\n- url: [String] - Base URL for the bundle size API (\"https://bundlesize-store.now.sh/values\")\n- enabled: [Boolean] - Flag indicating if API operations are enabled (true when repo and token are provided)\n\nMethods:\n- get: [get]() -> [Promise<Object>] - Retrieves file size values from the API. Returns a promise that resolves to an object mapping file paths to their sizes. Automatically sanitizes repository name by replacing dots with underscores.\n- set: [set](values: Object) -> [void] - Posts file size values to the API. Takes an object mapping file paths to sizes. Only operates when repo and token are available. Sanitizes repository name and includes commit SHA in the payload. Errors are logged to console.\n\nNote: Both methods handle errors by logging them to the console and continue execution (errors don't propagate). The class is designed to be fail-safe when API credentials aren't provided.",
    "Canonical_solution": "const axios = require('axios');\n\nclass BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = (this.repo && this.token) ? true : false;\n  }\n\n  get() {\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    return axios\n      .get(`${this.url}?repo=${sanitizedRepo}&token=${this.token}`)\n      .then(response => {\n        const values = {};\n        if (response && response.data && response.data.length) {\n          response.data.map(file => (values[file.path] = file.size));\n        }\n        return values;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  }\n\n  set(values) {\n    if (this.repo && this.token) {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      axios\n        .post(this.url, { repo: sanitizedRepo, token: this.token, sha: this.sha, values })\n        .catch(error => console.log(error));\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass BundleSizeAPI {\n  constructor({ repo, token, sha, ci }) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = \"https://bundlesize-store.now.sh/values\";\n    this.enabled = !!repo && !!token;\n  }\n\n  async get() {\n    if (!this.enabled) return {};\n\n    const sanitizedRepo = this.repo.replace(/\\./g, \"_\");\n    const response = await fetch(`${this.url}?repo=${sanitizedRepo}`, {\n      headers: {\n        Authorization: `Bearer ${this.token}`,\n      },\n    });\n\n    try {\n      if (response.ok) {\n        const data = await response.json();\n        return data;\n      }\n    } catch (error) {\n      console.error(\"Failed to retrieve bundle sizes:\", error);\n    }\n\n    return {};\n  }\n\n  set(values) {\n    if (!this.enabled || !values) return;\n\n    const sanitizedRepo = this.repo.replace(/\\./g, \"_\");\n    const payload = {\n      repo: sanitizedRepo,\n      sha: this.sha,\n      values,\n    };\n\n    fetch(this.url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${this.token}`,\n      },\n      body: JSON.stringify(payload),\n    }).catch((error) => {\n      console.error(\"Failed to store bundle sizes:\", error);\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a function that fetches COVID-19 related data from the Israeli government's health dashboard API using HTTP POST request and processes the response.\n\nFunction Description: The function makes a batch request to the Israeli health ministry's API endpoint to retrieve multiple COVID-19 related datasets including updates, patient statistics, test results, and demographic breakdowns. It handles the HTTP communication, error cases, and returns the parsed data or null if the request fails.\n\nInput: None (The function takes no parameters as all request configuration is internally defined)\n\nOutput: \n- On success: Returns parsed data from the API response (type depends on parseData implementation)\n- On failure: Returns null and logs the error",
    "Canonical_solution": "function israelData() {\n    const axios = require('axios');\n    const logger = require('../../../utils/logger');\n    const params = {\n        requests: [\n            { queryName: 'lastUpdate', single: true },\n            { queryName: 'patientsPerDate' },\n            { queryName: 'deadPatientsPerDate' },\n            { queryName: 'recoveredPerDay' },\n            { queryName: 'testResultsPerDate' },\n            { queryName: 'infectedByPeriodAndAgeAndGender' },\n            { queryName: 'deadByPeriodAndAgeAndGender' },\n            { queryName: 'breatheByPeriodAndAgeAndGender' },\n            { queryName: 'severeByPeriodAndAgeAndGender' },\n            { queryName: 'spotlightPublic' },\n            { queryName: 'spotlightLastupdate' }\n        ]\n    };\n    return axios.post('https://datadashboardapi.health.gov.il/api/queries/_batch', params, {\n        headers: { 'Content-Type': 'application/json' }\n    }).then(data => {\n        return parseData(data.data);\n    }).catch(err => {\n        logger.err('Error: Requesting Israel Gov Data failed!', err);\n        return null;\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function fetchCovidData() {\n    const url = 'https://data.gov.il/api/3/action/datastore_search';\n    const data = {\n        resource_id: '8256f1c4-97d4-40d8-a22e-ea169b7dd016',\n        q: 'covid'\n    };\n\n    try {\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n\n        const result = await response.json();\n        return parseData(result);\n    } catch (error) {\n        console.error('Failed to fetch or parse data:', error.message);\n        return null;\n    }\n}\n\nfunction parseData(data) {\n    // Example parsing logic; adjust based on actual API structure\n    if (data && data.result && data.result.records) {\n        return data.result.records;\n    }\n    return null;\n}\n```"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a function to send emails using different email service providers (Mailgun and Sendgrid) through HTTP requests, with error handling and promise-based asynchronous operation.\n\nFunction Description: The function `sendMail` sends an email using a configured transporter (either Mailgun or Sendgrid). It wraps the transporter's send operation in a Promise for better async handling. The transporter is configured to make HTTP requests to the respective email service API.\n\nInput:\n- `to`: [String] - Recipient email address\n- `subject`: [String] - Email subject\n- `text`: [String] - Email body content\n- `options`: [Object] (optional) - Additional email options (defaults to empty object)\n\nOutput:\n- [Promise] - Resolves with email sending success info, or rejects with an error if sending fails.\n\n---\n\nClass Description: (Not applicable, as the reference code is at the function level)",
    "Canonical_solution": "function sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    transporter.sendMail({\n      from: `\"${ config.plugins.email.name || '' }\" <${ config.plugins.email.email || config.plugins.email.username }>`,\n      to,\n      subject,\n      text,\n    }, (error, info) => {\n      if(error) {\n        return reject(error);\n      }\n      return resolve(info);\n    });\n  });\n}\n\n// External libraries and global variables used:\nconst axios = require('axios');\nconst FormData = require('form-data');\nconst config = appRequire('services/config').all();\nlet transporter;\n\n// Mailgun implementation\ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  const form = new FormData();\n  form.append('from', options.from);\n  form.append('to', options.to);\n  form.append('subject', options.subject);\n  form.append('text', options.text);\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: form.getHeaders(),\n    data: form,\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};\n\n// Sendgrid implementation  \ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${ emailConfig.apiKey }`,\n    },\n    data: {\n      personalizations: [{\n        to: [{ email: options.to }]\n      }],\n      from: { email: options.from },\n      subject: options.subject,\n      content: [{\n        type: 'text/plain',\n        value: options.text,\n      }]\n    },\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nfunction sendMail({ to, subject, text, options = {} }) {\n  return new Promise((resolve, reject) => {\n    const transporterType = process.env.EMAIL_TRANSPORTER;\n\n    if (!transporterType || !['mailgun', 'sendgrid'].includes(transporterType)) {\n      return reject(new Error('Invalid or missing email transporter configuration'));\n    }\n\n    let transporter;\n    if (transporterType === 'mailgun') {\n      transporter = {\n        auth: {\n          api_key: process.env.MAILGUN_API_KEY,\n          domain: process.env.MAILGUN_DOMAIN,\n        },\n        send: async ({ from, to, subject, text, ...rest }) => {\n          try {\n            const response = await fetch(`https://api.mailgun.net/v3/${process.env.MAILGUN_DOMAIN}/messages`, {\n              method: 'POST',\n              headers: {\n                Authorization: `Basic ${Buffer.from(`api:${process.env.MAILGUN_API_KEY}`).toString('base64')}`,\n                'Content-Type': 'application/x-www-form-urlencoded',\n              },\n              body: new URLSearchParams({\n                from,\n                to,\n                subject,\n                text,\n                ...rest,\n              }),\n            });\n\n            if (!response.ok) {\n              throw new Error(`Mailgun API error: ${await response.text()}`);\n            }\n\n            resolve(await response.json());\n          } catch (error) {\n            reject(error);\n          }\n        },\n      };\n    } else if (transporterType === 'sendgrid') {\n      transporter = {\n        apiKey: process.env.SENDGRID_API_KEY,\n        send: async ({ from, to, subject, text, ...rest }) => {\n          try {\n            const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n              method: 'POST',\n              headers: {\n                Authorization: `Bearer ${process.env.SENDGRID_API_KEY}`,\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify({\n                personalizations: [\n                  {\n                    to: [{ email: to }],\n                    subject,\n                  },\n                ],\n                from: { email: from },\n                content: [\n                  {\n                    type: 'text/plain',\n                    value: text,\n                  },\n                ],\n                ...rest,\n              }),\n            });\n\n            if (!response.ok) {\n              throw new Error(`SendGrid API error: ${await response.text()}`);\n            }\n\n            resolve({ success: true });\n          } catch (error) {\n            reject(error);\n          }\n        },\n      };\n    }\n\n    const from = options.from || process.env.DEFAULT_SENDER_EMAIL;\n\n    transporter.send({\n      from,\n      to,\n      subject,\n      text,\n      ...options,\n    });\n  });\n}\n```"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create an asynchronous function that fetches TV channel data from a specified API endpoint and processes it into a standardized format.\n\nFunction Description: The function makes an HTTP GET request to retrieve TV channel information from a remote API. It processes the response to extract relevant channel details (language, site ID, and name) and returns them in a structured array format. The function includes error handling to log any request failures.\n\nInput: None (The function uses a hardcoded API URL and parameters)\n\nOutput: An array of objects where each object represents a TV channel with the following properties:\n- lang: String - The language code for the channel (hardcoded as 'sq' in this case)\n- site_id: String - The unique identifier for the channel from the API\n- name: String - The display name of the channel",
    "Canonical_solution": "async function channels() {\n    const axios = require('axios')\n    const data = await axios\n        .get('https://www.tvim.tv/script/epg/category_channels?category=all&filter=playable')\n        .then(r => r.data)\n        .catch(console.log)\n\n    let channels = []\n    data.data.forEach(item => {\n        channels.push({\n            lang: 'sq',\n            site_id: item.epg_id,\n            name: item.name\n        })\n    })\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function fetchTVChannels() {\n    const url = 'https://api.example.com/tv-channels';\n\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n\n        const data = await response.json();\n        return data.map(channel => ({\n            lang: 'sq',\n            site_id: channel.id,\n            name: channel.name\n        }));\n    } catch (error) {\n        console.error('Error fetching TV channels:', error);\n        return [];\n    }\n}\n```"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a function to download a video file from a given URL and save it with a specified description as the filename.\n\nFunction Description: The function `downloadVideo` initiates an asynchronous HTTP GET request to download a video file from the provided URL. It handles the response as a binary blob, creates a downloadable link, and triggers the download automatically. The function includes error handling for empty URLs and checks for successful request completion.\n\nInput:\n- `url` (String): The URL of the video file to be downloaded.\n- `desc` (String): The description to be used as the filename for the downloaded video.\n\nOutput: None (The function triggers a file download but does not return any value.)",
    "Canonical_solution": "function downloadVideo(url, desc) {\n    if (isEmpty(url)) {\n        layer.msg('\u6682\u65e0\u6570\u636e');\n        return;\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'blob';\n    xhr.setRequestHeader(\"Access-Control-Allow-Origin\", \"*\");\n    xhr.setRequestHeader(\"Access-Control-Allow-Credentials\", true);\n    xhr.onload = function () {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            let blob = this.response;\n            let u = window.URL.createObjectURL(new Blob([blob]));\n            let a = document.createElement('a');\n            a.download = desc + '.mp4';\n            a.href = u;\n            a.style.display = 'none';\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nfunction downloadVideo(url, desc) {\n    if (!url) {\n        console.error(\"URL cannot be empty.\");\n        return;\n    }\n\n    fetch(url)\n        .then(response => {\n            if (!response.ok) {\n                throw new Error(`HTTP error! Status: ${response.status}`);\n            }\n            return response.blob();\n        })\n        .then(blob => {\n            const link = document.createElement(\"a\");\n            link.href = URL.createObjectURL(blob);\n            link.download = `${desc}.mp4`;\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n        })\n        .catch(error => {\n            console.error(\"Download failed:\", error);\n        });\n}\n```"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a cross-platform HTTP client tool that works in Node.js, Surge, and Quantumult X environments, providing consistent methods for making HTTP requests and handling responses across these platforms.\n\nClass Description: The `Tool` class is a utility class designed to abstract HTTP client functionality across different JavaScript environments (Node.js, Surge, and Quantumult X). It provides methods for making HTTP requests (GET/POST), persistent storage, and notifications while automatically detecting the runtime environment.\n\nAttributes:\n- _node: [Object|null] - Contains Node.js specific modules if running in Node.js environment\n- _isSurge: [Boolean] - Indicates if running in Surge environment\n- _isQuanX: [Boolean] - Indicates if running in Quantumult X environment\n- isSurge: [Boolean] - Public alias for _isSurge\n- isQuanX: [Boolean] - Public alias for _isQuanX\n- isResponse: [Boolean] - Indicates if $response is available\n\nMethods:\n- constructor() -> [void] - Initializes the tool and detects the runtime environment\n- notify(title: String, subtitle: String, message: String, option: Object) -> [void] - Sends a notification in the current environment\n- write(value: String, key: String) -> [Boolean] - Writes a value to persistent storage\n- read(key: String) -> [String] - Reads a value from persistent storage\n- get(options: Object|String, callback: Function) -> [void] - Makes a GET HTTP request\n- post(options: Object|String, callback: Function) -> [void] - Makes a POST HTTP request\n- _status(response: Object) -> [Object] - Internal method to normalize response status codes",
    "Canonical_solution": "const request = require('request');\n\nclass Tool {\n    constructor() {\n        this._node = (() => {\n            if (typeof require == \"function\") {\n                const request = require('request')\n                return ({ request })\n            } else {\n                return (null)\n            }\n        })()\n        this._isSurge = typeof $httpClient != \"undefined\"\n        this._isQuanX = typeof $task != \"undefined\"\n        this.isSurge = this._isSurge\n        this.isQuanX = this._isQuanX\n        this.isResponse = typeof $response != \"undefined\"\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) $notify(title, subtitle, message, option)\n        if (this._isSurge) $notification.post(title, subtitle, message, option[\"open-url\"])\n        if (this._node) console.log(JSON.stringify({ title, subtitle, message }));\n    }\n\n    write(value, key) {\n        if (this._isQuanX) return $prefs.setValueForKey(value, key)\n        if (this._isSurge) return $persistentStore.write(value, key)\n    }\n\n    read(key) {\n        if (this._isQuanX) return $prefs.valueForKey(key)\n        if (this._isSurge) return $persistentStore.read(key)\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"GET\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.get(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"POST\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    _status(response) {\n        if (response) {\n            if (response.status) {\n                response[\"statusCode\"] = response.status\n            } else if (response.statusCode) {\n                response[\"status\"] = response.statusCode\n            }\n        }\n        return response\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass Tool {\n  constructor() {\n    this._node = null;\n    this._isSurge = typeof $httpClient !== 'undefined';\n    this._isQuanX = typeof $task !== 'undefined';\n    this.isSurge = this._isSurge;\n    this.isQuanX = this._isQuanX;\n    this.isResponse = typeof $response !== 'undefined';\n\n    if (this.isSurge) {\n      this._node = require('node');\n    }\n  }\n\n  notify(title, subtitle, message, option = {}) {\n    if (this.isSurge) {\n      $notify(title, subtitle, message, option);\n    } else if (this.isQuanX) {\n      $notify(title, subtitle ? subtitle : '', message, option);\n    }\n  }\n\n  write(value, key) {\n    if (this.isSurge) {\n      return $persistentStore.write(value, key);\n    } else if (this.isQuanX) {\n      return $prefs.setValueForKey(value, key);\n    }\n    return false;\n  }\n\n  read(key) {\n    if (this.isSurge) {\n      return $persistentStore.read(key);\n    } else if (this.isQuanX) {\n      return $prefs.valueForKey(key);\n    }\n    return null;\n  }\n\n  get(options, callback) {\n    if (typeof options === 'string') {\n      options = { url: options };\n    }\n\n    if (this.isSurge) {\n      $httpClient.get(options.url, (error, response, body) => {\n        callback(error, this._status(response), body);\n      });\n    } else if (this.isQuanX) {\n      $task.fetch({\n        method: 'GET',\n        url: options.url,\n        headers: options.headers || {},\n        timeout: options.timeout || 60\n      }).then((response) => {\n        const body = response.body.string();\n        callback(null, this._status(response), body);\n      }, (reason) => {\n        callback(reason, null, null);\n      });\n    }\n  }\n\n  post(options, callback) {\n    if (typeof options === 'string') {\n      options = { url: options };\n    }\n\n    if (this.isSurge) {\n      $httpClient.post(options.url, options.body || '', (error, response, body) => {\n        callback(error, this._status(response), body);\n      });\n    } else if (this.isQuanX) {\n      $task.fetch({\n        method: 'POST',\n        url: options.url,\n        headers: options.headers || {},\n        body: options.body || '',\n        timeout: options.timeout || 60\n      }).then((response) => {\n        const body = response.body.string();\n        callback(null, this._status(response), body);\n      }, (reason) => {\n        callback(reason, null, null);\n      });\n    }\n  }\n\n  _status(response) {\n    let status = {};\n    if (this.isSurge) {\n      status = {\n        statusCode: response.status,\n        headers: response.headers,\n        cookies: response.cookies\n      };\n    } else if (this.isQuanX) {\n      status = {\n        statusCode: response.statusCode,\n        headers: response.headers,\n        cookies: response.cookies\n      };\n    }\n    return status;\n  }\n}\n```"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a class that simulates the behavior of an EventSource object, which is used to receive server-sent events (SSE) over HTTP. The class should handle the connection, reception of events, and error handling.\n\nClass Description: The `EventSource` class is designed to establish a persistent connection to a server using HTTP and receive server-sent events. It manages the connection state, handles incoming events, and dispatches them to appropriate event handlers. The class also supports reconnection in case of errors or connection loss.\n\nAttributes:\n\n- `URL`: [String] - The URL to which the EventSource connects to receive server-sent events.\n- `readyState`: [Number] - Represents the current state of the connection. Possible values are `CONNECTING` (0), `OPEN` (1), and `CLOSED` (2).\n- `_pollTimer`: [Object] - A timer object used to manage the polling interval for reconnection attempts.\n- `_xhr`: [Object] - The XMLHttpRequest object used to make HTTP requests to the server.\n\nMethods:\n\n- `poll()`: [Function] -> [Void] - Initiates a new HTTP request to the server to receive events. Handles the response, processes the events, and manages the connection state.\n- `close()`: [Function]() -> [Void] - Closes the connection to the server, sets the `readyState` to `CLOSED`, and stops any ongoing polling.\n- `dispatchEvent(type, event)`: [Function]([String], [Object]) -> [Void] - Dispatches an event to the registered event handlers based on the event type.\n- `addEventListener(type, handler)`: [Function]([String], [Function]) -> [Void] - Registers an event handler for a specific event type.\n- `removeEventListener()`: [Function]() -> [Void] - Placeholder method for removing event listeners (not implemented in the reference code).\n\nAdditional Classes:\n\n- `MessageEvent`: [Class] - Represents an event received from the server. Contains the event data, origin, and last event ID.\n\nAttributes of `MessageEvent`:\n\n- `data`: [String] - The data payload of the event.\n- `type`: [String] - The type of the event, defaulting to 'message'.\n- `lastEventId`: [String] - The ID of the last received event.\n- `origin`: [String] - The origin URL of the event.\n\nMethods of `MessageEvent`:\n\n- `MessageEvent(data, origin, lastEventId)`: [Constructor]([String], [String], [String]) -> [Object] - Initializes a new `MessageEvent` instance with the provided data, origin, and last event ID.",
    "Canonical_solution": "var EventSource = function (url) {\n  var eventsource = this,\n      interval = 500,\n      lastEventId = null,\n      cache = '';\n\n  if (!url || typeof url != 'string') {\n    throw new SyntaxError('Not enough arguments');\n  }\n\n  this.URL = url;\n  this.readyState = this.CONNECTING;\n  this._pollTimer = null;\n  this._xhr = null;\n\n  function poll() {\n    try {\n      if (eventsource.readyState == eventsource.CLOSED) return;\n\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', eventsource.URL, true);\n      xhr.setRequestHeader('Accept', 'text/event-stream');\n      xhr.setRequestHeader('Cache-Control', 'no-cache');\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n      if (lastEventId != null) xhr.setRequestHeader('Last-Event-ID', lastEventId);\n      cache = '';\n\n      xhr.timeout = 50000;\n      xhr.onreadystatechange = function () {\n        var status = 0;\n        try {\n          status = xhr.status;\n        } catch (e) {}\n\n        if ((this.readyState == 3 || this.readyState == 4) && status == 200) {\n          if (eventsource.readyState == eventsource.CONNECTING) {\n            eventsource.readyState = eventsource.OPEN;\n            eventsource.dispatchEvent('open', { type: 'open' });\n          }\n\n          var responseText = '';\n          try {\n            responseText = this.responseText || '';\n          } catch (e) {}\n\n          var parts = responseText.substr(cache.length).split(\"\\n\"),\n              eventType = 'message',\n              data = [],\n              i = 0,\n              line = '';\n\n          cache = responseText;\n\n          for (; i < parts.length; i++) {\n            line = parts[i].replace(reTrim, '');\n            if (line.indexOf('event') == 0) {\n              eventType = line.replace(/event:?\\s*/, '');\n            } else if (line.indexOf('data') == 0) {\n              data.push(line.replace(/data:?\\s*/, ''));\n            } else if (line.indexOf('id:') == 0) {\n              lastEventId = line.replace(/id:?\\s*/, '');\n            } else if (line.indexOf('id') == 0) {\n              lastEventId = null;\n            } else if (line == '') {\n              if (data.length) {\n                var event = new MessageEvent(data.join('\\n'), eventsource.url, lastEventId);\n                eventsource.dispatchEvent(eventType, event);\n                data = [];\n                eventType = 'message';\n              }\n            }\n          }\n\n          if (this.readyState == 4) pollAgain(this);\n        } else if (eventsource.readyState !== eventsource.CLOSED) {\n          if (this.readyState == 4) {\n            eventsource.readyState = eventsource.CONNECTING;\n            eventsource.dispatchEvent('error', { type: 'error' });\n            pollAgain(this);\n          } else if (this.readyState == 0) {\n            pollAgain(this);\n          }\n        }\n      };\n\n      xhr.send();\n\n      setTimeout(function () {\n        if (true || xhr.readyState == 3) xhr.abort();\n      }, xhr.timeout);\n\n      eventsource._xhr = xhr;\n\n    } catch (e) {\n      eventsource.dispatchEvent('error', { type: 'error', data: e.message });\n    }\n  };\n\n  poll();\n};\n\nEventSource.prototype = {\n  close: function () {\n    this.readyState = this.CLOSED;\n    clearInterval(this._pollTimer);\n    this._xhr.abort();\n  },\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  dispatchEvent: function (type, event) {\n    var handlers = this['_' + type + 'Handlers'];\n    if (handlers) {\n      for (var i = 0; i < handlers.length; i++) {\n        handlers[i].call(this, event);\n      }\n    }\n\n    if (this['on' + type]) {\n      this['on' + type].call(this, event);\n    }\n  },\n  addEventListener: function (type, handler) {\n    if (!this['_' + type + 'Handlers']) {\n      this['_' + type + 'Handlers'] = [];\n    }\n    this['_' + type + 'Handlers'].push(handler);\n  },\n  removeEventListener: function () {},\n  onerror: null,\n  onmessage: null,\n  onopen: null,\n  readyState: 0,\n  URL: ''\n};\n\nvar MessageEvent = function (data, origin, lastEventId) {\n  this.data = data;\n  this.origin = origin;\n  this.lastEventId = lastEventId || '';\n};\n\nMessageEvent.prototype = {\n  data: null,\n  type: 'message',\n  lastEventId: '',\n  origin: ''\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nclass MessageEvent {\n  constructor(data, origin, lastEventId) {\n    this.data = data;\n    this.type = 'message';\n    this.lastEventId = lastEventId || '';\n    this.origin = origin;\n  }\n}\n\nclass EventSource {\n  static CONNECTING = 0;\n  static OPEN = 1;\n  static CLOSED = 2;\n\n  constructor(url) {\n    this.URL = url;\n    this.readyState = EventSource.CONNECTING;\n    this._pollTimer = null;\n    this._xhr = null;\n    this._eventHandlers = {};\n  }\n\n  poll() {\n    if (this.readyState === EventSource.CLOSED) return;\n\n    this._xhr = new XMLHttpRequest();\n\n    this._xhr.onreadystatechange = () => {\n      if (this._xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n        const contentType = this._xhr.getResponseHeader('Content-Type');\n        if (!contentType || !contentType.startsWith('text/event-stream')) {\n          this.onerror({ type: 'error', message: 'Invalid content type' });\n          this.close();\n          return;\n        }\n      }\n\n      if (this._xhr.readyState === XMLHttpRequest.LOADING) {\n        let buffer = '';\n        const decoder = new TextDecoderStream();\n        const reader = decoder.readable.getReader();\n        const stream = new ReadableStream({\n          start(controller) {\n            const onProgress = () => {\n              if (this._xhr.status !== 200) {\n                controller.error(new Error('Request failed'));\n                return;\n              }\n              const chunk = this._xhr.responseText.slice(buffer.length);\n              buffer += chunk;\n              controller.enqueue(new TextEncoder().encode(chunk));\n            };\n            this._xhr.onprogress = onProgress;\n          },\n        });\n\n        const textDecoder = new TextDecoder();\n        let lastEventId = '';\n\n        stream.pipeTo(decoder.writable).catch(() => {});\n\n        const processEvents = async () => {\n          while (true) {\n            try {\n              const { value, done } = await reader.read();\n              if (done) break;\n              const chunk = textDecoder.decode(value, { stream: true });\n              const lines = chunk.split('\\n');\n\n              for (let line of lines) {\n                line = line.trim();\n                if (!line) continue;\n                if (line.startsWith('data:')) {\n                  const eventData = line.slice(5).trim();\n                  this.dispatchEvent('message', new MessageEvent(eventData, window.location.origin, lastEventId));\n                } else if (line.startsWith('id:')) {\n                  lastEventId = line.slice(3).trim();\n                } else if (line.startsWith('event:')) {\n                  const eventType = line.slice(6).trim();\n                  this.dispatchEvent(eventType, new MessageEvent('', window.location.origin, lastEventId));\n                }\n              }\n            } catch (e) {\n              this.onerror(e);\n              this.reconnect();\n              break;\n            }\n          }\n        };\n\n        processEvents();\n      }\n\n      if (this._xhr.readyState === XMLHttpRequest.DONE) {\n        if (this._xhr.status === 200) {\n          this.reconnect();\n        } else {\n          this.onerror({ type: 'error', message: 'Request failed with status ' + this._xhr.status });\n          this.reconnect();\n        }\n      }\n    };\n\n    this._xhr.open('GET', this.URL, true);\n    this._xhr.setRequestHeader('Accept', 'text/event-stream');\n    this._xhr.send();\n    this.readyState = EventSource.OPEN;\n  }\n\n  reconnect() {\n    if (this.readyState === EventSource.CLOSED) return;\n    this._pollTimer = setTimeout(() => {\n      this.poll();\n    }, 1000);\n  }\n\n  close() {\n    this.readyState = EventSource.CLOSED;\n    if (this._xhr) {\n      this._xhr.abort();\n      this._xhr = null;\n    }\n    if (this._pollTimer) {\n      clearTimeout(this._pollTimer);\n      this._pollTimer = null;\n    }\n    this.dispatchEvent('close', {});\n  }\n\n  dispatchEvent(type, event) {\n    if (this._eventHandlers[type]) {\n      for (const handler of this._eventHandlers[type]) {\n        handler(event);\n      }\n    }\n    if (type !== 'message' && this._eventHandlers['message']) {\n      for (const handler of this._eventHandlers['message']) {\n        handler(event);\n      }\n    }\n  }\n\n  addEventListener(type, handler) {\n    if (!this._eventHandlers[type]) {\n      this._eventHandlers[type] = [];\n    }\n    this._eventHandlers[type].push(handler);\n  }\n\n  removeEventListener() {\n    // Not implemented\n  }\n\n  onerror(error) {\n    this.dispatchEvent('error', error);\n  }\n}\n```"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a JavaScript class that handles HTTP requests to fetch data from a URL, with support for different data formats and authentication.\n\nClass Description: The DataManURL class provides methods to interact with remote resources via HTTP, supporting operations like fetching data as a buffer, converting to data URI, creating read streams, and retrieving metadata like content type and size.\n\nAttributes:\n- url: [String] - The URL of the remote resource to access\n- _type: [String] - The content type of the resource (e.g., 'image/png')\n- urlOpts: [Object] - Configuration options for the HTTP request (headers, auth, etc.)\n- _size: [Number] - The size in bytes of the fetched resource (cached after first request)\n\nMethods:\n- constructor(url, type, options) -> [void] - Initializes a new DataManURL instance\n  - url: [String] - The target URL\n  - type: [String] - Expected content type (optional)\n  - options: [Object] - Request options including auth and headers (optional)\n\n- getBuffer(callback) -> [void] - Fetches the resource as a binary buffer\n  - callback: [Function] - Receives (error, buffer) parameters\n\n- getDataUri(callback) -> [void] - Converts the resource to a base64 data URI\n  - callback: [Function] - Receives (error, dataUri) parameters\n\n- createReadStream() -> [Stream] - Creates a readable stream of the resource\n  - Returns: [Stream] - Readable stream of the resource data\n\n- size(callback) -> [void] - Gets the resource size in bytes\n  - callback: [Function] - Receives (error, size) parameters\n\n- type() -> [String] - Gets the content type of the resource\n  - Returns: [String] - The content type (may be null if not fetched yet)",
    "Canonical_solution": "var request = Npm.require(\"request\");\n\nclass DataManURL {\n  constructor(url, type, options) {\n    var self = this;\n    options = options || {};\n\n    self.url = url;\n    self._type = type;\n\n    if (options.auth) {\n      if (options.auth.indexOf(':') < 0)\n        throw new Error('auth option should be of the form \"username:password\"');\n      options.headers = options.headers || {};\n      options.headers['Authorization'] = \"Basic \"+\n        (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n      delete options.auth;\n    }\n\n    self.urlOpts = options;\n  }\n\n  getBuffer(callback) {\n    var self = this;\n\n    request(_.extend({\n      url: self.url,\n      method: \"GET\",\n      encoding: null,\n      jar: false\n    }, self.urlOpts), Meteor.bindEnvironment(function(err, res, body) {\n      if (err) {\n        callback(err);\n      } else {\n        self._type = res.headers['content-type'];\n        callback(null, body);\n      }\n    }, function(err) {\n      callback(err);\n    }));\n  }\n\n  getDataUri(callback) {\n    var self = this;\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        if (!self._type) {\n          callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n        } else {\n          var dataUri = \"data:\" + self._type + \";base64,\" + buffer.toString(\"base64\");\n          callback(null, dataUri);\n        }\n      }\n    });\n  }\n\n  createReadStream() {\n    var self = this;\n    return request(_.extend({\n      url: self.url,\n      method: \"GET\"\n    }, self.urlOpts));\n  }\n\n  size(callback) {\n    var self = this;\n\n    if (typeof self._size === \"number\") {\n      callback(null, self._size);\n      return;\n    }\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        self._size = buffer.length;\n        callback(null, self._size);\n      }\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst http = require('http');\nconst https = require('https');\nconst fs = require('fs');\nconst { Readable } = require('stream');\n\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options || {};\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    const protocol = this.url.startsWith('https') ? https : http;\n    const req = protocol.get(this.url, this.urlOpts, (res) => {\n      if (res.statusCode < 200 || res.statusCode >= 300) {\n        return callback(new Error(`HTTP status code ${res.statusCode}`));\n      }\n      let data = [];\n      res.on('data', (chunk) => {\n        data.push(chunk);\n      });\n      res.on('end', () => {\n        this._type = res.headers['content-type'] || this._type;\n        this._size = Buffer.byteLength(Buffer.concat(data));\n        callback(null, Buffer.concat(data));\n      });\n    });\n\n    req.on('error', (err) => {\n      callback(err);\n    });\n  }\n\n  getDataUri(callback) {\n    this.getBuffer((err, buffer) => {\n      if (err) return callback(err);\n      const base64 = buffer.toString('base64');\n      const dataUri = `data:${this._type};base64,${base64}`;\n      callback(null, dataUri);\n    });\n  }\n\n  createReadStream() {\n    const stream = new Readable();\n    stream._read = () => {};\n\n    const protocol = this.url.startsWith('https') ? https : http;\n    const req = protocol.get(this.url, this.urlOpts, (res) => {\n      if (res.statusCode < 200 || res.statusCode >= 300) {\n        stream.emit('error', new Error(`HTTP status code ${res.statusCode}`));\n        return stream.push(null);\n      }\n      res.pipe(stream);\n    });\n\n    req.on('error', (err) => {\n      stream.emit('error', err);\n      stream.push(null);\n    });\n\n    return stream;\n  }\n\n  size(callback) {\n    if (this._size !== null) {\n      return callback(null, this._size);\n    }\n\n    const protocol = this.url.startsWith('https') ? https : http;\n    const req = protocol.get(this.url, this.urlOpts, (res) => {\n      if (res.statusCode < 200 || res.statusCode >= 300) {\n        return callback(new Error(`HTTP status code ${res.statusCode}`));\n      }\n      const contentLength = res.headers['content-length'];\n      if (!contentLength) {\n        return callback(new Error('Content-Length header missing'));\n      }\n      this._size = parseInt(contentLength, 10);\n      callback(null, this._size);\n    });\n\n    req.on('error', (err) => {\n      callback(err);\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}\n```"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function that sends a POST request to a specified URL with form-urlencoded data and handles the response asynchronously.\n\nFunction Description: The function `sendPostRequest` constructs and sends an HTTP POST request to a given endpoint. It sets the appropriate content type header for form-urlencoded data, includes credentials if needed, and logs the server's response upon completion. This is useful for submitting form data or making authenticated API requests.\n\nInput: None (The URL and data are hardcoded in this example, but could be parameterized in a real implementation)\n\nOutput: None (The function logs the response to the console, but doesn't return anything)",
    "Canonical_solution": "function sendPostRequest() {\n    const data = 'secret=*%5*!';\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/post');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nasync function sendPostRequest() {\n  const url = 'https://example.com/api/submit';\n  const data = new URLSearchParams();\n  data.append('username', 'user123');\n  data.append('password', 'pass123');\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: data,\n      credentials: 'include'\n    });\n\n    const result = await response.text();\n    console.log('Server response:', result);\n  } catch (error) {\n    console.error('Request failed:', error);\n  }\n}\n```"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a function that handles different types of HTTP requests and script imports, then communicates the results back to a sender.\n\nFunction Description: The function `run_test` processes incoming data to determine which type of request or script import to execute. It supports XMLHttpRequest (XHR), Fetch API, and `importScripts` methods. Based on the input data, it initiates the corresponding operation and sends the result or error message back to the sender via the `postMessage` method.\n\nInput:  \n- `data` [String] - A string indicating the type of operation to perform. Valid values are 'xhr', 'fetch', or 'importScripts'.  \n- `sender` [Object] - An object with a `postMessage` method used to send the response or error message back to the caller.\n\nOutput:  \n- No direct return value. The function communicates results asynchronously via `sender.postMessage()`, sending either the response data (for successful operations) or an error message (for failures).  \n\nThe function handles the following cases:  \n1. If `data` is 'xhr', it performs an XMLHttpRequest GET operation and sends the response text or an error message.  \n2. If `data` is 'fetch', it uses the Fetch API to retrieve data and sends the response text or an error message.  \n3. If `data` is 'importScripts', it imports a script and sends a predefined message from the imported script.  \n4. For any other `data` value, it sends an \"Unexpected message\" response.",
    "Canonical_solution": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'synthesized-response.txt', true);\n    xhr.responseType = 'text';\n    xhr.send();\n    xhr.onload = evt => sender.postMessage(xhr.responseText);\n    xhr.onerror = () => sender.postMessage('XHR failed!');\n  } else if (data === 'fetch') {\n    fetch('synthesized-response.txt')\n        .then(response => response.text())\n        .then(data => sender.postMessage(data))\n        .catch(error => sender.postMessage('Fetch failed!'));\n  } else if (data === 'importScripts') {\n    importScripts('synthesized-response.js');\n    sender.postMessage(message);\n  } else {\n    sender.postMessage('Unexpected message! ' + data);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nfunction run_test(data, sender) {\n    if (data === 'xhr') {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', 'https://jsonplaceholder.typicode.com/posts/1', true);\n        xhr.onload = function () {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                sender.postMessage(xhr.responseText);\n            } else {\n                sender.postMessage('XHR Error: ' + xhr.statusText);\n            }\n        };\n        xhr.onerror = function () {\n            sender.postMessage('XHR Network Error');\n        };\n        xhr.send();\n    } else if (data === 'fetch') {\n        fetch('https://jsonplaceholder.typicode.com/posts/1')\n            .then(response => {\n                if (!response.ok) throw new Error('Fetch API error: ' + response.statusText);\n                return response.text();\n            })\n            .then(text => sender.postMessage(text))\n            .catch(error => sender.postMessage('Fetch Error: ' + error.message));\n    } else if (data === 'importScripts') {\n        try {\n            importScripts('https://example.com/script.js');\n            sender.postMessage('Script imported successfully.');\n        } catch (e) {\n            sender.postMessage('Import Script Error: ' + e.message);\n        }\n    } else {\n        sender.postMessage('Unexpected message: ' + data);\n    }\n}\n```"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a function that asynchronously loads YAML content from a specified URL and processes it using a callback function.\n\nFunction Description: The function `loadYamlUrl` initiates an HTTP GET request to fetch YAML content from a given URL. It handles the response asynchronously, checking for a successful status code (200) before passing the YAML text to a processing function (`yamlToForm`) and logging the response to the console.\n\nInput: \n- `url` [String] - The URL from which to fetch the YAML content.\n\nOutput: \n- None (The function does not return a value directly but processes the YAML content via the `yamlToForm` callback and logs the response to the console.)",
    "Canonical_solution": "function loadYamlUrl(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'text';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            yamlToForm(this.response);\n            console.log(this.response);\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nfunction loadYamlUrl(url) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            yamlToForm(xhr.responseText);\n            console.log(xhr.responseText);\n        }\n    };\n    xhr.send();\n}\n```"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs from multiple services (is.gd, goo.gl, budurl.com, snipurl.com, etc.) by making HTTP requests to their APIs or following HTTP redirects. It handles recursive expansion with depth control and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening services to their domain names\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration\n- expand(args: [Object], callback: [Function]) -> [void] - Recursively expands a shortened URL\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to call with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n      - err: [Error] - Any error that occurred (optional)\n      - headers: [Object] - Response headers (optional)\n      - urlp: [Object] - Parsed URL object (optional)",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }.bind(this)\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst http = require('http');\nconst https = require('https');\nconst url = require('url');\n\nclass URLExpander {\n  constructor() {\n    this.map = {\n      'is.gd': 'is.gd',\n      'goo.gl': 'goo.gl',\n      'budurl.com': 'budurl.com',\n      'snipurl.com': 'snipurl.com'\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      isgd: (shortUrl, callback) => {\n        const parsed = url.parse(shortUrl);\n        const options = {\n          hostname: parsed.hostname,\n          path: parsed.path,\n          method: 'GET',\n          headers: { 'User-Agent': 'URLExpander' }\n        };\n        const req = https.request(options, res => {\n          let data = '';\n          res.on('data', chunk => data += chunk.toString());\n          res.on('end', () => {\n            if (res.headers.location) {\n              callback(null, res.headers.location);\n            } else {\n              callback(new Error('No location header found'));\n            }\n          });\n        });\n        req.on('error', err => callback(err));\n        req.end();\n      },\n      gooGl: (shortUrl, callback) => {\n        const parsed = url.parse(shortUrl);\n        const options = {\n          hostname: parsed.hostname,\n          path: parsed.path,\n          method: 'GET',\n          headers: { 'User-Agent': 'URLExpander' }\n        };\n        const req = https.request(options, res => {\n          if (res.statusCode === 301 || res.statusCode === 302) {\n            callback(null, res.headers.location);\n          } else {\n            callback(new Error(`Unexpected status code ${res.statusCode}`));\n          }\n        });\n        req.on('error', err => callback(err));\n        req.end();\n      },\n      budurlCom: (shortUrl, callback) => {\n        const parsed = url.parse(shortUrl);\n        const options = {\n          hostname: parsed.hostname,\n          path: parsed.path,\n          method: 'GET',\n          headers: { 'User-Agent': 'URLExpander' }\n        };\n        const req = https.request(options, res => {\n          if (res.headers.location) {\n            callback(null, res.headers.location);\n          } else {\n            callback(new Error('No location header found'));\n          }\n        });\n        req.on('error', err => callback(err));\n        req.end();\n      },\n      snipurlCom: (shortUrl, callback) => {\n        const parsed = url.parse(shortUrl);\n        const options = {\n          hostname: parsed.hostname,\n          path: parsed.path,\n          method: 'GET',\n          headers: { 'User-Agent': 'URLExpander' }\n        };\n        const req = https.request(options, res => {\n          if (res.headers.location) {\n            callback(null, res.headers.location);\n          } else {\n            callback(new Error('No location header found'));\n          }\n        });\n        req.on('error', err => callback(err));\n        req.end();\n      }\n    };\n  }\n\n  expand(args, callback) {\n    const { url: currentUrl, depth = 0, seen = {} } = args;\n    if (depth > 10) {\n      return callback({ ...args, err: new Error('Maximum recursion depth exceeded') });\n    }\n    if (seen[currentUrl]) {\n      return callback({ ...args, err: new Error('Cycle detected') });\n    }\n    seen[currentUrl] = true;\n\n    const parsedUrl = url.parse(currentUrl);\n    const domain = parsedUrl.hostname.replace(/^www\\./, '');\n    if (!this.map[domain]) {\n      return callback({ ...args, url: currentUrl, seen });\n    }\n\n    const apiHandler = this.APIs[domain.toLowerCase()];\n    if (!apiHandler) {\n      return callback({ ...args, err: new Error('Unsupported service') });\n    }\n\n    apiHandler(currentUrl, (err, expandedUrl) => {\n      if (err) {\n        return callback({ ...args, err });\n      }\n      this.expand({ url: expandedUrl, depth: depth + 1, seen }, callback);\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a reusable HTTP server class in JavaScript using the Express framework that can handle various HTTP methods, middleware configuration, and file uploads.\n\nClass Description: The HTTPServer class encapsulates an Express application with configurable routes, middleware, and file upload capabilities. It provides methods to start/stop the server and add route handlers for different HTTP methods.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number the server listens on\n- server: [Object|null] - The HTTP server instance (null before starting)\n\nMethods:\n- constructor(port) -> [HTTPServer] - Initializes the Express app with middleware and file upload handling\n- start() -> [Promise] - Starts the server on the specified port\n- stop() -> [void] - Stops the server if running\n- addRoute(method, path, handler) -> [void] - Adds a route handler for a specific HTTP method\n- get(path, handler) -> [void] - Adds a GET route handler\n- post(path, handler) -> [void] - Adds a POST route handler\n- put(path, handler) -> [void] - Adds a PUT route handler\n- delete(path, handler) -> [void] - Adds a DELETE route handler\n- patch(path, handler) -> [void] - Adds a PATCH route handler\n- options(path, handler) -> [void] - Adds an OPTIONS route handler\n- trace(path, handler) -> [void] - Adds a TRACE route handler\n- head(path, handler) -> [void] - Adds a HEAD route handler",
    "Canonical_solution": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst multer = require(\"multer\");\n\nclass HTTPServer {\n    constructor(port) {\n        this.app = express();\n        this.port = port;\n        this.server = null;\n        \n        // Configure middleware\n        this.app.use(bodyParser.raw({type:\"*/*\"}));\n        this.app.use(cookieParser(undefined,{decode:String}));\n        \n        // File upload handling\n        const fileUploadApp = express();\n        const mp = multer({ storage: multer.memoryStorage() }).any();\n        fileUploadApp.post(\"/file-upload\",function(req,res,next) {\n            mp(req,res,function(err) {\n                req._body = true;\n                next(err);\n            })\n        },bodyParser.json(),function(req,res) {\n            res.json({\n                body: req.body,\n                files: req.files\n            })\n        });\n        this.app.use(fileUploadApp);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            this.server = this.app.listen(this.port, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n\n    addRoute(method, path, handler) {\n        this.app[method.toLowerCase()](path, handler);\n    }\n\n    get(path, handler) {\n        this.addRoute('get', path, handler);\n    }\n\n    post(path, handler) {\n        this.addRoute('post', path, handler);\n    }\n\n    put(path, handler) {\n        this.addRoute('put', path, handler);\n    }\n\n    delete(path, handler) {\n        this.addRoute('delete', path, handler);\n    }\n\n    patch(path, handler) {\n        this.addRoute('patch', path, handler);\n    }\n\n    options(path, handler) {\n        this.addRoute('options', path, handler);\n    }\n\n    trace(path, handler) {\n        this.addRoute('trace', path, handler);\n    }\n\n    head(path, handler) {\n        this.addRoute('head', path, handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "```js\nconst express = require('express');\nconst multer = require('multer');\nconst http = require('http');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n\n    // Configure middleware for parsing JSON and URL-encoded data\n    this.app.use(express.json());\n    this.app.use(express.urlencoded({ extended: true }));\n\n    // Configure file upload handling using multer (default to memory storage)\n    this.upload = multer();\n\n    // Default route if none defined\n    this.app.use((req, res, next) => {\n      res.status(404).json({ error: 'Route not found' });\n    });\n  }\n\n  async start() {\n    return new Promise((resolve, reject) => {\n      this.server = http.createServer(this.app);\n      this.server.listen(this.port, () => {\n        console.log(`Server running on port ${this.port}`);\n        resolve();\n      }).on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close(() => {\n        console.log('Server stopped');\n      });\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Implement a Twitter HTTP client class in JavaScript that handles API requests to Twitter, including request construction, execution, and response processing with error handling and clock synchronization.\n\nClass Description: The TwitterHTTPClient class provides methods to interact with Twitter's REST API. It handles HTTP requests (GET/POST), manages authentication, processes responses, and maintains clock synchronization with Twitter's servers.\n\nAttributes:\n- config: [Object] - Configuration object containing API credentials and settings\n- _twitter_time_minus_local_time_ms: [Number] - Time difference between Twitter's server time and local time in milliseconds\n\nMethods:\n- constructor(config) -> [TwitterHTTPClient] - Initializes the client with configuration\n- request(method, path, params, callback) -> [Promise] - Makes HTTP requests to Twitter API\n- _doRestApiRequest(reqOpts, twitOptions, method, callback) -> [void] - Executes the actual HTTP request\n- _updateClockOffsetFromResponse(resp) -> [void] - Updates the clock offset based on Twitter's server time\n\nMethod Details:\n1. request(method, path, params, callback)\n   - Input:\n     - method: [String] - HTTP method ('GET' or 'POST')\n     - path: [String] - API endpoint path\n     - params: [Object] - Request parameters\n     - callback: [Function] - Callback function for handling response\n   - Output: [Promise] - Resolves with response data or rejects with error\n\n2. _doRestApiRequest(reqOpts, twitOptions, method, callback)\n   - Input:\n     - reqOpts: [Object] - Request options including URL and headers\n     - twitOptions: [Object] - Twitter-specific options\n     - method: [String] - HTTP method\n     - callback: [Function] - Callback for handling response\n   - Output: [void] - Calls callback with response data or error\n\n3. _updateClockOffsetFromResponse(resp)\n   - Input:\n     - resp: [Object] - HTTP response object\n   - Output: [void] - Updates internal clock offset value",
    "Canonical_solution": "var request = require('request');\nvar helpers = require('./helpers');\n\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    var self = this;\n    assert(method == 'GET' || method == 'POST');\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      var _returnErrorToUser = function (err) {\n        if (callback && typeof callback === 'function') {\n          callback(err, null, null);\n        }\n        reject(err);\n      }\n\n      self._buildReqOpts(method, path, params, false, function (err, reqOpts) {\n        if (err) {\n          _returnErrorToUser(err);\n          return;\n        }\n\n        var twitOptions = (params && params.twit_options) || {};\n\n        process.nextTick(function () {\n          self._doRestApiRequest(reqOpts, twitOptions, method, function (err, parsedBody, resp) {\n            self._updateClockOffsetFromResponse(resp);\n\n            if (self.config.trusted_cert_fingerprints) {\n              if (!resp.socket.authorized) {\n                var authErrMsg = resp.socket.authorizationError.toString();\n                var err = helpers.makeTwitError('The peer certificate was not signed; ' + authErrMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n              var fingerprint = resp.socket.getPeerCertificate().fingerprint;\n              var trustedFingerprints = self.config.trusted_cert_fingerprints;\n              if (trustedFingerprints.indexOf(fingerprint) === -1) {\n                var errMsg = util.format('Certificate untrusted. Trusted fingerprints are: %s. Got fingerprint: %s.',\n                                         trustedFingerprints.join(','), fingerprint);\n                var err = new Error(errMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n            }\n\n            if (callback && typeof callback === 'function') {\n              callback(err, parsedBody, resp);\n            }\n\n            resolve({ data: parsedBody, resp: resp });\n            return;\n          });\n        });\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    var request_method = request[method.toLowerCase()];\n    var req = request_method(reqOpts);\n\n    var body = '';\n    var response = null;\n\n    var onRequestComplete = function () {\n      if (body !== '') {\n        try {\n          body = JSON.parse(body);\n        } catch (jsonDecodeError) {\n          var err = helpers.makeTwitError('JSON decode error: Twitter HTTP response body was not valid JSON');\n          err.statusCode = response ? response.statusCode: null;\n          err.allErrors.concat({error: jsonDecodeError.toString()});\n          callback(err, body, response);\n          return;\n        }\n      }\n\n      if (typeof body === 'object' && (body.error || body.errors)) {\n        var err = helpers.makeTwitError('Twitter API Error');\n        err.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n\n      callback(err, body, response);\n    }\n\n    req.on('response', function (res) {\n      response = res;\n      req.on('data', function (chunk) {\n        body += chunk.toString('utf8');\n      });\n      req.on('end', function () {\n        onRequestComplete();\n      });\n    });\n\n    req.on('error', function (err) {\n      if (twitOptions.retry &&\n          STATUS_CODES_TO_ABORT_ON.indexOf(err.statusCode) !== -1\n      ) {\n        self.request(method, path, params, callback);\n        return;\n      } else {\n        err.statusCode = null;\n        err.code = null;\n        err.allErrors = [];\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    var self = this;\n    if (resp && resp.headers && resp.headers.date &&\n        new Date(resp.headers.date).toString() !== 'Invalid Date'\n    ) {\n      var twitterTimeMs = new Date(resp.headers.date).getTime();\n      self._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  async request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearerToken}`,\n          'Content-Type': 'application/json',\n        },\n      };\n\n      if (method === 'GET') {\n        reqOpts.url = `${this.config.baseURL}${path}?${new URLSearchParams(params).toString()}`;\n      } else if (method === 'POST') {\n        reqOpts.url = `${this.config.baseURL}${path}`;\n        reqOpts.body = JSON.stringify(params);\n      }\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, resData) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(resData);\n        if (callback) callback(null, resData);\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const { url, headers, body } = reqOpts;\n\n    fetch(url, {\n      method,\n      headers,\n      body: body || undefined,\n    })\n      .then(async (response) => {\n        const resp = await response.json();\n        this._updateClockOffsetFromResponse(response.headers.get('Date'));\n        callback(null, resp);\n      })\n      .catch((error) => {\n        callback(error, null);\n      });\n  }\n\n  _updateClockOffsetFromResponse(dateHeader) {\n    const twitterTime = new Date(dateHeader).getTime();\n    const localTime = Date.now();\n    this._twitter_time_minus_local_time_ms = twitterTime - localTime;\n  }\n}\n```"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by detecting the shortening service and using the appropriate API or HTTP HEAD request to follow redirects. It handles recursive expansion with depth limiting and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening service names to their associated domains\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration including known URL shortening services and timeout\n- expand(args: [Object], callback: [Function]) -> [void] - The main method that initiates URL expansion\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to be called with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - err: [Error] - Any error encountered (optional)\n      - headers: [Object] - Response headers (optional)\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n\nThe class includes several internal API methods (isgd, googl, budurl, snipurl, generic) that handle specific URL shortening services or generic URL expansion through HTTP HEAD requests. These methods are not meant to be called directly but are used internally by the expand method.",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass URLExpander {\n  constructor() {\n    this.map = {\n      isgd: 'is.gd',\n      googl: 'goo.gl',\n      bitly: 'bit.ly',\n      tinyurl: 'tinyurl.com',\n      budurl: 'budurl.com',\n      snipurl: 'snipurl.com',\n      owly: 'ow.ly',\n      tinycc: 'tiny.cc',\n      rebrandly: 'rebrand.ly',\n      adfoc: 'adfoc.us'\n    };\n\n    this.timeout = 5000;\n\n    this.APIs = {\n      isgd: (url, args, callback) => {\n        const req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.onreadystatechange = () => {\n          if (req.readyState === 4 && req.status >= 200 && req.status < 300) {\n            try {\n              const expandedUrl = req.getResponseHeader('Location') || req.responseText.match(/\"destination\":\"(.*?)\"/)[1];\n              args.url = expandedUrl;\n              args.depth++;\n              args.seen[url] = true;\n              this.expand(args, callback);\n            } catch (err) {\n              callback({ ...args, err });\n            }\n          } else if (req.readyState === 4) {\n            callback({ ...args, err: new Error(`Failed to expand ${url}`) });\n          }\n        };\n        req.send();\n      },\n      googl: (url, args, callback) => {\n        const req = new XMLHttpRequest();\n        req.open('HEAD', url, true);\n        req.onreadystatechange = () => {\n          if (req.readyState === 4 && req.status >= 200 && req.status < 300) {\n            const expandedUrl = req.getResponseHeader('Location');\n            if (expandedUrl) {\n              args.url = expandedUrl;\n              args.depth++;\n              args.seen[url] = true;\n              this.expand(args, callback);\n            } else {\n              callback({ ...args, err: new Error(`No redirect found for ${url}`) });\n            }\n          } else if (req.readyState === 4) {\n            callback({ ...args, err: new Error(`Failed to expand ${url}`) });\n          }\n        };\n        req.send();\n      },\n      generic: (url, args, callback) => {\n        const req = new XMLHttpRequest();\n        req.open('HEAD', url, true);\n        req.onreadystatechange = () => {\n          if (req.readyState === 4 && req.status >= 200 && req.status < 300) {\n            const expandedUrl = req.getResponseHeader('Location');\n            if (expandedUrl) {\n              args.url = expandedUrl;\n              args.depth++;\n              args.seen[url] = true;\n              this.expand(args, callback);\n            } else {\n              callback(args);\n            }\n          } else if (req.readyState === 4) {\n            callback({ ...args, err: new Error(`Failed to expand ${url}`) });\n          }\n        };\n        req.send();\n      }\n    };\n  }\n\n  expand(args, callback) {\n    const { url, depth = 0, seen = {} } = args;\n    if (depth > 10) {\n      return callback({ ...args, err: new Error('Maximum recursion depth exceeded') });\n    }\n    if (seen[url]) {\n      return callback({ ...args, err: new Error('Cycle detected in URL expansion') });\n    }\n\n    let serviceFound = false;\n    for (const [service, domain] of Object.entries(this.map)) {\n      if (url.includes(domain)) {\n        this.APIs[service] ? this.APIs[service](url, { ...args, depth, seen }, callback) : this.APIs.generic(url, { ...args, depth, seen }, callback);\n        serviceFound = true;\n        break;\n      }\n    }\n\n    if (!serviceFound) {\n      callback(args);\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a function to start an Express server with REST API endpoints for managing tourist attractions, including retrieving approved attractions, adding new attractions, and fetching specific attraction details.\n\nFunction Description: The function initializes an Express application, configures middleware, sets up REST API routes using connect-rest, and starts an HTTP server. It handles GET and POST requests for attractions data, connects to a MongoDB model for data persistence, and implements error handling through domains.\n\nInput: None (The function takes no parameters but relies on environment variables like PORT and requires external modules)\n\nOutput: Returns the HTTP server instance that was created and started.\n\nMethods:\n\n- GET /attractions: Retrieves all approved attractions (returns array of attraction objects)\n- POST /attraction: Creates a new attraction (requires name, description, location, and email in request body, returns new attraction ID)\n- GET /attraction/:id: Retrieves details of a specific attraction (requires ID parameter, returns attraction object)\n\nError Handling:\n- Implements domain-based error handling that logs errors and gracefully shuts down the server\n- Returns appropriate error messages for database operations\n\nDependencies:\n- Requires Express, connect-rest, body-parser, and a MongoDB model (Attraction)\n- Uses cluster module for worker process management in case of errors",
    "Canonical_solution": "function startServer() {\n    var http = require('http'),\n        express = require('express'),\n        app = express();\n\n    app.set('port', process.env.PORT || 3000);\n\n    app.use(express.static(__dirname + '/public'));\n    app.use(require('body-parser')());\n\n    var rest = require('connect-rest');\n    var apiOptions = {\n        context: '/',\n        domain: require('domain').create(),\n    };\n\n    apiOptions.domain.on('error', function(err){\n        console.log('API domain error.\\n', err.stack);\n        setTimeout(function(){\n            console.log('Server shutting down after API domain error.');\n            process.exit(1);\n        }, 5000);\n        server.close();\n        var worker = require('cluster').worker;\n        if(worker) worker.disconnect();\n    });\n\n    var Attraction = require('./models/attraction.js');\n\n    rest.get('/attractions', function(req, content, cb){\n        Attraction.find({ approved: true }, function(err, attractions){\n            if(err) return cb({ error: 'Internal error.' });\n            cb(null, attractions.map(function(a){\n                return {\n                    name: a.name,\n                    description: a.description,\n                    location: a.location,\n                };\n            }));\n        });\n    });\n\n    rest.post('/attraction', function(req, content, cb){\n        var a = new Attraction({\n            name: req.body.name,\n            description: req.body.description,\n            location: { lat: req.body.lat, lng: req.body.lng },\n            history: {\n                event: 'created',\n                email: req.body.email,\n                date: new Date(),\n            },\n            approved: false,\n        });\n        a.save(function(err, a){\n            if(err) return cb({ error: 'Unable to add attraction.' });\n            cb(null, { id: a._id });\n        }); \n    });\n\n    rest.get('/attraction/:id', function(req, content, cb){\n        Attraction.findById(req.params.id, function(err, a){\n            if(err) return cb({ error: 'Unable to retrieve attraction.' });\n            cb(null, { \n                name: a.name,\n                description: a.description,\n                location: a.location,\n            });\n        });\n    });\n\n    var server = http.createServer(app).listen(app.get('port'), function(){\n        console.log( 'Express started in ' + app.get('env') +\n            ' mode on http://localhost:' + app.get('port') +\n            '; press Ctrl-C to terminate.' );\n    });\n\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst http = require('http');\nconst connectRest = require('connect-rest');\nconst bodyParser = require('body-parser');\nconst cluster = require('cluster');\nconst numCPUs = require('os').cpus().length;\nconst Attraction = require('./models/Attraction');\n\nfunction startServer() {\n  if (cluster.isMaster) {\n    console.log(`Master ${process.pid} is running`);\n\n    for (let i = 0; i < numCPUs; i++) {\n      cluster.fork();\n    }\n\n    cluster.on('exit', (worker, code, signal) => {\n      console.log(`Worker ${worker.process.pid} died`);\n      cluster.fork();\n    });\n\n    return;\n  }\n\n  const app = express();\n  const server = http.createServer(app);\n\n  const domain = require('domain').create();\n\n  domain.on('error', (err) => {\n    console.error('Domain error:', err);\n    server.close(() => process.exit(1));\n  });\n\n  domain.run(() => {\n    app.use(bodyParser.json());\n    connectRest(app, {\n      restPath: '/api',\n      apiVersion: '1.0',\n      resources: [\n        {\n          name: 'attractions',\n          methods: ['GET'],\n          handler: async (req, res) => {\n            try {\n              const attractions = await Attraction.find({ approved: true });\n              res.json(attractions);\n            } catch (error) {\n              res.status(500).json({ error: 'Failed to retrieve attractions' });\n            }\n          }\n        },\n        {\n          name: 'attraction',\n          methods: ['POST'],\n          handler: async (req, res) => {\n            try {\n              const { name, description, location, email } = req.body;\n              const attraction = new Attraction({ name, description, location, email });\n              await attraction.save();\n              res.status(201).json({ id: attraction._id });\n            } catch (error) {\n              res.status(500).json({ error: 'Failed to create attraction' });\n            }\n          }\n        },\n        {\n          name: 'attraction/:id',\n          methods: ['GET'],\n          handler: async (req, res) => {\n            try {\n              const attraction = await Attraction.findById(req.params.id);\n              if (!attraction) {\n                return res.status(404).json({ error: 'Attraction not found' });\n              }\n              res.json(attraction);\n            } catch (error) {\n              res.status(500).json({ error: 'Failed to retrieve attraction details' });\n            }\n          }\n        }\n      ]\n    });\n\n    const PORT = process.env.PORT || 3000;\n    server.listen(PORT, () => {\n      console.log(`Worker ${process.pid} listening on port ${PORT}`);\n    });\n  });\n\n  return server;\n}\n\nmodule.exports = startServer;\n```"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that makes an HTTP request to a specified URL with custom headers and handles the response.\n\nFunction Description: The function `makeHttpRequest` performs an HTTP GET request to a specified URL with custom headers and decompresses gzip-encoded responses. It uses the `request` module to send the request and handles the response through a callback function that checks for errors and logs the response body if successful.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function logs the response body to the console if the request is successful.)",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Accept-Encoding': 'gzip, deflate, sdch',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Referer': 'http://www.wikipedia.org/',\n        'Cookie': 'GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14',\n        'Connection': 'keep-alive'\n    };\n\n    var options = {\n        url: 'http://localhost:28139/',\n        headers: headers,\n        gzip: true\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst request = require('request');\nconst zlib = require('zlib');\n\nfunction makeHttpRequest() {\n  const url = 'https://example.com';\n  const headers = {\n    'User-Agent': 'Custom-User-Agent',\n    'Accept-Encoding': 'gzip'\n  };\n\n  request({ url, headers }, (error, response, body) => {\n    if (error) {\n      return console.error('Request error:', error);\n    }\n\n    if (response.headers['content-encoding'] === 'gzip') {\n      zlib.gunzip(body, (err, decompressed) => {\n        if (err) {\n          return console.error('Decompression error:', err);\n        }\n        console.log(decompressed.toString());\n      });\n    } else {\n      console.log(body);\n    }\n  });\n}\n```"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, and integrate it with Next.js for server-side rendering.\n\nFunction Description: The function `setupServer` initializes an Express server with session management configured to use MongoDB for session storage. It integrates with Next.js for handling server-side rendering and routes all requests to the Next.js request handler. The server listens on a specified port and logs the root URL when ready.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Port number to listen on (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that listens on the specified port and handles requests. It logs the root URL to the console when the server is ready.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    const next = require('next');\n    const mongoose = require('mongoose');\n\n    const dev = process.env.NODE_ENV !== 'production';\n    const MONGO_URL = process.env.MONGO_URL_TEST;\n    const port = process.env.PORT || 8000;\n    const ROOT_URL = `http://localhost:${port}`;\n\n    const app = next({ dev });\n    const handle = app.getRequestHandler();\n\n    const server = express();\n\n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: MONGO_URL,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => handle(req, res));\n\n    server.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on ${ROOT_URL}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```js\nconst express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-native')(session);\nconst next = require('next');\n\nasync function setupServer() {\n  const dev = process.env.NODE_ENV !== 'production';\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  await app.prepare();\n\n  const server = express();\n\n  const store = new MongoDBStore({\n    url: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  store.on('error', function (e) {\n    console.error('Session store error', e);\n  });\n\n  server.use(\n    session({\n      name: process.env.SESSION_NAME || 'session',\n      secret: process.env.SESSION_SECRET || 'keyboard cat',\n      resave: false,\n      saveUninitialized: false,\n      store: store,\n      cookie: {\n        secure: !dev,\n        httpOnly: true,\n        maxAge: 1000 * 60 * 60 * 24, // 1 day\n      },\n    })\n  );\n\n  server.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  const PORT = process.env.PORT || 8000;\n  server.listen(PORT, () => {\n    console.log(`> Ready on http://localhost:${PORT}`);\n  });\n}\n\nsetupServer();\n```"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a function to set up an Express server that serves static files for a specific route.\n\nFunction Description: The function `setupServer` initializes an Express application, configures a route to serve a static HTML file, and starts the server on port 3000. It is designed to handle GET requests for the '/users' path by sending the corresponding HTML file.\n\nInput: None\n\nOutput: None (The function starts the server and logs a message to the console when the server is running.)",
    "Canonical_solution": "const express = require('express');\nconst path = require('path');\n\nfunction setupServer() {\n    const app = express();\n    \n    app.get('/users', function (req, res) {\n        res.sendFile(path.join(__dirname, 'modules/users/views/list.html'));\n    });\n\n    app.listen(3000, function () {\n        console.log('Servidor rodando em localhost:3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst path = require('path');\n\nfunction setupServer() {\n  const app = express();\n  const PORT = 3000;\n\n  app.use('/users', express.static(path.join(__dirname, 'public')));\n\n  app.listen(PORT, () => {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  });\n}\n```"
  }
]