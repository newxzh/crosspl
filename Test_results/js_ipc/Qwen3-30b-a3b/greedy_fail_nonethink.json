[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a class for interacting with the EXMO cryptocurrency exchange API, handling authentication, request signing, and response processing.\n\nClass Description: The Trader class provides methods to authenticate and send signed requests to the EXMO API. It handles nonce generation, request signing using HMAC-SHA512, and response error handling.\n\nAttributes:\n- key: [String] - API key for authentication\n- secret: [String] - API secret for request signing\n- currency: [String] - Base currency for trading pairs\n- asset: [String] - Asset currency for trading pairs\n- pair: [String] - Combined trading pair in format 'asset_currency'\n- name: [String] - Exchange name (fixed as 'EXMO')\n- nonce: [Number] - Counter for API requests to prevent replay attacks\n\nMethods:\n- constructor(config) -> [Void] - Initializes the trader instance with configuration including API keys and currency pairs\n- api_query(method, params, callback) -> [Void] - Makes authenticated POST requests to the EXMO API\n  - method: [String] - API endpoint method\n  - params: [Object] - Request parameters\n  - callback: [Function] - Callback function to handle response (error, data)",
    "Canonical_solution": "const CryptoJS = require(\"crypto-js\");\nconst querystring = require('querystring');\nconst request = require('request');\n\nclass Trader {\n  constructor(config) {\n    this.key = \"\";\n    this.secret = \"\";\n    \n    if(_.isObject(config)) {\n      if(_.isString(config.key)) this.key = config.key;\n      if(_.isString(config.secret)) this.secret = config.secret;\n      this.currency = config.currency;\n      this.asset = config.asset;\n      this.pair = this.asset + '_' + this.currency;\n    };\n\n    this.name = 'EXMO';\n    this.nonce = new Date() * 1000;\n  }\n\n  api_query(method, params, callback) {\n    params.nonce = this.nonce++;\n    var post_data = querystring.stringify(params);\n\n    var options = {\n      url: API_URL + method,\n      headers: {'Key': this.key,'Sign': CryptoJS.HmacSHA512(post_data, this.secret).toString(CryptoJS.enc.hex) },\n      form: params\n    };\n    \n    request.post(options, function (error, response, body) {\n      if (!error && response.statusCode == 200) {\n        data=JSON.parse(body);          \n        if(data.error) error = { message: data.error }\n        else if (data.result!=undefined && data.result==false)  error = { message: '\"result\": false' } ;\n        callback(error, data);\n      } else {\n        console.log('cb request error');\n        console.log(body);\n\n        if(error) {\n          if(includes(error.message, recoverableErrors)) {\n            error.notFatal = true;\n          }\n          console.log(error);\n          callback(error);\n        };\n      };\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class Trader {\n  constructor(config) {\n    this.key = config.key;\n    this.secret = config.secret;\n    this.currency = config.currency;\n    this.asset = config.asset;\n    this.pair = `${this.asset}_${this.currency}`;\n    this.name = 'EXMO';\n    this.nonce = 0;\n  }\n\n  api_query(method, params, callback) {\n    this.nonce++;\n    const data = {\n      ...params,\n      key: this.key,\n      nonce: this.nonce\n    };\n    const message = `${method}\\n${JSON.stringify(data)}`;\n    const signature = crypto.createHmac('sha512', this.secret).update(message).digest('hex');\n    const headers = {\n      'Content-Type': 'application/json',\n      'Key': this.key,\n      'Sign': signature\n    };\n    fetch(`https://api.exmo.com/v1/${method}`, {\n      method: 'POST',\n      headers: headers,\n      body: JSON.stringify(data)\n    })\n    .then(response => response.json())\n    .then(json => {\n      if (json.error) {\n        callback(json.error, null);\n      } else {\n        callback(null, json);\n      }\n    })\n    .catch(error => {\n      callback(error, null);\n    });\n  }\n}"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a function that sets up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB, integrates with Next.js for server-side rendering, and sets up basic route handling. It prepares the Next.js application, configures middleware, and starts the server on a specified port.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret for session encryption)\n\nOutput: Returns a Promise that resolves to the configured Express server instance when the Next.js app is prepared and the server is listening on the specified port.",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  return app.prepare().then(async () => {\n    const server = express();\n\n    server.use(express.json());\n\n    const sessionOptions = {\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: mongoSessionStore.create({\n        mongoUrl: MONGO_URL,\n        ttl: 14 * 24 * 60 * 60,\n      }),\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        httpOnly: true,\n        maxAge: 14 * 24 * 60 * 60 * 1000,\n        domain: 'localhost',\n      },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => {\n      const url = URL_MAP[req.path];\n      if (url) {\n        app.render(req, res, url);\n      } else {\n        handle(req, res);\n      }\n    });\n\n    server.listen(port, (err) => {\n      if (err) throw err;\n      console.log(`> Ready on ${ROOT_URL}`);\n    });\n\n    return server;\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\n\nasync function setupServer() {\n  const app = express();\n  const dev = process.env.NODE_ENV !== 'production';\n  const port = process.env.PORT || 8000;\n  const sessionName = process.env.SESSION_NAME || 'session';\n  const sessionSecret = process.env.SESSION_SECRET || 'secret';\n  const mongoUrl = process.env.MONGO_URL_TEST;\n\n  const nextApp = next({ dev });\n  const handle = nextApp.getRequestHandler();\n\n  await nextApp.prepare();\n\n  const store = new MongoDBStore({\n    uri: mongoUrl,\n    collection: 'sessions'\n  });\n\n  app.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: false,\n    store: store,\n    cookie: {\n      maxAge: 1000 * 60 * 60 * 24 * 7 // 1 week\n    }\n  }));\n\n  app.use((req, res, next) => {\n    req.session.userId = req.session.userId || null;\n    next();\n  });\n\n  app.use((req, res) => {\n    return handle(req, res);\n  });\n\n  const server = app.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n\n  return new Promise(resolve => {\n    server.on('listening', () => resolve(app));\n  });\n}\n\nmodule.exports = setupServer;"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by:\n1. Maintaining a mapping of known URL shortening services\n2. Using service-specific APIs when available\n3. Falling back to generic HTTP HEAD requests to follow redirects\n4. Preventing infinite loops through depth tracking and URL history\n\nAttributes:\nmap: [Object] - A mapping of URL shortening services to their known domains\ntimeout: [Number] - HTTP request timeout in milliseconds (default: 5000)\n\nMethods:\nconstructor() -> [URLExpander] - Initializes the URL expander with default configuration\n\nexpand: [Function](args: Object, callback: Function) -> [void] - Main method to expand a URL\n- args: Object containing:\n  - url: String - The URL to expand\n  - depth: Number - Current recursion depth (optional)\n  - seen: Object - Map of previously seen URLs (optional)\n- callback: Function to receive the result with expanded args object\n\nAPIs: [Object] - Collection of service-specific expansion methods:\n- isgd: [Function](args: Object, callback: Function) -> [void] - Expands is.gd URLs\n- googl: [Function](args: Object, callback: Function) -> [void] - Expands goo.gl URLs\n- budurl: [Function](args: Object, callback: Function) -> [void] - Expands budurl.com URLs\n- snipurl: [Function](args: Object, callback: Function) -> [void] - Expands snipurl.com and related URLs\n- generic: [Function](args: Object, callback: Function) -> [void] - Generic URL expansion using HTTP HEAD requests",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "{\n  \"map\": {\n    \"is.gd\": \"is.gd\",\n    \"goo.gl\": \"goo.gl\",\n    \"budurl.com\": \"budurl.com\",\n    \"snipurl.com\": \"snipurl.com\"\n  },\n  \"timeout\": 5000,\n  \"constructor\": function() {\n    this.map = {\n      \"is.gd\": \"is.gd\",\n      \"goo.gl\": \"goo.gl\",\n      \"budurl.com\": \"budurl.com\",\n      \"snipurl.com\": \"snipurl.com\"\n    };\n    this.timeout = 5000;\n  },\n  \"expand\": function(args, callback) {\n    var url = args.url;\n    var depth = args.depth || 0;\n    var seen = args.seen || {};\n    var self = this;\n\n    if (depth > 10) {\n      callback({ error: \"Maximum recursion depth exceeded\" });\n      return;\n    }\n\n    if (seen[url]) {\n      callback({ error: \"URL loop detected\" });\n      return;\n    }\n\n    seen[url] = true;\n\n    var service = null;\n    for (var key in this.map) {\n      if (url.indexOf(this.map[key]) !== -1) {\n        service = key;\n        break;\n      }\n    }\n\n    if (service) {\n      this[service]({ url: url, depth: depth + 1, seen: seen }, callback);\n    } else {\n      this.generic({ url: url, depth: depth + 1, seen: seen }, callback);\n    }\n  },\n  \"APIs\": {\n    \"isgd\": function(args, callback) {\n      var url = args.url;\n      var depth = args.depth;\n      var seen = args.seen;\n      var self = this;\n\n      fetch(\"https://is.gd/forward.php?format=json&shorturl=\" + encodeURIComponent(url), { timeout: self.timeout })\n        .then(function(response) {\n          if (!response.ok) {\n            throw new Error(\"HTTP error \" + response.status);\n          }\n          return response.json();\n        })\n        .then(function(data) {\n          if (data.error) {\n            callback({ error: data.error });\n          } else {\n            self.expand({ url: data.long_url, depth: depth, seen: seen }, callback);\n          }\n        })\n        .catch(function(error) {\n          callback({ error: error.message });\n        });\n    },\n    \"googl\": function(args, callback) {\n      var url = args.url;\n      var depth = args.depth;\n      var seen = args.seen;\n      var self = this;\n\n      fetch(\"https://www.googleapis.com/urlshortener/v1/url?shortUrl=\" + encodeURIComponent(url) + \"&key=YOUR_API_KEY\", { timeout: self.timeout })\n        .then(function(response) {\n          if (!response.ok) {\n            throw new Error(\"HTTP error \" + response.status);\n          }\n          return response.json();\n        })\n        .then(function(data) {\n          if (data.error) {\n            callback({ error: data.error.message });\n          } else {\n            self.expand({ url: data.longUrl, depth: depth, seen: seen }, callback);\n          }\n        })\n        .catch(function(error) {\n          callback({ error: error.message });\n        });\n    },\n    \"budurl\": function(args, callback) {\n      var url = args.url;\n      var depth = args.depth;\n      var seen = args.seen;\n      var self = this;\n\n      fetch(\"https://api.budurl.com/api/v2/expand?shorturl=\" + encodeURIComponent(url), { timeout: self.timeout })\n        .then(function(response) {\n          if (!response.ok) {\n            throw new Error(\"HTTP error \" + response.status);\n          }\n          return response.json();\n        })\n        .then(function(data) {\n          if (data.error) {\n            callback({ error: data.error });\n          } else {\n            self.expand({ url: data.long_url, depth: depth, seen: seen }, callback);\n          }\n        })\n        .catch(function(error) {\n          callback({ error: error.message });\n        });\n    },\n    \"snipurl\": function(args, callback) {\n      var url = args.url;\n      var depth = args.depth;\n      var seen = args.seen;\n      var self = this;\n\n      fetch(\"https://snipurl.com/api/expand?shorturl=\" + encodeURIComponent(url), { timeout: self.timeout })\n        .then(function(response) {\n          if (!response.ok) {\n            throw new Error(\"HTTP error \" + response.status);\n          }\n          return response.json();\n        })\n        .then(function(data) {\n          if (data.error) {\n            callback({ error: data.error });\n          } else {\n            self.expand({ url: data.long_url, depth: depth, seen: seen }, callback);\n          }\n        })\n        .catch(function(error) {\n          callback({ error: error.message });\n        });\n    },\n    \"generic\": function(args, callback) {\n      var url = args.url;\n      var depth = args.depth;\n      var seen = args.seen;\n      var self = this;\n\n      fetch(url, { method: 'HEAD', timeout: self.timeout })\n        .then(function(response) {\n          if (!response.ok) {\n            throw new Error(\"HTTP error \" + response.status);\n          }\n          var location = response.headers.get('Location');\n          if (location) {\n            self.expand({ url: location, depth: depth, seen: seen }, callback);\n          } else {\n            callback({ url: url, depth: depth, seen: seen });\n          }\n        })\n        .catch(function(error) {\n          callback({ error: error.message });\n        });\n    }\n  }\n}"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Create a function to set up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB as the session store. It integrates Next.js for server-side rendering and sets up a catch-all route handler. The server listens on a specified port and connects to MongoDB using environment variables for configuration.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that:\n- Listens on the specified port\n- Outputs the server URL to console when ready\n- Maintains persistent connections to MongoDB for session storage)",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  mongoose.connect(MONGO_URL);\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  const server = express();\n\n  const sessionOptions = {\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    store: mongoSessionStore.create({\n      mongoUrl: MONGO_URL,\n      ttl: 14 * 24 * 60 * 60,\n    }),\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n      httpOnly: true,\n      maxAge: 14 * 24 * 60 * 60 * 1000,\n      domain: 'localhost',\n    },\n  };\n\n  const sessionMiddleware = session(sessionOptions);\n  server.use(sessionMiddleware);\n\n  server.get('*', (req, res) => handle(req, res));\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on ${ROOT_URL}`);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = express();\nconst nextApp = next({ dev });\nconst handle = nextApp.getRequestHandler();\n\nconst port = process.env.PORT || 8000;\nconst sessionName = process.env.SESSION_NAME || 'nextjs-session';\nconst sessionSecret = process.env.SESSION_SECRET || 'super-secret-key';\nconst mongoUrlTest = process.env.MONGO_URL_TEST;\n\nconst store = new MongoDBStore({\n  uri: mongoUrlTest,\n  collection: 'sessions',\n});\n\nstore.on('error', (err) => {\n  console.error('Session store error:', err);\n});\n\napp.use(\n  session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: false,\n    store: store,\n    cookie: {\n      maxAge: 1000 * 60 * 60 * 24 * 7, // 1 week\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n    },\n  })\n);\n\nnextApp.prepare().then(() => {\n  app.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  app.listen(port, () => {\n    console.log(`> Server started on http://localhost:${port}`);\n  });\n});"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a function to set up an Express.js server with middleware configuration, route handling, and database synchronization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with CORS support, request body parsing, and database synchronization. It configures middleware, defines basic routes, and starts the server on a specified port. The server integrates authentication and user management routes from external modules.\n\nInput: None (The function takes no parameters as it's self-contained for server setup)\n\nOutput: None (The function doesn't return anything but starts a server process that listens on the specified port)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require(\"express\");\n    const bodyParser = require(\"body-parser\");\n    const cors = require(\"cors\");\n\n    const app = express();\n\n    var corsOptions = {\n        origin: \"http://localhost:8081\"\n    };\n\n    app.use(cors(corsOptions));\n    app.use(bodyParser.json());\n    app.use(bodyParser.urlencoded({ extended: true }));\n\n    const db = require(\"./app/models\");\n    const Role = db.role;\n\n    db.sequelize.sync();\n\n    app.get(\"/\", (req, res) => {\n        res.json({ message: \"Welcome to bezkoder application.\" });\n    });\n\n    require('./app/routes/auth.routes')(app);\n    require('./app/routes/user.routes')(app);\n\n    const PORT = process.env.PORT || 8080;\n    app.listen(PORT, () => {\n        console.log(`Server is running on port ${PORT}.`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst mongoose = require('mongoose');\nconst authRoutes = require('./routes/authRoutes');\nconst userRoutes = require('./routes/userRoutes');\n\nfunction setupExpressServer() {\n  const app = express();\n\n  app.use(cors());\n  app.use(bodyParser.json());\n  app.use('/api/auth', authRoutes);\n  app.use('/api/users', userRoutes);\n\n  mongoose.connect('mongodb://localhost:27017/myappdb', { useNewUrlParser: true, useUnifiedTopology: true })\n    .then(() => console.log('Database connected'))\n    .catch(err => console.error('Database connection error:', err));\n\n  const PORT = process.env.PORT || 5000;\n  app.listen(PORT, () => {\n    console.log(`Server is running on port ${PORT}`);\n  });\n}"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a function that sets up an Express server with middleware configuration, route handling, and server initialization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with essential middleware (CORS, static file serving, JSON body parsing), configures route handlers, and starts listening on a specified port. It handles both API routes and serves static HTML files.\n\nInput: None (The function uses imported modules and configuration from './src/config' and './src/routes')\n\nOutput: None (The function's side effect is starting an HTTP server that listens on the configured port)",
    "Canonical_solution": "function setupExpressServer() {\n    const bodyParser = require('body-parser');\n    const express = require('express');\n    const path = require('path');\n    const cors = require('cors');\n    const config = require('./src/config');\n    const routes = require('./src/routes');\n\n    const app = express();\n\n    app.enable('trust proxy');\n    app.use(cors());\n    app.use(express.static(path.join(__dirname, 'www')));\n    app.use(bodyParser.json());\n\n    app.get('/v2', (req, res) => res.sendFile(path.join(__dirname, 'www/index.html')));\n    app.use(routes);\n\n    app.listen(config.PORT, err => {\n        if (err) console.error(err);\n        console.log('Server started on ' + config.PORT);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst { PORT } = require('./src/config');\nconst routes = require('./src/routes');\n\nfunction setupExpressServer() {\n  const app = express();\n\n  app.use(cors());\n  app.use(express.json());\n  app.use(express.static(path.join(__dirname, 'public')));\n  app.use('/api', routes);\n\n  app.listen(PORT, () => {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  });\n}\n\nsetupExpressServer();"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a function that sets up a proxy server using Express and http-proxy-middleware to forward requests to a target API while modifying request and response headers.\n\nFunction Description: The function `createProxyServer` initializes an Express application that acts as a proxy server. It configures middleware to forward all incoming requests to a specified target API (https://api.openai.com in this case), removes certain headers from outgoing requests, and adds CORS headers to responses. The server listens on port 9000 by default.\n\nInput: None (The function takes no parameters as all configurations are hardcoded)\n\nOutput: None (The function doesn't return anything but starts a server process that continues running)",
    "Canonical_solution": "function createProxyServer() {\n    const express = require('express');\n    const { createProxyMiddleware } = require('http-proxy-middleware');\n    const app = express();\n    const port = 9000;\n\n    app.use('/', createProxyMiddleware({\n        target: 'https://api.openai.com',\n        changeOrigin: true,\n        onProxyReq: (proxyReq, req, res) => {\n            proxyReq.removeHeader('x-forwarded-for');\n            proxyReq.removeHeader('x-real-ip');\n        },\n        onProxyRes: function (proxyRes, req, res) {\n            proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n        }\n    }));\n\n    app.listen(port, () => {\n        console.log(`Example app listening at http://localhost:${port}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\n\nfunction createProxyServer() {\n  const app = express();\n\n  const proxy = createProxyMiddleware({\n    target: 'https://api.openai.com',\n    changeOrigin: true,\n    onProxyReq: (proxyReq, req, res) => {\n      proxyReq.removeHeader('X-Forwarded-For');\n      proxyReq.removeHeader('X-Real-IP');\n      proxyReq.removeHeader('Host');\n    },\n    onProxyRes: (proxyRes, req, res) => {\n      proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n      proxyRes.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS';\n      proxyRes.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';\n    }\n  });\n\n  app.use(proxy);\n\n  app.listen(9000, () => {\n    console.log('Proxy server is running on http://localhost:9000');\n  });\n}\n\ncreateProxyServer();"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Twitter Search Client class that handles searching tweets, managing search state, and storing results locally.\n\nClass Description: TSClient is a Twitter search client that performs searches, tracks search state (including pagination and since_id), caches results to local files, and provides synchronization capabilities.\n\nAttributes:\n- search: [Object] - Contains search parameters and state including query (q), since_id, result count (rcount), and a unique search id\n- id: [String] - MD5 hash of the search query used as a unique identifier\n- new_since_id: [String] - Tracks the newest tweet ID retrieved during the current sync\n\nMethods:\n- constructor(query, cb) -> [TSClient] - Initializes a new search client with the given query. Creates a unique ID for the search and loads previous state if available. Calls the callback with the initialized client.\n  - query: [String] - The search query string\n  - cb: [Function] - Callback function that receives the initialized TSClient instance\n\n- syncSearch(callback) -> [void] - Initiates a new synchronization of search results, walking through paginated results.\n  - callback: [Function] - Called with the array of results when sync completes\n\n- set(search) -> [void] - Updates the search state and persists it to disk.\n  - search: [Object] - The search state object to save\n\n- _walker(s) -> [void] - Internal recursive method that handles pagination through search results.\n  - s: [Object] - State object containing:\n    - ts: [TSClient] - Reference to the TSClient instance\n    - search: [Object] - Current search parameters\n    - cb: [Function] - Completion callback\n    - page: [Number] - Current page number\n    - results: [Array] - Accumulated results\n    - new_since_id: [String] - Newest tweet ID in current batch (optional)",
    "Canonical_solution": "var request = require('request');\nvar url = require('url');\n\nclass TSClient {\n    constructor(query, cb) {\n        this.search = {};\n        this.search.q = query;\n        this.search.since_id = 0;\n        this.search.rcount = 0;\n        var hash = crypto.createHash('md5');\n        hash.update(query);\n        this.search.id = hash.digest('hex');\n        var self = this;\n        lfs.readObjectFromFile(self.search.id+'.search', function(data) {\n            if(data && data.id) {\n                self.search = data;            \n            } else {\n                lfs.writeObjectToFile(self.search.id+'.search',self.search);\n            }\n            cb(self);\n        });\n    }\n\n    syncSearch(callback) {\n        console.log(\"new sync \"+JSON.stringify(this.search));\n        this._walker({ts:this, search:this.search, cb:callback, page:1, results:[]});\n    }\n\n    set(search) {\n        this.search = search;\n        lfs.writeObjectToFile(search.id+'.search',search);    \n    }\n\n    _walker(s) {\n        var uri = url.parse(\"http://search.twitter.com/search.json\");\n        uri.query = {q:s.search.q, rpp:100, page:s.page, since_id:s.search.since_id};\n        console.log(\"walking page \"+url.format(uri));\n        request.get({uri:url.format(uri)}, function(err, resp, body) {\n            if(err) {\n                console.log(\"request failed: \"+err);\n                s.cb([]);\n                return;\n            }\n            var data = JSON.parse(body);\n            if(data && data.results && data.results.length > 0) {\n                s.results = s.results.concat(data.results);\n                s.page++;\n                console.log(\"page \"+data.page+\" and max \"+data.max_id_str);\n                if(data.page == 1) s.new_since_id = data.max_id_str;\n            } else {\n                s.page=16;\n            }\n            if(s.page <= 15) {\n                this._walker(s);\n            } else {\n                console.log(\"saving \"+s.results.length+\" tweets\");\n                lfs.writeObjectsToFile(s.search.id+'.tweets',s.results);\n                s.search.rcount += s.results.length;\n                if(s.new_since_id) s.search.since_id = s.new_since_id;\n                s.ts.set(s.search);\n                s.cb(s.results);\n            }\n        }.bind(this));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class TSClient {\n  constructor(query, cb) {\n    this.search = {\n      q: query,\n      since_id: '',\n      rcount: 100,\n      search_id: ''\n    };\n    this.id = require('crypto').createHash('md5').update(query).digest('hex');\n    this.new_since_id = '';\n    this.loadState();\n    cb(this);\n  }\n\n  syncSearch(callback) {\n    const state = {\n      ts: this,\n      search: { ...this.search },\n      cb: callback,\n      page: 1,\n      results: [],\n      new_since_id: ''\n    };\n    this._walker(state);\n  }\n\n  set(search) {\n    this.search = { ...this.search, ...search };\n    this.saveState();\n  }\n\n  _walker(s) {\n    const params = {\n      q: s.search.q,\n      since_id: s.search.since_id,\n      count: s.search.rcount,\n      page: s.page\n    };\n\n    // Simulate Twitter API call\n    setTimeout(() => {\n      const results = [\n        { id_str: '12345', text: 'Sample tweet 1' },\n        { id_str: '67890', text: 'Sample tweet 2' }\n      ];\n\n      if (results.length > 0) {\n        s.results = s.results.concat(results);\n        s.new_since_id = results[results.length - 1].id_str;\n        s.page++;\n        this._walker(s);\n      } else {\n        s.cb(s.results);\n      }\n    }, 100);\n  }\n\n  loadState() {\n    try {\n      const fs = require('fs');\n      const data = fs.readFileSync(`./search_state_${this.id}.json`, 'utf-8');\n      const state = JSON.parse(data);\n      this.search = { ...this.search, ...state };\n      this.new_since_id = state.new_since_id || '';\n    } catch (e) {\n      // No existing state found\n    }\n  }\n\n  saveState() {\n    const fs = require('fs');\n    const state = {\n      q: this.search.q,\n      since_id: this.search.since_id,\n      rcount: this.search.rcount,\n      search_id: this.search.search_id,\n      new_since_id: this.new_since_id\n    };\n    fs.writeFileSync(`./search_state_${this.id}.json`, JSON.stringify(state), 'utf-8');\n  }\n}"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a function that sets up and starts an Express server with basic configuration, static file serving, and additional route handlers.\n\nFunction Description: The function `createExpressServer` initializes an Express application, configures it to serve static files from a parent directory, integrates additional route handlers from a separate module, and starts listening on a specified port (either from environment variables or defaulting to 3000).\n\nInput: None (The function takes no parameters but uses environment variables for configuration)\n\nOutput: Returns the HTTP server instance created by `app.listen()`, which is actively listening on the specified port. The function also logs server start information to the console.",
    "Canonical_solution": "function createExpressServer() {\n    const express = require('express');\n    const app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.static('../'));\n\n    require('./src-server/multerImpl')(app);\n\n    return app.listen(app.get('port'), () => {\n        console.log('Express server listening on port ' + app.get('port'));\n        console.log('Visit http://localhost:' + app.get('port') + '/example/ to check out the upload example');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst path = require('path');\nconst http = require('http');\nconst routes = require('./routes');\n\nfunction createExpressServer() {\n  const app = express();\n  const port = process.env.PORT || 3000;\n\n  app.use(express.static(path.join(__dirname, '..')));\n  app.use('/', routes);\n\n  const server = http.createServer(app);\n  server.listen(port, () => {\n    console.log(`Server is running on http://localhost:${port}`);\n  });\n\n  return server;\n}"
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to record incoming connections and handle file uploads, using Node.js's `fs` and `http` modules. The server should log connection details and save request data to files.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming connections. It handles requests by piping the socket data to a file stream and provides a simple HTML form for file uploads. Each connection is assigned a unique filename for logging purposes.\n\nInput: None (The function does not take any input parameters)\n\nOutput: None (The function does not return any value but creates a running HTTP server that logs to the console and writes to files)",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const uniqueFilename = `request_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.txt`;\n    const filePath = path.join(__dirname, uniqueFilename);\n    const fileStream = fs.createWriteStream(filePath);\n\n    console.log(`New connection: ${req.url} - ${req.method}`);\n    console.log('Headers:', req.headers);\n\n    req.on('data', (chunk) => {\n      fileStream.write(chunk);\n    });\n\n    req.on('end', () => {\n      fileStream.end();\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\"></form>');\n    });\n  });\n\n  server.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n  });\n}"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that makes an HTTP POST request to a specified URL with custom headers and data, then handles the response.\n\nFunction Description: The function `makeHttpRequest` sends an HTTP POST request to a given URL with specified headers and a data payload. It uses the `request` module to perform the HTTP request and includes a callback function to handle the response or errors. The function is designed to be reusable for making HTTP POST requests with minimal configuration.\n\nInput: \n- None (The URL, headers, and data are hardcoded within the function for simplicity. In a real-world scenario, these could be passed as parameters.)\n\nOutput: \n- None (The function logs the response body to the console if the request is successful. In a real-world scenario, the response could be returned or processed further.)\n\nNote: The function assumes the `request` module is available in the environment. If not, it must be installed via npm or another package manager.",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    };\n\n    var dataString = '18233982904';\n\n    var options = {\n        url: 'http://localhost:28139/CurlToNode',\n        method: 'POST',\n        headers: headers,\n        body: dataString\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "makeHttpRequest = () => {\n  const request = require('request');\n  const url = 'https://example.com/api';\n  const headers = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer token123'\n  };\n  const data = JSON.stringify({\n    key1: 'value1',\n    key2: 'value2'\n  });\n\n  request.post({\n    url: url,\n    headers: headers,\n    body: data\n  }, (error, response, body) => {\n    if (error) {\n      console.error('Error making HTTP request:', error);\n    } else {\n      console.log('Response received:', body);\n    }\n  });\n};"
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a JavaScript function that sets up an HTTP server to serve an HTML file using Node.js's built-in modules (http and fs). The function should handle incoming requests by piping the file content directly to the response.\n\nFunction Description: The function creates an HTTP server that listens for incoming requests. When a request is received, it reads an HTML file from the specified path and pipes its content to the response object, setting the appropriate content-type header.\n\nInput: \n- __dirname (string): The directory path where the HTML file is located.\n- '/index.html' (string): The path to the HTML file to be served, relative to __dirname.\n\nOutput: \n- An HTTP server instance that serves the specified HTML file for all incoming requests. The server does not explicitly return a value but starts listening on a default port (typically 80 or a specified port).",
    "Canonical_solution": "var server = require('http').createServer(function incoming(req, res) {\n  res.setHeader('Content-Type', 'text/html');\n  require('fs').createReadStream(__dirname + '/index.html').pipe(res);\n});",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer(__dirname, filePath) {\n  const server = http.createServer((req, res) => {\n    const fullPath = path.join(__dirname, filePath);\n    fs.readFile(fullPath, (err, data) => {\n      if (err) {\n        res.writeHead(500);\n        res.end('Internal Server Error');\n        return;\n      }\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(data);\n    });\n  });\n\n  server.listen(80, () => {\n    console.log('Server is running on port 80');\n  });\n}"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Retrieve and process TV channel information from multiple providers via HTTP requests, then extract and deduplicate channel details.\n\nFunction Description: The function makes HTTP POST requests to a TV guide service for each provider, extracts channel information from the HTML response, and returns a deduplicated list of channels. It uses axios for HTTP requests, cheerio for HTML parsing, and lodash for deduplication.\n\nInput: None (The function uses hardcoded providers array and automatically determines the current date)\n\nOutput: Array of objects containing unique TV channel information with the following structure:\n[\n    {\n        lang: string,       // Language code ('it' for Italian)\n        name: string,       // Channel name\n        site_id: string     // Unique identifier combining channel number and slug\n    },\n    ...\n]",
    "Canonical_solution": "function async channels() {\n    const axios = require('axios')\n    const _ = require('lodash')\n\n    const providers = ['-1', '-2', '-3']\n\n    const channels = []\n    for (let provider of providers) {\n        const data = await axios\n            .post('https://www.guida.tv/guide/schedule', null, {\n                params: {\n                    provider,\n                    region: 'Italy',\n                    TVperiod: 'Night',\n                    date: dayjs().format('YYYY-MM-DD'),\n                    st: 0,\n                    u_time: 1429,\n                    is_mobile: 1\n                }\n            })\n            .then(r => r.data)\n            .catch(console.log)\n\n        const $ = cheerio.load(data)\n        $('.channelname').each((i, el) => {\n            const name = $(el).find('center > a:eq(1)').text()\n            const url = $(el).find('center > a:eq(1)').attr('href')\n            const [, number, slug] = url.match(/\\/(\\d+)\\/(.*)\\.html$/)\n\n            channels.push({\n                lang: 'it',\n                name,\n                site_id: `${number}/${slug}`\n            })\n        })\n    }\n\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "axios.post('https://example.com/api/channels', { provider: 'provider1' }).then(response1 => {\n    const $1 = cheerio.load(response1.data);\n    const channels1 = [];\n    $1('.channel').each((i, el) => {\n        channels1.push({\n            lang: 'it',\n            name: $1(el).find('.name').text(),\n            site_id: `${$1(el).find('.number').text()}-${$1(el).find('.slug').text()}`\n        });\n    });\n\n    axios.post('https://example.com/api/channels', { provider: 'provider2' }).then(response2 => {\n        const $2 = cheerio.load(response2.data);\n        const channels2 = [];\n        $2('.channel').each((i, el) => {\n            channels2.push({\n                lang: 'it',\n                name: $2(el).find('.name').text(),\n                site_id: `${$2(el).find('.number').text()}-${$2(el).find('.slug').text()}`\n            });\n        });\n\n        const allChannels = [...channels1, ...channels2];\n        const uniqueChannels = _.uniqBy(allChannels, 'site_id');\n        console.log(uniqueChannels);\n    });\n});"
  },
  {
    "Task_id": 144,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to stream the contents of a file to the client using Node.js's `fs` and `http` modules. The server should handle file streaming efficiently using pipes and manage errors appropriately.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 5000. When a request is received, it reads a specified file (`big.txt`) as a stream and pipes the data directly to the response object. This approach is memory-efficient for large files. The function handles both successful file streaming and errors during the process.\n\nInput: None (The function does not take any input parameters; the file path is hardcoded as `./content/big.txt`.)\n\nOutput: None (The function does not return any value; it creates an HTTP server that runs indefinitely until stopped externally.)",
    "Canonical_solution": "function createServer() {\n    const http = require('http');\n    const fs = require('fs');\n\n    http.createServer(function (req, res) {\n        const fileStream = fs.createReadStream('./content/big.txt', 'utf8');\n        fileStream.on('open', () => {\n            fileStream.pipe(res);\n        });\n        fileStream.on('error', (err) => {\n            res.end(err);\n        });\n    }).listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = './content/big.txt';\n    const fileStream = fs.createReadStream(filePath);\n\n    fileStream.on('data', (chunk) => {\n      res.write(chunk);\n    });\n\n    fileStream.on('end', () => {\n      res.end();\n    });\n\n    fileStream.on('error', (err) => {\n      res.statusCode = 500;\n      res.end('Error reading file');\n    });\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n}\n\ncreateServer();\n```"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files and handle dynamic JavaScript file concatenation, with support for piping binary files.\n\nFunction Description: The `createServer` function initializes an HTTP server that serves static files from specified directories, handles dynamic concatenation of JavaScript files, and pipes binary files directly to the response. It supports virtual paths, content type detection, and redirection.\n\nInput: \n- Optional command line argument [string] - The port number to listen on (defaults to 90 if not provided)\n\nOutput: \n- None (directly creates and starts an HTTP server)\n- Console output indicating server startup and loaded files\n\nAttributes: (N/A - This is a function, not a class)\n\nMethods: (N/A - This is a function, not a class)\n\nAdditional Implementation Details:\n1. Reads and caches static files from '../src' and '../dist' directories at startup\n2. Handles binary files separately from text files\n3. Supports special handling for core JavaScript files and plugins\n4. Implements virtual path redirection\n5. Uses file extension to determine content type\n6. Provides fallback behavior for undefined routes\n7. Listens on localhost (127.0.0.1) only\n8. Outputs loaded file list to console at startup",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require(\"fs\");\n    var url = require(\"url\");\n\n    var BASE_URL=\"http://www.servicestack.net\", \n        VIRTUAL_PATH=\"/jqbuilder\"; \n\n    var getExt = function(path) {\n        return path.substring(path.lastIndexOf('.')+1);\n    };\n    String.prototype.startsWith = function (str){\n        return this.indexOf(str) === 0;\n    };\n\n    var contentTypes = { \"htm\": \"text/html\", \"js\": \"text/javascript\", \"gif\": \"image/gif\" };\n\n    var srcDir = '../src', targetDir = '../dist';\n    var webFiles = fs.readdirSync(targetDir);\n    var staticFiles = {}, binaryFiles = {};\n    fs.readdirSync(srcDir).forEach(function(file) { \n        var filePath = srcDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(targetDir).forEach(function(file) { \n        var filePath = targetDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(\"./\").forEach(function(file) {\n        var isText = (contentTypes[getExt(file)]||\"\").startsWith(\"text\");\n        if (isText)\n            staticFiles[\"/\" + file] = fs.readFileSync(file).toString('utf-8');\n        else \n            binaryFiles[\"/\" + file] = file;\n    });\n\n    staticFiles[\"/\"] = staticFiles[\"/default.htm\"];\n\n    console.log(\"loaded: \", Object.keys(staticFiles));\n\n    var isCore = { \"/jquip.js\": true, \"/jquip.min.js\": true };\n\n    var port = process.argv[2] || 90;\n\n    http.createServer(function (req, res) {\n        var reqUrl = url.parse(req.url), path = reqUrl.pathname.replace(VIRTUAL_PATH,'');\n        if (reqUrl.pathname == VIRTUAL_PATH){\n            res.writeHead(302,BASE_URL+VIRTUAL_PATH+\"/\");\n            res.end();\n            return;\n        }\n\n        var fileContents = staticFiles[path];\n\n        if (fileContents) {\n            var ext = path == \"/\" ? \"htm\" : getExt(path);\n            var contentType = contentTypes[ext];\n            res.writeHead(200, {'Content-Type': contentType });\n            var isPlugin = ext == \"js\" && path.startsWith(\"/jquip.\") && !isCore[path];\n            if (isPlugin) {\n                var coreJs = path.indexOf(\"min\") != -1 \n                    ? staticFiles[\"/jquip.min.js\"]\n                    : staticFiles[\"/jquip.js\"];\n                fileContents = coreJs + \";\" + fileContents;\n            }\n\n            res.end(fileContents);\n        }\n        else if (binaryFiles[path]) { \n            var filePath = binaryFiles[path]; \n            fs.createReadStream(filePath, {\n              'bufferSize': 4 * 1024\n            }).pipe(res);\n        }\n        else\n        {\n            var isDynamic = path.startsWith(\"/jquip.\");\n            if (isDynamic) {\n                var parts = path.substring(1).split('.');\n                var isMin = parts.indexOf(\"min\") >= 0;\n                var js = isMin ? staticFiles[\"/jquip.min.js\"] : staticFiles[\"/jquip.js\"];\t\t\t\n                parts.forEach(function(part){\n                    if (part == \"jquip\" || part == \"min\" || part == \"js\") return;\n                    var path = \"/jquip.\" + part + (isMin ? \".min.js\" : \".js\");\n                    var jsFile = staticFiles[path];\n                    if (jsFile)\n                        js += \";\" + jsFile;\n                });\n                res.writeHead(200, {'Content-Type': 'text/javascript' });\n                res.end(js);\t\t\n                return;\n            }\n\n            res.writeHead(200, {'Content-Type': 'text/plain'});\n            var sb = \"\";\n            for (var i in reqUrl) {\n                if (sb) sb += \"\\n\";\n                sb += i + \": \" + reqUrl[i];\n            }\n            res.end(\"Path not found:\\n\" + sb);\n        }\n    })\n    .listen(port, \"127.0.0.1\");\n    console.log('Server running at http://127.0.0.1:'+port+'/');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "function createServer() {\n    const http = require('http');\n    const fs = require('fs');\n    const path = require('path');\n    const url = require('url');\n    const mime = require('mime-types');\n\n    const port = process.argv[2] || 90;\n    const staticDirs = ['../src', '../dist'];\n    const files = {};\n\n    function loadFiles(dir) {\n        const filesInDir = fs.readdirSync(dir);\n        for (const file of filesInDir) {\n            const filePath = path.join(dir, file);\n            const stat = fs.statSync(filePath);\n            if (stat.isDirectory()) {\n                loadFiles(filePath);\n            } else {\n                const relativePath = path.relative(process.cwd(), filePath);\n                files[relativePath] = {\n                    path: filePath,\n                    content: fs.readFileSync(filePath),\n                    type: mime.lookup(file)\n                };\n                console.log(`Loaded: ${relativePath}`);\n            }\n        }\n    }\n\n    staticDirs.forEach(loadFiles);\n\n    const server = http.createServer((req, res) => {\n        const parsedUrl = url.parse(req.url, true);\n        let filePath = parsedUrl.pathname;\n\n        if (filePath === '/') {\n            filePath = '/index.html';\n        }\n\n        const file = files[filePath];\n        if (file) {\n            if (file.type.startsWith('text/')) {\n                res.writeHead(200, { 'Content-Type': file.type });\n                res.end(file.content);\n            } else if (file.type.startsWith('application/javascript')) {\n                res.writeHead(200, { 'Content-Type': file.type });\n                res.end(file.content);\n            } else {\n                res.writeHead(200, { 'Content-Type': file.type });\n                res.end(file.content);\n            }\n        } else {\n            res.writeHead(404, { 'Content-Type': 'text/plain' });\n            res.end('404 Not Found');\n        }\n    });\n\n    server.listen(port, '127.0.0.1', () => {\n        console.log(`Server running at http://127.0.0.1:${port}/`);\n    });\n}\n\ncreateServer();"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement an OAuth server class that handles GitHub OAuth authentication flow, including starting a server to receive the authorization code and exchanging it for an access token.\n\nClass Description: The OAuthServer class represents a server that facilitates GitHub OAuth authentication. It creates an Express server to handle the OAuth callback, exchanges the authorization code for an access token using GitHub's API, and provides methods to start and stop the server.\n\nAttributes:\n- options: [Object] - Configuration object containing client credentials and server settings\n- prompt: [Object] - Reference to an external prompt object used to signal completion of authentication\n- app: [Object] - Express application instance for handling HTTP requests\n- server: [Object] - HTTP server instance created by Express\n- token: [String|null] - Stores the obtained OAuth access token\n\nMethods:\n- constructor(options) -> [OAuthServer] - Initializes the OAuth server with configuration options and sets up the Express route for handling OAuth callbacks\n- start() -> [Promise] - Starts the HTTP server on the configured port and returns a promise that resolves when the server is ready or rejects on error\n- stop() -> [void] - Stops the HTTP server and cleans up resources",
    "Canonical_solution": "const express = require('express');\nconst axios = require('axios');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = this.options.prompt;\n    this.app = express();\n    this.app.get('/', (req, res) => {\n      const code = req.query.code;\n      axios\n        .post(\n          `https://github.com/login/oauth/access_token?client_secret=${\n            this.options.client_secret\n          }&client_id=${this.options.client_id}&code=${code}`,\n          {},\n          {\n            headers: {\n              Accept: 'application/json'\n            }\n          }\n        )\n        .then(response => {\n          const accessToken = response.data.access_token;\n          this.token = accessToken;\n          res.send('Enquirer: Github OAuth Server is up');\n          this.prompt.submit();\n        })\n        .catch(e => console.log('axios error', e));\n    });\n    this.token = null;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.options.port, err => {\n        if (err) {\n          return reject(err);\n        }\n        resolve();\n      });\n    });\n  }\n\n  stop() {\n    this.server.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst express = require('express');\nconst http = require('http');\nconst { promisify } = require('util');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = options.prompt;\n    this.app = express();\n    this.server = http.createServer(this.app);\n    this.token = null;\n\n    this.app.get('/callback', this.handleCallback.bind(this));\n  }\n\n  async start() {\n    return new Promise((resolve, reject) => {\n      this.server.listen(this.options.port, () => {\n        console.log(`OAuth server started on port ${this.options.port}`);\n        resolve();\n      }).on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  stop() {\n    this.server.close(() => {\n      console.log('OAuth server stopped');\n    });\n  }\n\n  async handleCallback(req, res) {\n    const code = req.query.code;\n    if (!code) {\n      return res.status(400).send('No authorization code provided');\n    }\n\n    try {\n      const tokenResponse = await this.exchangeCodeForToken(code);\n      this.token = tokenResponse.access_token;\n      this.prompt.signal();\n      res.send('Authentication successful! You can close this window.');\n    } catch (error) {\n      console.error('Error exchanging code for token:', error);\n      res.status(500).send('Authentication failed');\n    }\n  }\n\n  async exchangeCodeForToken(code) {\n    const response = await fetch('https://github.com/login/oauth/access_token', {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        client_id: this.options.clientId,\n        client_secret: this.options.clientSecret,\n        code: code\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to exchange code for token: ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    return data;\n  }\n}\n```"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files from a specified directory, handling different MIME types and responding with 404 errors for non-existent files.\n\nFunction Description: The function `createFileServer` initializes an HTTP server that serves static files (HTML, images, JavaScript, CSS) from a 'static' directory in the current working directory. It handles proper MIME types for different file extensions and responds with 404 errors when files are not found. The server listens on port 1338 by default.\n\nInput: None (The function takes no parameters; all configuration is internal)\n\nOutput: None (The function doesn't return anything; it creates and starts an HTTP server that continues running)",
    "Canonical_solution": "function createFileServer() {\n    var http = require('http'),\n        url = require('url'),\n        path = require('path'),\n        fs = require('fs'),\n        port = 1338;\n    var mimeTypes = {\n        \"html\": \"text/html\",\n        \"jpeg\": \"image/jpeg\",\n        \"jpg\": \"image/jpeg\",\n        \"png\": \"image/png\",\n        \"js\": \"text/javascript\",\n        \"css\": \"text/css\"};\n\n    http.createServer(function(req, res) {\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(process.cwd(),'static', uri);\n        fs.exists(filename, function(exists) {\n            if(!exists) {\n                console.error(\"not exists: \" + filename);\n                res.writeHead(404, {'Content-Type': 'text/plain'});\n                res.write('404 Not Found\\n');\n                res.end();\n                return;\n            }\n            var mimeType = mimeTypes[path.extname(filename).split(\".\")[1]];\n            res.writeHead(200, {'Content-Type':mimeType});\n\n            var fileStream = fs.createReadStream(filename);\n            fileStream.pipe(res);\n        });\n    }).listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createFileServer() {\n  const PORT = 1338;\n  const STATIC_DIR = path.join(__dirname, 'static');\n\n  const mimeTypes = {\n    '.html': 'text/html',\n    '.js': 'text/javascript',\n    '.css': 'text/css',\n    '.jpg': 'image/jpeg',\n    '.jpeg': 'image/jpeg',\n    '.png': 'image/png',\n    '.gif': 'image/gif',\n    '.svg': 'image/svg+xml',\n    '.json': 'application/json'\n  };\n\n  http.createServer((req, res) => {\n    const filePath = path.join(STATIC_DIR, req.url === '/' ? 'index.html' : req.url);\n    const ext = path.extname(filePath);\n\n    if (ext && mimeTypes[ext]) {\n      fs.readFile(filePath, (err, data) => {\n        if (err) {\n          res.writeHead(404, { 'Content-Type': 'text/plain' });\n          res.end('404 Not Found');\n          return;\n        }\n        res.writeHead(200, { 'Content-Type': mimeTypes[ext] });\n        res.end(data);\n      });\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n    }\n  }).listen(PORT, () => {\n    console.log(`Server running at http://localhost:${PORT}/`);\n  });\n}\n\ncreateFileServer();\n```"
  },
  {
    "Task_id": 155,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's 'net' module that can handle client connections, respond to incoming data, and manage server lifecycle events.\n\nClass Description: The Server class represents a TCP server that listens on a dynamically assigned port. It handles client connections, processes incoming data, and sends appropriate responses. The server can be started, stopped, and connections can be dropped.\n\nAttributes:\n- server: [Object] - The TCP server instance created using the 'net' module\n- socket: [Object] - The current client socket connection\n- response: [Buffer|Object] - The predefined response to send to clients (optional)\n\nMethods:\n- constructor(response) -> [Server] - Initializes a new Server instance with an optional response buffer/object\n- start(cb) -> [void] - Starts the server on a random available port and invokes the callback with connection details (host and port)\n- drop() -> [void] - Terminates the current client connection\n- close(cb) -> [void] - Stops the server and invokes the callback when complete",
    "Canonical_solution": "var net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = undefined;\n    this.socket = undefined;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server = net.createServer(\n      function(socket) {\n        this.socket = socket;\n        if (this.response) {\n          this.socket.on(\n            'data',\n            function(data) {\n              if (data.length == 8) {\n                this.socket.write(Buffer.from('N', 'utf8'));\n              } else if (!data[0]) {\n                this.socket.write(buffers.authenticationOk());\n              } else {\n                this.socket.write(this.response);\n              }\n            }.bind(this)\n          );\n        }\n      }.bind(this)\n    );\n\n    const host = 'localhost';\n    this.server.listen({ host, port: 0 }, () => {\n      const port = this.server.address().port;\n      cb({\n        host,\n        port,\n      });\n    });\n  }\n\n  drop() {\n    this.socket.destroy();\n  }\n\n  close(cb) {\n    this.server.close(cb);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "class Server {\n  constructor(response) {\n    this.server = require('net').createServer();\n    this.socket = null;\n    this.response = response;\n  }\n  start(cb) {\n    this.server.listen(0, '127.0.0.1', () => {\n      const { address, port } = this.server.address();\n      this.server.on('connection', (socket) => {\n        this.socket = socket;\n        socket.on('data', (data) => {\n          if (this.response) {\n            socket.write(this.response);\n          }\n        });\n        socket.on('close', () => {\n          this.socket = null;\n        });\n      });\n      cb({ host: address, port });\n    });\n  }\n  drop() {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n  close(cb) {\n    this.server.close(() => {\n      this.socket = null;\n      cb();\n    });\n  }\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a class that handles HTTP requests with authentication and custom headers for a specific API service. The class should support both GET and POST methods, generate required authentication signatures, and handle request errors appropriately.\n\nClass Description: The TaskRequest class is designed to make authenticated HTTP requests to a specific API endpoint. It handles request signing, header generation, and error management. The class maintains authentication-related attributes and provides a method to execute requests.\n\nAttributes:\n- did: [String] - Device identifier used for authentication\n- finger: [String] - Fingerprint information for the request\n- token: [String] - Authentication token for API access\n- oaid: [String] - OAID (Open Anonymous Identification) for tracking\n\nMethods:\n- constructor(did, finger, token, oaid) -> [None] - Initializes the TaskRequest instance with authentication parameters\n- taskRequest(method, url, body) -> [Promise<Object>] - Executes an HTTP request with the specified method to the given URL, optionally with a request body. Returns the response data or throws an error if the request fails. The method handles request signing and header generation internally.\n\nInput:\n- method: [String] - HTTP method to use ('get' or 'post')\n- url: [String] - Target URL for the request\n- body: [String] (optional) - Request body for POST requests (default: empty string)\n\nOutput:\n- [Promise<Object>] - Resolves with the response data if the request succeeds\n- [Error] - Throws an error if the request fails",
    "Canonical_solution": "const axios = require('axios');\n\nclass TaskRequest {\n    constructor(did, finger, token, oaid) {\n        this.did = did;\n        this.finger = finger;\n        this.token = token;\n        this.oaid = oaid;\n    }\n\n    async taskRequest(method, url, body = \"\") {\n        let re = function (e) {\n            function convertObjectToQueryString(obj) {\n                let queryString = \"\";\n                if (obj) {\n                    const keys = Object.keys(obj).sort();\n                    keys.forEach(key => {\n                        const value = obj[key];\n                        if (value !== null && typeof value !== 'object') {\n                            queryString += `&${key}=${value}`;\n                        }\n                    });\n                }\n                return queryString.slice(1);\n            }\n            return convertObjectToQueryString(e)\n        }\n        \n        function v(e) {\n            const crypto = require(\"crypto\")\n            return crypto.createHash(\"md5\").update(e).digest(\"hex\")\n        }\n        \n        const g = {\n            traceid: v((new Date).getTime().toString() + Math.random().toString()),\n            noncestr: Math.random().toString().slice(2, 10),\n            timestamp: Date.now(),\n            platform: \"h5\",\n            did: this.did,\n            version: \"1.0.0\",\n            finger: this.finger,\n            token: this.token,\n            oaid: this.oaid,\n        }\n        \n        const c = \"\\u7c89\\u8c61\\u597d\\u725b\\u903ca8c19d8267527ea4c7d2f011acf7766f\"\n        let s = method === \"get\" ? void 0 : JSON.parse(body)\n        let e = void 0 === s ? {} : s\n        g.sign = v(re(e) + re(g) + c)\n        \n        let headers = {\n            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; MI 8 Lite Build/QKQ1.190910.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/80.0.3987.99 Mobile Safari/537.36 AgentWeb/5.0.0  UCBrowser/11.6.4.950',\n            'Accept': 'application/json, text/plain, */*',\n            'Accept-Encoding': 'gzip, deflate',\n            'Content-Type': 'application/json',\n            'origin': 'https://m.fenxianglife.com',\n            'sec-fetch-dest': 'empty',\n            'x-requested-with': 'com.n_add.android',\n            'sec-fetch-site': 'same-site',\n            'sec-fetch-mode': 'cors',\n            'referer': 'https://m.fenxianglife.com/h5-lottery/index.html?hideBack=1&sourceType=lottery_tab&token=030e7e9158af06dea2b3d0175a471ada&AppToken=96e06ae9f3cab6784de443015b8d9ad8&uid=515226607&v=5.4.3&did=njia992631e6-b9b2-4383-b67c-86b5d0fe818a&level=1&platform=android&timestamp=1717426249&channel=xiaomi&traFromId=23192687628924991393323633117947',\n            'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\n            \"Content-Type\": \"application/json\"\n        }\n        \n        Object.assign(headers, g)\n        \n        const reqeuestOptions = {\n            url: url,\n            method: method,\n            headers: headers,\n            data: body\n        }\n        \n        try {\n            const response = await axios(reqeuestOptions);\n            return response.data;\n        } catch (error) {\n            console.log('axios error', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class TaskRequest {\n  constructor(did, finger, token, oaid) {\n    this.did = did;\n    this.finger = finger;\n    this.token = token;\n    this.oaid = oaid;\n  }\n\n  async taskRequest(method, url, body = '') {\n    const headers = {\n      'X-Device-ID': this.did,\n      'X-Fingerprint': this.finger,\n      'X-Token': this.token,\n      'X-OAID': this.oaid,\n      'Content-Type': 'application/json'\n    };\n\n    const options = {\n      method: method.toUpperCase(),\n      headers: headers,\n      body: body\n    };\n\n    try {\n      const response = await fetch(url, options);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      throw new Error(`Request failed: ${error.message}`);\n    }\n  }\n}"
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a TCP server in Node.js that handles client connections, processes incoming data in batches, and forwards each batch to an external service for processing.\n\nFunction Description: The function `createTCPServer` initializes a TCP server that listens on port 5000. When a client connects, it sets up a bidirectional communication channel where incoming data from the client is collected in batches (separated by '.'). Each complete batch is then sent to an external 'uppercase' service via a REQ socket. The server handles data streaming and batch processing efficiently.\n\nInput: None (The function takes no parameters; configuration is hardcoded)\n\nOutput: None (The function creates a server instance that runs indefinitely, listening for connections)\n\n---\n\nIf you'd prefer the class format (though the reference code is function-based):\n\nTask Description: Implement a TCP server class in Node.js that manages client connections and batch processing of incoming data.\n\nClass Description: The `TCPServer` class encapsulates a TCP server that listens for client connections, collects incoming data in batches, and forwards complete batches to an external service.\n\nAttributes:\n- server: [net.Server] - The underlying TCP server instance\n- port: [number] - The port number the server listens on (default: 5000)\n\nMethods:\n- constructor([port: number]) -> void - Initializes the server with optional port configuration\n- start() -> void - Starts the server and begins listening for connections\n- handleConnection(conn: net.Socket) -> void - Internal method to manage client connections and data processing\n- processBatch(batch: string[]) -> void - Sends a complete batch to the external service",
    "Canonical_solution": "function createTCPServer() {\n    var server = require('net').createServer();\n    server.on('connection', function(conn) {\n        conn.setEncoding('utf8');\n        \n        var req = context.socket('REQ');\n        req.setEncoding('utf8');\n        req.pipe(conn);\n        req.connect('uppercase');\n        \n        var batch = [];\n        var ask = function (q) {\n            req.write(q, 'utf8');\n        }\n        function readBatch() {\n            var msg; while (msg = conn.read()) {\n                msg.split('\\n').forEach(function(item) {\n                    if (item == '.') {\n                        console.log('Sending batch %s', batch);\n                        batch.forEach(ask);\n                        batch = [];\n                    }\n                    else if (item != '') {\n                        batch.push(item);\n                    }\n                });\n            }\n        }\n        conn.on('readable', readBatch);\n        readBatch();\n    });\n    server.listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "wrong_result": "const net = require('net');\nconst zmq = require('zmq');\n\nclass TCPServer {\n  constructor(port = 5000) {\n    this.port = port;\n    this.server = net.createServer();\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`TCP server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', (conn) => {\n      this.handleConnection(conn);\n    });\n  }\n\n  handleConnection(conn) {\n    let buffer = '';\n\n    conn.on('data', (data) => {\n      buffer += data.toString();\n\n      const batches = buffer.split('.');\n      buffer = batches.pop();\n\n      batches.forEach((batch) => {\n        if (batch.trim() !== '') {\n          this.processBatch(batch.trim().split(','));\n        }\n      });\n    });\n\n    conn.on('end', () => {\n      if (buffer.trim() !== '') {\n        this.processBatch(buffer.trim().split(','));\n      }\n    });\n\n    conn.on('error', (err) => {\n      console.error('Connection error:', err);\n    });\n  }\n\n  processBatch(batch) {\n    const socket = zmq.socket('req');\n    socket.connect('tcp://localhost:5001');\n\n    socket.on('message', (response) => {\n      console.log('Received response from service:', response.toString());\n      socket.close();\n    });\n\n    socket.send(JSON.stringify(batch));\n  }\n}\n\nmodule.exports = TCPServer;"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a POP3 server class in Node.js that handles secure and non-secure connections, manages client connections, and provides event-driven communication.\n\nClass Description: The POP3Server class extends EventEmitter to create a TCP server that can handle both regular and TLS-secured POP3 connections. It manages client connections and emits events for server lifecycle and errors.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- connections: [Set] - Tracks active client connections\n- server: [net.Server|tls.Server] - The underlying TCP/TLS server instance\n\nMethods:\n- constructor(options) -> [void] - Initializes the server with optional configuration\n- _setListeners() -> [void] - Sets up event listeners for the server\n- _onListening() -> [void] - Handles the 'listening' event\n- _onClose() -> [void] - Handles the 'close' event\n- _onError(err) -> [void] - Handles the 'error' event\n- connect(socket, socketOptions) -> [void] - Creates and manages a new client connection\n- listen(...args) -> [void] - Starts the server listening on specified port\n- close(callback) -> [void] - Stops the server and invokes callback when closed",
    "Canonical_solution": "const EventEmitter = require('events');\nconst net = require('net');\nconst tls = require('tls');\n\nclass POP3Server extends EventEmitter {\n    constructor(options) {\n        super();\n\n        this.options = options || {};\n        this.connections = new Set();\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    this.connect(socket, socketOptions);\n                });\n            });\n        }\n\n        this._setListeners();\n    }\n\n    _setListeners() {\n        this.server.on('listening', () => this._onListening());\n        this.server.on('close', () => this._onClose());\n        this.server.on('error', err => this._onError(err));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new POP3Connection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.once('error', err => {\n            this.connections.delete(connection);\n            this._onError(err);\n        });\n        connection.once('close', () => {\n            this.connections.delete(connection);\n        });\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            if (typeof callback === 'function') {\n                return callback();\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "class POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options || {};\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', () => this._onListening());\n    this.server.on('close', () => this._onClose());\n    this.server.on('error', (err) => this._onError(err));\n    this.server.on('connection', (socket) => this.connect(socket, {}));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    const connection = new POP3Connection(socket, socketOptions);\n    this.connections.add(connection);\n    connection.on('end', () => this.connections.delete(connection));\n    connection.on('error', (err) => this.emit('error', err));\n    this.emit('connection', connection);\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = require('tls').createServer(this.options, (socket) => this.connect(socket, { secure: true }));\n    } else {\n      this.server = require('net').createServer((socket) => this.connect(socket, { secure: false }));\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    if (this.server) {\n      this.server.close(() => {\n        this.connections.forEach((conn) => conn.destroy());\n        this.connections.clear();\n        this.emit('close');\n        if (callback) callback();\n      });\n    } else if (callback) {\n      callback();\n    }\n  }\n}"
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Implement a TCP server class in JavaScript using Node.js's 'net' module to handle client connections, manage sockets, and provide event-driven communication.\n\nClass Description: The Socket class represents a TCP server that can bind to a specific port/host, manage client connections, handle socket errors, and emit events for various connection states. It extends EventEmitter for event handling capabilities.\n\nAttributes:\n- server: [net.Server] - The underlying TCP server instance\n- socks: [Array] - Array of connected client sockets\n- settings: [Object] - Configuration settings for the server\n- type: [String] - Indicates whether the instance is acting as a server or client\n\nMethods:\n- constructor() -> [void] - Initializes the socket instance with default settings\n- bind(port, host, fn) -> [Socket] - Binds the server to a specified port and host (supports both TCP and Unix sockets)\n- onconnect(sock) -> [void] - Handles new client connections\n- addSocket(sock) -> [void] - Adds a new socket to the connection pool and sets up message parsing\n- removeSocket(sock) -> [void] - Removes a socket from the connection pool\n- handleErrors(sock) -> [void] - Sets up error handling for a socket\n- closeServer(fn) -> [void] - Closes the server and all client connections",
    "Canonical_solution": "var Emitter = require('events').EventEmitter;\nvar net = require('net');\nvar debug = require('debug')('axon:sock');\n\nclass Socket {\n  constructor() {\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.set('hwm', Infinity);\n    this.set('identity', String(process.pid));\n    this.set('retry timeout', 100);\n    this.set('retry max timeout', 5000);\n  }\n\n  bind(port, host, fn) {\n    var self = this;\n    if ('client' == this.type) throw new Error('cannot bind() after connect()');\n    if ('function' == typeof host) {\n      fn = host;\n      host = undefined;\n    }\n\n    var unixSocket = false;\n\n    if ('string' == typeof port) {\n      port = url.parse(port);\n\n      if ('unix:' == port.protocol) {\n        host = fn;\n        fn = undefined;\n        port = port.pathname;\n        unixSocket = true;\n      } else {\n        host = port.hostname || '0.0.0.0';\n        port = parseInt(port.port, 10);\n      }\n    } else {\n      host = host || '0.0.0.0';\n    }\n\n    this.type = 'server';\n\n    this.server = net.createServer(this.onconnect.bind(this));\n\n    debug('%s bind %s:%s', this.type, host, port);\n    this.server.on('listening', this.emit.bind(this, 'bind'));\n\n    if (unixSocket) {\n      this.server.on('error', function(e) {\n        if (e.code == 'EADDRINUSE') {\n          var clientSocket = new net.Socket();\n\n          clientSocket.on('error', function(e2) {\n            if (e2.code == 'ECONNREFUSED') {\n              fs.unlink(port);\n              self.server.listen(port, host, fn);\n            }\n          });\n\n          clientSocket.connect({path: port}, function() {\n            throw e;\n          });\n        }\n      });\n    }\n\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    var self = this;\n    var addr = sock.remoteAddress + ':' + sock.remotePort;\n    debug('%s accept %s', self.type, addr);\n    this.addSocket(sock);\n    this.handleErrors(sock);\n    this.emit('connect', sock);\n    sock.on('close', function() {\n      debug('%s disconnect %s', self.type, addr);\n      self.emit('disconnect', sock);\n      self.removeSocket(sock);\n    });\n  }\n\n  addSocket(sock) {\n    var parser = new Parser;\n    var i = this.socks.push(sock) - 1;\n    debug('%s add socket %d', this.type, i);\n    sock.pipe(parser);\n    parser.on('data', this.onmessage(sock));\n  }\n\n  removeSocket(sock) {\n    var i = this.socks.indexOf(sock);\n    if (!~i) return;\n    debug('%s remove socket %d', this.type, i);\n    this.socks.splice(i, 1);\n  }\n\n  handleErrors(sock) {\n    var self = this;\n    sock.on('error', function(err) {\n      debug('%s error %s', self.type, err.code || err.message);\n      self.emit('socket error', err);\n      self.removeSocket(sock);\n      if (!~ignore.indexOf(err.code)) return self.emit('error', err);\n      debug('%s ignored %s', self.type, err.code);\n      self.emit('ignored error', err);\n    });\n  }\n\n  closeServer(fn) {\n    debug('%s closing server', this.type);\n    this.server.on('close', this.emit.bind(this, 'close'));\n    this.server.close();\n    fn && fn();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "class Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {\n      host: 'localhost',\n      port: 3000,\n      type: 'server'\n    };\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    this.settings.port = port;\n    this.settings.host = host;\n    this.server = net.createServer((sock) => {\n      this.onconnect(sock);\n      if (fn) fn(sock);\n    });\n    this.server.listen(this.settings.port, this.settings.host, () => {\n      this.emit('bind', this.settings);\n    });\n    return this;\n  }\n\n  onconnect(sock) {\n    this.addSocket(sock);\n    this.emit('connect', sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    sock.on('data', (data) => {\n      this.emit('message', data, sock);\n    });\n    sock.on('close', () => {\n      this.removeSocket(sock);\n      this.emit('close', sock);\n    });\n    this.handleErrors(sock);\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index > -1) {\n      this.socks.splice(index, 1);\n    }\n  }\n\n  handleErrors(sock) {\n    sock.on('error', (err) => {\n      this.emit('error', err, sock);\n      this.removeSocket(sock);\n    });\n  }\n\n  closeServer(fn) {\n    this.socks.forEach((sock) => {\n      sock.destroy();\n    });\n    this.server.close(() => {\n      this.emit('close', this.server);\n      if (fn) fn();\n    });\n  }\n}"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a class that provides wallpaper retrieval functionality from different APIs (Unsplash or Bing) based on client availability.\n\nClass Description: The WallpaperService class is designed to fetch random wallpapers from either Unsplash (if an API key is provided) or Bing's wallpaper API (as a fallback). It handles API requests, processes responses, and provides a consistent output format regardless of the source.\n\nAttributes: None (This is a static service class with no instance attributes)\n\nMethods:\ngetWallpaper: static async getWallpaper(unsplashClientId: string) -> Promise<Object> - Fetches a random wallpaper from either Unsplash or Bing. \n  - Input: \n    - unsplashClientId: string - The API client ID for Unsplash (optional, if not provided will use Bing)\n  - Output: \n    - Returns a Promise that resolves to an object with:\n      - type: string - Indicates the source ('unsplash' or 'bing')\n      - data: Array/Object - Contains the wallpaper data in the respective API's format\n    - On error, returns a fallback Bing wallpaper object with a default image",
    "Canonical_solution": "const axios = require('axios');\n\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    const wallpaperAPI = unsplashClientId\n      ? 'https://api.unsplash.com/photos/random?orientation=landscape&count=1&client_id=' + unsplashClientId\n      : 'https://cn.bing.com/HPImageArchive.aspx?format=js&n=1';\n\n    try {\n      const res = await axios.get(wallpaperAPI);\n      return unsplashClientId\n        ? { type: 'unsplash', data: res.data }\n        : { type: 'bing', data: res.data.images };\n    } catch (error) {\n      return {\n        type: 'bing',\n        data: [{\n          url: '/az/hprichbg/rb/SWFC_ZH-CN9558503653_1920x1080.jpg',\n          copyrightlink: '/search?q=%e4%b8%8a%e6%b5%b7%e4%b8%96%e7%95%8c%e9%87%91%e8%9e%8d%e4%b8%ad%e5%bf%83&form=hpcapt&mkt=zh-cn'\n        }]\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    try {\n      if (unsplashClientId) {\n        const response = await fetch(`https://api.unsplash.com/photos/random?client_id=${unsplashClientId}`);\n        if (!response.ok) throw new Error('Unsplash API request failed');\n        const data = await response.json();\n        return { type: 'unsplash', data };\n      }\n    } catch (error) {\n      console.error('Failed to fetch from Unsplash, falling back to Bing:', error);\n    }\n\n    try {\n      const response = await fetch('https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1');\n      if (!response.ok) throw new Error('Bing API request failed');\n      const data = await response.json();\n      const imageUrl = `https://www.bing.com${data.images[0].url}`;\n      return { type: 'bing', data: { url: imageUrl } };\n    } catch (error) {\n      console.error('Failed to fetch from Bing, returning fallback image:', error);\n      return { type: 'bing', data: { url: 'https://via.placeholder.com/1920x1080.png?text=No+Wallpaper+Available' } };\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Create a TCP server implementation for handling IMAP (Internet Message Access Protocol) connections with optional TLS/SSL security support.\n\nClass Description: IMAPServer is a class that implements a TCP server for IMAP protocol connections. It supports both plain and TLS/SSL encrypted connections, handles client connections, and manages server lifecycle events.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- server: [net.Server] - The underlying TCP server instance\n- connections: [Set] - Active client connections\n- _closeTimeout: [Timeout] - Timer for server shutdown operations\n\nMethods:\n- constructor(options) -> [IMAPServer] - Initializes the server with configuration options and sets up event listeners\n- connect(socket, socketOptions) -> [void] - Creates a new IMAPConnection for a client socket\n- listen(...args) -> [void] - Starts the server listening on specified port/address\n- close(callback) -> [void] - Gracefully shuts down the server\n- _setListeners() -> [void] - Sets up server event listeners\n- _onListening() -> [void] - Handles server 'listening' event\n- _onClose() -> [void] - Handles server 'close' event\n- _onError(err) -> [void] - Handles server 'error' event\n- _handleProxy(socket, callback) -> [void] - Handles proxy protocol if needed\n- _upgrade(socket, callback) -> [void] - Upgrades a connection to TLS/SSL",
    "Canonical_solution": "const net = require('net');\nconst tls = require('tls');\n\nclass IMAPServer {\n    constructor(options) {\n        this.options = options || {};\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                socket.setKeepAlive(true, 5 * 1000);\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket =>\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    socket.setKeepAlive(true, 5 * 1000);\n                    this.connect(socket, socketOptions);\n                })\n            );\n        }\n\n        this._setListeners();\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new IMAPConnection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.on('error', this._onError.bind(this));\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            clearTimeout(this._closeTimeout);\n            callback();\n        });\n    }\n\n    _setListeners() {\n        this.server.on('listening', this._onListening.bind(this));\n        this.server.on('close', this._onClose.bind(this));\n        this.server.on('error', this._onError.bind(this));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    _handleProxy(socket, callback) {\n        let socketOptions = {\n            id: base32.encode(crypto.randomBytes(10)).toLowerCase()\n        };\n        return setImmediate(() => callback(null, socketOptions));\n    }\n\n    _upgrade(socket, callback) {\n        let socketOptions = {\n            secureContext: this.secureContext.get('*'),\n            isServer: true,\n            server: this.server\n        };\n\n        let tlsSocket = new tls.TLSSocket(socket, socketOptions);\n        tlsSocket.on('secure', () => {\n            return callback(null, tlsSocket);\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "class IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = require('net').createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n    this._setListeners();\n  }\n\n  connect(socket, socketOptions) {\n    const IMAPConnection = require('./IMAPConnection');\n    const connection = new IMAPConnection(socket, socketOptions);\n    this.connections.add(connection);\n    connection.on('close', () => this.connections.delete(connection));\n  }\n\n  listen(...args) {\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    if (this._closeTimeout) clearTimeout(this._closeTimeout);\n    this._closeTimeout = setTimeout(() => {\n      this.server.close(callback);\n    }, 1000);\n  }\n\n  _setListeners() {\n    this.server.on('connection', (socket) => {\n      this._handleProxy(socket, () => {\n        if (this.options.tls) {\n          this._upgrade(socket, () => {\n            this.connect(socket, { tls: true });\n          });\n        } else {\n          this.connect(socket, { tls: false });\n        }\n      });\n    });\n\n    this.server.on('listening', () => this._onListening());\n    this.server.on('close', () => this._onClose());\n    this.server.on('error', (err) => this._onError(err));\n  }\n\n  _onListening() {\n    // Handle server 'listening' event\n  }\n\n  _onClose() {\n    // Handle server 'close' event\n  }\n\n  _onError(err) {\n    // Handle server 'error' event\n  }\n\n  _handleProxy(socket, callback) {\n    // Handle proxy protocol if needed\n    callback();\n  }\n\n  _upgrade(socket, callback) {\n    const tls = require('tls');\n    const secureContext = tls.createSecureContext(this.options.tls);\n    const secureSocket = tls.createServer(secureContext, () => {}).authorize(socket);\n    secureSocket.on('secure', () => {\n      callback();\n    });\n  }\n}"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a Flash Policy Server class in JavaScript using Node.js's net module to handle cross-domain policy requests for socket connections.\n\nClass Description: The FlashPolicyServer class creates a TCP server that responds to Flash socket policy requests. It manages allowed origins/ports, compiles the XML policy file, and handles server lifecycle events.\n\nAttributes:\n- origins: [Array] - List of allowed domain:port combinations\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [Object] - TCP server instance\n- buffer: [Buffer] - Compiled policy file in binary format\n- server: [Object] - Optional existing server instance to attach to\n\nMethods:\n- constructor(options, origins) -> [FlashPolicyServer] - Initializes the server with options and allowed origins\n- listen(port, server, cb) -> [FlashPolicyServer] - Starts listening on specified port, optionally attaching to existing server\n- responder(socket) -> [void] - Responds to policy requests on a socket connection\n- compile() -> [FlashPolicyServer] - Generates the XML policy buffer from allowed origins\n- add() -> [FlashPolicyServer] - Adds new allowed origins to the policy\n- remove(origin) -> [FlashPolicyServer] - Removes an origin from the allowed list\n- close() -> [FlashPolicyServer] - Stops the server and cleans up listeners",
    "Canonical_solution": "var net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => this.responder(socket));\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges.'\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (data && data[0] === 60 && data.toString() === '<policy-file-request/>\\0' &&\n              socket && (socket.readyState === 'open' || socket.readyState === 'writeOnly')) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    this.port >= 0 && this.socket.listen(this.port, () => {\n      this.socket.online = true;\n      if (callback) {\n        callback.call(this);\n        callback = undefined;\n      }\n    });\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = new Buffer(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options && options.port ? options.port : 843;\n    this.log = options && options.log ? options.log : console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options && options.server ? options.server : null;\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    if (server) {\n      this.server = server;\n    } else {\n      this.socket = net.createServer(this.responder.bind(this));\n    }\n    if (port) {\n      this.port = port;\n    }\n    if (this.server) {\n      this.server.on('connection', this.responder.bind(this));\n    } else {\n      this.socket.listen(this.port, () => {\n        this.log(`Flash Policy Server listening on port ${this.port}`);\n        if (cb) cb();\n      });\n    }\n    return this;\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      const request = data.toString();\n      if (request === '<policy-file-request/>\\0') {\n        socket.write(this.buffer);\n      }\n    });\n    socket.on('close', () => {\n      this.log('Client disconnected');\n    });\n    socket.on('error', (err) => {\n      this.log(`Socket error: ${err.message}`);\n    });\n  }\n\n  compile() {\n    let xml = '<cross-domain-policy>';\n    this.origins.forEach(origin => {\n      xml += `<allow-access-from domain=\"${origin}\" secure=\"false\"/>\\n`;\n    });\n    xml += '</cross-domain-policy>';\n    this.buffer = Buffer.from(xml, 'utf-8');\n    return this;\n  }\n\n  add(origin) {\n    if (!this.origins.includes(origin)) {\n      this.origins.push(origin);\n      this.compile();\n    }\n    return this;\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index !== -1) {\n      this.origins.splice(index, 1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    if (this.server) {\n      this.server.removeAllListeners('connection');\n      this.server = null;\n    }\n    this.log('Flash Policy Server closed');\n    return this;\n  }\n}\n```"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a reusable HTTP client class that simplifies making HTTP requests using Axios, with support for common methods like GET and POST, while handling errors consistently.\n\nClass Description: The HTTPClient class encapsulates Axios functionality to provide a clean interface for making HTTP requests. It maintains headers across requests and provides methods for GET and POST operations with error handling.\n\nAttributes:\n- headers: Object - Contains HTTP headers to be sent with every request\n\nMethods:\n- constructor(headers: Object) -> void - Initializes the HTTP client with default headers\n- get(url: String, params: Object = {}) -> Promise<Object> - Sends a GET request to the specified URL with optional query parameters, returns response data or throws error\n- post(url: String, data: Object = {}, params: Object = {}) -> Promise<Object> - Sends a POST request to the specified URL with optional request body and query parameters, returns response data or throws error",
    "Canonical_solution": "const axios = require('axios');\n\nclass HTTPClient {\n    constructor(headers) {\n        this.headers = headers;\n    }\n\n    async get(url, params = {}) {\n        try {\n            const response = await axios({\n                method: 'get',\n                url: url,\n                headers: this.headers,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('GET request failed:', error);\n            throw error;\n        }\n    }\n\n    async post(url, data = {}, params = {}) {\n        try {\n            const response = await axios({\n                method: 'post',\n                url: url,\n                headers: this.headers,\n                data: data,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('POST request failed:', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class HTTPClient {\n  constructor(headers) {\n    this.headers = headers;\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await axios.get(url, {\n        headers: this.headers,\n        params\n      });\n      return response.data;\n    } catch (error) {\n      throw new Error(`GET request to ${url} failed: ${error.message}`);\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await axios.post(url, data, {\n        headers: this.headers,\n        params\n      });\n      return response.data;\n    } catch (error) {\n      throw new Error(`POST request to ${url} failed: ${error.message}`);\n    }\n  }\n}"
  },
  {
    "Task_id": 191,
    "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome DevTools Protocol, handling connection, message exchange, and disconnection events.\n\nClass Description: The Chrome class is an EventEmitter that establishes and manages a WebSocket connection to Chrome's DevTools Protocol. It handles message parsing, error handling, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The WebSocket instance\n- _notifier: [EventEmitter] - External event notifier\n- _callbacks: [Object] - Stores pending command callbacks\n- _nextCommandId: [Number] - Tracks the next command ID\n\nMethods:\n- constructor(options, notifier) -> [void] - Initializes the Chrome instance with connection options and notifier\n- _start() -> [Promise] - Internal method to initiate WebSocket connection\n- _connectToWebSocket() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleConnectionClose() -> [void] - Cleans up when connection closes\n- _handleMessage(message) -> [void] - Processes incoming WebSocket messages\n- send(method, params, sessionId, callback) -> [Promise|void] - Sends a command to Chrome DevTools Protocol\n- _enqueueCommand(method, params, sessionId, callback) -> [void] - Internal method to queue commands\n- close(callback) -> [Promise|void] - Closes the WebSocket connection cleanly",
    "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this.webSocketUrl = undefined;\n        this._ws = null;\n        this._notifier = notifier;\n        this._start();\n    }\n\n    async _start() {\n        try {\n            await this._connectToWebSocket();\n            process.nextTick(() => {\n                this._notifier.emit('connect', this);\n            });\n        } catch (err) {\n            this._notifier.emit('error', err);\n        }\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleConnectionClose() {\n        this._callbacks = {};\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n\n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    close(callback) {\n        const closeWebSocket = (callback) => {\n            if (this._ws.readyState === 3) {\n                callback();\n            } else {\n                this._ws.removeAllListeners('close');\n                this._ws.once('close', () => {\n                    this._ws.removeAllListeners();\n                    this._handleConnectionClose();\n                    callback();\n                });\n                this._ws.close();\n            }\n        };\n        if (typeof callback === 'function') {\n            closeWebSocket(callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                closeWebSocket(fulfill);\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = `${this.secure ? 'wss' : 'ws'}://${this.host}:${this.port}`;\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 1;\n  }\n\n  _start() {\n    return this._connectToWebSocket();\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('open');\n        resolve();\n      };\n      this._ws.onmessage = (event) => {\n        this._handleMessage(event.data);\n      };\n      this._ws.onclose = () => {\n        this._handleConnectionClose();\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n    });\n  }\n\n  _handleConnectionClose() {\n    this.emit('close');\n    this._ws = null;\n    this._callbacks = {};\n    this._nextCommandId = 1;\n  }\n\n  _handleMessage(message) {\n    try {\n      const data = JSON.parse(message);\n      if (data.method === 'Target.attachedToTarget') {\n        this._notifier.emit('targetAttached', data.params);\n      } else if (data.method === 'Target.detachedFromTarget') {\n        this._notifier.emit('targetDetached', data.params);\n      } else if (data.method === 'Runtime.consoleAPICalled') {\n        this._notifier.emit('consoleMessage', data.params);\n      } else if (data.id && this._callbacks[data.id]) {\n        const callback = this._callbacks[data.id];\n        delete this._callbacks[data.id];\n        callback(null, data.result);\n      }\n    } catch (err) {\n      this.emit('error', err);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    const id = this._nextCommandId++;\n    const command = {\n      id: id,\n      method: method,\n      params: params\n    };\n    if (sessionId) {\n      command.sessionId = sessionId;\n    }\n    this._callbacks[id] = callback;\n    this._ws.send(JSON.stringify(command));\n    return new Promise((resolve, reject) => {\n      if (!callback) {\n        this._callbacks[id] = (err, result) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n        };\n      }\n    });\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    this.send(method, params, sessionId, callback);\n  }\n\n  close(callback) {\n    return new Promise((resolve, reject) => {\n      if (this._ws) {\n        this._ws.close();\n        this._ws = null;\n        this.emit('close');\n        if (callback) {\n          callback();\n        }\n        resolve();\n      } else {\n        reject(new Error('WebSocket is not connected'));\n      }\n    });\n  }\n}"
  },
  {
    "Task_id": 193,
    "Instruction": "Task Description: Implement a WebSocket client class in Node.js that connects to a speech synthesis service, sends SSML requests, and handles the audio response streams.\n\nClass Description: WebSocketClient is a class that manages WebSocket connections to Microsoft's Bing Speech API for text-to-speech synthesis. It handles connection lifecycle, request/response mapping, and binary audio data streaming.\n\nAttributes:\n- ws: [WebSocket|null] - Active WebSocket connection instance\n- executorMap: [Map] - Stores promise resolvers/rejectors mapped by request IDs\n- bufferMap: [Map] - Accumulates binary audio data chunks mapped by request IDs\n- timer: [Timeout|null] - Connection timeout handler\n\nMethods:\n- connect() -> [Promise<WebSocket>] - Establishes WebSocket connection with proper headers and returns a promise that resolves when connected\n- sendRequest(ssml: [String], format: [String]) -> [Promise<Buffer>] - Sends SSML request with specified audio format and returns promise resolving to audio buffer\n\nInput:\n- For connect(): None\n- For sendRequest():\n  - ssml: [String] - SSML markup for speech synthesis\n  - format: [String] - Desired audio output format (e.g., \"audio-24khz-48kbitrate-mono-mp3\")\n\nOutput:\n- For connect(): Resolves with WebSocket instance or rejects with error\n- For sendRequest(): Resolves with audio buffer or rejects with error",
    "Canonical_solution": "const { WebSocket } = require(\"ws\");\nconst { randomBytes } = require(\"crypto\");\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  async connect() {\n    const connectionId = randomBytes(16).toString(\"hex\").toLowerCase();\n    let url = `wss://speech.platform.bing.com/consumer/speech/synthesize/readaloud/edge/v1?TrustedClientToken=6A5AA1D4EAFF4E9FB37E23D68491D6F4&ConnectionId=${connectionId}`;\n    let ws = new WebSocket(url, {\n      host: \"speech.platform.bing.com\",\n      origin: \"chrome-extension://jdiccldimpdaibmpdkjnbmckianbfold\",\n      headers: {\n        \"User-Agent\":\n          \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.66 Safari/537.36 Edg/103.0.1264.44\",\n      },\n    });\n    \n    return new Promise((resolve, reject) => {\n      ws.on(\"open\", () => {\n        resolve(ws);\n      });\n      \n      ws.on(\"close\", (code, reason) => {\n        this.ws = null;\n        if (this.timer) {\n          clearTimeout(this.timer);\n          this.timer = null;\n        }\n        for (let [key, value] of this.executorMap) {\n          value.reject(`\u8fde\u63a5\u5df2\u5173\u95ed: ${reason} ${code}`);\n        }\n        this.executorMap.clear();\n        this.bufferMap.clear();\n      });\n\n      ws.on(\"message\", (message, isBinary) => {\n        let pattern = /X-RequestId:(?<id>[a-z|0-9]*)/;\n        if (!isBinary) {\n          let data = message.toString();\n          if (data.includes(\"Path:turn.start\")) {\n            let matches = data.match(pattern);\n            let requestId = matches.groups.id;\n            this.bufferMap.set(requestId, Buffer.from([]));\n          } else if (data.includes(\"Path:turn.end\")) {\n            let matches = data.match(pattern);\n            let requestId = matches.groups.id;\n            let executor = this.executorMap.get(requestId);\n            if (executor) {\n              this.executorMap.delete(matches.groups.id);\n              let result = this.bufferMap.get(requestId);\n              executor.resolve(result);\n            }\n          }\n        } else if (isBinary) {\n          let separator = \"Path:audio\\r\\n\";\n          let data = message;\n          let contentIndex = data.indexOf(separator) + separator.length;\n          let headers = data.slice(2, contentIndex).toString();\n          let matches = headers.match(pattern);\n          let requestId = matches.groups.id;\n          let content = data.slice(contentIndex);\n          let buffer = this.bufferMap.get(requestId);\n          if (buffer) {\n            buffer = Buffer.concat([buffer, content], buffer.length+content.length);\n            this.bufferMap.set(requestId, buffer);\n          }\n        }\n      });\n      \n      ws.on(\"error\", (error) => {\n        reject(`\u8fde\u63a5\u5931\u8d25\uff1a ${error}`);\n      });\n    });\n  }\n\n  async sendRequest(ssml, format) {\n    if (this.ws == null || this.ws.readyState != WebSocket.OPEN) {\n      let connection = await this.connect();\n      this.ws = connection;\n    }\n    \n    const requestId = randomBytes(16).toString(\"hex\").toLowerCase();\n    let result = new Promise((resolve, reject) => {\n      this.executorMap.set(requestId, { resolve, reject });\n      \n      let configData = {\n        context: {\n          synthesis: {\n            audio: {\n              metadataoptions: {\n                sentenceBoundaryEnabled: \"false\",\n                wordBoundaryEnabled: \"false\",\n              },\n              outputFormat: format,\n            },\n          },\n        },\n      };\n      \n      let configMessage =\n        `X-Timestamp:${Date()}\\r\\n` +\n        \"Content-Type:application/json; charset=utf-8\\r\\n\" +\n        \"Path:speech.config\\r\\n\\r\\n\" +\n        JSON.stringify(configData);\n        \n      this.ws.send(configMessage, (configError) => {\n        if (configError) return;\n        \n        let ssmlMessage =\n          `X-Timestamp:${Date()}\\r\\n` +\n          `X-RequestId:${requestId}\\r\\n` +\n          `Content-Type:application/ssml+xml\\r\\n` +\n          `Path:ssml\\r\\n\\r\\n` +\n          ssml;\n        this.ws.send(ssmlMessage);\n      });\n    });\n\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    \n    this.timer = setTimeout(() => {\n      if (this.ws && this.ws.readyState == WebSocket.OPEN) {\n        this.ws.close(1000);\n        this.timer = null;\n      }\n    }, 10000);\n\n    return await Promise.race([\n      result,\n      new Promise((resolve, reject) => {\n        setTimeout(() => {\n          this.executorMap.delete(requestId);\n          this.bufferMap.delete(requestId);\n          reject(\"\u8bf7\u6c42\u8d85\u65f6\");\n        }, 10000);\n      }),\n    ]);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      const url = 'wss://speech.platform.bing.com/consumer/speech/synthesize/readaloud/phonecall/cognitiveservices/v1';\n      this.ws = new WebSocket(url, {\n        headers: {\n          'Ocp-Apim-Subscription-Key': 'YOUR_SUBSCRIPTION_KEY',\n          'Content-Type': 'application/ssml+xml',\n          'X-Microsoft-OutputFormat': 'audio-24khz-48kbitrate-mono-mp3'\n        }\n      });\n\n      this.ws.onopen = () => {\n        if (this.timer) {\n          clearTimeout(this.timer);\n          this.timer = null;\n        }\n        resolve(this.ws);\n      };\n\n      this.ws.onmessage = (event) => {\n        if (event.data instanceof Buffer) {\n          const data = event.data;\n          const requestId = this.getRequestIdFromData(data);\n          if (requestId) {\n            if (!this.bufferMap.has(requestId)) {\n              this.bufferMap.set(requestId, []);\n            }\n            this.bufferMap.get(requestId).push(data);\n          }\n        }\n      };\n\n      this.ws.onerror = (error) => {\n        reject(error);\n      };\n\n      this.ws.onclose = () => {\n        this.ws = null;\n        reject(new Error('WebSocket connection closed'));\n      };\n\n      this.timer = setTimeout(() => {\n        this.ws.close();\n        reject(new Error('Connection timeout'));\n      }, 5000);\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      const requestId = this.generateRequestId();\n      const request = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='en-US'><voice name='en-US-JennyNeural'>${ssml}</voice></speak>`;\n      const buffer = Buffer.from(request, 'utf-8');\n\n      this.executorMap.set(requestId, { resolve, reject });\n\n      this.ws.send(buffer);\n\n      this.timer = setTimeout(() => {\n        this.executorMap.delete(requestId);\n        reject(new Error('Request timeout'));\n      }, 10000);\n    });\n  }\n\n  generateRequestId() {\n    return Math.random().toString(36).substr(2, 9);\n  }\n\n  getRequestIdFromData(data) {\n    // This is a placeholder; actual implementation would extract the request ID from the data\n    return 'request-id-placeholder';\n  }\n}"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a WebSocket-based OrderBook class for managing real-time order book data from a cryptocurrency exchange, with connection management and state handling capabilities.\n\nClass Description: The OrderBook class maintains a real-time order book for a specified trading pair by connecting to a WebSocket feed. It handles connection states, processes incoming messages, and provides event-driven updates. The class inherits from EventEmitter to notify consumers of state changes and order book updates.\n\nAttributes:\n- productID: string - The trading pair identifier (e.g., 'BTC-USD')\n- websocketURI: string - The WebSocket endpoint URL for real-time data\n- restURI: string - The REST API endpoint URL for initial snapshot\n- state: string - Current connection/processing state (from STATES enum)\n- fail_count: number - Count of consecutive connection failures\n- timeProvider: any - Service for timestamp generation\n- socket: WebSocket - The active WebSocket connection instance\n- queue: Array - Buffer for messages received during synchronization\n- book: object - The current order book state with sequence, bids, and asks\n\nMethods:\n- constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) -> OrderBook - Initializes the order book with configuration and starts connection\n- clear_book() -> void - Resets the order book and message queue\n- connect() -> void - Establishes new WebSocket connection with event handlers\n- disconnect() -> void - Closes active WebSocket connection\n- changeState(stateName: string) -> void - Updates state machine and handles transitions (emits statechange event)\n- onOpen() -> void - Handles WebSocket open event (starts synchronization)\n- onClose() -> void - Handles WebSocket close event (updates state)\n- onMessage(datastr: string) -> void - Processes incoming WebSocket messages\n- sync() -> void - Sends subscription message and loads initial snapshot\n- processMessage(message: object, t: Date) -> void - Validates and processes order book updates (emits message-type events)",
    "Canonical_solution": "var WebSocket = require('ws');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nclass OrderBook {\n    constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n        var self = this;\n        EventEmitter.call(self);\n\n        self.productID = productID || 'BTC-USD';\n        self.websocketURI = websocketURI || 'wss://ws-feed.exchange.coinbase.com';\n        self.restURI = restURI;\n        self.state = self.STATES.closed;\n        self.fail_count = 0;\n        self.timeProvider = timeProvider;\n        self.connect();\n    }\n\n    STATES = {\n        'closed': 'closed',\n        'open': 'open',\n        'syncing': 'syncing',\n        'processing': 'processing',\n        'error': 'error',\n    };\n\n    clear_book() {\n        var self = this;\n        self.queue = [];\n        self.book = {\n            'sequence': -1,\n            'bids': {},\n            'asks': {},\n        };\n    };\n\n    connect() {\n        var self = this;\n        if (self.socket) {\n            self.socket.close();\n        }\n        self.clear_book();\n        self.socket = new WebSocket(self.websocketURI);\n        self.socket.on('message', self.onMessage.bind(self));\n        self.socket.on('open', self.onOpen.bind(self));\n        self.socket.on('close', self.onClose.bind(self));\n    };\n\n    disconnect() {\n        var self = this;\n        if (!self.socket) {\n            throw \"Could not disconnect (not connected)\"\n        }\n        self.socket.close();\n        self.onClose();\n    };\n\n    changeState(stateName) {\n        var self = this;\n        var newState = self.STATES[stateName];\n        if (newState === undefined) {\n            throw \"Unrecognized state: \" + stateName;\n        }\n        var oldState = self.state;\n        self.state = newState;\n\n        if (self.fail_count > 3)\n            throw \"Tried to reconnect 4 times. Giving up.\";\n\n        if (self.state === self.STATES.error || self.state === self.STATES.closed) {\n            self.fail_count += 1;\n            self.socket.close();\n            setTimeout(() => self.connect(), 5000);\n        }\n        else if (self.state === self.STATES.processing) {\n            self.fail_count = 0;\n        }\n\n        self.emit('statechange', { 'old': oldState, 'new': newState });\n    };\n\n    onOpen() {\n        var self = this;\n        self.changeState(self.STATES.open);\n        self.sync();\n    };\n\n    onClose() {\n        var self = this;\n        self.changeState(self.STATES.closed);\n    };\n\n    onMessage(datastr: string) {\n        var self = this;\n        var t = self.timeProvider.utcNow();\n        var data = JSON.parse(datastr);\n        if (self.state !== self.STATES.processing) {\n            self.queue.push(data);\n        } else {\n            self.processMessage(data, t);\n        }\n    };\n\n    sync() {\n        var self = this;\n        self.changeState(self.STATES.syncing);\n        var subscribeMessage = {\n            'type': 'subscribe',\n            'product_id': self.productID,\n        };\n        self.socket.send(JSON.stringify(subscribeMessage));\n        self.loadSnapshot();\n    };\n\n    processMessage(message, t: Date) {\n        var self = this;\n        if (message.sequence <= self.book.sequence) {\n            self.emit('ignored', message);\n            return;\n        }\n        if (message.sequence != self.book.sequence + 1) {\n            self.changeState(self.STATES.error);\n        }\n        self.book.sequence = message.sequence;\n\n        self.emit(message.type, new Models.Timestamped(message, t));\n    };\n}\n\nutil.inherits(OrderBook, EventEmitter);",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class OrderBook extends EventEmitter {\n  constructor(productID, websocketURI, restURI, timeProvider) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = 'disconnected';\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = {\n      sequence: 0,\n      bids: [],\n      asks: []\n    };\n    this.connect();\n  }\n\n  clear_book() {\n    this.book = {\n      sequence: 0,\n      bids: [],\n      asks: []\n    };\n    this.queue = [];\n  }\n\n  connect() {\n    this.disconnect();\n    this.socket = new WebSocket(this.websocketURI);\n    this.socket.onopen = () => this.onOpen();\n    this.socket.onmessage = (event) => this.onMessage(event.data);\n    this.socket.onclose = () => this.onClose();\n    this.socket.onerror = (error) => this.onError(error);\n  }\n\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n  }\n\n  changeState(stateName) {\n    if (this.state !== stateName) {\n      this.state = stateName;\n      this.emit('statechange', this.state);\n    }\n  }\n\n  onOpen() {\n    this.changeState('connected');\n    this.sync();\n  }\n\n  onClose() {\n    this.changeState('disconnected');\n    this.fail_count++;\n    setTimeout(() => this.connect(), Math.min(1000 * Math.pow(2, this.fail_count), 30000));\n  }\n\n  onError(error) {\n    console.error('WebSocket error:', error);\n    this.onClose();\n  }\n\n  onMessage(datastr) {\n    try {\n      const message = JSON.parse(datastr);\n      if (this.state === 'synchronizing') {\n        this.queue.push(message);\n      } else {\n        this.processMessage(message, this.timeProvider.now());\n      }\n    } catch (e) {\n      console.error('Error parsing message:', e);\n    }\n  }\n\n  sync() {\n    this.changeState('synchronizing');\n    this.clear_book();\n    this.queue = [];\n    fetch(this.restURI)\n      .then(response => response.json())\n      .then(snapshot => {\n        this.processMessage(snapshot, this.timeProvider.now());\n        this.socket.send(JSON.stringify({ type: 'subscribe', product_id: this.productID }));\n      })\n      .catch(error => {\n        console.error('Failed to fetch snapshot:', error);\n        this.changeState('disconnected');\n      });\n  }\n\n  processMessage(message, t) {\n    if (this.state === 'synchronizing') {\n      if (message.type === 'snapshot') {\n        this.book = message;\n        this.changeState('synced');\n        this.emit('snapshot', this.book);\n      } else if (message.type === 'update') {\n        this.queue.push(message);\n        if (this.queue.length > 0) {\n          this.processQueue(t);\n        }\n      }\n    } else if (this.state === 'synced') {\n      if (message.type === 'update') {\n        this.applyUpdate(message);\n        this.emit('update', message);\n      }\n    }\n  }\n\n  processQueue(t) {\n    while (this.queue.length > 0) {\n      const message = this.queue.shift();\n      this.applyUpdate(message);\n      this.emit('update', message);\n    }\n  }\n\n  applyUpdate(message) {\n    if (message.sequence > this.book.sequence) {\n      this.book.sequence = message.sequence;\n      for (const bid of message.bids) {\n        const index = this.book.bids.findIndex(b => b[0] === bid[0]);\n        if (index !== -1) {\n          this.book.bids[index] = bid;\n        } else {\n          this.book.bids.push(bid);\n        }\n      }\n      for (const ask of message.asks) {\n        const index = this.book.asks.findIndex(a => a[0] === ask[0]);\n        if (index !== -1) {\n          this.book.asks[index] = ask;\n        } else {\n          this.book.asks.push(ask);\n        }\n      }\n      this.book.bids.sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]));\n      this.book.asks.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));\n    }\n  }\n}"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a WebSocket-based communication channel class that handles message sending, receiving, and connection management between a client and server.\n\nClass Description: The Channel class manages WebSocket communication by providing methods to send messages, handle incoming messages, and manage connection lifecycle events. It acts as an abstraction layer over raw WebSocket connections.\n\nAttributes:\n- _ws: [WebSocket] - The underlying WebSocket connection instance\n- _handler: [Object|null] - The message handler object that processes incoming messages\n- _messageListener: [Function] - The bound message event listener function\n\nMethods:\n- constructor(ws) -> [void] - Initializes the channel with a WebSocket instance and sets up message listener\n- send(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Closes the WebSocket connection\n- listen(handler) -> [void] - Sets the message handler for incoming messages\n- dispose() -> [void] - Cleans up event listeners\n- _messageReceived(message) -> [void] - Internal method that forwards incoming messages to the handler\n\nTask Description: Create a service class that manages multiple WebSocket connections and sessions for debugging purposes.\n\nClass Description: The NddService class manages multiple debugging sessions through WebSocket connections, handling session creation, connection events, and cleanup.\n\nAttributes:\n- _disconnectPromise: [Promise] - Promise that resolves when the process disconnects\n- _connected: [Set] - Set of currently connected session IDs\n- _frontend: [Object] - Frontend interface for handling session events\n- _pipe: [string] - Path to the named pipe for IPC communication\n\nMethods:\n- constructor(frontend) -> [void] - Initializes the service with frontend interface and sets up IPC server\n- _startSession(info, frontend) -> [Promise<Function>] - Starts a new debugging session and returns a cleanup function\n  - info: [Object] - Session information including inspector URL and ID\n  - frontend: [Object] - Frontend interface for session events\n  - Returns: [Function] - Async cleanup function for the session",
    "Canonical_solution": "const { spawn } = require('child_process');\nconst os = require('os');\nconst path = require('path');\nconst net = require('net');\nconst WebSocket = require('ws');\n\nclass Channel {\n  /**\n   * @param {!WebSocket} ws\n   */\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.on('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  /**\n   * @param {!Object}\n   */\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeListener('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler.dispatchMessage(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => process.once('disconnect', () => resolve()));\n    this._connected = new Set();\n    this._frontend = frontend;\n\n    const pipePrefix = process.platform === 'win32' ? '\\\\\\\\.\\\\pipe\\\\' : os.tmpdir();\n    const pipeName = `node-ndb.${process.pid}.sock`;\n    this._pipe = path.join(pipePrefix, pipeName);\n    const server = net.createServer(socket => {\n      socket.on('data', async d => {\n        const runSession = await this._startSession(JSON.parse(d), frontend);\n        socket.write('run');\n        runSession();\n      });\n      socket.on('error', e => {});\n    }).listen(this._pipe);\n    server.unref();\n  }\n\n  async _startSession(info, frontend) {\n    const ws = new WebSocket(info.inspectorUrl);\n    const openPromise = new Promise(resolve => ws.once('open', () => resolve()));\n    const errorPromise = new Promise(resolve => ws.once('error', () => resolve()));\n    const closePromise = new Promise(resolve => ws.once('close', () => resolve()));\n    let state = await Promise.race([openPromise, errorPromise, closePromise, this._disconnectPromise]);\n    if (state === openPromise) {\n      this._connected.add(info.id);\n      const channel = new Channel(ws);\n      state = await Promise.race([frontend.detected(info, rpc.handle(channel)), this._disconnectPromise]);\n      return async() => {\n        if (state !== this._disconnectPromise)\n          state = await Promise.race([closePromise, errorPromise, this._disconnectPromise]);\n        channel.dispose();\n        this._connected.delete(info.id);\n        if (state !== this._disconnectPromise)\n          frontend.disconnected(info.id);\n        else\n          ws.send(CALL_EXIT_MESSAGE, () => ws.close());\n      };\n    } else {\n      return async function() {};\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class Channel {\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.addEventListener('message', this._messageListener);\n  }\n\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeEventListener('message', this._messageListener);\n  }\n\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler.onMessage(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => {\n      process.on('disconnect', resolve);\n    });\n    this._connected = new Set();\n    this._frontend = frontend;\n    this._pipe = '/tmp/ndd-service.sock';\n    this._startIpcServer();\n  }\n\n  _startIpcServer() {\n    const server = require('net').createServer();\n    server.on('connection', socket => {\n      socket.on('data', data => {\n        const message = JSON.parse(data.toString());\n        if (message.type === 'startSession') {\n          this._startSession(message.info, this._frontend).then(cleanup => {\n            socket.write(JSON.stringify({ type: 'sessionStarted', id: message.info.id }));\n          });\n        } else if (message.type === 'closeSession') {\n          this._connected.delete(message.info.id);\n          this._frontend.onSessionClose(message.info.id);\n        }\n      });\n    });\n    server.listen(this._pipe, () => {\n      console.log(`IPC server started at ${this._pipe}`);\n    });\n  }\n\n  _startSession(info, frontend) {\n    return new Promise(resolve => {\n      const channel = new Channel(new WebSocket(info.inspectorUrl));\n      channel.listen({\n        onMessage: message => {\n          frontend.onMessage(info.id, message);\n        }\n      });\n      this._connected.add(info.id);\n      frontend.onSessionStart(info.id);\n      resolve(() => {\n        this._connected.delete(info.id);\n        channel.close();\n        channel.dispose();\n        frontend.onSessionClose(info.id);\n      });\n    });\n  }\n}"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome's DevTools Protocol, handling connection, message exchange, and event emission.\n\nClass Description: The Chrome class extends EventEmitter to create a WebSocket client that connects to Chrome's DevTools Protocol. It manages WebSocket connections, handles message parsing, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- _notifier: [Object] - External notification handler\n- _callbacks: [Object] - Map of pending command callbacks\n- _nextCommandId: [Number] - Counter for generating command IDs\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The active WebSocket connection instance\n\nMethods:\n- constructor: [constructor](options: Object, notifier: Object) -> [Chrome] - Initializes the Chrome instance with connection options and notifier\n- _connectToWebSocket: [_connectToWebSocket]() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleMessage: [_handleMessage](message: Object) -> [void] - Processes incoming WebSocket messages (responses and events)\n- _enqueueCommand: [_enqueueCommand](method: String, params: Object, sessionId: String, callback: Function) -> [void] - Sends a command through WebSocket and tracks its callback\n- send: [send](method: String, ...args: Any) -> [Promise|undefined] - Public method to send commands, supporting both callback and Promise patterns",
    "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this._notifier = notifier;\n        this._callbacks = {};\n        this._nextCommandId = 1;\n        this.webSocketUrl = undefined;\n        this._start();\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n        \n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 1;\n    this.webSocketUrl = `${this.secure ? 'wss' : 'ws'}://${this.host}:${this.port}`;\n    this._ws = null;\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connected');\n        resolve();\n      };\n      this._ws.onmessage = (event) => {\n        const message = JSON.parse(event.data);\n        this._handleMessage(message);\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n      this._ws.onclose = () => {\n        this.emit('disconnected');\n      };\n    });\n  }\n\n  _handleMessage(message) {\n    if (message.id && this._callbacks[message.id]) {\n      const callback = this._callbacks[message.id];\n      delete this._callbacks[message.id];\n      callback(null, message.result);\n    } else if (message.method) {\n      this.emit(message.method, message.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const id = this._nextCommandId++;\n    const command = {\n      id: id,\n      method: method,\n      params: params\n    };\n    if (sessionId) {\n      command.sessionId = sessionId;\n    }\n    this._callbacks[id] = callback;\n    this._ws.send(JSON.stringify(command));\n  }\n\n  send(method, ...args) {\n    const params = args[0] || {};\n    const sessionId = args[1];\n    const callback = args[args.length - 1];\n    if (typeof callback === 'function') {\n      this._enqueueCommand(method, params, sessionId, callback);\n      return;\n    } else {\n      return new Promise((resolve, reject) => {\n        this._enqueueCommand(method, params, sessionId, (err, result) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n        });\n      });\n    }\n  }\n}"
  },
  {
    "Task_id": 199,
    "Instruction": "Task Description: Create a WebSocket processor class that manages WebSocket connections and integrates with an HTTP server for handling real-time communication.\n\nClass Description: The Processor class extends EventEmitter to handle WebSocket connections over an HTTP server. It manages the server lifecycle, connection events, and data transmission between client and server.\n\nAttributes:\n- httpServer: [Object] - Instance of Node.js HTTP server used as base for WebSocket server\n- wsServer: [Object] - WebSocket server instance attached to the HTTP server\n- state: [Number] - Tracks the server state (ST_STARTED or ST_CLOSED)\n\nMethods:\n- constructor() -> [void] - Initializes the HTTP and WebSocket servers, sets up connection event handling\n- add(socket: [Object], data: [Buffer|String]) -> [void] - Processes incoming socket connection and data\n- close() -> [void] - Properly shuts down the WebSocket and HTTP servers",
    "Canonical_solution": "var HttpServer = require('http').Server;\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar WebSocketServer = require('ws').Server;\n\nvar ST_STARTED = 1;\nvar ST_CLOSED = 2;\n\nclass Processor extends EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = new HttpServer();\n    this.wsServer = new WebSocketServer({server: this.httpServer});\n    this.state = ST_STARTED;\n\n    this.wsServer.on('connection', (socket) => {\n      this.emit('connection', socket);\n    });\n  }\n\n  add(socket, data) {\n    if(this.state !== ST_STARTED) {\n      return;\n    }\n    this.httpServer.emit('connection', socket);\n    if(typeof socket.ondata === 'function') {\n      socket.ondata(data, 0, data.length);\n    } else {\n      socket.emit('data', data);\n    }\n  }\n\n  close() {\n    if(this.state !== ST_STARTED) {\n      return;\n    }\n    this.state = ST_CLOSED;\n    this.wsServer.close();\n    this.wsServer = null;\n    this.httpServer = null;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class Processor extends EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = require('http').createServer();\n    this.wsServer = require('ws').Server;\n    this.state = 0;\n  }\n  add(socket, data) {\n    socket.on('message', (message) => {\n      this.emit('message', message);\n    });\n    socket.on('close', () => {\n      this.emit('close');\n    });\n  }\n  close() {\n    this.wsServer.close();\n    this.httpServer.close();\n    this.state = 1;\n  }\n}"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a JavaScript class for interacting with the Cryptsy cryptocurrency exchange API, handling both public and private endpoints with proper authentication and request management.\n\nClass Description: The Cryptsy class provides a wrapper for the Cryptsy API, enabling users to make authenticated requests to private endpoints and public data requests. It handles API authentication, request signing, and response processing.\n\nAttributes:\n- key: string - API key for authentication\n- secret: string - API secret for request signing\n- PUBLIC_API_URL: string - Base URL for public API endpoints (default: 'http://pubapi.cryptsy.com/api.php')\n- PRIVATE_API_URL: string - Base URL for private API endpoints (default: 'https://api.cryptsy.com/api')\n- USER_AGENT: string - User agent string for requests (default: 'nomp/node-open-mining-portal')\n- STRICT_SSL: boolean - Static flag for SSL verification (default: true)\n\nMethods:\n- constructor(key, secret) -> Cryptsy - Initializes the API client with credentials\n- _getPrivateHeaders(parameters: object) -> object - Generates authentication headers for private requests\n- _request(options: object, callback: function) -> Cryptsy - Base request method with common configuration\n- _public(parameters: object, callback: function) -> Cryptsy - Makes public API requests\n- _private(parameters: object, callback: function) -> Cryptsy - Makes authenticated private API requests\n- getTicker(callback: function) -> Cryptsy - Gets market ticker data\n- getOrderBook(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets order book for a currency pair\n- getTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets public trade history\n- myBalances(callback: function) -> Cryptsy - Gets user's account balances\n- myOpenOrders(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's open orders\n- myTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's trade history\n- buy(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a buy order\n- sell(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a sell order\n- cancelOrder(currencyA: string, currencyB: string, orderNumber: string, callback: function) -> Cryptsy - Cancels an order\n- withdraw(currency: string, amount: number, address: string, callback: function) -> Cryptsy - Withdraws funds\n- _joinCurrencies(currencyA: string, currencyB: string) -> string - Helper to format currency pairs",
    "Canonical_solution": "var request = require('request');\nvar nonce = require('nonce');\nvar crypto = require('crypto');\n\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n    }\n\n    static STRICT_SSL = true;\n\n    _getPrivateHeaders(parameters) {\n        if (!this.key || !this.secret) {\n            throw 'Cryptsy: Error. API key and secret required';\n        }\n\n        let paramString = Object.keys(parameters).sort().map(function(param) {\n            return encodeURIComponent(param) + '=' + encodeURIComponent(parameters[param]);\n        }).join('&');\n\n        let signature = crypto.createHmac('sha512', this.secret).update(paramString).digest('hex');\n\n        return {\n            Key: this.key,\n            Sign: signature\n        };\n    }\n\n    _request(options, callback) {\n        if (!('headers' in options)) {\n            options.headers = {};\n        }\n\n        options.headers['User-Agent'] = this.USER_AGENT;\n        options.json = true;\n        options.strictSSL = Cryptsy.STRICT_SSL;\n\n        request(options, function(err, response, body) {\n            callback(err, body);\n        });\n\n        return this;\n    }\n\n    _public(parameters, callback) {\n        let options = {\n            method: 'GET',\n            url: this.PUBLIC_API_URL,\n            qs: parameters\n        };\n\n        return this._request(options, callback);\n    }\n\n    _private(parameters, callback) {\n        parameters.nonce = nonce();\n        let options = {\n            method: 'POST',\n            url: this.PRIVATE_API_URL,\n            form: parameters,\n            headers: this._getPrivateHeaders(parameters)\n        };\n\n        return this._request(options, callback);\n    }\n\n    getTicker(callback) {\n        let parameters = {\n            method: 'marketdatav2'\n        };\n        return this._public(parameters, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOrderBook',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    myBalances(callback) {\n        let parameters = {\n            command: 'returnBalances'\n        };\n        return this._private(parameters, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOpenOrders',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'buy',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'sell',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        let parameters = {\n            command: 'cancelOrder',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            orderNumber: orderNumber\n        };\n        return this._private(parameters, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        let parameters = {\n            command: 'withdraw',\n            currency: currency,\n            amount: amount,\n            address: address\n        };\n        return this._private(parameters, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return currencyA + '_' + currencyB;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class Cryptsy {\n  constructor(key, secret) {\n    this.key = key;\n    this.secret = secret;\n    this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n    this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n    this.USER_AGENT = 'nomp/node-open-mining-portal';\n    this.STRICT_SSL = true;\n  }\n\n  _getPrivateHeaders(parameters) {\n    const headers = {\n      'User-Agent': this.USER_AGENT,\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Key': this.key,\n      'Sign': this._signParameters(parameters)\n    };\n    return headers;\n  }\n\n  _request(options, callback) {\n    const https = require('https');\n    const qs = require('querystring');\n\n    const requestOptions = {\n      hostname: options.hostname,\n      port: options.port,\n      path: options.path,\n      method: options.method,\n      headers: options.headers\n    };\n\n    const req = https.request(requestOptions, (res) => {\n      let data = '';\n      res.on('data', (chunk) => {\n        data += chunk;\n      });\n      res.on('end', () => {\n        try {\n          const result = JSON.parse(data);\n          callback(null, result);\n        } catch (err) {\n          callback(err, null);\n        }\n      });\n    });\n\n    req.on('error', (err) => {\n      callback(err, null);\n    });\n\n    if (options.body) {\n      req.write(options.body);\n    }\n\n    req.end();\n  }\n\n  _public(parameters, callback) {\n    const qs = require('querystring');\n    const url = `${this.PUBLIC_API_URL}?${qs.stringify(parameters)}`;\n    this._request({\n      hostname: 'pubapi.cryptsy.com',\n      port: 80,\n      path: url,\n      method: 'GET',\n      headers: {\n        'User-Agent': this.USER_AGENT\n      }\n    }, callback);\n  }\n\n  _private(parameters, callback) {\n    const qs = require('querystring');\n    const body = qs.stringify(parameters);\n    this._request({\n      hostname: 'api.cryptsy.com',\n      port: 443,\n      path: '/api',\n      method: 'POST',\n      headers: this._getPrivateHeaders(parameters),\n      body: body\n    }, callback);\n  }\n\n  getTicker(callback) {\n    this._public({ command: 'getmarketdata' }, callback);\n  }\n\n  getOrderBook(currencyA, currencyB, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._public({ command: 'getorderbook', marketid: pair }, callback);\n  }\n\n  getTradeHistory(currencyA, currencyB, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._public({ command: 'gettradehistory', marketid: pair }, callback);\n  }\n\n  myBalances(callback) {\n    this._private({ command: 'getbalances' }, callback);\n  }\n\n  myOpenOrders(currencyA, currencyB, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._private({ command: 'getopenorders', marketid: pair }, callback);\n  }\n\n  myTradeHistory(currencyA, currencyB, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._private({ command: 'getmytradehistory', marketid: pair }, callback);\n  }\n\n  buy(currencyA, currencyB, rate, amount, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._private({ command: 'buy', marketid: pair, rate: rate, quantity: amount }, callback);\n  }\n\n  sell(currencyA, currencyB, rate, amount, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._private({ command: 'sell', marketid: pair, rate: rate, quantity: amount }, callback);\n  }\n\n  cancelOrder(currencyA, currencyB, orderNumber, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._private({ command: 'cancelorder', marketid: pair, orderNumber: orderNumber }, callback);\n  }\n\n  withdraw(currency, amount, address, callback) {\n    this._private({ command: 'withdraw', currency: currency, amount: amount, address: address }, callback);\n  }\n\n  _joinCurrencies(currencyA, currencyB) {\n    return `${currencyA}_${currencyB}`;\n  }\n\n  _signParameters(parameters) {\n    const crypto = require('crypto');\n    const keys = Object.keys(parameters).sort();\n    let str = '';\n    for (let i = 0; i < keys.length; i++) {\n      str += keys[i] + '=' + parameters[keys[i]] + '&';\n    }\n    str = str.slice(0, -1);\n    return crypto.createHmac('sha512', this.secret).update(str).digest('hex');\n  }\n}"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a class that handles the downloading and installation of binary packages from a specified URL, including directory management and error handling.\n\nClass Description: The Binary class is responsible for downloading a binary package from a given URL, extracting it to a specified directory, and managing the installation process. It handles directory creation, file extraction, and provides feedback on the installation status.\n\nAttributes:\n- url: [String] - The URL from which the binary package will be downloaded.\n- name: [String] - The name of the binary package (optional, defaults to -1).\n- installDirectory: [String] - The base directory where the binary will be installed (optional, defaults to a 'bin' subdirectory in the current working directory).\n- binaryDirectory: [String] - The full path to the directory where the binary will be extracted (initialized as -1, set during installation).\n- binaryPath: [String] - The full path to the binary file (initialized as -1, not used in current implementation).\n\nMethods:\n- constructor(url, data) -> [None] - Initializes the Binary instance with the download URL and optional configuration data (name and installDirectory).\n- install() -> [Promise] - Handles the complete installation process including directory preparation, downloading, extraction, and cleanup. Returns a Promise that resolves when installation is complete or rejects on error.\n  - Internal method _getInstallDirectory() is used to determine the installation directory path.",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass Binary {\n    constructor(url, data) {\n        this.url = url;\n        this.name = data.name || -1;\n        this.installDirectory = data.installDirectory || join(__dirname, \"bin\");\n        this.binaryDirectory = -1;\n        this.binaryPath = -1;\n    }\n\n    install() {\n        const dir = this._getInstallDirectory();\n        if (!existsSync(dir)) {\n            mkdirSync(dir, { recursive: true });\n        }\n\n        this.binaryDirectory = join(dir, \"bin\");\n\n        if (existsSync(this.binaryDirectory)) {\n            rimraf.sync(this.binaryDirectory);\n        }\n\n        mkdirSync(this.binaryDirectory, { recursive: true });\n\n        console.log(`Downloading release from ${this.url}`);\n\n        return axios({ url: this.url, responseType: \"stream\" })\n            .then(res => {\n                const writer = tar.x({ strip: 1, C: this.binaryDirectory });\n\n                return new Promise((resolve, reject) => {\n                    res.data.pipe(writer);\n                    let error = null;\n                    writer.on('error', err => {\n                      error = err;\n                      reject(err);\n                    });\n                    writer.on('close', () => {\n                      if (!error) {\n                        resolve(true);\n                      }\n                    });\n                })\n            })\n            .then(() => {\n                console.log(\n                    `${this.name ? this.name : \"Your package\"} has been installed!`\n                );\n            })\n            .catch(e => {\n                error(`Error fetching release: ${e.message}`);\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class Binary {\n  constructor(url, data) {\n    this.url = url;\n    this.name = data && data.name ? data.name : -1;\n    this.installDirectory = data && data.installDirectory ? data.installDirectory : 'bin';\n    this.binaryDirectory = -1;\n    this.binaryPath = -1;\n  }\n\n  async install() {\n    try {\n      const installDir = await this._getInstallDirectory();\n      this.binaryDirectory = installDir;\n      await this._download();\n      await this._extract();\n      await this._cleanup();\n      return Promise.resolve('Installation completed successfully.');\n    } catch (error) {\n      return Promise.reject(`Installation failed: ${error.message}`);\n    }\n  }\n\n  _getInstallDirectory() {\n    return new Promise((resolve, reject) => {\n      const fs = require('fs');\n      const path = require('path');\n      const dirPath = path.resolve(this.installDirectory);\n      fs.mkdir(dirPath, { recursive: true }, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(dirPath);\n        }\n      });\n    });\n  }\n\n  _download() {\n    return new Promise((resolve, reject) => {\n      const fs = require('fs');\n      const path = require('path');\n      const { exec } = require('child_process');\n      const fileName = this.name || path.basename(this.url);\n      const filePath = path.join(this.binaryDirectory, fileName);\n\n      exec(`curl -o \"${filePath}\" \"${this.url}\"`, (error, stdout, stderr) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(filePath);\n        }\n      });\n    });\n  }\n\n  _extract() {\n    return new Promise((resolve, reject) => {\n      const fs = require('fs');\n      const path = require('path');\n      const { exec } = require('child_process');\n      const filePath = path.join(this.binaryDirectory, this.name || path.basename(this.url));\n\n      exec(`tar -xzf \"${filePath}\" -C \"${this.binaryDirectory}\"`, (error, stdout, stderr) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  _cleanup() {\n    return new Promise((resolve, reject) => {\n      const fs = require('fs');\n      const path = require('path');\n      const filePath = path.join(this.binaryDirectory, this.name || path.basename(this.url));\n\n      fs.unlink(filePath, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n}"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a server, sends and receives messages in JSON format, and handles connection events including opening, closing, and errors.\n\nFunction Description: The function `testWebSocketConnection` initiates a WebSocket client connection to a specified server URL. It sends initial messages upon successful connection, listens for incoming messages, and handles connection lifecycle events. The function demonstrates a basic WebSocket interaction pattern including sending/receiving JSON data and proper connection cleanup.\n\nInput: \n- wssUrl: [String] - The WebSocket server URL (without protocol) to connect to (e.g., \"example.com:8080\")\n\nOutput: \n- None (void) - The function doesn't return any value but logs connection status and received messages to the console. All operations are performed through side effects (event handlers and WebSocket operations).",
    "Canonical_solution": "function testWebSocketConnection() {\n  var WebSocket = require('ws');\n  var echoWs = new WebSocket('wss://' + wssUrl + '/examples/echo');\n  \n  echoWs.on('open', function open() {\n    console.log('WebSocket connection established');\n    \n    echoWs.send('hello');\n    echoWs.once('message', function(data, flags) {\n      data = JSON.parse(data);\n      console.log('Received:', data);\n      \n      echoWs.send('{\"foo\": \"bar\"}');\n      echoWs.once('message', function(data, flags) {\n        data = JSON.parse(data);\n        console.log('Received:', data);\n        \n        echoWs.close();\n      });\n    });\n  });\n  \n  echoWs.on('close', function() {\n    console.log('WebSocket connection closed');\n  });\n  \n  echoWs.on('error', function(err) {\n    console.error('WebSocket error:', err);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nfunction testWebSocketConnection(wssUrl) {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.addEventListener('open', () => {\n    console.log('Connection opened');\n    const initialMessage = { type: 'init', data: 'Hello Server' };\n    ws.send(JSON.stringify(initialMessage));\n  });\n\n  ws.addEventListener('message', (event) => {\n    try {\n      const message = JSON.parse(event.data);\n      console.log('Received message:', message);\n    } catch (error) {\n      console.error('Failed to parse received message:', error);\n    }\n  });\n\n  ws.addEventListener('close', (event) => {\n    console.log(`Connection closed: ${event.reason}`);\n  });\n\n  ws.addEventListener('error', (event) => {\n    console.error('WebSocket error:', event.message);\n  });\n\n  ws.addEventListener('unexpectedClose', (event) => {\n    console.warn('Connection unexpectedly closed:', event.reason);\n  });\n}\n```"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using HTTP POST request with error handling.\n\nFunction Description: The function `sendWebhook` is an asynchronous function that takes data as input and sends it to a predefined webhook URL using an HTTP POST request. It handles potential errors during the request and logs them to the console.\n\nInput: \n- `data` [Object] - The payload/data to be sent to the webhook URL.\n\nOutput: \n- None (The function does not return any value, but it may log errors to the console if the request fails).",
    "Canonical_solution": "const axios = require('axios');\n\nconst sendWebhook = async (data) => {\n    try {\n        await axios.post(process.env.UPDATE_WEBHOOK, data);\n    } catch (err) {\n        console.log(err);\n    }\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function sendWebhook(data) {\n  const webhookUrl = 'https://example.com/webhook';\n  try {\n    const response = await fetch(webhookUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Error sending webhook:', error);\n  }\n}"
  },
  {
    "Task_id": 214,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript to establish a connection with a server, send a command, and handle connection events.\n\nFunction Description: The code establishes a WebSocket connection to a specified URL with a custom protocol. It sends a \"REBOOT\" command upon successful connection and provides empty handlers for incoming messages and connection closure. Error handling is included for connection issues.\n\nInput: None (The WebSocket URL is obtained internally via get_appropriate_ws_url() function)\n\nOutput: None (The function establishes a WebSocket connection and sends a command, but doesn't return any value)\n\nKey Steps:\n1. Initialize WebSocket connection with appropriate browser API (MozWebSocket or standard WebSocket)\n2. Set up event handlers for connection opening, message reception, and connection closing\n3. Implement error handling for connection attempts\n4. Send \"REBOOT\" command upon successful connection\n5. Provide empty handlers for message reception and connection closing events",
    "Canonical_solution": "function init_command() {\n    socket_command.send(\"REBOOT\\n\");\n}\n\nvar socket_command;\n\nif (typeof MozWebSocket != \"undefined\") {\n    socket_command = new MozWebSocket(get_appropriate_ws_url(), \"yi-hack-v3_command\");\n} else {\n    socket_command = new WebSocket(get_appropriate_ws_url(), \"yi-hack-v3_command\");\n}\n\ntry {\n    socket_command.onopen = function() {\n        init_command();\n    }\n\n    socket_command.onmessage = function got_packet(msg) {\n    }\n\n    socket_command.onclose = function(){\n    }\n} catch(exception) {\n    alert('<p>Error' + exception);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "new (function() {\n    var wsUrl = get_appropriate_ws_url();\n    var ws = new (window.MozWebSocket || window.WebSocket)(wsUrl, 'custom-protocol');\n    ws.onopen = function() {\n        ws.send('REBOOT');\n    };\n    ws.onmessage = function(event) {\n    };\n    ws.onclose = function() {\n    };\n    ws.onerror = function(error) {\n    };\n})();"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a client for interacting with Quqi.com's API to perform daily tasks, manage group operations, and track rewards.\n\nClass Description: The QuqiClient class provides methods to interact with Quqi.com's web services including task management, group operations, file uploads, and reward collection. It handles HTTP requests using Axios with proper headers and error handling.\n\nAttributes:\n- headers: [Object] - Contains HTTP headers including cookies and referer for API authentication\n- config: [Object] - Configuration object containing user credentials and settings\n\nMethods:\n- constructor(config) -> [void] - Initializes the client with configuration including authentication cookies\n- _sleep(ms) -> [Promise] - Utility method for delaying execution\n- getDailyTask() -> [Promise<Array|null>] - Retrieves list of incomplete daily tasks\n- getReward(id) -> [Promise<void>] - Claims reward for a specific task ID\n- visit(id) -> [Promise<void>] - Visits a specified group to complete visit tasks\n- getQuqiId() -> [Promise<Object|null>] - Gets group information and handles group joining if needed\n- uploadImg(id) -> [Promise<void>] - Uploads and deletes a dummy image to complete upload tasks\n- executeTasks() -> [Promise<String>] - Executes all available tasks and returns wallet information",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass QuqiClient {\n    constructor(config) {\n        this.headers = {\n            cookie: config.quqi.cookie,\n            referer: \"https://quqi.com/\"\n        };\n    }\n\n    async _sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    async getDailyTask() {\n        try {\n            let res = await axios.get(`https://exp.quqi.com/v1/dailyTask/state?_=1${Date.now()}`, {headers: this.headers});\n            if(res.data.err == 0) {\n                let list = res.data.data.filter(x => x.status != 2);\n                console.log(`\u5269\u4f59${list.length}\u4efb\u52a1\u672a\u5b8c\u6210`);\n                return list;\n            }\n        } catch (err) {\n            console.log(err);\n        }\n        return null;\n    }\n\n    async getReward(id) {\n        try {\n            let res = await axios.get(`https://exp.quqi.com/v1/dailyTask/sendAward/${id}`, {headers: this.headers});\n            console.log(\"\u9886\u53d6\u5956\u52b1\uff1a\" + res.data.msg);\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async visit(id) {\n        try {\n            this.headers[\"User-Agent\"] = \"Mozilla/5.0 (Linux; Android 11; Redmi K30) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36\";\n            let res = await axios.post(`https://quqi.com/api/dir/ls?quqi_id=${id}`, `quqi_id=${id}&tree_id=1&node_id=0`, {headers: this.headers});\n            let res1 = await axios.post(`https://quqi.com/auth/updateVisit?quqi_id=${id}`, `quqi_id=${id}`, {headers: this.headers});\n            console.log(\"\u6d4f\u89c8\u591a\u4eba\u7fa4\u7ec4\uff1a\" + res1.data.msg);\n            await this._sleep(1000);\n            await this.getReward(14);\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async getQuqiId() {\n        try {\n            let res = await axios.get(\"https://group.quqi.com/v1/group/list\", {headers: this.headers});\n            if (res.data.msg == \"success\") {\n                let gplist = res.data.data.filter(x => x.type == 14);\n                let quqid = gplist.length == 0 ? res.data.data[0].quqi_id : gplist[0].quqi_id;\n                let gtype = gplist.length == 0 ? 1 : 2;\n                if (gtype == 1) {\n                    console.log(\"\ud83c\ude1a\ufe0f\u591a\u4eba\u7fa4\u7ec4,\u8bf7\u81ea\u884c\u521b\u5efa\u4e00\u4e2a\u591a\u4eba\u7fa4\u7ec4,\u6216\u8005\u7533\u8bf7\u52a0\u5165https://quqi.avyeld.com/join/company/team.html?jointarget=ed521eef-7ed1-486f-a903-2457ebe5704f\");\n                    let sqres = await axios.post(\"https://group.quqi.com/v1/application\", \"credential=ed521eef-7ed1-486f-a903-2457ebe5704f\", {headers: this.headers});\n                    console.log(\"\u7533\u8bf7\u52a0\u5165\u591a\u4eba\u7fa4\u7ec4\uff1a\" + sqres.data.msg);\n                }\n                return {\n                    qid: quqid,\n                    gtype: gtype\n                };\n            }\n        } catch (err) {\n            console.log(err);\n        }\n        return null;\n    }\n\n    async uploadImg(id) {\n        try {\n            let name = `\u6bcf\u65e5\u7b7e\u5230${Date.now()}`;\n            this.headers[\"User-Agent\"] = \"Mozilla/5.0 (Linux; Android 11; Redmi K30) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36\";\n            let res = await axios.post(`https://quqi.com/api/upload/v1/file/init?quqi_id=${id}`, `file_name=${name}.jpg&is_slice=false&md5=507cf982c5db90bc35f9c6c8179c292f&parent_id=0&quqi_id=${id}&sha=4b4afc24113d86d0afd9be21b6841d9c627cdabf01317e3e760308b05f8bdd81&sign=617db783e0ba01343338ee9887dfdb18&size=331665&tree_id=1`, {headers: this.headers});\n            if (res.data.msg == \"ok\") {\n                console.log(`\u4e0a\u4f20\u56fe\u7247 ${name} \u6210\u529f`);\n                let nid = res.data.data.node_id;\n                if (nid) await axios.post(`https://quqi.com/api/node/batchDel?quqi_id=${id}`, `quqi_id=${id}&tree_id=1&node_ids=${nid}`, {headers: this.headers});\n                await this._sleep(1000);\n                await this.getReward(15);\n            } else {\n                console.log(\"\u4e0a\u4f20\u5931\u8d25\uff1a\" + res.data.msg);\n            }\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async executeTasks() {\n        let quqinfo = \"\";\n        let dailyTaskList = await this.getDailyTask();\n        let qgp = await this.getQuqiId();\n        \n        if (dailyTaskList) {\n            for (let task of dailyTaskList) {\n                console.log(task.task_decreption);\n                if (task.status == 1) {\n                    await this.getReward(task.task_type);\n                } else if (task.task_type == 14 && task.status == 0 && qgp.gtype == 2) {\n                    await this.visit(qgp.qid);\n                } else if (task.task_type == 15 && task.status == 0) {\n                    await this.uploadImg(qgp.qid);\n                }\n            }\n        }\n        \n        let ires = await axios.get(\"https://api.quqi.com/vipWallet/v1/vipAndWallet\", {headers: this.headers});\n        if (ires.data.msg == \"success\") {\n            quqinfo = `\u66f2\u5947\u997c\uff1a${ires.data.data.wallet_info.cookie}  \u66f2\u5947\u8c46\uff1a${ires.data.data.wallet_info.bean}`;\n        } else {\n            quqinfo = ires.data.msg;\n        }\n        console.log(quqinfo);\n        return \"\u3010\u66f2\u5947\u7f51\u76d8\u3011\uff1a\" + quqinfo;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "{\n  \"QuqiClient\": {\n    \"attributes\": {\n      \"headers\": \"{ 'User-Agent': 'Mozilla/5.0', 'Referer': 'https://www.quqi.com/', 'Cookie': '' }\",\n      \"config\": \"{ 'username': '', 'password': '', 'groupId': '' }\"\n    },\n    \"methods\": {\n      \"constructor\": \"function(config) { this.config = config; this.headers.Cookie = this._getAuthCookie(); }\",\n      \"_sleep\": \"function(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\",\n      \"getDailyTask\": \"async function() { try { const response = await axios.get('https://www.quqi.com/api/tasks/daily', { headers: this.headers }); return response.data.tasks; } catch (error) { console.error('Failed to get daily tasks:', error); return null; } }\",\n      \"getReward\": \"async function(id) { try { await axios.post(`https://www.quqi.com/api/tasks/reward/${id}`, {}, { headers: this.headers }); } catch (error) { console.error(`Failed to claim reward for task ${id}:`, error); } }\",\n      \"visit\": \"async function(id) { try { await axios.post(`https://www.quqi.com/api/groups/visit/${id}`, {}, { headers: this.headers }); } catch (error) { console.error(`Failed to visit group ${id}:`, error); } }\",\n      \"getQuqiId\": \"async function() { try { const response = await axios.get(`https://www.quqi.com/api/groups/${this.config.groupId}`, { headers: this.headers }); if (response.data.status === 'notJoined') { await this._joinGroup(); } return response.data; } catch (error) { console.error('Failed to get group info:', error); return null; }\",\n      \"uploadImg\": \"async function(id) { try { const formData = new FormData(); formData.append('file', new Blob(['dummy'], { type: 'image/png' }), 'dummy.png'); await axios.post(`https://www.quqi.com/api/tasks/upload/${id}`, formData, { headers: this.headers }); } catch (error) { console.error(`Failed to upload image for task ${id}:`, error); } }\",\n      \"executeTasks\": \"async function() { try { const tasks = await this.getDailyTask(); if (!tasks) return 'No tasks available'; for (const task of tasks) { if (task.type === 'visit') await this.visit(task.id); else if (task.type === 'upload') await this.uploadImg(task.id); else if (task.type === 'reward') await this.getReward(task.id); await this._sleep(1000); } const walletInfo = await axios.get('https://www.quqi.com/api/wallet', { headers: this.headers }); return walletInfo.data.balance; } catch (error) { console.error('Failed to execute tasks:', error); return 'Error executing tasks'; } }\",\n      \"_getAuthCookie\": \"function() { return `username=${this.config.username}; password=${this.config.password}`; }\",\n      \"_joinGroup\": \"async function() { try { await axios.post(`https://www.quqi.com/api/groups/join/${this.config.groupId}`, {}, { headers: this.headers }); } catch (error) { console.error('Failed to join group:', error); } }\"\n    }\n  }\n}"
  },
  {
    "Task_id": 221,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes multiple WebSocket connections for different binary data types (byte array, byte buffer, and input stream) and handles their communication events.\n\nClass Description: The WebSocketClient class manages three WebSocket connections for different binary data types. It initializes connections, sets binary data types, handles connection events (open, message, error), and provides methods for sending binary data and displaying communication status.\n\nAttributes:\n- websocketByteArray: [WebSocket] - WebSocket connection for byte array data\n- websocketByteBuffer: [WebSocket] - WebSocket connection for byte buffer data\n- websocketInputStream: [WebSocket] - WebSocket connection for input stream data\n- output: [HTMLElement] - DOM element for displaying communication logs\n\nMethods:\n- constructor() -> [void] - Initializes WebSocket connections and event handlers\n- initializeEventHandlers() -> [void] - Sets up event handlers for all WebSocket connections\n- onOpenByteArray(evt: [Event]) -> [void] - Handles byte array connection open event\n- onOpenByteBuffer(evt: [Event]) -> [void] - Handles byte buffer connection open event\n- onOpenInputStream(evt: [Event]) -> [void] - Handles input stream connection open event\n- echoBinaryByteArray() -> [void] - Sends binary data as byte array\n- echoBinaryByteBuffer() -> [void] - Sends binary data as byte buffer\n- echoBinaryInputStream() -> [void] - Sends binary data as input stream\n- onMessageByteArray(evt: [MessageEvent]) -> [void] - Handles received byte array messages\n- onMessageByteBuffer(evt: [MessageEvent]) -> [void] - Handles received byte buffer messages\n- onMessageInputStream(evt: [MessageEvent]) -> [void] - Handles received input stream messages\n- onError(evt: [Event]) -> [void] - Handles WebSocket errors\n- writeToScreen(message: [string]) -> [void] - Displays messages in the output element",
    "Canonical_solution": "var wsByteArrayUri = \"ws://\" + document.location.host + document.location.pathname + \"bytearray\";\nvar wsByteBufferUri = \"ws://\" + document.location.host + document.location.pathname + \"bytebuffer\";\nvar wsInputStreamUri = \"ws://\" + document.location.host + document.location.pathname + \"inputstream\";\n\nclass WebSocketClient {\n    constructor() {\n        this.websocketByteArray = new WebSocket(wsByteArrayUri);\n        this.websocketByteBuffer = new WebSocket(wsByteBufferUri);\n        this.websocketInputStream = new WebSocket(wsInputStreamUri);\n        \n        this.websocketByteArray.binaryType = \"arraybuffer\";\n        this.websocketByteBuffer.binaryType = \"arraybuffer\";\n        this.websocketInputStream.binaryType = \"arraybuffer\";\n        \n        this.output = document.getElementById(\"output\");\n        \n        this.initializeEventHandlers();\n    }\n\n    initializeEventHandlers() {\n        this.websocketByteArray.onopen = (evt) => this.onOpenByteArray(evt);\n        this.websocketByteArray.onmessage = (evt) => this.onMessageByteArray(evt);\n        this.websocketByteArray.onerror = (evt) => this.onError(evt);\n\n        this.websocketByteBuffer.onopen = (evt) => this.onOpenByteBuffer(evt);\n        this.websocketByteBuffer.onmessage = (evt) => this.onMessageByteBuffer(evt);\n        this.websocketByteBuffer.onerror = (evt) => this.onError(evt);\n\n        this.websocketInputStream.onopen = (evt) => this.onOpenInputStream(evt);\n        this.websocketInputStream.onmessage = (evt) => this.onMessageInputStream(evt);\n        this.websocketInputStream.onerror = (evt) => this.onError(evt);\n    }\n\n    onOpenByteArray() {\n        console.log(\"onOpen (byte])\");\n    }\n\n    onOpenByteBuffer() {\n        console.log(\"onOpen (ByteBuffer)\");\n    }\n\n    onOpenInputStream() {\n        console.log(\"onOpen (InputStream)\");\n    }\n\n    echoBinaryByteArray() {\n        var buffer = new ArrayBuffer(myField.value.length);\n        var bytes = new Uint8Array(buffer);\n        for (var i=0; i<bytes.length; i++) {\n            bytes[i] = i;\n        }\n        this.websocketByteArray.send(buffer);\n        this.writeToScreen(\"SENT (byte[]): \" + buffer.byteLength + \" bytes\");\n    }\n\n    echoBinaryByteBuffer() {\n        var buffer = new ArrayBuffer(myField.value.length);\n        var bytes = new Uint8Array(buffer);\n        for (var i=0; i<bytes.length; i++) {\n            bytes[i] = i;\n        }\n        this.websocketByteBuffer.send(buffer);\n        this.writeToScreen(\"SENT (ByteBuffer): \" + buffer.byteLength + \" bytes\");\n    }\n\n    echoBinaryInputStream() {\n        var buffer = new ArrayBuffer(myField.value.length);\n        var bytes = new Uint8Array(buffer);\n        for (var i=0; i<bytes.length; i++) {\n            bytes[i] = i;\n        }\n        this.websocketInputStream.send(buffer);\n        this.writeToScreen(\"SENT (InputStream): \" + buffer.byteLength + \" bytes\");\n    }\n\n    onMessageByteArray(evt) {\n        this.writeToScreen(\"RECEIVED (byte[]): \" + evt.data);\n    }\n\n    onMessageByteBuffer(evt) {\n        this.writeToScreen(\"RECEIVED (ByteBuffer): \" + evt.data);\n    }\n\n    onMessageInputStream(evt) {\n        this.writeToScreen(\"RECEIVED (InputStream): \" + evt.data);\n    }\n\n    onError(evt) {\n        this.writeToScreen('<span style=\"color: red;\">ERROR:</span> ' + evt.data);\n    }\n\n    writeToScreen(message) {\n        var pre = document.createElement(\"p\");\n        pre.style.wordWrap = \"break-word\";\n        pre.innerHTML = message;\n        this.output.appendChild(pre);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nclass WebSocketClient {\n  constructor(outputElement) {\n    this.websocketByteArray = new WebSocket('ws://example.com/bytearray');\n    this.websocketByteBuffer = new WebSocket('ws://example.com/bytebuffer');\n    this.websocketInputStream = new WebSocket('ws://example.com/inputstream');\n    this.output = outputElement;\n    this.initializeEventHandlers();\n  }\n\n  initializeEventHandlers() {\n    this.websocketByteArray.addEventListener('open', this.onOpenByteArray.bind(this));\n    this.websocketByteArray.addEventListener('message', this.onMessageByteArray.bind(this));\n    this.websocketByteArray.addEventListener('error', this.onError.bind(this));\n\n    this.websocketByteBuffer.addEventListener('open', this.onOpenByteBuffer.bind(this));\n    this.websocketByteBuffer.addEventListener('message', this.onMessageByteBuffer.bind(this));\n    this.websocketByteBuffer.addEventListener('error', this.onError.bind(this));\n\n    this.websocketInputStream.addEventListener('open', this.onOpenInputStream.bind(this));\n    this.websocketInputStream.addEventListener('message', this.onMessageInputStream.bind(this));\n    this.websocketInputStream.addEventListener('error', this.onError.bind(this));\n  }\n\n  onOpenByteArray(evt) {\n    this.writeToScreen('Byte array connection opened.');\n    this.echoBinaryByteArray();\n  }\n\n  onOpenByteBuffer(evt) {\n    this.writeToScreen('Byte buffer connection opened.');\n    this.echoBinaryByteBuffer();\n  }\n\n  onOpenInputStream(evt) {\n    this.writeToScreen('Input stream connection opened.');\n    this.echoBinaryInputStream();\n  }\n\n  echoBinaryByteArray() {\n    const data = new Uint8Array([1, 2, 3, 4, 5]);\n    this.websocketByteArray.send(data.buffer);\n  }\n\n  echoBinaryByteBuffer() {\n    const data = new ArrayBuffer(5);\n    const view = new Uint8Array(data);\n    view[0] = 6;\n    view[1] = 7;\n    view[2] = 8;\n    view[3] = 9;\n    view[4] = 10;\n    this.websocketByteBuffer.send(data);\n  }\n\n  echoBinaryInputStream() {\n    const data = new Uint8Array([11, 12, 13, 14, 15]);\n    this.websocketInputStream.send(data.buffer);\n  }\n\n  onMessageByteArray(evt) {\n    const arrayBuffer = evt.data;\n    const dataView = new DataView(arrayBuffer);\n    let message = 'Received byte array: ';\n    for (let i = 0; i < dataView.byteLength; i++) {\n      message += dataView.getUint8(i) + ' ';\n    }\n    this.writeToScreen(message);\n  }\n\n  onMessageByteBuffer(evt) {\n    const arrayBuffer = evt.data;\n    const dataView = new DataView(arrayBuffer);\n    let message = 'Received byte buffer: ';\n    for (let i = 0; i < dataView.byteLength; i++) {\n      message += dataView.getUint8(i) + ' ';\n    }\n    this.writeToScreen(message);\n  }\n\n  onMessageInputStream(evt) {\n    const arrayBuffer = evt.data;\n    const dataView = new DataView(arrayBuffer);\n    let message = 'Received input stream: ';\n    for (let i = 0; i < dataView.byteLength; i++) {\n      message += dataView.getUint8(i) + ' ';\n    }\n    this.writeToScreen(message);\n  }\n\n  onError(evt) {\n    this.writeToScreen('WebSocket error observed.');\n  }\n\n  writeToScreen(message) {\n    this.output.textContent += message + '\\n';\n  }\n}\n```"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a function that interacts with Microsoft's Speech API to convert SSML (Speech Synthesis Markup Language) text into speech audio using HTTP requests.\n\nFunction Description: The function `speechApi` sends a POST request to Microsoft's Speech API endpoint with SSML text as input and receives audio data in MP3 format as response. It handles the HTTP communication including request configuration, headers, payload, and error handling.\n\nInput: \n- ssml: [String] - The SSML formatted text to be converted to speech\n\nOutput: \n- [Promise] - Resolves with the audio data in arraybuffer format if successful, rejects with error if the request fails",
    "Canonical_solution": "const axios = require(\"axios\");\nconst { v4: uuidv4 } = require(\"uuid\");\n\nfunction speechApi(ssml) {\n    var data = JSON.stringify({\n        ssml,\n        ttsAudioFormat: \"audio-24khz-160kbitrate-mono-mp3\",\n        offsetInPlainText: 0,\n        properties: {\n            SpeakTriggerSource: \"AccTuningPagePlayButton\",\n        },\n    });\n\n    var config = {\n        method: \"post\",\n        url: \"https://southeastasia.api.speech.microsoft.com/accfreetrial/texttospeech/acc/v3.0-beta1/vcg/speak\",\n        responseType: \"arraybuffer\",\n        headers: {\n            authority: \"southeastasia.api.speech.microsoft.com\",\n            accept: \"*/*\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            customvoiceconnectionid: uuidv4(),\n            origin: \"https://speech.microsoft.com\",\n            \"sec-ch-ua\": '\"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-site\",\n            \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\",\n            \"content-type\": \"application/json\",\n        },\n        data: data,\n    };\n\n    return new Promise((resolve, reject) => {\n        axios(config)\n            .then(function(response) {\n                resolve(response.data);\n            })\n            .catch(function(error) {\n                console.error(error);\n                reject(error);\n            });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "function speechApi(ssml) {\n  return new Promise((resolve, reject) => {\n    const subscriptionKey = 'YOUR_SUBSCRIPTION_KEY';\n    const serviceRegion = 'YOUR_SERVICE_REGION';\n    const uri = `https://${serviceRegion}.api.cognitive.microsoft.com/sts/v1.0/issueToken`;\n    const ttsUri = `https://${serviceRegion}.tts.speech.microsoft.com/cognitiveservices/v1`;\n\n    fetch(uri, {\n      method: 'POST',\n      headers: {\n        'Ocp-Apim-Subscription-Key': subscriptionKey\n      }\n    })\n      .then(response => response.text())\n      .then(accessToken => {\n        fetch(ttsUri, {\n          method: 'POST',\n          headers: {\n            'Authorization': 'Bearer ' + accessToken,\n            'Content-Type': 'application/ssml+xml',\n            'X-Microsoft-OutputFormat': 'audio-16khz-32bit-flt-opus'\n          },\n          body: ssml\n        })\n          .then(response => {\n            if (!response.ok) {\n              throw new Error('Network response was not ok');\n            }\n            return response.arrayBuffer();\n          })\n          .then(data => resolve(data))\n          .catch(error => reject(error));\n      })\n      .catch(error => reject(error));\n  });\n}"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that connects to a server, sends messages, and displays received messages in a chat interface.\n\nFunction Description: The function `setupWebSocket` initializes a WebSocket connection to a server when a button is clicked. It handles connection events (open, close, message) and allows sending messages via an input field. The function disables the join button during active connection and re-enables it when closed.\n\nInput: \n- None (the function uses DOM elements internally: username input, join button, chat textarea, and message input field)\n\nOutput: \n- None (the function sets up event listeners and modifies DOM elements directly)\n\nAttributes: N/A (function-level implementation)\n\nMethods: N/A (function-level implementation)",
    "Canonical_solution": "function setupWebSocket() {\n    const username = document.querySelector(\"#username\");\n    const join_btn = document.querySelector(\"#join-chat\");\n    const textarea = document.querySelector(\"#chat\");\n    const input = document.querySelector(\"#input\");\n\n    join_btn.addEventListener(\"click\", function(e) {\n        this.disabled = true;\n\n        const websocket = new WebSocket(\"ws://localhost:3000/websocket\");\n\n        websocket.onopen = function() {\n            console.log(\"connection opened\");\n            websocket.send(username.value);\n        }\n\n        const btn = this;\n\n        websocket.onclose = function() {\n            console.log(\"connection closed\");\n            btn.disabled = false;\n        }\n\n        websocket.onmessage = function(e) {\n            console.log(\"received message: \"+e.data);\n            textarea.value += e.data+\"\\r\\n\";\n        }\n\n        input.onkeydown = function(e) {\n            if (e.key == \"Enter\") {\n                websocket.send(input.value);\n                input.value = \"\";\n            }\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nfunction setupWebSocket() {\n    const usernameInput = document.getElementById('username');\n    const joinButton = document.getElementById('join');\n    const chatBox = document.getElementById('chat');\n    const messageInput = document.getElementById('message');\n\n    let socket;\n\n    joinButton.addEventListener('click', () => {\n        const username = usernameInput.value.trim();\n        if (!username) return;\n\n        socket = new WebSocket(`ws://example.com/chat?username=${encodeURIComponent(username)}`);\n\n        socket.addEventListener('open', () => {\n            joinButton.disabled = true;\n            chatBox.textContent += 'Connected to the chat!\\n';\n        });\n\n        socket.addEventListener('message', (event) => {\n            const message = event.data;\n            chatBox.textContent += message + '\\n';\n            chatBox.scrollTop = chatBox.scrollHeight;\n        });\n\n        socket.addEventListener('close', () => {\n            chatBox.textContent += 'Disconnected from the chat.\\n';\n            joinButton.disabled = false;\n        });\n\n        socket.addEventListener('error', (error) => {\n            console.error('WebSocket Error:', error);\n        });\n\n        messageInput.addEventListener('keypress', (e) => {\n            if (e.key === 'Enter') {\n                const message = messageInput.value.trim();\n                if (message && socket.readyState === WebSocket.OPEN) {\n                    socket.send(message);\n                    messageInput.value = '';\n                }\n            }\n        });\n    });\n}\n```"
  },
  {
    "Task_id": 234,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a WebSocket server, handles connection events, sends and receives messages, and manages errors and connection closure.\n\nFunction Description: The function `testWebSocket` initializes a WebSocket connection to a specified URI and sets up event handlers for connection opening, closing, message reception, and errors. The event handlers (`onOpen`, `onClose`, `onMessage`, `onError`) manage the respective events, while `sendMessage` sends messages to the server.\n\nInput: \n- `wsUri` [String] - The WebSocket server URI to connect to.\n\nOutput: \n- None (The function sets up event handlers and manages WebSocket connection lifecycle).",
    "Canonical_solution": "function testWebSocket() {\n    websocket = new WebSocket(wsUri);\n    websocket.onopen = onOpen;\n    websocket.onclose = onClose;\n    websocket.onmessage = onMessage;\n    websocket.onerror = onError;\n}\n\nfunction onOpen(evt) {\n    writeLog(\"CONNECTED\");\n    sendMessage(\"Hello, Rocket!\");\n}\n\nfunction onClose(evt) {\n    writeLog(\"Websocket DISCONNECTED\");\n}\n\nfunction onMessage(evt) {\n    writeLog('<span style=\"color: blue;\">RESPONSE: ' + evt.data+'</span>');\n}\n\nfunction onError(evt) {\n    writeLog('<span style=\"color: red;\">ERROR:</span> ' + evt.data);\n}\n\nfunction sendMessage(message) {\n    writeLog(\"SENT: \" + message);\n    websocket.send(message);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nfunction testWebSocket(wsUri) {\n    const socket = new WebSocket(wsUri);\n\n    socket.addEventListener('open', function (event) {\n        onOpen(event);\n    });\n\n    socket.addEventListener('close', function (event) {\n        onClose(event);\n    });\n\n    socket.addEventListener('message', function (event) {\n        onMessage(event);\n    });\n\n    socket.addEventListener('error', function (event) {\n        onError(event);\n    });\n\n    function sendMessage(message) {\n        if (socket.readyState === WebSocket.OPEN) {\n            socket.send(message);\n        } else {\n            console.error('WebSocket is not open. Cannot send message.');\n        }\n    }\n\n    function onOpen(event) {\n        console.log('Connection opened:', event);\n        // Example: Send a greeting message\n        sendMessage('Hello, server!');\n    }\n\n    function onClose(event) {\n        console.log('Connection closed:', event);\n    }\n\n    function onMessage(event) {\n        console.log('Message received:', event.data);\n    }\n\n    function onError(event) {\n        console.error('WebSocket error:', event);\n    }\n}\n```"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a WebSocket client connection class for browser environments that handles connection lifecycle, message events, and window focus state tracking.\n\nClass Description: The BrowserConnection class manages a WebSocket connection in a browser environment, including connection setup, event handling, and window visibility tracking. It extends a base connection class (BaseConnection) and adds browser-specific functionality.\n\nAttributes:\n- focusDetectorTimer: [Number] - Timer ID for the focus detection interval\n- windowVisible: [Boolean] - Tracks whether the browser window is currently visible\n- socket: [WebSocket] - The WebSocket connection instance\n\nMethods:\n- constructor(opts: Object) -> void - Initializes the connection with options and sets up event listeners for 'ready' and 'disconnect' events\n- setupSocket() -> WebSocket - Creates and configures a new WebSocket connection with event handlers for open, close, and message events\n- startFocusLoop() -> void - Starts tracking window visibility by setting up event listeners for focus/blur events and periodic checks\n- stopFocusLoop() -> void - Stops the window visibility tracking by clearing the interval timer and removing event listeners\n- handleOpen() -> void - Inherited from BaseConnection, called when WebSocket connection opens\n- handleClose(code: Number, reason: String) -> void - Inherited from BaseConnection, called when WebSocket connection closes\n- handleData(data: String) -> void - Inherited from BaseConnection, called when WebSocket receives a message\n- reportFocus(isVisible: Boolean) -> void - Inherited from BaseConnection, reports current window focus state",
    "Canonical_solution": "var WebSocket = require(\"ws\");\nvar _ = require(\"underscore\");\n\nclass BrowserConnection {\n  constructor(opts) {\n    BaseConnection.call(this, opts);\n    var connection = this;\n    this.on(\"ready\", function() {\n      connection.startFocusLoop()\n    });\n    this.on(\"disconnect\", function() {\n      connection.stopFocusLoop()\n    });\n  }\n\n  setupSocket() {\n    var connection = this;\n    var socket = new WebSocket(this.getUrl());\n    socket.onopen = function() {\n      connection.handleOpen()\n    };\n    socket.onclose = function(data) {\n      connection.handleClose(data[\"code\"], data[\"reason\"])\n    };\n    socket.onmessage = function(message) {\n      connection.handleData(message.data)\n    };\n    return socket;\n  }\n\n  startFocusLoop() {\n    if (this.focusDetectorTimer) return;\n    var connection = this;\n    var propertyName = null;\n    if (typeof document.hidden !== \"undefined\") {\n      propertyName = \"hidden\"\n    } else if (typeof document.mozHidden !== \"undefined\") {\n      propertyName = \"mozHidden\"\n    } else if (typeof document.msHidden !== \"undefined\") {\n      propertyName = \"msHidden\"\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n      propertyName = \"webkitHidden\"\n    } else {\n      propertyName = undefined\n    }\n    if (connection.windowVisible === undefined) {\n      connection.windowVisible = propertyName === undefined ? true : document[propertyName] === false\n    }\n    var focusListener = window.addEventListener(\"focus\", function(e) {\n      connection.windowVisible = true;\n      updateFocusState()\n    });\n    var blurListener = window.addEventListener(\"blur\", function(e) {\n      connection.windowVisible = false;\n      updateFocusState()\n    });\n    this.on(\"disconnect\", function() {\n      window.removeEventListener(\"focus\", focusListener);\n      window.removeEventListener(\"blur\", blurListener)\n    });\n    var updateFocusState = function() {\n      var isVisible = propertyName === undefined ? true : document[propertyName] === false;\n      connection.reportFocus(isVisible && connection.windowVisible)\n    };\n    this.focusDetectorTimer = setInterval(updateFocusState, 100)\n  }\n\n  stopFocusLoop() {\n    if (!this.focusDetectorTimer) return;\n    clearTimeout(this.focusDetectorTimer);\n    delete this.focusDetectorTimer;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "class BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super(opts);\n    this.focusDetectorTimer = null;\n    this.windowVisible = true;\n    this.socket = null;\n  }\n\n  setupSocket() {\n    this.socket = new WebSocket(this.opts.url);\n    this.socket.addEventListener('open', () => this.handleOpen());\n    this.socket.addEventListener('close', (event) => this.handleClose(event.code, event.reason));\n    this.socket.addEventListener('message', (event) => this.handleData(event.data));\n    return this.socket;\n  }\n\n  startFocusLoop() {\n    this.windowVisible = document.visibilityState === 'visible';\n    this.focusDetectorTimer = setInterval(() => {\n      const isVisible = document.visibilityState === 'visible';\n      if (isVisible !== this.windowVisible) {\n        this.windowVisible = isVisible;\n        this.reportFocus(this.windowVisible);\n      }\n    }, 1000);\n    document.addEventListener('visibilitychange', () => {\n      const isVisible = document.visibilityState === 'visible';\n      if (isVisible !== this.windowVisible) {\n        this.windowVisible = isVisible;\n        this.reportFocus(this.windowVisible);\n      }\n    });\n  }\n\n  stopFocusLoop() {\n    if (this.focusDetectorTimer) {\n      clearInterval(this.focusDetectorTimer);\n      this.focusDetectorTimer = null;\n    }\n    document.removeEventListener('visibilitychange', () => {\n      const isVisible = document.visibilityState === 'visible';\n      if (isVisible !== this.windowVisible) {\n        this.windowVisible = isVisible;\n        this.reportFocus(this.windowVisible);\n      }\n    });\n  }\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a class that serves as an HTTP client for interacting with a build service API, handling different types of package-related operations with proper error handling.\n\nClass Description: The BuildService class provides methods to fetch package build statistics, exports, and export sizes from a remote build service. It uses Axios for HTTP requests and implements centralized error handling.\n\nAttributes:\n- operations: [Array] - A predefined list of available API operations, each specifying the operation type, endpoint, and corresponding method name\n\nMethods:\n- _makeHttpRequest: [Name](operation: Object, packageString: String) -> Promise<Object> - Makes an HTTP GET request to the build service with the specified operation and package string, handles the response and errors\n- _handleError: [Name](error: Error, operationType: String) -> Throws CustomError - Centralized error handling that processes different types of errors (response errors, request errors, and other errors) and throws appropriate custom errors\n- getPackageBuildStats: [Name](packageString: String) -> Promise<Object> - Retrieves build statistics for the specified package\n- getPackageExports: [Name](packageString: String) -> Promise<Object> - Retrieves all exports for the specified package\n- getPackageExportSizes: [Name](packageString: String) -> Promise<Object> - Retrieves size information for all exports of the specified package",
    "Canonical_solution": "const axios = require('axios');\nconst CustomError = require('../CustomError');\n\nclass BuildService {\n  constructor() {\n    this.operations = [\n      {\n        type: 'PACKAGE_BUILD_STATS',\n        endpoint: '/size',\n        methodName: 'getPackageStats',\n      },\n      {\n        type: 'PACKAGE_EXPORTS',\n        endpoint: '/exports',\n        methodName: 'getAllPackageExports',\n      },\n      {\n        type: 'PACKAGE_EXPORTS_SIZES',\n        endpoint: '/exports-sizes',\n        methodName: 'getPackageExportSizes',\n      },\n    ];\n  }\n\n  async _makeHttpRequest(operation, packageString) {\n    try {\n      const response = await axios.get(\n        `${process.env.BUILD_SERVICE_ENDPOINT}${operation.endpoint}?p=${encodeURIComponent(packageString)}`\n      );\n      return response.data;\n    } catch (error) {\n      this._handleError(error, operation.type);\n    }\n  }\n\n  _handleError(error, operationType) {\n    if (error.response) {\n      const contents = error.response.data;\n      throw new CustomError(\n        contents.name || 'BuildError',\n        contents.originalError,\n        contents.extra\n      );\n    } else if (error.request) {\n      throw new CustomError('BuildError', {\n        operation: operationType,\n        reason: 'BUILD_SERVICE_UNREACHABLE',\n        url: error.request._currentUrl,\n      });\n    } else {\n      throw new CustomError('BuildError', error.message, {\n        operation: operationType,\n      });\n    }\n  }\n\n  async getPackageBuildStats(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_BUILD_STATS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExports(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExportSizes(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS_SIZES');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class BuildService {\n  constructor() {\n    this.operations = [\n      { type: 'getPackageBuildStats', endpoint: '/build-stats', methodName: 'getPackageBuildStats' },\n      { type: 'getPackageExports', endpoint: '/exports', methodName: 'getPackageExports' },\n      { type: 'getPackageExportSizes', endpoint: '/export-sizes', methodName: 'getPackageExportSizes' }\n    ];\n  }\n\n  async _makeHttpRequest(operation, packageString) {\n    try {\n      const response = await axios.get(`https://build-service.example.com${operation.endpoint}/${packageString}`);\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, operation.type);\n    }\n  }\n\n  _handleError(error, operationType) {\n    if (error.response) {\n      throw new CustomError(`Request failed with status ${error.response.status} for ${operationType}`, error.response.status);\n    } else if (error.request) {\n      throw new CustomError(`No response received for ${operationType}`, 503);\n    } else {\n      throw new CustomError(`Error in request setup for ${operationType}`, 500);\n    }\n  }\n\n  async getPackageBuildStats(packageString) {\n    const operation = this.operations.find(op => op.methodName === 'getPackageBuildStats');\n    return this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExports(packageString) {\n    const operation = this.operations.find(op => op.methodName === 'getPackageExports');\n    return this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExportSizes(packageString) {\n    const operation = this.operations.find(op => op.methodName === 'getPackageExportSizes');\n    return this._makeHttpRequest(operation, packageString);\n  }\n}\n\nclass CustomError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.name = 'CustomError';\n    this.statusCode = statusCode;\n  }\n}"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Create a function to establish and manage a WebSocket connection in a browser environment, including handling connection events, sending messages, and closing the connection.\n\nFunction Description: The function `setupWebSocketConnection` initializes a WebSocket connection to a specified URL and provides methods to interact with the connection. It sets up event handlers for connection events (`open`, `message`, `close`, `error`) and returns an object with methods to send data, close the connection, and set the binary type of the WebSocket.\n\nInput: \n- `url` [String] - The URL to which the WebSocket connection will be established.\n\nOutput: \n- Returns an object with the following methods:\n  - `send(data)` - Sends data through the WebSocket connection.\n  - `close()` - Closes the WebSocket connection.\n  - `setBinaryType(type)` - Sets the binary type of the WebSocket connection (`blob` or `arraybuffer`).",
    "Canonical_solution": "function setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  \n  ws.onopen = function() {\n    alert('open');\n  };\n  \n  ws.onmessage = function(message) {\n    alert(message.data);\n  };\n  \n  ws.onclose = function() {\n    alert('close');\n  };\n  \n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    send: function(data) {\n      ws.send(data);\n    },\n    close: function() {\n      ws.close();\n    },\n    setBinaryType: function(type) {\n      ws.binaryType = type;\n    }\n  };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  return {\n    send(data) {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.send(data);\n      } else {\n        console.error('WebSocket is not open. Ready state:', ws.readyState);\n      }\n    },\n    close() {\n      ws.close();\n    },\n    setBinaryType(type) {\n      ws.binaryType = type;\n    }\n  };\n}"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, sends messages, and handles incoming messages, connection events, and errors.\n\nFunction Description: The WebSocket client connects to a specified URI using a custom protocol, provides functions to send messages, and includes event handlers for connection opening, message reception, and errors.\n\nInput:\n- `wsUri` (String): The WebSocket server URI to connect to (e.g., \"ws://example.com/socket\").\n- `myProtocol` (String): The subprotocol to use for the WebSocket connection (e.g., \"myProtocol\").\n- `myField.value` (String): The message to be sent to the server (provided via an input field in the UI).\n\nOutput:\n- Console/log output indicating connection status, sent messages, received messages, and errors.\n- No explicit return value; side effects include WebSocket communication and logging.\n\nMethods (implicit in the reference code):\n- `echoText()` -> undefined - Sends the value of `myField` to the WebSocket server and logs the sent message.\n- `onOpen(evt)` -> undefined - Logs when the WebSocket connection is successfully established.\n- `onMessage(evt)` -> undefined - Logs messages received from the WebSocket server.\n- `onError(evt)` -> undefined - Logs errors encountered during WebSocket communication.",
    "Canonical_solution": "function echoText() {\n    websocket.send(myField.value);\n    writeToScreen(\"SENT: \" + myField.value);\n}\n\nfunction onOpen() {\n    writeToScreen(\"CONNECTED\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen(\"RECEIVED: \" + evt.data);\n}\n\nfunction onError(evt) {\n    writeToScreen('<span style=\"color: red;\">ERROR:</span> ' + evt.data);\n}\n\nvar websocket = new WebSocket(wsUri, \"myProtocol\");\nwebsocket.onopen = function(evt) { onOpen(evt) };\nwebsocket.onmessage = function(evt) { onMessage(evt) };\nwebsocket.onerror = function(evt) { onError(evt) };",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nconst wsUri = \"ws://example.com/socket\";\nconst myProtocol = \"myProtocol\";\n\nconst myField = { value: \"Hello, WebSocket!\" };\n\nconst socket = new WebSocket(wsUri, myProtocol);\n\nsocket.addEventListener(\"open\", function (evt) {\n  console.log(\"Connection established:\", evt);\n});\n\nsocket.addEventListener(\"message\", function (evt) {\n  console.log(\"Received message:\", evt.data);\n});\n\nsocket.addEventListener(\"error\", function (evt) {\n  console.error(\"WebSocket error:\", evt);\n});\n\nfunction echoText() {\n  const message = myField.value;\n  socket.send(message);\n  console.log(\"Sent message:\", message);\n}\n```"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Write a function that retrieves TV channel data from a specified URL, processes the data to extract relevant channel information, and returns it in a structured format.\n\nFunction Description: The function `getChannels` asynchronously fetches TV channel data from a remote API endpoint using HTTP GET request. It processes the response to extract channel details such as language, site ID, and name, then returns them as an array of objects. Error handling is included to log any issues during the request.\n\nInput: None (The function does not take any input parameters; it uses a hardcoded URL for the API endpoint.)\n\nOutput: An array of objects, where each object represents a TV channel with the following properties:\n- `lang`: [String] - The language of the channel (e.g., 'lv').\n- `site_id`: [String] - The unique identifier/slug for the channel.\n- `name`: [String] - The display name of the channel.\n\nIf an error occurs during the HTTP request, the error will be logged to the console, and the function may return an empty array or undefined depending on the error handling flow.",
    "Canonical_solution": "async function getChannels() {\n    const axios = require('axios');\n    const groups = await axios\n        .get('https://www.tv.lv/data/channels/lvall')\n        .then(r => r.data)\n        .catch(console.log);\n\n    let channels = [];\n\n    groups.forEach(group => {\n        group.channels.forEach(item => {\n            channels.push({\n                lang: 'lv',\n                site_id: item.slug,\n                name: item.name\n            });\n        });\n    });\n\n    return channels;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function getChannels() {\n  const url = 'https://api.example.com/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    const data = await response.json();\n    return data.map(channel => ({\n      lang: channel.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching TV channel data:', error);\n    return [];\n  }\n}"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a WebSocket server, handles connection events, sends messages, and manages errors and closures.\n\nFunction Description: The function `connectWebSocket` initializes a WebSocket client connection to a specified server. It sets up event handlers for connection opening, incoming messages, and connection closing. The function also sends an initial message upon successful connection and logs all events to the console.\n\nInput: \n- Optional command line arguments:\n  - `port` (number): The port number to connect to (default: 7000).\n  - `secure` (boolean): Whether to use a secure WebSocket connection (wss) (default: false, uses ws).\n\nOutput: \n- No explicit return value. The function logs connection status, received messages, and closure events to the console.\n- Side effects: Establishes a WebSocket connection and sends/receives messages.",
    "Canonical_solution": "function connectWebSocket() {\n    var WebSocket = require('../lib/faye/websocket'),\n        port = process.argv[2] || 7000,\n        secure = process.argv[3] === 'ssl',\n        scheme = secure ? 'wss' : 'ws',\n        ws = new WebSocket.Client(scheme + '://localhost:' + port + '/');\n\n    console.log('Connecting to ' + ws.url);\n\n    ws.onopen = function(event) {\n        console.log('open');\n        ws.send('Hello, WebSocket!');\n    };\n\n    ws.onmessage = function(event) {\n        console.log('message', event.data);\n    };\n\n    ws.onclose = function(event) {\n        console.log('close', event.code, event.reason);\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function connectWebSocket(port = 7000, secure = false) {\n  const protocol = secure ? 'wss' : 'ws';\n  const ws = new WebSocket(`${protocol}://localhost:${port}`);\n\n  ws.addEventListener('open', () => {\n    console.log('WebSocket connection established.');\n    ws.send('Hello, server!');\n  });\n\n  ws.addEventListener('message', (event) => {\n    console.log('Received message:', event.data);\n  });\n\n  ws.addEventListener('close', (event) => {\n    console.log(`Connection closed. Code: ${event.code}, Reason: ${event.reason}`);\n  });\n\n  ws.addEventListener('error', (event) => {\n    console.error('WebSocket error:', event.message);\n  });\n}"
  },
  {
    "Task_id": 265,
    "Instruction": "Task Description: Create a WebSocket server class in Node.js that handles incoming connections, manages sessions, and processes messages with customizable handlers.\n\nClass Description: The XVIZServer class is a WebSocket server implementation that manages WebSocket connections, delegates session handling to provided handlers, and provides logging capabilities. It wraps the 'ws' library functionality with additional session management features.\n\nAttributes:\n- _server: [WebSocket.Server] - The underlying WebSocket server instance\n- handlers: [Array] - Array of handler objects responsible for managing sessions\n- options: [Object] - Configuration options for the server, merged with defaults\n\nMethods:\n- constructor(handlers, options, callback) -> [XVIZServer] - Initializes the WebSocket server with message handlers, options, and an optional callback. Throws an error if no handlers are provided.\n- get server() -> [WebSocket.Server] - Getter for the underlying WebSocket server instance\n- close(cb) -> [void] - Closes the WebSocket server, accepting an optional callback\n- handleSession(socket, request) -> [Promise<void>] - Handles new WebSocket connections, delegates to handlers for session creation, and closes the connection if no handler accepts it\n- log(...msg) -> [void] - Logs messages using the configured logger if available",
    "Canonical_solution": "const WebSocket = require('ws');\n\nexport class XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers) {\n      throw new Error('Must specify a handler for messages');\n    }\n\n    this.handlers = handlers;\n    this.options = Object.assign(DEFAULT_OPTIONS, options);\n    this._server = new WebSocket.Server(this.options, callback);\n\n    this.server.on('connection', (socket, request) => this.handleSession(socket, request));\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this._server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    this.log(`[> Connection] created: ${request.url}`);\n    const req = getRequestData(request.url);\n\n    for (const handler of this.handlers) {\n      const session = await handler.newSession(socket, req);\n      if (session) {\n        session.onConnect();\n        return;\n      }\n    }\n\n    socket.close();\n    this.log('[> Connection] closed due to no handler found');\n  }\n\n  log(...msg) {\n    const {logger} = this.options;\n    if (logger && logger.log) {\n      logger.log(...msg);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "class XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || handlers.length === 0) {\n      throw new Error('At least one handler must be provided');\n    }\n    this._server = new WebSocket.Server({ ...{ port: 8080 }, ...options });\n    this.handlers = handlers;\n    this.options = { ...{ port: 8080 }, ...options };\n    this._server.on('connection', (socket, request) => this.handleSession(socket, request));\n    if (callback) {\n      this._server.on('listening', callback);\n    }\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this._server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    let accepted = false;\n    for (const handler of this.handlers) {\n      if (handler.accept && handler.accept(socket, request)) {\n        accepted = true;\n        break;\n      }\n    }\n    if (!accepted) {\n      socket.close();\n      return;\n    }\n    socket.on('message', (data) => {\n      for (const handler of this.handlers) {\n        if (handler.onMessage) {\n          handler.onMessage(socket, data);\n        }\n      }\n    });\n    socket.on('close', () => {\n      for (const handler of this.handlers) {\n        if (handler.onClose) {\n          handler.onClose(socket);\n        }\n      }\n    });\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n}"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a WebSocket server class in Node.js that handles client connections, message processing, and subscription management for real-time communication.\n\nClass Description: The AphlictClientServer class implements a WebSocket server that manages client connections, processes incoming messages (including subscriptions, replays, and pings), and maintains listener lists for different instances. It's built on top of Node.js's HTTP server and ws WebSocket library.\n\nAttributes:\n- _server: [Object] - The underlying HTTP server instance\n- _lists: [Object] - Dictionary storing listener lists for different instances\n- _adminServers: [Array] - Array containing admin server references\n\nMethods:\n- constructor(server) -> [void] - Initializes the server instance and sets up request handling\n- _onrequest(request, response) -> [void] - Handles HTTP requests (returns 501 as this is a WebSocket server)\n- _parseInstanceFromPath(path) -> [String] - Extracts instance name from URL path\n- listen() -> [void] - Starts the WebSocket server and sets up connection handlers\n- getListenerList(instance) -> [Object] - Returns the listener list for a given instance (implied by usage)\n- log(message) -> [void] - Logs messages (implied by usage)\n- trace(message) -> [void] - Logs trace-level messages (implied by usage)\n- getHistory(min_age) -> [Array] - Returns historical messages (implied by usage in replay handler)\n\nThe class handles WebSocket connections with the following behaviors:\n1. Parses instance names from connection URLs\n2. Manages listener subscriptions/unsubscriptions\n3. Handles message replay requests\n4. Processes ping/pong messages\n5. Logs connection/disconnection events\n6. Maintains separate listener lists for different instances",
    "Canonical_solution": "var url = require('url');\nvar util = require('util');\nvar WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    server.on('request', this._onrequest.bind(this));\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end('HTTP/501 Use Websockets\\n');\n  }\n\n  _parseInstanceFromPath(path) {\n    if (path.indexOf('~') === -1) {\n      return 'default';\n    }\n\n    var instance = path.split('~')[1];\n    instance = instance.replace(/\\//g, '');\n    if (!instance.length) {\n      return 'default';\n    }\n\n    return instance;\n  }\n\n  listen() {\n    var self = this;\n    var server = this._server.listen.apply(this._server, arguments);\n    var wss = new WebSocket.Server({server: server});\n\n    wss.on('connection', function(ws, request) {\n      if ('upgradeReq' in ws) {\n        request = ws.upgradeReq;\n      }\n\n      var path = url.parse(request.url).pathname;\n      var instance = self._parseInstanceFromPath(path);\n\n      var listener = self.getListenerList(instance).addListener(ws);\n\n      function msg(argv) {\n        return util.format('<%s>', listener.getDescription()) +\n          ' ' +\n          util.format.apply(null, argv);\n      }\n\n      function log() {\n        self.log(msg(arguments));\n      }\n\n      function trace() {\n        self.trace(msg(arguments));\n      }\n\n      trace('Connected from %s.', ws._socket.remoteAddress);\n\n      ws.on('message', function(data) {\n        trace('Received message: %s', data);\n\n        var message;\n        try {\n          message = JSON.parse(data);\n        } catch (err) {\n          log('Message is invalid: %s', err.message);\n          return;\n        }\n\n        switch (message.command) {\n          case 'subscribe':\n            trace(\n              'Subscribed to: %s',\n              JSON.stringify(message.data));\n            listener.subscribe(message.data);\n            break;\n\n          case 'unsubscribe':\n            trace(\n              'Unsubscribed from: %s',\n              JSON.stringify(message.data));\n            listener.unsubscribe(message.data);\n            break;\n\n          case 'replay':\n            var age = message.data.age || 60000;\n            var min_age = (new Date().getTime() - age);\n\n            var old_messages = self.getHistory(min_age);\n            for (var ii = 0; ii < old_messages.length; ii++) {\n              var old_message = old_messages[ii];\n\n              if (!listener.isSubscribedToAny(old_message.subscribers)) {\n                continue;\n              }\n\n              try {\n                listener.writeMessage(old_message);\n              } catch (error) {\n                break;\n              }\n            }\n            break;\n\n          case 'ping':\n            var pong = {\n              type: 'pong'\n            };\n\n            try {\n              listener.writeMessage(pong);\n            } catch (error) {\n              // Ignore any issues here, we'll clean up elsewhere.\n            }\n            break;\n\n          default:\n            log(\n              'Unrecognized command \"%s\".',\n              message.command || '<undefined>');\n        }\n      });\n\n      ws.on('close', function() {\n        self.getListenerList(instance).removeListener(listener);\n        trace('Disconnected.');\n      });\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "class AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end();\n  }\n\n  _parseInstanceFromPath(path) {\n    const match = path.match(/\\/([^\\/?]+)/);\n    return match ? match[1] : null;\n  }\n\n  listen() {\n    this._server.on('upgrade', (request, socket, head) => {\n      const instance = this._parseInstanceFromPath(request.url);\n      if (!instance) {\n        socket.destroy();\n        return;\n      }\n      const ws = new WebSocket(request.url, {\n        server: this._server,\n        perMessageDeflate: false\n      });\n      ws.on('open', () => {\n        this.log(`Connection opened for instance: ${instance}`);\n      });\n      ws.on('message', (data) => {\n        const message = data.toString();\n        if (message.startsWith('subscribe')) {\n          const [_, topic] = message.split(' ');\n          if (!this._lists[instance]) {\n            this._lists[instance] = {};\n          }\n          if (!this._lists[instance][topic]) {\n            this._lists[instance][topic] = [];\n          }\n          this._lists[instance][topic].push(ws);\n          this.log(`Subscribed to topic ${topic} for instance ${instance}`);\n        } else if (message.startsWith('replay')) {\n          const [_, topic, min_age] = message.split(' ');\n          const history = this.getHistory(parseInt(min_age));\n          ws.send(JSON.stringify(history));\n        } else if (message === 'ping') {\n          ws.send('pong');\n        }\n      });\n      ws.on('close', () => {\n        this.log(`Connection closed for instance: ${instance}`);\n        for (const topic in this._lists[instance]) {\n          const index = this._lists[instance][topic].indexOf(ws);\n          if (index > -1) {\n            this._lists[instance][topic].splice(index, 1);\n          }\n        }\n      });\n      ws.on('error', (err) => {\n        this.trace(`WebSocket error: ${err.message}`);\n      });\n    });\n  }\n\n  getListenerList(instance) {\n    return this._lists[instance] || {};\n  }\n\n  log(message) {\n    console.log(`[AphlictClientServer] ${message}`);\n  }\n\n  trace(message) {\n    console.debug(`[AphlictClientServer TRACE] ${message}`);\n  }\n\n  getHistory(min_age) {\n    return [];\n  }\n}"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Create a class that implements HTTP client functionality using Axios for making HTTP requests with support for GET and POST methods, including proper header and parameter handling.\n\nClass Description: HTTPClient is a class that provides HTTP request capabilities using Axios as the underlying library. It handles request configuration, parameter serialization, content-type detection, and response processing.\n\nAttributes:\n- requestModule: [String] - Specifies the HTTP library being used (default: 'axios')\n\nMethods:\n- httpRequest: [async](options) -> [Object] - Makes an HTTP request based on provided options\n  - options: [Object] - Configuration object containing:\n    - method: [String] - HTTP method (GET/POST)\n    - url: [String] - Request URL\n    - headers: [Object] - Request headers\n    - params: [Object] - Query parameters\n    - body: [Object|String] - Request payload\n- queryStr: [function](options) -> [String] - Converts an object to URL-encoded query string\n  - options: [Object] - Key-value pairs to serialize\n- isJSONString: [function](str) -> [Boolean] - Checks if a string is valid JSON\n  - str: [String] - String to validate\n- isJson: [function](obj) -> [Boolean] - Checks if an object is a plain JSON object\n  - obj: [Any] - Object to validate",
    "Canonical_solution": "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n    constructor() {\n        this.requestModule = 'axios';\n    }\n\n    async httpRequest(options) {\n        let t = { ...options };\n        t.headers = t.headers || {};\n        if (t.params) {\n            t.url += '?' + this.queryStr(t.params);\n        }\n        t.method = t.method.toLowerCase();\n        if (t.method === 'get') {\n            delete t.headers['Content-Type'];\n            delete t.headers['Content-Length'];\n            delete t.headers['content-type'];\n            delete t.headers['content-length'];\n            delete t.body;\n        } else if (t.method === 'post') {\n            let ContentType;\n            if (!t.body) {\n                t.body = \"\";\n            } else if (typeof t.body === \"string\") {\n                ContentType = this.isJSONString(t.body) ? 'application/json' : 'application/x-www-form-urlencoded';\n            } else if (this.isJson(t.body)) {\n                t.body = JSON.stringify(t.body);\n                ContentType = 'application/json';\n            }\n            if (!t.headers['Content-Type'] && !t.headers['content-type']) {\n                t.headers['Content-Type'] = ContentType;\n            }\n        }\n        if (this.requestModule === \"axios\" && t.method === \"post\") {\n            t.data = t.body;\n            delete t.body;\n        }\n        let httpResult;\n        if (this.requestModule === \"axios\") {\n            httpResult = await axios(t);\n            httpResult.body = httpResult.data;\n        }\n        return httpResult;\n    }\n\n    queryStr(options) {\n        return Object.entries(options).map(([key, value]) => `${key}=${typeof value === 'object' ? JSON.stringify(value) : value}`).join('&');\n    }\n\n    isJSONString(str) {\n        try {\n            return JSON.parse(str) && typeof JSON.parse(str) === 'object';\n        } catch (e) {\n            return false;\n        }\n    }\n\n    isJson(obj) {\n        var isjson = typeof (obj) == \"object\" && Object.prototype.toString.call(obj).toLowerCase() == \"[object object]\" && !obj.length;\n        return isjson;\n    }\n}\n```",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class HTTPClient {\n  constructor() {\n    this.requestModule = 'axios';\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n\n    let config = {\n      method,\n      url,\n      headers: headers || {},\n      params: params || {}\n    };\n\n    if (method === 'POST' && body) {\n      if (this.isJson(body)) {\n        config.headers['Content-Type'] = 'application/json';\n        config.data = JSON.stringify(body);\n      } else if (typeof body === 'string') {\n        config.data = body;\n      } else {\n        config.data = this.queryStr(body);\n        config.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      }\n    }\n\n    try {\n      const response = await this.requestModule.request(config);\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return typeof obj === 'object' && obj !== null && !Array.isArray(obj) && !(obj instanceof Date);\n  }\n}"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript to handle real-time bidirectional communication between clients and the server.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io. It sets up event listeners for client connections, messages, and disconnections. The server broadcasts received messages to all connected clients.\n\nInput:\n- `port` (Number): The port number on which the WebSocket server will listen for incoming connections.\n\nOutput:\n- Returns the `socketServer` instance (Object) which can be used to further configure or interact with the WebSocket server.\n\nNote: The function internally uses the `http` module to create an HTTP server and binds socket.io to it for WebSocket communication. The server logs connection, message, and disconnection events to the console.",
    "Canonical_solution": "const http = require(\"http\");\nconst socketIo = require(\"socket.io\");\n\nfunction setupWebSocketServer(port) {\n    const app = express();\n    const webServer = http.createServer(app);\n    const socketServer = socketIo(webServer, {\"log level\": 1});\n\n    socketServer.on(\"connection\", (socket) => {\n        console.log(\"New client connected\");\n\n        socket.on(\"message\", (data) => {\n            console.log(\"Message received: \", data);\n            socketServer.emit(\"message\", data);\n        });\n\n        socket.on(\"disconnect\", () => {\n            console.log(\"Client disconnected\");\n        });\n    });\n\n    webServer.listen(port, () => {\n        console.log(\"WebSocket server listening on port: \" + port);\n    });\n\n    return socketServer;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "wrong_result": "const http = require('http');\nconst { Server } = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const httpServer = http.createServer();\n  const socketServer = new Server(httpServer, {\n    cors: {\n      origin: '*',\n      methods: ['GET', 'POST']\n    }\n  });\n\n  socketServer.on('connection', (socket) => {\n    console.log('A client connected:', socket.id);\n\n    socket.on('message', (data) => {\n      console.log('Received message:', data);\n      socketServer.emit('message', data);\n    });\n\n    socket.on('disconnect', () => {\n      console.log('A client disconnected:', socket.id);\n    });\n  });\n\n  httpServer.listen(port, () => {\n    console.log(`WebSocket server is running on port ${port}`);\n  });\n\n  return socketServer;\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript that handles real-time communication between clients and integrates with an Express application and Deployd backend.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io, integrates it with an Express application, and attaches a Deployd backend. It sets up event listeners for server operations and handles custom Express routes.\n\nInput: None (The function uses environment variables for configuration: `process.env.NODE_ENV` for environment setting and `process.env.PORT` for port number)\n\nOutput: None (The function starts a server that listens on the specified port and logs server status to the console)\n\nNote: The function internally uses:\n- Express for HTTP server functionality\n- Socket.io for WebSocket communication\n- Deployd for backend services\n- MongoDB (configured to connect to localhost:27017 with database name 'test-app')",
    "Canonical_solution": "function setupWebSocketServer() {\n    var express = require('express');\n    var app = express();\n    var server = require('http').createServer(app);\n    var io = require('socket.io').listen(server, {'log level': 0});\n\n    require('deployd').attach(server, {\n        socketIo: io,\n        env: process.env.NODE_ENV || 'development',\n        db: {host:'localhost', port:27017, name:'test-app'}\n    });\n    app.use(server.handleRequest);\n\n    app.get('/express-custom-handler', function(req, res) {\n        res.send('Ok');\n    });\n\n    server.listen(process.env.PORT || 2403, function() {\n        console.log({ ENV: process.env.NODE_ENV || 'development', PORT: process.env.PORT || 2403 });\n    });\n    server.on('error', function(err) {\n        console.log(err.stack);\n        process.nextTick(function() {\n            process.exit();\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "wrong_result": "const express = require('express');\nconst http = require('http');\nconst socketIO = require('socket.io');\nconst deployd = require('deployd');\n\nfunction setupWebSocketServer() {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIO(server);\n\n  const dpd = deployd({\n    env: process.env.NODE_ENV || 'development',\n    port: process.env.PORT || 2468,\n    db: {\n      type: 'memory'\n    }\n  });\n\n  dpd.listen();\n\n  app.use(dpd.app);\n\n  io.on('connection', (socket) => {\n    console.log('A client connected');\n\n    socket.on('message', (data) => {\n      console.log('Received message:', data);\n      io.emit('response', `Server received: ${data}`);\n    });\n\n    socket.on('disconnect', () => {\n      console.log('A client disconnected');\n    });\n  });\n\n  server.listen(process.env.PORT || 3000, () => {\n    console.log(`Server is running on port ${process.env.PORT || 3000}`);\n  });\n}"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Write a function that scrapes TV channel information from a webpage, processes the data, and returns a list of channel objects with their details.\n\nFunction Description: The function `getChannels` asynchronously fetches HTML content from a URL, parses it to extract TV channel information, and returns an array of channel objects. Each channel object contains language, site ID, and name. The function uses Axios for HTTP requests and Cheerio for HTML parsing.\n\nInput: None (The function uses an implicit `this.url()` method to generate the target URL)\n\nOutput: Array<Object> - Returns an array of channel objects with the following structure:\n[\n  {\n    lang: string,      // Language code of the channel (e.g., 'tr')\n    site_id: string,   // Unique identifier for the channel\n    name: string       // Name of the channel\n  },\n  ...\n]",
    "Canonical_solution": "async function getChannels() {\n    const channels = {};\n    const axios = require('axios');\n    const data = await axios\n        .get(this.url({ date: dayjs() }))\n        .then(r => r.data)\n        .catch(console.error);\n\n    const $ = cheerio.load(data);\n    $('.channelContent').toArray()\n        .forEach(el => {\n            const item = $(el);\n            const channelId = item.find('.channelDetail .tvGuideResult-box-wholeDates-title')\n                .first()\n                .attr('onclick');\n            if (channelId) {\n                const site_id = channelId.match(/\\s(\\d+)\\)/)[1];\n                if (channels[site_id] === undefined) {\n                    channels[site_id] = {\n                        lang: 'tr',\n                        site_id,\n                        name: item.find('#channelID').val()\n                    };\n                }\n            }\n        });\n\n    return Object.values(channels);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function getChannels() {\n  const axios = require('axios');\n  const cheerio = require('cheerio');\n  const html = await axios.get(this.url());\n  const $ = cheerio.load(html.data);\n  const channels = [];\n  $('div.channel').each((i, elem) => {\n    const lang = $(elem).find('span.lang').text().trim();\n    const siteId = $(elem).find('span.site-id').text().trim();\n    const name = $(elem).find('h3.name').text().trim();\n    channels.push({ lang, site_id: siteId, name });\n  });\n  return channels;\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a function to send telemetry data to a remote endpoint after a software installation, while respecting user preferences for telemetry collection.\n\nFunction Description: The function `installTelemetry` sends a POST request to a specified telemetry endpoint with installation-related data (Node.js version and platform). It checks an environment variable to determine if telemetry collection is enabled before sending any data. The function handles both success and error cases silently.\n\nInput: None (uses environment variable `TUNNELMOLE_TELEMETRY` and Node.js process information)\n\nOutput: None (the function doesn't return any value, it only performs a side effect of sending telemetry data)",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function installTelemetry() {\n  const telemetryEndpoint = `https://service.tunnelmole.com/tunnelmole-log-telemetry`;\n\n  if (process.env.TUNNELMOLE_TELEMETRY === \"0\") {\n    return;\n  }\n\n  axios\n    .post(telemetryEndpoint, {\n      type: \"post-install\",\n      data: {\n        nodeVersion: process.version ? process.version : \"Unknown\",\n        platform: process.platform ? process.platform : \"Unknown\"\n      }\n    }).then(function () {\n      // Ignore the response\n    }).catch(function () {\n      // Ignore the error\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst https = require('https');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === '1';\n  if (!telemetryEnabled) return;\n\n  const data = JSON.stringify({\n    nodeVersion: process.versions.node,\n    platform: process.platform,\n    arch: process.arch\n  });\n\n  const options = {\n    hostname: 'telemetry.example.com',\n    port: 443,\n    path: '/api/v1/telemetry',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': data.length\n    }\n  };\n\n  const req = https.request(options, () => {\n    // Silent success handling\n  });\n\n  req.on('error', () => {\n    // Silent error handling\n  });\n\n  req.write(data);\n  req.end();\n}\n```"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a SauceLabs API client class in JavaScript that handles HTTP requests to the SauceLabs REST API, including authentication and basic GET/POST operations.\n\nClass Description: The SauceLabsClient class provides methods to interact with the SauceLabs REST API. It handles authentication and provides simplified methods for making GET and POST requests to the API endpoints.\n\nAttributes:\n- auth: [Object] - An object containing user authentication credentials (username and access token)\n\nMethods:\n- setAuth: [setAuth](saucelabsUsername: String, saucelabsToken: String) -> Void - Sets the authentication credentials for API requests\n- get: [get](path: String, callback: Function) -> Void - Makes a GET request to the specified API path and handles the response through a callback\n- post: [post](path: String, data: Object, callback: Function) -> Void - Makes a POST request to the specified API path with provided data and handles the response through a callback",
    "Canonical_solution": "var request = require('request');\n\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {\n      user: null,\n      password: null\n    };\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.user = saucelabsUsername;\n    this.auth.password = saucelabsToken;\n  }\n\n  get(path, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + path,\n      auth: this.auth\n    };\n    request.get(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        console.log(params);\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(JSON.parse(body));\n    });\n  }\n\n  post(path, data, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + this.auth.user + '/' + path,\n      auth: { user: this.auth.user, password: this.auth.password },\n      json: data\n    };\n    request.post(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(body);\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class SauceLabsClient {\n  constructor() {\n    this.auth = {};\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth = {\n      username: saucelabsUsername,\n      accessKey: saucelabsToken\n    };\n  }\n\n  get(path, callback) {\n    const options = {\n      method: 'GET',\n      headers: {\n        'Authorization': 'Basic ' + Buffer.from(`${this.auth.username}:${this.auth.accessKey}`).toString('base64')\n      }\n    };\n\n    fetch(`https://api.saucelabs.com${path}`, options)\n      .then(response => response.json())\n      .then(data => callback(null, data))\n      .catch(error => callback(error, null));\n  }\n\n  post(path, data, callback) {\n    const options = {\n      method: 'POST',\n      headers: {\n        'Authorization': 'Basic ' + Buffer.from(`${this.auth.username}:${this.auth.accessKey}`).toString('base64'),\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    };\n\n    fetch(`https://api.saucelabs.com${path}`, options)\n      .then(response => response.json())\n      .then(data => callback(null, data))\n      .catch(error => callback(error, null));\n  }\n}"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using an HTTP POST request and triggers a callback function upon completion or failure.\n\nFunction Description: The function uses Axios to send an HTTP POST request to a specified webhook URL with event and data payload. It triggers a callback function (triggerActivity) when the request succeeds or fails. The request includes custom headers for identification.\n\nInput:\n- url: [String] - The webhook URL to which the POST request will be sent\n- event: [String/Object] - The event information to be sent in the request payload\n- data: [Object] - The data payload to be sent in the request\n- triggerActivity: [Function] - Callback function to be triggered after request completion (takes an optional error parameter)\n\nOutput: [None] - The function doesn't return anything but triggers the callback function",
    "Canonical_solution": "const axios = require(\"axios\");\n\nfunction postWebhook(url, event, data, triggerActivity) {\n    axios.post(url, {event, data}, {headers: {\"user-agent\": \"MySpeed/WebhookAgent\"}})\n        .then(() => triggerActivity())\n        .catch(() => triggerActivity(true));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "axios.post(url, { event, data }, { headers: { 'X-Request-ID': 'unique-id' } })\n  .then(() => triggerActivity())\n  .catch((error) => triggerActivity(error));"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Write a function that retrieves TV channel information from multiple regions, processes the data, and returns a unique list of channels based on their site IDs.\n\nFunction Description: The function `channels` makes HTTP GET requests to a TV channel API for multiple regions, collects channel data from all available pages for each region, and returns a deduplicated list of channels. It uses axios for HTTP requests and lodash for data processing.\n\nInput: None (The function uses hardcoded region IDs internally)\n\nOutput: An array of objects representing unique TV channels, where each object contains:\n- lang: string - Language code ('ru' for Russian)\n- name: string - Name of the TV channel\n- site_id: string/number - Unique identifier for the channel on the site\n\nThe output is deduplicated based on the site_id field using lodash's uniqBy function.",
    "Canonical_solution": "async function channels() {\n    const _ = require('lodash')\n    const axios = require('axios')\n\n    const regions = [5506, 1096, 1125, 285]\n    let channels = []\n    for (let region of regions) {\n        const totalPages = await getTotalPageCount(region)\n        const pages = Array.from(Array(totalPages).keys())\n        for (let page of pages) {\n            const data = await axios\n                .get('https://tv.mail.ru/ajax/channel/list/', {\n                    params: { page },\n                    headers: {\n                        cookie: `s=fver=0|geo=${region};`\n                    }\n                })\n                .then(r => r.data)\n                .catch(console.log)\n\n            data.channels.forEach(item => {\n                channels.push({\n                    lang: 'ru',\n                    name: item.name,\n                    site_id: item.id\n                })\n            })\n        }\n    }\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "axios.get('https://api.example.com/channels?region=1').then(response => response.data),\naxios.get('https://api.example.com/channels?region=2').then(response => response.data),\naxios.get('https://api.example.com/channels?region=3').then(response => response.data)\n]).then(responses => {\n  const allChannels = responses.flat();\n  return _.uniqBy(allChannels, 'site_id');\n});"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Create a class that interacts with a bundle size tracking API to get and set file size values for a repository.\n\nClass Description: The BundleSizeAPI class provides methods to retrieve and store file size information from a remote API. It handles authentication, repository name sanitization, and error logging.\n\nAttributes:\n- repo: [String] - The repository name (e.g., \"owner/repo\")\n- token: [String] - Authentication token for API access\n- sha: [String] - Commit SHA associated with the bundle sizes\n- ci: [Any] - CI environment information (usage not shown in reference)\n- url: [String] - Base URL for the bundle size API (\"https://bundlesize-store.now.sh/values\")\n- enabled: [Boolean] - Flag indicating if API operations are enabled (true when repo and token are provided)\n\nMethods:\n- get: [get]() -> [Promise<Object>] - Retrieves file size values from the API. Returns a promise that resolves to an object mapping file paths to their sizes. Automatically sanitizes repository name by replacing dots with underscores.\n- set: [set](values: Object) -> [void] - Posts file size values to the API. Takes an object mapping file paths to sizes. Only operates when repo and token are available. Sanitizes repository name and includes commit SHA in the payload. Errors are logged to console.\n\nNote: Both methods handle errors by logging them to the console and continue execution (errors don't propagate). The class is designed to be fail-safe when API credentials aren't provided.",
    "Canonical_solution": "const axios = require('axios');\n\nclass BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = (this.repo && this.token) ? true : false;\n  }\n\n  get() {\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    return axios\n      .get(`${this.url}?repo=${sanitizedRepo}&token=${this.token}`)\n      .then(response => {\n        const values = {};\n        if (response && response.data && response.data.length) {\n          response.data.map(file => (values[file.path] = file.size));\n        }\n        return values;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  }\n\n  set(values) {\n    if (this.repo && this.token) {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      axios\n        .post(this.url, { repo: sanitizedRepo, token: this.token, sha: this.sha, values })\n        .catch(error => console.log(error));\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = \"https://bundlesize-store.now.sh/values\";\n    this.enabled = Boolean(repo && token);\n  }\n\n  sanitizeRepo(repo) {\n    return repo.replace(/\\./g, \"_\");\n  }\n\n  async get() {\n    if (!this.enabled) {\n      console.log(\"BundleSizeAPI is not enabled. Missing repo or token.\");\n      return {};\n    }\n\n    const sanitizedRepo = this.sanitizeRepo(this.repo);\n    const response = await fetch(`${this.url}/${sanitizedRepo}`);\n    if (!response.ok) {\n      console.error(`Failed to retrieve bundle sizes for ${sanitizedRepo}:`, response.statusText);\n      return {};\n    }\n\n    try {\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.error(\"Failed to parse bundle size response:\", error);\n      return {};\n    }\n  }\n\n  set(values) {\n    if (!this.enabled) {\n      console.log(\"BundleSizeAPI is not enabled. Missing repo or token.\");\n      return;\n    }\n\n    const sanitizedRepo = this.sanitizeRepo(this.repo);\n    const payload = {\n      ...values,\n      sha: this.sha\n    };\n\n    fetch(`${this.url}/${sanitizedRepo}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": `token ${this.token}`\n      },\n      body: JSON.stringify(payload)\n    }).catch(error => {\n      console.error(\"Failed to set bundle sizes:\", error);\n    });\n  }\n}"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a function that fetches COVID-19 related data from the Israeli government's health dashboard API using HTTP POST request and processes the response.\n\nFunction Description: The function makes a batch request to the Israeli health ministry's API endpoint to retrieve multiple COVID-19 related datasets including updates, patient statistics, test results, and demographic breakdowns. It handles the HTTP communication, error cases, and returns the parsed data or null if the request fails.\n\nInput: None (The function takes no parameters as all request configuration is internally defined)\n\nOutput: \n- On success: Returns parsed data from the API response (type depends on parseData implementation)\n- On failure: Returns null and logs the error",
    "Canonical_solution": "function israelData() {\n    const axios = require('axios');\n    const logger = require('../../../utils/logger');\n    const params = {\n        requests: [\n            { queryName: 'lastUpdate', single: true },\n            { queryName: 'patientsPerDate' },\n            { queryName: 'deadPatientsPerDate' },\n            { queryName: 'recoveredPerDay' },\n            { queryName: 'testResultsPerDate' },\n            { queryName: 'infectedByPeriodAndAgeAndGender' },\n            { queryName: 'deadByPeriodAndAgeAndGender' },\n            { queryName: 'breatheByPeriodAndAgeAndGender' },\n            { queryName: 'severeByPeriodAndAgeAndGender' },\n            { queryName: 'spotlightPublic' },\n            { queryName: 'spotlightLastupdate' }\n        ]\n    };\n    return axios.post('https://datadashboardapi.health.gov.il/api/queries/_batch', params, {\n        headers: { 'Content-Type': 'application/json' }\n    }).then(data => {\n        return parseData(data.data);\n    }).catch(err => {\n        logger.err('Error: Requesting Israel Gov Data failed!', err);\n        return null;\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "function fetchCovidData() {\n    const url = 'https://www.health.gov.il/Services-Tools/COVID-19/APIs';\n    const data = {\n        \"requests\": [\n            \"get_updates\",\n            \"get_patient_statistics\",\n            \"get_test_results\",\n            \"get_demographic_breakdown\"\n        ]\n    };\n\n    return fetch(url, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(data)\n    })\n    .then(response => {\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n    })\n    .then(parsedData => {\n        return parseData(parsedData);\n    })\n    .catch(error => {\n        console.error('Error fetching COVID-19 data:', error);\n        return null;\n    });\n}\n\nfunction parseData(data) {\n    // Implement parsing logic based on actual API response structure\n    return data;\n}"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with optional path extension and error data, then triggers an activity callback based on the request's success or failure.\n\nFunction Description: The function `sendPing` is an asynchronous function that constructs a target URL by combining a base URL and an optional path, then sends an HTTP POST request using Axios. The request includes error data in the payload and a custom user-agent header. Depending on the request's outcome, it triggers a callback function (`triggerActivity`) with a success or failure indicator.\n\nInput:  \n- `url`: [String] - The base URL to which the request will be sent.  \n- `path`: [String] (optional) - An additional path segment to append to the base URL.  \n- `error`: [Any] - Data to be sent as the request payload (typically error information).  \n- `triggerActivity`: [Function] - A callback function to be executed after the request completes, receiving a boolean parameter indicating failure (true) or success (false/undefined).  \n\nOutput:  \n- None (The function's primary effect is the HTTP request and callback execution, not a direct return value).",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function sendPing(url, path, error, triggerActivity) {\n    if (url == null) return;\n    if (path) url += \"/\" + path;\n\n    await axios.post(url, error, {headers: {\"user-agent\": \"MySpeed/HealthAgent\"}})\n        .then(() => triggerActivity())\n        .catch(() => triggerActivity(true));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function sendPing(url, path, error, triggerActivity) {\n  const targetUrl = path ? `${url}/${path}` : url;\n  try {\n    await axios.post(targetUrl, error, {\n      headers: {\n        'User-Agent': 'CustomUserAgent'\n      }\n    });\n    triggerActivity(false);\n  } catch (err) {\n    triggerActivity(true);\n  }\n}\n```"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a function to send emails using different email service providers (Mailgun and Sendgrid) through HTTP requests, with error handling and promise-based asynchronous operation.\n\nFunction Description: The function `sendMail` sends an email using a configured transporter (either Mailgun or Sendgrid). It wraps the transporter's send operation in a Promise for better async handling. The transporter is configured to make HTTP requests to the respective email service API.\n\nInput:\n- `to`: [String] - Recipient email address\n- `subject`: [String] - Email subject\n- `text`: [String] - Email body content\n- `options`: [Object] (optional) - Additional email options (defaults to empty object)\n\nOutput:\n- [Promise] - Resolves with email sending success info, or rejects with an error if sending fails.\n\n---\n\nClass Description: (Not applicable, as the reference code is at the function level)",
    "Canonical_solution": "function sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    transporter.sendMail({\n      from: `\"${ config.plugins.email.name || '' }\" <${ config.plugins.email.email || config.plugins.email.username }>`,\n      to,\n      subject,\n      text,\n    }, (error, info) => {\n      if(error) {\n        return reject(error);\n      }\n      return resolve(info);\n    });\n  });\n}\n\n// External libraries and global variables used:\nconst axios = require('axios');\nconst FormData = require('form-data');\nconst config = appRequire('services/config').all();\nlet transporter;\n\n// Mailgun implementation\ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  const form = new FormData();\n  form.append('from', options.from);\n  form.append('to', options.to);\n  form.append('subject', options.subject);\n  form.append('text', options.text);\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: form.getHeaders(),\n    data: form,\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};\n\n// Sendgrid implementation  \ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${ emailConfig.apiKey }`,\n    },\n    data: {\n      personalizations: [{\n        to: [{ email: options.to }]\n      }],\n      from: { email: options.from },\n      subject: options.subject,\n      content: [{\n        type: 'text/plain',\n        value: options.text,\n      }]\n    },\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "function sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    const transporter = process.env.EMAIL_SERVICE === 'mailgun' ? require('./mailgunTransporter') : require('./sendgridTransporter');\n    const mailOptions = {\n      to,\n      subject,\n      text,\n      ...options\n    };\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n}"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create an asynchronous function that fetches TV channel data from a specified API endpoint and processes it into a standardized format.\n\nFunction Description: The function makes an HTTP GET request to retrieve TV channel information from a remote API. It processes the response to extract relevant channel details (language, site ID, and name) and returns them in a structured array format. The function includes error handling to log any request failures.\n\nInput: None (The function uses a hardcoded API URL and parameters)\n\nOutput: An array of objects where each object represents a TV channel with the following properties:\n- lang: String - The language code for the channel (hardcoded as 'sq' in this case)\n- site_id: String - The unique identifier for the channel from the API\n- name: String - The display name of the channel",
    "Canonical_solution": "async function channels() {\n    const axios = require('axios')\n    const data = await axios\n        .get('https://www.tvim.tv/script/epg/category_channels?category=all&filter=playable')\n        .then(r => r.data)\n        .catch(console.log)\n\n    let channels = []\n    data.data.forEach(item => {\n        channels.push({\n            lang: 'sq',\n            site_id: item.epg_id,\n            name: item.name\n        })\n    })\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function fetchTVChannels() {\n  const url = 'https://api.example.com/tv-channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    const data = await response.json();\n    return data.map(channel => ({\n      lang: 'sq',\n      site_id: channel.id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Failed to fetch TV channels:', error);\n    return [];\n  }\n}"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Create a function that retrieves TV channel information from multiple providers and returns a list of unique channels.\n\nFunction Description: The function makes HTTP POST requests to a TV guide service for each provider, extracts channel information from the HTML response, and returns a deduplicated list of channels. It uses axios for HTTP requests, cheerio for HTML parsing, and lodash for deduplication.\n\nInput: None (The function uses hardcoded providers and parameters)\n\nOutput: Array of objects - Returns an array of channel objects containing language, name, and site_id (deduplicated by site_id). Each channel object has the following structure:\n{\n    lang: string,    // Language code ('fr' for French)\n    name: string,    // Channel name\n    site_id: string  // Unique identifier combining channel number and slug\n}",
    "Canonical_solution": "function async channels() {\n    const axios = require('axios')\n    const _ = require('lodash')\n\n    const providers = ['-1', '-2', '-3', '-4', '-5']\n\n    const channels = []\n    for (let provider of providers) {\n        const data = await axios\n            .post('https://www.tvcesoir.fr/guide/schedule', null, {\n                params: {\n                    provider,\n                    region: 'France',\n                    TVperiod: 'Night',\n                    date: dayjs().format('YYYY-MM-DD'),\n                    st: 0,\n                    u_time: 2155,\n                    is_mobile: 1\n                }\n            })\n            .then(r => r.data)\n            .catch(console.log)\n\n        const $ = cheerio.load(data)\n        $('.channelname').each((i, el) => {\n            const name = $(el).find('center > a:eq(1)').text()\n            const url = $(el).find('center > a:eq(1)').attr('href')\n            const [, number, slug] = url.match(/\\/(\\d+)\\/(.*)\\.html$/)\n\n            channels.push({\n                lang: 'fr',\n                name,\n                site_id: `${number}/${slug}`\n            })\n        })\n    }\n\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "axios.post('https://provider1.com/api/channels', { param: 'value' }).then(res => {\n    const $ = cheerio.load(res.data);\n    const channels = [];\n    $('.channel').each((i, el) => {\n        const lang = $(el).find('.lang').text();\n        const name = $(el).find('.name').text();\n        const number = $(el).find('.number').text();\n        const slug = $(el).find('.slug').text();\n        channels.push({ lang, name, site_id: `${number}-${slug}` });\n    });\n    return channels;\n}).catch(err => console.error(err));\n\naxios.post('https://provider2.com/api/channels', { param: 'value' }).then(res => {\n    const $ = cheerio.load(res.data);\n    const channels = [];\n    $('.channel').each((i, el) => {\n        const lang = $(el).find('.lang').text();\n        const name = $(el).find('.name').text();\n        const number = $(el).find('.number').text();\n        const slug = $(el).find('.slug').text();\n        channels.push({ lang, name, site_id: `${number}-${slug}` });\n    });\n    return channels;\n}).catch(err => console.error(err));\n\naxios.post('https://provider3.com/api/channels', { param: 'value' }).then(res => {\n    const $ = cheerio.load(res.data);\n    const channels = [];\n    $('.channel').each((i, el) => {\n        const lang = $(el).find('.lang').text();\n        const name = $(el).find('.name').text();\n        const number = $(el).find('.number').text();\n        const slug = $(el).find('.slug').text();\n        channels.push({ lang, name, site_id: `${number}-${slug}` });\n    });\n    return channels;\n}).catch(err => console.error(err));\n\nPromise.all([axios.post('https://provider1.com/api/channels', { param: 'value' }), axios.post('https://provider2.com/api/channels', { param: 'value' }), axios.post('https://provider3.com/api/channels', { param: 'value' })])\n    .then(responses => {\n        const allChannels = responses.flatMap(res => {\n            const $ = cheerio.load(res.data);\n            const channels = [];\n            $('.channel').each((i, el) => {\n                const lang = $(el).find('.lang').text();\n                const name = $(el).find('.name').text();\n                const number = $(el).find('.number').text();\n                const slug = $(el).find('.slug').text();\n                channels.push({ lang, name, site_id: `${number}-${slug}` });\n            });\n            return channels;\n        });\n        const uniqueChannels = _.uniqBy(allChannels, 'site_id');\n        console.log(uniqueChannels);\n    })\n    .catch(err => console.error(err));"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a function to download a video file from a given URL and save it with a specified description as the filename.\n\nFunction Description: The function `downloadVideo` initiates an asynchronous HTTP GET request to download a video file from the provided URL. It handles the response as a binary blob, creates a downloadable link, and triggers the download automatically. The function includes error handling for empty URLs and checks for successful request completion.\n\nInput:\n- `url` (String): The URL of the video file to be downloaded.\n- `desc` (String): The description to be used as the filename for the downloaded video.\n\nOutput: None (The function triggers a file download but does not return any value.)",
    "Canonical_solution": "function downloadVideo(url, desc) {\n    if (isEmpty(url)) {\n        layer.msg('\u6682\u65e0\u6570\u636e');\n        return;\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'blob';\n    xhr.setRequestHeader(\"Access-Control-Allow-Origin\", \"*\");\n    xhr.setRequestHeader(\"Access-Control-Allow-Credentials\", true);\n    xhr.onload = function () {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            let blob = this.response;\n            let u = window.URL.createObjectURL(new Blob([blob]));\n            let a = document.createElement('a');\n            a.download = desc + '.mp4';\n            a.href = u;\n            a.style.display = 'none';\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "async function downloadVideo(url, desc) {\n  if (!url || !desc) {\n    console.error(\"URL and description are required.\");\n    return;\n  }\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const blob = await response.blob();\n    const link = document.createElement('a');\n    link.href = URL.createObjectURL(blob);\n    link.download = `${desc}.mp4`;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  } catch (error) {\n    console.error(\"Error downloading video:\", error);\n  }\n}"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a cross-platform HTTP client tool that works in Node.js, Surge, and Quantumult X environments, providing consistent methods for making HTTP requests and handling responses across these platforms.\n\nClass Description: The `Tool` class is a utility class designed to abstract HTTP client functionality across different JavaScript environments (Node.js, Surge, and Quantumult X). It provides methods for making HTTP requests (GET/POST), persistent storage, and notifications while automatically detecting the runtime environment.\n\nAttributes:\n- _node: [Object|null] - Contains Node.js specific modules if running in Node.js environment\n- _isSurge: [Boolean] - Indicates if running in Surge environment\n- _isQuanX: [Boolean] - Indicates if running in Quantumult X environment\n- isSurge: [Boolean] - Public alias for _isSurge\n- isQuanX: [Boolean] - Public alias for _isQuanX\n- isResponse: [Boolean] - Indicates if $response is available\n\nMethods:\n- constructor() -> [void] - Initializes the tool and detects the runtime environment\n- notify(title: String, subtitle: String, message: String, option: Object) -> [void] - Sends a notification in the current environment\n- write(value: String, key: String) -> [Boolean] - Writes a value to persistent storage\n- read(key: String) -> [String] - Reads a value from persistent storage\n- get(options: Object|String, callback: Function) -> [void] - Makes a GET HTTP request\n- post(options: Object|String, callback: Function) -> [void] - Makes a POST HTTP request\n- _status(response: Object) -> [Object] - Internal method to normalize response status codes",
    "Canonical_solution": "const request = require('request');\n\nclass Tool {\n    constructor() {\n        this._node = (() => {\n            if (typeof require == \"function\") {\n                const request = require('request')\n                return ({ request })\n            } else {\n                return (null)\n            }\n        })()\n        this._isSurge = typeof $httpClient != \"undefined\"\n        this._isQuanX = typeof $task != \"undefined\"\n        this.isSurge = this._isSurge\n        this.isQuanX = this._isQuanX\n        this.isResponse = typeof $response != \"undefined\"\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) $notify(title, subtitle, message, option)\n        if (this._isSurge) $notification.post(title, subtitle, message, option[\"open-url\"])\n        if (this._node) console.log(JSON.stringify({ title, subtitle, message }));\n    }\n\n    write(value, key) {\n        if (this._isQuanX) return $prefs.setValueForKey(value, key)\n        if (this._isSurge) return $persistentStore.write(value, key)\n    }\n\n    read(key) {\n        if (this._isQuanX) return $prefs.valueForKey(key)\n        if (this._isSurge) return $persistentStore.read(key)\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"GET\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.get(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"POST\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    _status(response) {\n        if (response) {\n            if (response.status) {\n                response[\"statusCode\"] = response.status\n            } else if (response.statusCode) {\n                response[\"status\"] = response.statusCode\n            }\n        }\n        return response\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass Tool {\n  constructor() {\n    this._node = null;\n    this._isSurge = typeof $httpClient !== 'undefined';\n    this._isQuanX = typeof $task !== 'undefined';\n    this.isSurge = this._isSurge;\n    this.isQuanX = this._isQuanX;\n    this.isResponse = typeof $response !== 'undefined';\n    if (typeof require !== 'undefined') {\n      this._node = {\n        fs: require('fs'),\n        path: require('path'),\n        http: require('http'),\n        https: require('https')\n      };\n    }\n  }\n  notify(title, subtitle, message, option) {\n    if (this._isSurge) {\n      $notification.post(title, subtitle, message, option);\n    } else if (this._isQuanX) {\n      $notify(title, subtitle, message, option);\n    }\n  }\n  write(value, key) {\n    if (this._isSurge) {\n      $persistentWrite(value, key);\n      return true;\n    } else if (this._isQuanX) {\n      $prefs.setValueForKey(value, key);\n      return true;\n    }\n    return false;\n  }\n  read(key) {\n    if (this._isSurge) {\n      return $persistentRead(key);\n    } else if (this._isQuanX) {\n      return $prefs.valueForKey(key);\n    }\n    return null;\n  }\n  get(options, callback) {\n    if (this._isSurge) {\n      $httpClient.get(options, (error, response, data) => {\n        callback(error, this._status(response), data);\n      });\n    } else if (this._isQuanX) {\n      $task.fetch(options).then(response => {\n        callback(null, this._status(response), response.body);\n      }, reason => {\n        callback(reason, null, null);\n      });\n    } else if (this._node) {\n      const url = new URL(options.url || options);\n      const protocol = url.protocol === 'https:' ? this._node.https : this._node.http;\n      const req = protocol.request({\n        hostname: url.hostname,\n        port: url.port,\n        path: url.pathname + url.search,\n        method: 'GET',\n        headers: options.headers || {}\n      }, res => {\n        let data = '';\n        res.on('data', chunk => {\n          data += chunk;\n        });\n        res.on('end', () => {\n          callback(null, this._status(res), data);\n        });\n      });\n      req.on('error', error => {\n        callback(error, null, null);\n      });\n      req.end();\n    }\n  }\n  post(options, callback) {\n    if (this._isSurge) {\n      $httpClient.post(options, (error, response, data) => {\n        callback(error, this._status(response), data);\n      });\n    } else if (this._isQuanX) {\n      $task.fetch(Object.assign({}, options, { method: 'POST' })).then(response => {\n        callback(null, this._status(response), response.body);\n      }, reason => {\n        callback(reason, null, null);\n      });\n    } else if (this._node) {\n      const url = new URL(options.url || options);\n      const protocol = url.protocol === 'https:' ? this._node.https : this._node.http;\n      const req = protocol.request({\n        hostname: url.hostname,\n        port: url.port,\n        path: url.pathname + url.search,\n        method: 'POST',\n        headers: Object.assign({\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }, options.headers || {})\n      }, res => {\n        let data = '';\n        res.on('data', chunk => {\n          data += chunk;\n        });\n        res.on('end', () => {\n          callback(null, this._status(res), data);\n        });\n      });\n      req.on('error', error => {\n        callback(error, null, null);\n      });\n      req.write(options.body || '');\n      req.end();\n    }\n  }\n  _status(response) {\n    if (this._isSurge) {\n      return {\n        statusCode: response.statusCode,\n        statusMessage: response.statusMessage,\n        headers: response.headers\n      };\n    } else if (this._isQuanX) {\n      return {\n        statusCode: response.statusCode,\n        statusMessage: response.statusMessage,\n        headers: response.headers\n      };\n    } else if (this._node) {\n      return {\n        statusCode: response.statusCode,\n        statusMessage: response.statusMessage,\n        headers: response.headers\n      };\n    }\n    return {};\n  }\n}\n```"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a class that simulates the behavior of an EventSource object, which is used to receive server-sent events (SSE) over HTTP. The class should handle the connection, reception of events, and error handling.\n\nClass Description: The `EventSource` class is designed to establish a persistent connection to a server using HTTP and receive server-sent events. It manages the connection state, handles incoming events, and dispatches them to appropriate event handlers. The class also supports reconnection in case of errors or connection loss.\n\nAttributes:\n\n- `URL`: [String] - The URL to which the EventSource connects to receive server-sent events.\n- `readyState`: [Number] - Represents the current state of the connection. Possible values are `CONNECTING` (0), `OPEN` (1), and `CLOSED` (2).\n- `_pollTimer`: [Object] - A timer object used to manage the polling interval for reconnection attempts.\n- `_xhr`: [Object] - The XMLHttpRequest object used to make HTTP requests to the server.\n\nMethods:\n\n- `poll()`: [Function] -> [Void] - Initiates a new HTTP request to the server to receive events. Handles the response, processes the events, and manages the connection state.\n- `close()`: [Function]() -> [Void] - Closes the connection to the server, sets the `readyState` to `CLOSED`, and stops any ongoing polling.\n- `dispatchEvent(type, event)`: [Function]([String], [Object]) -> [Void] - Dispatches an event to the registered event handlers based on the event type.\n- `addEventListener(type, handler)`: [Function]([String], [Function]) -> [Void] - Registers an event handler for a specific event type.\n- `removeEventListener()`: [Function]() -> [Void] - Placeholder method for removing event listeners (not implemented in the reference code).\n\nAdditional Classes:\n\n- `MessageEvent`: [Class] - Represents an event received from the server. Contains the event data, origin, and last event ID.\n\nAttributes of `MessageEvent`:\n\n- `data`: [String] - The data payload of the event.\n- `type`: [String] - The type of the event, defaulting to 'message'.\n- `lastEventId`: [String] - The ID of the last received event.\n- `origin`: [String] - The origin URL of the event.\n\nMethods of `MessageEvent`:\n\n- `MessageEvent(data, origin, lastEventId)`: [Constructor]([String], [String], [String]) -> [Object] - Initializes a new `MessageEvent` instance with the provided data, origin, and last event ID.",
    "Canonical_solution": "var EventSource = function (url) {\n  var eventsource = this,\n      interval = 500,\n      lastEventId = null,\n      cache = '';\n\n  if (!url || typeof url != 'string') {\n    throw new SyntaxError('Not enough arguments');\n  }\n\n  this.URL = url;\n  this.readyState = this.CONNECTING;\n  this._pollTimer = null;\n  this._xhr = null;\n\n  function poll() {\n    try {\n      if (eventsource.readyState == eventsource.CLOSED) return;\n\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', eventsource.URL, true);\n      xhr.setRequestHeader('Accept', 'text/event-stream');\n      xhr.setRequestHeader('Cache-Control', 'no-cache');\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n      if (lastEventId != null) xhr.setRequestHeader('Last-Event-ID', lastEventId);\n      cache = '';\n\n      xhr.timeout = 50000;\n      xhr.onreadystatechange = function () {\n        var status = 0;\n        try {\n          status = xhr.status;\n        } catch (e) {}\n\n        if ((this.readyState == 3 || this.readyState == 4) && status == 200) {\n          if (eventsource.readyState == eventsource.CONNECTING) {\n            eventsource.readyState = eventsource.OPEN;\n            eventsource.dispatchEvent('open', { type: 'open' });\n          }\n\n          var responseText = '';\n          try {\n            responseText = this.responseText || '';\n          } catch (e) {}\n\n          var parts = responseText.substr(cache.length).split(\"\\n\"),\n              eventType = 'message',\n              data = [],\n              i = 0,\n              line = '';\n\n          cache = responseText;\n\n          for (; i < parts.length; i++) {\n            line = parts[i].replace(reTrim, '');\n            if (line.indexOf('event') == 0) {\n              eventType = line.replace(/event:?\\s*/, '');\n            } else if (line.indexOf('data') == 0) {\n              data.push(line.replace(/data:?\\s*/, ''));\n            } else if (line.indexOf('id:') == 0) {\n              lastEventId = line.replace(/id:?\\s*/, '');\n            } else if (line.indexOf('id') == 0) {\n              lastEventId = null;\n            } else if (line == '') {\n              if (data.length) {\n                var event = new MessageEvent(data.join('\\n'), eventsource.url, lastEventId);\n                eventsource.dispatchEvent(eventType, event);\n                data = [];\n                eventType = 'message';\n              }\n            }\n          }\n\n          if (this.readyState == 4) pollAgain(this);\n        } else if (eventsource.readyState !== eventsource.CLOSED) {\n          if (this.readyState == 4) {\n            eventsource.readyState = eventsource.CONNECTING;\n            eventsource.dispatchEvent('error', { type: 'error' });\n            pollAgain(this);\n          } else if (this.readyState == 0) {\n            pollAgain(this);\n          }\n        }\n      };\n\n      xhr.send();\n\n      setTimeout(function () {\n        if (true || xhr.readyState == 3) xhr.abort();\n      }, xhr.timeout);\n\n      eventsource._xhr = xhr;\n\n    } catch (e) {\n      eventsource.dispatchEvent('error', { type: 'error', data: e.message });\n    }\n  };\n\n  poll();\n};\n\nEventSource.prototype = {\n  close: function () {\n    this.readyState = this.CLOSED;\n    clearInterval(this._pollTimer);\n    this._xhr.abort();\n  },\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  dispatchEvent: function (type, event) {\n    var handlers = this['_' + type + 'Handlers'];\n    if (handlers) {\n      for (var i = 0; i < handlers.length; i++) {\n        handlers[i].call(this, event);\n      }\n    }\n\n    if (this['on' + type]) {\n      this['on' + type].call(this, event);\n    }\n  },\n  addEventListener: function (type, handler) {\n    if (!this['_' + type + 'Handlers']) {\n      this['_' + type + 'Handlers'] = [];\n    }\n    this['_' + type + 'Handlers'].push(handler);\n  },\n  removeEventListener: function () {},\n  onerror: null,\n  onmessage: null,\n  onopen: null,\n  readyState: 0,\n  URL: ''\n};\n\nvar MessageEvent = function (data, origin, lastEventId) {\n  this.data = data;\n  this.origin = origin;\n  this.lastEventId = lastEventId || '';\n};\n\nMessageEvent.prototype = {\n  data: null,\n  type: 'message',\n  lastEventId: '',\n  origin: ''\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "wrong_result": "class MessageEvent {\n  constructor(data, origin, lastEventId) {\n    this.data = data;\n    this.type = 'message';\n    this.lastEventId = lastEventId;\n    this.origin = origin;\n  }\n}\n\nclass EventSource {\n  static get CONNECTING() { return 0; }\n  static get OPEN() { return 1; }\n  static get CLOSED() { return 2; }\n\n  constructor(url) {\n    this.URL = url;\n    this.readyState = EventSource.CONNECTING;\n    this._pollTimer = null;\n    this._xhr = null;\n    this._eventListeners = {};\n  }\n\n  poll() {\n    if (this.readyState === EventSource.CLOSED) return;\n\n    this._xhr = new XMLHttpRequest();\n    this._xhr.open('GET', this.URL, true);\n    this._xhr.onreadystatechange = () => {\n      if (this._xhr.readyState === 4) {\n        if (this._xhr.status === 200) {\n          this.readyState = EventSource.OPEN;\n          this._processEvents(this._xhr.responseText);\n        } else {\n          this._reconnect();\n        }\n      }\n    };\n    this._xhr.send();\n  }\n\n  close() {\n    if (this.readyState === EventSource.CLOSED) return;\n\n    this.readyState = EventSource.CLOSED;\n    if (this._pollTimer) {\n      clearTimeout(this._pollTimer);\n      this._pollTimer = null;\n    }\n    if (this._xhr) {\n      this._xhr.abort();\n      this._xhr = null;\n    }\n  }\n\n  dispatchEvent(type, event) {\n    if (this._eventListeners[type]) {\n      this._eventListeners[type].forEach(handler => handler(event));\n    }\n  }\n\n  addEventListener(type, handler) {\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n    this._eventListeners[type].push(handler);\n  }\n\n  removeEventListener() {\n    // Placeholder for future implementation\n  }\n\n  _processEvents(data) {\n    const lines = data.split('\\n');\n    let currentEvent = {};\n\n    for (const line of lines) {\n      if (line.trim() === '') {\n        if (Object.keys(currentEvent).length > 0) {\n          const event = new MessageEvent(\n            currentEvent.data,\n            this.URL,\n            currentEvent.id\n          );\n          this.dispatchEvent(currentEvent.eventType || 'message', event);\n          currentEvent = {};\n        }\n        continue;\n      }\n\n      const [key, value] = line.split(':', 2);\n      const trimmedKey = key.trim();\n      const trimmedValue = value ? value.trim() : '';\n\n      if (trimmedKey === 'event') {\n        currentEvent.eventType = trimmedValue;\n      } else if (trimmedKey === 'data') {\n        currentEvent.data = (currentEvent.data || '') + trimmedValue + '\\n';\n      } else if (trimmedKey === 'id') {\n        currentEvent.id = trimmedValue;\n      }\n    }\n\n    if (Object.keys(currentEvent).length > 0) {\n      const event = new MessageEvent(\n        currentEvent.data,\n        this.URL,\n        currentEvent.id\n      );\n      this.dispatchEvent(currentEvent.eventType || 'message', event);\n    }\n  }\n\n  _reconnect() {\n    if (this.readyState === EventSource.CLOSED) return;\n\n    this.readyState = EventSource.CONNECTING;\n    this._pollTimer = setTimeout(() => {\n      this.poll();\n    }, 1000);\n  }\n}"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a JavaScript class that handles HTTP requests to fetch data from a URL, with support for different data formats and authentication.\n\nClass Description: The DataManURL class provides methods to interact with remote resources via HTTP, supporting operations like fetching data as a buffer, converting to data URI, creating read streams, and retrieving metadata like content type and size.\n\nAttributes:\n- url: [String] - The URL of the remote resource to access\n- _type: [String] - The content type of the resource (e.g., 'image/png')\n- urlOpts: [Object] - Configuration options for the HTTP request (headers, auth, etc.)\n- _size: [Number] - The size in bytes of the fetched resource (cached after first request)\n\nMethods:\n- constructor(url, type, options) -> [void] - Initializes a new DataManURL instance\n  - url: [String] - The target URL\n  - type: [String] - Expected content type (optional)\n  - options: [Object] - Request options including auth and headers (optional)\n\n- getBuffer(callback) -> [void] - Fetches the resource as a binary buffer\n  - callback: [Function] - Receives (error, buffer) parameters\n\n- getDataUri(callback) -> [void] - Converts the resource to a base64 data URI\n  - callback: [Function] - Receives (error, dataUri) parameters\n\n- createReadStream() -> [Stream] - Creates a readable stream of the resource\n  - Returns: [Stream] - Readable stream of the resource data\n\n- size(callback) -> [void] - Gets the resource size in bytes\n  - callback: [Function] - Receives (error, size) parameters\n\n- type() -> [String] - Gets the content type of the resource\n  - Returns: [String] - The content type (may be null if not fetched yet)",
    "Canonical_solution": "var request = Npm.require(\"request\");\n\nclass DataManURL {\n  constructor(url, type, options) {\n    var self = this;\n    options = options || {};\n\n    self.url = url;\n    self._type = type;\n\n    if (options.auth) {\n      if (options.auth.indexOf(':') < 0)\n        throw new Error('auth option should be of the form \"username:password\"');\n      options.headers = options.headers || {};\n      options.headers['Authorization'] = \"Basic \"+\n        (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n      delete options.auth;\n    }\n\n    self.urlOpts = options;\n  }\n\n  getBuffer(callback) {\n    var self = this;\n\n    request(_.extend({\n      url: self.url,\n      method: \"GET\",\n      encoding: null,\n      jar: false\n    }, self.urlOpts), Meteor.bindEnvironment(function(err, res, body) {\n      if (err) {\n        callback(err);\n      } else {\n        self._type = res.headers['content-type'];\n        callback(null, body);\n      }\n    }, function(err) {\n      callback(err);\n    }));\n  }\n\n  getDataUri(callback) {\n    var self = this;\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        if (!self._type) {\n          callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n        } else {\n          var dataUri = \"data:\" + self._type + \";base64,\" + buffer.toString(\"base64\");\n          callback(null, dataUri);\n        }\n      }\n    });\n  }\n\n  createReadStream() {\n    var self = this;\n    return request(_.extend({\n      url: self.url,\n      method: \"GET\"\n    }, self.urlOpts));\n  }\n\n  size(callback) {\n    var self = this;\n\n    if (typeof self._size === \"number\") {\n      callback(null, self._size);\n      return;\n    }\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        self._size = buffer.length;\n        callback(null, self._size);\n      }\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type || null;\n    this.urlOpts = options || {};\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    const https = require('https');\n    const http = require('http');\n    const protocol = this.url.startsWith('https') ? https : http;\n\n    protocol.get(this.url, this.urlOpts, (res) => {\n      let data = Buffer.alloc(0);\n      res.on('data', (chunk) => {\n        data = Buffer.concat([data, chunk]);\n      });\n      res.on('end', () => {\n        callback(null, data);\n      });\n    }).on('error', (err) => {\n      callback(err, null);\n    });\n  }\n\n  getDataUri(callback) {\n    this.getBuffer((err, buffer) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n      const mimeType = this._type || 'application/octet-stream';\n      const dataUri = `data:${mimeType};base64,${buffer.toString('base64')}`;\n      callback(null, dataUri);\n    });\n  }\n\n  createReadStream() {\n    const https = require('https');\n    const http = require('http');\n    const protocol = this.url.startsWith('https') ? https : http;\n\n    return protocol.get(this.url, this.urlOpts);\n  }\n\n  size(callback) {\n    if (this._size !== null) {\n      callback(null, this._size);\n      return;\n    }\n\n    const https = require('https');\n    const http = require('http');\n    const protocol = this.url.startsWith('https') ? https : http;\n\n    protocol.get(this.url, this.urlOpts, (res) => {\n      const contentLength = parseInt(res.headers['content-length'], 10);\n      this._size = contentLength;\n      callback(null, contentLength);\n    }).on('error', (err) => {\n      callback(err, null);\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function that sends a POST request to a specified URL with form-urlencoded data and handles the response asynchronously.\n\nFunction Description: The function `sendPostRequest` constructs and sends an HTTP POST request to a given endpoint. It sets the appropriate content type header for form-urlencoded data, includes credentials if needed, and logs the server's response upon completion. This is useful for submitting form data or making authenticated API requests.\n\nInput: None (The URL and data are hardcoded in this example, but could be parameterized in a real implementation)\n\nOutput: None (The function logs the response to the console, but doesn't return anything)",
    "Canonical_solution": "function sendPostRequest() {\n    const data = 'secret=*%5*!';\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/post');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "async function sendPostRequest() {\n  const url = 'https://example.com/api';\n  const data = new URLSearchParams();\n  data.append('username', 'user123');\n  data.append('password', 'pass123');\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      body: data,\n      credentials: 'include'\n    });\n\n    const result = await response.text();\n    console.log('Server Response:', result);\n  } catch (error) {\n    console.error('Error sending POST request:', error);\n  }\n}"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a JavaScript class that handles AJAX requests using XMLHttpRequest, supporting cross-origin requests, custom headers, and various response handling scenarios.\n\nClass Description: The AjaxTransport class provides a wrapper around XMLHttpRequest for making asynchronous HTTP requests. It handles request creation, header management, response processing, and cleanup. The class supports CORS, maintains request state, and provides error handling capabilities.\n\nAttributes:\n\nxhrId: [Number] - Counter for generating unique IDs for each XMLHttpRequest instance\nxhrCallbacks: [Object] - Stores callback functions for active requests\nxhrSuccessStatus: [Object] - Maps certain HTTP status codes to standard success codes\nxhrSupported: [XMLHttpRequest|Boolean] - Stores the created XMLHttpRequest instance or false if not supported\n\nMethods:\n\ncreateXHR: () -> [XMLHttpRequest|undefined] - Creates and returns a new XMLHttpRequest instance or undefined if creation fails\n\nsendRequest: (options: Object, headers: Object, complete: Function) -> [undefined] - \n  Sends an AJAX request with the given configuration\n  options: Contains request parameters (type, url, async, etc.)\n  headers: Key-value pairs of request headers\n  complete: Callback function to handle response\n\nabortRequest: (callback: Function) -> [undefined] - \n  Aborts an active request and executes the given callback\n  callback: Function to execute after aborting\n\ngetTransport: (options: Object) -> [Object|undefined] - \n  Returns a transport object if the request can be handled\n  options: Configuration object for the request\n  Returns an object with send and abort methods or undefined if request can't be handled",
    "Canonical_solution": "var jQuery = require(\"../core\");\nvar support = require(\"../var/support\");\n\nclass AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = {\n      0: 200,\n      1223: 204\n    };\n    this.xhrSupported = this.createXHR();\n    \n    if (window.ActiveXObject) {\n      jQuery(window).on(\"unload\", () => {\n        for (var key in this.xhrCallbacks) {\n          this.xhrCallbacks[key]();\n        }\n      });\n    }\n    \n    support.cors = !!this.xhrSupported && (\"withCredentials\" in this.xhrSupported);\n    support.ajax = !!this.xhrSupported;\n  }\n\n  createXHR() {\n    try {\n      return new XMLHttpRequest();\n    } catch(e) {}\n  }\n\n  sendRequest(options, headers, complete) {\n    var xhr = options.xhr();\n    var id = ++this.xhrId;\n\n    xhr.open(options.type, options.url, options.async, options.username, options.password);\n\n    if (options.xhrFields) {\n      for (var i in options.xhrFields) {\n        xhr[i] = options.xhrFields[i];\n      }\n    }\n\n    if (options.mimeType && xhr.overrideMimeType) {\n      xhr.overrideMimeType(options.mimeType);\n    }\n\n    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n      headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n    }\n\n    for (var i in headers) {\n      xhr.setRequestHeader(i, headers[i]);\n    }\n\n    var callback = (type) => {\n      return () => {\n        if (callback) {\n          delete this.xhrCallbacks[id];\n          callback = xhr.onload = xhr.onerror = null;\n\n          if (type === \"abort\") {\n            xhr.abort();\n          } else if (type === \"error\") {\n            complete(xhr.status, xhr.statusText);\n          } else {\n            complete(\n              this.xhrSuccessStatus[xhr.status] || xhr.status,\n              xhr.statusText,\n              typeof xhr.responseText === \"string\" ? { text: xhr.responseText } : undefined,\n              xhr.getAllResponseHeaders()\n            );\n          }\n        }\n      };\n    };\n\n    xhr.onload = callback();\n    xhr.onerror = callback(\"error\");\n    callback = this.xhrCallbacks[id] = callback(\"abort\");\n\n    try {\n      xhr.send(options.hasContent && options.data || null);\n    } catch (e) {\n      if (callback) {\n        throw e;\n      }\n    }\n  }\n\n  abortRequest(callback) {\n    if (callback) {\n      callback();\n    }\n  }\n\n  getTransport(options) {\n    if (support.cors || this.xhrSupported && !options.crossDomain) {\n      return {\n        send: (headers, complete) => this.sendRequest(options, headers, complete),\n        abort: () => this.abortRequest(callback)\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "wrong_result": "class AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = { 201: 200, 202: 200, 203: 200, 204: 200, 205: 200, 206: 200 };\n    this.xhrSupported = false;\n  }\n\n  createXHR() {\n    try {\n      this.xhrSupported = new XMLHttpRequest();\n      return this.xhrSupported;\n    } catch (e) {\n      return undefined;\n    }\n  }\n\n  sendRequest(options, headers, complete) {\n    const xhr = this.createXHR();\n    if (!xhr) return;\n\n    const id = ++this.xhrId;\n    this.xhrCallbacks[id] = complete;\n\n    xhr.open(options.type, options.url, options.async !== false);\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        const status = xhr.status;\n        const successStatus = this.xhrSuccessStatus[status] || status;\n        const response = xhr.responseText;\n        const error = !((successStatus >= 200 && successStatus < 300) || successStatus === 304);\n\n        if (error) {\n          this.xhrCallbacks[id](true, response, xhr);\n        } else {\n          this.xhrCallbacks[id](false, response, xhr);\n        }\n\n        delete this.xhrCallbacks[id];\n      }\n    };\n\n    for (const header in headers) {\n      if (headers.hasOwnProperty(header)) {\n        xhr.setRequestHeader(header, headers[header]);\n      }\n    }\n\n    xhr.send(options.data);\n  }\n\n  abortRequest(callback) {\n    const xhr = this.xhrSupported;\n    if (xhr) {\n      xhr.abort();\n      callback();\n    }\n  }\n\n  getTransport(options) {\n    if (typeof XMLHttpRequest === 'undefined') return undefined;\n\n    const transport = {\n      send: (headers, complete) => this.sendRequest(options, headers, complete),\n      abort: (callback) => this.abortRequest(callback)\n    };\n\n    return transport;\n  }\n}"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a function that handles different types of HTTP requests and script imports, then communicates the results back to a sender.\n\nFunction Description: The function `run_test` processes incoming data to determine which type of request or script import to execute. It supports XMLHttpRequest (XHR), Fetch API, and `importScripts` methods. Based on the input data, it initiates the corresponding operation and sends the result or error message back to the sender via the `postMessage` method.\n\nInput:  \n- `data` [String] - A string indicating the type of operation to perform. Valid values are 'xhr', 'fetch', or 'importScripts'.  \n- `sender` [Object] - An object with a `postMessage` method used to send the response or error message back to the caller.\n\nOutput:  \n- No direct return value. The function communicates results asynchronously via `sender.postMessage()`, sending either the response data (for successful operations) or an error message (for failures).  \n\nThe function handles the following cases:  \n1. If `data` is 'xhr', it performs an XMLHttpRequest GET operation and sends the response text or an error message.  \n2. If `data` is 'fetch', it uses the Fetch API to retrieve data and sends the response text or an error message.  \n3. If `data` is 'importScripts', it imports a script and sends a predefined message from the imported script.  \n4. For any other `data` value, it sends an \"Unexpected message\" response.",
    "Canonical_solution": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'synthesized-response.txt', true);\n    xhr.responseType = 'text';\n    xhr.send();\n    xhr.onload = evt => sender.postMessage(xhr.responseText);\n    xhr.onerror = () => sender.postMessage('XHR failed!');\n  } else if (data === 'fetch') {\n    fetch('synthesized-response.txt')\n        .then(response => response.text())\n        .then(data => sender.postMessage(data))\n        .catch(error => sender.postMessage('Fetch failed!'));\n  } else if (data === 'importScripts') {\n    importScripts('synthesized-response.js');\n    sender.postMessage(message);\n  } else {\n    sender.postMessage('Unexpected message! ' + data);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://example.com/data', true);\n    xhr.onload = function() {\n      if (xhr.status === 200) {\n        sender.postMessage(xhr.responseText);\n      } else {\n        sender.postMessage('Error: XHR request failed with status ' + xhr.status);\n      }\n    };\n    xhr.onerror = function() {\n      sender.postMessage('Error: XHR request failed');\n    };\n    xhr.send();\n  } else if (data === 'fetch') {\n    fetch('https://example.com/data')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error('Fetch request failed with status ' + response.status);\n        }\n        return response.text();\n      })\n      .then(data => sender.postMessage(data))\n      .catch(error => sender.postMessage('Error: ' + error.message));\n  } else if (data === 'importScripts') {\n    importScripts('https://example.com/script.js');\n    sender.postMessage('Script imported successfully');\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n}"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a function that asynchronously loads YAML content from a specified URL and processes it using a callback function.\n\nFunction Description: The function `loadYamlUrl` initiates an HTTP GET request to fetch YAML content from a given URL. It handles the response asynchronously, checking for a successful status code (200) before passing the YAML text to a processing function (`yamlToForm`) and logging the response to the console.\n\nInput: \n- `url` [String] - The URL from which to fetch the YAML content.\n\nOutput: \n- None (The function does not return a value directly but processes the YAML content via the `yamlToForm` callback and logs the response to the console.)",
    "Canonical_solution": "function loadYamlUrl(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'text';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            yamlToForm(this.response);\n            console.log(this.response);\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "async function loadYamlUrl(url) {\n  try {\n    const response = await fetch(url);\n    if (response.status === 200) {\n      const yamlText = await response.text();\n      yamlToForm(yamlText);\n      console.log(yamlText);\n    } else {\n      console.error(`Failed to load YAML: ${response.statusText}`);\n    }\n  } catch (error) {\n    console.error(`Error fetching YAML: ${error.message}`);\n  }\n}"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create an HTTP server using Express.js that handles various routes for data processing, API endpoints, and event handling. The server should dynamically generate API endpoints based on available utility functions and provide basic route handling for updates, embedding, and event processing.\n\nFunction Description: The `createServer` function initializes an Express.js server with middleware configuration, defines route handlers for specific endpoints, dynamically creates API routes based on utility functions, and starts the server on a random available port. It outputs the server's port information as JSON to stdout.\n\nInput: None (The function takes no parameters but relies on external modules and variables like `express`, `connect`, `dataIn`, `locker`, `oembed`, `async`, `logger`, and `util` being available in scope)\n\nOutput: \n- The function doesn't return anything directly\n- Writes server port information to stdout as JSON: `{port: [number]}`\n- Creates a running HTTP server listening on localhost\n- Provides the following endpoints:\n  - GET /update - Triggers reindexing\n  - GET /embed - Handles oEmbed requests\n  - POST /events - Processes queued events\n  - Dynamic GET routes based on utility functions",
    "Canonical_solution": "function createServer() {\n    var express = require('express'),\n        connect = require('connect');\n    var app = express.createServer(connect.bodyParser());\n    app.use(require(\"express-jsonstream\")());\n    app.set('views', __dirname);\n    app.get('/update', function (req, res) {\n        dataIn.reIndex(locker, function () {\n            res.writeHead(200);\n            res.end('Extra mince!');\n        });\n    });\n    app.get('/embed', function (req, res) {\n        if (!dataIn.process) return res.send({});\n        oembed.fetch({url:req.query.url}, function (e) {\n            if(e) return res.send(e);\n            res.send({});\n        });\n    });\n    app.post('/events', function (req, res) {\n        var q = async.queue(dataIn.processEvent, 1);\n        req.jsonStream(q.push, function (error) {\n            if(error) logger.error(error);\n            res.send(200);\n        });\n    });\n    function genericApi(name,f) {\n        app.get(name, function (req,res) {\n            var results = [];\n            f(req.query, function (item) { results.push(item); }, function (err) {\n                if(err) {\n                    res.writeHead(500, {'Content-Type': 'text/plain'});\n                    res.end(err);\n                } else {\n                    res.writeHead(200, {'Content-Type': 'application/json'});\n                    res.end(JSON.stringify(results));\n                }\n            });\n        });\n    }\n    for (var f in util) {\n        if (f == 'init') continue;\n        genericApi('/'+f,util[f]);\n    }\n    app.listen(0, 'localhost', function () {\n        var returnedInfo = {port: app.address().port};\n        process.stdout.write(JSON.stringify(returnedInfo));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nfunction createServer() {\n  const app = express();\n  app.use(connect());\n  app.use(express.json());\n  app.use(logger);\n\n  app.get('/update', (req, res) => {\n    dataIn.reindex();\n    res.status(200).send('Reindexing triggered');\n  });\n\n  app.get('/embed', (req, res) => {\n    oembed.handleRequest(req, res);\n  });\n\n  app.post('/events', (req, res) => {\n    locker.lock(() => {\n      async.waterfall([\n        (cb) => {\n          util.processEvents(req.body.events, cb);\n        },\n        (results, cb) => {\n          util.saveResults(results, cb);\n        }\n      ], (err) => {\n        if (err) return res.status(500).send(err.message);\n        res.status(200).send('Events processed');\n      });\n    });\n  });\n\n  Object.keys(util).forEach((key) => {\n    if (typeof util[key] === 'function' && key.startsWith('get')) {\n      const route = `/${key.substring(3)}`;\n      app.get(route, (req, res) => {\n        util[key](req.query, (err, data) => {\n          if (err) return res.status(500).send(err.message);\n          res.json(data);\n        });\n      });\n    }\n  });\n\n  const server = app.listen(0, 'localhost', () => {\n    const port = server.address().port;\n    console.log(JSON.stringify({ port }));\n  });\n}\n```"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a reusable HTTP server class in JavaScript using the Express framework that can handle various HTTP methods, middleware configuration, and file uploads.\n\nClass Description: The HTTPServer class encapsulates an Express application with configurable routes, middleware, and file upload capabilities. It provides methods to start/stop the server and add route handlers for different HTTP methods.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number the server listens on\n- server: [Object|null] - The HTTP server instance (null before starting)\n\nMethods:\n- constructor(port) -> [HTTPServer] - Initializes the Express app with middleware and file upload handling\n- start() -> [Promise] - Starts the server on the specified port\n- stop() -> [void] - Stops the server if running\n- addRoute(method, path, handler) -> [void] - Adds a route handler for a specific HTTP method\n- get(path, handler) -> [void] - Adds a GET route handler\n- post(path, handler) -> [void] - Adds a POST route handler\n- put(path, handler) -> [void] - Adds a PUT route handler\n- delete(path, handler) -> [void] - Adds a DELETE route handler\n- patch(path, handler) -> [void] - Adds a PATCH route handler\n- options(path, handler) -> [void] - Adds an OPTIONS route handler\n- trace(path, handler) -> [void] - Adds a TRACE route handler\n- head(path, handler) -> [void] - Adds a HEAD route handler",
    "Canonical_solution": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst multer = require(\"multer\");\n\nclass HTTPServer {\n    constructor(port) {\n        this.app = express();\n        this.port = port;\n        this.server = null;\n        \n        // Configure middleware\n        this.app.use(bodyParser.raw({type:\"*/*\"}));\n        this.app.use(cookieParser(undefined,{decode:String}));\n        \n        // File upload handling\n        const fileUploadApp = express();\n        const mp = multer({ storage: multer.memoryStorage() }).any();\n        fileUploadApp.post(\"/file-upload\",function(req,res,next) {\n            mp(req,res,function(err) {\n                req._body = true;\n                next(err);\n            })\n        },bodyParser.json(),function(req,res) {\n            res.json({\n                body: req.body,\n                files: req.files\n            })\n        });\n        this.app.use(fileUploadApp);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            this.server = this.app.listen(this.port, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n\n    addRoute(method, path, handler) {\n        this.app[method.toLowerCase()](path, handler);\n    }\n\n    get(path, handler) {\n        this.addRoute('get', path, handler);\n    }\n\n    post(path, handler) {\n        this.addRoute('post', path, handler);\n    }\n\n    put(path, handler) {\n        this.addRoute('put', path, handler);\n    }\n\n    delete(path, handler) {\n        this.addRoute('delete', path, handler);\n    }\n\n    patch(path, handler) {\n        this.addRoute('patch', path, handler);\n    }\n\n    options(path, handler) {\n        this.addRoute('options', path, handler);\n    }\n\n    trace(path, handler) {\n        this.addRoute('trace', path, handler);\n    }\n\n    head(path, handler) {\n        this.addRoute('head', path, handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "class HTTPServer {\n  constructor(port) {\n    this.app = require('express')();\n    this.port = port;\n    this.server = null;\n    this.app.use(require('body-parser').json());\n    this.app.use(require('express').static('public'));\n    this.app.use(require('multer')({ dest: 'uploads/' }));\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.port, () => {\n        console.log(`Server running on port ${this.port}`);\n        resolve();\n      }).on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close(() => {\n        console.log('Server stopped');\n      });\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app.route(path)[method](handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Implement a Twitter HTTP client class in JavaScript that handles API requests to Twitter, including request construction, execution, and response processing with error handling and clock synchronization.\n\nClass Description: The TwitterHTTPClient class provides methods to interact with Twitter's REST API. It handles HTTP requests (GET/POST), manages authentication, processes responses, and maintains clock synchronization with Twitter's servers.\n\nAttributes:\n- config: [Object] - Configuration object containing API credentials and settings\n- _twitter_time_minus_local_time_ms: [Number] - Time difference between Twitter's server time and local time in milliseconds\n\nMethods:\n- constructor(config) -> [TwitterHTTPClient] - Initializes the client with configuration\n- request(method, path, params, callback) -> [Promise] - Makes HTTP requests to Twitter API\n- _doRestApiRequest(reqOpts, twitOptions, method, callback) -> [void] - Executes the actual HTTP request\n- _updateClockOffsetFromResponse(resp) -> [void] - Updates the clock offset based on Twitter's server time\n\nMethod Details:\n1. request(method, path, params, callback)\n   - Input:\n     - method: [String] - HTTP method ('GET' or 'POST')\n     - path: [String] - API endpoint path\n     - params: [Object] - Request parameters\n     - callback: [Function] - Callback function for handling response\n   - Output: [Promise] - Resolves with response data or rejects with error\n\n2. _doRestApiRequest(reqOpts, twitOptions, method, callback)\n   - Input:\n     - reqOpts: [Object] - Request options including URL and headers\n     - twitOptions: [Object] - Twitter-specific options\n     - method: [String] - HTTP method\n     - callback: [Function] - Callback for handling response\n   - Output: [void] - Calls callback with response data or error\n\n3. _updateClockOffsetFromResponse(resp)\n   - Input:\n     - resp: [Object] - HTTP response object\n   - Output: [void] - Updates internal clock offset value",
    "Canonical_solution": "var request = require('request');\nvar helpers = require('./helpers');\n\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    var self = this;\n    assert(method == 'GET' || method == 'POST');\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      var _returnErrorToUser = function (err) {\n        if (callback && typeof callback === 'function') {\n          callback(err, null, null);\n        }\n        reject(err);\n      }\n\n      self._buildReqOpts(method, path, params, false, function (err, reqOpts) {\n        if (err) {\n          _returnErrorToUser(err);\n          return;\n        }\n\n        var twitOptions = (params && params.twit_options) || {};\n\n        process.nextTick(function () {\n          self._doRestApiRequest(reqOpts, twitOptions, method, function (err, parsedBody, resp) {\n            self._updateClockOffsetFromResponse(resp);\n\n            if (self.config.trusted_cert_fingerprints) {\n              if (!resp.socket.authorized) {\n                var authErrMsg = resp.socket.authorizationError.toString();\n                var err = helpers.makeTwitError('The peer certificate was not signed; ' + authErrMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n              var fingerprint = resp.socket.getPeerCertificate().fingerprint;\n              var trustedFingerprints = self.config.trusted_cert_fingerprints;\n              if (trustedFingerprints.indexOf(fingerprint) === -1) {\n                var errMsg = util.format('Certificate untrusted. Trusted fingerprints are: %s. Got fingerprint: %s.',\n                                         trustedFingerprints.join(','), fingerprint);\n                var err = new Error(errMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n            }\n\n            if (callback && typeof callback === 'function') {\n              callback(err, parsedBody, resp);\n            }\n\n            resolve({ data: parsedBody, resp: resp });\n            return;\n          });\n        });\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    var request_method = request[method.toLowerCase()];\n    var req = request_method(reqOpts);\n\n    var body = '';\n    var response = null;\n\n    var onRequestComplete = function () {\n      if (body !== '') {\n        try {\n          body = JSON.parse(body);\n        } catch (jsonDecodeError) {\n          var err = helpers.makeTwitError('JSON decode error: Twitter HTTP response body was not valid JSON');\n          err.statusCode = response ? response.statusCode: null;\n          err.allErrors.concat({error: jsonDecodeError.toString()});\n          callback(err, body, response);\n          return;\n        }\n      }\n\n      if (typeof body === 'object' && (body.error || body.errors)) {\n        var err = helpers.makeTwitError('Twitter API Error');\n        err.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n\n      callback(err, body, response);\n    }\n\n    req.on('response', function (res) {\n      response = res;\n      req.on('data', function (chunk) {\n        body += chunk.toString('utf8');\n      });\n      req.on('end', function () {\n        onRequestComplete();\n      });\n    });\n\n    req.on('error', function (err) {\n      if (twitOptions.retry &&\n          STATUS_CODES_TO_ABORT_ON.indexOf(err.statusCode) !== -1\n      ) {\n        self.request(method, path, params, callback);\n        return;\n      } else {\n        err.statusCode = null;\n        err.code = null;\n        err.allErrors = [];\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    var self = this;\n    if (resp && resp.headers && resp.headers.date &&\n        new Date(resp.headers.date).toString() !== 'Invalid Date'\n    ) {\n      var twitterTimeMs = new Date(resp.headers.date).getTime();\n      self._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        method: method,\n        headers: {\n          'Authorization': this._getAuthHeader(method, path, params),\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      };\n\n      const twitOptions = {\n        method: method,\n        path: path,\n        params: params\n      };\n\n      this._doRestApiRequest(reqOpts, twitOptions, method, (err, data, response) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(response);\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const https = require('https');\n    const qs = require('querystring');\n\n    const options = {\n      hostname: 'api.twitter.com',\n      port: 443,\n      path: `/1.1/${twitOptions.path}.json?${qs.stringify(twitOptions.params)}`,\n      method: method,\n      headers: reqOpts.headers\n    };\n\n    const req = https.request(options, (res) => {\n      let data = '';\n\n      res.on('data', (chunk) => {\n        data += chunk;\n      });\n\n      res.on('end', () => {\n        try {\n          const parsedData = JSON.parse(data);\n          callback(null, parsedData, res);\n        } catch (e) {\n          callback(e, null, res);\n        }\n      });\n    });\n\n    req.on('error', (e) => {\n      callback(e, null, null);\n    });\n\n    if (method === 'POST') {\n      req.write(qs.stringify(twitOptions.params));\n    }\n\n    req.end();\n  }\n\n  _getAuthHeader(method, path, params) {\n    const oauth = require('oauth-1.0a');\n    const crypto = require('crypto');\n\n    const consumerKey = this.config.consumer_key;\n    const consumerSecret = this.config.consumer_secret;\n    const token = this.config.access_token;\n    const tokenSecret = this.config.access_token_secret;\n\n    const oauthObj = oauth({\n      consumer: { key: consumerKey, secret: consumerSecret },\n      token: { key: token, secret: tokenSecret }\n    });\n\n    const authHeader = oauthObj.toHeader(oauthObj.authorize({\n      url: `https://api.twitter.com/1.1/${path}.json`,\n      method: method,\n      data: params\n    }));\n\n    return authHeader['Authorization'];\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const twitterTimeStr = resp.headers['date'];\n    if (twitterTimeStr) {\n      const twitterTime = new Date(twitterTimeStr).getTime();\n      const localTime = new Date().getTime();\n      this._twitter_time_minus_local_time_ms = twitterTime - localTime;\n    }\n  }\n}"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a function that sets up an Express server with middleware configuration, route handling, and database interactions for tracking page views and predictions.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js server with CORS support and body parsing middleware. It establishes routes for handling POST requests to track page views, interact with a MongoDB database to store/view predictions, and determine prefetch paths based on user navigation patterns. The server listens on a configured port.\n\nInput: None (The function doesn't take any direct parameters, but relies on external configuration files for database connection and server port)\n\nOutput: Returns the Express application instance (app) that has been configured and started.\n\nNote: The function assumes the existence of several external dependencies:\n- express, body-parser, and cors npm packages\n- MongoDB connection configuration in './config'\n- Mongoose models Prediction and PageView in './src/models'\n- A helper function `shouldPrefetch` (not shown in reference code)\n- A helper function `getPreviousPageId` (not shown in reference code)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express')\n    const bodyParser = require('body-parser')\n    const cors = require('cors')\n    const app = express()\n\n    app.use(bodyParser.json())\n    app.use(bodyParser.urlencoded({ extended: true }))\n    app.use(cors())\n\n    app.all('/', function (req, res, next) {\n        res.header('Access-Control-Allow-Origin', '*')\n        res.header('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS')\n        res.header('Access-Control-Allow-Headers', 'X-Requested-With, Content-Type')\n        next()\n    })\n\n    app.post('/', async (req, res) => {\n        const mongoose = require('mongoose')\n        const Prediction = require('./src/models/prediction')\n        const PageView = require('./src/models/pageView')\n        const config = require('./config')\n\n        mongoose.connect(config.db.mongoURL)\n        const prediction = await Prediction.findOne({'pagePath': req.body['pagePath']})\n        const prefetchPath = shouldPrefetch(req, prediction) ? prediction['nextPagePath'] : ''\n\n        const pageView = await PageView.create({\n            pagePath: req.body['pagePath'],\n            clientInfo: req.body['clientInfo'],\n            userFlow: req.body['userFlow'],\n            prefetchPath: prefetchPath\n        })\n\n        if (req.body.userFlow.length > 0) {\n            const id = getPreviousPageId(req.body.userFlow)\n            await PageView.findByIdAndUpdate(id, {'actualNextPagePath': req.body.pagePath})\n        }\n\n        res.json({\n            'pageViewId': pageView._id,\n            'prefetchPath': prefetchPath\n        })\n    })\n\n    app.listen(config.server.port)\n    return app\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "app.use(cors());\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\nconst db = require('./config');\nconst Prediction = require('./src/models/Prediction');\nconst PageView = require('./src/models/PageView');\napp.post('/track-page-view', async (req, res) => {\n  try {\n    const { userId, pageId, timestamp } = req.body;\n    const previousPageId = await getPreviousPageId(userId);\n    const shouldPrefetch = await shouldPrefetch(previousPageId, pageId);\n    const pageView = new PageView({ userId, pageId, timestamp, previousPageId, shouldPrefetch });\n    await pageView.save();\n    res.status(201).send('Page view tracked');\n  } catch (error) {\n    res.status(500).send('Error tracking page view');\n  }\n});\napp.get('/predictions', async (req, res) => {\n  try {\n    const predictions = await Prediction.find();\n    res.json(predictions);\n  } catch (error) {\n    res.status(500).send('Error fetching predictions');\n  }\n});\napp.get('/prefetch-paths', async (req, res) => {\n  try {\n    const prefetchPaths = await PageView.aggregate([\n      { $group: { _id: { previousPageId: '$previousPageId', nextPageId: '$pageId' }, count: { $sum: 1 } } },\n      { $sort: { 'count': -1 } },\n      { $limit: 5 }\n    ]);\n    res.json(prefetchPaths);\n  } catch (error) {\n    res.status(500).send('Error fetching prefetch paths');\n  }\n});\napp.listen(process.env.PORT || 3000, () => {\n  console.log(`Server running on port ${process.env.PORT || 3000}`);\n});\nmodule.exports = app;"
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Create an HTTP server using Express.js that serves a JavaScript version endpoint and handles file uploads with configuration options.\n\nFunction Description: The function sets up an Express.js server with middleware for file uploads and JSON body parsing. It defines a route '/version.js' that returns JavaScript code to display a version number in the UI. The server listens on a specified port from environment variables.\n\nInput:\n- process.env.PORT: [String] - The port number on which the server should listen\n- constants.VERSION_NAME: [String] - The version string to be displayed in the UI (used in the version.js endpoint)\n\nOutput:\n- An active HTTP server listening on the specified port\n- The '/version.js' endpoint returns JavaScript code that updates the UI with the version number every second\n\nMethods:\n- app.use(): [Function] - Configures middleware for file uploads and JSON body parsing\n- app.get(): [Function] - Defines a GET route handler for '/version.js'\n- app.listen(): [Function] - Starts the server on the specified port\n\nMiddleware Configuration:\n- fileUpload: [Object] - Configures file upload options (createParentPath: true)\n- bodyParser.json: [Object] - Configures JSON body parsing with a 50MB limit\n\nRoute Handlers:\n- '/version.js': [GET] - Returns JavaScript code that continuously updates an element with id \"uiversion\" with the version string",
    "Canonical_solution": "const express = require('express')\nconst bodyParser = require('body-parser')\nconst fileUpload = require('express-fileupload');\n\nlet app = express()\n\napp.use(fileUpload({\n    createParentPath: true\n}));\napp.use(bodyParser.json({limit: '50mb'}))\n\napp.get('/version.js', (req, res) => {\n    res.writeHead(200, {\n        'Content-Type': 'application/javascript'\n    });\n\n    res.write( `\n        function setUIVersionNow() {\n            setTimeout( setUIVersionNow, 1000);\n            var element = document.getElementById(\"uiversion\");\n            if (element != null) {\n                element.innerHTML = \"${constants.VERSION_NAME}\";\n            }\n        }\n        setTimeout( setUIVersionNow, 1000);\n    ` );\n    res.end();\n});\n\napp.listen(process.env.PORT, () => {\n    console.log(`HTTP server running on port: http://*:${process.env.PORT}`)\n})",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "app.use(fileUpload({ createParentPath: true }));\napp.use(bodyParser.json({ limit: '50mb' }));\napp.get('/version.js', (req, res) => {\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(`setInterval(() => { document.getElementById('uiversion').innerText = '${constants.VERSION_NAME}'; }, 1000);`);\n});\napp.listen(process.env.PORT, () => console.log(`Server running on port ${process.env.PORT}`));"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that makes an HTTP request to a specified URL with custom headers and handles the response.\n\nFunction Description: The function `makeHttpRequest` performs an HTTP GET request to a specified URL with custom headers and decompresses gzip-encoded responses. It uses the `request` module to send the request and handles the response through a callback function that checks for errors and logs the response body if successful.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function logs the response body to the console if the request is successful.)",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Accept-Encoding': 'gzip, deflate, sdch',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Referer': 'http://www.wikipedia.org/',\n        'Cookie': 'GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14',\n        'Connection': 'keep-alive'\n    };\n\n    var options = {\n        url: 'http://localhost:28139/',\n        headers: headers,\n        gzip: true\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "makeHttpRequest = () => {\n  const request = require('request');\n  const url = 'https://example.com';\n  const headers = {\n    'User-Agent': 'CustomUserAgent',\n    'Accept-Encoding': 'gzip'\n  };\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Request failed:', error);\n      return;\n    }\n    console.log('Response status code:', response.statusCode);\n    console.log('Response body:', body);\n  });\n};"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, and integrate it with Next.js for server-side rendering.\n\nFunction Description: The function `setupServer` initializes an Express server with session management configured to use MongoDB for session storage. It integrates with Next.js for handling server-side rendering and routes all requests to the Next.js request handler. The server listens on a specified port and logs the root URL when ready.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Port number to listen on (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that listens on the specified port and handles requests. It logs the root URL to the console when the server is ready.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    const next = require('next');\n    const mongoose = require('mongoose');\n\n    const dev = process.env.NODE_ENV !== 'production';\n    const MONGO_URL = process.env.MONGO_URL_TEST;\n    const port = process.env.PORT || 8000;\n    const ROOT_URL = `http://localhost:${port}`;\n\n    const app = next({ dev });\n    const handle = app.getRequestHandler();\n\n    const server = express();\n\n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: MONGO_URL,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => handle(req, res));\n\n    server.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on ${ROOT_URL}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\n\nasync function setupServer() {\n  const dev = process.env.NODE_ENV !== 'production';\n  const app = express();\n  const nextApp = next({ dev });\n  const handle = nextApp.getRequestHandler();\n\n  await nextApp.prepare();\n\n  const mongoUrl = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const sessionName = process.env.SESSION_NAME || 'sessionId';\n  const sessionSecret = process.env.SESSION_SECRET;\n\n  if (!sessionSecret) {\n    throw new Error('SESSION_SECRET environment variable is required');\n  }\n\n  mongoose.connect(mongoUrl, { useNewUrlParser: true, useUnifiedTopology: true });\n\n  const store = new MongoDBStore({\n    uri: mongoUrl,\n    collection: 'sessions'\n  });\n\n  app.use(session({\n    secret: sessionSecret,\n    name: sessionName,\n    store: store,\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n      maxAge: 1000 * 60 * 60 * 24 * 7 // 1 week\n    }\n  }));\n\n  app.use((req, res, next) => {\n    req.nextApp = nextApp;\n    next();\n  });\n\n  app.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  app.listen(port, () => {\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n}\n\nsetupServer();"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a function to set up a server using Express.js with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB, integrates Next.js for server-side rendering, and sets up basic route handling. It prepares the server environment, configures middleware, and starts listening on a specified port.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret for session encryption\n)\n\nOutput: None (The function starts a server process that:\n1. Creates an Express server with session management\n2. Integrates Next.js for server-side rendering\n3. Sets up route handling\n4. Listens on the specified port\n5. Logs server readiness to console\n)",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  app.prepare().then(async () => {\n    const server = express();\n\n    server.use(express.json());\n\n    const sessionOptions = {\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: mongoSessionStore.create({\n        mongoUrl: MONGO_URL,\n        ttl: 14 * 24 * 60 * 60,\n      }),\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        httpOnly: true,\n        maxAge: 14 * 24 * 60 * 60 * 1000,\n        domain: 'localhost',\n      },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => {\n      const url = URL_MAP[req.path];\n      if (url) {\n        app.render(req, res, url);\n      } else {\n        handle(req, res);\n      }\n    });\n\n    server.listen(port, (err) => {\n      if (err) throw err;\n      console.log(`> Ready on ${ROOT_URL}`);\n    });\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = express();\nconst nextApp = next({ dev });\nconst handle = nextApp.getRequestHandler();\n\nconst PORT = process.env.PORT || 8000;\nconst MONGO_URL_TEST = process.env.MONGO_URL_TEST;\nconst SESSION_NAME = process.env.SESSION_NAME;\nconst SESSION_SECRET = process.env.SESSION_SECRET;\n\nconst store = new MongoDBStore({\n  uri: MONGO_URL_TEST,\n  collection: 'sessions',\n});\n\nstore.on('error', (err) => {\n  console.error('MongoDB Session Store Error:', err);\n});\n\napp.use(session({\n  secret: SESSION_SECRET,\n  name: SESSION_NAME,\n  resave: false,\n  saveUninitialized: false,\n  store,\n  cookie: {\n    maxAge: 1000 * 60 * 60 * 24 * 7, // 1 week\n    sameSite: 'lax',\n    secure: process.env.NODE_ENV === 'production',\n  },\n}));\n\nnextApp.prepare().then(() => {\n  app.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  app.listen(PORT, () => {\n    console.log(`> Server listening on http://localhost:${PORT}`);\n  });\n});"
  }
]