[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a PHP class that interacts with an Ollama API to generate responses using HTTP requests through the Guzzle HTTP client.\n\nClass Description: The Ollama class is designed to communicate with an Ollama API endpoint to generate responses based on provided prompts. It handles the configuration of the API request and processes the response.\n\nAttributes:\n- model: string - The name of the AI model to be used for generating responses.\n- prompt: string - The input text prompt to be sent to the AI model.\n- temperature: float - Controls the randomness of the output (higher values make output more random).\n- stream: bool - Determines whether the response should be streamed.\n- raw: bool - Specifies whether to use raw mode for the prompt processing.\n\nMethods:\n- __construct(string $model, string $prompt, float $temperature, bool $stream, bool $raw) -> void - Initializes the Ollama instance with the specified parameters for model interaction.\n- ask() -> string - Sends a POST request to the Ollama API with the configured parameters and returns the generated response from the AI model.",
    "Canonical_solution": "use GuzzleHttp\\Client;\n\nclass Ollama\n{\n    /**\n     * New service instance.\n     */\n    public function __construct(\n        protected string $model,\n        protected string $prompt,\n        protected float $temperature,\n        protected bool $stream,\n        protected bool $raw,\n    ) {}\n\n    /**\n     * Set LLM prompt text.\n     */\n    public function ask(): string\n    {\n        $httpClient = new Client;\n\n        $endpoint = core()->getConfigData('general.magic_ai.settings.api_domain').'/api/generate';\n\n        $result = $httpClient->request('POST', $endpoint, [\n            'headers' => [\n                'Accept' => 'application/json',\n            ],\n            'json'    => [\n                'model'  => $this->model,\n                'prompt' => $this->prompt,\n                'raw'    => $this->raw,\n                'stream' => $this->stream,\n            ],\n        ]);\n\n        $result = json_decode($result->getBody()->getContents(), true);\n\n        return $result['response'];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\RequestOptions;\n\nclass Ollama\n{\n    private string $model;\n    private string $prompt;\n    private float $temperature;\n    private bool $stream;\n    private bool $raw;\n\n    public function __construct(string $model, string $prompt, float $temperature = 0.7, bool $stream = false, bool $raw = false)\n    {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n    }\n\n    public function ask(): string\n    {\n        $client = new Client([\n            'base_uri' => 'http://localhost:11434', // Default Ollama API endpoint\n        ]);\n\n        $options = [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw,\n            ],\n            RequestOptions::HEADERS => [\n                'Accept' => 'application/json',\n            ],\n        ];\n\n\n        if ($this->stream) {\n            $response = '';\n            $stream = $client->post('/api/generate', $options)->getBody();\n            while (!$stream->eof()) {\n                $response .= $stream->read(1024);\n            }\n            return $response;\n\n        } else {\n            $response = $client->post('/api/generate', $options);\n            $data = json_decode($response->getBody(), true);\n            return $data['response'];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\RequestOptions;\n\nclass Ollama\n{\n    private string $model;\n    private string $prompt;\n    private float $temperature;\n    private bool $stream;\n    private bool $raw;\n\n    public function __construct(string $model, string $prompt, float $temperature = 0.7, bool $stream = false, bool $raw = false)\n    {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n    }\n\n    public function ask(): string\n    {\n        $client = new Client([\n            'base_uri' => 'http://localhost:11434', // Default Ollama API endpoint\n        ]);\n\n        $options = [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw,\n            ],\n            RequestOptions::HEADERS => [\n                'Accept' => 'application/json',\n            ],\n        ];\n\n\n        if ($this->stream) {\n            $response = '';\n            $stream = $client->post('/api/generate', $options)->getBody();\n            while (!$stream->eof()) {\n                $response .= $stream->read(1024);\n            }\n            return $response;\n\n        } else {\n            $response = $client->post('/api/generate', $options);\n            $data = json_decode($response->getBody(), true);\n            return $data['response'];\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\RequestOptions;\n\nclass Ollama\n{\n    private string $model;\n    private string $prompt;\n    private float $temperature;\n    private bool $stream;\n    private bool $raw;\n\n    public function __construct(string $model, string $prompt, float $temperature = 0.7, bool $stream = false, bool $raw = false)\n    {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n    }\n\n    public function ask(): string\n    {\n        $client = new Client([\n            'base_uri' => 'http://localhost:11434', // Default Ollama API endpoint\n        ]);\n\n        $options = [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw,\n            ],\n            RequestOptions::HEADERS => [\n                'Accept' => 'application/json',\n            ],\n        ];\n\n\n        if ($this->stream) {\n            $response = '';\n            $stream = $client->post('/api/generate', $options)->getBody();\n            while (!$stream->eof()) {\n                $response .= $stream->read(1024);\n            }\n            return $response;\n\n        } else {\n            $response = $client->post('/api/generate', $options);\n            $data = json_decode($response->getBody(), true);\n            return $data['response'];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\RequestOptions;\n\nclass Ollama\n{\n    private string $model;\n    private string $prompt;\n    private float $temperature;\n    private bool $stream;\n    private bool $raw;\n\n    public function __construct(string $model, string $prompt, float $temperature = 0.7, bool $stream = false, bool $raw = false)\n    {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n    }\n\n    public function ask(): string\n    {\n        $client = new Client([\n            'base_uri' => 'http://localhost:11434', // Default Ollama API endpoint\n        ]);\n\n        $options = [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw,\n            ],\n            RequestOptions::HEADERS => [\n                'Accept' => 'application/json',\n            ],\n        ];\n\n\n        if ($this->stream) {\n            $response = '';\n            $stream = $client->post('/api/generate', $options)->getBody();\n            while (!$stream->eof()) {\n                $response .= $stream->read(1024);\n            }\n            return $response;\n\n        } else {\n            $response = $client->post('/api/generate', $options);\n            $data = json_decode($response->getBody(), true);\n            return $data['response'];\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\RequestOptions;\n\nclass Ollama\n{\n    private string $model;\n    private string $prompt;\n    private float $temperature;\n    private bool $stream;\n    private bool $raw;\n\n    public function __construct(string $model, string $prompt, float $temperature = 0.7, bool $stream = false, bool $raw = false)\n    {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n    }\n\n    public function ask(): string\n    {\n        $client = new Client([\n            'base_uri' => 'http://localhost:11434', // Default Ollama API endpoint\n        ]);\n\n        $options = [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw,\n            ],\n            RequestOptions::HEADERS => [\n                'Accept' => 'application/json',\n            ],\n        ];\n\n\n        if ($this->stream) {\n            $response = '';\n            $stream = $client->post('/api/generate', $options)->getBody();\n            while (!$stream->eof()) {\n                $response .= $stream->read(1024);\n            }\n            return $response;\n\n        } else {\n            $response = $client->post('/api/generate', $options);\n            $data = json_decode($response->getBody(), true);\n            return $data['response'];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\RequestOptions;\n\nclass Ollama\n{\n    private string $model;\n    private string $prompt;\n    private float $temperature;\n    private bool $stream;\n    private bool $raw;\n\n    public function __construct(string $model, string $prompt, float $temperature = 0.7, bool $stream = false, bool $raw = false)\n    {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n    }\n\n    public function ask(): string\n    {\n        $client = new Client([\n            'base_uri' => 'http://localhost:11434', // Default Ollama API endpoint\n        ]);\n\n        $options = [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw,\n            ],\n            RequestOptions::HEADERS => [\n                'Accept' => 'application/json',\n            ],\n        ];\n\n\n        if ($this->stream) {\n            $response = '';\n            $stream = $client->post('/api/generate', $options)->getBody();\n            while (!$stream->eof()) {\n                $response .= $stream->read(1024);\n            }\n            return $response;\n\n        } else {\n            $response = $client->post('/api/generate', $options);\n            $data = json_decode($response->getBody(), true);\n            return $data['response'];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\RequestOptions;\n\nclass Ollama\n{\n    private string $model;\n    private string $prompt;\n    private float $temperature;\n    private bool $stream;\n    private bool $raw;\n\n    public function __construct(string $model, string $prompt, float $temperature = 0.7, bool $stream = false, bool $raw = false)\n    {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n    }\n\n    public function ask(): string\n    {\n        $client = new Client([\n            'base_uri' => 'http://localhost:11434', // Default Ollama API endpoint\n        ]);\n\n        $options = [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw,\n            ],\n            RequestOptions::HEADERS => [\n                'Accept' => 'application/json',\n            ],\n        ];\n\n\n        if ($this->stream) {\n            $response = '';\n            $stream = $client->post('/api/generate', $options)->getBody();\n            while (!$stream->eof()) {\n                $response .= $stream->read(1024);\n            }\n            return $response;\n\n        } else {\n            $response = $client->post('/api/generate', $options);\n            $data = json_decode($response->getBody(), true);\n            return $data['response'];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\RequestOptions;\n\nclass Ollama\n{\n    private string $model;\n    private string $prompt;\n    private float $temperature;\n    private bool $stream;\n    private bool $raw;\n\n    public function __construct(string $model, string $prompt, float $temperature = 0.7, bool $stream = false, bool $raw = false)\n    {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n    }\n\n    public function ask(): string\n    {\n        $client = new Client([\n            'base_uri' => 'http://localhost:11434', // Default Ollama API endpoint\n        ]);\n\n        $options = [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw,\n            ],\n            RequestOptions::HEADERS => [\n                'Accept' => 'application/json',\n            ],\n        ];\n\n\n        if ($this->stream) {\n            $response = '';\n            $stream = $client->post('/api/generate', $options)->getBody();\n            while (!$stream->eof()) {\n                $response .= $stream->read(1024);\n            }\n            return $response;\n\n        } else {\n            $response = $client->post('/api/generate', $options);\n            $data = json_decode($response->getBody(), true);\n            return $data['response'];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\RequestOptions;\n\nclass Ollama\n{\n    private string $model;\n    private string $prompt;\n    private float $temperature;\n    private bool $stream;\n    private bool $raw;\n\n    public function __construct(string $model, string $prompt, float $temperature = 0.7, bool $stream = false, bool $raw = false)\n    {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n    }\n\n    public function ask(): string\n    {\n        $client = new Client([\n            'base_uri' => 'http://localhost:11434', // Default Ollama API endpoint\n        ]);\n\n        $options = [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw,\n            ],\n            RequestOptions::HEADERS => [\n                'Accept' => 'application/json',\n            ],\n        ];\n\n\n        if ($this->stream) {\n            $response = '';\n            $stream = $client->post('/api/generate', $options)->getBody();\n            while (!$stream->eof()) {\n                $response .= $stream->read(1024);\n            }\n            return $response;\n\n        } else {\n            $response = $client->post('/api/generate', $options);\n            $data = json_decode($response->getBody(), true);\n            return $data['response'];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\RequestOptions;\n\nclass Ollama\n{\n    private string $model;\n    private string $prompt;\n    private float $temperature;\n    private bool $stream;\n    private bool $raw;\n\n    public function __construct(string $model, string $prompt, float $temperature = 0.7, bool $stream = false, bool $raw = false)\n    {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n    }\n\n    public function ask(): string\n    {\n        $client = new Client([\n            'base_uri' => 'http://localhost:11434', // Default Ollama API endpoint\n        ]);\n\n        $options = [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw,\n            ],\n            RequestOptions::HEADERS => [\n                'Accept' => 'application/json',\n            ],\n        ];\n\n\n        if ($this->stream) {\n            $response = '';\n            $stream = $client->post('/api/generate', $options)->getBody();\n            while (!$stream->eof()) {\n                $response .= $stream->read(1024);\n            }\n            return $response;\n\n        } else {\n            $response = $client->post('/api/generate', $options);\n            $data = json_decode($response->getBody(), true);\n            return $data['response'];\n        }\n    }\n}\n?>\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client for sending payment requests to an e-payment API using Guzzle.\n\nClass Description: The EpayHttpClient class is designed to handle HTTP communication with an e-payment API. It encapsulates the functionality for sending payment requests and processing the responses. The class uses Guzzle HTTP client for making requests and handles potential exceptions that may occur during the process.\n\nAttributes:\n- epay: array - Stores the configuration for the e-payment API\n- client: Client - The Guzzle HTTP client instance used for making requests\n\nMethods:\n- __construct(array $epayConfig) -> void - Initializes the class with e-payment configuration and creates a new Guzzle Client instance\n- sendPaymentRequest(array $data) -> array - Sends a payment request to the API endpoint and processes the response. Returns an array indicating success/failure and containing either the payment URL or an error message",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    protected array $epay;\n    protected Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $res = $this->client->request('POST', $this->epay['apiurl'] . 'mapi.php', ['form_params' => $data]);\n\n            if ($res->getStatusCode() !== 200) {\n                throw new Exception();\n            }\n\n            $resData = json_decode($res->getBody()->__toString(), true);\n\n            if ($resData['code'] !== 1 || !isset($resData['payurl'])) {\n                throw new Exception();\n            }\n\n            return [\n                'success' => true,\n                'payurl' => $resData['payurl']\n            ];\n        } catch (Exception|GuzzleException) {\n            return [\n                'success' => false,\n                'error' => '请求支付失败'\n            ];\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    private array $epay;\n    private Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['api_url'], [\n                'form_params' => $data,\n            ]);\n\n            $responseBody = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200 && isset($responseBody['payment_url'])) {\n                return [\n                    'success' => true,\n                    'payment_url' => $responseBody['payment_url'],\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => $responseBody['error'] ?? 'An unknown error occurred.',\n                ];\n            }\n        } catch (GuzzleException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage(),\n            ];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    private array $epay;\n    private Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['api_url'], [\n                'form_params' => $data,\n                'headers' => [\n                    'Authorization' => 'Bearer ' . $this->epay['api_key'],\n                ],\n            ]);\n\n            $responseBody = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200 && isset($responseBody['payment_url'])) {\n                return [\n                    'success' => true,\n                    'payment_url' => $responseBody['payment_url'],\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => $responseBody['error'] ?? 'An error occurred during payment processing.',\n                ];\n            }\n        } catch (GuzzleException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage(),\n            ];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    private array $epay;\n    private Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['api_url'], [\n                'form_params' => $data,\n            ]);\n\n            $responseBody = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200 && isset($responseBody['payment_url'])) {\n                return [\n                    'success' => true,\n                    'payment_url' => $responseBody['payment_url'],\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => $responseBody['error'] ?? 'An error occurred during payment processing.',\n                ];\n            }\n        } catch (GuzzleException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage(),\n            ];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    private array $epay;\n    private Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['api_url'], [\n                'form_params' => $data,\n            ]);\n\n            $responseBody = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200 && isset($responseBody['payment_url'])) {\n                return [\n                    'success' => true,\n                    'payment_url' => $responseBody['payment_url'],\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => $responseBody['error'] ?? 'An error occurred during payment processing.',\n                ];\n            }\n        } catch (GuzzleException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage(),\n            ];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    private array $epay;\n    private Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['api_url'], [\n                'form_params' => $data,\n            ]);\n\n            $responseBody = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200 && isset($responseBody['payment_url'])) {\n                return [\n                    'success' => true,\n                    'payment_url' => $responseBody['payment_url'],\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => $responseBody['error'] ?? 'An error occurred during payment processing.',\n                ];\n            }\n        } catch (GuzzleException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage(),\n            ];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    private array $epay;\n    private Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['api_url'], [\n                'form_params' => $data,\n            ]);\n\n            $responseBody = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200 && isset($responseBody['payment_url'])) {\n                return [\n                    'success' => true,\n                    'payment_url' => $responseBody['payment_url'],\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => $responseBody['error'] ?? 'An error occurred during payment processing.',\n                ];\n            }\n        } catch (GuzzleException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage(),\n            ];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    private array $epay;\n    private Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['api_url'], [\n                'form_params' => $data,\n            ]);\n\n            $responseBody = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200 && isset($responseBody['payment_url'])) {\n                return [\n                    'success' => true,\n                    'payment_url' => $responseBody['payment_url'],\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => $responseBody['error'] ?? 'An error occurred during payment processing.',\n                ];\n            }\n        } catch (GuzzleException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage(),\n            ];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    private array $epay;\n    private Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['api_url'], [\n                'form_params' => $data,\n            ]);\n\n            $responseBody = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200 && isset($responseBody['payment_url'])) {\n                return [\n                    'success' => true,\n                    'payment_url' => $responseBody['payment_url'],\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => $responseBody['error'] ?? 'An error occurred during payment processing.',\n                ];\n            }\n        } catch (GuzzleException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage(),\n            ];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    private array $epay;\n    private Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['api_url'], [\n                'form_params' => $data,\n                'headers' => [\n                    'Authorization' => 'Bearer ' . $this->epay['api_key'],\n                ],\n            ]);\n\n            $responseBody = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200 && isset($responseBody['payment_url'])) {\n                return [\n                    'success' => true,\n                    'payment_url' => $responseBody['payment_url'],\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => $responseBody['message'] ?? 'An error occurred during payment processing.',\n                ];\n            }\n        } catch (GuzzleException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage(),\n            ];\n        }\n    }\n}\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    private array $epay;\n    private Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['api_url'], [\n                'form_params' => $data,\n            ]);\n\n            $responseBody = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200 && isset($responseBody['payment_url'])) {\n                return [\n                    'success' => true,\n                    'payment_url' => $responseBody['payment_url'],\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => $responseBody['error'] ?? 'An error occurred during payment processing.',\n                ];\n            }\n        } catch (GuzzleException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage(),\n            ];\n        }\n    }\n}\n?>\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 100,
    "Instruction": "Task Description: Create a PHP class that handles downloading and processing images with size limitations and compression capabilities.\n\nClass Description: The Picture class is designed to download images from given URLs while enforcing size limits and compression thresholds. It uses cURL for HTTP requests and provides mechanisms to control download size and handle response data efficiently.\n\nAttributes:\n- compressLimit: [int] - The maximum size (in bytes) for downloaded content before compression is considered\n- sizeLimit: [int] - The maximum dimension (in pixels) for the image width/height\n\nMethods:\n- downloadImage: [downloadImage]($url: string) -> string - Downloads an image from the specified URL while respecting size limits. Returns the image body content.\n  - $url: The URL of the image to download\n  - Returns: The binary content of the downloaded image",
    "Canonical_solution": "namespace App\\Widgets\\Picture;\n\nuse Movim\\Image;\n\nclass Picture\n{\n    private $compressLimit = SMALL_PICTURE_LIMIT * 6;\n    private $sizeLimit = 1920;\n\n    public function downloadImage($url)\n    {\n        $headers = requestHeaders($url);\n        $chunks = '';\n\n        $max = $headers[\"download_content_length\"] > $this->compressLimit ? $this->compressLimit : $headers[\"download_content_length\"];\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n        curl_setopt($ch, CURLOPT_RANGE, '0-' . $max);\n        curl_setopt($ch, CURLOPT_BUFFERSIZE, 12800);\n        curl_setopt($ch, CURLOPT_NOPROGRESS, false);\n        curl_setopt($ch, CURLOPT_USERAGENT, DEFAULT_HTTP_USER_AGENT);\n        curl_setopt($ch, CURLOPT_WRITEFUNCTION, function ($ch, $chunk) use (&$chunks) {\n            $chunks .= $chunk;\n            return (strlen($chunks) >= $this->compressLimit + 1) ? 0 : strlen($chunk);\n        });\n\n        curl_exec($ch);\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        curl_close($ch);\n\n        $headers = preg_split('/[\\r\\n]+/', substr($chunks, 0, $headerSize));\n        $body = substr($chunks, $headerSize);\n\n        return $body;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Picture {\n    public int $compressLimit;\n    public int $sizeLimit;\n\n    public function __construct(int $compressLimit = 102400, int $sizeLimit = 1000) {\n        $this->compressLimit = $compressLimit;\n        $this->sizeLimit = $sizeLimit;\n    }\n\n    public function downloadImage(string $url): string {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 3);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n\n        $imageData = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if ($httpCode !== 200 || $imageData === false) {\n            curl_close($ch);\n            return '';\n        }\n\n        $imageSize = strlen($imageData);\n\n        if ($imageSize > $this->compressLimit) {\n            // Placeholder for compression logic (implementation omitted for brevity)\n            // Example: $imageData = compressImage($imageData);\n        }\n\n\n        $imageInfo = getimagesizefromstring($imageData);\n        if ($imageInfo === false || $imageInfo[0] > $this->sizeLimit || $imageInfo[1] > $this->sizeLimit) {\n            curl_close($ch);\n            return '';\n        }\n\n        curl_close($ch);\n        return $imageData;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Picture {\n    public int $compressLimit;\n    public int $sizeLimit;\n\n    public function __construct(int $compressLimit = 1024 * 1024, int $sizeLimit = 2000) {\n        $this->compressLimit = $compressLimit;\n        $this->sizeLimit = $sizeLimit;\n    }\n\n    public function downloadImage(string $url): string {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_BUFFERSIZE, 4096);\n        $imageData = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new Exception(\"Error downloading image: \" . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode !== 200) {\n            throw new Exception(\"HTTP error: \" . $httpCode);\n        }\n\n        curl_close($ch);\n\n\n        $imageSize = strlen($imageData);\n        if ($imageSize > $this->compressLimit) {\n           $imageData = $this->compressImage($imageData);\n        }\n\n\n        $imageInfo = getimagesizefromstring($imageData);\n        if ($imageInfo === false) {\n            throw new Exception(\"Invalid image data\");\n        }\n\n        $width = $imageInfo[0];\n        $height = $imageInfo[1];\n\n        if ($width > $this->sizeLimit || $height > $this->sizeLimit) {\n            throw new Exception(\"Image dimensions exceed limit\");\n        }\n\n        return $imageData;\n    }\n\n\n    private function compressImage(string $imageData): string {\n        $imageInfo = getimagesizefromstring($imageData);\n        $mimeType = $imageInfo['mime'];\n\n        switch ($mimeType) {\n            case 'image/jpeg':\n                $image = imagecreatefromstring($imageData);\n                ob_start();\n                imagejpeg($image, null, 80);\n                $compressedData = ob_get_clean();\n                imagedestroy($image);\n                return $compressedData;\n            case 'image/png':\n                $image = imagecreatefromstring($imageData);\n                ob_start();\n                imagepng($image, null, 6);\n                $compressedData = ob_get_clean();\n                imagedestroy($image);\n                return $compressedData;\n            default:\n                return $imageData;\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass Picture {\n    public int $compressLimit;\n    public int $sizeLimit;\n\n    public function __construct(int $compressLimit = 1024 * 1024, int $sizeLimit = 2000) {\n        $this->compressLimit = $compressLimit;\n        $this->sizeLimit = $sizeLimit;\n    }\n\n    public function downloadImage(string $url): string {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_BUFFERSIZE, 4096);\n\n        $imageData = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if ($httpCode !== 200 || $imageData === false) {\n            curl_close($ch);\n            throw new Exception(\"Failed to download image. HTTP Code: \" . $httpCode . \", Error: \" . curl_error($ch));\n        }\n\n        $imageSize = strlen($imageData);\n\n        if ($imageSize > $this->compressLimit) {\n            // Placeholder for compression logic (implementation omitted for brevity)\n            // Example: $imageData = compressImage($imageData);\n        }\n\n\n        $imageInfo = getimagesizefromstring($imageData);\n        if ($imageInfo === false) {\n            curl_close($ch);\n            throw new Exception(\"Invalid image data.\");\n        }\n\n        $width = $imageInfo[0];\n        $height = $imageInfo[1];\n\n        if ($width > $this->sizeLimit || $height > $this->sizeLimit) {\n            curl_close($ch);\n            throw new Exception(\"Image dimensions exceed the limit.\");\n        }\n\n        curl_close($ch);\n        return $imageData;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Picture {\n    public int $compressLimit;\n    public int $sizeLimit;\n\n    public function __construct(int $compressLimit = 102400, int $sizeLimit = 1024) {\n        $this->compressLimit = $compressLimit;\n        $this->sizeLimit = $sizeLimit;\n    }\n\n    public function downloadImage(string $url): string {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_BUFFERSIZE, 4096);\n        $imageData = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if ($httpCode !== 200 || $imageData === false) {\n            curl_close($ch);\n            return '';\n        }\n\n        $imageSize = strlen($imageData);\n\n        if ($imageSize > $this->compressLimit) {\n            // Placeholder for compression logic.  In a real implementation, image compression would occur here.\n        }\n\n\n        $imageInfo = getimagesizefromstring($imageData);\n        if ($imageInfo === false) {\n            curl_close($ch);\n            return '';\n        }\n\n        $width = $imageInfo[0];\n        $height = $imageInfo[1];\n\n        if ($width > $this->sizeLimit || $height > $this->sizeLimit) {\n            // Placeholder for resizing logic. In a real implementation, image resizing would occur here.\n        }\n\n        curl_close($ch);\n        return $imageData;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Picture {\n    public int $compressLimit;\n    public int $sizeLimit;\n\n    public function __construct(int $compressLimit = 102400, int $sizeLimit = 1024) {\n        $this->compressLimit = $compressLimit;\n        $this->sizeLimit = $sizeLimit;\n    }\n\n    public function downloadImage(string $url): string {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_BUFFERSIZE, 4096);\n        $imageData = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new Exception('Error downloading image: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode !== 200) {\n            throw new Exception('HTTP error: ' . $httpCode);\n        }\n\n        curl_close($ch);\n\n\n        $imageSize = strlen($imageData);\n        if ($imageSize > $this->compressLimit) {\n            // Placeholder for compression logic (implementation omitted for brevity)\n            // In a real implementation, image compression would occur here.\n        }\n\n        $imageInfo = getimagesizefromstring($imageData);\n        if ($imageInfo === false) {\n            throw new Exception(\"Invalid image data\");\n        }\n\n        $width = $imageInfo[0];\n        $height = $imageInfo[1];\n\n        if ($width > $this->sizeLimit || $height > $this->sizeLimit) {\n            // Placeholder for resizing logic (implementation omitted for brevity)\n            // In a real implementation, image resizing would occur here.\n        }\n\n        return $imageData;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Picture {\n    public int $compressLimit;\n    public int $sizeLimit;\n\n    public function __construct(int $compressLimit = 1024 * 1024, int $sizeLimit = 2000) {\n        $this->compressLimit = $compressLimit;\n        $this->sizeLimit = $sizeLimit;\n    }\n\n    public function downloadImage(string $url): string {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_BUFFERSIZE, 128 * 1024); // Use a reasonable buffer size\n\n        $imageData = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if ($httpCode !== 200 || $imageData === false) {\n            curl_close($ch);\n            throw new Exception(\"Failed to download image. HTTP Code: \" . $httpCode . \", Error: \" . curl_error($ch));\n        }\n\n\n        $imageSize = strlen($imageData);\n\n        if ($imageSize > $this->compressLimit) {\n            // Handle compression if needed (implementation omitted for brevity)\n        }\n\n        $imageInfo = getimagesizefromstring($imageData);\n        if ($imageInfo === false) {\n            curl_close($ch);\n            throw new Exception(\"Invalid image data.\");\n        }\n\n        $width = $imageInfo[0];\n        $height = $imageInfo[1];\n\n        if ($width > $this->sizeLimit || $height > $this->sizeLimit) {\n            curl_close($ch);\n            throw new Exception(\"Image dimensions exceed the limit.\");\n        }\n\n        curl_close($ch);\n        return $imageData;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Picture {\n    public int $compressLimit;\n    public int $sizeLimit;\n\n    public function __construct(int $compressLimit = 1024 * 1024, int $sizeLimit = 2000) {\n        $this->compressLimit = $compressLimit;\n        $this->sizeLimit = $sizeLimit;\n    }\n\n    public function downloadImage(string $url): string {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_BUFFERSIZE, 128 * 1024); // Use a larger buffer size\n\n        $imageData = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if ($httpCode !== 200 || $imageData === false) {\n            curl_close($ch);\n            throw new Exception(\"Failed to download image. HTTP Code: \" . $httpCode . \" - Error: \" . curl_error($ch));\n        }\n\n\n        $imageSize = strlen($imageData);\n\n        if ($imageSize > $this->compressLimit) {\n            // Handle compression if needed (implementation omitted for brevity)\n        }\n\n        $imageInfo = getimagesizefromstring($imageData);\n        if ($imageInfo === false) {\n            curl_close($ch);\n            throw new Exception(\"Invalid image data.\");\n        }\n\n        $width = $imageInfo[0];\n        $height = $imageInfo[1];\n\n        if ($width > $this->sizeLimit || $height > $this->sizeLimit) {\n            curl_close($ch);\n            throw new Exception(\"Image dimensions exceed the limit.\");\n        }\n\n        curl_close($ch);\n        return $imageData;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Picture {\n    public int $compressLimit;\n    public int $sizeLimit;\n\n    public function __construct(int $compressLimit = 1024 * 1024, int $sizeLimit = 2000) {\n        $this->compressLimit = $compressLimit;\n        $this->sizeLimit = $sizeLimit;\n    }\n\n    public function downloadImage(string $url): string {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_BUFFERSIZE, 4096);\n\n        $imageData = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if ($httpCode !== 200 || $imageData === false) {\n            curl_close($ch);\n            throw new Exception(\"Failed to download image. HTTP Code: \" . $httpCode . \" URL: \" . $url);\n        }\n\n        $imageSize = strlen($imageData);\n\n        if ($imageSize > $this->compressLimit) {\n            // Placeholder for compression logic (implementation omitted for brevity)\n            // In a real-world scenario, image compression would be performed here.\n        }\n\n\n        $imageInfo = getimagesizefromstring($imageData);\n        if ($imageInfo === false) {\n            curl_close($ch);\n            throw new Exception(\"Invalid image data received from URL: \" . $url);\n        }\n\n        $width = $imageInfo[0];\n        $height = $imageInfo[1];\n\n        if ($width > $this->sizeLimit || $height > $this->sizeLimit) {\n            curl_close($ch);\n            throw new Exception(\"Image dimensions exceed the limit (\" . $this->sizeLimit . \"px). Width: \" . $width . \", Height: \" . $height);\n        }\n\n        curl_close($ch);\n        return $imageData;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Picture {\n    public int $compressLimit;\n    public int $sizeLimit;\n\n    public function __construct(int $compressLimit = 102400, int $sizeLimit = 1024) {\n        $this->compressLimit = $compressLimit;\n        $this->sizeLimit = $sizeLimit;\n    }\n\n    public function downloadImage(string $url): string {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_BUFFERSIZE, 4096);\n        $imageData = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            curl_close($ch);\n            throw new Exception(\"Error downloading image: \" . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode !== 200) {\n            curl_close($ch);\n            throw new Exception(\"HTTP error: \" . $httpCode);\n        }\n\n        curl_close($ch);\n\n\n        $imageSize = strlen($imageData);\n        if ($imageSize > $this->compressLimit) {\n            // Placeholder for compression logic (implementation omitted for brevity)\n            // In a real implementation, you would use image compression libraries here\n            // For example, using GD or Imagick to compress the $imageData\n        }\n\n        $imageInfo = getimagesizefromstring($imageData);\n        if ($imageInfo === false) {\n            throw new Exception(\"Invalid image data\");\n        }\n\n        $width = $imageInfo[0];\n        $height = $imageInfo[1];\n\n        if ($width > $this->sizeLimit || $height > $this->sizeLimit) {\n            // Placeholder for resizing logic (implementation omitted for brevity)\n            // In a real implementation, you would use image manipulation libraries here\n            // For example, using GD or Imagick to resize the image based on $this->sizeLimit\n        }\n\n        return $imageData;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Picture {\n    public int $compressLimit;\n    public int $sizeLimit;\n\n    public function __construct(int $compressLimit = 102400, int $sizeLimit = 1024) {\n        $this->compressLimit = $compressLimit;\n        $this->sizeLimit = $sizeLimit;\n    }\n\n    public function downloadImage(string $url): string {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_BUFFERSIZE, 4096);\n        $imageData = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new Exception('Error downloading image: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode !== 200) {\n            throw new Exception('HTTP error: ' . $httpCode);\n        }\n\n        curl_close($ch);\n\n\n        $imageSize = strlen($imageData);\n        if ($imageSize > $this->compressLimit) {\n            // Placeholder for compression logic (implementation omitted for brevity)\n            // In a real implementation, image compression would occur here\n            // For example, using GD or ImageMagick libraries\n        }\n\n        $imageInfo = getimagesizefromstring($imageData);\n        if ($imageInfo === false) {\n            throw new Exception('Invalid image data');\n        }\n\n        $width = $imageInfo[0];\n        $height = $imageInfo[1];\n\n        if ($width > $this->sizeLimit || $height > $this->sizeLimit) {\n            // Placeholder for resizing logic (implementation omitted for brevity)\n            // In a real implementation, image resizing would occur here\n            // For example, using GD or ImageMagick libraries\n        }\n\n        return $imageData;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a PHP function that fetches content from a specified HTTP URL using fsockopen for low-level HTTP communication, with support for proxies and basic authentication.\n\nFunction Description: The function establishes a TCP connection to an HTTP server (or proxy), sends an HTTP GET request, reads the response, and returns the response body. It handles URL parsing, proxy configuration, timeout settings, and basic authentication. The function can either return the content directly or assign it to a template variable.\n\nInput:\n- $params: An associative array containing:\n  - 'file': (string, required) The HTTP URL to fetch\n  - 'assign': (string, optional) Template variable name to assign content to\n  - 'proxy_host': (string, optional) Proxy server hostname\n  - 'proxy_port': (int, optional) Proxy server port\n  - 'timeout': (int, optional) Connection timeout in seconds (default: 30)\n- $template: (object) The template object for assigning content (when 'assign' parameter is used)\n\nOutput:\n- Returns the fetched content as a string if 'assign' parameter is not provided\n- Assigns content to the specified template variable and returns nothing if 'assign' parameter is provided\n- Returns nothing and triggers notice on error conditions (invalid URL, connection failure)",
    "Canonical_solution": "function smarty_function_fetch($params, $template)\n{\n    if (empty($params['file'])) {\n        trigger_error(\"[plugin] fetch parameter 'file' cannot be empty\", E_USER_NOTICE);\n        return;\n    }\n\n    $content = '';\n    if (preg_match('!^http://!i', $params['file'])) {\n        if ($uri_parts = parse_url($params['file'])) {\n            $host = $server_name = $uri_parts['host'];\n            $timeout = 30;\n            $port = empty($uri_parts['port']) ? 80 : $uri_parts['port'];\n            $user = empty($uri_parts['user']) ? null : $uri_parts['user'];\n            $pass = empty($uri_parts['pass']) ? null : $uri_parts['pass'];\n            $uri = !empty($uri_parts['path']) ? $uri_parts['path'] : '/';\n            $uri .= !empty($uri_parts['query']) ? '?' . $uri_parts['query'] : '';\n            \n            $_is_proxy = false;\n            foreach ($params as $param_key => $param_value) {\n                switch ($param_key) {\n                    case \"proxy_host\":\n                        $proxy_host = $param_value;\n                        break;\n                    case \"proxy_port\":\n                        $proxy_port = (int)$param_value;\n                        break;\n                    case \"timeout\":\n                        $timeout = (int)$param_value;\n                        break;\n                }\n            }\n\n            if (!empty($proxy_host) && !empty($proxy_port)) {\n                $_is_proxy = true;\n                $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, $timeout);\n            } else {\n                $fp = fsockopen($server_name, $port, $errno, $errstr, $timeout);\n            }\n\n            if (!$fp) {\n                trigger_error(\"[plugin] unable to fetch: $errstr ($errno)\", E_USER_NOTICE);\n                return;\n            }\n\n            if ($_is_proxy) {\n                fputs($fp, 'GET ' . $params['file'] . \" HTTP/1.0\\r\\n\");\n            } else {\n                fputs($fp, \"GET $uri HTTP/1.0\\r\\n\");\n            }\n            fputs($fp, \"Host: $host\\r\\n\");\n            if (!empty($user) && !empty($pass)) {\n                fputs($fp, \"Authorization: BASIC \" . base64_encode(\"$user:$pass\") . \"\\r\\n\");\n            }\n            fputs($fp, \"\\r\\n\");\n\n            while (!feof($fp)) {\n                $content .= fgets($fp, 4096);\n            }\n            fclose($fp);\n\n            $csplit = preg_split(\"!\\r\\n\\r\\n!\", $content, 2);\n            $content = $csplit[1];\n        }\n    }\n\n    if (!empty($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 131,
    "matched_results": [
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        trigger_error(\"Invalid URL: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n    $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';\n\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    if (isset($params['proxy_host']) && $params['proxy_host']) {\n        $fp = @fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        trigger_error(\"Connection failed: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . $scheme . \"://\" . $request_host . $path . $query . \" HTTP/1.1\\r\\n\";\n    $request .= \"Host: \" . $host . \"\\r\\n\";\n\n    if (isset($url_parts['user']) && isset($url_parts['pass'])) {\n        $auth = base64_encode($url_parts['user'] . ':' . $url_parts['pass']);\n        $request .= \"Authorization: Basic \" . $auth . \"\\r\\n\";\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        trigger_error(\"Invalid URL: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    $fp = @fsockopen(\n        isset($params['proxy_host']) ? $params['proxy_host'] : $host,\n        isset($params['proxy_port']) ? $params['proxy_port'] : $port,\n        $errno,\n        $errstr,\n        $timeout\n    );\n\n    if (!$fp) {\n        trigger_error(\"Connection failed: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . (isset($params['proxy_host']) ? $params['file'] : $path . $query) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $host . \"\\r\\n\";\n\n    if (isset($url_parts['user']) && isset($url_parts['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($url_parts['user'] . \":\" . $url_parts['pass']) . \"\\r\\n\";\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        trigger_error(\"Invalid URL: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    $fp = @fsockopen(\n        isset($params['proxy_host']) ? $params['proxy_host'] : $host,\n        isset($params['proxy_port']) ? $params['proxy_port'] : $port,\n        $errno,\n        $errstr,\n        $timeout\n    );\n\n    if (!$fp) {\n        trigger_error(\"Connection failed: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . (isset($params['proxy_host']) ? $params['file'] : $path . $query) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $host . \"\\r\\n\";\n\n    if (isset($url_parts['user']) && isset($url_parts['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($url_parts['user'] . \":\" . $url_parts['pass']) . \"\\r\\n\";\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        trigger_error(\"Invalid URL: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    $fp = @fsockopen(\n        isset($params['proxy_host']) ? $params['proxy_host'] : $host,\n        isset($params['proxy_port']) ? $params['proxy_port'] : $port,\n        $errno,\n        $errstr,\n        $timeout\n    );\n\n    if (!$fp) {\n        trigger_error(\"Connection failed: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . (isset($params['proxy_host']) ? $params['file'] : $path . $query) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $host . \"\\r\\n\";\n\n    if (isset($url_parts['user']) && isset($url_parts['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($url_parts['user'] . \":\" . $url_parts['pass']) . \"\\r\\n\";\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        trigger_error(\"Invalid URL: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : null;\n    $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : null;\n\n    if ($proxy_host) {\n        $fp = @fsockopen($proxy_host, $proxy_port, $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        trigger_error(\"Connection failed: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . $path . $query . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $request_host . \"\\r\\n\";\n\n    if (isset($url_parts['user']) && isset($url_parts['pass'])) {\n        $auth = base64_encode($url_parts['user'] . ':' . $url_parts['pass']);\n        $request .= \"Authorization: Basic \" . $auth . \"\\r\\n\";\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        trigger_error(\"Invalid URL: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    $fp = @fsockopen(\n        isset($params['proxy_host']) ? $params['proxy_host'] : $host,\n        isset($params['proxy_port']) ? $params['proxy_port'] : $port,\n        $errno,\n        $errstr,\n        $timeout\n    );\n\n    if (!$fp) {\n        trigger_error(\"Connection failed: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . (isset($params['proxy_host']) ? $params['file'] : $path . $query) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $host . \"\\r\\n\";\n\n    if (isset($url_parts['user']) && isset($url_parts['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($url_parts['user'] . \":\" . $url_parts['pass']) . \"\\r\\n\";\n    }\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        trigger_error(\"Invalid URL: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : null;\n    $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : null;\n\n    if ($proxy_host) {\n        $fp = @fsockopen($proxy_host, $proxy_port, $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        trigger_error(\"Connection failed: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . $path . $query . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $request_host . \"\\r\\n\";\n\n    if (isset($url_parts['user']) && isset($url_parts['pass'])) {\n        $auth = base64_encode($url_parts['user'] . ':' . $url_parts['pass']);\n        $request .= \"Authorization: Basic \" . $auth . \"\\r\\n\";\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        trigger_error(\"Invalid URL: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    $fp = @fsockopen(\n        isset($params['proxy_host']) ? $params['proxy_host'] : $host,\n        isset($params['proxy_port']) ? $params['proxy_port'] : $port,\n        $errno,\n        $errstr,\n        $timeout\n    );\n\n    if (!$fp) {\n        trigger_error(\"Connection failed: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . (isset($params['proxy_host']) ? $params['file'] : $path . $query) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $host . \"\\r\\n\";\n\n    if (isset($url_parts['user']) && isset($url_parts['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($url_parts['user'] . \":\" . $url_parts['pass']) . \"\\r\\n\";\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        trigger_error(\"Invalid URL: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    $fp = @fsockopen(\n        isset($params['proxy_host']) ? $params['proxy_host'] : $host,\n        isset($params['proxy_port']) ? $params['proxy_port'] : $port,\n        $errno,\n        $errstr,\n        $timeout\n    );\n\n    if (!$fp) {\n        trigger_error(\"Connection failed: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . (isset($params['proxy_host']) ? $params['file'] : $path . $query) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $host . \"\\r\\n\";\n\n    if (isset($url_parts['user']) && isset($url_parts['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($url_parts['user'] . \":\" . $url_parts['pass']) . \"\\r\\n\";\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        trigger_error(\"Invalid URL: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    $fp = @fsockopen(\n        isset($params['proxy_host']) ? $params['proxy_host'] : $host,\n        isset($params['proxy_port']) ? $params['proxy_port'] : $port,\n        $errno,\n        $errstr,\n        $timeout\n    );\n\n    if (!$fp) {\n        trigger_error(\"Connection failed: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . (isset($params['proxy_host']) ? $params['file'] : $path . $query) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $host . \"\\r\\n\";\n\n    if (isset($url_parts['user']) && isset($url_parts['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($url_parts['user'] . \":\" . $url_parts['pass']) . \"\\r\\n\";\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 102,
    "Instruction": "Task Description: Create a PHP function that fetches content from a specified URL or file path, with support for HTTP requests using fsockopen, including handling of proxy servers, authentication, and security checks.\n\nFunction Description: The function retrieves content from either a local file or a remote HTTP resource. For HTTP requests, it establishes a socket connection, sends a GET request with appropriate headers (including authentication if provided), reads the response, and extracts the content body. It includes security checks for trusted URIs and resource directories when operating within a Smarty template context.\n\nInput:\n- $params: An associative array containing:\n  - 'file': (string) Required. The URL or file path to fetch\n  - 'assign': (string) Optional. Template variable name to assign the content to\n  - 'assign_headers': (string) Optional. Template variable name to assign headers to\n  - 'user': (string) Optional. Username for HTTP authentication\n  - 'pass': (string) Optional. Password for HTTP authentication\n  - 'proxy_host': (string) Optional. Proxy server hostname\n  - 'proxy_port': (integer) Optional. Proxy server port\n- $template: The Smarty template object (used for security checks and variable assignment)\n\nOutput:\n- Returns the fetched content as a string if no 'assign' parameter is provided\n- Assigns the content to the specified template variable if 'assign' parameter is present\n- Returns nothing if security checks fail or if there are errors in fetching the content",
    "Canonical_solution": "function smarty_function_fetch($params, $template)\n{\n    if (empty($params['file'])) {\n        trigger_error(\"[plugin] fetch parameter 'file' cannot be empty\",E_USER_NOTICE);\n        return;\n    }\n\n    if (stripos($params['file'], 'file://') === 0) {\n        $params['file'] = substr($params['file'], 7);\n    }\n\n    $protocol = strpos($params['file'], '://');\n    if ($protocol !== false) {\n        $protocol = strtolower(substr($params['file'], 0, $protocol));\n    }\n\n    if (isset($template->smarty->security_policy)) {\n        if ($protocol) {\n            if (!$template->smarty->security_policy->isTrustedUri($params['file'])) {\n                return;\n            }\n        } else {\n            if (!$template->smarty->security_policy->isTrustedResourceDir($params['file'])) {\n                return;\n            }\n        }\n    }\n\n    $content = '';\n    if ($protocol == 'http') {\n        if ($uri_parts = parse_url($params['file'])) {\n            $host = $server_name = $uri_parts['host'];\n            $timeout = 30;\n            $port = empty($uri_parts['port']) ? 80 : $uri_parts['port'];\n            $user = !empty($uri_parts['user']) ? $uri_parts['user'] : '';\n            $pass = !empty($uri_parts['pass']) ? $uri_parts['pass'] : '';\n            $uri = !empty($uri_parts['path']) ? $uri_parts['path'] : '/';\n            $uri .= !empty($uri_parts['query']) ? '?' . $uri_parts['query'] : '';\n            $_is_proxy = false;\n\n            foreach ($params as $param_key => $param_value) {\n                switch ($param_key) {\n                    case \"file\":\n                    case \"assign\":\n                    case \"assign_headers\":\n                        break;\n                    case \"user\":\n                        if (!empty($param_value)) $user = $param_value;\n                        break;\n                    case \"pass\":\n                        if (!empty($param_value)) $pass = $param_value;\n                        break;\n                    case \"proxy_host\":\n                        if (!empty($param_value)) $proxy_host = $param_value;\n                        break;\n                    case \"proxy_port\":\n                        if (!preg_match('!\\D!', $param_value)) {\n                            $proxy_port = (int) $param_value;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            if (!empty($proxy_host) && !empty($proxy_port)) {\n                $_is_proxy = true;\n                $fp = fsockopen($proxy_host,$proxy_port,$errno,$errstr,$timeout);\n            } else {\n                $fp = fsockopen($server_name,$port,$errno,$errstr,$timeout);\n            }\n\n            if (!$fp) {\n                trigger_error(\"[plugin] unable to fetch: $errstr ($errno)\",E_USER_NOTICE);\n                return;\n            } else {\n                if ($_is_proxy) {\n                    fputs($fp, 'GET ' . $params['file'] . \" HTTP/1.0\\r\\n\");\n                } else {\n                    fputs($fp, \"GET $uri HTTP/1.0\\r\\n\");\n                }\n                fputs($fp, \"Host: $host\\r\\n\");\n                if (!empty($user) && !empty($pass)) {\n                    fputs($fp, \"Authorization: BASIC \".base64_encode(\"$user:$pass\").\"\\r\\n\");\n                }\n                fputs($fp, \"\\r\\n\");\n\n                while (!feof($fp)) {\n                    $content .= fgets($fp,4096);\n                }\n                fclose($fp);\n                $csplit = preg_split(\"!\\r\\n\\r\\n!\",$content,2);\n                $content = $csplit[1];\n            }\n        } else {\n            trigger_error(\"[plugin fetch] unable to parse URL, check syntax\",E_USER_NOTICE);\n            return;\n        }\n    } else {\n        $content = @file_get_contents($params['file']);\n    }\n\n    if (!empty($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 131,
    "matched_results": [
      "<?php\n\nfunction fetch_content($params, $template) {\n    $file = $params['file'];\n    $assign = isset($params['assign']) ? $params['assign'] : null;\n    $assign_headers = isset($params['assign_headers']) ? $params['assign_headers'] : null;\n\n    if (isset($template) && !empty($template->_resource_dir)) {\n        $_resource_dir = $template->_resource_dir;\n        if (!preg_match('/^([\\/\\\\\\\\]|[a-zA-Z]:[\\/\\\\\\\\])/', $file)) {\n            $file = $_resource_dir . $file;\n        }\n        if (!is_readable($file)) {\n            return false;\n        }\n        $content = file_get_contents($file);\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n        return $content;\n    }\n\n\n    if (preg_match('!^https?:\\/\\/!i', $file)) {\n        $url = parse_url($file);\n        $host = $url['host'];\n        $port = isset($url['port']) ? $url['port'] : 80;\n        $path = isset($url['path']) ? $url['path'] : '/';\n        $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n        $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : null;\n        $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : null;\n\n        if ($proxy_host) {\n            $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, 30);\n            $request = \"GET \" . $file . \" HTTP/1.0\\r\\nHost: \" . $host . \"\\r\\n\";\n        } else {\n            $fp = fsockopen($host, $port, $errno, $errstr, 30);\n            $request = \"GET \" . $path . $query . \" HTTP/1.0\\r\\nHost: \" . $host . \"\\r\\n\";\n        }\n\n        if (!$fp) {\n            return false;\n        }\n\n        if (isset($params['user']) && isset($params['pass'])) {\n            $auth = base64_encode($params['user'] . ':' . $params['pass']);\n            $request .= \"Authorization: Basic \" . $auth . \"\\r\\n\";\n        }\n\n        $request .= \"Connection: Close\\r\\n\\r\\n\";\n        fwrite($fp, $request);\n\n        $response = '';\n        while (!feof($fp)) {\n            $response .= fgets($fp, 1024);\n        }\n        fclose($fp);\n\n        $pos = strpos($response, \"\\r\\n\\r\\n\");\n        $headers = substr($response, 0, $pos);\n        $content = substr($response, $pos + 4);\n\n        if ($assign_headers) {\n            $template->assign($assign_headers, $headers);\n        }\n\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n\n        return $content;\n    }\n\n    return false;\n}\n\n?>\n",
      "```php\n<?php\n\nfunction fetch_content($params, $template) {\n    $file = $params['file'];\n    $assign = isset($params['assign']) ? $params['assign'] : null;\n    $assign_headers = isset($params['assign_headers']) ? $params['assign_headers'] : null;\n\n    if (isset($template) && !empty($template->_resource_dir)) {\n        $_resource_dir = $template->_resource_dir;\n        if (!preg_match('/^([\\/\\\\\\\\]|[a-zA-Z]:[\\/\\\\\\\\])/', $file)) {\n            $file = $_resource_dir . $file;\n        }\n        if (!is_readable($file)) {\n            return false;\n        }\n        $content = file_get_contents($file);\n        if ($assign) {\n            $template->assign($assign, $content);\n        } else {\n            return $content;\n        }\n        return;\n    }\n\n\n    if (preg_match('!^https?:\\/\\/!i', $file)) {\n        $url = parse_url($file);\n        $host = $url['host'];\n        $port = isset($url['port']) ? $url['port'] : ($url['scheme'] == 'https' ? 443 : 80);\n        $path = isset($url['path']) ? $url['path'] : '/';\n        $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n        $headers = \"GET $path$query HTTP/1.0\\r\\nHost: $host\\r\\n\";\n\n        if (isset($params['user']) && isset($params['pass'])) {\n            $headers .= \"Authorization: Basic \" . base64_encode($params['user'] . \":\" . $params['pass']) . \"\\r\\n\";\n        }\n\n        $headers .= \"Connection: close\\r\\n\\r\\n\";\n\n        if (isset($params['proxy_host']) && isset($params['proxy_port'])) {\n            $fp = fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, 30);\n            if (!$fp) {\n                return false;\n            }\n            $request = \"GET $file HTTP/1.0\\r\\nHost: $host\\r\\n\";\n            if (isset($params['user']) && isset($params['pass'])) {\n                $request .= \"Proxy-Authorization: Basic \" . base64_encode($params['user'] . \":\" . $params['pass']) . \"\\r\\n\";\n            }\n            $request .= \"Connection: close\\r\\n\\r\\n\";\n            fwrite($fp, $request);\n        } else {\n            $fp = fsockopen(($url['scheme'] == 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n            if (!$fp) {\n                return false;\n            }\n            fwrite($fp, $headers);\n        }\n\n        $response = '';\n        while (!feof($fp)) {\n            $response .= fgets($fp, 1024);\n        }\n        fclose($fp);\n\n        $pos = strpos($response, \"\\r\\n\\r\\n\");\n        $headers = substr($response, 0, $pos);\n        $content = substr($response, $pos + 4);\n\n        if ($assign_headers) {\n            $template->assign($assign_headers, $headers);\n        }\n\n        if ($assign) {\n            $template->assign($assign, $content);\n        } else {\n            return $content;\n        }\n\n    } else {\n        if (isset($template) && ($template->security || !empty($template->_trusted_dir))) {\n            if (!preg_match('/^([\\/\\\\\\\\]|[a-zA-Z]:[\\/\\\\\\\\])/', $file)) {\n                $file = $template->_trusted_dir . $file;\n            }\n            if (!file_exists($file)) {\n                return false;\n            }\n        }\n        if (is_readable($file)) {\n            $content = file_get_contents($file);\n            if ($assign) {\n                $template->assign($assign, $content);\n            } else {\n                return $content;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\n?>\n```",
      "<?php\n\nfunction fetch_content($params, $template) {\n    $file = $params['file'];\n    $assign = isset($params['assign']) ? $params['assign'] : null;\n    $assign_headers = isset($params['assign_headers']) ? $params['assign_headers'] : null;\n\n    if (isset($template) && !empty($template->security_policy)) {\n        if (!preg_match('!^(http|ftp)://!i', $file)) {\n            if ($template->security_policy->isTrustedResourceDir($file)) {\n                $file = realpath($file);\n            } else {\n                return;\n            }\n        } else {\n            if (!$template->security_policy->isTrustedUri($file)) {\n                return;\n            }\n        }\n    }\n\n\n    $content = '';\n    $headers = array();\n    if (preg_match('!^http(s)?://!i', $file)) {\n        $url_parts = parse_url($file);\n        $host = $url_parts['host'];\n        $port = isset($url_parts['port']) ? $url_parts['port'] : ($url_parts['scheme'] == 'https' ? 443 : 80);\n        $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n        $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n        $fp = @fsockopen(\n            (isset($params['proxy_host']) ? $params['proxy_host'] : $host),\n            (isset($params['proxy_port']) ? $params['proxy_port'] : $port),\n            $errno,\n            $errstr,\n            30\n        );\n\n        if (!$fp) {\n            return;\n        }\n\n        $request = \"GET $path$query HTTP/1.1\\r\\n\";\n        $request .= \"Host: $host\\r\\n\";\n\n        if (isset($params['user']) && isset($params['pass'])) {\n            $request .= \"Authorization: Basic \" . base64_encode($params['user'] . \":\" . $params['pass']) . \"\\r\\n\";\n        }\n\n        $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n        fwrite($fp, $request);\n\n        $header = true;\n        while (!feof($fp)) {\n            $line = fgets($fp);\n            if ($header) {\n                if (trim($line) == '') {\n                    $header = false;\n                } else {\n                    if (!preg_match('/^HTTP\\/.* ([0-9]+) (.*)/', $line, $match)) {\n                        $parts = explode(':', $line, 2);\n                        if (count($parts) > 1) {\n                            $headers[trim($parts[0])] = trim($parts[1]);\n                        }\n                    }\n                }\n            } else {\n                $content .= $line;\n            }\n        }\n        fclose($fp);\n\n    } else {\n        $content = @file_get_contents($file);\n    }\n\n    if ($assign) {\n        $template->assign($assign, $content);\n    }\n\n    if ($assign_headers) {\n        $template->assign($assign_headers, $headers);\n    }\n\n    if (!$assign) {\n        return $content;\n    }\n}\n\n?>\n",
      "<?php\n\nfunction fetch_content($params, $template) {\n    $file = $params['file'];\n    $assign = isset($params['assign']) ? $params['assign'] : null;\n    $assign_headers = isset($params['assign_headers']) ? $params['assign_headers'] : null;\n\n    if (isset($template) && !empty($template->_resource_dir)) {\n        $_resource_dir = $template->_resource_dir;\n        if (!preg_match('/^([\\/\\\\\\\\]|[a-zA-Z]:[\\/\\\\\\\\])/', $file)) {\n            $file = $_resource_dir . $file;\n        }\n        if (!is_readable($file)) {\n            return false;\n        }\n        $content = file_get_contents($file);\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n        return $content;\n    }\n\n    if (preg_match('!^https?:\\/\\/!i', $file)) {\n        $url = parse_url($file);\n        $host = $url['host'];\n        $port = isset($url['port']) ? $url['port'] : ($url['scheme'] == 'https' ? 443 : 80);\n        $path = isset($url['path']) ? $url['path'] : '/';\n        $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n        $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : null;\n        $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : null;\n\n        if ($proxy_host) {\n            $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, 30);\n            $request = \"GET \" . $file . \" HTTP/1.0\\r\\nHost: \" . $host . \"\\r\\n\";\n        } else {\n            $fp = fsockopen(($url['scheme'] == 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n            $request = \"GET \" . $path . $query . \" HTTP/1.0\\r\\nHost: \" . $host . \"\\r\\n\";\n        }\n\n        if (!$fp) {\n            return false;\n        }\n\n        if (isset($params['user']) && isset($params['pass'])) {\n            $auth = base64_encode($params['user'] . ':' . $params['pass']);\n            $request .= \"Authorization: Basic \" . $auth . \"\\r\\n\";\n        }\n\n        $request .= \"Connection: Close\\r\\n\\r\\n\";\n        fwrite($fp, $request);\n\n        $response = '';\n        while (!feof($fp)) {\n            $response .= fgets($fp, 1024);\n        }\n        fclose($fp);\n\n        list($headers, $content) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n        if ($assign_headers) {\n            $template->assign($assign_headers, $headers);\n        }\n        return $content;\n    }\n\n    return false;\n}\n\n?>\n",
      "<?php\n\nfunction fetch_content($params, $template) {\n    $file = $params['file'];\n    $assign = isset($params['assign']) ? $params['assign'] : null;\n    $assign_headers = isset($params['assign_headers']) ? $params['assign_headers'] : null;\n\n    if (isset($template) && !empty($template->_resource_dir)) {\n        $_resource_dir = $template->_resource_dir;\n        if (!preg_match('/^([\\/\\\\\\\\]|[a-zA-Z]:[\\/\\\\\\\\])/', $file)) {\n            $file = $_resource_dir . $file;\n        }\n        if (!is_readable($file)) {\n            return false;\n        }\n        $content = file_get_contents($file);\n        if ($assign) {\n            $template->assign($assign, $content);\n        } else {\n            return $content;\n        }\n    } elseif (preg_match('!^https?:\\/\\/!i', $file)) {\n        $url = parse_url($file);\n        $host = $url['host'];\n        $port = isset($url['port']) ? $url['port'] : 80;\n        $path = isset($url['path']) ? $url['path'] : '/';\n        $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n        $user = isset($params['user']) ? $params['user'] : '';\n        $pass = isset($params['pass']) ? $params['pass'] : '';\n        $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : '';\n        $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : '';\n\n        if ($proxy_host) {\n            $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, 30);\n            $get = \"GET $file HTTP/1.0\\r\\n\";\n        } else {\n            $fp = fsockopen($host, $port, $errno, $errstr, 30);\n            $get = \"GET $path$query HTTP/1.0\\r\\nHost: $host\\r\\n\";\n        }\n\n        if ($fp) {\n            if ($user && $pass) {\n                $get .= \"Authorization: Basic \" . base64_encode(\"$user:$pass\") . \"\\r\\n\";\n            }\n            $get .= \"Connection: Close\\r\\n\\r\\n\";\n            fwrite($fp, $get);\n            $content = '';\n            $headers = '';\n            while (!feof($fp)) {\n                $line = fgets($fp, 4096);\n                if ($line == \"\\r\\n\") {\n                    break;\n                }\n                $headers .= $line;\n            }\n            while (!feof($fp)) {\n                $content .= fread($fp, 4096);\n            }\n            fclose($fp);\n\n            if ($assign) {\n                $template->assign($assign, $content);\n            }\n            if ($assign_headers) {\n                $template->assign($assign_headers, $headers);\n            }\n            if (!$assign) {\n                return $content;\n            }\n        } else {\n            return false;\n        }\n    } else {\n        if ($assign) {\n            $template->assign($assign, $file);\n        } else {\n            return $file;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nfunction fetch_content($params, $template) {\n    $file = $params['file'];\n    $assign = isset($params['assign']) ? $params['assign'] : null;\n    $assign_headers = isset($params['assign_headers']) ? $params['assign_headers'] : null;\n\n    if (isset($template) && !empty($template->security_policy)) {\n        if (!preg_match('!^(http|ftp)://!i', $file)) {\n            if ($template->security_policy->isTrustedResourceDir($file)) {\n                $file = realpath($file);\n            } else {\n                return;\n            }\n        } else {\n            if (!$template->security_policy->isTrustedUri($file)) {\n                return;\n            }\n        }\n    }\n\n\n    $content = '';\n    $headers = array();\n    if (preg_match('!^http(s)?://!i', $file)) {\n        $url_parts = parse_url($file);\n        $host = $url_parts['host'];\n        $port = isset($url_parts['port']) ? $url_parts['port'] : ($url_parts['scheme'] == 'https' ? 443 : 80);\n        $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n        $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n        $fp = @fsockopen(\n            (isset($params['proxy_host']) ? $params['proxy_host'] : $host),\n            (isset($params['proxy_port']) ? $params['proxy_port'] : $port),\n            $errno,\n            $errstr,\n            30\n        );\n\n        if (!$fp) {\n            return;\n        }\n\n        $request = \"GET $path$query HTTP/1.1\\r\\n\";\n        $request .= \"Host: $host\\r\\n\";\n\n        if (isset($params['user']) && isset($params['pass'])) {\n            $request .= \"Authorization: Basic \" . base64_encode($params['user'] . \":\" . $params['pass']) . \"\\r\\n\";\n        }\n\n        $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n        fwrite($fp, $request);\n\n        $header = true;\n        while (!feof($fp)) {\n            $line = fgets($fp);\n            if ($header && $line == \"\\r\\n\") {\n                $header = false;\n            } elseif ($header) {\n                $headers[] = $line;\n            } else {\n                $content .= $line;\n            }\n        }\n        fclose($fp);\n\n        if ($assign_headers) {\n            $template->assign($assign_headers, $headers);\n        }\n    } else {\n        $content = @file_get_contents($file);\n    }\n\n    if ($assign) {\n        $template->assign($assign, $content);\n    } else {\n        return $content;\n    }\n}\n\n?>\n",
      "```php\n<?php\n\nfunction fetch_content($params, $template) {\n    $file = $params['file'];\n    $assign = isset($params['assign']) ? $params['assign'] : null;\n    $assign_headers = isset($params['assign_headers']) ? $params['assign_headers'] : null;\n\n    if (isset($template) && !empty($template->_resource_dir)) {\n        $_resource_dir = $template->_resource_dir;\n        if (!preg_match('/^([\\/\\\\\\\\]|[a-zA-Z]:[\\/\\\\\\\\])/', $file)) {\n            $file = $_resource_dir . $file;\n        }\n        if (!is_readable($file)) {\n            return false;\n        }\n        $content = file_get_contents($file);\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n        return $content;\n    }\n\n    if (preg_match('!^https?:\\/\\/!i', $file)) {\n        $url = parse_url($file);\n        $host = $url['host'];\n        $port = isset($url['port']) ? $url['port'] : ($url['scheme'] == 'https' ? 443 : 80);\n        $path = isset($url['path']) ? $url['path'] : '/';\n        $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n        $headers = \"GET {$path}{$query} HTTP/1.0\\r\\nHost: {$host}\\r\\n\";\n\n        if (isset($params['user']) && isset($params['pass'])) {\n            $headers .= \"Authorization: Basic \" . base64_encode($params['user'] . ':' . $params['pass']) . \"\\r\\n\";\n        }\n\n        $headers .= \"Connection: close\\r\\n\\r\\n\";\n\n        if (isset($params['proxy_host']) && isset($params['proxy_port'])) {\n            $fp = @fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, 30);\n            if (!$fp) {\n                return false;\n            }\n            $request = \"GET {$file} HTTP/1.0\\r\\nHost: {$host}\\r\\n\";\n            if (isset($params['user']) && isset($params['pass'])) {\n                $request .= \"Proxy-Authorization: Basic \" . base64_encode($params['user'] . ':' . $params['pass']) . \"\\r\\n\";\n            }\n            $request .= \"Connection: close\\r\\n\\r\\n\";\n            fwrite($fp, $request);\n        } else {\n            $fp = @fsockopen(($url['scheme'] == 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n            if (!$fp) {\n                return false;\n            }\n            fwrite($fp, $headers);\n        }\n\n        $response = '';\n        while (!feof($fp)) {\n            $response .= fgets($fp, 4096);\n        }\n        fclose($fp);\n\n        $pos = strpos($response, \"\\r\\n\\r\\n\");\n        $headers = substr($response, 0, $pos);\n        $content = substr($response, $pos + 4);\n\n        if ($assign_headers) {\n            $template->assign($assign_headers, $headers);\n        }\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n        return $content;\n    }\n\n    return false;\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction fetch_content($params, $template) {\n    $file = $params['file'];\n    $assign = isset($params['assign']) ? $params['assign'] : null;\n    $assign_headers = isset($params['assign_headers']) ? $params['assign_headers'] : null;\n\n    if (isset($template) && !empty($template->_resource_dir)) {\n        $_resource_dir = $template->_resource_dir;\n        if (!preg_match('/^([\\/\\\\\\\\]|[a-zA-Z]:[\\/\\\\\\\\])/', $file)) {\n            $file = $_resource_dir . $file;\n        }\n        if (!is_readable($file)) {\n            return false;\n        }\n        $content = file_get_contents($file);\n        if ($assign) {\n            $template->assign($assign, $content);\n        } else {\n            return $content;\n        }\n        return;\n    }\n\n\n    if (preg_match('!^https?:\\/\\/!i', $file)) {\n        $url = parse_url($file);\n        $host = $url['host'];\n        $port = isset($url['port']) ? $url['port'] : ($url['scheme'] == 'https' ? 443 : 80);\n        $path = isset($url['path']) ? $url['path'] : '/';\n        $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n        $user = isset($params['user']) ? $params['user'] : null;\n        $pass = isset($params['pass']) ? $params['pass'] : null;\n        $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : null;\n        $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : null;\n\n        $fp = ($proxy_host) ? fsockopen($proxy_host, $proxy_port) : fsockopen($host, $port);\n\n        if (!$fp) {\n            return false;\n        }\n\n        $request = \"GET \" . $path . $query . \" HTTP/1.0\\r\\n\";\n        $request .= \"Host: \" . $host . \"\\r\\n\";\n\n        if ($user && $pass) {\n            $request .= \"Authorization: Basic \" . base64_encode($user . \":\" . $pass) . \"\\r\\n\";\n        }\n\n        $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n        fwrite($fp, $request);\n\n        $response = '';\n        while (!feof($fp)) {\n            $response .= fgets($fp, 1024);\n        }\n        fclose($fp);\n\n        list($headers, $content) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n        if ($assign_headers) {\n            $template->assign($assign_headers, $headers);\n        }\n\n        if (!$assign) {\n            return $content;\n        }\n\n    } else {\n        if (isset($template) && (!isset($template->security_policy) || $template->security_policy->isTrustedResourceDir($file))) {\n            $content = file_get_contents($file);\n            if ($assign) {\n                $template->assign($assign, $content);\n            } else {\n                return $content;\n            }\n        }\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction fetch_content($params, $template) {\n    $file = $params['file'];\n    $assign = isset($params['assign']) ? $params['assign'] : null;\n    $assign_headers = isset($params['assign_headers']) ? $params['assign_headers'] : null;\n\n    if (isset($template) && !empty($template->_resource_dir)) {\n        $_resource_dir = $template->_resource_dir;\n        if (!preg_match('/^([\\/\\\\\\\\]|[a-zA-Z]:[\\/\\\\\\\\])/', $file)) {\n            $file = $_resource_dir . $file;\n        }\n        if (!is_readable($file)) {\n            return false;\n        }\n        $content = file_get_contents($file);\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n        return $content;\n    }\n\n\n    if (preg_match('!^https?:\\/\\/!i', $file)) {\n        $url = parse_url($file);\n        $host = $url['host'];\n        $path = isset($url['path']) ? $url['path'] : '/';\n        $query = isset($url['query']) ? '?' . $url['query'] : '';\n        $port = isset($url['port']) ? $url['port'] : 80;\n        $scheme = $url['scheme'];\n\n        $headers = [];\n        $fp = @fsockopen(\n            (isset($params['proxy_host']) ? $params['proxy_host'] : null),\n            (isset($params['proxy_port']) ? $params['proxy_port'] : null),\n            $errno,\n            $errstr,\n            30\n        );\n\n        if (!$fp) {\n            return false;\n        }\n\n        $request = \"GET $path$query HTTP/1.0\\r\\n\";\n        $request .= \"Host: $host\\r\\n\";\n\n        if (isset($params['user']) && isset($params['pass'])) {\n            $request .= \"Authorization: Basic \" . base64_encode($params['user'] . ':' . $params['pass']) . \"\\r\\n\";\n        }\n\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        fwrite($fp, $request);\n\n        $response = '';\n        while (!feof($fp)) {\n            $response .= fgets($fp, 4096);\n        }\n        fclose($fp);\n\n        $pos = strpos($response, \"\\r\\n\\r\\n\");\n        $content = substr($response, $pos + 4);\n        $header_text = substr($response, 0, $pos);\n        $header_lines = explode(\"\\r\\n\", $header_text);\n\n        foreach ($header_lines as $header_line) {\n            if (strpos($header_line, ':') !== false) {\n                list($key, $value) = explode(':', $header_line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n        if ($assign_headers) {\n            $template->assign($assign_headers, $headers);\n        }\n\n        return $content;\n    }\n\n    return false;\n}\n\n?>\n```"
    ],
    "unmatched_results": [
      "```php\n<?php\n\nfunction fetch_content($params, $template) {\n    $file = $params['file'];\n    $assign = isset($params['assign']) ? $params['assign'] : null;\n    $assign_headers = isset($params['assign_headers']) ? $params['assign_headers'] : null;\n\n    if (isset($template) && !empty($template->_resource_dir)) {\n        $_resource_dir = $template->_resource_dir;\n        if (!preg_match('/^([\\/\\\\\\\\]|[a-zA-Z]:[\\/\\\\\\\\])/', $file)) {\n            $file = $_resource_dir . $file;\n        }\n        if (!is_readable($file)) {\n            return false;\n        }\n        $content = file_get_contents($file);\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n        return $content;\n    }\n\n\n    if (preg_match('!^https?:\\/\\/!i', $file)) {\n        $url = parse_url($file);\n        $host = $url['host'];\n        $path = isset($url['path']) ? $url['path'] : '/';\n        $query = isset($url['query']) ? '?' . $url['query'] : '';\n        $port = isset($url['port']) ? $url['port'] : 80;\n        $scheme = $url['scheme'];\n\n        $headers = array(\n            'Host' => $host,\n            'User-Agent' => 'Smarty Template Engine',\n            'Connection' => 'close'\n        );\n\n        if (isset($params['user']) || isset($params['pass'])) {\n            $headers['Authorization'] = 'Basic ' . base64_encode($params['user'] . ':' . $params['pass']);\n        }\n\n        $fp = @fsockopen(\n            (isset($params['proxy_host']) ? $params['proxy_host'] : $host),\n            (isset($params['proxy_port']) ? $params['proxy_port'] : $port),\n            $errno,\n            $errstr,\n            30\n        );\n\n        if (!$fp) {\n            return false;\n        }\n\n        $request = \"GET $path$query HTTP/1.1\\r\\n\";\n        foreach ($headers as $k => $v) {\n            $request .= \"$k: $v\\r\\n\";\n        }\n        $request .= \"\\r\\n\";\n\n        fwrite($fp, $request);\n\n        $response = '';\n        while (!feof($fp)) {\n            $response .= fread($fp, 4096);\n        }\n        fclose($fp);\n\n        $header_data = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $content = $header_data[1];\n        $response_headers = $header_data[0];\n\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n        if ($assign_headers) {\n            $template->assign($assign_headers, $response_headers);\n        }\n\n        return $content;\n    } else {\n        if (isset($template) && !empty($template->_resource_dir)) {\n            if (!preg_match('/^([\\/\\\\\\\\]|[a-zA-Z]:[\\/\\\\\\\\])/', $file)) {\n                $file = $template->_resource_dir . $file;\n            }\n        }\n\n        if (!is_readable($file)) {\n            return false;\n        }\n        $content = file_get_contents($file);\n        if ($assign) {\n            $template->assign($assign, $content);\n        }\n        return $content;\n    }\n}\n\n?>\n```"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Implement a PHP class for handling trackback requests using low-level HTTP socket communication.\n\nClass Description: The CI_Trackback class provides functionality to send and process trackback pings to remote servers. It handles HTTP communication directly using fsockopen, processes responses, and manages errors.\n\nAttributes:\n- charset: string - Character encoding to use (default: 'UTF-8')\n- data: array - Trackback data including url, title, excerpt, blog_name, and charset\n- convert_ascii: bool - Whether to convert non-ASCII characters (default: TRUE)\n- response: string - Raw HTTP response from the trackback server\n- error_msg: array - Collection of error messages encountered during processing\n\nMethods:\n- process(string $url, string $data) -> bool - Sends a trackback ping to the specified URL with the given data. Returns TRUE on success, FALSE on failure.\n  Input: \n    $url: string - Target URL for the trackback\n    $data: string - URL-encoded trackback data\n  Output: bool - Success status\n\n- get_id(string $url) -> mixed - Extracts a numeric ID from the given URL. Returns the ID as string or FALSE if not found.\n  Input: $url: string - URL to parse for an ID\n  Output: mixed - Extracted ID string or FALSE\n\n- set_error(string $msg) -> void - Adds an error message to the error collection.\n  Input: $msg: string - Error message to store\n  Output: void",
    "Canonical_solution": "class CI_Trackback {\n    public $charset = 'UTF-8';\n    public $data = array(\n        'url' => '',\n        'title' => '',\n        'excerpt' => '',\n        'blog_name' => '',\n        'charset' => ''\n    );\n    public $convert_ascii = TRUE;\n    public $response = '';\n    public $error_msg = array();\n\n    public function process($url, $data) {\n        $target = parse_url($url);\n\n        if ( ! $fp = @fsockopen($target['host'], 80)) {\n            $this->set_error('Invalid Connection: '.$url);\n            return FALSE;\n        }\n\n        $path = isset($target['path']) ? $target['path'] : $url;\n        empty($target['query']) OR $path .= '?'.$target['query'];\n\n        if ($id = $this->get_id($url)) {\n            $data = 'tb_id='.$id.'&'.$data;\n        }\n\n        fputs($fp, 'POST '.$path.\" HTTP/1.0\\r\\n\");\n        fputs($fp, 'Host: '.$target['host'].\"\\r\\n\");\n        fputs($fp, \"Content-type: application/x-www-form-urlencoded\\r\\n\");\n        fputs($fp, 'Content-length: '.strlen($data).\"\\r\\n\");\n        fputs($fp, \"Connection: close\\r\\n\\r\\n\");\n        fputs($fp, $data);\n\n        $this->response = '';\n        while ( ! feof($fp)) {\n            $this->response .= fgets($fp, 128);\n        }\n        @fclose($fp);\n\n        if (stripos($this->response, '<error>0</error>') === FALSE) {\n            $message = preg_match('/<message>(.*?)<\\/message>/is', $this->response, $match)\n                ? trim($match[1])\n                : 'An unknown error was encountered';\n            $this->set_error($message);\n            return FALSE;\n        }\n\n        return TRUE;\n    }\n\n    public function get_id($url) {\n        $tb_id = '';\n\n        if (strpos($url, '?') !== FALSE) {\n            $tb_array = explode('/', $url);\n            $tb_end   = $tb_array[count($tb_array)-1];\n\n            if ( ! is_numeric($tb_end)) {\n                $tb_end  = $tb_array[count($tb_array)-2];\n            }\n\n            $tb_array = explode('=', $tb_end);\n            $tb_id    = $tb_array[count($tb_array)-1];\n        }\n        else {\n            $url = rtrim($url, '/');\n\n            $tb_array = explode('/', $url);\n            $tb_id    = $tb_array[count($tb_array)-1];\n\n            if ( ! is_numeric($tb_id)) {\n                $tb_id = $tb_array[count($tb_array)-2];\n            }\n        }\n\n        return ctype_digit((string) $tb_id) ? $tb_id : FALSE;\n    }\n\n    public function set_error($msg) {\n        $this->error_msg[] = $msg;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 131,
    "matched_results": [
      "<?php\nclass CI_Trackback {\n    public $charset = 'UTF-8';\n    public $data = array('url' => '', 'title' => '', 'excerpt' => '', 'blog_name' => '', 'charset' => '');\n    public $convert_ascii = TRUE;\n    public $response = '';\n    public $error_msg = array();\n\n    public function process($url, $data) {\n        $this->response = '';\n        $this->error_msg = array();\n        if ($fp = @fsockopen($url[0], $url[1], $errno, $errstr, 3)) {\n            $data = \"POST {$url[2]} HTTP/1.0\\r\\n\";\n            $data .= \"Host: {$url[3]}\\r\\n\";\n            $data .= \"Content-type: application/x-www-form-urlencoded; charset={$this->charset}\\r\\n\";\n            $data .= \"Content-length: \" . strlen($this->data) . \"\\r\\n\";\n            $data .= \"User-Agent: CodeIgniter\\r\\n\";\n            $data .= \"Connection: close\\r\\n\\r\\n\";\n            $data .= $this->data;\n            fputs($fp, $data);\n            while (!feof($fp)) {\n                $this->response .= fgets($fp, 1160);\n            }\n            fclose($fp);\n            if (strpos($this->response, '<error>0</error>') === FALSE) {\n                $message = preg_match('/<message>(.*?)<\\/message>/', $this->response, $match) ? trim($match[1]) : 'An unknown error was encountered.';\n                $this->set_error($message);\n                return FALSE;\n            }\n            return TRUE;\n        }\n        $this->set_error('A connection could not be made.');\n        return FALSE;\n    }\n\n    public function get_id($url) {\n        if (preg_match('#\\d+#', $url, $match)) {\n            return $match[0];\n        }\n        return FALSE;\n    }\n\n    public function set_error($msg) {\n        $this->error_msg[] = $msg;\n    }\n}\n?>\n",
      "<?php\nclass CI_Trackback {\n    public $charset = 'UTF-8';\n    public $data = array('url' => '', 'title' => '', 'excerpt' => '', 'blog_name' => '', 'charset' => '');\n    public $convert_ascii = TRUE;\n    public $response = '';\n    public $error_msg = array();\n\n    public function process($url, $data) {\n        $this->response = '';\n        $this->error_msg = array();\n        if ($fp = @fsockopen($url[0], $url[1], $errno, $errstr, 3)) {\n            $data = \"POST {$url[2]} HTTP/1.0\\r\\n\";\n            $data .= \"Host: {$url[3]}\\r\\n\";\n            $data .= \"Content-type: application/x-www-form-urlencoded; charset={$this->charset}\\r\\n\";\n            $data .= \"Content-length: \" . strlen($this->data) . \"\\r\\n\";\n            $data .= \"User-Agent: CodeIgniter\\r\\n\";\n            $data .= \"\\r\\n\";\n            $data .= $this->data;\n            fputs($fp, $data);\n            while (!feof($fp)) {\n                $this->response .= fgets($fp, 1160);\n            }\n            fclose($fp);\n            if (strpos($this->response, '<error>0</error>') === FALSE) {\n                $message = preg_match('/<message>(.*?)<\\/message>/', $this->response, $match) ? trim($match[1]) : 'An unknown error was encountered.';\n                $this->set_error($message);\n                return FALSE;\n            }\n            return TRUE;\n        }\n        $this->set_error('A connection could not be made.');\n        return FALSE;\n    }\n\n    public function get_id($url) {\n        if (preg_match('#\\d+#', $url, $match)) {\n            return $match[0];\n        }\n        return FALSE;\n    }\n\n    public function set_error($msg) {\n        $this->error_msg[] = $msg;\n    }\n}\n?>\n",
      "<?php\nclass CI_Trackback {\n    public $charset = 'UTF-8';\n    public $data = array('url' => '', 'title' => '', 'excerpt' => '', 'blog_name' => '', 'charset' => '');\n    public $convert_ascii = TRUE;\n    public $response = '';\n    public $error_msg = array();\n\n    public function process($url, $data) {\n        $this->data = $data;\n        $target = parse_url($url);\n\n        if (!isset($target['host'])) {\n            $this->set_error('Invalid URL');\n            return FALSE;\n        }\n\n        $fp = @fsockopen($target['host'], 80, $errno, $errstr, 30);\n        if (!$fp) {\n            $this->set_error($errstr);\n            return FALSE;\n        }\n\n        $path = isset($target['path']) ? $target['path'] : $url;\n        $path .= isset($target['query']) ? '?'.$target['query'] : '';\n\n        fputs($fp, \"POST \".$path.\" HTTP/1.0\\r\\n\");\n        fputs($fp, \"Host: \".$target['host'].\"\\r\\n\");\n        fputs($fp, \"Content-type: application/x-www-form-urlencoded; charset=\".$this->charset.\"\\r\\n\");\n        fputs($fp, \"Content-length: \".strlen($data).\"\\r\\n\");\n        fputs($fp, \"Connection: close\\r\\n\\r\\n\");\n        fputs($fp, $data);\n\n        while (!feof($fp)) {\n            $this->response .= fgets($fp, 1160);\n        }\n        fclose($fp);\n\n        if (strpos($this->response, '<error>0</error>') === FALSE) {\n            $message = preg_match('/<message>(.*?)<\\/message>/', $this->response, $match) ? trim($match[1]) : '';\n            $this->set_error($message);\n            return FALSE;\n        }\n\n        return TRUE;\n    }\n\n\n    public function get_id($url)\n    {\n        $tb_id = '';\n        if (strpos($url, '?') !== FALSE)\n        {\n            $tb_array = explode('?', $url);\n            $tb_array2 = explode('=', $tb_array[1]);\n\n            $tb_id = $tb_array2[1];\n        }\n        else\n        {\n            $tb_array = explode('/', $url);\n            $tb_id = $tb_array[count($tb_array)-1];\n        }\n\n        if (!is_numeric($tb_id))\n        {\n            return FALSE;\n        }\n\n        return $tb_id;\n    }\n\n    public function set_error($msg) {\n        $this->error_msg[] = $msg;\n    }\n}\n?>\n",
      "<?php\nclass CI_Trackback {\n    public $charset = 'UTF-8';\n    public $data = array('url' => '', 'title' => '', 'excerpt' => '', 'blog_name' => '', 'charset' => '');\n    public $convert_ascii = TRUE;\n    public $response = '';\n    public $error_msg = array();\n\n    public function process($url, $data) {\n        $this->response = '';\n        $this->error_msg = array();\n        if ($fp = @fsockopen($url[0], $url[1], $errno, $errstr, 3)) {\n            $data = \"POST \" . $url[2] . \" HTTP/1.0\\r\\n\";\n            $data .= \"Host: \" . $url[3] . \"\\r\\n\";\n            $data .= \"Content-type: application/x-www-form-urlencoded; charset=\" . $this->charset . \"\\r\\n\";\n            $data .= \"Content-length: \" . strlen($this->data) . \"\\r\\n\";\n            $data .= \"User-Agent: CodeIgniter\\r\\n\";\n            $data .= \"\\r\\n\";\n            $data .= $this->data;\n            fputs($fp, $data);\n            while (!feof($fp)) {\n                $this->response .= fgets($fp, 1160);\n            }\n            fclose($fp);\n            if (strpos($this->response, '<error>0</error>') === FALSE) {\n                $message = preg_match('/<message>(.*?)<\\/message>/', $this->response, $match) ? trim($match[1]) : 'An unknown error was encountered.';\n                $this->set_error($message);\n                return FALSE;\n            }\n            return TRUE;\n        }\n        $this->set_error('A connection could not be made.');\n        return FALSE;\n    }\n\n    public function get_id($url) {\n        if (preg_match('#\\d+#', $url, $match)) {\n            return $match[0];\n        }\n        return FALSE;\n    }\n\n    public function set_error($msg) {\n        $this->error_msg[] = $msg;\n    }\n}\n?>\n",
      "<?php\nclass CI_Trackback {\n    public $charset = 'UTF-8';\n    public $data = array('url' => '', 'title' => '', 'excerpt' => '', 'blog_name' => '', 'charset' => '');\n    public $convert_ascii = TRUE;\n    public $response = '';\n    public $error_msg = array();\n\n    public function process($url, $data) {\n        $this->data = $data;\n        $target = parse_url($url);\n\n        if (!isset($target['host'])) {\n            $this->set_error('Invalid URL');\n            return FALSE;\n        }\n\n        $fp = @fsockopen($target['host'], 80, $errno, $errstr, 30);\n        if (!$fp) {\n            $this->set_error($errstr);\n            return FALSE;\n        }\n\n        $path = isset($target['path']) ? $target['path'] : $url;\n        $path .= isset($target['query']) ? '?'.$target['query'] : '';\n\n        fputs($fp, \"POST \".$path.\" HTTP/1.0\\r\\n\");\n        fputs($fp, \"Host: \".$target['host'].\"\\r\\n\");\n        fputs($fp, \"Content-type: application/x-www-form-urlencoded; charset=\".$this->charset.\"\\r\\n\");\n        fputs($fp, \"Content-length: \".strlen($data).\"\\r\\n\");\n        fputs($fp, \"Connection: close\\r\\n\\r\\n\");\n        fputs($fp, $data);\n\n        while (!feof($fp)) {\n            $this->response .= fgets($fp, 1160);\n        }\n        fclose($fp);\n\n        if (strpos($this->response, '<error>0</error>') === FALSE) {\n            $message = preg_match('/<message>(.*?)<\\/message>/', $this->response, $match) ? trim($match[1]) : '';\n            $this->set_error($message);\n            return FALSE;\n        }\n\n        return TRUE;\n    }\n\n    public function get_id($url)\n    {\n        $tb_id = '';\n        if (strpos($url, '?') !== FALSE) {\n            $tb_array = explode('?', $url);\n            $tb_array2 = explode('=', $tb_array[1]);\n\n            if (!empty($tb_array2[0]) && $tb_array2[0] == 'tb_id') {\n                $tb_id = $tb_array2[1];\n            }\n        }\n        return ($tb_id != '' && is_numeric($tb_id)) ? $tb_id : FALSE;\n    }\n\n\n    public function set_error($msg) {\n        $this->error_msg[] = $msg;\n    }\n}\n?>\n",
      "<?php\nclass CI_Trackback {\n    public $charset = 'UTF-8';\n    public $data = array('url' => '', 'title' => '', 'excerpt' => '', 'blog_name' => '', 'charset' => '');\n    public $convert_ascii = TRUE;\n    public $response = '';\n    public $error_msg = array();\n\n    public function process($url, $data) {\n        $this->response = '';\n        $this->error_msg = array();\n        if ($fp = @fsockopen($url[0], $url[1], $errno, $errstr, 3)) {\n            $data = \"POST \" . $url[2] . \" HTTP/1.0\\r\\n\";\n            $data .= \"Host: \" . $url[3] . \"\\r\\n\";\n            $data .= \"Content-type: application/x-www-form-urlencoded; charset=\" . $this->charset . \"\\r\\n\";\n            $data .= \"Content-length: \" . strlen($this->data) . \"\\r\\n\";\n            $data .= \"User-Agent: CodeIgniter\\r\\n\";\n            $data .= \"\\r\\n\";\n            $data .= $this->data;\n            fputs($fp, $data);\n            while (!feof($fp)) {\n                $this->response .= fgets($fp, 1160);\n            }\n            fclose($fp);\n            if (preg_match('/<error>1<\\/error>/', $this->response)) {\n                if (preg_match('/<message>([^\\<]+)<\\/message>/', $this->response, $match)) {\n                    $this->set_error($match[1]);\n                } else {\n                    $this->set_error('An unknown error was encountered.');\n                }\n                return FALSE;\n            }\n            return TRUE;\n        } else {\n            $this->set_error('Could not open a socket connection to the remote server. ' . $errstr);\n            return FALSE;\n        }\n    }\n\n    public function get_id($url) {\n        if (preg_match('#(\\d+)$#', $url, $match)) {\n            return $match[1];\n        }\n        return FALSE;\n    }\n\n    public function set_error($msg) {\n        $this->error_msg[] = $msg;\n    }\n}\n?>\n",
      "<?php\nclass CI_Trackback {\n    public $charset = 'UTF-8';\n    public $data = array('url' => '', 'title' => '', 'excerpt' => '', 'blog_name' => '', 'charset' => '');\n    public $convert_ascii = TRUE;\n    public $response = '';\n    public $error_msg = array();\n\n    public function process($url, $data) {\n        $this->response = '';\n        $this->error_msg = array();\n        if ($fp = @fsockopen($url[0], $url[1], $errno, $errstr, 3)) {\n            $data = \"POST \" . $url[2] . \" HTTP/1.0\\r\\n\";\n            $data .= \"Host: \" . $url[3] . \"\\r\\n\";\n            $data .= \"Content-type: application/x-www-form-urlencoded; charset=\" . $this->charset . \"\\r\\n\";\n            $data .= \"Content-length: \" . strlen($this->data) . \"\\r\\n\";\n            $data .= \"User-Agent: CodeIgniter\\r\\n\";\n            $data .= \"\\r\\n\";\n            $data .= $this->data;\n            fputs($fp, $data);\n            while (!feof($fp)) {\n                $this->response .= fgets($fp, 1160);\n            }\n            fclose($fp);\n            if (preg_match('/<error>1<\\/error>/', $this->response)) {\n                if (preg_match('/<message>([^\\<]+)\\<\\/message>/', $this->response, $match)) {\n                    $this->set_error($match[1]);\n                } else {\n                    $this->set_error('An unknown error was encountered.');\n                }\n                return FALSE;\n            }\n            return TRUE;\n        } else {\n            $this->set_error('Could not open a socket connection to the remote server.');\n            return FALSE;\n        }\n    }\n\n    public function get_id($url) {\n        if (preg_match('#(\\d+)$#', $url, $match)) {\n            return $match[1];\n        }\n        return FALSE;\n    }\n\n    public function set_error($msg) {\n        $this->error_msg[] = $msg;\n    }\n}\n?>\n",
      "<?php\nclass CI_Trackback {\n    public $charset = 'UTF-8';\n    public $data = array('url' => '', 'title' => '', 'excerpt' => '', 'blog_name' => '', 'charset' => '');\n    public $convert_ascii = TRUE;\n    public $response = '';\n    public $error_msg = array();\n\n    public function process($url, $data) {\n        $this->response = '';\n        $this->error_msg = array();\n        if ($fp = @fsockopen($url[0], $url[1], $errno, $errstr, 3)) {\n            $data = \"POST \" . $url[2] . \" HTTP/1.0\\r\\n\";\n            $data .= \"Host: \" . $url[3] . \"\\r\\n\";\n            $data .= \"Content-type: application/x-www-form-urlencoded; charset=\" . $this->charset . \"\\r\\n\";\n            $data .= \"Content-length: \" . strlen($this->data) . \"\\r\\n\";\n            $data .= \"User-Agent: CodeIgniter\\r\\n\\r\\n\";\n            $data .= $this->data;\n            fputs($fp, $data);\n            while (!feof($fp)) {\n                $this->response .= fgets($fp, 1160);\n            }\n            fclose($fp);\n            if (preg_match('/<error>1<\\/error>/', $this->response)) {\n                if (preg_match('/<message>([^\\<]+)<\\/message>/', $this->response, $match)) {\n                    $this->set_error($match[1]);\n                } else {\n                    $this->set_error('An unknown error was encountered.');\n                }\n                return FALSE;\n            }\n            return TRUE;\n        } else {\n            $this->set_error('Could not open a socket connection to the remote server. ' . $errstr);\n            return FALSE;\n        }\n    }\n\n    public function get_id($url) {\n        if (preg_match('#(\\d+)$#', $url, $match)) {\n            return $match[1];\n        }\n        return FALSE;\n    }\n\n    public function set_error($msg) {\n        $this->error_msg[] = $msg;\n    }\n}\n?>\n",
      "<?php\nclass CI_Trackback {\n    public $charset = 'UTF-8';\n    public $data = array('url' => '', 'title' => '', 'excerpt' => '', 'blog_name' => '', 'charset' => '');\n    public $convert_ascii = TRUE;\n    public $response = '';\n    public $error_msg = array();\n\n    public function process($url, $data) {\n        $this->response = '';\n        $this->error_msg = array();\n        if ($fp = @fsockopen($url[0], $url[1], $errno, $errstr, 3)) {\n            $data = \"POST {$url[2]} HTTP/1.0\\r\\n\";\n            $data .= \"Host: {$url[3]}\\r\\n\";\n            $data .= \"Content-type: application/x-www-form-urlencoded; charset={$this->charset}\\r\\n\";\n            $data .= \"Content-length: \" . strlen($this->data) . \"\\r\\n\";\n            $data .= \"User-Agent: CodeIgniter\\r\\n\";\n            $data .= \"\\r\\n\";\n            $data .= $this->data;\n            fputs($fp, $data);\n            while (!feof($fp)) {\n                $this->response .= fgets($fp, 1160);\n            }\n            fclose($fp);\n            if (strpos($this->response, '<error>0</error>') === FALSE) {\n                $message = preg_match('/<message>(.*?)<\\/message>/', $this->response, $match) ? trim($match[1]) : 'An unknown error was encountered.';\n                $this->set_error($message);\n                return FALSE;\n            }\n            return TRUE;\n        }\n        $this->set_error('A connection could not be made.');\n        return FALSE;\n    }\n\n    public function get_id($url) {\n        if (preg_match('#\\d+#', $url, $match)) {\n            return $match[0];\n        }\n        return FALSE;\n    }\n\n    public function set_error($msg) {\n        $this->error_msg[] = $msg;\n    }\n}\n?>\n",
      "<?php\nclass CI_Trackback {\n    public $charset = 'UTF-8';\n    public $data = array('url' => '', 'title' => '', 'excerpt' => '', 'blog_name' => '', 'charset' => '');\n    public $convert_ascii = TRUE;\n    public $response = '';\n    public $error_msg = array();\n\n    public function process($url, $data) {\n        $this->response = '';\n        $this->error_msg = array();\n        if ($fp = @fsockopen($url[0], $url[1], $errno, $errstr, 3)) {\n            $data = \"POST {$url[2]} HTTP/1.0\\r\\n\";\n            $data .= \"Host: {$url[3]}\\r\\n\";\n            $data .= \"Content-type: application/x-www-form-urlencoded; charset={$this->charset}\\r\\n\";\n            $data .= \"Content-length: \" . strlen($this->data) . \"\\r\\n\";\n            $data .= \"User-Agent: CodeIgniter\\r\\n\";\n            $data .= \"\\r\\n\";\n            $data .= $this->data;\n            fputs($fp, $data);\n            while (!feof($fp)) {\n                $this->response .= fgets($fp, 1160);\n            }\n            fclose($fp);\n            if (strpos($this->response, '<error>0</error>') === FALSE) {\n                $message = preg_match('/<message>(.*?)<\\/message>/', $this->response, $match) ? trim($match[1]) : 'An unknown error was encountered.';\n                $this->set_error($message);\n                return FALSE;\n            }\n            return TRUE;\n        }\n        $this->set_error('A connection could not be made.');\n        return FALSE;\n    }\n\n    public function get_id($url) {\n        if (preg_match('#\\d+#', $url, $match)) {\n            return $match[0];\n        }\n        return FALSE;\n    }\n\n    public function set_error($msg) {\n        $this->error_msg[] = $msg;\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Implement a class that handles HTTP POST requests to Google's reCAPTCHA verification service using low-level socket operations in PHP.\n\nClass Description: ReCaptchaSocketPostRequestMethod is a class that implements reCAPTCHA verification by establishing a direct socket connection to Google's servers, sending an HTTP POST request, and processing the response. It provides an alternative to higher-level HTTP clients.\n\nAttributes:\n- socket: [ReCaptchaSocket] - The socket connection handler used for HTTP communication\n- RECAPTCHA_HOST: [string] - Constant storing Google's reCAPTCHA hostname ('www.google.com')\n- SITE_VERIFY_PATH: [string] - Constant storing the reCAPTCHA verification endpoint path ('/recaptcha/api/siteverify')\n- BAD_REQUEST: [string] - Constant JSON response for failed requests\n- BAD_RESPONSE: [string] - Constant JSON response for invalid server responses\n\nMethods:\n- __construct([ReCaptchaSocket $socket = null]) -> [void] - Initializes the class with an optional socket dependency injection\n- submit(ReCaptchaRequestParameters $params) -> [string] - Performs the reCAPTCHA verification by:\n  1. Opening an SSL socket connection to Google's server\n  2. Formatting and sending an HTTP POST request with verification parameters\n  3. Reading and parsing the server response\n  4. Returning the verification result as JSON string\n  Returns either the server response or error JSON if the request/response fails",
    "Canonical_solution": "class ReCaptchaSocketPostRequestMethod implements ReCaptchaRequestMethod\n{\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"invalid-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n    private $socket;\n\n    public function __construct(ReCaptchaSocket $socket = null)\n    {\n        if (!is_null($socket)) {\n            $this->socket = $socket;\n        } else {\n            $this->socket = new ReCaptchaSocket();\n        }\n    }\n\n    public function submit(ReCaptchaRequestParameters $params)\n    {\n        $errno = 0;\n        $errstr = '';\n\n        if (false === $this->socket->fsockopen('ssl://' . self::RECAPTCHA_HOST, 443, $errno, $errstr, 30)) {\n            return self::BAD_REQUEST;\n        }\n\n        $content = $params->toQueryString();\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-length: \" . strlen($content) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $content . \"\\r\\n\\r\\n\";\n\n        $this->socket->fwrite($request);\n        $response = '';\n\n        while (!$this->socket->feof()) {\n            $response .= $this->socket->fgets(4096);\n        }\n\n        $this->socket->fclose();\n\n        if (0 !== strpos($response, 'HTTP/1.1 200 OK')) {\n            return self::BAD_RESPONSE;\n        }\n\n        $parts = preg_split(\"#\\n\\s*\\n#Uis\", $response);\n\n        return $parts[1];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 131,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nclass ReCaptchaSocket {\n    public function fsockopen($hostname, $port, &$errno, &$errstr, $timeout) {}\n    public function fwrite($handle, $string, $length = null) {}\n    public function fread($handle, $length) {}\n    public function fclose($handle) {}\n    public function stream_set_timeout($handle, $seconds, $microseconds = 0) {}\n}\n\nclass ReCaptchaRequestParameters {\n    public $secret;\n    public $response;\n    public function __construct($secret, $response) {\n        $this->secret = $secret;\n        $this->response = $response;\n    }\n}\n\n\nclass ReCaptchaSocketPostRequestMethod {\n\n    private $socket;\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"bad-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null) {\n        $this->socket = $socket ?: new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params) {\n        $errno = 0;\n        $errstr = '';\n\n        $handle = $this->socket->fsockopen('ssl://' . self::RECAPTCHA_HOST, 443, $errno, $errstr, 30);\n\n        if (!$handle) {\n            return self::BAD_REQUEST;\n        }\n\n        $this->socket->stream_set_timeout($handle, 30);\n\n        $data = http_build_query([\n            'secret'   => $params->secret,\n            'response' => $params->response,\n        ]);\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-Length: \" . strlen($data) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $data;\n\n        if ($this->socket->fwrite($handle, $request) === false) {\n            $this->socket->fclose($handle);\n            return self::BAD_REQUEST;\n        }\n\n        $response = '';\n        while (!feof($handle)) {\n            $response .= $this->socket->fread($handle, 1024);\n        }\n\n        $this->socket->fclose($handle);\n\n        $response = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (!isset($response[1])) {\n            return self::BAD_RESPONSE;\n        }\n        return $response[1];\n    }\n}\n",
      "<?php\n\nclass ReCaptchaSocket {\n    public function fsockopen($hostname, $port, &$errno, &$errstr, $timeout) {}\n    public function fwrite($handle, $string, $length = null) {}\n    public function fread($handle, $length) {}\n    public function fclose($handle) {}\n}\n\nclass ReCaptchaRequestParameters {\n    public $secret;\n    public $response;\n    public function __construct($secret, $response) {\n        $this->secret = $secret;\n        $this->response = $response;\n    }\n}\n\n\nclass ReCaptchaSocketPostRequestMethod {\n\n    private $socket;\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"bad-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null) {\n        $this->socket = $socket ?: new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params) {\n        $errno = 0;\n        $errstr = '';\n\n        $handle = $this->socket->fsockopen('ssl://' . self::RECAPTCHA_HOST, 443, $errno, $errstr, 5);\n\n        if (!$handle) {\n            return self::BAD_REQUEST;\n        }\n\n        $data = http_build_query([\n            'secret'   => $params->secret,\n            'response' => $params->response,\n        ]);\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-Length: \" . strlen($data) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $data;\n\n        $this->socket->fwrite($handle, $request);\n\n        $response = '';\n        while (!feof($handle)) {\n            $response .= $this->socket->fread($handle, 1024);\n        }\n\n        $this->socket->fclose($handle);\n\n        $response = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $responseBody = isset($response[1]) ? $response[1] : null;\n\n        if (!$responseBody) {\n            return self::BAD_RESPONSE;\n        }\n\n        return $responseBody;\n    }\n}\n?>\n",
      "<?php\n\nclass ReCaptchaSocketPostRequestMethod\n{\n    private $socket;\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"bad-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null)\n    {\n        $this->socket = $socket ?: new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params)\n    {\n        $errno = 0;\n        $errstr = '';\n\n        $options = [\n            'ssl' => [\n                'verify_peer' => true,\n                'verify_peer_name' => true,\n            ],\n        ];\n\n        $context = stream_context_create($options);\n\n        $fp = stream_socket_client(\n            'ssl://' . self::RECAPTCHA_HOST . ':443',\n            $errno,\n            $errstr,\n            30,\n            STREAM_CLIENT_CONNECT,\n            $context\n        );\n\n        if (!$fp) {\n            return self::BAD_REQUEST;\n        }\n\n        $data = $params->toQueryString();\n\n        $header = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $header .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $header .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $header .= \"Content-Length: \" . strlen($data) . \"\\r\\n\";\n        $header .= \"Connection: close\\r\\n\\r\\n\";\n        $header .= $data;\n\n        fwrite($fp, $header);\n\n        $response = '';\n        while (!feof($fp)) {\n            $response .= fgets($fp, 1024);\n        }\n\n        fclose($fp);\n\n        $response = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n        if (!isset($response[1])) {\n            return self::BAD_RESPONSE;\n        }\n\n        return $response[1];\n    }\n}\n",
      "<?php\n\nclass ReCaptchaSocket\n{\n    public function fsockopen($hostname, $port, &$errno, &$errstr, $timeout) {}\n    public function fwrite($handle, $string, $length = null) {}\n    public function fread($handle, $length) {}\n    public function fclose($handle) {}\n}\n\nclass ReCaptchaRequestParameters\n{\n    public $secret;\n    public $response;\n    public function __construct($secret, $response) {\n        $this->secret = $secret;\n        $this->response = $response;\n    }\n}\n\n\nclass ReCaptchaSocketPostRequestMethod\n{\n    private $socket;\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"bad-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null)\n    {\n        $this->socket = $socket ?: new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params)\n    {\n        $errno = 0;\n        $errstr = '';\n\n        $handle = $this->socket->fsockopen('ssl://' . self::RECAPTCHA_HOST, 443, $errno, $errstr, 5);\n\n        if (!$handle) {\n            return self::BAD_REQUEST;\n        }\n\n        $data = http_build_query([\n            'secret' => $params->secret,\n            'response' => $params->response,\n        ]);\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-Length: \" . strlen($data) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $data;\n\n        $this->socket->fwrite($handle, $request);\n\n        $response = '';\n        while (!feof($handle)) {\n            $response .= $this->socket->fread($handle, 1024);\n        }\n\n        $this->socket->fclose($handle);\n\n        $response = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $responseBody = isset($response[1]) ? $response[1] : null;\n\n        if (!$responseBody) {\n            return self::BAD_RESPONSE;\n        }\n\n        return $responseBody;\n    }\n}\n",
      "<?php\n\nclass ReCaptchaSocket {\n    public function open($host, $port, $timeout) {}\n    public function write($data) {}\n    public function read($length) {}\n    public function close() {}\n}\n\nclass ReCaptchaRequestParameters {\n    public $secret;\n    public $response;\n    public function __construct($secret, $response) {\n        $this->secret = $secret;\n        $this->response = $response;\n    }\n}\n\nclass ReCaptchaSocketPostRequestMethod {\n\n    private $socket;\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"bad-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null) {\n        $this->socket = $socket ?? new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params) {\n        $errno = 0;\n        $errstr = '';\n\n        $result = $this->socket->open(self::RECAPTCHA_HOST, 443, 10);\n        if (!$result) return self::BAD_REQUEST;\n\n        $content = http_build_query([\n            'secret' => $params->secret,\n            'response' => $params->response,\n        ]);\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-Length: \" . strlen($content) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $content;\n\n        $this->socket->write($request);\n\n        $response = '';\n        while ($chunk = $this->socket->read(1024)) {\n            $response .= $chunk;\n        }\n\n        $this->socket->close();\n\n        $response_array = explode(\"\\r\\n\\r\\n\", $response);\n        if (count($response_array) < 2) return self::BAD_RESPONSE;\n\n        return $response_array[1];\n    }\n}\n?>\n",
      "<?php\n\nclass ReCaptchaSocket\n{\n    public function fsockopen($hostname, $port, &$errno, &$errstr, $timeout) {}\n    public function fwrite($handle, $string, $length = null) {}\n    public function fread($handle, $length) {}\n    public function fclose($handle) {}\n}\n\nclass ReCaptchaRequestParameters\n{\n    public $secret;\n    public $response;\n    public function __construct($secret, $response) {\n        $this->secret = $secret;\n        $this->response = $response;\n    }\n}\n\n\nclass ReCaptchaSocketPostRequestMethod\n{\n    private $socket;\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"bad-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null)\n    {\n        $this->socket = $socket ?: new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params)\n    {\n        $errno = 0;\n        $errstr = '';\n\n        $handle = $this->socket->fsockopen('ssl://' . self::RECAPTCHA_HOST, 443, $errno, $errstr, 5);\n\n        if (!$handle) {\n            return self::BAD_REQUEST;\n        }\n\n        $data = http_build_query([\n            'secret' => $params->secret,\n            'response' => $params->response,\n        ]);\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-Length: \" . strlen($data) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $data;\n\n        $this->socket->fwrite($handle, $request);\n\n        $response = '';\n        while (!feof($handle)) {\n            $response .= $this->socket->fread($handle, 1024);\n        }\n\n        $this->socket->fclose($handle);\n\n        $response = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $responseBody = isset($response[1]) ? $response[1] : null;\n\n\n        if (!$responseBody) {\n            return self::BAD_RESPONSE;\n        }\n\n        return $responseBody;\n    }\n}\n",
      "<?php\n\nclass ReCaptchaSocket {\n    public function open($host, $port, $timeout) {}\n    public function write($data) {}\n    public function read($length) {}\n    public function close() {}\n}\n\nclass ReCaptchaRequestParameters {\n    public $secret;\n    public $response;\n    public function __construct($secret, $response) {\n        $this->secret = $secret;\n        $this->response = $response;\n    }\n}\n\nclass ReCaptchaSocketPostRequestMethod {\n\n    private $socket;\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"bad-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null) {\n        $this->socket = $socket ?: new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params) {\n        $errno = 0;\n        $errstr = '';\n\n        $result = $this->socket->open(self::RECAPTCHA_HOST, 443, 10);\n        if (!$result) {\n            return self::BAD_REQUEST;\n        }\n\n        $content = http_build_query([\n            'secret' => $params->secret,\n            'response' => $params->response,\n        ]);\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-Length: \" . strlen($content) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $content;\n\n        if (!$this->socket->write($request)) {\n            $this->socket->close();\n            return self::BAD_REQUEST;\n        }\n\n        $response = '';\n        while ($chunk = $this->socket->read(4096)) {\n            $response .= $chunk;\n        }\n\n        $this->socket->close();\n\n        $response_array = explode(\"\\r\\n\\r\\n\", $response);\n        if (count($response_array) < 2) {\n            return self::BAD_RESPONSE;\n        }\n\n        return $response_array[1];\n    }\n}\n?>\n",
      "<?php\n\nclass ReCaptchaSocket {\n    public function fsockopen($hostname, $port, &$errno, &$errstr, $timeout) {}\n    public function fwrite($handle, $string, $length = null) {}\n    public function fread($handle, $length) {}\n    public function fclose($handle) {}\n    public function stream_set_timeout($handle, $seconds, $microseconds = 0) {}\n}\n\nclass ReCaptchaRequestParameters {\n    public $secret;\n    public $response;\n    public function __construct($secret, $response) {\n        $this->secret = $secret;\n        $this->response = $response;\n    }\n}\n\n\nclass ReCaptchaSocketPostRequestMethod {\n\n    private $socket;\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"bad-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null) {\n        $this->socket = $socket ?: new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params) {\n        $errno = 0;\n        $errstr = '';\n\n        $handle = $this->socket->fsockopen('ssl://' . self::RECAPTCHA_HOST, 443, $errno, $errstr, 5);\n\n        if ($handle === false) {\n            return self::BAD_REQUEST;\n        }\n\n        $this->socket->stream_set_timeout($handle, 5);\n\n        $data = http_build_query([\n            'secret'   => $params->secret,\n            'response' => $params->response,\n        ]);\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-Length: \" . strlen($data) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $data;\n\n        if ($this->socket->fwrite($handle, $request) === false) {\n            $this->socket->fclose($handle);\n            return self::BAD_REQUEST;\n        }\n\n        $response = '';\n        while (!feof($handle)) {\n            $response .= $this->socket->fread($handle, 1024);\n        }\n\n        $this->socket->fclose($handle);\n\n        $response = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (!isset($response[1])) {\n            return self::BAD_RESPONSE;\n        }\n        return $response[1];\n    }\n}\n",
      "<?php\n\nclass ReCaptchaSocket\n{\n    public function fsockopen($hostname, $port, &$errno, &$errstr, $timeout) {}\n    public function fwrite($handle, $string, $length = null) {}\n    public function fread($handle, $length) {}\n    public function fclose($handle) {}\n}\n\nclass ReCaptchaRequestParameters\n{\n    public $secret;\n    public $response;\n    public function __construct($secret, $response) {\n        $this->secret = $secret;\n        $this->response = $response;\n    }\n}\n\n\nclass ReCaptchaSocketPostRequestMethod\n{\n    private $socket;\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"bad-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null)\n    {\n        $this->socket = $socket ?: new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params)\n    {\n        $errno = 0;\n        $errstr = '';\n\n        $handle = $this->socket->fsockopen('ssl://' . self::RECAPTCHA_HOST, 443, $errno, $errstr, 5);\n\n        if (!$handle) {\n            return self::BAD_REQUEST;\n        }\n\n        $data = http_build_query([\n            'secret' => $params->secret,\n            'response' => $params->response,\n        ]);\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-Length: \" . strlen($data) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $data;\n\n        $this->socket->fwrite($handle, $request);\n\n        $response = '';\n        while (!feof($handle)) {\n            $response .= $this->socket->fread($handle, 1024);\n        }\n\n        $this->socket->fclose($handle);\n\n        $response = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $responseBody = isset($response[1]) ? $response[1] : '';\n\n        if (empty($responseBody)) {\n            return self::BAD_RESPONSE;\n        }\n\n        return $responseBody;\n    }\n}\n",
      "<?php\n\nclass ReCaptchaSocket {\n    public function open($host, $port, $timeout) {}\n    public function write($data) {}\n    public function read($length) {}\n    public function close() {}\n}\n\nclass ReCaptchaRequestParameters {\n    public $secret;\n    public $response;\n    public function __construct($secret, $response) {\n        $this->secret = $secret;\n        $this->response = $response;\n    }\n}\n\nclass ReCaptchaSocketPostRequestMethod {\n\n    private $socket;\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"bad-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null) {\n        $this->socket = $socket ?? new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params) {\n        $errno = 0;\n        $errstr = '';\n\n        $result = $this->socket->open(self::RECAPTCHA_HOST, 443, 10);\n        if (!$result) {\n            return self::BAD_REQUEST;\n        }\n\n        $content = http_build_query([\n            'secret' => $params->secret,\n            'response' => $params->response,\n        ]);\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-Length: \" . strlen($content) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $content;\n\n        $this->socket->write($request);\n\n        $response = '';\n        while ($chunk = $this->socket->read(1024)) {\n            $response .= $chunk;\n        }\n\n        $this->socket->close();\n\n        $response_array = explode(\"\\r\\n\\r\\n\", $response);\n        if (count($response_array) < 2) {\n            return self::BAD_RESPONSE;\n        }\n\n        return $response_array[1];\n    }\n}\n?>\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a PHP class for handling HTTP/HTTPS communications using either socket-based connections (via fsockopen) or cURL, supporting both standard and persistent connections, with proper header and cookie management.\n\nClass Description: The soap_transport_http class provides low-level HTTP transport capabilities for SOAP communications, supporting both socket and cURL implementations. It handles connection management, request/response processing, and error handling.\n\nAttributes:\n- url: string - The target URL for HTTP requests\n- uri: string - The URI portion of the URL\n- scheme: string - The protocol scheme (http/https)\n- host: string - The target hostname\n- port: string - The target port number\n- path: string - The path portion of the URL\n- request_method: string - HTTP method (default: POST)\n- protocol_version: string - HTTP version (default: 1.0)\n- outgoing_headers: array - Headers to be sent with the request\n- incoming_headers: array - Headers received in the response\n- outgoing_payload: string - Data to be sent in the request\n- incoming_payload: string - Data received in the response\n- persistentConnection: bool - Flag for persistent connections\n- use_curl: bool - Flag to use cURL instead of sockets\n- proxy: array|null - Proxy configuration if used\n\nMethods:\n- __construct(string $url, array $curl_options=null, bool $use_curl=false) -> void - Initializes the transport with target URL and options\n- connect(int $connection_timeout=0, int $response_timeout=30) -> bool - Establishes connection to server\n- send(string $data, int $timeout=0, int $response_timeout=30, array $cookies=null) -> mixed - Sends data and returns response\n- sendRequest(string $data, array $cookies=null) -> bool - Sends the HTTP request with headers\n- getResponse() -> string|bool - Reads and processes the server response\n- setHeader(string $name, string $value) -> void - Adds a header to outgoing request\n- setCurlOption(mixed $option, mixed $value) -> void - Sets cURL option when using cURL\n- parseCookie(string $cookie_str) -> array|bool - Parses Set-Cookie header into array",
    "Canonical_solution": "class soap_transport_http extends nusoap_base {\n    var $url = '';\n    var $uri = '';\n    var $digest_uri = '';\n    var $scheme = '';\n    var $host = '';\n    var $port = '';\n    var $path = '';\n    var $request_method = 'POST';\n    var $protocol_version = '1.0';\n    var $encoding = '';\n    var $outgoing_headers = array();\n    var $incoming_headers = array();\n    var $incoming_cookies = array();\n    var $outgoing_payload = '';\n    var $incoming_payload = '';\n    var $response_status_line;\n    var $useSOAPAction = true;\n    var $persistentConnection = false;\n    var $ch = false;\n    var $ch_options = array();\n    var $use_curl = false;\n    var $proxy = null;\n    var $username = '';\n    var $password = '';\n    var $authtype = '';\n    var $digestRequest = array();\n    var $certRequest = array();\n\n    function soap_transport_http($url, $curl_options = NULL, $use_curl = false) {\n        parent::nusoap_base();\n        $this->debug(\"ctor url=$url use_curl=$use_curl curl_options:\");\n        $this->appendDebug($this->varDump($curl_options));\n        $this->setURL($url);\n        if (is_array($curl_options)) {\n            $this->ch_options = $curl_options;\n        }\n        $this->use_curl = $use_curl;\n        preg_match('/\\$Revisio' . 'n: ([^ ]+)/', $this->revision, $rev);\n        $this->setHeader('User-Agent', $this->title.'/'.$this->version.' ('.$rev[1].')');\n    }\n\n    function connect($connection_timeout=0,$response_timeout=30) {\n        $this->debug(\"connect connection_timeout $connection_timeout, response_timeout $response_timeout, scheme $this->scheme, host $this->host, port $this->port\");\n        if ($this->io_method() == 'socket') {\n            if (!is_array($this->proxy)) {\n                $host = $this->host;\n                $port = $this->port;\n            } else {\n                $host = $this->proxy['host'];\n                $port = $this->proxy['port'];\n            }\n\n            if($this->persistentConnection && isset($this->fp) && is_resource($this->fp)){\n                if (!feof($this->fp)) {\n                    $this->debug('Re-use persistent connection');\n                    return true;\n                }\n                fclose($this->fp);\n                $this->debug('Closed persistent connection at EOF');\n            }\n\n            if ($this->scheme == 'ssl') {\n                $host = 'ssl://' . $host;\n            }\n            $this->debug('calling fsockopen with host ' . $host . ' connection_timeout ' . $connection_timeout);\n\n            if($connection_timeout > 0){\n                $this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str, $connection_timeout);\n            } else {\n                $this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str);\n            }\n            \n            if(!$this->fp) {\n                $msg = 'Couldn\\'t open socket connection to server ' . $this->url;\n                if ($this->errno) {\n                    $msg .= ', Error ('.$this->errno.'): '.$this->error_str;\n                } else {\n                    $msg .= ' prior to connect().  This is often a problem looking up the host name.';\n                }\n                $this->debug($msg);\n                $this->setError($msg);\n                return false;\n            }\n            \n            $this->debug('set response timeout to ' . $response_timeout);\n            socket_set_timeout( $this->fp, $response_timeout);\n\n            $this->debug('socket connected');\n            return true;\n        } else if ($this->io_method() == 'curl') {\n            if (!extension_loaded('curl')) {\n                $this->setError('The PHP cURL Extension is required for HTTPS or NLTM.  You will need to re-build or update your PHP to include cURL or change php.ini to load the PHP cURL extension.');\n                return false;\n            }\n            $this->debug('connect using cURL');\n            $this->ch = curl_init();\n            $hostURL = ($this->port != '') ? \"$this->scheme://$this->host:$this->port\" : \"$this->scheme://$this->host\";\n            $hostURL .= $this->path;\n            $this->setCurlOption(CURLOPT_URL, $hostURL);\n            if (ini_get('safe_mode') || ini_get('open_basedir')) {\n                $this->debug('safe_mode or open_basedir set, so do not set CURLOPT_FOLLOWLOCATION');\n            } else {\n                $this->setCurlOption(CURLOPT_FOLLOWLOCATION, 1);\n            }\n            $this->setCurlOption(CURLOPT_HEADER, 1);\n            $this->setCurlOption(CURLOPT_RETURNTRANSFER, 1);\n            if ($this->persistentConnection) {\n                $this->persistentConnection = false;\n                $this->setHeader('Connection', 'close');\n            }\n            if ($connection_timeout != 0) {\n                $this->setCurlOption(CURLOPT_CONNECTIONTIMEOUT, $connection_timeout);\n            }\n            if ($response_timeout != 0) {\n                $this->setCurlOption(CURLOPT_TIMEOUT, $response_timeout);\n            }\n            $this->debug('cURL connection set up');\n            return true;\n        } else {\n            $this->setError('Unknown scheme ' . $this->scheme);\n            $this->debug('Unknown scheme ' . $this->scheme);\n            return false;\n        }\n    }\n\n    function send($data, $timeout=0, $response_timeout=30, $cookies=NULL) {\n        $this->debug('entered send() with data of length: '.strlen($data));\n        $this->tryagain = true;\n        $tries = 0;\n        while ($this->tryagain) {\n            $this->tryagain = false;\n            if ($tries++ < 2) {\n                if (!$this->connect($timeout, $response_timeout)){\n                    return false;\n                }\n                if (!$this->sendRequest($data, $cookies)){\n                    return false;\n                }\n                $respdata = $this->getResponse();\n            } else {\n                $this->setError(\"Too many tries to get an OK response ($this->response_status_line)\");\n            }\n        }        \n        $this->debug('end of send()');\n        return $respdata;\n    }\n\n    function sendRequest($data, $cookies = NULL) {\n        $cookie_str = $this->getCookiesForRequest($cookies, (($this->scheme == 'ssl') || ($this->scheme == 'https')));\n        $this->buildPayload($data, $cookie_str);\n        if ($this->io_method() == 'socket') {\n            if(!fputs($this->fp, $this->outgoing_payload, strlen($this->outgoing_payload))) {\n                $this->setError('couldn\\'t write message data to socket');\n                $this->debug('couldn\\'t write message data to socket');\n                return false;\n            }\n            $this->debug('wrote data to socket, length = ' . strlen($this->outgoing_payload));\n            return true;\n        } else if ($this->io_method() == 'curl') {\n            $curl_headers = array();\n            foreach($this->outgoing_headers as $k => $v){\n                if ($k == 'Connection' || $k == 'Content-Length' || $k == 'Host' || $k == 'Authorization' || $k == 'Proxy-Authorization') {\n                    $this->debug(\"Skip cURL header $k: $v\");\n                } else {\n                    $curl_headers[] = \"$k: $v\";\n                }\n            }\n            if ($cookie_str != '') {\n                $curl_headers[] = 'Cookie: ' . $cookie_str;\n            }\n            $this->setCurlOption(CURLOPT_HTTPHEADER, $curl_headers);\n            $this->debug('set cURL HTTP headers');\n            if ($this->request_method == \"POST\") {\n                $this->setCurlOption(CURLOPT_POST, 1);\n                $this->setCurlOption(CURLOPT_POSTFIELDS, $data);\n                $this->debug('set cURL POST data');\n            }\n            foreach ($this->ch_options as $key => $val) {\n                $this->setCurlOption($key, $val);\n            }\n            $this->debug('set cURL payload');\n            return true;\n        }\n    }\n\n    function getResponse(){\n        $this->incoming_payload = '';\n        if ($this->io_method() == 'socket') {\n            $data = '';\n            while (!isset($lb)){\n                if(feof($this->fp)) {\n                    $this->incoming_payload = $data;\n                    $this->debug('found no headers before EOF after length ' . strlen($data));\n                    $this->debug(\"received before EOF:\\n\" . $data);\n                    $this->setError('server failed to send headers');\n                    return false;\n                }\n                $tmp = fgets($this->fp, 256);\n                $tmplen = strlen($tmp);\n                $this->debug(\"read line of $tmplen bytes: \" . trim($tmp));\n                if ($tmplen == 0) {\n                    $this->incoming_payload = $data;\n                    $this->debug('socket read of headers timed out after length ' . strlen($data));\n                    $this->debug(\"read before timeout: \" . $data);\n                    $this->setError('socket read of headers timed out');\n                    return false;\n                }\n                $data .= $tmp;\n                $pos = strpos($data,\"\\r\\n\\r\\n\");\n                if($pos > 1){\n                    $lb = \"\\r\\n\";\n                } else {\n                    $pos = strpos($data,\"\\n\\n\");\n                    if($pos > 1){\n                        $lb = \"\\n\";\n                    }\n                }\n                if (isset($lb) && preg_match('/^HTTP\\/1.1 100/',$data)) {\n                    unset($lb);\n                    $data = '';\n                }\n            }\n            $this->incoming_payload .= $data;\n            $this->debug('found end of headers after length ' . strlen($data));\n            $header_data = trim(substr($data,0,$pos));\n            $header_array = explode($lb,$header_data);\n            $this->incoming_headers = array();\n            $this->incoming_cookies = array();\n            foreach($header_array as $header_line){\n                $arr = explode(':',$header_line, 2);\n                if(count($arr) > 1){\n                    $header_name = strtolower(trim($arr[0]));\n                    $this->incoming_headers[$header_name] = trim($arr[1]);\n                    if ($header_name == 'set-cookie') {\n                        $cookie = $this->parseCookie(trim($arr[1]));\n                        if ($cookie) {\n                            $this->incoming_cookies[] = $cookie;\n                            $this->debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);\n                        } else {\n                            $this->debug('did not find cookie in ' . trim($arr[1]));\n                        }\n                    }\n                } else if (isset($header_name)) {\n                    $this->incoming_headers[$header_name] .= $lb . ' ' . $header_line;\n                }\n            }\n            if (isset($this->incoming_headers['transfer-encoding']) && strtolower($this->incoming_headers['transfer-encoding']) == 'chunked') {\n                $content_length =  2147483647;\n                $chunked = true;\n                $this->debug(\"want to read chunked content\");\n            } elseif (isset($this->incoming_headers['content-length'])) {\n                $content_length = $this->incoming_headers['content-length'];\n                $chunked = false;\n                $this->debug(\"want to read content of length $content_length\");\n            } else {\n                $content_length =  2147483647;\n                $chunked = false;\n                $this->debug(\"want to read content to EOF\");\n            }\n            $data = '';\n            do {\n                if ($chunked) {\n                    $tmp = fgets($this->fp, 256);\n                    $tmplen = strlen($tmp);\n                    $this->debug(\"read chunk line of $tmplen bytes\");\n                    if ($tmplen == 0) {\n                        $this->incoming_payload = $data;\n                        $this->debug('socket read of chunk length timed out after length ' . strlen($data));\n                        $this->debug(\"read before timeout:\\n\" . $data);\n                        $this->setError('socket read of chunk length timed out');\n                        return false;\n                    }\n                    $content_length = hexdec(trim($tmp));\n                    $this->debug(\"chunk length $content_length\");\n                }\n                $strlen = 0;\n                while (($strlen < $content_length) && (!feof($this->fp))) {\n                    $readlen = min(8192, $content_length - $strlen);\n                    $tmp = fread($this->fp, $readlen);\n                    $tmplen = strlen($tmp);\n                    $this->debug(\"read buffer of $tmplen bytes\");\n                    if (($tmplen == 0) && (!feof($this->fp))) {\n                        $this->incoming_payload = $data;\n                        $this->debug('socket read of body timed out after length ' . strlen($data));\n                        $this->debug(\"read before timeout:\\n\" . $data);\n                        $this->setError('socket read of body timed out');\n                        return false;\n                    }\n                    $strlen += $tmplen;\n                    $data .= $tmp;\n                }\n                if ($chunked && ($content_length > 0)) {\n                    $tmp = fgets($this->fp, 256);\n                    $tmplen = strlen($tmp);\n                    $this->debug(\"read chunk terminator of $tmplen bytes\");\n                    if ($tmplen == 0) {\n                        $this->incoming_payload = $data;\n                        $this->debug('socket read of chunk terminator timed out after length ' . strlen($data));\n                        $this->debug(\"read before timeout:\\n\" . $data);\n                        $this->setError('socket read of chunk terminator timed out');\n                        return false;\n                    }\n                }\n            } while ($chunked && ($content_length > 0) && (!feof($this->fp)));\n            if (feof($this->fp)) {\n                $this->debug('read to EOF');\n            }\n            $this->debug('read body of length ' . strlen($data));\n            $this->incoming_payload .= $data;\n            $this->debug('received a total of '.strlen($this->incoming_payload).' bytes of data from server');\n            if(\n                (isset($this->incoming_headers['connection']) && strtolower($this->incoming_headers['connection']) == 'close') || \n                (! $this->persistentConnection) || feof($this->fp)){\n                fclose($this->fp);\n                $this->fp = false;\n                $this->debug('closed socket');\n            }\n            if($this->incoming_payload == ''){\n                $this->setError('no response from server');\n                return false;\n            }\n            return $data;\n        } else if ($this->io_method() == 'curl') {\n            $this->debug('send and receive with cURL');\n            $this->incoming_payload = curl_exec($this->ch);\n            $data = $this->incoming_payload;\n            $cErr = curl_error($this->ch);\n            if ($cErr != '') {\n                $err = 'cURL ERROR: '.curl_errno($this->ch).': '.$cErr.'<br>';\n                foreach(curl_getinfo($this->ch) as $k => $v){\n                    $err .= \"$k: $v<br>\";\n                }\n                $this->debug($err);\n                $this->setError($err);\n                curl_close($this->ch);\n                return false;\n            }\n            $this->debug('No cURL error, closing cURL');\n            curl_close($this->ch);\n            $savedata = $data;\n            while ($this->isSkippableCurlHeader($data)) {\n                $this->debug(\"Found HTTP header to skip\");\n                if ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\n                    $data = ltrim(substr($data,$pos));\n                } elseif($pos = strpos($data,\"\\n\\n\") ) {\n                    $data = ltrim(substr($data,$pos));\n                }\n            }\n            if ($data == '') {\n                $data = $savedata;\n                while (preg_match('/^HTTP\\/1.1 100/',$data)) {\n                    if ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\n                        $data = ltrim(substr($data,$pos));\n                    } elseif($pos = strpos($data,\"\\n\\n\") ) {\n                        $data = ltrim(substr($data,$pos));\n                    }\n                }\n            }\n            if ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\n                $lb = \"\\r\\n\";\n            } elseif( $pos = strpos($data,\"\\n\\n\")) {\n                $lb = \"\\n\";\n            } else {\n                $this->debug('no proper separation of headers and document');\n                $this->setError('no proper separation of headers and document');\n                return false;\n            }\n            $header_data = trim(substr($data,0,$pos));\n            $header_array = explode($lb,$header_data);\n            $data = ltrim(substr($data,$pos));\n            $this->debug('found proper separation of headers and document');\n            $this->debug('cleaned data, stringlen: '.strlen($data));\n            foreach ($header_array as $header_line) {\n                $arr = explode(':',$header_line",
    "Code_level": "Class-level",
    "FSMID_for_test": 131,
    "matched_results": [],
    "unmatched_results": [
      "<?php\nclass soap_transport_http {\n    public $url;\n    public $uri;\n    public $scheme;\n    public $host;\n    public $port;\n    public $path;\n    public $request_method = 'POST';\n    public $protocol_version = '1.0';\n    public $outgoing_headers = [];\n    public $incoming_headers = [];\n    public $outgoing_payload;\n    public $incoming_payload;\n    public $persistentConnection = false;\n    public $use_curl = false;\n    public $proxy = null;\n    private $ch;\n    private $fp;\n\n    public function __construct($url, $curl_options = null, $use_curl = false) {\n        $this->url = $url;\n        $parsed_url = parse_url($url);\n        $this->uri = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        if (isset($parsed_url['query'])) {\n            $this->uri .= '?' . $parsed_url['query'];\n        }\n        $this->scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] : 'http';\n        $this->host = isset($parsed_url['host']) ? $parsed_url['host'] : '';\n        $this->port = isset($parsed_url['port']) ? $parsed_url['port'] : ($this->scheme == 'https' ? 443 : 80);\n        $this->path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $this->use_curl = $use_curl;\n        if ($this->use_curl && is_array($curl_options)) {\n            foreach ($curl_options as $option => $value) {\n                $this->setCurlOption($option, $value);\n            }\n        }\n    }\n\n    public function connect($connection_timeout = 0, $response_timeout = 30) {\n        if ($this->use_curl) {\n            $this->ch = curl_init();\n            curl_setopt($this->ch, CURLOPT_URL, $this->url);\n            curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, $connection_timeout);\n            curl_setopt($this->ch, CURLOPT_TIMEOUT, $response_timeout);\n            if ($this->scheme == 'https') {\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, false);\n            }\n            if (is_array($this->proxy)) {\n                curl_setopt($this->ch, CURLOPT_PROXY, $this->proxy['host'] . ':' . $this->proxy['port']);\n                if (isset($this->proxy['user'])) {\n                    curl_setopt($this->ch, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['password']);\n                }\n            }\n            return true;\n        } else {\n            $host = ($this->port != 80 && $this->port != 443) ? $this->host . ':' . $this->port : $this->host;\n            $this->fp = @fsockopen(($this->scheme == 'https' ? 'ssl://' : '') . $host, $this->port, $errno, $errstr, $connection_timeout);\n            return $this->fp;\n        }\n    }\n\n    public function send($data, $timeout = 0, $response_timeout = 30, $cookies = null) {\n        $this->outgoing_payload = $data;\n        if (!$this->connect($timeout, $response_timeout)) {\n            return false;\n        }\n        if (!$this->sendRequest($data, $cookies)) {\n            return false;\n        }\n        return $this->getResponse();\n    }\n\n\n    public function sendRequest($data, $cookies = null) {\n        $headers = $this->outgoing_headers;\n        if (is_array($cookies)) {\n            $cookie_str = '';\n            foreach ($cookies as $name => $value) {\n                $cookie_str .= $name . '=' . $value . '; ';\n            }\n            $headers['Cookie'] = $cookie_str;\n        }\n\n        if ($this->use_curl) {\n            curl_setopt($this->ch, CURLOPT_HTTPHEADER, $this->formatHeaders($headers));\n            curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n            curl_setopt($this->ch, CURLOPT_CUSTOMREQUEST, $this->request_method);\n            $result = curl_exec($this->ch);\n\n            if ($result === false) {\n                return false;\n            }\n            $this->incoming_payload = $result;\n            $this->incoming_headers = curl_getinfo($this->ch, CURLINFO_HEADER_OUT);\n            return true;\n\n        } else {\n\n            $request = $this->request_method . ' ' . $this->uri . ' HTTP/' . $this->protocol_version . \"\\r\\n\";\n            $request .= 'Host: ' . $this->host . \"\\r\\n\";\n            foreach ($headers as $key => $value) {\n                $request .= $key . ': ' . $value . \"\\r\\n\";\n            }\n            $request .= \"Content-Length: \" . strlen($data) . \"\\r\\n\";\n            $request .= \"Connection: \" . ($this->persistentConnection ? 'Keep-Alive' : 'Close') . \"\\r\\n\\r\\n\";\n            $request .= $data;\n            fwrite($this->fp, $request);\n            return true;\n        }\n    }\n\n    public function getResponse() {\n        if ($this->use_curl) {\n            return $this->incoming_payload;\n        } else {\n            $response = '';\n            while (!feof($this->fp)) {\n                $response .= fread($this->fp, 8192);\n            }\n            if (!$this->persistentConnection) {\n                fclose($this->fp);\n            }\n\n            $this->incoming_payload = $response;\n            return $response;\n        }\n    }\n\n\n    public function setHeader($name, $value) {\n        $this->outgoing_headers[$name] = $value;\n    }\n\n    public function setCurlOption($option, $value) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, $option, $value);\n        }\n    }\n\n    private function formatHeaders($headers)\n    {\n        $formattedHeaders = [];\n        foreach ($headers as $key => $value) {\n            $formattedHeaders[] = $key . ': ' . $value;\n        }\n        return $formattedHeaders;\n    }\n\n    public function parseCookie($cookie_str) {\n        $cookies = [];\n        $parts = explode(';', $cookie_str);\n        foreach ($parts as $part) {\n            $pair = explode('=', trim($part), 2);\n            if (count($pair) == 2) {\n                $cookies[$pair[0]] = $pair[1];\n            }\n        }\n        return $cookies;\n    }\n}\n\n",
      "<?php\nclass soap_transport_http {\n    public $url;\n    public $uri;\n    public $scheme;\n    public $host;\n    public $port;\n    public $path;\n    public $request_method = 'POST';\n    public $protocol_version = '1.0';\n    public $outgoing_headers = [];\n    public $incoming_headers = [];\n    public $outgoing_payload;\n    public $incoming_payload;\n    public $persistentConnection = false;\n    public $use_curl = false;\n    public $proxy = null;\n    private $ch;\n    private $fp;\n\n    public function __construct($url, $curl_options = null, $use_curl = false) {\n        $this->url = $url;\n        $parsed_url = parse_url($url);\n        $this->uri = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        if (isset($parsed_url['query'])) {\n            $this->uri .= '?' . $parsed_url['query'];\n        }\n        $this->scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] : 'http';\n        $this->host = isset($parsed_url['host']) ? $parsed_url['host'] : '';\n        $this->port = isset($parsed_url['port']) ? $parsed_url['port'] : ($this->scheme == 'https' ? 443 : 80);\n        $this->path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $this->use_curl = $use_curl;\n        if ($this->use_curl && is_array($curl_options)) {\n            foreach ($curl_options as $option => $value) {\n                $this->setCurlOption($option, $value);\n            }\n        }\n    }\n\n    public function connect($connection_timeout = 0, $response_timeout = 30) {\n        if ($this->use_curl) {\n            $this->ch = curl_init();\n            curl_setopt($this->ch, CURLOPT_URL, $this->url);\n            curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, $connection_timeout);\n            curl_setopt($this->ch, CURLOPT_TIMEOUT, $response_timeout);\n            if ($this->scheme == 'https') {\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, false);\n            }\n            if (is_array($this->proxy)) {\n                curl_setopt($this->ch, CURLOPT_PROXY, $this->proxy['host'] . ':' . $this->proxy['port']);\n                if (isset($this->proxy['user'])) {\n                    curl_setopt($this->ch, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['password']);\n                }\n            }\n            return true;\n        } else {\n            $host = ($this->port != 80 && $this->port != 443) ? $this->host . ':' . $this->port : $this->host;\n            $this->fp = @fsockopen(($this->scheme == 'https' ? 'ssl://' : '') . $host, $this->port, $errno, $errstr, $connection_timeout);\n            return $this->fp;\n        }\n    }\n\n    public function send($data, $timeout = 0, $response_timeout = 30, $cookies = null) {\n        $this->outgoing_payload = $data;\n        if (!$this->sendRequest($data, $cookies)) {\n            return false;\n        }\n        return $this->getResponse();\n    }\n\n\n    public function sendRequest($data, $cookies = null) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, CURLOPT_CUSTOMREQUEST, $this->request_method);\n            curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n            $headers = [];\n            foreach ($this->outgoing_headers as $key => $value) {\n                $headers[] = $key . ': ' . $value;\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $headers[] = 'Cookie: ' . $cookie_string;\n            }\n            curl_setopt($this->ch, CURLOPT_HTTPHEADER, $headers);\n            return true;\n        } else {\n\n            $request = $this->request_method . ' ' . $this->uri . ' HTTP/' . $this->protocol_version . \"\\r\\n\";\n            $request .= 'Host: ' . $this->host . \"\\r\\n\";\n            foreach ($this->outgoing_headers as $key => $value) {\n                $request .= $key . ': ' . $value . \"\\r\\n\";\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $request .= 'Cookie: ' . $cookie_string . \"\\r\\n\";\n            }\n            $request .= 'Content-Length: ' . strlen($data) . \"\\r\\n\";\n            $request .= \"Connection: \" . ($this->persistentConnection ? 'Keep-Alive' : 'Close') . \"\\r\\n\\r\\n\";\n            $request .= $data;\n            fwrite($this->fp, $request);\n            return true;\n        }\n    }\n\n    public function getResponse() {\n        if ($this->use_curl) {\n            $response = curl_exec($this->ch);\n            $info = curl_getinfo($this->ch);\n            $this->incoming_headers = $this->parseHeaders($response);\n            $this->incoming_payload = $response;\n\n            if (curl_errno($this->ch)) {\n                return false;\n            }\n            return $response;\n\n        } else {\n            $response = '';\n            while (!feof($this->fp)) {\n                $response .= fread($this->fp, 8192);\n            }\n            if (!$this->persistentConnection) {\n                fclose($this->fp);\n            }\n\n            $this->incoming_headers = $this->parseHeaders($response);\n            list($headers, $this->incoming_payload) = explode(\"\\r\\n\\r\\n\", $response, 2);\n            return $this->incoming_payload;\n        }\n    }\n\n\n    public function setHeader($name, $value) {\n        $this->outgoing_headers[$name] = $value;\n    }\n\n    public function setCurlOption($option, $value) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, $option, $value);\n        }\n    }\n\n    private function parseHeaders($response) {\n        $headers = [];\n        $header_text = substr($response, 0, strpos($response, \"\\r\\n\\r\\n\"));\n        foreach (explode(\"\\r\\n\", $header_text) as $i => $line) {\n            if ($i === 0) {\n                continue;\n            }\n            list($key, $value) = explode(': ', $line, 2);\n            $headers[$key] = $value;\n        }\n        return $headers;\n    }\n\n\n    public function parseCookie($cookie_str) {\n        $cookies = [];\n        $parts = explode(';', $cookie_str);\n        foreach ($parts as $part) {\n            $pair = explode('=', $part, 2);\n            if (count($pair) == 2) {\n                $cookies[trim($pair[0])] = trim($pair[1]);\n            }\n        }\n        return $cookies;\n    }\n}\n\n",
      "<?php\nclass soap_transport_http {\n    public $url;\n    public $uri;\n    public $scheme;\n    public $host;\n    public $port;\n    public $path;\n    public $request_method = 'POST';\n    public $protocol_version = '1.0';\n    public $outgoing_headers = [];\n    public $incoming_headers = [];\n    public $outgoing_payload;\n    public $incoming_payload;\n    public $persistentConnection = false;\n    public $use_curl = false;\n    public $proxy = null;\n    private $fp;\n    private $ch;\n\n    public function __construct($url, $curl_options = null, $use_curl = false) {\n        $this->url = $url;\n        $parsed_url = parse_url($url);\n        $this->uri = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        if (isset($parsed_url['query'])) {\n            $this->uri .= '?' . $parsed_url['query'];\n        }\n        $this->scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] : 'http';\n        $this->host = isset($parsed_url['host']) ? $parsed_url['host'] : '';\n        $this->port = isset($parsed_url['port']) ? $parsed_url['port'] : ($this->scheme == 'https' ? 443 : 80);\n        $this->path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $this->use_curl = $use_curl;\n        if ($this->use_curl && is_array($curl_options)) {\n            foreach ($curl_options as $option => $value) {\n                $this->setCurlOption($option, $value);\n            }\n        }\n    }\n\n    public function connect($connection_timeout = 0, $response_timeout = 30) {\n        if ($this->use_curl) {\n            $this->ch = curl_init();\n            curl_setopt($this->ch, CURLOPT_URL, $this->url);\n            curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, $connection_timeout);\n            curl_setopt($this->ch, CURLOPT_TIMEOUT, $response_timeout);\n            if ($this->scheme == 'https') {\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, false);\n            }\n            if (is_array($this->proxy)) {\n                curl_setopt($this->ch, CURLOPT_PROXY, $this->proxy['host'] . ':' . $this->proxy['port']);\n                if (isset($this->proxy['user'])) {\n                    curl_setopt($this->ch, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['password']);\n                }\n            }\n            return true;\n        } else {\n            $host = ($this->port != 80 && $this->port != 443) ? $this->host . ':' . $this->port : $this->host;\n            $this->fp = @fsockopen(($this->scheme == 'https' ? 'ssl://' : '') . $host, $this->port, $errno, $errstr, $connection_timeout);\n            return $this->fp;\n        }\n    }\n\n    public function send($data, $timeout = 0, $response_timeout = 30, $cookies = null) {\n        $this->outgoing_payload = $data;\n        if (!$this->sendRequest($data, $cookies)) {\n            return false;\n        }\n        return $this->getResponse();\n    }\n\n\n    public function sendRequest($data, $cookies = null) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, CURLOPT_CUSTOMREQUEST, $this->request_method);\n            curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n            $headers = [];\n            foreach ($this->outgoing_headers as $key => $value) {\n                $headers[] = $key . ': ' . $value;\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $headers[] = 'Cookie: ' . $cookie_string;\n            }\n            curl_setopt($this->ch, CURLOPT_HTTPHEADER, $headers);\n            return true;\n        } else {\n            $request = $this->request_method . ' ' . $this->uri . ' HTTP/' . $this->protocol_version . \"\\r\\n\";\n            $request .= 'Host: ' . $this->host . \"\\r\\n\";\n            foreach ($this->outgoing_headers as $key => $value) {\n                $request .= $key . ': ' . $value . \"\\r\\n\";\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $request .= 'Cookie: ' . $cookie_string . \"\\r\\n\";\n            }\n\n            $request .= 'Content-Length: ' . strlen($data) . \"\\r\\n\";\n            $request .= \"Connection: \" . ($this->persistentConnection ? 'Keep-Alive' : 'Close') . \"\\r\\n\\r\\n\";\n            $request .= $data;\n            fwrite($this->fp, $request);\n            return true;\n        }\n    }\n\n    public function getResponse() {\n        if ($this->use_curl) {\n            $response = curl_exec($this->ch);\n            $info = curl_getinfo($this->ch);\n            $this->incoming_headers = $this->parseHeaders($response);\n            $this->incoming_payload = $response;\n            return $response;\n\n        } else {\n            $response = '';\n            while (!feof($this->fp)) {\n                $response .= fread($this->fp, 8192);\n            }\n            if (!$this->persistentConnection) {\n                fclose($this->fp);\n            }\n\n            $this->incoming_headers = $this->parseHeaders($response);\n            list($headers, $this->incoming_payload) = explode(\"\\r\\n\\r\\n\", $response, 2);\n            return $this->incoming_payload;\n        }\n    }\n\n\n    public function setHeader($name, $value) {\n        $this->outgoing_headers[$name] = $value;\n    }\n\n    public function setCurlOption($option, $value) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, $option, $value);\n        }\n    }\n\n    private function parseHeaders($response) {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", substr($response, 0, strpos($response, \"\\r\\n\\r\\n\")));\n        array_shift($lines);\n        foreach ($lines as $line) {\n            list($key, $value) = explode(':', $line, 2);\n            $headers[trim($key)] = trim($value);\n        }\n        return $headers;\n    }\n\n    public function parseCookie($cookie_str) {\n        $cookies = [];\n        $parts = explode(';', $cookie_str);\n        foreach ($parts as $part) {\n            $pair = explode('=', $part, 2);\n            if (count($pair) == 2) {\n                $cookies[trim($pair[0])] = trim($pair[1]);\n            }\n        }\n        return $cookies;\n    }\n}\n\n",
      "<?php\nclass soap_transport_http {\n    public $url;\n    public $uri;\n    public $scheme;\n    public $host;\n    public $port;\n    public $path;\n    public $request_method = 'POST';\n    public $protocol_version = '1.0';\n    public $outgoing_headers = [];\n    public $incoming_headers = [];\n    public $outgoing_payload;\n    public $incoming_payload;\n    public $persistentConnection = false;\n    public $use_curl = false;\n    public $proxy = null;\n    private $fp;\n    private $ch;\n\n    public function __construct($url, $curl_options = null, $use_curl = false) {\n        $this->url = $url;\n        $parsed_url = parse_url($url);\n        $this->uri = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        if (isset($parsed_url['query'])) {\n            $this->uri .= '?' . $parsed_url['query'];\n        }\n        $this->scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] : 'http';\n        $this->host = isset($parsed_url['host']) ? $parsed_url['host'] : 'localhost';\n        $this->port = isset($parsed_url['port']) ? $parsed_url['port'] : ($this->scheme == 'https' ? 443 : 80);\n        $this->path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $this->use_curl = $use_curl;\n        if ($this->use_curl && is_array($curl_options)) {\n            foreach ($curl_options as $option => $value) {\n                $this->setCurlOption($option, $value);\n            }\n        }\n    }\n\n    public function connect($connection_timeout = 0, $response_timeout = 30) {\n        if ($this->use_curl) {\n            $this->ch = curl_init();\n            curl_setopt($this->ch, CURLOPT_URL, $this->url);\n            curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, $connection_timeout);\n            curl_setopt($this->ch, CURLOPT_TIMEOUT, $response_timeout);\n            if ($this->scheme == 'https') {\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, false);\n            }\n            if (is_array($this->proxy)) {\n                curl_setopt($this->ch, CURLOPT_PROXY, $this->proxy['host'] . ':' . $this->proxy['port']);\n                if (isset($this->proxy['user'])) {\n                    curl_setopt($this->ch, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['password']);\n                }\n            }\n            return true;\n        } else {\n            $host = ($this->port != 80 && $this->port != 443) ? $this->host . ':' . $this->port : $this->host;\n            $this->fp = @fsockopen(($this->scheme == 'https' ? 'ssl://' : '') . $host, $this->port, $errno, $errstr, $connection_timeout);\n            return $this->fp;\n        }\n    }\n\n    public function send($data, $timeout = 0, $response_timeout = 30, $cookies = null) {\n        $this->outgoing_payload = $data;\n        if (!$this->sendRequest($data, $cookies)) {\n            return false;\n        }\n        return $this->getResponse();\n    }\n\n\n    public function sendRequest($data, $cookies = null) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, CURLOPT_CUSTOMREQUEST, $this->request_method);\n            curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n            $headers = [];\n            foreach ($this->outgoing_headers as $key => $value) {\n                $headers[] = $key . ': ' . $value;\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $headers[] = 'Cookie: ' . $cookie_string;\n            }\n            curl_setopt($this->ch, CURLOPT_HTTPHEADER, $headers);\n            return true;\n\n        } else {\n            $request = $this->request_method . ' ' . $this->uri . ' HTTP/' . $this->protocol_version . \"\\r\\n\";\n            $request .= 'Host: ' . $this->host . \"\\r\\n\";\n            foreach ($this->outgoing_headers as $key => $value) {\n                $request .= $key . ': ' . $value . \"\\r\\n\";\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $request .= 'Cookie: ' . $cookie_string . \"\\r\\n\";\n            }\n            $request .= 'Content-Length: ' . strlen($data) . \"\\r\\n\";\n            $request .= \"Connection: \" . ($this->persistentConnection ? 'Keep-Alive' : 'Close') . \"\\r\\n\\r\\n\";\n            $request .= $data;\n            fwrite($this->fp, $request);\n            return true;\n        }\n    }\n\n    public function getResponse() {\n        if ($this->use_curl) {\n            $response = curl_exec($this->ch);\n            $info = curl_getinfo($this->ch);\n            $this->incoming_headers = [];\n            if (isset($info['http_code']) && $info['http_code'] >= 200 && $info['http_code'] < 300) {\n                $this->incoming_payload = $response;\n                return $response;\n            } else {\n                return false;\n            }\n        } else {\n            $response = '';\n            while (!feof($this->fp)) {\n                $response .= fread($this->fp, 4096);\n            }\n\n            if (!$this->persistentConnection) {\n                fclose($this->fp);\n            }\n\n            list($headers, $this->incoming_payload) = explode(\"\\r\\n\\r\\n\", $response, 2);\n            $this->incoming_headers = [];\n            foreach (explode(\"\\r\\n\", $headers) as $header) {\n                if (strpos($header, ':')) {\n                    list($key, $value) = explode(':', $header, 2);\n                    $this->incoming_headers[trim($key)] = trim($value);\n                }\n            }\n            return $this->incoming_payload;\n        }\n    }\n\n\n    public function setHeader($name, $value) {\n        $this->outgoing_headers[$name] = $value;\n    }\n\n    public function setCurlOption($option, $value) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, $option, $value);\n        }\n    }\n\n    public function parseCookie($cookie_str) {\n        $cookies = [];\n        $parts = explode(';', $cookie_str);\n        foreach ($parts as $part) {\n            $pair = explode('=', $part, 2);\n            if (count($pair) == 2) {\n                $cookies[trim($pair[0])] = trim($pair[1]);\n            }\n        }\n        return $cookies;\n    }\n}\n\n",
      "<?php\nclass soap_transport_http {\n    public $url;\n    public $uri;\n    public $scheme;\n    public $host;\n    public $port;\n    public $path;\n    public $request_method = 'POST';\n    public $protocol_version = '1.0';\n    public $outgoing_headers = [];\n    public $incoming_headers = [];\n    public $outgoing_payload;\n    public $incoming_payload;\n    public $persistentConnection = false;\n    public $use_curl = false;\n    public $proxy = null;\n    private $ch;\n    private $fp;\n\n    public function __construct($url, $curl_options = null, $use_curl = false) {\n        $this->url = $url;\n        $parsed_url = parse_url($url);\n        $this->uri = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        if (isset($parsed_url['query'])) {\n            $this->uri .= '?' . $parsed_url['query'];\n        }\n        $this->scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] : 'http';\n        $this->host = isset($parsed_url['host']) ? $parsed_url['host'] : '';\n        $this->port = isset($parsed_url['port']) ? $parsed_url['port'] : ($this->scheme == 'https' ? 443 : 80);\n        $this->path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $this->use_curl = $use_curl;\n\n        if ($this->use_curl && is_array($curl_options)) {\n            foreach ($curl_options as $option => $value) {\n                $this->setCurlOption($option, $value);\n            }\n        }\n    }\n\n    public function connect($connection_timeout = 0, $response_timeout = 30) {\n        if ($this->use_curl) {\n            $this->ch = curl_init();\n            curl_setopt($this->ch, CURLOPT_URL, $this->url);\n            curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, $connection_timeout);\n            curl_setopt($this->ch, CURLOPT_TIMEOUT, $response_timeout);\n            if ($this->scheme == 'https') {\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, false);\n            }\n            if (is_array($this->proxy)) {\n                curl_setopt($this->ch, CURLOPT_PROXY, $this->proxy['host'] . ':' . $this->proxy['port']);\n                if (isset($this->proxy['user'])) {\n                    curl_setopt($this->ch, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['password']);\n                }\n            }\n            return true;\n        } else {\n            $host = ($this->port != 80 && $this->port != 443) ? $this->host . ':' . $this->port : $this->host;\n            $this->fp = @fsockopen(($this->scheme == 'ssl' || $this->scheme == 'https' ? 'ssl://' : '') . $host, $this->port, $errno, $errstr, $connection_timeout);\n            return $this->fp;\n        }\n    }\n\n    public function send($data, $timeout = 0, $response_timeout = 30, $cookies = null) {\n        $this->outgoing_payload = $data;\n        if (!$this->connect($timeout, $response_timeout)) {\n            return false;\n        }\n        if (!$this->sendRequest($data, $cookies)) {\n            return false;\n        }\n        return $this->getResponse();\n    }\n\n\n    public function sendRequest($data, $cookies = null) {\n        $headers = $this->outgoing_headers;\n        if (is_array($cookies)) {\n            $cookie_str = '';\n            foreach ($cookies as $cookie_name => $cookie_value) {\n                $cookie_str .= $cookie_name . '=' . $cookie_value . '; ';\n            }\n            $headers[] = 'Cookie: ' . $cookie_str;\n        }\n\n        if ($this->use_curl) {\n            curl_setopt($this->ch, CURLOPT_HTTPHEADER, $headers);\n            curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n            curl_setopt($this->ch, CURLOPT_CUSTOMREQUEST, $this->request_method);\n            $result = curl_exec($this->ch);\n            $this->incoming_payload = $result;\n            return $result !== false;\n        } else {\n            $request = $this->request_method . ' ' . $this->uri . ' HTTP/' . $this->protocol_version . \"\\r\\n\";\n            $request .= 'Host: ' . $this->host . \"\\r\\n\";\n            foreach ($headers as $header) {\n                $request .= $header . \"\\r\\n\";\n            }\n            $request .= \"Content-Length: \" . strlen($data) . \"\\r\\n\";\n            $request .= \"Connection: \" . ($this->persistentConnection ? 'Keep-Alive' : 'Close') . \"\\r\\n\\r\\n\";\n            $request .= $data;\n            fwrite($this->fp, $request);\n            return true;\n        }\n    }\n\n    public function getResponse() {\n        if ($this->use_curl) {\n            $this->incoming_headers = curl_getinfo($this->ch, CURLINFO_HTTP_CODE);\n            if (!$this->persistentConnection) {\n                curl_close($this->ch);\n            }\n            return $this->incoming_payload;\n        } else {\n            $response = '';\n            while (!feof($this->fp)) {\n                $response .= fread($this->fp, 8192);\n            }\n\n            if (!$this->persistentConnection) {\n                fclose($this->fp);\n            }\n\n            list($headers, $this->incoming_payload) = explode(\"\\r\\n\\r\\n\", $response, 2);\n            $this->incoming_headers = explode(\"\\r\\n\", $headers);\n            return $this->incoming_payload;\n        }\n    }\n\n\n    public function setHeader($name, $value) {\n        $this->outgoing_headers[] = $name . ': ' . $value;\n    }\n\n    public function setCurlOption($option, $value) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, $option, $value);\n        }\n    }\n\n    public function parseCookie($cookie_str) {\n        $cookies = [];\n        $parts = explode(';', $cookie_str);\n        foreach ($parts as $part) {\n            $pair = explode('=', trim($part), 2);\n            if (count($pair) == 2) {\n                $cookies[$pair[0]] = $pair[1];\n            }\n        }\n        return $cookies;\n    }\n}\n\n",
      "<?php\nclass soap_transport_http {\n    public $url;\n    public $uri;\n    public $scheme;\n    public $host;\n    public $port;\n    public $path;\n    public $request_method = 'POST';\n    public $protocol_version = '1.0';\n    public $outgoing_headers = [];\n    public $incoming_headers = [];\n    public $outgoing_payload;\n    public $incoming_payload;\n    public $persistentConnection = false;\n    public $use_curl = false;\n    public $proxy = null;\n    private $fp;\n    private $ch;\n\n    public function __construct($url, $curl_options = null, $use_curl = false) {\n        $this->url = $url;\n        $parsed_url = parse_url($url);\n        $this->uri = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        if (isset($parsed_url['query'])) {\n            $this->uri .= '?' . $parsed_url['query'];\n        }\n        $this->scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] : 'http';\n        $this->host = isset($parsed_url['host']) ? $parsed_url['host'] : '';\n        $this->port = isset($parsed_url['port']) ? $parsed_url['port'] : ($this->scheme == 'https' ? 443 : 80);\n        $this->path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $this->use_curl = $use_curl;\n        if ($this->use_curl && is_array($curl_options)) {\n            foreach ($curl_options as $option => $value) {\n                $this->setCurlOption($option, $value);\n            }\n        }\n    }\n\n    public function connect($connection_timeout = 0, $response_timeout = 30) {\n        if ($this->use_curl) {\n            $this->ch = curl_init();\n            curl_setopt($this->ch, CURLOPT_URL, $this->url);\n            curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, $connection_timeout);\n            curl_setopt($this->ch, CURLOPT_TIMEOUT, $response_timeout);\n            if ($this->scheme == 'https') {\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, false);\n            }\n            if (is_array($this->proxy)) {\n                curl_setopt($this->ch, CURLOPT_PROXY, $this->proxy['host'] . ':' . $this->proxy['port']);\n                if (isset($this->proxy['user'])) {\n                    curl_setopt($this->ch, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['password']);\n                }\n            }\n            return true;\n        } else {\n            $host = ($this->port != 80 && $this->port != 443) ? $this->host . ':' . $this->port : $this->host;\n            $this->fp = @fsockopen(($this->scheme == 'https' ? 'ssl://' : '') . $host, $this->port, $errno, $errstr, $connection_timeout);\n            return $this->fp;\n        }\n    }\n\n    public function send($data, $timeout = 0, $response_timeout = 30, $cookies = null) {\n        $this->outgoing_payload = $data;\n        if (!$this->sendRequest($data, $cookies)) {\n            return false;\n        }\n        return $this->getResponse();\n    }\n\n\n    public function sendRequest($data, $cookies = null) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, CURLOPT_CUSTOMREQUEST, $this->request_method);\n            curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n            $headers = [];\n            foreach ($this->outgoing_headers as $key => $value) {\n                $headers[] = $key . ': ' . $value;\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $headers[] = 'Cookie: ' . $cookie_string;\n            }\n            curl_setopt($this->ch, CURLOPT_HTTPHEADER, $headers);\n            return true;\n\n        } else {\n            $request = $this->request_method . ' ' . $this->uri . ' HTTP/' . $this->protocol_version . \"\\r\\n\";\n            $request .= 'Host: ' . $this->host . \"\\r\\n\";\n            foreach ($this->outgoing_headers as $key => $value) {\n                $request .= $key . ': ' . $value . \"\\r\\n\";\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $request .= 'Cookie: ' . $cookie_string . \"\\r\\n\";\n            }\n\n            $request .= 'Content-Length: ' . strlen($data) . \"\\r\\n\";\n            $request .= \"Connection: \" . ($this->persistentConnection ? 'Keep-Alive' : 'Close') . \"\\r\\n\\r\\n\";\n            $request .= $data;\n            fwrite($this->fp, $request);\n            return true;\n        }\n    }\n\n    public function getResponse() {\n        if ($this->use_curl) {\n            $response = curl_exec($this->ch);\n            $info = curl_getinfo($this->ch);\n            $this->incoming_headers = $this->parseHeaders($response);\n            $this->incoming_payload = $response;\n\n            if (curl_errno($this->ch)) {\n                return false;\n            }\n            return $response;\n        } else {\n            $response = '';\n            while (!feof($this->fp)) {\n                $response .= fread($this->fp, 8192);\n            }\n\n            if (!$this->persistentConnection) {\n                fclose($this->fp);\n            }\n\n            list($headers, $this->incoming_payload) = explode(\"\\r\\n\\r\\n\", $response, 2);\n            $this->incoming_headers = $this->parseHeaders($headers);\n            return $this->incoming_payload;\n        }\n    }\n\n\n    public function setHeader($name, $value) {\n        $this->outgoing_headers[$name] = $value;\n    }\n\n    public function setCurlOption($option, $value) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, $option, $value);\n        }\n    }\n\n    private function parseHeaders($headers) {\n        $header_array = [];\n        $headers = explode(\"\\r\\n\", $headers);\n        foreach ($headers as $header) {\n            if (strpos($header, ':') !== false) {\n                list($key, $value) = explode(':', $header, 2);\n                $header_array[trim($key)] = trim($value);\n            }\n        }\n        return $header_array;\n    }\n\n\n    public function parseCookie($cookie_str) {\n        $cookies = [];\n        $parts = explode(';', $cookie_str);\n        foreach ($parts as $part) {\n            $pair = explode('=', $part, 2);\n            if (count($pair) == 2) {\n                $cookies[trim($pair[0])] = trim($pair[1]);\n            }\n        }\n        return $cookies;\n    }\n}\n\n",
      "<?php\nclass soap_transport_http {\n    public $url;\n    public $uri;\n    public $scheme;\n    public $host;\n    public $port;\n    public $path;\n    public $request_method = 'POST';\n    public $protocol_version = '1.0';\n    public $outgoing_headers = [];\n    public $incoming_headers = [];\n    public $outgoing_payload;\n    public $incoming_payload;\n    public $persistentConnection = false;\n    public $use_curl = false;\n    public $proxy = null;\n    private $ch;\n    private $fp;\n\n    public function __construct($url, $curl_options = null, $use_curl = false) {\n        $this->url = $url;\n        $parsed_url = parse_url($url);\n        $this->uri = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        if (isset($parsed_url['query'])) {\n            $this->uri .= '?' . $parsed_url['query'];\n        }\n        $this->scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] : 'http';\n        $this->host = isset($parsed_url['host']) ? $parsed_url['host'] : '';\n        $this->port = isset($parsed_url['port']) ? $parsed_url['port'] : ($this->scheme == 'https' ? 443 : 80);\n        $this->path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $this->use_curl = $use_curl;\n        if ($this->use_curl && is_array($curl_options)) {\n            foreach ($curl_options as $option => $value) {\n                $this->setCurlOption($option, $value);\n            }\n        }\n    }\n\n    public function connect($connection_timeout = 0, $response_timeout = 30) {\n        if ($this->use_curl) {\n            $this->ch = curl_init();\n            curl_setopt($this->ch, CURLOPT_URL, $this->url);\n            curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, $connection_timeout);\n            curl_setopt($this->ch, CURLOPT_TIMEOUT, $response_timeout);\n            if ($this->scheme == 'https') {\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, false);\n            }\n            if (is_array($this->proxy)) {\n                curl_setopt($this->ch, CURLOPT_PROXY, $this->proxy['host'] . ':' . $this->proxy['port']);\n                if (isset($this->proxy['user'])) {\n                    curl_setopt($this->ch, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['password']);\n                }\n            }\n            return true;\n        } else {\n            $host = ($this->port != 80 && $this->port != 443) ? $this->host . ':' . $this->port : $this->host;\n            $this->fp = @fsockopen(($this->scheme == 'https' ? 'ssl://' : '') . $host, $this->port, $errno, $errstr, $connection_timeout);\n            return $this->fp;\n        }\n    }\n\n    public function send($data, $timeout = 0, $response_timeout = 30, $cookies = null) {\n        $this->outgoing_payload = $data;\n        if (!$this->sendRequest($data, $cookies)) {\n            return false;\n        }\n        return $this->getResponse();\n    }\n\n\n    public function sendRequest($data, $cookies = null) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, CURLOPT_CUSTOMREQUEST, $this->request_method);\n            curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n            $headers = [];\n            foreach ($this->outgoing_headers as $key => $value) {\n                $headers[] = $key . ': ' . $value;\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $headers[] = 'Cookie: ' . $cookie_string;\n            }\n            curl_setopt($this->ch, CURLOPT_HTTPHEADER, $headers);\n            return true;\n\n        } else {\n            $request = $this->request_method . ' ' . $this->uri . ' HTTP/' . $this->protocol_version . \"\\r\\n\";\n            $request .= 'Host: ' . $this->host . \"\\r\\n\";\n            foreach ($this->outgoing_headers as $key => $value) {\n                $request .= $key . ': ' . $value . \"\\r\\n\";\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $request .= 'Cookie: ' . $cookie_string . \"\\r\\n\";\n            }\n\n            $request .= 'Content-Length: ' . strlen($data) . \"\\r\\n\";\n            $request .= \"Connection: \" . ($this->persistentConnection ? 'Keep-Alive' : 'Close') . \"\\r\\n\\r\\n\";\n            $request .= $data;\n            fwrite($this->fp, $request);\n            return true;\n        }\n    }\n\n    public function getResponse() {\n        if ($this->use_curl) {\n            $response = curl_exec($this->ch);\n            $info = curl_getinfo($this->ch);\n            $this->incoming_headers = [];\n            if (isset($info['http_code']) && $info['http_code'] >= 200 && $info['http_code'] < 300) {\n                $this->incoming_payload = $response;\n                return $response;\n            } else {\n                return false;\n            }\n        } else {\n            $response = '';\n            while (!feof($this->fp)) {\n                $response .= fread($this->fp, 8192);\n            }\n            if (!$this->persistentConnection) {\n                fclose($this->fp);\n            }\n\n            list($headers, $this->incoming_payload) = explode(\"\\r\\n\\r\\n\", $response, 2);\n            $this->incoming_headers = [];\n            foreach (explode(\"\\r\\n\", $headers) as $header) {\n                if (strpos($header, ':')) {\n                    list($key, $value) = explode(':', $header, 2);\n                    $this->incoming_headers[trim($key)] = trim($value);\n                }\n            }\n            return $this->incoming_payload;\n        }\n    }\n\n\n    public function setHeader($name, $value) {\n        $this->outgoing_headers[$name] = $value;\n    }\n\n    public function setCurlOption($option, $value) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, $option, $value);\n        }\n    }\n\n    public function parseCookie($cookie_str) {\n        $cookies = [];\n        $parts = explode(';', $cookie_str);\n        foreach ($parts as $part) {\n            $pair = explode('=', $part, 2);\n            if (count($pair) == 2) {\n                $cookies[trim($pair[0])] = trim($pair[1]);\n            }\n        }\n        return $cookies;\n    }\n}\n\n?>\n",
      "<?php\nclass soap_transport_http {\n    public $url;\n    public $uri;\n    public $scheme;\n    public $host;\n    public $port;\n    public $path;\n    public $request_method = 'POST';\n    public $protocol_version = '1.0';\n    public $outgoing_headers = [];\n    public $incoming_headers = [];\n    public $outgoing_payload;\n    public $incoming_payload;\n    public $persistentConnection = false;\n    public $use_curl = false;\n    public $proxy = null;\n    private $fp;\n    private $ch;\n\n    public function __construct($url, $curl_options = null, $use_curl = false) {\n        $this->url = $url;\n        $parsed_url = parse_url($url);\n        $this->uri = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        if (isset($parsed_url['query'])) {\n            $this->uri .= '?' . $parsed_url['query'];\n        }\n        $this->scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] : 'http';\n        $this->host = isset($parsed_url['host']) ? $parsed_url['host'] : 'localhost';\n        $this->port = isset($parsed_url['port']) ? $parsed_url['port'] : ($this->scheme == 'https' ? 443 : 80);\n        $this->path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $this->use_curl = $use_curl;\n        if ($this->use_curl && is_array($curl_options)) {\n            foreach ($curl_options as $option => $value) {\n                $this->setCurlOption($option, $value);\n            }\n        }\n    }\n\n    public function connect($connection_timeout = 0, $response_timeout = 30) {\n        if ($this->use_curl) {\n            $this->ch = curl_init();\n            curl_setopt($this->ch, CURLOPT_URL, $this->url);\n            curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, $connection_timeout);\n            curl_setopt($this->ch, CURLOPT_TIMEOUT, $response_timeout);\n            if ($this->scheme == 'https') {\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, false);\n            }\n            if (is_array($this->proxy)) {\n                curl_setopt($this->ch, CURLOPT_PROXY, $this->proxy['host'] . ':' . $this->proxy['port']);\n                if (isset($this->proxy['user'])) {\n                    curl_setopt($this->ch, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['password']);\n                }\n            }\n            return true;\n        } else {\n            $host = ($this->port != 80 && $this->port != 443) ? $this->host . ':' . $this->port : $this->host;\n            $this->fp = @fsockopen(($this->scheme == 'https' ? 'ssl://' : '') . $host, $this->port, $errno, $errstr, $connection_timeout);\n            return $this->fp;\n        }\n    }\n\n    public function send($data, $timeout = 0, $response_timeout = 30, $cookies = null) {\n        $this->outgoing_payload = $data;\n        if (!$this->sendRequest($data, $cookies)) {\n            return false;\n        }\n        return $this->getResponse();\n    }\n\n\n    public function sendRequest($data, $cookies = null) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, CURLOPT_CUSTOMREQUEST, $this->request_method);\n            curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n            $headers = [];\n            foreach ($this->outgoing_headers as $key => $value) {\n                $headers[] = $key . ': ' . $value;\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $headers[] = 'Cookie: ' . $cookie_string;\n            }\n            curl_setopt($this->ch, CURLOPT_HTTPHEADER, $headers);\n            return true;\n        } else {\n\n            $request = $this->request_method . ' ' . $this->uri . ' HTTP/' . $this->protocol_version . \"\\r\\n\";\n            $request .= 'Host: ' . $this->host . \"\\r\\n\";\n            foreach ($this->outgoing_headers as $key => $value) {\n                $request .= $key . ': ' . $value . \"\\r\\n\";\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $request .= 'Cookie: ' . $cookie_string . \"\\r\\n\";\n            }\n            $request .= 'Content-Length: ' . strlen($data) . \"\\r\\n\";\n            $request .= \"Connection: \" . ($this->persistentConnection ? 'Keep-Alive' : 'Close') . \"\\r\\n\\r\\n\";\n            $request .= $data;\n            fwrite($this->fp, $request);\n            return true;\n        }\n    }\n\n    public function getResponse() {\n        if ($this->use_curl) {\n            $response = curl_exec($this->ch);\n            $info = curl_getinfo($this->ch);\n            $this->incoming_headers = $this->parseHeaders($response);\n\n            if ($info['http_code'] >= 400) {\n                return false;\n            }\n\n            $this->incoming_payload = $response;\n            return $response;\n\n        } else {\n            $response = '';\n            while (!feof($this->fp)) {\n                $response .= fread($this->fp, 4096);\n            }\n\n            if (!$this->persistentConnection) {\n                fclose($this->fp);\n            }\n\n            $this->incoming_headers = $this->parseHeaders($response);\n            list($headers, $this->incoming_payload) = explode(\"\\r\\n\\r\\n\", $response, 2);\n            return $this->incoming_payload;\n        }\n    }\n\n\n    public function setHeader($name, $value) {\n        $this->outgoing_headers[$name] = $value;\n    }\n\n\n    public function setCurlOption($option, $value) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, $option, $value);\n        }\n    }\n\n\n    private function parseHeaders($response) {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", substr($response, 0, strpos($response, \"\\r\\n\\r\\n\")));\n        array_shift($lines);\n        foreach ($lines as $line) {\n            list($key, $value) = explode(':', $line, 2);\n            $headers[trim($key)] = trim($value);\n        }\n        return $headers;\n    }\n\n    public function parseCookie($cookie_str) {\n        $cookies = [];\n        $parts = explode(';', $cookie_str);\n        foreach ($parts as $part) {\n            $pair = explode('=', $part, 2);\n            if (count($pair) == 2) {\n                $cookies[trim($pair[0])] = trim($pair[1]);\n            }\n        }\n        return $cookies;\n    }\n}\n\n?>\n",
      "<?php\nclass soap_transport_http {\n    public $url;\n    public $uri;\n    public $scheme;\n    public $host;\n    public $port;\n    public $path;\n    public $request_method = 'POST';\n    public $protocol_version = '1.0';\n    public $outgoing_headers = [];\n    public $incoming_headers = [];\n    public $outgoing_payload;\n    public $incoming_payload;\n    public $persistentConnection = false;\n    public $use_curl = false;\n    public $proxy = null;\n    private $fp;\n    private $ch;\n\n    public function __construct($url, $curl_options = null, $use_curl = false) {\n        $this->url = $url;\n        $parsed_url = parse_url($url);\n        $this->uri = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        if (isset($parsed_url['query'])) {\n            $this->uri .= '?' . $parsed_url['query'];\n        }\n        $this->scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] : 'http';\n        $this->host = isset($parsed_url['host']) ? $parsed_url['host'] : 'localhost';\n        $this->port = isset($parsed_url['port']) ? $parsed_url['port'] : ($this->scheme == 'https' ? 443 : 80);\n        $this->path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $this->use_curl = $use_curl;\n        if ($this->use_curl && is_array($curl_options)) {\n            foreach ($curl_options as $option => $value) {\n                $this->setCurlOption($option, $value);\n            }\n        }\n    }\n\n    public function connect($connection_timeout = 0, $response_timeout = 30) {\n        if ($this->use_curl) {\n            $this->ch = curl_init();\n            curl_setopt($this->ch, CURLOPT_URL, $this->url);\n            curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, $connection_timeout);\n            curl_setopt($this->ch, CURLOPT_TIMEOUT, $response_timeout);\n            if ($this->scheme == 'https') {\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, false);\n            }\n            if (is_array($this->proxy)) {\n                curl_setopt($this->ch, CURLOPT_PROXY, $this->proxy['host'] . ':' . $this->proxy['port']);\n                if (isset($this->proxy['user'])) {\n                    curl_setopt($this->ch, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['password']);\n                }\n            }\n            return true;\n        } else {\n            $host = ($this->port != 80 && $this->port != 443) ? $this->host . ':' . $this->port : $this->host;\n            $this->fp = @fsockopen(($this->scheme == 'https' ? 'ssl://' : '') . $host, $this->port, $errno, $errstr, $connection_timeout);\n            return $this->fp;\n        }\n    }\n\n    public function send($data, $timeout = 0, $response_timeout = 30, $cookies = null) {\n        $this->outgoing_payload = $data;\n        if (!$this->sendRequest($data, $cookies)) {\n            return false;\n        }\n        return $this->getResponse();\n    }\n\n\n    public function sendRequest($data, $cookies = null) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, CURLOPT_CUSTOMREQUEST, $this->request_method);\n            curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n            $headers = [];\n            foreach ($this->outgoing_headers as $key => $value) {\n                $headers[] = $key . ': ' . $value;\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $headers[] = 'Cookie: ' . $cookie_string;\n            }\n            curl_setopt($this->ch, CURLOPT_HTTPHEADER, $headers);\n            return true;\n\n        } else {\n            $headers = $this->request_method . ' ' . $this->uri . ' HTTP/' . $this->protocol_version . \"\\r\\n\";\n            $headers .= 'Host: ' . $this->host . \"\\r\\n\";\n            foreach ($this->outgoing_headers as $key => $value) {\n                $headers .= $key . ': ' . $value . \"\\r\\n\";\n            }\n            if (is_array($cookies)) {\n                $cookie_string = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_string .= $name . '=' . $value . '; ';\n                }\n                $headers .= 'Cookie: ' . $cookie_string . \"\\r\\n\";\n            }\n            $headers .= 'Content-Length: ' . strlen($data) . \"\\r\\n\";\n            $headers .= \"Connection: \" . ($this->persistentConnection ? 'Keep-Alive' : 'Close') . \"\\r\\n\\r\\n\";\n            fwrite($this->fp, $headers . $data);\n            return true;\n        }\n    }\n\n    public function getResponse() {\n        if ($this->use_curl) {\n            $response = curl_exec($this->ch);\n            $header_size = curl_getinfo($this->ch, CURLINFO_HEADER_SIZE);\n            $this->incoming_headers = $this->parseHeaders(substr($response, 0, $header_size));\n            $this->incoming_payload = substr($response, $header_size);\n            return $this->incoming_payload;\n        } else {\n            $this->incoming_payload = '';\n            while (!feof($this->fp)) {\n                $this->incoming_payload .= fread($this->fp, 4096);\n            }\n\n            if (!$this->persistentConnection) {\n                fclose($this->fp);\n            }\n\n            list($headers, $this->incoming_payload) = explode(\"\\r\\n\\r\\n\", $this->incoming_payload, 2);\n            $this->incoming_headers = $this->parseHeaders($headers);\n            return $this->incoming_payload;\n        }\n    }\n\n\n    public function setHeader($name, $value) {\n        $this->outgoing_headers[$name] = $value;\n    }\n\n    public function setCurlOption($option, $value) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, $option, $value);\n        }\n    }\n\n    private function parseHeaders($headers) {\n        $header_array = [];\n        $headers = explode(\"\\r\\n\", $headers);\n        foreach ($headers as $header) {\n            if (strpos($header, ':') !== false) {\n                list($key, $value) = explode(':', $header, 2);\n                $header_array[trim($key)] = trim($value);\n            }\n        }\n        return $header_array;\n    }\n\n    public function parseCookie($cookie_str) {\n        $cookies = [];\n        $parts = explode(';', $cookie_str);\n        foreach ($parts as $part) {\n            $pair = explode('=', $part, 2);\n            if (count($pair) == 2) {\n                $cookies[trim($pair[0])] = trim($pair[1]);\n            }\n        }\n        return $cookies;\n    }\n}\n\n",
      "<?php\nclass soap_transport_http {\n    public $url;\n    public $uri;\n    public $scheme;\n    public $host;\n    public $port;\n    public $path;\n    public $request_method = 'POST';\n    public $protocol_version = '1.0';\n    public $outgoing_headers = [];\n    public $incoming_headers = [];\n    public $outgoing_payload;\n    public $incoming_payload;\n    public $persistentConnection = false;\n    public $use_curl = false;\n    public $proxy = null;\n    private $ch;\n    private $fp;\n\n    public function __construct($url, $curl_options = null, $use_curl = false) {\n        $this->url = $url;\n        $parsed_url = parse_url($url);\n        $this->uri = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        if (isset($parsed_url['query'])) {\n            $this->uri .= '?' . $parsed_url['query'];\n        }\n        $this->scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] : 'http';\n        $this->host = isset($parsed_url['host']) ? $parsed_url['host'] : '';\n        $this->port = isset($parsed_url['port']) ? $parsed_url['port'] : ($this->scheme == 'https' ? 443 : 80);\n        $this->path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $this->use_curl = $use_curl;\n        if ($this->use_curl && is_array($curl_options)) {\n            foreach ($curl_options as $option => $value) {\n                $this->setCurlOption($option, $value);\n            }\n        }\n    }\n\n    public function connect($connection_timeout = 0, $response_timeout = 30) {\n        if ($this->use_curl) {\n            $this->ch = curl_init();\n            curl_setopt($this->ch, CURLOPT_URL, $this->url);\n            curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, $connection_timeout);\n            curl_setopt($this->ch, CURLOPT_TIMEOUT, $response_timeout);\n            if ($this->scheme == 'https') {\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, false);\n            }\n            if (is_array($this->proxy)) {\n                curl_setopt($this->ch, CURLOPT_PROXY, $this->proxy['host'] . ':' . $this->proxy['port']);\n                if (isset($this->proxy['user'])) {\n                    curl_setopt($this->ch, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['password']);\n                }\n            }\n            return true;\n        } else {\n            $host = ($this->port != 80 && $this->port != 443) ? $this->host . ':' . $this->port : $this->host;\n            $this->fp = @fsockopen(($this->scheme == 'https' ? 'ssl://' : '') . $host, $this->port, $errno, $errstr, $connection_timeout);\n            return $this->fp;\n        }\n    }\n\n    public function send($data, $timeout = 0, $response_timeout = 30, $cookies = null) {\n        $this->outgoing_payload = $data;\n        if (!$this->connect($timeout, $response_timeout)) {\n            return false;\n        }\n        if (!$this->sendRequest($data, $cookies)) {\n            return false;\n        }\n        return $this->getResponse();\n    }\n\n\n    public function sendRequest($data, $cookies = null) {\n        $headers = $this->outgoing_headers;\n        if (is_array($cookies)) {\n            $cookie_str = '';\n            foreach ($cookies as $name => $value) {\n                $cookie_str .= $name . '=' . $value . '; ';\n            }\n            $headers[] = 'Cookie: ' . $cookie_str;\n        }\n\n        if ($this->use_curl) {\n            curl_setopt($this->ch, CURLOPT_HTTPHEADER, $headers);\n            curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n            curl_setopt($this->ch, CURLOPT_CUSTOMREQUEST, $this->request_method);\n            $result = curl_exec($this->ch);\n            $this->incoming_payload = $result;\n            $this->incoming_headers = curl_getinfo($this->ch, CURLINFO_HTTP_CODE) == 200 ? $this->parseHeaders(curl_getinfo($this->ch, CURLINFO_HEADER_OUT)) : [];\n            return $result !== false;\n        } else {\n            $request = $this->request_method . ' ' . $this->uri . ' HTTP/' . $this->protocol_version . \"\\r\\n\";\n            $request .= 'Host: ' . $this->host . \"\\r\\n\";\n            foreach ($headers as $header) {\n                $request .= $header . \"\\r\\n\";\n            }\n            $request .= \"Content-Length: \" . strlen($data) . \"\\r\\n\";\n            $request .= \"Connection: \" . ($this->persistentConnection ? 'Keep-Alive' : 'Close') . \"\\r\\n\\r\\n\";\n            $request .= $data;\n            fwrite($this->fp, $request);\n            return true;\n        }\n    }\n\n    public function getResponse() {\n        if ($this->use_curl) {\n            return $this->incoming_payload;\n        } else {\n            $response = '';\n            while (!feof($this->fp)) {\n                $response .= fread($this->fp, 8192);\n            }\n            if (!$this->persistentConnection) {\n                fclose($this->fp);\n            }\n\n            list($headers, $this->incoming_payload) = explode(\"\\r\\n\\r\\n\", $response, 2);\n            $this->incoming_headers = $this->parseHeaders($headers);\n            return $this->incoming_payload;\n        }\n    }\n\n\n    public function setHeader($name, $value) {\n        $this->outgoing_headers[] = $name . ': ' . $value;\n    }\n\n    public function setCurlOption($option, $value) {\n        if ($this->use_curl) {\n            curl_setopt($this->ch, $option, $value);\n        }\n    }\n\n    private function parseHeaders($headers) {\n        $header_array = [];\n        $headers = explode(\"\\r\\n\", $headers);\n        foreach ($headers as $header) {\n            if (strpos($header, ':') !== false) {\n                list($key, $value) = explode(':', $header, 2);\n                $header_array[trim($key)] = trim($value);\n            }\n        }\n        return $header_array;\n    }\n\n\n    public function parseCookie($cookie_str) {\n        $cookies = [];\n        $parts = explode(';', $cookie_str);\n        foreach ($parts as $part) {\n            $pair = explode('=', $part, 2);\n            if (count($pair) == 2) {\n                $cookies[trim($pair[0])] = trim($pair[1]);\n            }\n        }\n        return $cookies;\n    }\n}\n\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a PHP function that fetches content from a remote HTTP server using low-level socket operations, with support for various HTTP request parameters and proxy configuration.\n\nFunction Description: The function establishes a TCP connection to an HTTP server (or proxy), sends an HTTP GET request with customizable headers, reads the response, and returns the content body. It supports authentication, custom headers, timeout settings, and proxy configuration. The function can either return the content directly or assign it to a template variable.\n\nInput:\n- $params: [array] - An associative array containing the following possible keys:\n  - 'file': [string] - The URL to fetch (required)\n  - 'assign': [string] - Template variable name to assign content to (optional)\n  - 'assign_headers': [string] - Template variable name to assign response headers to (optional)\n  - 'user': [string] - Username for HTTP authentication (optional)\n  - 'pass': [string] - Password for HTTP authentication (optional)\n  - 'accept': [string] - Accept header value (optional)\n  - 'header': [string|array] - Additional HTTP headers (optional)\n  - 'proxy_host': [string] - Proxy server hostname (optional)\n  - 'proxy_port': [int] - Proxy server port (optional)\n  - 'agent': [string] - User-Agent header value (optional)\n  - 'referer': [string] - Referer header value (optional)\n  - 'timeout': [int] - Connection timeout in seconds (optional)\n- $template: [object] - Template engine object for variable assignment (optional)\n\nOutput:\n- If 'assign' parameter is provided: [void] - Assigns content to template variable\n- If 'assign' parameter is not provided: [string] - Returns the fetched content\n- On error: [void] - Triggers notice and returns nothing",
    "Canonical_solution": "function smarty_function_fetch($params, $template)\n{\n    if (empty($params['file'])) {\n        trigger_error(\"[plugin] fetch parameter 'file' cannot be empty\", E_USER_NOTICE);\n        return;\n    }\n\n    $content = '';\n    if (preg_match('!^http://!i', $params['file'])) {\n        if ($uri_parts = parse_url($params['file'])) {\n            $host = $server_name = $uri_parts['host'];\n            $timeout = 30;\n            $port = empty($uri_parts['port']) ? 80 : $uri_parts['port'];\n            $user = empty($uri_parts['user']) ? null : $uri_parts['user'];\n            $pass = empty($uri_parts['pass']) ? null : $uri_parts['pass'];\n            $uri = !empty($uri_parts['path']) ? $uri_parts['path'] : '/';\n            $uri .= !empty($uri_parts['query']) ? '?' . $uri_parts['query'] : '';\n            $_is_proxy = false;\n            $proxy_host = $proxy_port = null;\n            $extra_headers = array();\n            $accept = \"image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\";\n            $agent = \"Smarty Template Engine \" . Smarty::SMARTY_VERSION;\n            $referer = \"\";\n\n            foreach ($params as $param_key => $param_value) {\n                switch ($param_key) {\n                    case \"file\":\n                    case \"assign\":\n                    case \"assign_headers\":\n                        break;\n                    case \"user\":\n                        if (!empty($param_value)) $user = $param_value;\n                        break;\n                    case \"pass\":\n                        if (!empty($param_value)) $pass = $param_value;\n                        break;\n                    case \"accept\":\n                        if (!empty($param_value)) $accept = $param_value;\n                        break;\n                    case \"header\":\n                        if (!empty($param_value) && preg_match('![\\w\\d-]+: .+!', $param_value)) {\n                            $extra_headers[] = $param_value;\n                        }\n                        break;\n                    case \"proxy_host\":\n                        if (!empty($param_value)) $proxy_host = $param_value;\n                        break;\n                    case \"proxy_port\":\n                        if (!preg_match('!\\D!', $param_value)) $proxy_port = (int)$param_value;\n                        break;\n                    case \"agent\":\n                        if (!empty($param_value)) $agent = $param_value;\n                        break;\n                    case \"referer\":\n                        if (!empty($param_value)) $referer = $param_value;\n                        break;\n                    case \"timeout\":\n                        if (!preg_match('!\\D!', $param_value)) $timeout = (int)$param_value;\n                        break;\n                }\n            }\n\n            if (!empty($proxy_host) && !empty($proxy_port)) {\n                $_is_proxy = true;\n                $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, $timeout);\n            } else {\n                $fp = fsockopen($server_name, $port, $errno, $errstr, $timeout);\n            }\n\n            if (!$fp) {\n                trigger_error(\"[plugin] unable to fetch: $errstr ($errno)\", E_USER_NOTICE);\n                return;\n            }\n\n            if ($_is_proxy) {\n                fputs($fp, 'GET ' . $params['file'] . \" HTTP/1.0\\r\\n\");\n            } else {\n                fputs($fp, \"GET $uri HTTP/1.0\\r\\n\");\n            }\n            if (!empty($host)) fputs($fp, \"Host: $host\\r\\n\");\n            if (!empty($accept)) fputs($fp, \"Accept: $accept\\r\\n\");\n            if (!empty($agent)) fputs($fp, \"User-Agent: $agent\\r\\n\");\n            if (!empty($referer)) fputs($fp, \"Referer: $referer\\r\\n\");\n            foreach ($extra_headers as $curr_header) {\n                fputs($fp, $curr_header . \"\\r\\n\");\n            }\n            if (!empty($user) && !empty($pass)) {\n                fputs($fp, \"Authorization: BASIC \" . base64_encode(\"$user:$pass\") . \"\\r\\n\");\n            }\n\n            fputs($fp, \"\\r\\n\");\n            while (!feof($fp)) {\n                $content .= fgets($fp, 4096);\n            }\n            fclose($fp);\n\n            $csplit = preg_split(\"!\\r\\n\\r\\n!\", $content, 2);\n            $content = $csplit[1];\n\n            if (!empty($params['assign_headers'])) {\n                $template->assign($params['assign_headers'], preg_split(\"!\\r\\n!\", $csplit[0]));\n            }\n        }\n    }\n\n    if (!empty($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 131,
    "matched_results": [
      "<?php\nfunction fetch_url($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!$url) {\n        trigger_error(\"fetch_url: Invalid URL provided\", E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url['host'];\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n    if (isset($params['proxy_host'])) {\n        $proxy_host = $params['proxy_host'];\n        $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : 8080;\n        $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, isset($params['timeout']) ? $params['timeout'] : 15);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = fsockopen($host, $port, $errno, $errstr, isset($params['timeout']) ? $params['timeout'] : 15);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        trigger_error(\"fetch_url: \" . $errstr . \" (\" . $errno . \")\", E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . $path . $query . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $request_host . \"\\r\\n\";\n\n    if (isset($params['user'], $params['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($params['user'] . \":\" . $params['pass']) . \"\\r\\n\";\n    }\n\n    if (isset($params['accept'])) {\n        $request .= \"Accept: \" . $params['accept'] . \"\\r\\n\";\n    }\n\n    if (isset($params['agent'])) {\n        $request .= \"User-Agent: \" . $params['agent'] . \"\\r\\n\";\n    }\n\n    if (isset($params['referer'])) {\n        $request .= \"Referer: \" . $params['referer'] . \"\\r\\n\";\n    }\n\n    if (isset($params['header'])) {\n        if (is_array($params['header'])) {\n            foreach ($params['header'] as $header) {\n                $request .= $header . \"\\r\\n\";\n            }\n        } else {\n            $request .= $params['header'] . \"\\r\\n\";\n        }\n    }\n\n    $request .= \"Connection: close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    list($headers, $content) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    }\n\n    if (isset($params['assign_headers'])) {\n        $template->assign($params['assign_headers'], $headers);\n    }\n\n\n    if (!isset($params['assign'])) {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!isset($url['host'])) {\n        trigger_error(\"fetch_url: Invalid URL supplied: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url['host'];\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n    if (isset($params['proxy_host'])) {\n        $fp = fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, isset($params['timeout']) ? $params['timeout'] : 30);\n        $request = \"GET \" . $params['file'] . \" HTTP/1.0\\r\\n\";\n    } else {\n        $fp = fsockopen($host, $port, $errno, $errstr, isset($params['timeout']) ? $params['timeout'] : 30);\n        $request = \"GET \" . $path . $query . \" HTTP/1.0\\r\\n\";\n    }\n\n    if (!$fp) {\n        trigger_error(\"fetch_url: Error connecting to \" . $host . \":\" . $port . \" - \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request .= \"Host: \" . $host . \"\\r\\n\";\n\n    if (isset($params['user'], $params['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($params['user'] . \":\" . $params['pass']) . \"\\r\\n\";\n    }\n\n    if (isset($params['accept'])) {\n        $request .= \"Accept: \" . $params['accept'] . \"\\r\\n\";\n    }\n\n    if (isset($params['agent'])) {\n        $request .= \"User-Agent: \" . $params['agent'] . \"\\r\\n\";\n    }\n\n    if (isset($params['referer'])) {\n        $request .= \"Referer: \" . $params['referer'] . \"\\r\\n\";\n    }\n\n    if (isset($params['header'])) {\n        if (is_array($params['header'])) {\n            foreach ($params['header'] as $header) {\n                $request .= $header . \"\\r\\n\";\n            }\n        } else {\n            $request .= $params['header'] . \"\\r\\n\";\n        }\n    }\n\n    $request .= \"Connection: close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $response_parts = explode(\"\\r\\n\\r\\n\", $response, 2);\n    $headers = isset($response_parts[0]) ? $response_parts[0] : '';\n    $content = isset($response_parts[1]) ? $response_parts[1] : '';\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    }\n\n    if (isset($params['assign_headers'])) {\n        $template->assign($params['assign_headers'], $headers);\n    }\n\n    if (!isset($params['assign'])) {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!isset($url['host'])) {\n        trigger_error(\"fetch_url: Invalid URL supplied: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url['host'];\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n    $fp = @fsockopen(\n        isset($params['proxy_host']) ? $params['proxy_host'] : $host,\n        isset($params['proxy_port']) ? $params['proxy_port'] : $port,\n        $errno,\n        $errstr,\n        isset($params['timeout']) ? $params['timeout'] : 30\n    );\n\n    if (!$fp) {\n        trigger_error(\"fetch_url: Unable to connect to $host:$port ($errstr)\", E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . (isset($params['proxy_host']) ? $params['file'] : $path . $query) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: $host\\r\\n\";\n\n    if (isset($params['user'], $params['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($params['user'] . \":\" . $params['pass']) . \"\\r\\n\";\n    }\n\n    if (isset($params['accept'])) {\n        $request .= \"Accept: \" . $params['accept'] . \"\\r\\n\";\n    }\n\n    if (isset($params['agent'])) {\n        $request .= \"User-Agent: \" . $params['agent'] . \"\\r\\n\";\n    }\n\n    if (isset($params['referer'])) {\n        $request .= \"Referer: \" . $params['referer'] . \"\\r\\n\";\n    }\n\n    if (isset($params['header'])) {\n        if (is_array($params['header'])) {\n            foreach ($params['header'] as $header) {\n                $request .= $header . \"\\r\\n\";\n            }\n        } else {\n            $request .= $params['header'] . \"\\r\\n\";\n        }\n    }\n\n    $request .= \"Connection: close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $responseParts = explode(\"\\r\\n\\r\\n\", $response, 2);\n    $headers = isset($responseParts[0]) ? $responseParts[0] : '';\n    $content = isset($responseParts[1]) ? $responseParts[1] : '';\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    }\n\n    if (isset($params['assign_headers'])) {\n        $template->assign($params['assign_headers'], $headers);\n    }\n\n    if (!isset($params['assign'])) {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!isset($url['host'])) {\n        trigger_error(\"fetch_url: Invalid URL supplied: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url['host'];\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n    $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : null;\n    $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : null;\n\n    if ($proxy_host) {\n        $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, isset($params['timeout']) ? $params['timeout'] : 30);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = fsockopen($host, $port, $errno, $errstr, isset($params['timeout']) ? $params['timeout'] : 30);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        trigger_error(\"fetch_url: Error connecting to host: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . $path . $query . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $request_host . \"\\r\\n\";\n\n    if (isset($params['user'], $params['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($params['user'] . \":\" . $params['pass']) . \"\\r\\n\";\n    }\n\n    $request .= isset($params['accept']) ? \"Accept: \" . $params['accept'] . \"\\r\\n\" : \"Accept: */*\\r\\n\";\n    $request .= isset($params['agent']) ? \"User-Agent: \" . $params['agent'] . \"\\r\\n\" : \"User-Agent: PHP\\r\\n\";\n    $request .= isset($params['referer']) ? \"Referer: \" . $params['referer'] . \"\\r\\n\" : \"\";\n\n    if (isset($params['header'])) {\n        if (is_array($params['header'])) {\n            foreach ($params['header'] as $header) {\n                $request .= $header . \"\\r\\n\";\n            }\n        } else {\n            $request .= $params['header'] . \"\\r\\n\";\n        }\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $response_parts = explode(\"\\r\\n\\r\\n\", $response, 2);\n    $headers = isset($response_parts[0]) ? $response_parts[0] : '';\n    $content = isset($response_parts[1]) ? $response_parts[1] : '';\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    }\n\n    if (isset($params['assign_headers'])) {\n        $template->assign($params['assign_headers'], $headers);\n    }\n\n    if (!isset($params['assign'])) {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!isset($url['host'])) {\n        trigger_error('fetch_url: Invalid URL', E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url['host'];\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n    if (isset($params['proxy_host'])) {\n        $fp = fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, isset($params['timeout']) ? $params['timeout'] : 30);\n        $request = \"GET \" . $params['file'] . \" HTTP/1.0\\r\\n\";\n    } else {\n        $fp = fsockopen($host, $port, $errno, $errstr, isset($params['timeout']) ? $params['timeout'] : 30);\n        $request = \"GET \" . $path . $query . \" HTTP/1.0\\r\\n\";\n    }\n\n    if (!$fp) {\n        trigger_error('fetch_url: ' . $errstr . ' (' . $errno . ')', E_USER_NOTICE);\n        return;\n    }\n\n    $request .= \"Host: \" . $host . \"\\r\\n\";\n\n    if (isset($params['user'], $params['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($params['user'] . ':' . $params['pass']) . \"\\r\\n\";\n    }\n\n    if (isset($params['accept'])) {\n        $request .= \"Accept: \" . $params['accept'] . \"\\r\\n\";\n    }\n\n    if (isset($params['agent'])) {\n        $request .= \"User-Agent: \" . $params['agent'] . \"\\r\\n\";\n    }\n\n    if (isset($params['referer'])) {\n        $request .= \"Referer: \" . $params['referer'] . \"\\r\\n\";\n    }\n\n    if (isset($params['header'])) {\n        if (is_array($params['header'])) {\n            foreach ($params['header'] as $header) {\n                $request .= $header . \"\\r\\n\";\n            }\n        } else {\n            $request .= $params['header'] . \"\\r\\n\";\n        }\n    }\n\n    $request .= \"Connection: close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $response_parts = explode(\"\\r\\n\\r\\n\", $response, 2);\n    $headers = isset($response_parts[0]) ? $response_parts[0] : '';\n    $content = isset($response_parts[1]) ? $response_parts[1] : '';\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    }\n\n    if (isset($params['assign_headers'])) {\n        $template->assign($params['assign_headers'], $headers);\n    }\n\n    if (!isset($params['assign'])) {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!isset($url['host'])) {\n        trigger_error(\"fetch_url: Invalid URL supplied: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url['host'];\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n    $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : null;\n    $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : null;\n\n    if ($proxy_host) {\n        $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, isset($params['timeout']) ? $params['timeout'] : 30);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = fsockopen($host, $port, $errno, $errstr, isset($params['timeout']) ? $params['timeout'] : 30);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        trigger_error(\"fetch_url: Error connecting to host: \" . $errstr, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . $path . $query . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $request_host . \"\\r\\n\";\n\n    if (isset($params['user'], $params['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($params['user'] . \":\" . $params['pass']) . \"\\r\\n\";\n    }\n\n    if (isset($params['accept'])) {\n        $request .= \"Accept: \" . $params['accept'] . \"\\r\\n\";\n    }\n\n    if (isset($params['agent'])) {\n        $request .= \"User-Agent: \" . $params['agent'] . \"\\r\\n\";\n    }\n\n    if (isset($params['referer'])) {\n        $request .= \"Referer: \" . $params['referer'] . \"\\r\\n\";\n    }\n\n    if (isset($params['header'])) {\n        if (is_array($params['header'])) {\n            foreach ($params['header'] as $header) {\n                $request .= $header . \"\\r\\n\";\n            }\n        } else {\n            $request .= $params['header'] . \"\\r\\n\";\n        }\n    }\n\n    $request .= \"Connection: close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    list($headers, $content) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    if (isset($params['assign_headers']) && $template) {\n        $template->assign($params['assign_headers'], explode(\"\\r\\n\", $headers));\n    }\n\n    if (isset($params['assign']) && $template) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!isset($url['host'])) {\n        trigger_error(\"fetch_url: Invalid URL supplied: \" . $params['file'], E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url['host'];\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n    $fp = @fsockopen(\n        isset($params['proxy_host']) ? $params['proxy_host'] : $host,\n        isset($params['proxy_port']) ? $params['proxy_port'] : $port,\n        $errno,\n        $errstr,\n        isset($params['timeout']) ? $params['timeout'] : 15\n    );\n\n    if (!$fp) {\n        trigger_error(\"fetch_url: Unable to connect to host: \" . $host, E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . (isset($params['proxy_host']) ? $params['file'] : $path . $query) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $host . \"\\r\\n\";\n\n    if (isset($params['user'], $params['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($params['user'] . \":\" . $params['pass']) . \"\\r\\n\";\n    }\n\n    if (isset($params['accept'])) {\n        $request .= \"Accept: \" . $params['accept'] . \"\\r\\n\";\n    }\n\n    if (isset($params['agent'])) {\n        $request .= \"User-Agent: \" . $params['agent'] . \"\\r\\n\";\n    }\n\n    if (isset($params['referer'])) {\n        $request .= \"Referer: \" . $params['referer'] . \"\\r\\n\";\n    }\n\n    if (isset($params['header'])) {\n        if (is_array($params['header'])) {\n            foreach ($params['header'] as $header) {\n                $request .= $header . \"\\r\\n\";\n            }\n        } else {\n            $request .= $params['header'] . \"\\r\\n\";\n        }\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $responseParts = explode(\"\\r\\n\\r\\n\", $response, 2);\n    $headers = isset($responseParts[0]) ? $responseParts[0] : '';\n    $content = isset($responseParts[1]) ? $responseParts[1] : '';\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    }\n\n    if (isset($params['assign_headers'])) {\n        $template->assign($params['assign_headers'], $headers);\n    }\n\n    if (!isset($params['assign'])) {\n        return $content;\n    }\n}\n?>\n"
    ],
    "unmatched_results": [
      "<?php\nfunction fetch_url($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!isset($url['host'])) {\n        trigger_error('fetch_url: Invalid URL', E_USER_NOTICE);\n        return;\n    }\n\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n    $host = $params['proxy_host'] ?? $url['host'];\n    $port = $params['proxy_port'] ?? $port;\n\n    $fp = @fsockopen($host, $port, $errno, $errstr, $params['timeout'] ?? 30);\n    if (!$fp) {\n        trigger_error(\"fetch_url: Unable to connect to $host:$port ($errstr)\", E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . ($params['proxy_host'] ? $params['file'] : $path . $query) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $url['host'] . \"\\r\\n\";\n\n    if (isset($params['user'], $params['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($params['user'] . ':' . $params['pass']) . \"\\r\\n\";\n    }\n\n    $request .= \"Accept: \" . ($params['accept'] ?? '*/*') . \"\\r\\n\";\n    $request .= \"User-Agent: \" . ($params['agent'] ?? 'PHP Fetch URL') . \"\\r\\n\";\n\n    if (isset($params['referer'])) {\n        $request .= \"Referer: \" . $params['referer'] . \"\\r\\n\";\n    }\n\n    if (isset($params['header'])) {\n        $headers = is_array($params['header']) ? $params['header'] : [$params['header']];\n        foreach ($headers as $header) {\n            $request .= $header . \"\\r\\n\";\n        }\n    }\n\n    $request .= \"\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fread($fp, 4096);\n    }\n    fclose($fp);\n\n    list($headers, $content) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    if (isset($params['assign_headers']) && $template) {\n        $template->assign($params['assign_headers'], explode(\"\\r\\n\", $headers));\n    }\n\n    if (isset($params['assign']) && $template) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!isset($url['host'])) {\n        trigger_error('fetch_url: Invalid URL', E_USER_NOTICE);\n        return;\n    }\n\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    $path .= isset($url['query']) ? '?' . $url['query'] : '';\n\n    $host = $params['proxy_host'] ?? $url['host'];\n    $port = $params['proxy_port'] ?? $port;\n\n    $fp = @fsockopen($host, $port, $errno, $errstr, $params['timeout'] ?? 30);\n    if (!$fp) {\n        trigger_error(\"fetch_url: Unable to connect to $host:$port ($errstr)\", E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . ($params['proxy_host'] ? $params['file'] : $path) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $url['host'] . \"\\r\\n\";\n\n    if (isset($params['user'], $params['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($params['user'] . ':' . $params['pass']) . \"\\r\\n\";\n    }\n\n    $request .= \"Accept: \" . ($params['accept'] ?? '*/*') . \"\\r\\n\";\n    $request .= \"User-Agent: \" . ($params['agent'] ?? 'PHP Fetch URL') . \"\\r\\n\";\n\n    if (isset($params['referer'])) {\n        $request .= \"Referer: \" . $params['referer'] . \"\\r\\n\";\n    }\n\n    if (isset($params['header'])) {\n        $headers = is_array($params['header']) ? $params['header'] : [$params['header']];\n        foreach ($headers as $header) {\n            $request .= $header . \"\\r\\n\";\n        }\n    }\n\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fread($fp, 8192);\n    }\n    fclose($fp);\n\n    list($headers, $content) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    if (isset($params['assign_headers']) && $template) {\n        $template->assign($params['assign_headers'], explode(\"\\r\\n\", $headers));\n    }\n\n    if (isset($params['assign']) && $template) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!isset($url['host'])) {\n        trigger_error('fetch_url: Invalid URL', E_USER_NOTICE);\n        return;\n    }\n\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    $query = isset($url['query']) ? '?' . $url['query'] : '';\n\n    $host = $params['proxy_host'] ?? $url['host'];\n    $port = $params['proxy_port'] ?? $port;\n\n    $fp = @fsockopen($host, $port, $errno, $errstr, $params['timeout'] ?? 30);\n    if (!$fp) {\n        trigger_error(\"fetch_url: $errstr ($errno)\", E_USER_NOTICE);\n        return;\n    }\n\n    $request = \"GET \" . ($params['proxy_host'] ? $params['file'] : $path . $query) . \" HTTP/1.0\\r\\n\";\n    $request .= \"Host: \" . $url['host'] . \"\\r\\n\";\n\n    if (isset($params['user'], $params['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode($params['user'] . ':' . $params['pass']) . \"\\r\\n\";\n    }\n\n    $request .= \"Accept: \" . ($params['accept'] ?? '*/*') . \"\\r\\n\";\n    $request .= \"User-Agent: \" . ($params['agent'] ?? 'PHP Fetch URL') . \"\\r\\n\";\n\n    if (isset($params['referer'])) {\n        $request .= \"Referer: \" . $params['referer'] . \"\\r\\n\";\n    }\n\n    if (isset($params['header'])) {\n        $headers = is_array($params['header']) ? $params['header'] : [$params['header']];\n        foreach ($headers as $header) {\n            $request .= $header . \"\\r\\n\";\n        }\n    }\n\n    $request .= \"Connection: close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fread($fp, 8192);\n    }\n    fclose($fp);\n\n    list($headers, $content) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    if (isset($params['assign_headers']) && $template) {\n        $template->assign($params['assign_headers'], explode(\"\\r\\n\", $headers));\n    }\n\n    if (isset($params['assign']) && $template) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n"
    ],
    "match_count": 7,
    "pass@3": 0.9916666666666667,
    "pass@5": 1.0
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using fsockopen for making HTTP requests when CURL extension is not available. The class should support both GET and POST methods, handle headers, cookies, timeouts, and allow configuration of various connection parameters.\n\nClass Description: The Http class provides low-level HTTP client functionality using PHP's fsockopen function. It's designed as a fallback when CURL isn't available, offering stable performance for making HTTP requests. The class contains one static method that handles the complete HTTP request lifecycle from connection establishment to response processing.\n\nMethods:\n\nMethod1: fsockopenDownload(string $url, array $conf = []) -> mixed - Performs an HTTP request using fsockopen\n  Input Parameters:\n    - $url: string - The target URL to request\n    - $conf: array - Configuration options including:\n      - limit: int - Maximum bytes to read (0 for unlimited)\n      - post: mixed - POST data (array or string)\n      - cookie: string - Cookie header content\n      - ip: string - Force specific IP address\n      - timeout: int - Connection timeout in seconds\n      - block: bool - Whether to use blocking mode\n  Return Type: mixed - Returns the HTTP response body as string, or empty string on failure\n\nThe method follows these steps:\n1. Parses the URL and merges configuration with defaults\n2. Prepares appropriate HTTP request headers (GET/POST)\n3. Establishes TCP connection using fsockopen\n4. Sends the HTTP request\n5. Reads and processes the response\n6. Closes the connection and returns the response body",
    "Canonical_solution": "namespace Org\\Net;\n\nclass Http\n{\n    /**\n     * 使用 fsockopen 通过 HTTP 协议直接访问(采集)远程文件\n     * 如果主机或服务器没有开启 CURL 扩展可考虑使用\n     * fsockopen 比 CURL 稍慢,但性能稳定\n     * @static\n     * @access public\n     * @param string $url 远程URL\n     * @param array $conf 其他配置信息\n     *        int   limit 分段读取字符个数\n     *        string post  post的内容,字符串或数组,key=value&形式\n     *        string cookie 携带cookie访问,该参数是cookie内容\n     *        string ip    如果该参数传入,$url将不被使用,ip访问优先\n     *        int    timeout 采集超时时间\n     *        bool   block 是否阻塞访问,默认为true\n     * @return mixed\n     */\n    static public function fsockopenDownload($url, $conf = array())\n    {\n        $return = '';\n        if(!is_array($conf)) return $return;\n\n        $matches = parse_url($url);\n        !isset($matches['host'])    && $matches['host']    = '';\n        !isset($matches['path'])    && $matches['path']    = '';\n        !isset($matches['query'])   && $matches['query']   = '';\n        !isset($matches['port'])     && $matches['port']    = '';\n        $host = $matches['host'];\n        $path = $matches['path'] ? $matches['path'].($matches['query'] ? '?'.$matches['query'] : '') : '/';\n        $port = !empty($matches['port']) ? $matches['port'] : 80;\n\n        $conf_arr = array(\n            'limit'     =>  0,\n            'post'      =>  '',\n            'cookie'    =>  '',\n            'ip'        =>  '',\n            'timeout'   =>  15,\n            'block'     =>  TRUE,\n            );\n\n        foreach (array_merge($conf_arr, $conf) as $k=>$v) ${$k} = $v;\n\n        if($post) {\n            if(is_array($post))\n            {\n                $post = http_build_query($post);\n            }\n            $out  = \"POST $path HTTP/1.0\\r\\n\";\n            $out .= \"Accept: */*\\r\\n\";\n            $out .= \"Accept-Language: zh-cn\\r\\n\";\n            $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $out .= \"User-Agent: $_SERVER[HTTP_USER_AGENT]\\r\\n\";\n            $out .= \"Host: $host\\r\\n\";\n            $out .= 'Content-Length: '.strlen($post).\"\\r\\n\";\n            $out .= \"Connection: Close\\r\\n\";\n            $out .= \"Cache-Control: no-cache\\r\\n\";\n            $out .= \"Cookie: $cookie\\r\\n\\r\\n\";\n            $out .= $post;\n        } else {\n            $out  = \"GET $path HTTP/1.0\\r\\n\";\n            $out .= \"Accept: */*\\r\\n\";\n            $out .= \"Accept-Language: zh-cn\\r\\n\";\n            $out .= \"User-Agent: $_SERVER[HTTP_USER_AGENT]\\r\\n\";\n            $out .= \"Host: $host\\r\\n\";\n            $out .= \"Connection: Close\\r\\n\";\n            $out .= \"Cookie: $cookie\\r\\n\\r\\n\";\n        }\n        $fp = @fsockopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout);\n        if(!$fp) {\n            return '';\n        } else {\n            stream_set_blocking($fp, $block);\n            stream_set_timeout($fp, $timeout);\n            @fwrite($fp, $out);\n            $status = stream_get_meta_data($fp);\n            if(!$status['timed_out']) {\n                while (!feof($fp)) {\n                    if(($header = @fgets($fp)) && ($header == \"\\r\\n\" ||  $header == \"\\n\")) {\n                        break;\n                    }\n                }\n\n                $stop = false;\n                while(!feof($fp) && !$stop) {\n                    $data = fread($fp, ($limit == 0 || $limit > 8192 ? 8192 : $limit));\n                    $return .= $data;\n                    if($limit) {\n                        $limit -= strlen($data);\n                        $stop = $limit <= 0;\n                    }\n                }\n            }\n            @fclose($fp);\n            return $return;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 131,
    "matched_results": [
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = []) : mixed {\n        $purl = parse_url($url);\n        $conf += [\n            'limit' => 0,\n            'post' => '',\n            'cookie' => '',\n            'ip' => '',\n            'timeout' => 15,\n            'block' => true,\n        ];\n        $fp = @fsockopen(($conf['ip'] ? $conf['ip'] : $purl['host']), isset($purl['port']) ? $purl['port'] : 80, $errno, $errstr, $conf['timeout']);\n        if (!$fp) {\n            return '';\n        }\n        stream_set_blocking($fp, $conf['block']);\n        stream_set_timeout($fp, $conf['timeout']);\n        $r = $conf['post'] ? \"POST \" : \"GET \";\n        $r .= ($purl['path'] ?: '/') . (isset($purl['query']) ? '?' . $purl['query'] : '') . \" HTTP/1.1\\r\\n\";\n        $r .= \"Host: \" . $purl['host'] . \"\\r\\n\";\n        $r .= \"User-Agent: PHP\\r\\n\";\n        $r .= \"Accept: */*\\r\\n\";\n        if ($conf['post']) {\n            if (is_array($conf['post'])) {\n                $post = http_build_query($conf['post']);\n            } else {\n                $post = $conf['post'];\n            }\n            $r .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $r .= \"Content-Length: \" . strlen($post) . \"\\r\\n\";\n        }\n        if ($conf['cookie']) {\n            $r .= \"Cookie: \" . $conf['cookie'] . \"\\r\\n\";\n        }\n        $r .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($conf['post']) {\n            $r .= $post;\n        }\n        fwrite($fp, $r);\n        $headers = '';\n        while (!feof($fp) && ($line = fgets($fp))) {\n            $headers .= $line;\n            if ($line == \"\\r\\n\") {\n                break;\n            }\n        }\n        $body = '';\n        $limit = $conf['limit'];\n        while (!feof($fp) && (!$limit || strlen($body) < $limit)) {\n            $body .= fread($fp, 8192);\n        }\n        fclose($fp);\n        return $body;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = []) : mixed {\n        $parsed_url = parse_url($url);\n        $host = $parsed_url['host'];\n        $port = isset($parsed_url['port']) ? $parsed_url['port'] : 80;\n        $path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $query = isset($parsed_url['query']) ? '?' . $parsed_url['query'] : '';\n\n        $limit = $conf['limit'] ?? 0;\n        $post = $conf['post'] ?? null;\n        $cookie = $conf['cookie'] ?? '';\n        $ip = $conf['ip'] ?? null;\n        $timeout = $conf['timeout'] ?? 10;\n        $block = $conf['block'] ?? true;\n\n        $fp = @fsockopen($ip ?? $host, $port, $errno, $errstr, $timeout);\n        if (!$fp) {\n            return '';\n        }\n        stream_set_blocking($fp, $block);\n        stream_set_timeout($fp, $timeout);\n\n        $method = $post ? 'POST' : 'GET';\n        $contentLength = $post ? (is_array($post) ? strlen(http_build_query($post)) : strlen($post)) : 0;\n        $headers = \"$method $path$query HTTP/1.1\\r\\n\";\n        $headers .= \"Host: $host\\r\\n\";\n        $headers .= \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\\r\\n\";\n        if ($contentLength > 0) {\n            $headers .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $headers .= \"Content-Length: $contentLength\\r\\n\";\n        }\n        if ($cookie) {\n            $headers .= \"Cookie: $cookie\\r\\n\";\n        }\n        $headers .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($post) {\n            $headers .= is_array($post) ? http_build_query($post) : $post;\n        }\n\n        fwrite($fp, $headers);\n\n        $response = '';\n        $headers_done = false;\n        while (!feof($fp)) {\n            $line = fgets($fp);\n            if ($headers_done && $limit > 0 && strlen($response) >= $limit) {\n                break;\n            }\n            if ($headers_done) {\n                $response .= $line;\n            } elseif (trim($line) == '') {\n                $headers_done = true;\n            }\n        }\n        fclose($fp);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = []) : mixed {\n        $purl = parse_url($url);\n        $conf += [\n            'limit' => 0,\n            'post' => '',\n            'cookie' => '',\n            'ip' => '',\n            'timeout' => 15,\n            'block' => true,\n        ];\n        $fp = @fsockopen(($conf['ip'] ? $conf['ip'] : $purl['host']), isset($purl['port']) ? $purl['port'] : 80, $errno, $errstr, $conf['timeout']);\n        if (!$fp) {\n            return '';\n        }\n        $header = ($conf['post'] ? \"POST \" : \"GET \") . (isset($purl['path']) ? $purl['path'] : '/') . (isset($purl['query']) ? \"?\" . $purl['query'] : \"\") . \" HTTP/1.1\\r\\n\";\n        $header .= \"Host: \" . $purl['host'] . \"\\r\\n\";\n        $header .= \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0\\r\\n\";\n        $header .= \"Accept: */*\\r\\n\";\n        $header .= $conf['cookie'] ? \"Cookie: \" . $conf['cookie'] . \"\\r\\n\" : '';\n        if ($conf['post']) {\n            $post_data = is_array($conf['post']) ? http_build_query($conf['post']) : $conf['post'];\n            $header .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $header .= \"Content-Length: \" . strlen($post_data) . \"\\r\\n\";\n        }\n        $header .= \"Connection: Close\\r\\n\\r\\n\";\n        $header .= $conf['post'] ? $post_data : '';\n\n        stream_set_blocking($fp, $conf['block']);\n        fwrite($fp, $header);\n\n        $response = '';\n        if ($conf['limit']) {\n            $response = stream_get_contents($fp, $conf['limit']);\n        } else {\n            while (!feof($fp)) {\n                $response .= fgets($fp, 1024);\n            }\n        }\n        fclose($fp);\n\n        $pos = strpos($response, \"\\r\\n\\r\\n\");\n        if ($pos !== false) {\n            $response = substr($response, $pos + 4);\n        }\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = []) : mixed {\n        $parsed_url = parse_url($url);\n        $host = $parsed_url['host'];\n        $port = isset($parsed_url['port']) ? $parsed_url['port'] : 80;\n        $path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $query = isset($parsed_url['query']) ? '?' . $parsed_url['query'] : '';\n\n        $limit = $conf['limit'] ?? 0;\n        $post = $conf['post'] ?? null;\n        $cookie = $conf['cookie'] ?? '';\n        $ip = $conf['ip'] ?? null;\n        $timeout = $conf['timeout'] ?? 10;\n        $block = $conf['block'] ?? true;\n\n        $fp = @fsockopen($ip ?? $host, $port, $errno, $errstr, $timeout);\n        if (!$fp) {\n            return '';\n        }\n        stream_set_blocking($fp, $block);\n        stream_set_timeout($fp, $timeout);\n\n        $method = $post ? 'POST' : 'GET';\n        $contentLength = $post ? (is_array($post) ? strlen(http_build_query($post)) : strlen($post)) : 0;\n\n        $headers = \"$method $path$query HTTP/1.1\\r\\n\";\n        $headers .= \"Host: $host\\r\\n\";\n        $headers .= \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\\r\\n\";\n        if ($contentLength > 0) {\n            $headers .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $headers .= \"Content-Length: $contentLength\\r\\n\";\n        }\n        if ($cookie) {\n            $headers .= \"Cookie: $cookie\\r\\n\";\n        }\n        $headers .= \"Connection: Close\\r\\n\\r\\n\";\n\n        if ($post) {\n            $headers .= is_array($post) ? http_build_query($post) : $post;\n        }\n\n        fwrite($fp, $headers);\n\n        $response = '';\n        $headers_done = false;\n        while (!feof($fp)) {\n            $line = fgets($fp);\n            if ($headers_done && $limit > 0 && strlen($response) >= $limit) {\n                break;\n            }\n            if ($headers_done) {\n                $response .= $line;\n            } elseif (trim($line) == '') {\n                $headers_done = true;\n            }\n        }\n        fclose($fp);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = []) : mixed {\n        $parsed_url = parse_url($url);\n        $host = $parsed_url['host'];\n        $port = isset($parsed_url['port']) ? $parsed_url['port'] : 80;\n        $path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $query = isset($parsed_url['query']) ? '?' . $parsed_url['query'] : '';\n\n        $limit = $conf['limit'] ?? 0;\n        $post = $conf['post'] ?? null;\n        $cookie = $conf['cookie'] ?? '';\n        $ip = $conf['ip'] ?? null;\n        $timeout = $conf['timeout'] ?? 10;\n        $block = $conf['block'] ?? true;\n\n        $fp = @fsockopen($ip ?? $host, $port, $errno, $errstr, $timeout);\n        if (!$fp) {\n            return '';\n        }\n        stream_set_blocking($fp, $block);\n        stream_set_timeout($fp, $timeout);\n\n        $method = $post ? 'POST' : 'GET';\n        $contentLength = $post ? (is_array($post) ? strlen(http_build_query($post)) : strlen($post)) : 0;\n\n        $headers = \"$method $path$query HTTP/1.1\\r\\n\";\n        $headers .= \"Host: $host\\r\\n\";\n        $headers .= \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\\r\\n\";\n        if ($contentLength > 0) {\n            $headers .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $headers .= \"Content-Length: $contentLength\\r\\n\";\n        }\n        if ($cookie) {\n            $headers .= \"Cookie: $cookie\\r\\n\";\n        }\n        $headers .= \"Connection: Close\\r\\n\\r\\n\";\n\n        if ($post) {\n            $headers .= is_array($post) ? http_build_query($post) : $post;\n        }\n\n        fwrite($fp, $headers);\n\n        $response = '';\n        $headers_done = false;\n        while (!feof($fp)) {\n            $line = fgets($fp);\n            if ($headers_done && $limit > 0 && strlen($response) >= $limit) {\n                break;\n            }\n            if ($headers_done) {\n                $response .= $line;\n            } elseif (trim($line) == '') {\n                $headers_done = true;\n            }\n        }\n\n        fclose($fp);\n        return $response;\n    }\n}\n?>\n"
    ],
    "unmatched_results": [
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = []) : mixed {\n        $purl = parse_url($url);\n        $conf += [\n            'limit' => 0,\n            'post' => '',\n            'cookie' => '',\n            'ip' => '',\n            'timeout' => 15,\n            'block' => true,\n        ];\n        $fp = @fsockopen(($conf['ip'] ? $conf['ip'] : $purl['host']), isset($purl['port']) ? $purl['port'] : 80, $errno, $errstr, $conf['timeout']);\n        if (!$fp) {\n            return '';\n        }\n        stream_set_blocking($fp, $conf['block']);\n        stream_set_timeout($fp, $conf['timeout']);\n        $header = ($conf['post'] ? \"POST \" : \"GET \") . (isset($purl['path']) ? $purl['path'] : '/') . (isset($purl['query']) ? '?' . $purl['query'] : '') . \" HTTP/1.1\\r\\n\";\n        $header .= \"Host: \" . $purl['host'] . \"\\r\\n\";\n        $header .= \"User-Agent: PHP\\r\\n\";\n        $header .= \"Accept: */*\\r\\n\";\n        $header .= $conf['cookie'] ? \"Cookie: \" . $conf['cookie'] . \"\\r\\n\" : '';\n        if ($conf['post']) {\n            $post_data = is_array($conf['post']) ? http_build_query($conf['post']) : $conf['post'];\n            $header .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $header .= \"Content-Length: \" . strlen($post_data) . \"\\r\\n\";\n        }\n        $header .= \"Connection: Close\\r\\n\\r\\n\";\n        fwrite($fp, $header);\n        if ($conf['post']) {\n            fwrite($fp, $post_data);\n        }\n        $response = '';\n        $limit = $conf['limit'];\n        while (!feof($fp) && (!$limit || strlen($response) < $limit)) {\n            $response .= fread($fp, 8192);\n        }\n        fclose($fp);\n        $pos = strpos($response, \"\\r\\n\\r\\n\");\n        if ($pos !== false) {\n            $response = substr($response, $pos + 4);\n        }\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = []) : mixed {\n        $purl = parse_url($url);\n        $conf += [\n            'limit' => 0,\n            'post' => '',\n            'cookie' => '',\n            'ip' => '',\n            'timeout' => 15,\n            'block' => true,\n        ];\n        $fp = @fsockopen(($conf['ip'] ? $conf['ip'] : $purl['host']), isset($purl['port']) ? $purl['port'] : 80, $errno, $errstr, $conf['timeout']);\n        if (!$fp) {\n            return '';\n        }\n        stream_set_blocking($fp, $conf['block']);\n        stream_set_timeout($fp, $conf['timeout']);\n        $header = ($conf['post'] ? \"POST \" : \"GET \") . (isset($purl['path']) ? $purl['path'] : '/') . (isset($purl['query']) ? \"?\" . $purl['query'] : \"\") . \" HTTP/1.1\\r\\n\";\n        $header .= \"Host: \" . $purl['host'] . \"\\r\\n\";\n        $header .= \"User-Agent: PHP\\r\\n\";\n        if (!empty($conf['cookie'])) {\n            $header .= \"Cookie: \" . $conf['cookie'] . \"\\r\\n\";\n        }\n        if ($conf['post']) {\n            $post_string = is_array($conf['post']) ? http_build_query($conf['post']) : $conf['post'];\n            $header .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $header .= \"Content-Length: \" . strlen($post_string) . \"\\r\\n\";\n        }\n        $header .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($conf['post']) {\n            $header .= $post_string;\n        }\n        fwrite($fp, $header);\n        $response = '';\n        while (!feof($fp) && (!$conf['limit'] || strlen($response) < $conf['limit'])) {\n            $response .= fread($fp, 8192);\n        }\n        fclose($fp);\n        $pos = strpos($response, \"\\r\\n\\r\\n\");\n        if ($pos === false) {\n            return '';\n        }\n        $body = substr($response, $pos + 4);\n        return $body;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = []) : mixed {\n        $purl = parse_url($url);\n        $conf += [\n            'limit' => 0,\n            'post' => null,\n            'cookie' => null,\n            'ip' => null,\n            'timeout' => 15,\n            'block' => true,\n        ];\n        $fp = @fsockopen(($conf['ip'] ? $conf['ip'] : $purl['host']), isset($purl['port']) ? $purl['port'] : 80, $errno, $errstr, $conf['timeout']);\n        if (!$fp) {\n            return '';\n        }\n        stream_set_blocking($fp, $conf['block']);\n        stream_set_timeout($fp, $conf['timeout']);\n        $head = ($conf['post'] ? \"POST \" : \"GET \") . ($purl['path'] ?: '/') . (isset($purl['query']) ? '?' . $purl['query'] : '') . \" HTTP/1.1\\r\\n\";\n        $head .= \"Host: \" . $purl['host'] . \"\\r\\n\";\n        $head .= \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\\r\\n\";\n        if ($conf['cookie']) {\n            $head .= \"Cookie: \" . $conf['cookie'] . \"\\r\\n\";\n        }\n        if ($conf['post']) {\n            $post_data = is_array($conf['post']) ? http_build_query($conf['post']) : $conf['post'];\n            $head .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $head .= \"Content-Length: \" . strlen($post_data) . \"\\r\\n\";\n        }\n        $head .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($conf['post']) {\n            $head .= $post_data;\n        }\n        fwrite($fp, $head);\n        $responseBody = '';\n        $header = '';\n        do {\n            $header .= fread($fp, 1);\n        } while (!preg_match('/\\r\\n\\r\\n$/', $header));\n\n        if ($conf['limit'] > 0) {\n            $responseBody = stream_get_contents($fp, $conf['limit']);\n        } else {\n            $responseBody = stream_get_contents($fp);\n        }\n\n        fclose($fp);\n        return $responseBody;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = []) : mixed {\n        $purl = parse_url($url);\n        $conf += [\n            'limit' => 0,\n            'post' => '',\n            'cookie' => '',\n            'ip' => '',\n            'timeout' => 15,\n            'block' => true,\n        ];\n        $fp = @fsockopen(($conf['ip'] ? $conf['ip'] : $purl['host']), isset($purl['port']) ? $purl['port'] : 80, $errno, $errstr, $conf['timeout']);\n        if (!$fp) {\n            return '';\n        }\n        stream_set_blocking($fp, $conf['block']);\n        stream_set_timeout($fp, $conf['timeout']);\n        $header = ($conf['post'] ? \"POST \" : \"GET \") . (isset($purl['path']) ? $purl['path'] : '/') . (isset($purl['query']) ? '?' . $purl['query'] : '') . \" HTTP/1.1\\r\\n\";\n        $header .= \"Host: \" . $purl['host'] . \"\\r\\n\";\n        $header .= \"User-Agent: PHP\\r\\n\";\n        if (!empty($conf['cookie'])) {\n            $header .= \"Cookie: \" . $conf['cookie'] . \"\\r\\n\";\n        }\n        if ($conf['post']) {\n            if (is_array($conf['post'])) {\n                $post_string = http_build_query($conf['post']);\n            } else {\n                $post_string = $conf['post'];\n            }\n            $header .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $header .= \"Content-Length: \" . strlen($post_string) . \"\\r\\n\";\n        }\n        $header .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($conf['post']) {\n            $header .= $post_string;\n        }\n        fwrite($fp, $header);\n        $response = '';\n        $limit = $conf['limit'];\n        while (!feof($fp) && (!$limit || strlen($response) < $limit)) {\n            $response .= fread($fp, 8192);\n        }\n        fclose($fp);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = []) : mixed {\n        $purl = parse_url($url);\n        $conf += [\n            'limit' => 0,\n            'post' => '',\n            'cookie' => '',\n            'ip' => '',\n            'timeout' => 15,\n            'block' => true,\n        ];\n        $fp = @fsockopen(($conf['ip'] ? $conf['ip'] : $purl['host']), isset($purl['port']) ? $purl['port'] : 80, $errno, $errstr, $conf['timeout']);\n        if (!$fp) {\n            return '';\n        }\n        $header = ($conf['post'] ? \"POST \" : \"GET \") . (isset($purl['path']) ? $purl['path'] : '/') . (isset($purl['query']) ? \"?\" . $purl['query'] : \"\") . \" HTTP/1.1\\r\\n\";\n        $header .= \"Host: \" . $purl['host'] . \"\\r\\n\";\n        $header .= \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\\r\\n\";\n        $header .= \"Accept: */*\\r\\n\";\n        $header .= $conf['cookie'] ? \"Cookie: \" . $conf['cookie'] . \"\\r\\n\" : '';\n        if ($conf['post']) {\n            $header .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $header .= \"Content-Length: \" . strlen($conf['post']) . \"\\r\\n\";\n        }\n        $header .= \"Connection: Close\\r\\n\\r\\n\";\n        $header .= $conf['post'];\n        stream_set_blocking($fp, $conf['block']);\n        stream_set_timeout($fp, $conf['timeout']);\n        fwrite($fp, $header);\n        $info = stream_get_meta_data($fp);\n        $response = '';\n        $limit = $conf['limit'];\n        while (!feof($fp) && (!$limit || strlen($response) < $limit)) {\n            if ($info['timed_out']) {\n                return '';\n            }\n            $response .= fread($fp, 8192);\n            $info = stream_get_meta_data($fp);\n        }\n        fclose($fp);\n        $response = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n        return $response;\n    }\n}\n?>\n"
    ],
    "match_count": 5,
    "pass@3": 0.9166666666666666,
    "pass@5": 0.996031746031746
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a PHP function that fetches content from a specified HTTP URL using fsockopen for low-level HTTP communication, with support for proxy configuration and timeout settings.\n\nFunction Description: The function establishes a TCP connection to an HTTP server (or proxy server if configured), sends an HTTP GET request, reads the response, and returns the response body. It handles URL parsing, connection establishment, request sending, response reading, and connection closing. The function can either return the fetched content directly or assign it to a template variable.\n\nInput:\n- $params: An associative array containing:\n  - 'file': (string, required) The HTTP URL to fetch\n  - 'proxy_host': (string, optional) Proxy server hostname\n  - 'proxy_port': (integer, optional) Proxy server port\n  - 'timeout': (integer, optional) Connection timeout in seconds (default: 30)\n  - 'assign': (string, optional) Template variable name to assign the content to\n- $template: (object) The template object for assigning content when 'assign' parameter is used\n\nOutput:\n- Returns the fetched content as a string if 'assign' parameter is not provided\n- Returns nothing (void) if 'assign' parameter is provided (content is assigned to template instead)",
    "Canonical_solution": "function smarty_function_fetch($params, $template)\n{\n    if (empty($params['file'])) {\n        trigger_error(\"[plugin] fetch parameter 'file' cannot be empty\", E_USER_NOTICE);\n        return;\n    }\n\n    $content = '';\n    if (preg_match('!^http://!i', $params['file'])) {\n        if ($uri_parts = parse_url($params['file'])) {\n            $host = $server_name = $uri_parts['host'];\n            $timeout = 30;\n            $port = empty($uri_parts['port']) ? 80 : $uri_parts['port'];\n            $uri = !empty($uri_parts['path']) ? $uri_parts['path'] : '/';\n            $uri .= !empty($uri_parts['query']) ? '?' . $uri_parts['query'] : '';\n            $_is_proxy = false;\n\n            foreach ($params as $param_key => $param_value) {\n                switch ($param_key) {\n                    case \"proxy_host\":\n                        if (!empty($param_value)) {\n                            $proxy_host = $param_value;\n                        }\n                        break;\n                    case \"proxy_port\":\n                        if (!preg_match('!\\D!', $param_value)) {\n                            $proxy_port = (int) $param_value;\n                        }\n                        break;\n                    case \"timeout\":\n                        if (!preg_match('!\\D!', $param_value)) {\n                            $timeout = (int) $param_value;\n                        }\n                        break;\n                }\n            }\n\n            if (!empty($proxy_host) && !empty($proxy_port)) {\n                $_is_proxy = true;\n                $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, $timeout);\n            } else {\n                $fp = fsockopen($server_name, $port, $errno, $errstr, $timeout);\n            }\n\n            if (!$fp) {\n                trigger_error(\"[plugin] unable to fetch: $errstr ($errno)\", E_USER_NOTICE);\n                return;\n            }\n\n            if ($_is_proxy) {\n                fputs($fp, 'GET ' . $params['file'] . \" HTTP/1.0\\r\\n\");\n            } else {\n                fputs($fp, \"GET $uri HTTP/1.0\\r\\n\");\n            }\n            fputs($fp, \"Host: $host\\r\\n\");\n            fputs($fp, \"\\r\\n\");\n\n            while (!feof($fp)) {\n                $content .= fgets($fp, 4096);\n            }\n            fclose($fp);\n\n            $csplit = preg_split(\"!\\r\\n\\r\\n!\", $content, 2);\n            $content = $csplit[1];\n        }\n    }\n\n    if (!empty($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 131,
    "matched_results": [
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : null;\n    $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : null;\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    if ($proxy_host) {\n        $fp = @fsockopen($proxy_host, $proxy_port, $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET $path$query HTTP/1.0\\r\\n\";\n    $request .= \"Host: $request_host\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : null;\n    $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : null;\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    if ($proxy_host) {\n        $fp = @fsockopen($proxy_host, $proxy_port, $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET $path$query HTTP/1.0\\r\\n\";\n    $request .= \"Host: $request_host\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : null;\n    $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : null;\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    if ($proxy_host) {\n        $fp = @fsockopen($proxy_host, $proxy_port, $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET $path$query HTTP/1.0\\r\\n\";\n    $request .= \"Host: $request_host\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    if (isset($params['proxy_host']) && $params['proxy_host']) {\n        $fp = fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET $path$query HTTP/1.0\\r\\n\";\n    $request .= \"Host: $request_host\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    if (isset($params['proxy_host']) && $params['proxy_host']) {\n        $fp = @fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET $path$query HTTP/1.0\\r\\n\";\n    $request .= \"Host: $request_host\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $pos = strpos($response, \"\\r\\n\\r\\n\");\n    if ($pos !== false) {\n        $body = substr($response, $pos + 4);\n    } else {\n        $body = '';\n    }\n\n    if (isset($params['assign']) && $params['assign']) {\n        $template->assign($params['assign'], $body);\n        return;\n    } else {\n        return $body;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    if (isset($params['proxy_host']) && $params['proxy_host']) {\n        $fp = @fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET $path$query HTTP/1.0\\r\\n\";\n    $request .= \"Host: $request_host\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $pos = strpos($response, \"\\r\\n\\r\\n\");\n    if ($pos !== false) {\n        $body = substr($response, $pos + 4);\n    } else {\n        $body = '';\n    }\n\n    if (isset($params['assign']) && $params['assign']) {\n        $template->assign($params['assign'], $body);\n        return;\n    } else {\n        return $body;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    if (isset($params['proxy_host']) && $params['proxy_host']) {\n        $fp = fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET $path$query HTTP/1.1\\r\\n\";\n    $request .= \"Host: $request_host\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $pos = strpos($response, \"\\r\\n\\r\\n\");\n    $body = substr($response, $pos + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $body);\n    } else {\n        return $body;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    if (isset($params['proxy_host']) && $params['proxy_host']) {\n        $fp = fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET $path$query HTTP/1.0\\r\\n\";\n    $request .= \"Host: $request_host\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $content = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    if (isset($params['proxy_host']) && $params['proxy_host']) {\n        $fp = fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET $path$query HTTP/1.0\\r\\n\";\n    $request .= \"Host: $request_host\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $pos = strpos($response, \"\\r\\n\\r\\n\");\n    $body = substr($response, $pos + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $body);\n    } else {\n        return $body;\n    }\n}\n?>\n",
      "<?php\nfunction fetch_url($params, $template) {\n    $url_parts = parse_url($params['file']);\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : 80;\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    if (isset($params['proxy_host']) && $params['proxy_host']) {\n        $fp = fsockopen($params['proxy_host'], $params['proxy_port'], $errno, $errstr, $timeout);\n        $request_host = $host . ':' . $port;\n    } else {\n        $fp = fsockopen($host, $port, $errno, $errstr, $timeout);\n        $request_host = $host;\n    }\n\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET $path$query HTTP/1.1\\r\\n\";\n    $request .= \"Host: $request_host\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    $pos = strpos($response, \"\\r\\n\\r\\n\");\n    $body = substr($response, $pos + 4);\n\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $body);\n    } else {\n        return $body;\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a PHP function that retrieves content from a specified URL using low-level socket operations (fsockopen) rather than higher-level HTTP client libraries. The function should handle both HTTP and HTTPS protocols, manage connection timeouts, and properly process the HTTP response.\n\nFunction Description: The function establishes a TCP connection to the specified HTTP server, sends a GET request, reads the response (separating headers from body), and returns the content. It handles both HTTP and HTTPS connections with appropriate ports, includes basic error handling, and follows proper HTTP protocol for request/response cycles.\n\nInput:\n- $url (string): The URL to fetch content from (e.g., \"http://example.com\" or \"https://example.com\")\n- &$data (string, passed by reference): Variable that will contain the response body content\n\nOutput:\n- bool: Returns true if the request was successful and content was retrieved, false if any error occurred (connection failure, empty response, etc.)\n- The response body content is stored in the $data parameter passed by reference\n\nNote: The function does not return the content directly but instead modifies the $data parameter. This follows the pattern seen in the reference code where output is handled via parameter reference rather than return value.",
    "Canonical_solution": "function file_get_contents_by_socket($url, &$data)\n{\n    $timeout = 1;\n    $p = parse_url($url);\n    $file = $p['path'];\n    if ($p['scheme'] == 'https') {\n        $prefix = 'ssl://';\n        $port = ($p['port'] ? $p['port'] : 443);\n    } else {\n        $prefix = '';\n        $port = ($p['port'] ? $p['port'] : 80);\n    }\n    if ($p['query']) {\n        $file .= '?' . $p['query'];\n    }\n    if (!($fh = @fsockopen($prefix . $p['host'], $port, $errno, $errstr, $timeout))) {\n        return false;\n    }\n\n    $getstring =\n        \"GET \" . $file . \" HTTP/1.0 \\r\\n\" .\n        \"Host: \" . $p['host'] . \" \\r\\n\" .\n        \"Connection: close\\r\\n\\r\\n\";\n    fwrite($fh, $getstring);\n    $s = fgets($fh, 1024);\n    if (!$s) {\n        return false;\n    }\n    $httpheader .= $s;\n    while (!feof($fh)) {\n        $s = fgets($fh, 1024);\n        if ($s == \"\\r\\n\") {\n            break;\n        }\n    }\n    $data = '';\n    while (!feof($fh)) {\n        $data .= fgets($fh, 1024);\n    }\n    fclose($fh);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 131,
    "matched_results": [
      "<?php\nfunction get_url_content($url, &$data) {\n    $url_parts = parse_url($url);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : ($scheme === 'https' ? 443 : 80);\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET {$path}{$query} HTTP/1.1\\r\\n\";\n    $request .= \"Host: {$host}\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    if (!$response) {\n        return false;\n    }\n\n    list($headers, $data) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    return true;\n}\n?>\n",
      "<?php\nfunction get_url_content($url, &$data) {\n    $url_parts = parse_url($url);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : ($scheme === 'https' ? 443 : 80);\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET {$path}{$query} HTTP/1.1\\r\\n\";\n    $request .= \"Host: {$host}\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    if (!$response) {\n        return false;\n    }\n\n    list($headers, $data) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    return true;\n}\n?>\n",
      "<?php\nfunction get_url_content($url, &$data) {\n    $url_parts = parse_url($url);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : ($scheme === 'https' ? 443 : 80);\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET {$path}{$query} HTTP/1.1\\r\\n\";\n    $request .= \"Host: {$host}\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    if (!$response) {\n        return false;\n    }\n\n    list($headers, $data) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    return true;\n}\n?>\n",
      "<?php\nfunction get_url_content($url, &$data) {\n    $url_parts = parse_url($url);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : ($scheme === 'https' ? 443 : 80);\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET {$path}{$query} HTTP/1.1\\r\\n\";\n    $request .= \"Host: {$host}\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    if (!$response) {\n        return false;\n    }\n\n    list($headers, $data) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    return true;\n}\n?>\n",
      "<?php\nfunction get_url_content($url, &$data) {\n    $url_parts = parse_url($url);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : ($scheme === 'https' ? 443 : 80);\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET {$path}{$query} HTTP/1.1\\r\\n\";\n    $request .= \"Host: {$host}\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    if (!$response) {\n        return false;\n    }\n\n    list($headers, $data) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    return true;\n}\n?>\n",
      "<?php\nfunction get_url_content($url, &$data) {\n    $url_parts = parse_url($url);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : ($scheme === 'https' ? 443 : 80);\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET {$path}{$query} HTTP/1.1\\r\\n\";\n    $request .= \"Host: {$host}\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    if (!$response) {\n        return false;\n    }\n\n    list($headers, $data) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    return true;\n}\n?>\n",
      "<?php\nfunction get_url_content($url, &$data) {\n    $url_parts = parse_url($url);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : ($scheme === 'https' ? 443 : 80);\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET {$path}{$query} HTTP/1.1\\r\\n\";\n    $request .= \"Host: {$host}\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    if (!$response) {\n        return false;\n    }\n\n    list($headers, $data) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    return true;\n}\n?>\n",
      "<?php\nfunction get_url_content($url, &$data) {\n    $url_parts = parse_url($url);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : ($scheme === 'https' ? 443 : 80);\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET {$path}{$query} HTTP/1.1\\r\\n\";\n    $request .= \"Host: {$host}\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    if (!$response) {\n        return false;\n    }\n\n    $header_end = strpos($response, \"\\r\\n\\r\\n\");\n    if ($header_end === false) {\n        return false;\n    }\n\n    $data = substr($response, $header_end + 4);\n\n    return true;\n}\n?>\n",
      "<?php\nfunction get_url_content($url, &$data) {\n    $url_parts = parse_url($url);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : ($scheme === 'https' ? 443 : 80);\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET {$path}{$query} HTTP/1.1\\r\\n\";\n    $request .= \"Host: {$host}\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    if (!$response) {\n        return false;\n    }\n\n    list($headers, $data) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    return true;\n}\n?>\n",
      "<?php\nfunction get_url_content($url, &$data) {\n    $url_parts = parse_url($url);\n    if (!$url_parts) {\n        return false;\n    }\n\n    $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';\n    $host = $url_parts['host'];\n    $port = isset($url_parts['port']) ? $url_parts['port'] : ($scheme === 'https' ? 443 : 80);\n    $path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n    $query = isset($url_parts['query']) ? '?' . $url_parts['query'] : '';\n\n    $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n    if (!$fp) {\n        return false;\n    }\n\n    $request = \"GET {$path}{$query} HTTP/1.1\\r\\n\";\n    $request .= \"Host: {$host}\\r\\n\";\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    fwrite($fp, $request);\n\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 1024);\n    }\n    fclose($fp);\n\n    if (!$response) {\n        return false;\n    }\n\n    list($headers, $data) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n    return true;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a PHP class that handles file uploads to a specified host using HTTP PUT requests with Guzzle HTTP client, including CRC32 checksum verification.\n\nClass Description: ImageX is a class that extends V4Curl and provides functionality to upload files to a remote server. It handles file validation, CRC32 checksum generation, and HTTP communication using Guzzle's HTTP client.\n\nAttributes: (No explicit attributes in this class - it inherits from V4Curl)\n\nMethods:\nupload: [upload](string $uploadHost, array $storeInfo, string $filePath) -> int - Uploads a file to the specified host using HTTP PUT request. Validates file existence, calculates CRC32 checksum, and sends the file with appropriate headers. Returns 0 on success, -1 if file doesn't exist, or -2 if upload fails.\n\nParameters:\n- $uploadHost: string - The host address to upload to\n- $storeInfo: array - Contains 'StoreUri' for upload endpoint and 'Auth' for authorization\n- $filePath: string - Local path to the file to be uploaded\n\nReturn:\n- int: 0 for success, -1 for file not found, -2 for upload failure",
    "Canonical_solution": "use Volc\\Base\\V4Curl;\nuse GuzzleHttp\\Client;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, $storeInfo, string $filePath)\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n        $content = file_get_contents($filePath);\n        $crc32 = sprintf(\"%08x\", crc32($content));\n\n        $body = fopen($filePath, \"r\");\n        $tosClient = new Client([\n            'base_uri' => \"https://\" . $uploadHost,\n            'timeout' => 5.0,\n        ]);\n\n        $response = $tosClient->request('PUT', $storeInfo[\"StoreUri\"], [\"body\" => $body, \"headers\" => ['Authorization' => $storeInfo[\"Auth\"], 'Content-CRC32' => $crc32]]);\n        $uploadResponse = json_decode((string) $response->getBody(), true);\n        if (!isset($uploadResponse[\"success\"]) || $uploadResponse[\"success\"] != 0) {\n            return -2;\n        }\n        return 0;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Utils;\nuse GuzzleHttp\\Exception\\RequestException;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, array $storeInfo, string $filePath): int\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $fileSize = filesize($filePath);\n        $crc32 = hash_file('crc32b', $filePath);\n\n        $client = new Client();\n\n        try {\n            $response = $client->put($uploadHost . $storeInfo['StoreUri'], [\n                'headers' => [\n                    'Authorization' => $storeInfo['Auth'],\n                    'Content-Length' => $fileSize,\n                    'Content-CRC32' => $crc32,\n                    'Content-Type' => mime_content_type($filePath),\n                ],\n                'body' => Utils::streamFor(fopen($filePath, 'r')),\n            ]);\n\n            if ($response->getStatusCode() >= 200 && $response->getStatusCode() < 300) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (RequestException $e) {\n            return -2;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Utils;\nuse GuzzleHttp\\Exception\\RequestException;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, array $storeInfo, string $filePath): int\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $fileSize = filesize($filePath);\n        $crc32 = hash_file('crc32b', $filePath);\n        $fileStream = Utils::tryFopen($filePath, 'r');\n\n        $client = new Client();\n\n        try {\n            $response = $client->put($uploadHost . $storeInfo['StoreUri'], [\n                'headers' => [\n                    'Content-Length' => $fileSize,\n                    'Content-CRC32' => $crc32,\n                    'Authorization' => $storeInfo['Auth'],\n                ],\n                'body' => $fileStream,\n            ]);\n\n            if ($response->getStatusCode() >= 200 && $response->getStatusCode() < 300) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (RequestException $e) {\n            return -2;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Utils;\nuse GuzzleHttp\\Exception\\RequestException;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, array $storeInfo, string $filePath): int\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $fileSize = filesize($filePath);\n        $crc32 = hash_file('crc32b', $filePath);\n        $fileStream = Utils::tryFopen($filePath, 'r');\n\n        $client = new Client();\n\n        $headers = [\n            'Content-Length' => $fileSize,\n            'Content-CRC32' => $crc32,\n            'Authorization' => $storeInfo['Auth'],\n        ];\n\n        try {\n            $response = $client->put($uploadHost . $storeInfo['StoreUri'], [\n                'headers' => $headers,\n                'body' => $fileStream,\n            ]);\n\n            if ($response->getStatusCode() >= 200 && $response->getStatusCode() < 300) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (RequestException $e) {\n            return -2;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Utils;\nuse GuzzleHttp\\RequestOptions;\nuse GuzzleHttp\\Exception\\RequestException;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, array $storeInfo, string $filePath): int\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $fileSize = filesize($filePath);\n        $crc32 = hash_file('crc32b', $filePath);\n        $fileStream = Utils::tryFopen($filePath, 'r');\n\n        $client = new Client();\n\n        $headers = [\n            'Content-Length' => $fileSize,\n            'Content-CRC32' => $crc32,\n            'Authorization' => $storeInfo['Auth'],\n        ];\n\n        try {\n            $response = $client->put($uploadHost . $storeInfo['StoreUri'], [\n                RequestOptions::HEADERS => $headers,\n                RequestOptions::BODY => $fileStream,\n            ]);\n\n            if ($response->getStatusCode() >= 200 && $response->getStatusCode() < 300) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (RequestException $e) {\n            return -2;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Utils;\nuse GuzzleHttp\\Exception\\RequestException;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, array $storeInfo, string $filePath): int\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $fileSize = filesize($filePath);\n        $crc32 = hash_file('crc32b', $filePath);\n        $fileStream = Utils::tryFopen($filePath, 'r');\n\n        $client = new Client();\n\n        $headers = [\n            'Content-Length' => $fileSize,\n            'Content-CRC32' => $crc32,\n            'Authorization' => $storeInfo['Auth'],\n        ];\n\n        try {\n            $response = $client->put($uploadHost . $storeInfo['StoreUri'], [\n                'headers' => $headers,\n                'body' => $fileStream,\n            ]);\n\n            if ($response->getStatusCode() >= 200 && $response->getStatusCode() < 300) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (RequestException $e) {\n            return -2;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Utils;\nuse GuzzleHttp\\RequestOptions;\nuse GuzzleHttp\\Exception\\RequestException;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, array $storeInfo, string $filePath): int\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $fileSize = filesize($filePath);\n        $crc32 = hash_file('crc32b', $filePath);\n        $fileStream = Utils::tryFopen($filePath, 'r');\n\n        $client = new Client();\n\n        $headers = [\n            'Content-Length' => $fileSize,\n            'Content-CRC32' => $crc32,\n            'Authorization' => $storeInfo['Auth'],\n        ];\n\n        try {\n            $response = $client->put($uploadHost . $storeInfo['StoreUri'], [\n                RequestOptions::HEADERS => $headers,\n                RequestOptions::BODY => $fileStream,\n            ]);\n\n            if ($response->getStatusCode() >= 200 && $response->getStatusCode() < 300) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (RequestException $e) {\n            return -2;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Utils;\nuse GuzzleHttp\\RequestOptions;\nuse GuzzleHttp\\Exception\\RequestException;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, array $storeInfo, string $filePath): int\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $fileSize = filesize($filePath);\n        $crc32 = hash_file('crc32b', $filePath);\n        $fileStream = Utils::tryFopen($filePath, 'r');\n\n        $client = new Client();\n\n        $headers = [\n            'Content-Length' => $fileSize,\n            'Content-CRC32' => $crc32,\n            'Authorization' => $storeInfo['Auth'],\n        ];\n\n        try {\n            $response = $client->put($uploadHost . $storeInfo['StoreUri'], [\n                RequestOptions::HEADERS => $headers,\n                RequestOptions::BODY => $fileStream,\n            ]);\n\n            if ($response->getStatusCode() >= 200 && $response->getStatusCode() < 300) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (RequestException $e) {\n            return -2;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Utils;\nuse GuzzleHttp\\RequestOptions;\nuse GuzzleHttp\\Exception\\RequestException;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, array $storeInfo, string $filePath): int\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $fileSize = filesize($filePath);\n        $crc32 = hash_file('crc32b', $filePath);\n        $fileStream = Utils::tryFopen($filePath, 'r');\n\n\n        $client = new Client();\n\n        try {\n            $response = $client->put($uploadHost . $storeInfo['StoreUri'], [\n                RequestOptions::BODY => $fileStream,\n                RequestOptions::HEADERS => [\n                    'Content-Length' => $fileSize,\n                    'Content-CRC32' => $crc32,\n                    'Authorization' => $storeInfo['Auth'],\n                ],\n            ]);\n\n            if ($response->getStatusCode() >= 200 && $response->getStatusCode() < 300) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (RequestException $e) {\n            return -2;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Utils;\nuse GuzzleHttp\\Exception\\RequestException;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, array $storeInfo, string $filePath): int\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $fileSize = filesize($filePath);\n        $crc32 = hash_file('crc32b', $filePath);\n        $fileStream = Utils::tryFopen($filePath, 'r');\n\n        $client = new Client();\n\n        $headers = [\n            'Content-Length' => $fileSize,\n            'Content-CRC32' => $crc32,\n            'Authorization' => $storeInfo['Auth'],\n        ];\n\n        try {\n            $response = $client->put($uploadHost . $storeInfo['StoreUri'], [\n                'headers' => $headers,\n                'body' => $fileStream,\n            ]);\n\n            if ($response->getStatusCode() >= 200 && $response->getStatusCode() < 300) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (RequestException $e) {\n            return -2;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Utils;\nuse GuzzleHttp\\RequestOptions;\nuse GuzzleHttp\\Exception\\RequestException;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, array $storeInfo, string $filePath): int\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $fileSize = filesize($filePath);\n        $crc32 = hash_file('crc32b', $filePath);\n        $fileStream = Utils::tryFopen($filePath, 'r');\n\n        $client = new Client();\n\n        $headers = [\n            'Content-Length' => $fileSize,\n            'Content-CRC32' => $crc32,\n            'Authorization' => $storeInfo['Auth'],\n        ];\n\n        try {\n            $response = $client->put($uploadHost . $storeInfo['StoreUri'], [\n                RequestOptions::HEADERS => $headers,\n                RequestOptions::BODY => $fileStream,\n            ]);\n\n            if ($response->getStatusCode() >= 200 && $response->getStatusCode() < 300) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (RequestException $e) {\n            return -2;\n        }\n    }\n}\n\n?>\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Implement a PHP class that provides HTTP client functionality using fsockopen for making HTTP requests when cURL is not available. The class should support both GET and POST requests with configurable options like timeout, cookies, and blocking mode.\n\nClass Description: The Http class provides a static method for making HTTP requests using fsockopen. It's designed as a fallback when cURL isn't available, offering stable performance with configurable options for different HTTP request scenarios.\n\nMethods:\n\nMethod1: fsockopenDownload(string $url, array $conf = array()) -> mixed - Makes an HTTP request using fsockopen\n  Input:\n    - $url: string - The target URL to request\n    - $conf: array - Configuration options including:\n      - limit: int - Number of characters to read in segments (0 for unlimited)\n      - post: string|array - POST content (either as string or array for form data)\n      - cookie: string - Cookie content to send with request\n      - ip: string - IP address to use instead of resolving hostname\n      - timeout: int - Connection timeout in seconds (default: 15)\n      - block: bool - Whether to use blocking mode (default: true)\n  Output:\n    - Returns string containing the HTTP response body, or empty string on failure",
    "Canonical_solution": "namespace Org\\Net;\n\nclass Http\n{\n    /**\n     * 使用 fsockopen 通过 HTTP 协议直接访问(采集)远程文件\n     * 如果主机或服务器没有开启 CURL 扩展可考虑使用\n     * fsockopen 比 CURL 稍慢,但性能稳定\n     * @static\n     * @access public\n     * @param string $url 远程URL\n     * @param array $conf 其他配置信息\n     *        int   limit 分段读取字符个数\n     *        string post  post的内容,字符串或数组,key=value&形式\n     *        string cookie 携带cookie访问,该参数是cookie内容\n     *        string ip    如果该参数传入,$url将不被使用,ip访问优先\n     *        int    timeout 采集超时时间\n     *        bool   block 是否阻塞访问,默认为true\n     * @return mixed\n     */\n    public static function fsockopenDownload($url, $conf = array())\n    {\n        $return = '';\n        if (!is_array($conf)) {\n            return $return;\n        }\n\n        $matches                                       = parse_url($url);\n        !isset($matches['host']) && $matches['host']   = '';\n        !isset($matches['path']) && $matches['path']   = '';\n        !isset($matches['query']) && $matches['query'] = '';\n        !isset($matches['port']) && $matches['port']   = '';\n        $host                                          = $matches['host'];\n        $path                                          = $matches['path'] ? $matches['path'] . ($matches['query'] ? '?' . $matches['query'] : '') : '/';\n        $port                                          = !empty($matches['port']) ? $matches['port'] : 80;\n\n        $conf_arr = array(\n            'limit'   => 0,\n            'post'    => '',\n            'cookie'  => '',\n            'ip'      => '',\n            'timeout' => 15,\n            'block'   => true,\n        );\n\n        foreach (array_merge($conf_arr, $conf) as $k => $v) {\n            ${$k} = $v;\n        }\n\n        if ($post) {\n            if (is_array($post)) {\n                $post = http_build_query($post);\n            }\n            $out = \"POST $path HTTP/1.0\\r\\n\";\n            $out .= \"Accept: */*\\r\\n\";\n            $out .= \"Accept-Language: zh-cn\\r\\n\";\n            $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $out .= \"User-Agent: $_SERVER[HTTP_USER_AGENT]\\r\\n\";\n            $out .= \"Host: $host\\r\\n\";\n            $out .= 'Content-Length: ' . strlen($post) . \"\\r\\n\";\n            $out .= \"Connection: Close\\r\\n\";\n            $out .= \"Cache-Control: no-cache\\r\\n\";\n            $out .= \"Cookie: $cookie\\r\\n\\r\\n\";\n            $out .= $post;\n        } else {\n            $out = \"GET $path HTTP/1.0\\r\\n\";\n            $out .= \"Accept: */*\\r\\n\";\n            $out .= \"Accept-Language: zh-cn\\r\\n\";\n            $out .= \"User-Agent: $_SERVER[HTTP_USER_AGENT]\\r\\n\";\n            $out .= \"Host: $host\\r\\n\";\n            $out .= \"Connection: Close\\r\\n\";\n            $out .= \"Cookie: $cookie\\r\\n\\r\\n\";\n        }\n        $fp = @fsockopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout);\n        if (!$fp) {\n            return '';\n        } else {\n            stream_set_blocking($fp, $block);\n            stream_set_timeout($fp, $timeout);\n            @fwrite($fp, $out);\n            $status = stream_get_meta_data($fp);\n            if (!$status['timed_out']) {\n                while (!feof($fp)) {\n                    if (($header = @fgets($fp)) && (\"\\r\\n\" == $header || \"\\n\" == $header)) {\n                        break;\n                    }\n                }\n\n                $stop = false;\n                while (!feof($fp) && !$stop) {\n                    $data = fread($fp, (0 == $limit || $limit > 8192 ? 8192 : $limit));\n                    $return .= $data;\n                    if ($limit) {\n                        $limit -= strlen($data);\n                        $stop = $limit <= 0;\n                    }\n                }\n            }\n            @fclose($fp);\n            return $return;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 131,
    "matched_results": [
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = array()) {\n        $parsedUrl = parse_url($url);\n        $host = $parsedUrl['host'];\n        $port = isset($parsedUrl['port']) ? $parsedUrl['port'] : 80;\n        $path = isset($parsedUrl['path']) ? $parsedUrl['path'] : '/';\n        $query = isset($parsedUrl['query']) ? '?' . $parsedUrl['query'] : '';\n\n        $limit = $conf['limit'] ?? 0;\n        $post = $conf['post'] ?? null;\n        $cookie = $conf['cookie'] ?? '';\n        $ip = $conf['ip'] ?? null;\n        $timeout = $conf['timeout'] ?? 15;\n        $block = $conf['block'] ?? true;\n\n        $fp = @fsockopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout);\n        if (!$fp) {\n            return '';\n        }\n\n        $method = $post ? 'POST' : 'GET';\n        $content = is_array($post) ? http_build_query($post) : $post;\n        $contentType = is_array($post) ? 'application/x-www-form-urlencoded' : 'text/plain';\n\n        $out = \"$method $path$query HTTP/1.1\\r\\n\";\n        $out .= \"Host: $host\\r\\n\";\n        if ($cookie) {\n            $out .= \"Cookie: $cookie\\r\\n\";\n        }\n        if ($post) {\n            $out .= \"Content-Type: $contentType\\r\\n\";\n            $out .= \"Content-Length: \" . strlen($content) . \"\\r\\n\";\n        }\n        $out .= \"Connection: Close\\r\\n\\r\\n\";\n        $out .= $content;\n\n        stream_set_blocking($fp, $block);\n        fwrite($fp, $out);\n\n        $response = '';\n        $headers = '';\n        while (!feof($fp)) {\n            $line = fgets($fp);\n            if ($line == \"\\r\\n\") {\n                break;\n            }\n            $headers .= $line;\n        }\n\n        $body = '';\n        $i = 0;\n        while (!feof($fp) && (!$limit || $i < $limit)) {\n            $body .= fread($fp, 8192);\n            $i += 8192;\n        }\n\n        fclose($fp);\n        return $body;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = array()) {\n        $parsed_url = parse_url($url);\n        $host = $parsed_url['host'];\n        $port = isset($parsed_url['port']) ? $parsed_url['port'] : 80;\n        $path = isset($parsed_url['path']) ? $parsed_url['path'] : '/';\n        $query = isset($parsed_url['query']) ? '?' . $parsed_url['query'] : '';\n\n        $fp = @fsockopen(isset($conf['ip']) ? $conf['ip'] : $host, $port, $errno, $errstr, isset($conf['timeout']) ? $conf['timeout'] : 15);\n        if (!$fp) {\n            return '';\n        }\n\n        $limit = isset($conf['limit']) ? $conf['limit'] : 0;\n        $post_content = isset($conf['post']) ? $conf['post'] : '';\n        $cookie = isset($conf['cookie']) ? $conf['cookie'] : '';\n        $block = isset($conf['block']) ? $conf['block'] : true;\n\n\n        if (is_array($post_content)) {\n            $post_string = http_build_query($post_content);\n            $content_type = \"application/x-www-form-urlencoded\";\n        } else {\n            $post_string = $post_content;\n            $content_type = \"application/octet-stream\"; \n        }\n\n        $out = (empty($post_content) ? \"GET\" : \"POST\") . \" $path$query HTTP/1.1\\r\\n\";\n        $out .= \"Host: $host\\r\\n\";\n        $out .= \"User-Agent: PHP fsockopen\\r\\n\";\n        if (!empty($cookie)) {\n            $out .= \"Cookie: $cookie\\r\\n\";\n        }\n        if (!empty($post_content)) {\n            $out .= \"Content-Type: $content_type\\r\\n\";\n            $out .= \"Content-Length: \" . strlen($post_string) . \"\\r\\n\";\n        }\n        $out .= \"Connection: Close\\r\\n\\r\\n\";\n        $out .= $post_string;\n\n        stream_set_blocking($fp, $block);\n        fwrite($fp, $out);\n\n        $response = '';\n        $header_parsed = false;\n\n        while (!feof($fp)) {\n            $line = fgets($fp, 1024);\n            if ($header_parsed && ($limit == 0 || strlen($response) < $limit)) {\n                $response .= $line;\n            }\n\n            if ($line == \"\\r\\n\") {\n                $header_parsed = true;\n            }\n        }\n        fclose($fp);\n        return $response;\n    }\n}\n?>\n"
    ],
    "unmatched_results": [
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = array()) {\n        $parsedUrl = parse_url($url);\n        $host = $parsedUrl['host'];\n        $port = isset($parsedUrl['port']) ? $parsedUrl['port'] : 80;\n        $path = isset($parsedUrl['path']) ? $parsedUrl['path'] : '/';\n        $query = isset($parsedUrl['query']) ? '?' . $parsedUrl['query'] : '';\n\n        $limit = isset($conf['limit']) ? $conf['limit'] : 0;\n        $post = isset($conf['post']) ? $conf['post'] : '';\n        $cookie = isset($conf['cookie']) ? $conf['cookie'] : '';\n        $ip = isset($conf['ip']) ? $conf['ip'] : '';\n        $timeout = isset($conf['timeout']) ? $conf['timeout'] : 15;\n        $block = isset($conf['block']) ? $conf['block'] : true;\n\n\n        $fp = @fsockopen($ip ?: $host, $port, $errno, $errstr, $timeout);\n\n        if (!$fp) {\n            return '';\n        }\n\n        $method = empty($post) ? 'GET' : 'POST';\n\n        if (is_array($post)) {\n            $post_string = http_build_query($post);\n            $content_type = \"application/x-www-form-urlencoded\";\n        } else {\n            $post_string = $post;\n            $content_type = \"application/json\"; \n        }\n\n\n        $out = \"$method $path$query HTTP/1.1\\r\\n\";\n        $out .= \"Host: $host\\r\\n\";\n        if (!empty($cookie)) {\n            $out .= \"Cookie: $cookie\\r\\n\";\n        }\n        if (!empty($post)) {\n            $out .= \"Content-Type: $content_type\\r\\n\";\n            $out .= \"Content-Length: \" . strlen($post_string) . \"\\r\\n\";\n        }\n        $out .= \"Connection: Close\\r\\n\\r\\n\";\n        $out .= $post_string;\n\n\n        stream_set_blocking($fp, $block);\n        fwrite($fp, $out);\n\n        $response = '';\n        $total_read = 0;\n\n        while (!feof($fp)) {\n            $data = fread($fp, $limit ? min(8192, $limit - $total_read) : 8192);\n            if ($data === false) {\n                return '';\n            }\n            $response .= $data;\n            $total_read += strlen($data);\n            if ($limit && $total_read >= $limit) {\n                break;\n            }\n        }\n\n        fclose($fp);\n\n        $header_end = strpos($response, \"\\r\\n\\r\\n\");\n        if ($header_end !== false) {\n            $response = substr($response, $header_end + 4);\n        }\n\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = array()) {\n        $parsedUrl = parse_url($url);\n        $host = $parsedUrl['host'];\n        $port = isset($parsedUrl['port']) ? $parsedUrl['port'] : 80;\n        $path = isset($parsedUrl['path']) ? $parsedUrl['path'] : '/';\n        $query = isset($parsedUrl['query']) ? '?' . $parsedUrl['query'] : '';\n\n        $limit = isset($conf['limit']) ? $conf['limit'] : 0;\n        $post = isset($conf['post']) ? $conf['post'] : '';\n        $cookie = isset($conf['cookie']) ? $conf['cookie'] : '';\n        $ip = isset($conf['ip']) ? $conf['ip'] : '';\n        $timeout = isset($conf['timeout']) ? $conf['timeout'] : 15;\n        $block = isset($conf['block']) ? $conf['block'] : true;\n\n        $fp = @fsockopen($ip ?: $host, $port, $errno, $errstr, $timeout);\n        if (!$fp) {\n            return '';\n        }\n\n        $method = empty($post) ? 'GET' : 'POST';\n        $contentLength = is_array($post) ? strlen(http_build_query($post)) : strlen($post);\n\n        $out = \"$method $path$query HTTP/1.1\\r\\n\";\n        $out .= \"Host: $host\\r\\n\";\n        $out .= \"User-Agent: PHP\\r\\n\";\n        if ($contentLength > 0) {\n            $out .= \"Content-Type: \" . (is_array($post) ? 'application/x-www-form-urlencoded' : 'application/octet-stream') . \"\\r\\n\";\n            $out .= \"Content-Length: $contentLength\\r\\n\";\n        }\n        if (!empty($cookie)) {\n            $out .= \"Cookie: $cookie\\r\\n\";\n        }\n        $out .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($contentLength > 0) {\n            $out .= is_array($post) ? http_build_query($post) : $post;\n        }\n\n        stream_set_blocking($fp, $block);\n        fwrite($fp, $out);\n\n        $response = '';\n        $limitCounter = 0;\n        while (!feof($fp)) {\n            $response .= fread($fp, $limit > 0 && $limitCounter + 8192 > $limit ? $limit - $limitCounter : 8192);\n            $limitCounter += 8192;\n            if ($limit > 0 && $limitCounter >= $limit) break;\n        }\n        fclose($fp);\n\n        $headerPos = strpos($response, \"\\r\\n\\r\\n\");\n        if ($headerPos !== false) {\n            $response = substr($response, $headerPos + 4);\n        }\n\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = array()) {\n        $parsedUrl = parse_url($url);\n        $host = $parsedUrl['host'];\n        $port = isset($parsedUrl['port']) ? $parsedUrl['port'] : 80;\n        $path = isset($parsedUrl['path']) ? $parsedUrl['path'] : '/';\n        $query = isset($parsedUrl['query']) ? '?' . $parsedUrl['query'] : '';\n\n        $limit = isset($conf['limit']) ? $conf['limit'] : 0;\n        $post = isset($conf['post']) ? $conf['post'] : '';\n        $cookie = isset($conf['cookie']) ? $conf['cookie'] : '';\n        $ip = isset($conf['ip']) ? $conf['ip'] : '';\n        $timeout = isset($conf['timeout']) ? $conf['timeout'] : 15;\n        $block = isset($conf['block']) ? $conf['block'] : true;\n\n\n        $fp = @fsockopen($ip ?: $host, $port, $errno, $errstr, $timeout);\n\n        if (!$fp) {\n            return '';\n        }\n\n        $method = empty($post) ? 'GET' : 'POST';\n\n        if (is_array($post)) {\n            $post_string = http_build_query($post);\n            $content_type = 'application/x-www-form-urlencoded';\n        } else {\n            $post_string = $post;\n            $content_type = 'application/octet-stream'; \n        }\n\n\n        $out = \"$method $path$query HTTP/1.1\\r\\n\";\n        $out .= \"Host: $host\\r\\n\";\n        $out .= \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\\r\\n\";\n        if (!empty($cookie)) {\n            $out .= \"Cookie: $cookie\\r\\n\";\n        }\n        if (!empty($post)) {\n            $out .= \"Content-Type: $content_type\\r\\n\";\n            $out .= \"Content-Length: \" . strlen($post_string) . \"\\r\\n\";\n        }\n        $out .= \"Connection: Close\\r\\n\\r\\n\";\n        $out .= $post_string;\n\n\n        stream_set_blocking($fp, $block);\n        fwrite($fp, $out);\n\n        $response = '';\n        $total_read = 0;\n\n        while (!feof($fp) && (!$limit || $total_read < $limit)) {\n            $chunk = fread($fp, 8192);\n            if ($chunk === false) {\n                break; \n            }\n            $response .= $chunk;\n            $total_read += strlen($chunk);\n        }\n\n        fclose($fp);\n\n        $header_end = strpos($response, \"\\r\\n\\r\\n\");\n        if ($header_end !== false) {\n            return substr($response, $header_end + 4);\n        }\n\n        return '';\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = array()) {\n        $parsedUrl = parse_url($url);\n        $host = $parsedUrl['host'];\n        $port = isset($parsedUrl['port']) ? $parsedUrl['port'] : 80;\n        $path = isset($parsedUrl['path']) ? $parsedUrl['path'] : '/';\n        $query = isset($parsedUrl['query']) ? '?' . $parsedUrl['query'] : '';\n\n        $fp = @fsockopen(isset($conf['ip']) ? $conf['ip'] : $host, $port, $errno, $errstr, isset($conf['timeout']) ? $conf['timeout'] : 15);\n        if (!$fp) {\n            return '';\n        }\n\n        $method = isset($conf['post']) ? 'POST' : 'GET';\n        $content = isset($conf['post']) ? (is_array($conf['post']) ? http_build_query($conf['post']) : $conf['post']) : '';\n        $contentLength = strlen($content);\n\n        $headers = \"$method $path$query HTTP/1.1\\r\\n\";\n        $headers .= \"Host: $host\\r\\n\";\n        if ($contentLength > 0) {\n            $headers .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $headers .= \"Content-Length: $contentLength\\r\\n\";\n        }\n        if (isset($conf['cookie'])) {\n            $headers .= \"Cookie: \" . $conf['cookie'] . \"\\r\\n\";\n        }\n        $headers .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($contentLength > 0) {\n            $headers .= $content;\n        }\n\n        stream_set_blocking($fp, isset($conf['block']) ? $conf['block'] : true);\n        fwrite($fp, $headers);\n\n        $response = '';\n        $limit = isset($conf['limit']) ? $conf['limit'] : 0;\n        if ($limit > 0) {\n            while (!feof($fp) && $limit > 0) {\n                $chunk = fread($fp, min($limit, 8192));\n                $response .= $chunk;\n                $limit -= strlen($chunk);\n            }\n        } else {\n            while (!feof($fp)) {\n                $response .= fread($fp, 8192);\n            }\n        }\n        fclose($fp);\n\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = array()) {\n        $parsedUrl = parse_url($url);\n        $host = $parsedUrl['host'];\n        $port = isset($parsedUrl['port']) ? $parsedUrl['port'] : 80;\n        $path = isset($parsedUrl['path']) ? $parsedUrl['path'] : '/';\n        $query = isset($parsedUrl['query']) ? '?' . $parsedUrl['query'] : '';\n\n        $limit = isset($conf['limit']) ? $conf['limit'] : 0;\n        $post = isset($conf['post']) ? $conf['post'] : '';\n        $cookie = isset($conf['cookie']) ? $conf['cookie'] : '';\n        $ip = isset($conf['ip']) ? $conf['ip'] : '';\n        $timeout = isset($conf['timeout']) ? $conf['timeout'] : 15;\n        $block = isset($conf['block']) ? $conf['block'] : true;\n\n        $fp = @fsockopen($ip ?: $host, $port, $errno, $errstr, $timeout);\n        if (!$fp) {\n            return '';\n        }\n\n        $method = empty($post) ? 'GET' : 'POST';\n        $contentLength = is_array($post) ? self::getPostContentLength($post) : strlen($post);\n\n        $out = \"$method $path$query HTTP/1.1\\r\\n\";\n        $out .= \"Host: $host\\r\\n\";\n        $out .= \"User-Agent: PHP\\r\\n\";\n        if ($contentLength > 0) {\n            $out .= \"Content-Type: \" . (is_array($post) ? 'application/x-www-form-urlencoded' : 'application/octet-stream') . \"\\r\\n\";\n            $out .= \"Content-Length: $contentLength\\r\\n\";\n        }\n        if (!empty($cookie)) {\n            $out .= \"Cookie: $cookie\\r\\n\";\n        }\n        $out .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($contentLength > 0) {\n            $out .= is_array($post) ? http_build_query($post) : $post;\n        }\n\n        stream_set_blocking($fp, $block);\n        fwrite($fp, $out);\n\n        $response = '';\n        $limitReached = false;\n        while (!feof($fp) && !$limitReached) {\n            $chunk = fread($fp, 8192);\n            if ($limit > 0 && strlen($response) + strlen($chunk) >= $limit) {\n                $chunk = substr($chunk, 0, $limit - strlen($response));\n                $limitReached = true;\n            }\n            $response .= $chunk;\n        }\n        fclose($fp);\n\n        return $response;\n    }\n\n    private static function getPostContentLength(array $postData): int {\n        $length = 0;\n        foreach ($postData as $key => $value) {\n            $length += strlen(urlencode($key)) + 1 + strlen(urlencode($value)) + ($length > 0 ? 1 : 0);\n        }\n        return $length;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = array()) {\n        $parsedUrl = parse_url($url);\n        $host = $parsedUrl['host'];\n        $port = isset($parsedUrl['port']) ? $parsedUrl['port'] : 80;\n        $path = isset($parsedUrl['path']) ? $parsedUrl['path'] : '/';\n        $query = isset($parsedUrl['query']) ? '?' . $parsedUrl['query'] : '';\n\n        $limit = $conf['limit'] ?? 0;\n        $post = $conf['post'] ?? null;\n        $cookie = $conf['cookie'] ?? '';\n        $ip = $conf['ip'] ?? null;\n        $timeout = $conf['timeout'] ?? 15;\n        $block = $conf['block'] ?? true;\n\n        $fp = @fsockopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout);\n        if (!$fp) {\n            return '';\n        }\n\n        $method = $post ? 'POST' : 'GET';\n        $contentLength = is_array($post) ? http_build_query($post) : $post;\n        $contentType = is_array($post) ? 'application/x-www-form-urlencoded' : (is_string($post) ? 'text/plain' : '');\n\n        $out = \"$method $path$query HTTP/1.1\\r\\n\";\n        $out .= \"Host: $host\\r\\n\";\n        $out .= \"User-Agent: PHP fsockopen\\r\\n\";\n        if ($cookie) {\n            $out .= \"Cookie: $cookie\\r\\n\";\n        }\n        if ($contentLength) {\n            $out .= \"Content-Type: $contentType\\r\\n\";\n            $out .= \"Content-Length: \" . strlen($contentLength) . \"\\r\\n\";\n        }\n        $out .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($contentLength) {\n            $out .= $contentLength;\n        }\n\n        stream_set_blocking($fp, $block);\n        fwrite($fp, $out);\n\n        $response = '';\n        $headers = '';\n        while (!feof($fp) && (!$limit || strlen($response) < $limit)) {\n            $response .= fread($fp, 8192);\n        }\n        fclose($fp);\n\n        $headerPos = strpos($response, \"\\r\\n\\r\\n\");\n        if ($headerPos !== false) {\n            $headers = substr($response, 0, $headerPos);\n            $response = substr($response, $headerPos + 4);\n        }\n\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = array()) {\n        $parsedUrl = parse_url($url);\n        $host = $parsedUrl['host'];\n        $port = isset($parsedUrl['port']) ? $parsedUrl['port'] : 80;\n        $path = isset($parsedUrl['path']) ? $parsedUrl['path'] : '/';\n        $query = isset($parsedUrl['query']) ? '?' . $parsedUrl['query'] : '';\n\n        $limit = $conf['limit'] ?? 0;\n        $postData = $conf['post'] ?? null;\n        $cookie = $conf['cookie'] ?? '';\n        $ip = $conf['ip'] ?? null;\n        $timeout = $conf['timeout'] ?? 15;\n        $block = $conf['block'] ?? true;\n\n        $fp = @fsockopen(($ip ?: $host), $port, $errno, $errstr, $timeout);\n        if (!$fp) {\n            return '';\n        }\n\n        $method = $postData ? 'POST' : 'GET';\n        $contentLength = is_array($postData) ? self::buildPostData($postData) : strlen($postData);\n\n        $headers = \"$method $path$query HTTP/1.1\\r\\n\";\n        $headers .= \"Host: $host\\r\\n\";\n        if ($cookie) {\n            $headers .= \"Cookie: $cookie\\r\\n\";\n        }\n        if ($postData) {\n            $headers .= \"Content-Type: \" . (is_array($postData) ? 'application/x-www-form-urlencoded' : 'application/octet-stream') . \"\\r\\n\";\n            $headers .= \"Content-Length: $contentLength\\r\\n\";\n        }\n        $headers .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($postData) {\n            $headers .= (is_array($postData) ? $contentLength : $postData);\n        }\n\n        stream_set_blocking($fp, $block);\n        fwrite($fp, $headers);\n\n        $response = '';\n        $readLength = 0;\n        while (!feof($fp) && (!$limit || $readLength < $limit)) {\n            $chunk = fread($fp, 8192);\n            if ($chunk === false) break;\n            $response .= $chunk;\n            $readLength += strlen($chunk);\n        }\n        fclose($fp);\n\n        return $response;\n    }\n\n    private static function buildPostData(array $postData): string {\n        $data = [];\n        foreach ($postData as $key => $value) {\n            $data[] = urlencode($key) . '=' . urlencode($value);\n        }\n        return implode('&', $data);\n    }\n}\n?>\n",
      "<?php\nclass Http {\n    public static function fsockopenDownload(string $url, array $conf = array()) {\n        $parsedUrl = parse_url($url);\n        $host = $parsedUrl['host'];\n        $port = isset($parsedUrl['port']) ? $parsedUrl['port'] : 80;\n        $path = isset($parsedUrl['path']) ? $parsedUrl['path'] : '/';\n        $query = isset($parsedUrl['query']) ? '?' . $parsedUrl['query'] : '';\n\n        $limit = isset($conf['limit']) ? $conf['limit'] : 0;\n        $post = isset($conf['post']) ? $conf['post'] : '';\n        $cookie = isset($conf['cookie']) ? $conf['cookie'] : '';\n        $ip = isset($conf['ip']) ? $conf['ip'] : '';\n        $timeout = isset($conf['timeout']) ? $conf['timeout'] : 15;\n        $block = isset($conf['block']) ? $conf['block'] : true;\n\n        $fp = @fsockopen($ip ?: $host, $port, $errno, $errstr, $timeout);\n        if (!$fp) {\n            return '';\n        }\n\n        $method = empty($post) ? 'GET' : 'POST';\n        $contentLength = is_array($post) ? self::getPostContentLength($post) : strlen($post);\n\n        $out = \"$method $path$query HTTP/1.1\\r\\n\";\n        $out .= \"Host: $host\\r\\n\";\n        $out .= \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\\r\\n\";\n        if (!empty($cookie)) {\n            $out .= \"Cookie: $cookie\\r\\n\";\n        }\n        if ($method == 'POST') {\n            $out .= \"Content-Type: \" . (is_array($post) ? 'application/x-www-form-urlencoded' : 'application/octet-stream') . \"\\r\\n\";\n            $out .= \"Content-Length: $contentLength\\r\\n\";\n        }\n        $out .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($method == 'POST') {\n            $out .= is_array($post) ? http_build_query($post) : $post;\n        }\n\n        stream_set_blocking($fp, $block);\n        fwrite($fp, $out);\n\n        $response = '';\n        $limitCounter = 0;\n        while (!feof($fp)) {\n            $response .= fread($fp, $limit > 0 ? min(8192, $limit - $limitCounter) : 8192);\n            if ($limit > 0) {\n                $limitCounter += 8192;\n                if ($limitCounter >= $limit) break;\n            }\n        }\n        fclose($fp);\n\n        return $response;\n    }\n\n    private static function getPostContentLength(array $post): int {\n        $content = http_build_query($post);\n        return strlen($content);\n    }\n}\n?>\n"
    ],
    "match_count": 2,
    "pass@3": 0.5333333333333333,
    "pass@5": 0.7777777777777778
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Implement a PHP function that performs HTTP requests using either cURL (if available) or fsockopen as a fallback, supporting both GET and POST methods with various configurations.\n\nFunction Description: The function _dfsockopen performs HTTP requests to a specified URL with support for POST data, cookies, custom headers, file uploads, and timeout settings. It first attempts to use cURL if available, falling back to fsockopen for basic socket communication. The function handles both URL-encoded and multipart form data for POST requests.\n\nInput:\n- $url: (string) The target URL for the HTTP request\n- $limit: (int) Maximum number of bytes to read from response (0 for unlimited)\n- $post: (string|array) POST data to send (either query string or associative array)\n- $cookie: (string) Cookie header string\n- $bysocket: (bool) Force using fsockopen (unused in this implementation)\n- $ip: (string) Specific IP to connect to (bypassing DNS)\n- $timeout: (int) Connection timeout in seconds\n- $block: (bool) Whether to use blocking I/O\n- $encodetype: (string) POST data encoding type ('URLENCODE' or other for multipart)\n- $allowcurl: (bool) Whether to allow cURL usage\n- $position: (int) Unused parameter\n- $files: (array) Associative array of file paths for file uploads\n\nOutput:\n- Returns: (string) The HTTP response body (limited by $limit if specified)\n- Side effect: Sets $GLOBALS['filesockheader'] with response headers\n- Returns empty string on connection failure or non-200 status code (for cURL)",
    "Canonical_solution": "function _dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = FALSE, $ip = '', $timeout = 15, $block = TRUE, $encodetype = 'URLENCODE', $allowcurl = TRUE, $position = 0, $files = array()) {\n    $matches = parse_url($url);\n    $scheme = $matches['scheme'];\n    $host = $matches['host'];\n    $path = $matches['path'] ? $matches['path'].($matches['query'] ? '?'.$matches['query'] : '') : '/';\n    $port = !empty($matches['port']) ? $matches['port'] : ($scheme == 'http' ? '80' : '');\n\n    if($post) {\n        if(!is_array($post)) {\n            parse_str($post, $post);\n        }\n        _format_postkey($post, $postnew);\n        $post = $postnew;\n    }\n\n    if(function_exists('curl_init') && function_exists('curl_exec') && $allowcurl) {\n        $ch = curl_init();\n        $httpheader = array();\n        if($ip) {\n            $httpheader[] = \"Host: \".$host;\n        }\n        curl_setopt($ch, CURLOPT_URL, $scheme.'://'.($ip ? $ip : $host).($port ? ':'.$port : '').$path);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        if($post) {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            if($encodetype == 'URLENCODE') {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n            } else {\n                foreach($post as $k => $v) {\n                    if(isset($files[$k])) {\n                        $post[$k] = '@'.$files[$k];\n                    }\n                }\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n            }\n        }\n        if($cookie) {\n            curl_setopt($ch, CURLOPT_COOKIE, $cookie);\n        }\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);\n        $data = curl_exec($ch);\n        $status = curl_getinfo($ch);\n        curl_close($ch);\n        if($status['http_code'] != 200) {\n            return;\n        } else {\n            $GLOBALS['filesockheader'] = substr($data, 0, $status['header_size']);\n            $data = substr($data, $status['header_size']);\n            return !$limit ? $data : substr($data, 0, $limit);\n        }\n    }\n\n    $boundary = $encodetype == 'URLENCODE' ? '' : random(40);\n    if($post) {\n        if($encodetype == 'URLENCODE') {\n            $data = http_build_query($post);\n        } else {\n            $data = '';\n            foreach($post as $k => $v) {\n                $data .= \"--$boundary\\r\\n\";\n                $data .= 'Content-Disposition: form-data; name=\"'.$k.'\"'.(isset($files[$k]) ? '; filename=\"'.basename($files[$k]).'\"; Content-Type: application/octet-stream' : '').\"\\r\\n\\r\\n\";\n                $data .= $v.\"\\r\\n\";\n            }\n            $data .= \"--$boundary\\r\\n\";\n        }\n        $out = \"POST $path HTTP/1.0\\r\\n\";\n        $header = \"Content-Type: \".($encodetype == 'URLENCODE' ? \"application/x-www-form-urlencoded\" : \"multipart/form-data; boundary=$boundary\").\"\\r\\n\";\n        $header .= 'Content-Length: '.strlen($data).\"\\r\\n\";\n    } else {\n        $out = \"GET $path HTTP/1.0\\r\\n\";\n        $header = \"\";\n    }\n\n    $header .= \"Host: $host:$port\\r\\n\";\n    $header .= \"Connection: Close\\r\\n\";\n    $header .= \"Cookie: $cookie\\r\\n\\r\\n\";\n    $out .= $header;\n    if($post) $out .= $data;\n\n    if(!$fp = @fsocketopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout)) {\n        return '';\n    }\n\n    stream_set_blocking($fp, $block);\n    stream_set_timeout($fp, $timeout);\n    @fwrite($fp, $out);\n\n    $headers = '';\n    while (!feof($fp)) {\n        $header = @fgets($fp);\n        $headers .= $header;\n        if($header && ($header == \"\\r\\n\" || $header == \"\\n\")) {\n            break;\n        }\n    }\n    $GLOBALS['filesockheader'] = $headers;\n\n    $return = $limit ? stream_get_contents($fp, $limit) : stream_get_contents($fp);\n    @fclose($fp);\n    return $return;\n}\n\nfunction _format_postkey($post, &$result, $key = '') {\n    foreach($post as $k => $v) {\n        $_k = $key ? $key.'['.$k.']' : $k;\n        if(is_array($v)) {\n            _format_postkey($v, $result, $_k);\n        } else {\n            $result[$_k] = $v;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 131,
    "matched_results": [
      "<?php\nfunction _dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = false, $ip = '', $timeout = 15, $block = true, $encodetype = 'URLENCODE', $allowcurl = true, $position = 0, $files = array()) {\n    $GLOBALS['filesockheader'] = '';\n    $urlparts = parse_url($url);\n    $host = $urlparts['host'];\n    if (!empty($urlparts['port'])) {\n        $port = $urlparts['port'];\n    } else if ($urlparts['scheme'] == 'https') {\n        $port = 443;\n    } else {\n        $port = 80;\n    }\n    $path = $urlparts['path'] ? $urlparts['path'] . (!empty($urlparts['query']) ? '?' . $urlparts['query'] : '') : '/';\n\n    if ($allowcurl && function_exists('curl_init') && function_exists('curl_exec')) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        if ($post) {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n        }\n        if ($cookie) {\n            curl_setopt($ch, CURLOPT_COOKIE, $cookie);\n        }\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n        if ($ip) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, array(\"Host: $host\"));\n            curl_setopt($ch, CURLOPT_RESOLVE, array(\"$host:$port:$ip\"));\n        }\n        $data = curl_exec($ch);\n        $responseCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($responseCode == 200) {\n            list($header, $body) = explode(\"\\r\\n\\r\\n\", $data, 2);\n            $GLOBALS['filesockheader'] = $header;\n            return $limit ? substr($body, 0, $limit) : $body;\n        }\n        return '';\n    }\n\n    $fp = @fsockopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout);\n    if (!$fp) {\n        return '';\n    }\n    $out = ($post ? \"POST \" : \"GET \") . $path . \" HTTP/1.1\\r\\n\";\n    $out .= \"Host: $host\\r\\n\";\n    $out .= \"Accept-language: zh-cn\\r\\n\";\n    $out .= \"User-Agent: Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\\r\\n\";\n    if ($cookie) {\n        $out .= \"Cookie: $cookie\\r\\n\";\n    }\n    if ($post) {\n        if ($encodetype == 'URLENCODE') {\n            $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $out .= 'Content-Length: ' . strlen($post) . \"\\r\\n\";\n        } else {\n            $boundary = '---------------------------' . substr(md5(mt_rand()), 0, 10);\n            $out .= \"Content-Type: multipart/form-data; boundary=$boundary\\r\\n\";\n\n            $body = '';\n            foreach ($post as $key => $value) {\n                $body .= \"--$boundary\\r\\n\";\n                $body .= \"Content-Disposition: form-data; name=\\\"$key\\\"\\r\\n\\r\\n\";\n                $body .= $value . \"\\r\\n\";\n            }\n\n            foreach ($files as $key => $filepath) {\n                $body .= \"--$boundary\\r\\n\";\n                $body .= \"Content-Disposition: form-data; name=\\\"$key\\\"; filename=\\\"\" . basename($filepath) . \"\\\"\\r\\n\";\n                $body .= \"Content-Type: application/octet-stream\\r\\n\\r\\n\";\n                $body .= file_get_contents($filepath) . \"\\r\\n\";\n            }\n\n            $body .= \"--$boundary--\\r\\n\";\n            $out .= 'Content-Length: ' . strlen($body) . \"\\r\\n\";\n            $post = $body;\n        }\n    }\n    $out .= \"Connection: Close\\r\\n\\r\\n\";\n    if ($post) {\n        $out .= $post;\n    }\n    fwrite($fp, $out);\n    $GLOBALS['filesockheader'] = '';\n    if (!$block) {\n        fclose($fp);\n        return '';\n    }\n    $in = '';\n    while (!feof($fp)) {\n        $in .= fgets($fp, 12800);\n    }\n    fclose($fp);\n    $pos = strpos($in, \"\\r\\n\\r\\n\");\n    $head = substr($in, 0, $pos);\n    $GLOBALS['filesockheader'] = $head;\n    $body = substr($in, $pos + 4);\n    return $limit ? substr($body, 0, $limit) : $body;\n}\n?>\n"
    ],
    "unmatched_results": [
      "<?php\nfunction _dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = false, $ip = '', $timeout = 15, $block = true, $encodetype = 'URLENCODE', $allowcurl = true, $position = 0, $files = array()) {\n    $GLOBALS['filesockheader'] = '';\n    $urlparts = parse_url($url);\n    $host = $urlparts['host'];\n    if (!empty($urlparts['port'])) {\n        $port = $urlparts['port'];\n    } else if ($urlparts['scheme'] == 'https') {\n        $port = 443;\n    } else {\n        $port = 80;\n    }\n    $path = $urlparts['path'] ? $urlparts['path'] . (!empty($urlparts['query']) ? '?' . $urlparts['query'] : '') : '/';\n    if (function_exists('curl_init') && function_exists('curl_exec') && $allowcurl) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n        if ($ip) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, array(\"Host: \" . $host));\n            curl_setopt($ch, CURLOPT_RESOLVE, array($host . \":\" . $port . \":\" . $ip));\n        }\n        if ($post) {\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n        }\n        if ($cookie) {\n            curl_setopt($ch, CURLOPT_COOKIE, $cookie);\n        }\n        $data = curl_exec($ch);\n        $responseCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        if ($responseCode != 200) {\n            return '';\n        }\n        list($header, $data) = explode(\"\\r\\n\\r\\n\", $data, 2);\n        $GLOBALS['filesockheader'] = $header;\n        if ($limit > 0) {\n            $data = substr($data, 0, $limit);\n        }\n        return $data;\n    }\n\n    if ($ip) {\n        $host = $ip;\n    }\n    $fp = @fsockopen(($urlparts['scheme'] == 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, $timeout);\n    if (!$fp) {\n        return '';\n    }\n    stream_set_blocking($fp, $block);\n    stream_set_timeout($fp, $timeout);\n    $out = ($post ? \"POST \" : \"GET \") . $path . \" HTTP/1.1\\r\\n\";\n    $out .= \"Host: $host\\r\\n\";\n    $out .= \"Accept-language: zh-cn\\r\\n\";\n    $out .= \"User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36\\r\\n\";\n    if ($cookie) {\n        $out .= \"Cookie: $cookie\\r\\n\";\n    }\n    if ($post) {\n        if ($encodetype == 'URLENCODE') {\n            $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $out .= 'Content-Length: ' . strlen($post) . \"\\r\\n\";\n        } else {\n            $boundary = '---------------------------' . substr(md5(mt_rand()), 0, 10);\n            $out .= \"Content-Type: multipart/form-data; boundary=$boundary\\r\\n\";\n            $out .= 'Content-Length: ' . _dfsockopen_get_post_length($post, $files, $boundary) . \"\\r\\n\";\n        }\n        $out .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($encodetype == 'URLENCODE') {\n            $out .= $post;\n        } else {\n            $out .= _dfsockopen_build_multipart_data($post, $files, $boundary);\n        }\n    } else {\n        $out .= \"Connection: Close\\r\\n\\r\\n\";\n    }\n    fwrite($fp, $out);\n    $status = stream_get_meta_data($fp);\n    if ($status['timed_out']) {\n        fclose($fp);\n        return '';\n    }\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fread($fp, 8192);\n    }\n    fclose($fp);\n    list($header, $data) = explode(\"\\r\\n\\r\\n\", $response, 2);\n    $GLOBALS['filesockheader'] = $header;\n    if ($limit > 0) {\n        $data = substr($data, 0, $limit);\n    }\n    return $data;\n}\n\nfunction _dfsockopen_get_post_length($post_fields, $files, $boundary) {\n    $content_length = 0;\n    foreach ($post_fields as $name => $value) {\n        $content_length += strlen(\"--$boundary\\r\\n\");\n        $content_length += strlen(\"Content-Disposition: form-data; name=\\\"$name\\\"\\r\\n\\r\\n\");\n        $content_length += strlen($value) + 2;\n    }\n    foreach ($files as $name => $file) {\n        $content_length += strlen(\"--$boundary\\r\\n\");\n        $content_length += strlen(\"Content-Disposition: form-data; name=\\\"$name\\\"; filename=\\\"\" . basename($file) . \"\\\"\\r\\n\");\n        $content_length += strlen(\"Content-Type: application/octet-stream\\r\\n\\r\\n\");\n        $content_length += filesize($file) + 2;\n    }\n    $content_length += strlen(\"--$boundary--\\r\\n\");\n    return $content_length;\n}\n\nfunction _dfsockopen_build_multipart_data($post_fields, $files, $boundary) {\n    $data = '';\n    foreach ($post_fields as $name => $value) {\n        $data .= \"--$boundary\\r\\n\";\n        $data .= \"Content-Disposition: form-data; name=\\\"$name\\\"\\r\\n\\r\\n\";\n        $data .= $value . \"\\r\\n\";\n    }\n    foreach ($files as $name => $file) {\n        $data .= \"--$boundary\\r\\n\";\n        $data .= \"Content-Disposition: form-data; name=\\\"$name\\\"; filename=\\\"\" . basename($file) . \"\\\"\\r\\n\";\n        $data .= \"Content-Type: application/octet-stream\\r\\n\\r\\n\";\n        $data .= file_get_contents($file) . \"\\r\\n\";\n    }\n    $data .= \"--$boundary--\\r\\n\";\n    return $data;\n}\n?>\n",
      "<?php\nfunction _dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = false, $ip = '', $timeout = 15, $block = true, $encodetype = 'URLENCODE', $allowcurl = true, $position = 0, $files = array()) {\n    $GLOBALS['filesockheader'] = '';\n    $urlparts = parse_url($url);\n    $host = $urlparts['host'];\n    if (!isset($urlparts['port'])) {\n        $urlparts['port'] = ($urlparts['scheme'] == 'https' ? 443 : 80);\n    }\n    $path = isset($urlparts['path']) ? $urlparts['path'] : '/';\n    if (isset($urlparts['query'])) {\n        $path .= '?' . $urlparts['query'];\n    }\n\n    if ($allowcurl && function_exists('curl_init')) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n        if ($ip) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, array(\"Host: \" . $host));\n            curl_setopt($ch, CURLOPT_RESOLVE, array($host . \":\" . $urlparts['port'] . \":\" . $ip));\n        }\n        if ($post) {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n        }\n        if ($cookie) {\n            curl_setopt($ch, CURLOPT_COOKIE, $cookie);\n        }\n        $data = curl_exec($ch);\n        $responseCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($responseCode == 200) {\n            list($header, $body) = explode(\"\\r\\n\\r\\n\", $data, 2);\n            $GLOBALS['filesockheader'] = $header;\n            return ($limit > 0) ? substr($body, 0, $limit) : $body;\n        }\n        return '';\n    }\n\n    if ($ip) {\n        $host = $ip;\n    }\n    $fp = @fsockopen(($urlparts['scheme'] == 'https' ? 'ssl://' : '') . $host, $urlparts['port'], $errno, $errstr, $timeout);\n    if (!$fp) {\n        return '';\n    }\n    stream_set_blocking($fp, $block);\n    $out = ($post ? \"POST \" : \"GET \") . $path . \" HTTP/1.1\\r\\n\";\n    $out .= \"Host: \" . $host . \"\\r\\n\";\n    $out .= \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\\r\\n\";\n    if ($cookie) {\n        $out .= \"Cookie: \" . $cookie . \"\\r\\n\";\n    }\n    if ($post) {\n        if ($encodetype == 'URLENCODE') {\n            $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $out .= \"Content-Length: \" . strlen($post) . \"\\r\\n\";\n        } else {\n            $boundary = '---------------------------' . substr(md5(mt_rand()), 0, 10);\n            $out .= \"Content-Type: multipart/form-data; boundary=\" . $boundary . \"\\r\\n\";\n\n            $post_data = '';\n            foreach ($post as $key => $value) {\n                $post_data .= \"--\" . $boundary . \"\\r\\n\";\n                $post_data .= \"Content-Disposition: form-data; name=\\\"\" . $key . \"\\\"\\r\\n\\r\\n\";\n                $post_data .= $value . \"\\r\\n\";\n            }\n            foreach ($files as $key => $filepath) {\n                $filename = basename($filepath);\n                $file_contents = file_get_contents($filepath);\n                $post_data .= \"--\" . $boundary . \"\\r\\n\";\n                $post_data .= \"Content-Disposition: form-data; name=\\\"\" . $key . \"\\\"; filename=\\\"\" . $filename . \"\\\"\\r\\n\";\n                $post_data .= \"Content-Type: application/octet-stream\\r\\n\\r\\n\";\n                $post_data .= $file_contents . \"\\r\\n\";\n            }\n\n            $post_data .= \"--\" . $boundary . \"--\\r\\n\";\n            $out .= \"Content-Length: \" . strlen($post_data) . \"\\r\\n\";\n            $post = $post_data;\n        }\n    }\n    $out .= \"Connection: Close\\r\\n\\r\\n\";\n    $out .= $post;\n    fwrite($fp, $out);\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fread($fp, 8192);\n    }\n    fclose($fp);\n    list($header, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n    $GLOBALS['filesockheader'] = $header;\n    return ($limit > 0) ? substr($body, 0, $limit) : $body;\n}\n?>\n",
      "<?php\nfunction _dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = false, $ip = '', $timeout = 15, $block = true, $encodetype = 'URLENCODE', $allowcurl = true, $position = 0, $files = array()) {\n    $GLOBALS['filesockheader'] = '';\n    $urlparts = parse_url($url);\n    $host = $urlparts['host'];\n    if (!empty($urlparts['port'])) {\n        $port = $urlparts['port'];\n    } else if ($urlparts['scheme'] == 'https') {\n        $port = 443;\n    } else {\n        $port = 80;\n    }\n    $path = !empty($urlparts['path']) ? $urlparts['path'] : '/';\n    if (!empty($urlparts['query'])) {\n        $path .= '?' . $urlparts['query'];\n    }\n\n    if ($allowcurl && function_exists('curl_init') && function_exists('curl_exec')) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n        if ($ip) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, array(\"Host: \" . $host));\n            curl_setopt($ch, CURLOPT_RESOLVE, array($host . \":\" . $port . \":\" . $ip));\n        }\n        if ($post) {\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n        }\n        if ($cookie) {\n            curl_setopt($ch, CURLOPT_COOKIE, $cookie);\n        }\n        if ($urlparts['scheme'] == 'https') {\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        $response = curl_exec($ch);\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $GLOBALS['filesockheader'] = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        if ($httpCode == 200) {\n            return $limit > 0 && strlen($body) > $limit ? substr($body, 0, $limit) : $body;\n        } else {\n            return '';\n        }\n    }\n\n    $fp = @fsockopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout);\n    if (!$fp) {\n        return '';\n    }\n    $out = ($post ? \"POST \" : \"GET \") . $path . \" HTTP/1.1\\r\\n\";\n    $out .= \"Host: $host\\r\\n\";\n    $out .= \"Cookie: $cookie\\r\\n\";\n    if ($post) {\n        if ($encodetype == 'URLENCODE') {\n            $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        } else {\n            $boundary = '---------------------------' . substr(md5(mt_rand()), 0, 10);\n            $out .= \"Content-Type: multipart/form-data; boundary=$boundary\\r\\n\";\n            $post_data = '';\n            foreach ($post as $key => $value) {\n                $post_data .= \"--$boundary\\r\\n\";\n                $post_data .= \"Content-Disposition: form-data; name=\\\"$key\\\"\\r\\n\\r\\n\";\n                $post_data .= \"$value\\r\\n\";\n            }\n            foreach ($files as $key => $filepath) {\n                $filename = basename($filepath);\n                $filedata = file_get_contents($filepath);\n                $post_data .= \"--$boundary\\r\\n\";\n                $post_data .= \"Content-Disposition: form-data; name=\\\"$key\\\"; filename=\\\"$filename\\\"\\r\\n\";\n                $post_data .= \"Content-Type: application/octet-stream\\r\\n\\r\\n\";\n                $post_data .= \"$filedata\\r\\n\";\n            }\n            $post_data .= \"--$boundary--\\r\\n\";\n            $post = $post_data;\n        }\n        $out .= \"Content-Length: \" . strlen($post) . \"\\r\\n\";\n    }\n    $out .= \"Connection: Close\\r\\n\\r\\n\";\n    $out .= $post;\n\n    stream_set_blocking($fp, $block);\n    fwrite($fp, $out);\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fread($fp, 8192);\n    }\n    fclose($fp);\n\n    $pos = strpos($response, \"\\r\\n\\r\\n\");\n    $GLOBALS['filesockheader'] = substr($response, 0, $pos);\n    $body = substr($response, $pos + 4);\n    return $limit > 0 && strlen($body) > $limit ? substr($body, 0, $limit) : $body;\n}\n?>\n",
      "<?php\nfunction _dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = false, $ip = '', $timeout = 15, $block = true, $encodetype = 'URLENCODE', $allowcurl = true, $position = 0, $files = array()) {\n    $GLOBALS['filesockheader'] = '';\n    $urlparts = parse_url($url);\n    $host = $urlparts['host'];\n    if (!empty($urlparts['port'])) {\n        $port = $urlparts['port'];\n    } else if ($urlparts['scheme'] == 'https') {\n        $port = 443;\n    } else {\n        $port = 80;\n    }\n    $path = $urlparts['path'] ? $urlparts['path'] . (!empty($urlparts['query']) ? '?' . $urlparts['query'] : '') : '/';\n    if (!empty($ip)) {\n        $host = $ip;\n    }\n\n    if ($allowcurl && function_exists('curl_init')) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n        if (!empty($post)) {\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n        }\n        if (!empty($cookie)) {\n            curl_setopt($ch, CURLOPT_COOKIE, $cookie);\n        }\n        if ($urlparts['scheme'] == 'https') {\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        $response = curl_exec($ch);\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $GLOBALS['filesockheader'] = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($httpCode == 200) {\n            return $limit > 0 && strlen($body) > $limit ? substr($body, 0, $limit) : $body;\n        } else {\n            return '';\n        }\n    }\n\n    $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n    if (!$fp) {\n        return '';\n    }\n    $out = ($post ? \"POST \" : \"GET \") . $path . \" HTTP/1.1\\r\\n\";\n    $out .= \"Host: $host\\r\\n\";\n    $out .= \"Cookie: $cookie\\r\\n\";\n    if ($post) {\n        $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $out .= \"Content-Length: \" . strlen($post) . \"\\r\\n\";\n    }\n    $out .= \"Connection: Close\\r\\n\\r\\n\";\n    $out .= $post;\n\n    fwrite($fp, $out);\n    stream_set_blocking($fp, $block);\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fread($fp, 8192);\n    }\n    fclose($fp);\n\n    $pos = strpos($response, \"\\r\\n\\r\\n\");\n    $GLOBALS['filesockheader'] = substr($response, 0, $pos);\n    $body = substr($response, $pos + 4);\n\n    return $limit > 0 && strlen($body) > $limit ? substr($body, 0, $limit) : $body;\n}\n?>\n",
      "<?php\nfunction _dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = false, $ip = '', $timeout = 15, $block = true, $encodetype = 'URLENCODE', $allowcurl = true, $position = 0, $files = array()) {\n    $GLOBALS['filesockheader'] = '';\n    $urlparts = parse_url($url);\n    $host = $urlparts['host'];\n    if (!empty($urlparts['port'])) {\n        $port = $urlparts['port'];\n    } else if ($urlparts['scheme'] == 'https') {\n        $port = 443;\n    } else {\n        $port = 80;\n    }\n    $path = !empty($urlparts['path']) ? $urlparts['path'] : '/';\n    if (!empty($urlparts['query'])) {\n        $path .= '?' . $urlparts['query'];\n    }\n    if (!empty($ip)) {\n        $host = $ip;\n    }\n\n    if (function_exists('curl_init') && $allowcurl) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n        if ($post) {\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n        }\n        if ($cookie) {\n            curl_setopt($ch, CURLOPT_COOKIE, $cookie);\n        }\n        if ($urlparts['scheme'] == 'https') {\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        $response = curl_exec($ch);\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $GLOBALS['filesockheader'] = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($httpCode != 200) {\n            return '';\n        }\n        if ($limit > 0) {\n            $body = substr($body, 0, $limit);\n        }\n        return $body;\n    }\n\n    $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n    if (!$fp) {\n        return '';\n    }\n    $out = ($post ? \"POST \" : \"GET \") . $path . \" HTTP/1.1\\r\\n\";\n    $out .= \"Host: $host\\r\\n\";\n    $out .= \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\\r\\n\";\n    if ($cookie) {\n        $out .= \"Cookie: $cookie\\r\\n\";\n    }\n    if ($post) {\n        if (is_array($post)) {\n            $post = http_build_query($post);\n        }\n        $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $out .= \"Content-Length: \" . strlen($post) . \"\\r\\n\";\n    }\n    $out .= \"Connection: Close\\r\\n\\r\\n\";\n    $out .= $post;\n\n    fwrite($fp, $out);\n    stream_set_blocking($fp, $block);\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fread($fp, 8192);\n    }\n    fclose($fp);\n\n    $pos = strpos($response, \"\\r\\n\\r\\n\");\n    $GLOBALS['filesockheader'] = substr($response, 0, $pos);\n    $body = substr($response, $pos + 4);\n\n    if ($limit > 0) {\n        $body = substr($body, 0, $limit);\n    }\n    return $body;\n}\n?>\n",
      "<?php\nfunction _dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = false, $ip = '', $timeout = 15, $block = true, $encodetype = 'URLENCODE', $allowcurl = true, $position = 0, $files = array()) {\n    $GLOBALS['filesockheader'] = '';\n    $urlparts = parse_url($url);\n    $host = $urlparts['host'];\n    if (!empty($urlparts['port'])) {\n        $port = $urlparts['port'];\n    } else if ($urlparts['scheme'] == 'https') {\n        $port = 443;\n    } else {\n        $port = 80;\n    }\n    $path = $urlparts['path'] ? $urlparts['path'] . (!empty($urlparts['query']) ? '?' . $urlparts['query'] : '') : '/';\n    if (function_exists('curl_init') && function_exists('curl_exec') && $allowcurl) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n        if ($ip) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, array(\"Host: \" . $host));\n            curl_setopt($ch, CURLOPT_RESOLVE, array($host . \":\" . $port . \":\" . $ip));\n        }\n        if ($post) {\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n        }\n        if ($cookie) {\n            curl_setopt($ch, CURLOPT_COOKIE, $cookie);\n        }\n        if ($urlparts['scheme'] == 'https') {\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        $data = curl_exec($ch);\n        $responseCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if ($responseCode != 200 || $data === false) {\n            return '';\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $GLOBALS['filesockheader'] = substr($data, 0, $headerSize);\n        $body = substr($data, $headerSize);\n        curl_close($ch);\n        return $limit > 0 && strlen($body) > $limit ? substr($body, 0, $limit) : $body;\n    }\n\n    $fp = @fsockopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout);\n    if (!$fp) {\n        return '';\n    }\n    $out = ($post ? \"POST \" : \"GET \") . $path . \" HTTP/1.1\\r\\n\";\n    $out .= \"Host: $host\\r\\n\";\n    $out .= \"Cookie: $cookie\\r\\n\";\n    if ($post) {\n        if (is_array($post)) {\n            $post = http_build_query($post);\n        }\n        $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $out .= \"Content-Length: \" . strlen($post) . \"\\r\\n\";\n    }\n    $out .= \"Connection: Close\\r\\n\\r\\n\";\n    $out .= $post;\n    fwrite($fp, $out);\n    stream_set_blocking($fp, $block);\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fread($fp, 8192);\n    }\n    fclose($fp);\n    $pos = strpos($response, \"\\r\\n\\r\\n\");\n    $GLOBALS['filesockheader'] = substr($response, 0, $pos);\n    $body = substr($response, $pos + 4);\n    return $limit > 0 && strlen($body) > $limit ? substr($body, 0, $limit) : $body;\n}\n\n?>\n",
      "<?php\nfunction _dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = false, $ip = '', $timeout = 15, $block = true, $encodetype = 'URLENCODE', $allowcurl = true, $position = 0, $files = array()) {\n    $GLOBALS['filesockheader'] = '';\n    $urlparts = parse_url($url);\n    $host = $urlparts['host'];\n    if (!empty($urlparts['port'])) {\n        $port = $urlparts['port'];\n    } else if ($urlparts['scheme'] == 'https') {\n        $port = 443;\n    } else {\n        $port = 80;\n    }\n    $path = !empty($urlparts['path']) ? $urlparts['path'] : '/';\n    if (!empty($urlparts['query'])) {\n        $path .= '?' . $urlparts['query'];\n    }\n\n    if ($allowcurl && function_exists('curl_init') && function_exists('curl_exec')) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        if ($post) {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n        }\n        if ($cookie) {\n            curl_setopt($ch, CURLOPT_COOKIE, $cookie);\n        }\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n        if ($urlparts['scheme'] == 'https') {\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        $data = curl_exec($ch);\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $GLOBALS['filesockheader'] = substr($data, 0, $header_size);\n        $body = substr($data, $header_size);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        if ($http_code == 200) {\n            return $limit > 0 ? substr($body, 0, $limit) : $body;\n        } else {\n            return '';\n        }\n\n    } else {\n        if ($ip) {\n            $host = $ip;\n        }\n        $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n        if (!$fp) {\n            return '';\n        }\n        $out = ($post ? \"POST \" : \"GET \") . $path . \" HTTP/1.1\\r\\n\";\n        $out .= \"Host: $host\\r\\n\";\n        $out .= \"Cookie: $cookie\\r\\n\";\n        if ($post) {\n            if (is_array($post)) {\n                $post = http_build_query($post);\n            }\n            $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n            $out .= \"Content-Length: \" . strlen($post) . \"\\r\\n\";\n        }\n        $out .= \"Connection: Close\\r\\n\\r\\n\";\n        if ($post) {\n            $out .= $post;\n        }\n        fwrite($fp, $out);\n        stream_set_blocking($fp, $block);\n        $response = '';\n        while (!feof($fp)) {\n            $response .= fread($fp, 8192);\n        }\n        fclose($fp);\n\n        $pos = strpos($response, \"\\r\\n\\r\\n\");\n        $GLOBALS['filesockheader'] = substr($response, 0, $pos);\n        $body = substr($response, $pos + 4);\n        return $limit > 0 ? substr($body, 0, $limit) : $body;\n    }\n}\n?>\n",
      "<?php\nfunction _dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = false, $ip = '', $timeout = 15, $block = true, $encodetype = 'URLENCODE', $allowcurl = true, $position = 0, $files = array()) {\n    $GLOBALS['filesockheader'] = '';\n    $urlparts = parse_url($url);\n    $host = $urlparts['host'];\n    if (!empty($urlparts['port'])) {\n        $port = $urlparts['port'];\n    } else if ($urlparts['scheme'] == 'https') {\n        $port = 443;\n    } else {\n        $port = 80;\n    }\n    $path = !empty($urlparts['path']) ? $urlparts['path'] : '/';\n    if (!empty($urlparts['query'])) {\n        $path .= '?' . $urlparts['query'];\n    }\n\n    if ($allowcurl && function_exists('curl_init') && function_exists('curl_exec')) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n        if ($ip) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, array(\"Host: \" . $host));\n            curl_setopt($ch, CURLOPT_RESOLVE, array(\"$host:$port:$ip\"));\n        }\n\n        if ($post) {\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n        }\n\n        if ($cookie) {\n            curl_setopt($ch, CURLOPT_COOKIE, $cookie);\n        }\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            return '';\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $GLOBALS['filesockheader'] = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n\n        if (curl_getinfo($ch, CURLINFO_HTTP_CODE) != 200) {\n            return '';\n        }\n\n        curl_close($ch);\n        return $limit > 0 && strlen($body) > $limit ? substr($body, 0, $limit) : $body;\n    }\n\n    $fp = @fsockopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout);\n    if (!$fp) {\n        return '';\n    }\n    $out = ($post ? \"POST \" : \"GET \") . $path . \" HTTP/1.1\\r\\n\";\n    $out .= \"Host: $host\\r\\n\";\n    $out .= \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\\r\\n\";\n    if ($cookie) {\n        $out .= \"Cookie: $cookie\\r\\n\";\n    }\n    if ($post) {\n        if (is_array($post)) {\n            $post = http_build_query($post);\n        }\n        $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $out .= \"Content-Length: \" . strlen($post) . \"\\r\\n\";\n    }\n    $out .= \"Connection: Close\\r\\n\\r\\n\";\n    if ($post) {\n        $out .= $post;\n    }\n    fwrite($fp, $out);\n    stream_set_blocking($fp, $block);\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fread($fp, 8192);\n    }\n    fclose($fp);\n\n    $pos = strpos($response, \"\\r\\n\\r\\n\");\n    $GLOBALS['filesockheader'] = substr($response, 0, $pos);\n    $body = substr($response, $pos + 4);\n    return $limit > 0 && strlen($body) > $limit ? substr($body, 0, $limit) : $body;\n}\n\n?>\n",
      "<?php\nfunction _dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = false, $ip = '', $timeout = 15, $block = true, $encodetype = 'URLENCODE', $allowcurl = true, $position = 0, $files = array()) {\n    $GLOBALS['filesockheader'] = '';\n    $urlparts = parse_url($url);\n    $host = $urlparts['host'];\n    if (!empty($urlparts['port'])) {\n        $port = $urlparts['port'];\n    } else if ($urlparts['scheme'] == 'https') {\n        $port = 443;\n    } else {\n        $port = 80;\n    }\n    $path = $urlparts['path'] ? $urlparts['path'] . (!empty($urlparts['query']) ? '?' . $urlparts['query'] : '') : '/';\n    if (!empty($ip)) {\n        $host = $ip;\n    }\n\n    if ($allowcurl && function_exists('curl_init') && function_exists('curl_exec')) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        if ($post) {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post);\n        }\n        if ($cookie) {\n            curl_setopt($ch, CURLOPT_COOKIE, $cookie);\n        }\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n        if ($urlparts['scheme'] == 'https') {\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        }\n        $data = curl_exec($ch);\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $GLOBALS['filesockheader'] = substr($data, 0, $headerSize);\n        $body = substr($data, $headerSize);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return $limit > 0 ? substr($body, 0, $limit) : $body;\n        } else {\n            return '';\n        }\n    }\n\n    $fp = @fsockopen(($urlparts['scheme'] == 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, $timeout);\n    if (!$fp) {\n        return '';\n    }\n    $out = ($post ? \"POST \" : \"GET \") . $path . \" HTTP/1.1\\r\\n\";\n    $out .= \"Host: $host\\r\\n\";\n    $out .= \"Cookie: $cookie\\r\\n\";\n    if ($post) {\n        if ($encodetype == 'URLENCODE') {\n            $out .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        } else {\n            $boundary = '---------------------------' . substr(md5(mt_rand()), 0, 10);\n            $out .= \"Content-Type: multipart/form-data; boundary=$boundary\\r\\n\";\n            $post_string = '';\n            foreach ($post as $key => $value) {\n                $post_string .= \"--$boundary\\r\\n\";\n                $post_string .= \"Content-Disposition: form-data; name=\\\"$key\\\"\\r\\n\\r\\n\";\n                $post_string .= \"$value\\r\\n\";\n            }\n            foreach ($files as $key => $filepath) {\n                $basename = basename($filepath);\n                $post_string .= \"--$boundary\\r\\n\";\n                $post_string .= \"Content-Disposition: form-data; name=\\\"$key\\\"; filename=\\\"$basename\\\"\\r\\n\";\n                $post_string .= \"Content-Type: application/octet-stream\\r\\n\\r\\n\";\n                $post_string .= file_get_contents($filepath) . \"\\r\\n\";\n            }\n            $post_string .= \"--$boundary--\\r\\n\";\n            $post = $post_string;\n        }\n        $out .= \"Content-Length: \" . strlen($post) . \"\\r\\n\";\n    }\n    $out .= \"Connection: Close\\r\\n\\r\\n\";\n    $out .= $post;\n    stream_set_blocking($fp, $block);\n    fwrite($fp, $out);\n    $status = stream_get_meta_data($fp);\n    if ($status['timed_out']) {\n        fclose($fp);\n        return '';\n    }\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fread($fp, 8192);\n    }\n    fclose($fp);\n    $pos = strpos($response, \"\\r\\n\\r\\n\");\n    $GLOBALS['filesockheader'] = substr($response, 0, $pos);\n    $body = substr($response, $pos + 4);\n    return $limit > 0 ? substr($body, 0, $limit) : $body;\n}\n?>\n"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client using low-level socket operations (fsockopen) to send HTTP requests and handle responses, with logging capabilities.\n\nClass Description: SocketHttpClient is a PSR-compatible HTTP client that establishes direct socket connections to HTTP servers, sends requests, and processes responses. It implements both a custom HTTP client interface and PSR-18's ClientInterface, while also supporting PSR-3 logging.\n\nAttributes:\n- logger: [LoggerInterface] - PSR-3 logger instance for tracking connection attempts, errors, and debug information\n\nMethods:\n- __construct([LoggerInterface $logger]) -> [void] - Initializes the client with a PSR-3 logger instance\n- sendRequest([RequestInterface $request]) -> [ResponseInterface] - Sends an HTTP request and returns the response. Handles both HTTP and HTTPS connections, processes headers and body, and manages socket lifecycle. Returns a PSR-7 response object.",
    "Canonical_solution": "use Mpdf\\Log\\Context as LogContext;\nuse Mpdf\\PsrHttpMessageShim\\Response;\nuse Mpdf\\PsrHttpMessageShim\\Stream;\nuse Mpdf\\PsrLogAwareTrait\\PsrLogAwareTrait;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass SocketHttpClient implements \\Mpdf\\Http\\ClientInterface, \\Psr\\Log\\LoggerAwareInterface\n{\n    use PsrLogAwareTrait;\n\n    public function __construct(LoggerInterface $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function sendRequest(RequestInterface $request)\n    {\n        if (null === $request->getUri()) {\n            return (new Response());\n        }\n\n        $url = $request->getUri();\n\n        if (is_string($url)) {\n            $url = new Uri($url);\n        }\n\n        $timeout = 1;\n\n        $file = $url->getPath() ?: '/';\n        $scheme = $url->getScheme();\n        $port = $url->getPort() ?: 80;\n        $prefix = '';\n\n        if ($scheme === 'https') {\n            $prefix = 'ssl://';\n            $port = $url->getPort() ?: 443;\n        }\n\n        $query = $url->getQuery();\n        if ($query) {\n            $file .= '?' . $query;\n        }\n\n        $socketPath = $prefix . $url->getHost();\n\n        $this->logger->debug(sprintf('Opening socket on %s:%s of URL \"%s\"', $socketPath, $port, $request->getUri()), ['context' => LogContext::REMOTE_CONTENT]);\n\n        $response = new Response();\n\n        if (!($fh = @fsockopen($socketPath, $port, $errno, $errstr, $timeout))) {\n            $this->logger->error(sprintf('Socket error \"%s\": \"%s\"', $errno, $errstr), ['context' => LogContext::REMOTE_CONTENT]);\n            return $response;\n        }\n\n        $getRequest = 'GET ' . $file . ' HTTP/1.1' . \"\\r\\n\" .\n            'Host: ' . $url->getHost() . \" \\r\\n\" .\n            'Connection: close' . \"\\r\\n\\r\\n\";\n\n        fwrite($fh, $getRequest);\n\n        $httpHeader = fgets($fh, 1024);\n        if (!$httpHeader) {\n            return $response;\n        }\n\n        preg_match('@HTTP/(?P<protocolVersion>[\\d\\.]+) (?P<httpStatusCode>[\\d]+) .*@', $httpHeader, $parsedHeader);\n\n        if (!$parsedHeader) {\n            return $response;\n        }\n\n        $response = $response->withStatus($parsedHeader['httpStatusCode']);\n\n        while (!feof($fh)) {\n            $s = fgets($fh, 1024);\n            if ($s === \"\\r\\n\") {\n                break;\n            }\n            preg_match('/^(?P<headerName>.*?): ?(?P<headerValue>.*)$/', $s, $parsedHeader);\n            if (!$parsedHeader) {\n                continue;\n            }\n            $response = $response->withHeader($parsedHeader['headerName'], trim($parsedHeader['headerValue']));\n        }\n\n        $body = '';\n\n        while (!feof($fh)) {\n            $line = fgets($fh, 1024);\n            $body .= $line;\n        }\n\n        fclose($fh);\n\n        $stream = Stream::create($body);\n        $stream->rewind();\n\n        return $response\n            ->withBody($stream);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 131,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\NullLogger;\n\nclass SocketHttpClient implements ClientInterface\n{\n    private LoggerInterface $logger;\n    private ResponseFactoryInterface $responseFactory;\n    private StreamFactoryInterface $streamFactory;\n\n    public function __construct(\n        ResponseFactoryInterface $responseFactory,\n        StreamFactoryInterface $streamFactory,\n        ?LoggerInterface $logger = null\n    ) {\n        $this->logger = $logger ?? new NullLogger();\n        $this->responseFactory = $responseFactory;\n        $this->streamFactory = $streamFactory;\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $scheme = $uri->getScheme();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($scheme === 'https' ? 443 : 80);\n        $path = $uri->getPath() ?: '/';\n        $query = $uri->getQuery();\n        if ($query) {\n            $path .= '?' . $query;\n        }\n\n        $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n        if (!$fp) {\n            $this->logger->error(\"Connection failed: {$errstr} ({$errno})\");\n            throw new \\RuntimeException(\"Connection failed: {$errstr} ({$errno})\");\n        }\n\n        $method = $request->getMethod();\n        $headers = $request->getHeaders();\n        $body = $request->getBody();\n\n        $requestString = \"{$method} {$path} HTTP/1.1\\r\\n\";\n        $requestString .= \"Host: {$host}\\r\\n\";\n        foreach ($headers as $name => $values) {\n            $requestString .= \"{$name}: \" . implode(', ', $values) . \"\\r\\n\";\n        }\n        $requestString .= \"Content-Length: \" . $body->getSize() . \"\\r\\n\";\n        $requestString .= \"\\r\\n\";\n        $requestString .= $body->getContents();\n\n\n        fwrite($fp, $requestString);\n\n        $responseString = '';\n        while (!feof($fp)) {\n            $responseString .= fread($fp, 8192);\n        }\n        fclose($fp);\n\n        $parts = explode(\"\\r\\n\\r\\n\", $responseString, 2);\n        $headerString = $parts[0];\n        $bodyString = $parts[1] ?? '';\n\n        $headers = [];\n        $lines = explode(\"\\r\\n\", $headerString);\n        $statusLine = array_shift($lines);\n        preg_match('/HTTP\\/\\d\\.\\d (\\d+) (.+)/', $statusLine, $matches);\n        $statusCode = (int)$matches[1];\n        $reasonPhrase = $matches[2];\n\n        foreach ($lines as $line) {\n            [$name, $value] = explode(':', $line, 2);\n            $headers[trim($name)][] = trim($value);\n        }\n\n        $response = $this->responseFactory->createResponse($statusCode, $reasonPhrase);\n        foreach ($headers as $name => $values) {\n            $response = $response->withHeader($name, $values);\n        }\n        $response = $response->withBody($this->streamFactory->createStream($bodyString));\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\NullLogger;\n\nclass SocketHttpClient implements ClientInterface\n{\n    private LoggerInterface $logger;\n    private ResponseFactoryInterface $responseFactory;\n    private StreamFactoryInterface $streamFactory;\n\n    public function __construct(\n        ResponseFactoryInterface $responseFactory,\n        StreamFactoryInterface $streamFactory,\n        ?LoggerInterface $logger = null\n    ) {\n        $this->logger = $logger ?? new NullLogger();\n        $this->responseFactory = $responseFactory;\n        $this->streamFactory = $streamFactory;\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $scheme = $uri->getScheme();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($scheme === 'https' ? 443 : 80);\n        $path = $uri->getPath() ?: '/';\n        $query = $uri->getQuery();\n        if ($query) {\n            $path .= '?' . $query;\n        }\n\n        $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 10);\n        if (!$fp) {\n            $this->logger->error(\"Connection failed: {$errstr} ({$errno})\");\n            throw new \\RuntimeException(\"Connection failed: {$errstr} ({$errno})\");\n        }\n\n        $method = $request->getMethod();\n        $headers = $request->getHeaders();\n        $body = $request->getBody()->getContents();\n\n        $requestString = \"{$method} {$path} HTTP/1.1\\r\\n\";\n        $requestString .= \"Host: {$host}\\r\\n\";\n        foreach ($headers as $name => $values) {\n            $requestString .= \"{$name}: \" . implode(', ', $values) . \"\\r\\n\";\n        }\n        $requestString .= \"Content-Length: \" . strlen($body) . \"\\r\\n\";\n        $requestString .= \"\\r\\n\";\n        $requestString .= $body;\n\n        fwrite($fp, $requestString);\n\n        $responseString = '';\n        while (!feof($fp)) {\n            $responseString .= fread($fp, 8192);\n        }\n        fclose($fp);\n\n        $parts = explode(\"\\r\\n\\r\\n\", $responseString, 2);\n        $headerString = $parts[0];\n        $body = isset($parts[1]) ? $parts[1] : '';\n\n        $headers = [];\n        $lines = explode(\"\\r\\n\", $headerString);\n        $statusLine = array_shift($lines);\n        preg_match('/^HTTP\\/\\d\\.\\d (\\d{3}) (.*)$/', $statusLine, $matches);\n        $statusCode = (int)$matches[1];\n        $reasonPhrase = $matches[2];\n\n        foreach ($lines as $line) {\n            [$name, $value] = explode(':', $line, 2);\n            $headers[trim($name)][] = trim($value);\n        }\n\n        $response = $this->responseFactory->createResponse($statusCode, $reasonPhrase);\n        foreach ($headers as $name => $values) {\n            $response = $response->withHeader($name, $values);\n        }\n        $response = $response->withBody($this->streamFactory->createStream($body));\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\NullLogger;\n\nclass SocketHttpClient implements ClientInterface\n{\n    private LoggerInterface $logger;\n    private ResponseFactoryInterface $responseFactory;\n\n    public function __construct(?LoggerInterface $logger = null, ?ResponseFactoryInterface $responseFactory = null)\n    {\n        $this->logger = $logger ?? new NullLogger();\n        $this->responseFactory = $responseFactory ?? new class implements ResponseFactoryInterface {\n            public function createResponse(int $code = 200, string $reasonPhrase = ''): ResponseInterface\n            {\n                return new class($code, $reasonPhrase) implements ResponseInterface {\n                    private int $statusCode;\n                    private string $reasonPhrase;\n                    private array $headers = [];\n                    private string $body = '';\n\n                    public function __construct(int $code, string $reasonPhrase) {\n                        $this->statusCode = $code;\n                        $this->reasonPhrase = $reasonPhrase;\n                    }\n\n                    public function getProtocolVersion() { return '1.1'; }\n                    public function withProtocolVersion($version) { return $this; }\n                    public function getHeaders() { return $this->headers; }\n                    public function hasHeader($name) { return isset($this->headers[$name]); }\n                    public function getHeader($name) { return $this->headers[$name] ?? []; }\n                    public function getHeaderLine($name) { return implode(', ', $this->getHeader($name)); }\n                    public function withHeader($name, $value) { $clone = clone $this; $clone->headers[$name] = $value; return $clone;}\n                    public function withAddedHeader($name, $value) { $clone = clone $this; $clone->headers[$name] = array_merge($clone->headers[$name] ?? [], (array)$value); return $clone;}\n                    public function withoutHeader($name) { $clone = clone $this; unset($clone->headers[$name]); return $clone;}\n                    public function getBody() { return \\GuzzleHttp\\Psr7\\Utils::streamFor($this->body); }\n                    public function withBody(\\Psr\\Http\\Message\\StreamInterface $body) { $clone = clone $this; $clone->body = (string)$body; return $clone;}\n                    public function getStatusCode() { return $this->statusCode; }\n                    public function withStatus($code, $reasonPhrase = '') { $clone = clone $this; $clone->statusCode = $code; $clone->reasonPhrase = $reasonPhrase; return $clone;}\n                    public function getReasonPhrase() { return $this->reasonPhrase; }\n                };\n            }\n        };\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($uri->getScheme() === 'https' ? 443 : 80);\n        $ssl = $uri->getScheme() === 'https' ? 'ssl://' : '';\n\n        $fp = @fsockopen($ssl . $host, $port, $errno, $errstr, 10);\n\n        if (!$fp) {\n            $this->logger->error(\"Connection failed: {$errstr} ({$errno})\");\n            throw new \\RuntimeException(\"Connection failed: {$errstr} ({$errno})\");\n        }\n\n        $headers = $request->getHeaders();\n        $headers['Host'] = [$host];\n        $headers['Connection'] = ['close'];\n\n        $requestString = \"{$request->getMethod()} {$uri->getPath()} HTTP/{$request->getProtocolVersion()}\\r\\n\";\n        foreach ($headers as $name => $values) {\n            $requestString .= \"{$name}: \" . implode(', ', $values) . \"\\r\\n\";\n        }\n        $requestString .= \"\\r\\n\" . $request->getBody();\n\n\n        fwrite($fp, $requestString);\n\n        $responseString = '';\n        while (!feof($fp)) {\n            $responseString .= fread($fp, 8192);\n        }\n        fclose($fp);\n\n        $parts = explode(\"\\r\\n\\r\\n\", $responseString, 2);\n        $headerLines = explode(\"\\r\\n\", $parts[0]);\n        $statusLine = array_shift($headerLines);\n        preg_match('/HTTP\\/\\S+ (\\d+) (.+)/', $statusLine, $matches);\n        $statusCode = (int)$matches[1];\n        $reasonPhrase = $matches[2];\n\n        $response = $this->responseFactory->createResponse($statusCode, $reasonPhrase);\n\n        foreach ($headerLines as $headerLine) {\n            [$name, $value] = explode(':', $headerLine, 2);\n            $response = $response->withHeader(trim($name), trim($value));\n        }\n        $response = $response->withBody(\\GuzzleHttp\\Psr7\\Utils::streamFor($parts[1] ?? ''));\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\NullLogger;\n\nclass SocketHttpClient implements ClientInterface\n{\n    private LoggerInterface $logger;\n    private ResponseFactoryInterface $responseFactory;\n    private StreamFactoryInterface $streamFactory;\n\n    public function __construct(\n        ResponseFactoryInterface $responseFactory,\n        StreamFactoryInterface $streamFactory,\n        ?LoggerInterface $logger = null\n    ) {\n        $this->logger = $logger ?? new NullLogger();\n        $this->responseFactory = $responseFactory;\n        $this->streamFactory = $streamFactory;\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $scheme = $uri->getScheme();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($scheme === 'https' ? 443 : 80);\n        $path = $uri->getPath() ?: '/';\n        $query = $uri->getQuery();\n        if ($query) {\n            $path .= '?' . $query;\n        }\n\n        $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 10);\n        if (!$fp) {\n            $this->logger->error(\"Connection failed: {$errstr} ({$errno})\");\n            throw new \\RuntimeException(\"Connection failed: {$errstr} ({$errno})\");\n        }\n\n        $method = $request->getMethod();\n        $headers = $request->getHeaders();\n        $body = $request->getBody();\n\n        $requestString = \"{$method} {$path} HTTP/1.1\\r\\n\";\n        $requestString .= \"Host: {$host}\\r\\n\";\n        foreach ($headers as $name => $values) {\n            $requestString .= \"{$name}: \" . implode(', ', $values) . \"\\r\\n\";\n        }\n        $requestString .= \"Content-Length: \" . $body->getSize() . \"\\r\\n\";\n        $requestString .= \"\\r\\n\";\n        $requestString .= $body->getContents();\n\n\n        fwrite($fp, $requestString);\n\n        $responseString = '';\n        while (!feof($fp)) {\n            $responseString .= fgets($fp);\n        }\n        fclose($fp);\n\n\n        $parts = explode(\"\\r\\n\\r\\n\", $responseString, 2);\n        $headerString = $parts[0];\n        $bodyString = $parts[1] ?? '';\n\n        $headerLines = explode(\"\\r\\n\", $headerString);\n        $statusLine = array_shift($headerLines);\n        preg_match('/HTTP\\/\\d\\.\\d (\\d+) (.+)/', $statusLine, $matches);\n        $statusCode = (int)$matches[1];\n        $reasonPhrase = $matches[2];\n\n        $responseHeaders = [];\n        foreach ($headerLines as $headerLine) {\n            [$name, $value] = explode(':', $headerLine, 2);\n            $responseHeaders[trim($name)] = [trim($value)];\n        }\n\n        $response = $this->responseFactory->createResponse($statusCode, $reasonPhrase);\n        foreach ($responseHeaders as $name => $values) {\n            $response = $response->withHeader($name, $values);\n        }\n\n        $stream = $this->streamFactory->createStream($bodyString);\n        $response = $response->withBody($stream);\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\NullLogger;\n\nclass SocketHttpClient implements ClientInterface\n{\n    private LoggerInterface $logger;\n    private ResponseFactoryInterface $responseFactory;\n    private StreamFactoryInterface $streamFactory;\n\n    public function __construct(\n        ResponseFactoryInterface $responseFactory,\n        StreamFactoryInterface $streamFactory,\n        ?LoggerInterface $logger = null\n    ) {\n        $this->logger = $logger ?? new NullLogger();\n        $this->responseFactory = $responseFactory;\n        $this->streamFactory = $streamFactory;\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $scheme = $uri->getScheme();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($scheme === 'https' ? 443 : 80);\n        $path = $uri->getPath() ?: '/';\n        $query = $uri->getQuery();\n        if ($query) {\n            $path .= '?' . $query;\n        }\n\n        $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n        if (!$fp) {\n            $this->logger->error(\"Connection failed: {$errstr} ({$errno})\");\n            throw new \\RuntimeException(\"Connection failed: {$errstr} ({$errno})\");\n        }\n\n        $headers = $request->getHeaders();\n        $headersString = '';\n        foreach ($headers as $name => $values) {\n            $headersString .= $name . ': ' . implode(', ', $values) . \"\\r\\n\";\n        }\n\n        $body = $request->getBody();\n        $bodyContent = $body->getContents();\n\n\n        $out = $request->getMethod() . \" {$path} HTTP/1.1\\r\\n\";\n        $out .= \"Host: {$host}\\r\\n\";\n        $out .= $headersString;\n        $out .= \"Content-Length: \" . strlen($bodyContent) . \"\\r\\n\";\n        $out .= \"Connection: close\\r\\n\\r\\n\";\n        $out .= $bodyContent;\n\n        fwrite($fp, $out);\n\n        $responseString = '';\n        while (!feof($fp)) {\n            $responseString .= fgets($fp, 1024);\n        }\n        fclose($fp);\n\n        $parts = explode(\"\\r\\n\\r\\n\", $responseString, 2);\n        $headerPart = $parts[0];\n        $bodyPart = $parts[1] ?? '';\n\n        $headerLines = explode(\"\\r\\n\", $headerPart);\n        $statusLine = array_shift($headerLines);\n        preg_match('/HTTP\\/\\d\\.\\d (\\d{3}) (.*)/', $statusLine, $matches);\n        $statusCode = (int)$matches[1];\n        $reasonPhrase = $matches[2];\n\n        $responseHeaders = [];\n        foreach ($headerLines as $headerLine) {\n            [$name, $value] = explode(':', $headerLine, 2);\n            $responseHeaders[trim($name)] = [trim($value)];\n        }\n\n        $responseBody = $this->streamFactory->createStream($bodyPart);\n        $response = $this->responseFactory->createResponse($statusCode, $reasonPhrase)\n            ->withBody($responseBody);\n\n        foreach ($responseHeaders as $name => $values) {\n            $response = $response->withHeader($name, $values);\n        }\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\NullLogger;\n\nclass SocketHttpClient implements ClientInterface\n{\n    private LoggerInterface $logger;\n    private ResponseFactoryInterface $responseFactory;\n    private StreamFactoryInterface $streamFactory;\n\n    public function __construct(\n        ResponseFactoryInterface $responseFactory,\n        StreamFactoryInterface $streamFactory,\n        ?LoggerInterface $logger = null\n    ) {\n        $this->logger = $logger ?? new NullLogger();\n        $this->responseFactory = $responseFactory;\n        $this->streamFactory = $streamFactory;\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $scheme = $uri->getScheme();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($scheme === 'https' ? 443 : 80);\n        $path = $uri->getPath() ?: '/';\n        $query = $uri->getQuery();\n        if ($query) {\n            $path .= '?' . $query;\n        }\n\n        $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 10);\n        if (!$fp) {\n            $this->logger->error(\"Connection failed: {$errstr} ({$errno})\");\n            throw new \\RuntimeException(\"Connection failed: {$errstr} ({$errno})\");\n        }\n\n        $headers = $request->getHeaders();\n        $headersString = '';\n        foreach ($headers as $name => $values) {\n            $headersString .= $name . ': ' . implode(', ', $values) . \"\\r\\n\";\n        }\n\n        $body = $request->getBody();\n        $bodyContent = $body->getContents();\n\n\n        $out = $request->getMethod() . \" {$path} HTTP/1.1\\r\\n\";\n        $out .= \"Host: {$host}\\r\\n\";\n        $out .= $headersString;\n        $out .= \"Content-Length: \" . strlen($bodyContent) . \"\\r\\n\";\n        $out .= \"Connection: close\\r\\n\\r\\n\";\n        $out .= $bodyContent;\n\n        fwrite($fp, $out);\n\n        $responseString = '';\n        while (!feof($fp)) {\n            $responseString .= fgets($fp, 1024);\n        }\n        fclose($fp);\n\n        $parts = explode(\"\\r\\n\\r\\n\", $responseString, 2);\n        $headerPart = $parts[0];\n        $bodyPart = $parts[1] ?? '';\n\n        $headerLines = explode(\"\\r\\n\", $headerPart);\n        $statusLine = array_shift($headerLines);\n        preg_match('/HTTP\\/\\d\\.\\d (\\d+) (.+)/', $statusLine, $matches);\n        $statusCode = (int)$matches[1];\n        $reasonPhrase = $matches[2];\n\n        $responseHeaders = [];\n        foreach ($headerLines as $headerLine) {\n            [$name, $value] = explode(':', $headerLine, 2);\n            $responseHeaders[trim($name)] = [trim($value)];\n        }\n\n        $responseBody = $this->streamFactory->createStream($bodyPart);\n        $response = $this->responseFactory->createResponse($statusCode, $reasonPhrase)\n            ->withBody($responseBody);\n\n        foreach ($responseHeaders as $name => $values) {\n            $response = $response->withHeader($name, $values);\n        }\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\NullLogger;\n\nclass SocketHttpClient implements ClientInterface\n{\n    private LoggerInterface $logger;\n    private ResponseFactoryInterface $responseFactory;\n\n    public function __construct(LoggerInterface $logger = null, ResponseFactoryInterface $responseFactory)\n    {\n        $this->logger = $logger ?? new NullLogger();\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $scheme = $uri->getScheme();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($scheme === 'https' ? 443 : 80);\n        $path = $uri->getPath() ?: '/';\n        $query = $uri->getQuery();\n        if ($query) {\n            $path .= '?' . $query;\n        }\n\n        $fp = @fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n        if (!$fp) {\n            $this->logger->error(\"Connection failed: {error}\", ['error' => $errstr]);\n            throw new \\RuntimeException(\"Connection failed: {$errstr}\");\n        }\n\n        $headers = $request->getHeaders();\n        $headersString = '';\n        foreach ($headers as $name => $values) {\n            $headersString .= \"{$name}: \" . implode(', ', $values) . \"\\r\\n\";\n        }\n\n        $body = $request->getBody();\n        $contentLength = $body->getSize();\n\n        $out = \"{$request->getMethod()} {$path} HTTP/1.1\\r\\n\";\n        $out .= \"Host: {$host}\\r\\n\";\n        $out .= $headersString;\n        if ($contentLength !== null) {\n            $out .= \"Content-Length: {$contentLength}\\r\\n\";\n        }\n        $out .= \"Connection: close\\r\\n\\r\\n\";\n        $out .= $body->getContents();\n\n        fwrite($fp, $out);\n\n        $responseString = '';\n        while (!feof($fp)) {\n            $responseString .= fgets($fp, 1024);\n        }\n        fclose($fp);\n\n\n        $parts = explode(\"\\r\\n\\r\\n\", $responseString, 2);\n        $headerPart = $parts[0];\n        $bodyPart = $parts[1] ?? '';\n\n        $headerLines = explode(\"\\r\\n\", $headerPart);\n        $statusLine = array_shift($headerLines);\n        preg_match('/HTTP\\/\\d\\.\\d (\\d{3}) (.*)/', $statusLine, $matches);\n        $statusCode = (int)$matches[1];\n        $reasonPhrase = $matches[2];\n\n        $responseHeaders = [];\n        foreach ($headerLines as $headerLine) {\n            [$name, $value] = explode(':', $headerLine, 2);\n            $responseHeaders[trim($name)] = [trim($value)];\n        }\n\n        $response = $this->responseFactory->createResponse($statusCode, $reasonPhrase);\n\n        foreach ($responseHeaders as $name => $values) {\n            $response = $response->withHeader($name, $values[0]);\n        }\n\n        $response->getBody()->write($bodyPart);\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\NullLogger;\n\nclass SocketHttpClient implements ClientInterface\n{\n    private LoggerInterface $logger;\n    private ResponseFactoryInterface $responseFactory;\n    private StreamFactoryInterface $streamFactory;\n\n    public function __construct(\n        ResponseFactoryInterface $responseFactory,\n        StreamFactoryInterface $streamFactory,\n        ?LoggerInterface $logger = null\n    ) {\n        $this->logger = $logger ?? new NullLogger();\n        $this->responseFactory = $responseFactory;\n        $this->streamFactory = $streamFactory;\n    }\n\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($uri->getScheme() === 'https' ? 443 : 80);\n        $ssl = $uri->getScheme() === 'https' ? 'ssl://' : '';\n\n        $this->logger->debug(\"Connecting to {$ssl}{$host}:{$port}\");\n\n        $fp = @fsockopen($ssl . $host, $port, $errno, $errstr, 10);\n\n        if (!$fp) {\n            $this->logger->error(\"Connection failed: {$errstr} ({$errno})\");\n            throw new \\RuntimeException(\"Connection failed: {$errstr} ({$errno})\");\n        }\n\n        $path = $uri->getPath() ?: '/';\n        $query = $uri->getQuery() ? '?' . $uri->getQuery() : '';\n\n        $out = \"{$request->getMethod()} {$path}{$query} HTTP/1.1\\r\\n\";\n        $out .= \"Host: {$host}\\r\\n\";\n        foreach ($request->getHeaders() as $name => $values) {\n            $out .= $name . ': ' . implode(', ', $values) . \"\\r\\n\";\n        }\n        $out .= \"Content-Length: \" . $request->getBody()->getSize() . \"\\r\\n\";\n        $out .= \"Connection: close\\r\\n\\r\\n\";\n        $out .= $request->getBody()->getContents();\n\n\n        fwrite($fp, $out);\n\n        $responseString = '';\n        while (!feof($fp)) {\n            $responseString .= fgets($fp, 1024);\n        }\n        fclose($fp);\n\n\n        $parts = explode(\"\\r\\n\\r\\n\", $responseString, 2);\n        $headers = $parts[0];\n        $body = $parts[1] ?? '';\n\n        $headers = explode(\"\\r\\n\", $headers);\n        $statusLine = array_shift($headers);\n        preg_match('/HTTP\\/\\d\\.\\d (\\d{3}) (.*)/', $statusLine, $matches);\n        $statusCode = (int)$matches[1];\n        $reasonPhrase = $matches[2];\n\n        $response = $this->responseFactory->createResponse($statusCode, $reasonPhrase);\n        $response = $response->withBody($this->streamFactory->createStream($body));\n\n        foreach ($headers as $header) {\n            [$name, $value] = explode(':', $header, 2);\n            $response = $response->withHeader(trim($name), trim($value));\n        }\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\NullLogger;\n\nclass SocketHttpClient implements ClientInterface\n{\n    private LoggerInterface $logger;\n    private ResponseFactoryInterface $responseFactory;\n    private StreamFactoryInterface $streamFactory;\n\n    public function __construct(\n        ResponseFactoryInterface $responseFactory,\n        StreamFactoryInterface $streamFactory,\n        ?LoggerInterface $logger = null\n    ) {\n        $this->logger = $logger ?? new NullLogger();\n        $this->responseFactory = $responseFactory;\n        $this->streamFactory = $streamFactory;\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($uri->getScheme() === 'https' ? 443 : 80);\n        $ssl = $uri->getScheme() === 'https' ? 'ssl://' : '';\n\n        $this->logger->debug(\"Connecting to {$ssl}{$host}:{$port}\");\n\n        $fp = @fsockopen($ssl . $host, $port, $errno, $errstr, 10);\n\n        if (!$fp) {\n            $this->logger->error(\"Connection failed: {$errstr} ({$errno})\");\n            throw new \\RuntimeException(\"Connection failed: {$errstr} ({$errno})\");\n        }\n\n        $path = $uri->getPath() ?: '/';\n        $query = $uri->getQuery() ? '?' . $uri->getQuery() : '';\n\n        $headers = $request->getHeaders();\n        $headersString = '';\n        foreach ($headers as $name => $values) {\n            $headersString .= $name . ': ' . implode(', ', $values) . \"\\r\\n\";\n        }\n\n        $requestBody = $request->getBody()->getContents();\n\n        $out = \"{$request->getMethod()} {$path}{$query} HTTP/1.1\\r\\n\";\n        $out .= \"Host: {$host}\\r\\n\";\n        $out .= $headersString;\n        $out .= \"Content-Length: \" . strlen($requestBody) . \"\\r\\n\";\n        $out .= \"Connection: close\\r\\n\\r\\n\";\n        $out .= $requestBody;\n\n        fwrite($fp, $out);\n\n        $responseString = '';\n        while (!feof($fp)) {\n            $responseString .= fgets($fp, 1024);\n        }\n\n        fclose($fp);\n\n        $parts = explode(\"\\r\\n\\r\\n\", $responseString, 2);\n        $headerString = $parts[0];\n        $body = $parts[1] ?? '';\n\n        $headerLines = explode(\"\\r\\n\", $headerString);\n        $statusLine = array_shift($headerLines);\n        preg_match('/HTTP\\/\\d\\.\\d (\\d{3}) (.+)/', $statusLine, $matches);\n        $statusCode = (int)$matches[1];\n        $reasonPhrase = $matches[2];\n\n        $responseHeaders = [];\n        foreach ($headerLines as $headerLine) {\n            [$name, $value] = explode(':', $headerLine, 2);\n            $responseHeaders[trim($name)] = [trim($value)];\n        }\n\n\n        $response = $this->responseFactory->createResponse($statusCode, $reasonPhrase);\n\n        foreach ($responseHeaders as $name => $values) {\n            $response = $response->withHeader($name, $values);\n        }\n        $responseBody = $this->streamFactory->createStream($body);\n        $response = $response->withBody($responseBody);\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\NullLogger;\n\nclass SocketHttpClient implements ClientInterface\n{\n    private LoggerInterface $logger;\n    private ResponseFactoryInterface $responseFactory;\n\n    public function __construct(?LoggerInterface $logger = null, ?ResponseFactoryInterface $responseFactory = null)\n    {\n        $this->logger = $logger ?? new NullLogger();\n        $this->responseFactory = $responseFactory ?? new class implements ResponseFactoryInterface {\n            public function createResponse(int $code = 200, string $reasonPhrase = ''): ResponseInterface\n            {\n                return new class($code, $reasonPhrase) implements ResponseInterface {\n                    private int $statusCode;\n                    private string $reasonPhrase;\n                    private array $headers = [];\n                    private string $body = '';\n\n                    public function __construct(int $code, string $reasonPhrase) {\n                        $this->statusCode = $code;\n                        $this->reasonPhrase = $reasonPhrase;\n                    }\n\n                    public function getProtocolVersion() { return '1.1'; }\n                    public function withProtocolVersion($version) { return $this; }\n                    public function getHeaders() { return $this->headers; }\n                    public function hasHeader($name) { return isset($this->headers[$name]); }\n                    public function getHeader($name) { return $this->headers[$name] ?? []; }\n                    public function getHeaderLine($name) { return implode(', ', $this->getHeader($name)); }\n                    public function withHeader($name, $value) { $clone = clone $this; $clone->headers[$name] = $value; return $clone; }\n                    public function withAddedHeader($name, $value) { $clone = clone $this; $clone->headers[$name] = array_merge($clone->headers[$name] ?? [], (array)$value); return $clone; }\n                    public function withoutHeader($name) { $clone = clone $this; unset($clone->headers[$name]); return $clone; }\n                    public function getBody() { return \\GuzzleHttp\\Psr7\\Utils::streamFor($this->body); }\n                    public function withBody(\\Psr\\Http\\Message\\StreamInterface $body) { $clone = clone $this; $clone->body = (string)$body; return $clone; }\n                    public function getStatusCode() { return $this->statusCode; }\n                    public function withStatus($code, $reasonPhrase = '') { $clone = clone $this; $clone->statusCode = $code; $clone->reasonPhrase = $reasonPhrase; return $clone; }\n                    public function getReasonPhrase() { return $this->reasonPhrase; }\n                };\n            }\n        };\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($uri->getScheme() === 'https' ? 443 : 80);\n        $ssl = $uri->getScheme() === 'https';\n\n        $fp = @fsockopen(($ssl ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n        if (!$fp) {\n            $this->logger->error(\"Connection failed: {$errstr} ({$errno})\");\n            throw new \\RuntimeException(\"Connection failed: {$errstr} ({$errno})\");\n        }\n\n        $headers = $request->getHeaders();\n        $headers['Host'] = [$host];\n        $headers['Connection'] = ['close'];\n\n        $requestString = \"{$request->getMethod()} {$uri->getPath()} HTTP/{$request->getProtocolVersion()}\\r\\n\";\n        foreach ($headers as $name => $values) {\n            foreach ($values as $value) {\n                $requestString .= \"{$name}: {$value}\\r\\n\";\n            }\n        }\n        $requestString .= \"\\r\\n\" . $request->getBody();\n\n        fwrite($fp, $requestString);\n\n        $responseString = '';\n        while (!feof($fp)) {\n            $responseString .= fread($fp, 8192);\n        }\n        fclose($fp);\n\n        $parts = explode(\"\\r\\n\\r\\n\", $responseString, 2);\n        $headerLines = explode(\"\\r\\n\", $parts[0]);\n        $statusLine = array_shift($headerLines);\n        preg_match('/HTTP\\/(\\d\\.\\d) (\\d+) (.*)/', $statusLine, $matches);\n        $statusCode = (int)$matches[2];\n        $reasonPhrase = $matches[3];\n\n        $response = $this->responseFactory->createResponse($statusCode, $reasonPhrase);\n        foreach ($headerLines as $headerLine) {\n            [$name, $value] = explode(':', $headerLine, 2);\n            $response = $response->withHeader(trim($name), trim($value));\n        }\n        $response = $response->withBody(\\GuzzleHttp\\Psr7\\Utils::streamFor($parts[1] ?? ''));\n\n        return $response;\n    }\n}\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a function that implements a RabbitMQ consumer in PHP to process messages from a specified queue.\n\nFunction Description: The function establishes a connection to a RabbitMQ server, declares a queue and exchange, binds them, and starts consuming messages. It processes each message by printing its content and acknowledging it. The consumer stops when it receives a 'quit' message or when the channel is no longer consuming. The function includes proper cleanup by closing the channel and connection upon shutdown.\n\nInput:\n- $host (string): The hostname of the RabbitMQ server\n- $port (int): The port number of the RabbitMQ server\n- $user (string): The username for RabbitMQ authentication\n- $pass (string): The password for RabbitMQ authentication\n- $vhost (string): The virtual host to connect to\n- $exchange (string): The name of the exchange to declare\n- $queue (string): The name of the queue to declare and consume from\n- $consumerTag (string): The identifier for this consumer\n\nOutput: None (The function processes messages asynchronously and does not return a value)",
    "Canonical_solution": "function start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag)\n{\n    require_once __DIR__ . '/vendor/autoload.php';\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n    $channel->queue_bind($queue, $exchange);\n\n    function process_message($message)\n    {\n        echo \"\\n--------\\n\";\n        echo $message->body;\n        echo \"\\n--------\\n\";\n\n        $message->ack();\n\n        if ($message->body === 'quit') {\n            $message->getChannel()->basic_cancel($message->getConsumerTag());\n        }\n    }\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, 'process_message');\n\n    function shutdown($channel, $connection)\n    {\n        $channel->close();\n        $connection->close();\n    }\n\n    register_shutdown_function('shutdown', $channel, $connection);\n\n    while ($channel->is_consuming()) {\n        $channel->wait(null, true);\n        usleep(300000);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 143,
    "matched_results": [
      "<?php\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, false, false);\n    $channel->queue_declare($queue, false, false, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    $callback = function (AMQPMessage $msg) use ($channel) {\n        echo $msg->body . \"\\n\";\n        $msg->ack();\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n        }\n    };\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n",
      "<?php\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    $callback = function (AMQPMessage $msg) use ($channel) {\n        echo $msg->body . \"\\n\";\n        $msg->ack();\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n        }\n    };\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n",
      "<?php\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    $callback = function (AMQPMessage $msg) use ($channel) {\n        echo $msg->body . \"\\n\";\n        $msg->ack();\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n        }\n    };\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n",
      "<?php\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    $callback = function (AMQPMessage $msg) use ($channel) {\n        echo $msg->body . \"\\n\";\n        $msg->ack();\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n        }\n    };\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n",
      "<?php\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    $callback = function (AMQPMessage $msg) use ($channel) {\n        echo $msg->body . \"\\n\";\n        $msg->ack();\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n        }\n    };\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n"
    ],
    "unmatched_results": [
      "<?php\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'login' => $user,\n        'password' => $pass,\n        'vhost' => $vhost\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($channel, $consumerTag) {\n        echo $message->getBody() . \"\\n\";\n        $queue->ack($message->getDeliveryTag());\n\n        if ($message->getBody() === 'quit') {\n            $channel->basic_cancel($consumerTag);\n        }\n    };\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, $callback);\n\n    while (count($channel->callbacks)) {\n        $channel->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n",
      "<?php\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($channel, $consumerTag) {\n        echo $message->getBody() . PHP_EOL;\n        $queue->ack($message->getDeliveryTag());\n\n        if ($message->getBody() === 'quit') {\n            $channel->basic_cancel($consumerTag);\n        }\n    };\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n",
      "<?php\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($channel, $consumerTag) {\n        echo $message->getBody() . \"\\n\";\n        $queue->ack($message->getDeliveryTag());\n\n        if ($message->getBody() === 'quit') {\n            $channel->basic_cancel($consumerTag);\n        }\n    };\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n",
      "<?php\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'login' => $user,\n        'password' => $pass,\n        'vhost' => $vhost\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($channel, $consumerTag) {\n        echo $message->getBody() . \"\\n\";\n        $queue->ack($message->getDeliveryTag());\n\n        if ($message->getBody() === 'quit') {\n            $channel->basic_cancel($consumerTag);\n        }\n    };\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n",
      "<?php\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($channel, $consumerTag) {\n        echo $message->getBody() . \"\\n\";\n        $queue->ack($message->getDeliveryTag());\n\n        if ($message->getBody() === 'quit') {\n            $channel->basic_cancel($consumerTag);\n        }\n    };\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, $callback);\n\n    while (count($channel->callbacks)) {\n        $channel->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n"
    ],
    "match_count": 5,
    "pass@3": 0.9166666666666666,
    "pass@5": 0.996031746031746
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a RabbitMQ consumer class in PHP that connects to a RabbitMQ server, declares a queue and exchange, binds them, and processes incoming messages until a termination signal is received.\n\nClass Description: The RabbitMQConsumer class handles the consumption of messages from a RabbitMQ queue. It establishes a connection to the server, sets up the necessary queue and exchange, processes messages, and provides shutdown functionality.\n\nAttributes:\n- msgCount: [int] - Tracks the number of messages processed\n- startTime: [float|null] - Records the start time of message processing\n- conn: [AMQPStreamConnection] - Holds the RabbitMQ server connection\n- ch: [AMQPChannel] - Represents the communication channel\n- exchange: [string] - Name of the exchange to bind to\n- queue: [string] - Name of the queue to consume from\n- consumer_tag: [string] - Identifier for the consumer (empty in this implementation)\n\nMethods:\n- __construct() -> [void] - Initializes the RabbitMQ connection, channel, exchange, and queue\n- process_message([AMQPMessage] $msg) -> [void] - Processes incoming messages and handles termination signal\n- startConsuming() -> [void] - Starts consuming messages from the queue\n- shutdown() -> [void] - Closes the channel and connection cleanly",
    "Canonical_solution": "use PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nrequire __DIR__ . '/../vendor/autoload.php';\nrequire __DIR__ . '/../tests/config.php';\n\nclass RabbitMQConsumer\n{\n    protected $msgCount = 0;\n    protected $startTime = null;\n    protected $conn;\n    protected $ch;\n    protected $exchange = 'bench_exchange';\n    protected $queue = 'bench_queue';\n    protected $consumer_tag = '';\n\n    public function __construct()\n    {\n        $this->conn = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n        $this->ch = $this->conn->channel();\n        $this->ch->queue_declare($this->queue, false, false, false, false);\n        $this->ch->exchange_declare($this->exchange, 'direct', false, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange);\n    }\n\n    public function process_message($msg)\n    {\n        if ($this->startTime === null) {\n            $this->startTime = microtime(true);\n        }\n\n        if ($msg->body == 'quit') {\n            echo sprintf(\"Pid: %s, Count: %s, Time: %.4f\\n\", getmypid(), $this->msgCount, microtime(true) - $this->startTime);\n            $this->shutdown();\n            die;\n        }\n        $this->msgCount++;\n    }\n\n    public function startConsuming()\n    {\n        $this->ch->basic_consume($this->queue, '', false, true, false, false, array($this, 'process_message'));\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n    protected function shutdown()\n    {\n        $this->ch->close();\n        $this->conn->close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 143,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nclass RabbitMQConsumer\n{\n    private int $msgCount = 0;\n    private ?float $startTime = null;\n    private AMQPStreamConnection $conn;\n    private AMQPChannel $ch;\n    private string $exchange;\n    private string $queue;\n    private string $consumer_tag = \"\";\n\n    public function __construct(string $host, int $port, string $user, string $pass, string $vhost, string $exchange, string $queue)\n    {\n        $this->conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n        $this->ch = $this->conn->channel();\n        $this->exchange = $exchange;\n        $this->queue = $queue;\n\n        $this->ch->exchange_declare($this->exchange, 'direct', false, true, false);\n        $this->ch->queue_declare($this->queue, false, true, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange, $this->queue);\n    }\n\n    public function process_message(AMQPMessage $msg): void\n    {\n        $this->msgCount++;\n        if ($this->msgCount === 1) {\n            $this->startTime = microtime(true);\n        }\n\n        echo $msg->body . PHP_EOL;\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            if (pcntl_sigtimedwait([SIGINT, SIGTERM], $siginfo, 0) > 0) {\n                $this->shutdown();\n            }\n        }\n    }\n\n    public function startConsuming(): void\n    {\n        $this->ch->basic_consume($this->queue, $this->consumer_tag, false, false, false, false, [$this, 'process_message']);\n\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n    public function shutdown(): void\n    {\n        if ($this->startTime !== null) {\n            $endTime = microtime(true);\n            $duration = $endTime - $this->startTime;\n            echo \"Processed {$this->msgCount} messages in {$duration} seconds.\" . PHP_EOL;\n        }\n        $this->ch->close();\n        $this->conn->close();\n    }\n}\n\n// Example usage (replace with your credentials and settings):\n$host = 'localhost';\n$port = 5672;\n$user = 'guest';\n$pass = 'guest';\n$vhost = '/';\n$exchange = 'my_exchange';\n$queue = 'my_queue';\n\n$consumer = new RabbitMQConsumer($host, $port, $user, $pass, $vhost, $exchange, $queue);\n$consumer->startConsuming();\n\n?>\n",
      "<?php\n\nclass RabbitMQConsumer\n{\n    private int $msgCount = 0;\n    private ?float $startTime = null;\n    private AMQPStreamConnection $conn;\n    private AMQPChannel $ch;\n    private string $exchange;\n    private string $queue;\n    private string $consumer_tag = '';\n\n    public function __construct(string $host, int $port, string $user, string $pass, string $vhost, string $exchange, string $queue)\n    {\n        $this->conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n        $this->ch = $this->conn->channel();\n        $this->exchange = $exchange;\n        $this->queue = $queue;\n\n        $this->ch->exchange_declare($this->exchange, 'direct', false, true, false);\n        $this->ch->queue_declare($this->queue, false, true, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange, $this->queue);\n    }\n\n    public function process_message(AMQPMessage $msg): void\n    {\n        $this->msgCount++;\n        if ($this->msgCount === 1) {\n            $this->startTime = microtime(true);\n        }\n\n        echo $msg->body . PHP_EOL;\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            if (pcntl_sigtimedwait([SIGINT, SIGTERM], $siginfo, 0) > 0) {\n                $this->shutdown();\n            }\n        }\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n\n    }\n\n    public function startConsuming(): void\n    {\n        $this->ch->basic_consume($this->queue, $this->consumer_tag, false, false, false, false, [$this, 'process_message']);\n\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n    public function shutdown(): void\n    {\n        if ($this->startTime !== null) {\n            $endTime = microtime(true);\n            $elapsed = $endTime - $this->startTime;\n            echo \"Processed {$this->msgCount} messages in \" . round($elapsed, 3) . \" seconds.\" . PHP_EOL;\n        }\n        $this->ch->close();\n        $this->conn->close();\n        exit(0);\n    }\n}\n\n?>\n",
      "<?php\n\nclass RabbitMQConsumer\n{\n    private int $msgCount = 0;\n    private ?float $startTime = null;\n    private AMQPStreamConnection $conn;\n    private AMQPChannel $ch;\n    private string $exchange;\n    private string $queue;\n    private string $consumer_tag = \"\";\n\n    public function __construct(string $host, int $port, string $user, string $pass, string $vhost, string $exchange, string $queue)\n    {\n        $this->conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n        $this->ch = $this->conn->channel();\n        $this->exchange = $exchange;\n        $this->queue = $queue;\n\n        $this->ch->exchange_declare($this->exchange, 'direct', false, true, false);\n        $this->ch->queue_declare($this->queue, false, true, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange, $this->queue);\n    }\n\n    public function process_message(AMQPMessage $msg): void\n    {\n        $this->msgCount++;\n        if ($this->msgCount === 1) {\n            $this->startTime = microtime(true);\n        }\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            pcntl_signal_dispatch();\n        }\n\n        if ($this->msgCount % 1000 === 0) {\n            $now = microtime(true);\n            $elapsed = $now - $this->startTime;\n            echo \"Processed {$this->msgCount} messages in {$elapsed} seconds\\n\";\n        }\n\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            if (pcntl_sigprocmask(SIG_BLOCK, [SIGINT, SIGTERM], $siginfo) === false) {\n                exit(1);\n            }\n            if ($siginfo[SIGINT] || $siginfo[SIGTERM]) {\n                $this->shutdown();\n            }\n        }\n    }\n\n    public function startConsuming(): void\n    {\n        $this->ch->basic_consume($this->queue, $this->consumer_tag, false, false, false, false, [$this, 'process_message']);\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n    public function shutdown(): void\n    {\n        $this->ch->close();\n        $this->conn->close();\n        echo \"Exiting consumer...\\n\";\n        exit(0);\n    }\n}\n\n?>\n",
      "<?php\n\nclass RabbitMQConsumer\n{\n    private int $msgCount = 0;\n    private ?float $startTime = null;\n    private AMQPStreamConnection $conn;\n    private AMQPChannel $ch;\n    private string $exchange;\n    private string $queue;\n    private string $consumer_tag = \"\";\n\n    public function __construct(string $host, int $port, string $user, string $pass, string $vhost, string $exchange, string $queue)\n    {\n        $this->conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n        $this->ch = $this->conn->channel();\n        $this->exchange = $exchange;\n        $this->queue = $queue;\n\n        $this->ch->exchange_declare($this->exchange, 'direct', false, true, false);\n        $this->ch->queue_declare($this->queue, false, true, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange, $this->queue);\n    }\n\n    public function process_message(AMQPMessage $msg): void\n    {\n        $this->msgCount++;\n        if ($this->msgCount === 1) {\n            $this->startTime = microtime(true);\n        }\n\n        echo $msg->body . PHP_EOL;\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            if (pcntl_sigtimedwait([SIGINT, SIGTERM], $siginfo, 0) !== false) {\n                $this->shutdown();\n            }\n        }\n    }\n\n    public function startConsuming(): void\n    {\n        $this->ch->basic_consume($this->queue, $this->consumer_tag, false, false, false, false, [$this, 'process_message']);\n\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n    public function shutdown(): void\n    {\n        if ($this->startTime !== null) {\n            $endTime = microtime(true);\n            $duration = $endTime - $this->startTime;\n            echo \"Processed {$this->msgCount} messages in {$duration} seconds.\" . PHP_EOL;\n        }\n\n        $this->ch->close();\n        $this->conn->close();\n        exit(0);\n    }\n}\n\n// Example usage (replace with your credentials and settings)\n$consumer = new RabbitMQConsumer('localhost', 5672, 'guest', 'guest', '/', 'test_exchange', 'test_queue');\n$consumer->startConsuming();\n\n?>\n",
      "<?php\n\nclass RabbitMQConsumer\n{\n    private int $msgCount = 0;\n    private ?float $startTime = null;\n    private AMQPStreamConnection $conn;\n    private AMQPChannel $ch;\n    private string $exchange;\n    private string $queue;\n    private string $consumer_tag = \"\";\n\n\n    public function __construct(string $host, int $port, string $user, string $pass, string $vhost, string $exchange, string $queue)\n    {\n        $this->conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n        $this->ch = $this->conn->channel();\n        $this->exchange = $exchange;\n        $this->queue = $queue;\n\n        $this->ch->exchange_declare($this->exchange, 'direct', false, true, false);\n        $this->ch->queue_declare($this->queue, false, true, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange, $this->queue);\n    }\n\n    public function process_message(AMQPMessage $msg): void\n    {\n        $this->msgCount++;\n        if ($this->msgCount === 1) {\n            $this->startTime = microtime(true);\n        }\n\n        echo $msg->body . PHP_EOL;\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            if (pcntl_sigtimedwait([SIGINT, SIGTERM], $siginfo, 0) > 0) {\n                $this->shutdown();\n            }\n        }\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n\n    }\n\n    public function startConsuming(): void\n    {\n        $this->ch->basic_consume($this->queue, $this->consumer_tag, false, false, false, false, [$this, 'process_message']);\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n    public function shutdown(): void\n    {\n        if ($this->startTime !== null) {\n            $endTime = microtime(true);\n            $elapsed = $endTime - $this->startTime;\n            echo \"Processed {$this->msgCount} messages in $elapsed seconds.\" . PHP_EOL;\n        }\n        $this->ch->close();\n        $this->conn->close();\n        exit(0);\n    }\n}\n\n?>\n",
      "<?php\n\nclass RabbitMQConsumer\n{\n    private int $msgCount = 0;\n    private ?float $startTime = null;\n    private AMQPStreamConnection $conn;\n    private AMQPChannel $ch;\n    private string $exchange;\n    private string $queue;\n    private string $consumer_tag = \"\";\n\n    public function __construct(string $host, int $port, string $user, string $pass, string $vhost, string $exchange, string $queue)\n    {\n        $this->conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n        $this->ch = $this->conn->channel();\n        $this->exchange = $exchange;\n        $this->queue = $queue;\n\n        $this->ch->exchange_declare($this->exchange, 'direct', false, true, false);\n        $this->ch->queue_declare($this->queue, false, true, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange, $this->queue);\n    }\n\n    public function process_message(AMQPMessage $msg): void\n    {\n        $this->msgCount++;\n        if ($this->msgCount === 1) {\n            $this->startTime = microtime(true);\n        }\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            pcntl_signal_dispatch();\n        }\n\n        if ($this->msgCount % 1000 === 0) {\n            $now = microtime(true);\n            $elapsed = $now - $this->startTime;\n            echo \"Processed {$this->msgCount} messages in {$elapsed} seconds\\n\";\n        }\n\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            if (pcntl_sigtimedwait([SIGINT, SIGTERM], $siginfo, 0) !== false) {\n                $this->shutdown();\n                exit;\n            }\n        }\n    }\n\n    public function startConsuming(): void\n    {\n        $this->ch->basic_consume($this->queue, $this->consumer_tag, false, false, false, false, [$this, 'process_message']);\n\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n    public function shutdown(): void\n    {\n        $this->ch->close();\n        $this->conn->close();\n    }\n}\n\n?>\n",
      "<?php\n\nclass RabbitMQConsumer\n{\n    private int $msgCount = 0;\n    private ?float $startTime = null;\n    private AMQPStreamConnection $conn;\n    private AMQPChannel $ch;\n    private string $exchange;\n    private string $queue;\n    private string $consumer_tag = \"\";\n\n    public function __construct(string $host, int $port, string $user, string $pass, string $vhost, string $exchange, string $queue)\n    {\n        $this->conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n        $this->ch = $this->conn->channel();\n        $this->exchange = $exchange;\n        $this->queue = $queue;\n\n        $this->ch->exchange_declare($this->exchange, 'direct', false, true, false);\n        $this->ch->queue_declare($this->queue, false, true, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange, $this->queue);\n    }\n\n    public function process_message(AMQPMessage $msg): void\n    {\n        $this->msgCount++;\n        if ($this->msgCount === 1) {\n            $this->startTime = microtime(true);\n        }\n\n        echo $msg->body . PHP_EOL;\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            if (pcntl_sigtimedwait([SIGINT, SIGTERM], $siginfo, 0) > 0) {\n                $this->shutdown();\n            }\n        }\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n\n    }\n\n    public function startConsuming(): void\n    {\n        $this->ch->basic_consume($this->queue, $this->consumer_tag, false, false, false, false, [$this, 'process_message']);\n\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n    public function shutdown(): void\n    {\n        if ($this->startTime !== null) {\n            $endTime = microtime(true);\n            $elapsed = $endTime - $this->startTime;\n            echo \"Processed {$this->msgCount} messages in \" . round($elapsed, 3) . \" seconds.\" . PHP_EOL;\n        }\n        $this->ch->close();\n        $this->conn->close();\n        exit(0);\n    }\n}\n\n// Example usage (replace with your credentials and settings):\n$host = 'localhost';\n$port = 5672;\n$user = 'guest';\n$pass = 'guest';\n$vhost = '/';\n$exchange = 'test_exchange';\n$queue = 'test_queue';\n\n$consumer = new RabbitMQConsumer($host, $port, $user, $pass, $vhost, $exchange, $queue);\n$consumer->startConsuming();\n\n?>\n",
      "<?php\n\nclass RabbitMQConsumer\n{\n    private int $msgCount = 0;\n    private ?float $startTime = null;\n    private AMQPStreamConnection $conn;\n    private AMQPChannel $ch;\n    private string $exchange;\n    private string $queue;\n    private string $consumer_tag = \"\";\n\n    public function __construct(string $host, int $port, string $user, string $pass, string $vhost, string $exchange, string $queue)\n    {\n        $this->conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n        $this->ch = $this->conn->channel();\n        $this->exchange = $exchange;\n        $this->queue = $queue;\n\n        $this->ch->exchange_declare($this->exchange, 'direct', false, true, false);\n        $this->ch->queue_declare($this->queue, false, true, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange, $this->queue);\n    }\n\n    public function process_message(AMQPMessage $msg): void\n    {\n        $this->msgCount++;\n        if ($this->msgCount === 1) {\n            $this->startTime = microtime(true);\n        }\n\n        echo $msg->body . PHP_EOL;\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            if (pcntl_sigtimedwait([SIGINT, SIGTERM], $siginfo, 0) > 0) {\n                $this->shutdown();\n            }\n        }\n    }\n\n    public function startConsuming(): void\n    {\n        $this->ch->basic_consume($this->queue, $this->consumer_tag, false, false, false, false, [$this, 'process_message']);\n\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n    public function shutdown(): void\n    {\n        if ($this->startTime !== null) {\n            $endTime = microtime(true);\n            $elapsed = $endTime - $this->startTime;\n            echo \"Processed {$this->msgCount} messages in \" . round($elapsed, 3) . \" seconds.\" . PHP_EOL;\n        }\n\n        $this->ch->close();\n        $this->conn->close();\n        exit(0);\n    }\n}\n\n// Example usage (replace with your credentials and settings)\n$consumer = new RabbitMQConsumer('localhost', 5672, 'guest', 'guest', '/', 'test_exchange', 'test_queue');\n$consumer->startConsuming();\n\n?>\n",
      "<?php\n\nclass RabbitMQConsumer\n{\n    private int $msgCount = 0;\n    private ?float $startTime = null;\n    private AMQPStreamConnection $conn;\n    private AMQPChannel $ch;\n    private string $exchange;\n    private string $queue;\n    private string $consumer_tag = \"\";\n\n    public function __construct(string $host, int $port, string $user, string $pass, string $vhost, string $exchange, string $queue)\n    {\n        $this->conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n        $this->ch = $this->conn->channel();\n        $this->exchange = $exchange;\n        $this->queue = $queue;\n\n        $this->ch->exchange_declare($this->exchange, 'direct', false, true, false);\n        $this->ch->queue_declare($this->queue, false, true, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange, $this->queue);\n    }\n\n    public function process_message(AMQPMessage $msg): void\n    {\n        $this->msgCount++;\n        if ($this->msgCount === 1) {\n            $this->startTime = microtime(true);\n        }\n\n        echo $msg->body . PHP_EOL;\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            if (pcntl_sigtimedwait([SIGINT, SIGTERM], $siginfo, 0) !== false) {\n                $this->shutdown();\n            }\n        }\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n\n    }\n\n    public function startConsuming(): void\n    {\n        $this->ch->basic_consume($this->queue, $this->consumer_tag, false, false, false, false, [$this, 'process_message']);\n\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n\n    public function shutdown(): void\n    {\n        if ($this->startTime !== null) {\n            $endTime = microtime(true);\n            $elapsed = $endTime - $this->startTime;\n            echo \"Processed {$this->msgCount} messages in \" . round($elapsed, 3) . \" seconds.\" . PHP_EOL;\n        }\n        $this->ch->close();\n        $this->conn->close();\n        exit(0);\n    }\n}\n\n?>\n",
      "<?php\n\nclass RabbitMQConsumer\n{\n    private int $msgCount = 0;\n    private ?float $startTime = null;\n    private AMQPStreamConnection $conn;\n    private AMQPChannel $ch;\n    private string $exchange;\n    private string $queue;\n    private string $consumer_tag = \"\";\n\n    public function __construct(string $host, int $port, string $user, string $pass, string $vhost, string $exchange, string $queue)\n    {\n        $this->conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n        $this->ch = $this->conn->channel();\n        $this->exchange = $exchange;\n        $this->queue = $queue;\n\n        $this->ch->exchange_declare($this->exchange, 'direct', false, true, false);\n        $this->ch->queue_declare($this->queue, false, true, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange, $this->queue);\n    }\n\n    public function process_message(AMQPMessage $msg): void\n    {\n        $this->msgCount++;\n        if ($this->msgCount === 1) {\n            $this->startTime = microtime(true);\n        }\n\n        echo $msg->body . PHP_EOL;\n\n        if (extension_loaded('pcntl') && defined('AMQP_WITHOUT_SIGNALS') === false) {\n            if (pcntl_sigtimedwait([SIGINT, SIGTERM], $siginfo, 0) !== false) {\n                $this->shutdown();\n            }\n        }\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n\n    }\n\n    public function startConsuming(): void\n    {\n        $this->ch->basic_consume($this->queue, $this->consumer_tag, false, false, false, false, [$this, 'process_message']);\n\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n    public function shutdown(): void\n    {\n        if ($this->startTime !== null) {\n            $endTime = microtime(true);\n            $elapsed = $endTime - $this->startTime;\n            echo \"Processed {$this->msgCount} messages in \" . round($elapsed, 3) . \" seconds.\" . PHP_EOL;\n        }\n\n        $this->ch->close();\n        $this->conn->close();\n        exit(0);\n    }\n}\n\n?>\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a PHP function that implements a RabbitMQ consumer to process messages from a specified queue, with the ability to acknowledge or reject messages based on their content, and properly handle connection shutdown.\n\nFunction Description: The function establishes a connection to a RabbitMQ server, declares a queue and exchange, binds them together, and starts consuming messages. It processes each message by acknowledging \"good\" messages and rejecting others. If the message body is \"quit\", it stops consuming. The function includes proper cleanup by closing the channel and connection on shutdown.\n\nInput:\n- $host: string - RabbitMQ server hostname\n- $port: int - RabbitMQ server port\n- $user: string - RabbitMQ username\n- $pass: string - RabbitMQ password  \n- $vhost: string - RabbitMQ virtual host\n- $exchange: string - Exchange name to bind to\n- $queue: string - Queue name to consume from\n- $consumerTag: string - Identifier for this consumer\n\nOutput: None (This is a long-running consumer process that handles messages asynchronously)",
    "Canonical_solution": "function start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag)\n{\n    require_once __DIR__ . '/config.php';\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n    $channel->queue_bind($queue, $exchange);\n\n    function process_message($message)\n    {\n        if ($message->body == 'good') {\n            $message->ack();\n        } else {\n            $message->nack();\n        }\n\n        if ($message->body === 'quit') {\n            $message->getChannel()->basic_cancel($message->getConsumerTag());\n        }\n    }\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, 'process_message');\n\n    function shutdown($channel, $connection)\n    {\n        $channel->close();\n        $connection->close();\n    }\n\n    register_shutdown_function('shutdown', $channel, $connection);\n\n    $channel->consume();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 143,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection, &$callback) {\n        $body = $message->getBody();\n        echo \"Received message: \" . $body . \"\\n\";\n\n        if ($body === \"quit\") {\n            $queue->cancel($message->getDeliveryTag());\n            $queue->ack($message->getDeliveryTag());\n            $connection->shutdown();\n            return;\n        }\n\n        if ($body === \"good\") {\n            $queue->ack($message->getDeliveryTag());\n        } else {\n            $queue->reject($message->getDeliveryTag(), AMQP_REQUEUE);\n        }\n    };\n\n    $queue_obj->consume($callback, AMQP_AUTOACK, $consumerTag);\n\n\n    while (count($connection->callbacks)) {\n        $connection->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n",
      "<?php\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass,\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    function process_message($envelope, $queue) {\n        $msg = $envelope->getBody();\n        echo \"Received message: \" . $msg . \"\\n\";\n\n        if ($msg === \"quit\") {\n            $queue->cancel($envelope->getDeliveryTag());\n            $queue->shutdown();\n        } elseif ($msg === \"good\") {\n            $queue->ack($envelope->getDeliveryTag());\n        } else {\n            $queue->reject($envelope->getDeliveryTag(), AMQP_REQUEUE);\n        }\n    };\n\n    $queue_obj->consume(\"process_message\", AMQP_AUTOACK | AMQP_DURABLE, $consumerTag);\n\n\n    register_shutdown_function(function() use ($channel, $connection) {\n        try {\n            if ($channel) {\n                $channel->close();\n            }\n            if ($connection) {\n                $connection->close();\n            }\n        } catch (Exception $e) {\n            error_log(\"Shutdown error: \" . $e->getMessage());\n        }\n    });\n\n    while (count($channel->callbacks)) {\n        $channel->wait();\n    }\n\n}\n\n?>\n",
      "<?php\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection, $channel) {\n        $body = $message->getBody();\n        echo \"Received message: \" . $body . \"\\n\";\n\n        if ($body === \"quit\") {\n            $queue->ack($message->getDeliveryTag());\n            $channel->basic_cancel($queue->getConsumerTag());\n            return;\n        }\n\n        if ($body === \"good\") {\n            $queue->ack($message->getDeliveryTag());\n        } else {\n            $queue->reject($message->getDeliveryTag(), AMQP_REQUEUE);\n        }\n    };\n\n\n    $queue_obj->consume($callback, AMQP_AUTOACK, $consumerTag);\n\n\n    register_shutdown_function(function () use ($connection, $channel) {\n        echo \"Closing connection...\\n\";\n        try {\n            if ($channel) {\n                $channel->close();\n            }\n            if ($connection) {\n                $connection->close();\n            }\n        } catch (Exception $e) {\n            echo \"Error during shutdown: \" . $e->getMessage() . \"\\n\";\n        }\n    });\n\n    while ($channel->isConnected()) {\n    }\n}\n\n?>\n",
      "<?php\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection, $channel) {\n        $body = $message->getBody();\n        echo \"Received message: \" . $body . PHP_EOL;\n\n        if ($body === \"quit\") {\n            $queue->ack($message->getDeliveryTag());\n            $channel->basic_cancel($queue->getConsumerTag());\n            return;\n        }\n\n        if ($body === \"good\") {\n            $queue->ack($message->getDeliveryTag());\n        } else {\n            $queue->reject($message->getDeliveryTag(), AMQP_REQUEUE);\n        }\n    };\n\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, $callback);\n\n\n    while (count($channel->callbacks)) {\n        $channel->wait();\n    }\n\n    $channel->close();\n    $connection->close();\n}\n\n?>\n",
      "<?php\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    function process_message($envelope, $queue) {\n        $msg = $envelope->getBody();\n        echo \"Received message: \" . $msg . \"\\n\";\n\n        if ($msg === \"quit\") {\n            $queue->cancel($envelope->getDeliveryTag());\n            $queue->shutdown();\n        } elseif ($msg === \"good\") {\n            $queue->ack($envelope->getDeliveryTag());\n        } else {\n            $queue->reject($envelope->getDeliveryTag(), AMQP_REQUEUE);\n        }\n    };\n\n    $queue_obj->consume(\"process_message\", AMQP_AUTOACK | AMQP_DURABLE, $consumerTag);\n\n\n    register_shutdown_function(function() use ($channel, $connection) {\n        try {\n            if ($channel) {\n                $channel->close();\n            }\n            if ($connection) {\n                $connection->close();\n            }\n        } catch (Exception $e) {\n            error_log(\"Shutdown error: \" . $e->getMessage());\n        }\n    });\n\n    while (count($channel->callbacks)) {\n        $channel->wait();\n    }\n}\n\n?>\n",
      "<?php\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection, $channel) {\n        $body = $message->getBody();\n        echo \"Received message: \" . $body . PHP_EOL;\n\n        if ($body === \"quit\") {\n            $queue->ack($message->getDeliveryTag());\n            $channel->basic_cancel($queue->getConsumerTag());\n            return;\n        }\n\n        if ($body === \"good\") {\n            $queue->ack($message->getDeliveryTag());\n        } else {\n            $queue->reject($message->getDeliveryTag(), AMQP_REQUEUE);\n        }\n    };\n\n\n    $queue_obj->consume($callback, AMQP_AUTOACK, $consumerTag);\n\n\n    register_shutdown_function(function () use ($connection, $channel) {\n        try {\n            if ($channel) {\n                $channel->close();\n            }\n            if ($connection) {\n                $connection->close();\n            }\n        } catch (Exception $e) {\n            error_log(\"Shutdown error: \" . $e->getMessage());\n        }\n    });\n\n    while ($channel->isConnected()) {\n    }\n}\n\n?>\n",
      "<?php\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'login' => $user,\n        'password' => $pass,\n        'vhost' => $vhost\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection, &$callback, $consumerTag) {\n        $body = $message->getBody();\n        echo \"Received message: \" . $body . PHP_EOL;\n\n        if ($body === \"quit\") {\n            $queue->cancel($consumerTag);\n            $connection->disconnect();\n            return;\n        }\n\n        if ($body === \"good\") {\n            $queue->ack($message->getDeliveryTag());\n        } else {\n            $queue->reject($message->getDeliveryTag(), AMQP_REQUEUE);\n        }\n    };\n\n\n    $queue_obj->consume($callback, AMQP_AUTOACK, $consumerTag);\n\n\n    register_shutdown_function(function () use ($connection, $channel, $consumerTag, $queue_obj) {\n        try {\n            if (isset($queue_obj) && isset($consumerTag)) {\n                $queue_obj->cancel($consumerTag);\n            }\n            if (isset($channel)) {\n                $channel->close();\n            }\n            if (isset($connection) && $connection->isConnected()) {\n                $connection->disconnect();\n            }\n        } catch (Exception $e) {\n            error_log(\"Shutdown error: \" . $e->getMessage());\n        }\n    });\n\n    while ($connection->isConnected()) {\n    }\n}\n\n?>\n",
      "<?php\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'login' => $user,\n        'password' => $pass,\n        'vhost' => $vhost\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection, $channel, $consumerTag) {\n        $body = $message->getBody();\n        echo \"Received message: \" . $body . PHP_EOL;\n\n        if ($body === \"quit\") {\n            $queue->cancel($consumerTag);\n            $channel->close();\n            $connection->close();\n        } elseif ($body === \"good\") {\n            $queue->ack($message->getDeliveryTag());\n        } else {\n            $queue->reject($message->getDeliveryTag(), AMQP_REQUEUE);\n        }\n\n    };\n\n\n    $queue_obj->consume($callback, AMQP_AUTOACK, $consumerTag);\n\n\n    register_shutdown_function(function () use ($connection, $channel, $consumerTag, $queue_obj) {\n        echo \"Shutting down consumer...\\n\";\n        try {\n            if (isset($queue_obj)) {\n                $queue_obj->cancel($consumerTag);\n            }\n            if (isset($channel)) {\n                $channel->close();\n            }\n            if (isset($connection)) {\n                $connection->close();\n            }\n        } catch (Exception $e) {\n            error_log(\"Shutdown error: \" . $e->getMessage());\n        }\n    });\n\n}\n\n?>\n",
      "<?php\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass,\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection, $channel, $consumerTag) {\n        $body = $message->getBody();\n        echo \"Received message: \" . $body . \"\\n\";\n\n        if ($body === \"quit\") {\n            $queue->cancel($consumerTag);\n            $channel->close();\n            $connection->close();\n        } elseif ($body === \"good\") {\n            $queue->ack($message->getDeliveryTag());\n        } else {\n            $queue->reject($message->getDeliveryTag(), AMQP_REQUEUE);\n        }\n    };\n\n\n    $queue_obj->consume($callback, AMQP_AUTOACK, $consumerTag);\n\n\n    register_shutdown_function(function () use ($connection, $channel, $consumerTag, $queue_obj) {\n        echo \"Shutting down...\\n\";\n        try {\n            if (isset($queue_obj)) {\n                $queue_obj->cancel($consumerTag);\n            }\n            if (isset($channel)) {\n                $channel->close();\n            }\n            if (isset($connection)) {\n                $connection->close();\n            }\n        } catch (Exception $e) {\n            error_log(\"Shutdown error: \" . $e->getMessage());\n        }\n    });\n\n    while ($connection->isConnected()) {\n    }\n}\n\n?>\n",
      "<?php\n\nfunction consume_messages($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'login' => $user,\n        'password' => $pass,\n        'vhost' => $vhost\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection, $channel, $consumerTag) {\n        $body = $message->getBody();\n        echo \"Received message: \" . $body . \"\\n\";\n\n        if ($body === \"quit\") {\n            $queue->cancel($consumerTag);\n            $channel->close();\n            $connection->close();\n        } elseif ($body === \"good\") {\n            $queue->ack($message->getDeliveryTag());\n        } else {\n            $queue->reject($message->getDeliveryTag(), AMQP_REQUEUE);\n        }\n    };\n\n\n    $queue_obj->consume($callback, AMQP_AUTOACK, $consumerTag);\n\n\n    register_shutdown_function(function () use ($connection, $channel, $consumerTag, $queue_obj) {\n        echo \"Shutting down...\\n\";\n        try {\n            if (isset($queue_obj)) {\n                $queue_obj->cancel($consumerTag);\n            }\n            if (isset($channel)) {\n                $channel->close();\n            }\n            if (isset($connection)) {\n                $connection->close();\n            }\n        } catch (Exception $e) {\n            error_log(\"Shutdown error: \" . $e->getMessage());\n        }\n    });\n\n    while (count($connection->callbacks)) {\n        $connection->wait();\n    }\n}\n\n?>\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Implement a PHP function that establishes a RabbitMQ consumer to process messages from a specified queue. The function should handle connection setup, message consumption, and proper cleanup.\n\nFunction Description: The function `start_rabbitmq_consumer` initializes a RabbitMQ consumer that connects to a specified server, declares a queue and exchange, binds them, and starts consuming messages. It processes each message using a callback function and handles graceful shutdown.\n\nInput:\n- `$host` (string): RabbitMQ server hostname or IP address\n- `$port` (int): RabbitMQ server port number\n- `$user` (string): RabbitMQ username for authentication\n- `$pass` (string): RabbitMQ password for authentication\n- `$vhost` (string): RabbitMQ virtual host\n- `$exchange` (string): Name of the exchange to bind to\n- `$queue` (string): Name of the queue to consume messages from\n\nOutput: None (The function runs continuously until terminated or until receiving a 'quit' message)",
    "Canonical_solution": "function start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue)\n{\n    require_once __DIR__ . '/config.php';\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\n    $consumerTag = 'consumer' . getmypid();\n\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->queue_declare($queue, false, false, false, true);\n    $channel->exchange_declare($exchange, AMQPExchangeType::FANOUT, false, false, true);\n    $channel->queue_bind($queue, $exchange);\n\n    function process_message($message)\n    {\n        echo \"\\n--------\\n\";\n        echo $message->body;\n        echo \"\\n--------\\n\";\n\n        $message->ack();\n\n        if ($message->body === 'quit') {\n            $message->getChannel()->basic_cancel($message->getConsumerTag());\n        }\n    }\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, 'process_message');\n\n    function shutdown($channel, $connection)\n    {\n        $channel->close();\n        $connection->close();\n    }\n\n    register_shutdown_function('shutdown', $channel, $connection);\n\n    $channel->consume();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 143,
    "matched_results": [],
    "unmatched_results": [
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    echo \" [*] Waiting for messages. To exit press CTRL+C\\n\";\n\n    $callback = function ($msg) use ($channel, $connection) {\n        echo ' [x] Received ', $msg->body, \"\\n\";\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n            $channel->close();\n            $connection->close();\n            exit;\n        }\n        $msg->ack();\n    };\n\n    $channel->basic_qos(null, 1, null);\n    $channel->basic_consume($queue, '', false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    echo ' [*] Waiting for messages. To exit press CTRL+C', \"\\n\";\n\n    $callback = function ($msg) use ($channel, $connection) {\n        echo \" [x] Received \", $msg->body, \"\\n\";\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n            $channel->close();\n            $connection->close();\n            exit;\n        }\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n    };\n\n    $channel->basic_qos(null, 1, null);\n    $channel->basic_consume($queue, '', false, false, false, false, $callback);\n\n    while (count($channel->callbacks)) {\n        $channel->wait();\n    }\n}\n\n?>\n\n```",
      "<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    echo \" [*] Waiting for messages. To exit press CTRL+C\\n\";\n\n    $callback = function ($msg) use ($channel, $connection) {\n        echo ' [x] Received ', $msg->body, \"\\n\";\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n            $channel->close();\n            $connection->close();\n            exit;\n        }\n        $msg->ack();\n    };\n\n    $channel->basic_qos(null, 1, null);\n    $channel->basic_consume($queue, '', false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n}\n\n?>\n",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    echo \" [*] Waiting for messages. To exit press CTRL+C\\n\";\n\n    $callback = function ($msg) use ($channel, $connection) {\n        echo ' [x] Received ', $msg->body, \"\\n\";\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n            $channel->close();\n            $connection->close();\n            exit;\n        }\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n    };\n\n    $channel->basic_qos(null, 1, null);\n    $channel->basic_consume($queue, '', false, false, false, false, $callback);\n\n    while (count($channel->callbacks)) {\n        $channel->wait();\n    }\n}\n\n?>\n\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    echo \" [*] Waiting for messages. To exit press CTRL+C\\n\";\n\n    $callback = function ($msg) use ($channel, $connection) {\n        echo ' [x] Received ', $msg->body, \"\\n\";\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n            $channel->close();\n            $connection->close();\n            exit;\n        }\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n    };\n\n    $channel->basic_qos(null, 1, null);\n    $channel->basic_consume($queue, '', false, false, false, false, $callback);\n\n    while (count($channel->callbacks)) {\n        $channel->wait();\n    }\n}\n\n?>\n\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    echo ' [*] Waiting for messages. To exit press CTRL+C', \"\\n\";\n\n    $callback = function ($msg) use ($channel, $connection) {\n        echo \" [x] Received \", $msg->body, \"\\n\";\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n            $channel->close();\n            $connection->close();\n            exit;\n        }\n        $msg->ack();\n    };\n\n    $channel->basic_qos(null, 1, null);\n    $channel->basic_consume($queue, '', false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    echo ' [*] Waiting for messages. To exit press CTRL+C', \"\\n\";\n\n    $callback = function ($msg) use ($channel, $connection) {\n        echo \" [x] Received \", $msg->body, \"\\n\";\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n            $channel->close();\n            $connection->close();\n            exit;\n        }\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n    };\n\n    $channel->basic_qos(null, 1, null);\n    $channel->basic_consume($queue, '', false, false, false, false, $callback);\n\n    while (count($channel->callbacks)) {\n        $channel->wait();\n    }\n}\n\n?>\n\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    echo \" [*] Waiting for messages. To exit press CTRL+C\\n\";\n\n    $callback = function ($msg) use ($channel, $connection) {\n        echo ' [x] Received ', $msg->body, \"\\n\";\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n            $channel->close();\n            $connection->close();\n            exit;\n        }\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n    };\n\n    $channel->basic_qos(null, 1, null);\n    $channel->basic_consume($queue, '', false, false, false, false, $callback);\n\n    while (count($channel->callbacks)) {\n        $channel->wait();\n    }\n}\n\n?>\n\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    echo ' [*] Waiting for messages. To exit press CTRL+C', \"\\n\";\n\n    $callback = function ($msg) use ($channel, $connection) {\n        echo \" [x] Received \", $msg->body, \"\\n\";\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n            $channel->close();\n            $connection->close();\n            exit;\n        }\n        $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);\n\n    };\n\n    $channel->basic_qos(null, 1, null);\n    $channel->basic_consume($queue, '', false, false, false, false, $callback);\n\n    while (count($channel->callbacks)) {\n        $channel->wait();\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare($exchange, 'direct', false, true, false);\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->queue_bind($queue, $exchange, $queue);\n\n    echo \" [*] Waiting for messages. To exit press CTRL+C\\n\";\n\n    $callback = function ($msg) use ($channel, $connection) {\n        echo ' [x] Received ', $msg->body, \"\\n\";\n        if ($msg->body === 'quit') {\n            $channel->basic_cancel($msg->getDeliveryTag());\n            $channel->close();\n            $connection->close();\n            exit;\n        }\n        $msg->ack();\n    };\n\n    $channel->basic_qos(null, 1, null);\n    $channel->basic_consume($queue, '', false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        $channel->wait();\n    }\n}\n\n?>\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 117,
    "Instruction": "Task Description: Implement a PHP function that establishes a RabbitMQ consumer to process messages from a specified queue. The function should handle connection setup, message consumption, and proper cleanup.\n\nFunction Description: The function `start_rabbitmq_consumer` initializes a RabbitMQ consumer that connects to a specified server, declares a queue and exchange, binds them, and starts consuming messages. It processes each message using a callback function and handles graceful shutdown.\n\nInput:\n- `$host` (string): The hostname of the RabbitMQ server.\n- `$port` (int): The port number of the RabbitMQ server.\n- `$user` (string): The username for RabbitMQ authentication.\n- `$pass` (string): The password for RabbitMQ authentication.\n- `$vhost` (string): The virtual host to connect to.\n- `$exchange` (string): The name of the exchange to declare.\n- `$queue` (string): The name of the queue to declare and consume from.\n\nOutput: None. The function runs indefinitely until a 'quit' message is received or the process is terminated. Messages are processed and acknowledged, and connections are closed upon shutdown.",
    "Canonical_solution": "function start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue)\n{\n    require_once __DIR__ . '/config.php';\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\n    $consumerTag = 'consumer' . getmypid();\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->queue_declare($queue, false, false, false, true);\n    $channel->exchange_declare($exchange, AMQPExchangeType::FANOUT, false, false, true);\n    $channel->queue_bind($queue, $exchange);\n\n    function process_message($message)\n    {\n        echo \"\\n--------\\n\";\n        echo $message->body;\n        echo \"\\n--------\\n\";\n\n        $message->ack();\n\n        if ($message->body === 'quit') {\n            $message->getChannel()->basic_cancel($message->getConsumerTag());\n        }\n    }\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, 'process_message');\n\n    function shutdown($channel, $connection)\n    {\n        $channel->close();\n        $connection->close();\n    }\n\n    register_shutdown_function('shutdown', $channel, $connection);\n    $channel->consume();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 143,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection) {\n        echo \"Received message: \" . $message->getBody() . \"\\n\";\n        $queue->ack($message->getDeliveryTag());\n\n        if ($message->getBody() === 'quit') {\n            $queue->cancel($message->getConsumerTag());\n            $connection->disconnect();\n        }\n    };\n\n    $queue_obj->consume($callback);\n}\n\n?>\n",
      "<?php\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName($exchange);\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->setFlags(AMQP_DURABLE);\n    $exchange->declareExchange();\n\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName($queue);\n    $queue->setFlags(AMQP_DURABLE);\n    $queue->declareQueue();\n\n    $queue->bind($exchange->getName(), $queue->getName());\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection) {\n        $msg = $message->getBody();\n        echo \"Received: \" . $msg . PHP_EOL;\n        if ($msg === 'quit') {\n            $queue->ack($message->getDeliveryTag());\n            $connection->disconnect();\n            exit();\n        }\n        $queue->ack($message->getDeliveryTag());\n\n    };\n\n    $queue->consume($callback);\n\n\n}\n\n?>\n",
      "```php\n<?php\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $channel->qos(0, 1);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection) {\n        $msg_body = $message->getBody();\n        echo \"Received message: \" . $msg_body . \"\\n\";\n\n        if ($msg_body === 'quit') {\n            $queue->ack($message->getDeliveryTag());\n            $connection->disconnect();\n            exit();\n        }\n\n        $queue->ack($message->getDeliveryTag());\n\n    };\n\n    $queue_obj->consume($callback);\n\n\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection) {\n        echo \"Received message: \" . $message->getBody() . \"\\n\";\n        $queue->ack($message->getDeliveryTag());\n\n        if ($message->getBody() === 'quit') {\n            $queue->cancel($message->getConsumerTag());\n            $connection->disconnect();\n        }\n    };\n\n    $queue_obj->consume($callback);\n\n\n}\n\n?>\n```",
      "<?php\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection) {\n        $msg_body = $message->getBody();\n        echo \"Received message: \" . $msg_body . \"\\n\";\n\n        if ($msg_body === 'quit') {\n            $queue->ack($message->getDeliveryTag());\n            $connection->disconnect();\n            exit();\n        }\n\n        $queue->ack($message->getDeliveryTag());\n    };\n\n\n    $queue_obj->consume($callback);\n\n\n    while ($connection->isConnected()) {\n\n    }\n}\n\n?>\n",
      "```php\n<?php\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName($exchange);\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->setFlags(AMQP_DURABLE);\n    $exchange->declareExchange();\n\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName($queue);\n    $queue->setFlags(AMQP_DURABLE);\n    $queue->declareQueue();\n\n    $queue->bind($exchange->getName(), $queue->getName());\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection) {\n        $msg = $message->getBody();\n        echo \"Received: \" . $msg . PHP_EOL;\n        if ($msg === 'quit') {\n            $queue->ack($message->getDeliveryTag());\n            $connection->disconnect();\n            exit();\n        }\n        $queue->ack($message->getDeliveryTag());\n    };\n\n    $queue->consume($callback);\n}\n\n?>\n```",
      "<?php\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection) {\n        $msg = $message->getBody();\n        echo \"Received: \" . $msg . PHP_EOL;\n\n        if ($msg === 'quit') {\n            $queue->ack($message->getDeliveryTag());\n            $connection->disconnect();\n            exit();\n        }\n\n        $queue->ack($message->getDeliveryTag());\n\n    };\n\n    $queue_obj->consume($callback);\n\n\n}\n\n?>\n",
      "```php\n<?php\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection) {\n        echo \"Received message: \" . $message->getBody() . \"\\n\";\n        $queue->ack($message->getDeliveryTag());\n\n        if ($message->getBody() === 'quit') {\n            $queue->cancel($message->getConsumerTag());\n            $connection->disconnect();\n        }\n    };\n\n    $queue_obj->consume($callback);\n\n\n}\n\n\n?>\n```",
      "```php\n<?php\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName($exchange);\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->setFlags(AMQP_DURABLE);\n    $exchange->declareExchange();\n\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName($queue);\n    $queue->setFlags(AMQP_DURABLE);\n    $queue->declareQueue();\n\n    $queue->bind($exchange->getName(), $queue->getName());\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $q) use ($connection) {\n        echo $message->getBody() . PHP_EOL;\n        $q->ack($message->getDeliveryTag());\n\n        if ($message->getBody() === 'quit') {\n            $q->cancel($message->getConsumerTag());\n            $connection->disconnect();\n        }\n    };\n\n    $queue->consume($callback);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass,\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n\n    $exchange_obj = new AMQPExchange($channel);\n    $exchange_obj->setName($exchange);\n    $exchange_obj->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange_obj->setFlags(AMQP_DURABLE);\n    $exchange_obj->declareExchange();\n\n\n    $queue_obj = new AMQPQueue($channel);\n    $queue_obj->setName($queue);\n    $queue_obj->setFlags(AMQP_DURABLE);\n    $queue_obj->declareQueue();\n\n    $queue_obj->bind($exchange, $queue);\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) use ($connection) {\n        echo \"Received message: \" . $message->getBody() . \"\\n\";\n        $queue->ack($message->getDeliveryTag());\n\n        if ($message->getBody() === 'quit') {\n            $queue->cancel($message->getConsumerTag());\n            $connection->disconnect();\n        }\n    };\n\n    $queue_obj->consume($callback);\n}\n\n?>\n\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a PHP function that consumes messages from a RabbitMQ queue using headers-based routing. The function should establish a connection to RabbitMQ, declare an exchange and queue, bind the queue with specified headers, and process incoming messages with a callback function.\n\nFunction Description: The function `consume_rabbitmq_messages` connects to a RabbitMQ server, sets up a headers-based exchange, declares a temporary queue, binds the queue with the provided headers, and starts consuming messages. It processes each message using a callback function that displays the message body and headers. The function handles timeouts gracefully and cleans up resources after processing.\n\nInput: \n- `$headers` (array): An array of strings in the format \"key=value\" representing the headers to bind the queue with.\n\nOutput: \n- Returns `true` if the function executes successfully.\n- Returns `false` if the input headers are empty.\n- Outputs message details to stdout and may write errors to stderr.",
    "Canonical_solution": "function consume_rabbitmq_messages($headers)\n{\n    require __DIR__ . '/config.php';\n    \n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exception\\AMQPTimeoutException;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n    use PhpAmqpLib\\Wire\\AMQPTable;\n\n    if (empty($headers)) {\n        file_put_contents('php://stderr', \"Usage: $argv[0] [header1=value1] [header2=value2]\\n\");\n        return false;\n    }\n\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchangeName = 'topic_headers_test';\n    $channel->exchange_declare($exchangeName, AMQPExchangeType::HEADERS);\n\n    list($queueName, ,) = $channel->queue_declare('', false, false, true);\n\n    $bindArguments = [];\n    foreach ($headers as $header) {\n        list ($key, $value) = explode('=', $header, 2);\n        $bindArguments[$key] = $value;\n    }\n\n    $channel->queue_bind($queueName, $exchangeName, '', false, new AMQPTable($bindArguments));\n\n    $callback = function (AMQPMessage $message) {\n        echo PHP_EOL . ' [x] ', $message->getRoutingKey(), ':', $message->getBody(), \"\\n\";\n        echo 'Message headers follows' . PHP_EOL;\n        var_dump($message->get('application_headers')->getNativeData());\n        echo PHP_EOL;\n    };\n\n    $channel->basic_consume($queueName, '', false, true, true, false, $callback);\n    while ($channel->is_consuming()) {\n        try {\n            $channel->wait(null, false, 2);\n        } catch (AMQPTimeoutException $exception) {\n        }\n        echo '*' . PHP_EOL;\n    }\n\n    $channel->close();\n    $connection->close();\n    return true;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 143,
    "matched_results": [
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction consume_rabbitmq_messages(array $headers): bool\n{\n    if (empty($headers)) {\n        return false;\n    }\n\n    $connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');\n    $channel = $connection->channel();\n\n    $exchangeName = 'headers_exchange';\n    $channel->exchange_declare($exchangeName, 'headers', false, true, false);\n\n    list($queueName, ,) = $channel->queue_declare('', false, false, true, false);\n\n    $headersTable = new AMQPTable();\n    foreach ($headers as $header) {\n        [$key, $value] = explode('=', $header);\n        $headersTable->set($key, $value);\n    }\n\n    $channel->queue_bind($queueName, $exchangeName, '', false, $headersTable);\n\n\n    $callback = function (AMQPMessage $msg) {\n        echo \"Message Body: \" . $msg->body . PHP_EOL;\n        echo \"Message Headers: \" . json_encode($msg->get('application_headers')->getNativeData()) . PHP_EOL;\n        $msg->ack();\n    };\n\n    $channel->basic_consume($queueName, '', false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        try {\n            $channel->wait(null, false, 3);\n        } catch (PhpAmqpLib\\Exception\\AMQPTimeoutException $e) {\n            echo \"Timeout reached. Exiting gracefully.\" . PHP_EOL;\n            break; \n        }\n    }\n\n\n    $channel->close();\n    $connection->close();\n\n    return true;\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction consume_rabbitmq_messages(array $headers): bool\n{\n    if (empty($headers)) {\n        return false;\n    }\n\n    $connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');\n    $channel = $connection->channel();\n\n    $exchangeName = 'headers_exchange';\n    $channel->exchange_declare($exchangeName, 'headers', false, true, false);\n\n    list($queueName, ,) = $channel->queue_declare('', false, false, true, false);\n\n    $headersTable = new AMQPTable();\n    foreach ($headers as $header) {\n        [$key, $value] = explode('=', $header);\n        $headersTable->set($key, $value);\n    }\n\n    $channel->queue_bind($queueName, $exchangeName, '', false, $headersTable);\n\n\n    $callback = function (AMQPMessage $msg) {\n        echo \"Message Body: \" . $msg->body . PHP_EOL;\n        echo \"Message Headers: \" . json_encode($msg->get('application_headers')->getNativeData()) . PHP_EOL;\n        $msg->ack();\n    };\n\n    $channel->basic_consume($queueName, '', false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        try {\n            $channel->wait(null, false, 5); // Timeout after 5 seconds\n        } catch (PhpAmqpLib\\Exception\\AMQPTimeoutException $e) {\n            echo \"Timeout reached. Exiting consumer.\" . PHP_EOL;\n            break; \n        } catch (Exception $e) {\n            fwrite(STDERR, \"Error: \" . $e->getMessage() . PHP_EOL);\n            break;\n        }\n    }\n\n    $channel->close();\n    $connection->close();\n\n    return true;\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\nfunction consume_rabbitmq_messages(array $headers): bool\n{\n    if (empty($headers)) {\n        return false;\n    }\n\n    $connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');\n    $channel = $connection->channel();\n\n    $exchange = 'headers_exchange';\n    $queue = '';\n    $consumer_tag = '';\n\n    try {\n        $channel->exchange_declare($exchange, AMQPExchangeType::HEADERS, false, true, false);\n        list($queue, ,) = $channel->queue_declare($queue, false, false, true, false);\n\n        $headers_array = [];\n        foreach ($headers as $header) {\n            list($key, $value) = explode('=', $header);\n            $headers_array[$key] = $value;\n        }\n\n        $channel->queue_bind($queue, $exchange, '', $headers_array);\n\n        $callback = function (AMQPMessage $msg) {\n            echo \"Message Body: \" . $msg->body . PHP_EOL;\n            echo \"Message Headers: \" . json_encode($msg->get('application_headers')->getNativeData()) . PHP_EOL;\n            $msg->ack();\n        };\n\n        $consumer_tag = $channel->basic_consume($queue, '', false, false, false, false, $callback);\n\n        while ($channel->is_consuming()) {\n            $channel->wait(null, false, 3); // Timeout after 3 seconds\n        }\n\n    } catch (Exception $e) {\n        fwrite(STDERR, \"Error: \" . $e->getMessage() . PHP_EOL);\n    } finally {\n        if (!empty($consumer_tag)) {\n            $channel->basic_cancel($consumer_tag);\n        }\n        $channel->close();\n        $connection->close();\n    }\n\n    return true;\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction consume_rabbitmq_messages(array $headers): bool\n{\n    if (empty($headers)) {\n        return false;\n    }\n\n    $connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');\n    $channel = $connection->channel();\n\n    $exchangeName = 'headers_exchange';\n    $channel->exchange_declare($exchangeName, 'headers', false, true, false);\n\n    list($queueName, ,) = $channel->queue_declare('', false, false, true, false);\n\n    $headersTable = new AMQPTable();\n    foreach ($headers as $header) {\n        [$key, $value] = explode('=', $header);\n        $headersTable->set($key, $value);\n    }\n\n    $channel->queue_bind($queueName, $exchangeName, '', false, $headersTable);\n\n\n    $callback = function (AMQPMessage $msg) {\n        echo \"Message Body: \" . $msg->body . PHP_EOL;\n        echo \"Message Headers: \" . json_encode($msg->get('application_headers')->getNativeData()) . PHP_EOL;\n        $msg->ack();\n    };\n\n    $channel->basic_consume($queueName, '', false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        try {\n            $channel->wait(null, false, 5); // Timeout after 5 seconds\n        } catch (PhpAmqpLib\\Exception\\AMQPTimeoutException $e) {\n            echo \"Timeout reached. Exiting consumer.\" . PHP_EOL;\n            break; \n        } catch (Exception $e) {\n            fwrite(STDERR, \"Error: \" . $e->getMessage() . PHP_EOL);\n            break;\n        }\n    }\n\n    $channel->close();\n    $connection->close();\n\n    return true;\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction consume_rabbitmq_messages(array $headers): bool\n{\n    if (empty($headers)) {\n        return false;\n    }\n\n    $connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');\n    $channel = $connection->channel();\n\n    $exchangeName = 'headers_exchange';\n    $channel->exchange_declare($exchangeName, 'headers', false, true, false);\n\n    list($queueName, ,) = $channel->queue_declare('', false, false, true, false);\n\n    $headersTable = new AMQPTable();\n    foreach ($headers as $header) {\n        [$key, $value] = explode('=', $header);\n        $headersTable->set($key, $value);\n    }\n\n    $channel->queue_bind($queueName, $exchangeName, '', false, $headersTable);\n\n\n    $callback = function (AMQPMessage $msg) {\n        echo \"Message Body: \" . $msg->body . PHP_EOL;\n        echo \"Message Headers: \" . json_encode($msg->get('application_headers')->getNativeData()) . PHP_EOL;\n        $msg->ack();\n    };\n\n\n    $channel->basic_consume($queueName, '', false, false, false, false, $callback);\n\n\n    while ($channel->is_consuming()) {\n        try {\n            $channel->wait(null, false, 5); // Timeout after 5 seconds\n        } catch (PhpAmqpLib\\Exception\\AMQPTimeoutException $e) {\n            echo \"Timeout reached. Exiting consumer.\" . PHP_EOL;\n            break;\n        } catch (Exception $e) {\n            fwrite(STDERR, \"Error: \" . $e->getMessage() . PHP_EOL);\n            break; \n        }\n    }\n\n    $channel->close();\n    $connection->close();\n\n    return true;\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction consume_rabbitmq_messages(array $headers): bool\n{\n    if (empty($headers)) {\n        return false;\n    }\n\n    $connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');\n    $channel = $connection->channel();\n\n    $exchangeName = 'headers_exchange';\n    $channel->exchange_declare($exchangeName, 'headers', false, true, false);\n\n    list($queueName, ,) = $channel->queue_declare('', false, false, true, false);\n\n\n    $headersTable = new AMQPTable();\n    foreach ($headers as $header) {\n        [$key, $value] = explode('=', $header);\n        $headersTable->set($key, $value);\n    }\n\n    $channel->queue_bind($queueName, $exchangeName, '', false, $headersTable);\n\n\n    $callback = function (AMQPMessage $msg) {\n        echo \"Message Body: \" . $msg->body . PHP_EOL;\n        echo \"Message Headers: \" . json_encode($msg->get('application_headers')->getNativeData()) . PHP_EOL;\n        $msg->ack();\n    };\n\n    $channel->basic_consume($queueName, '', false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        try {\n            $channel->wait(null, false, 5); // Timeout after 5 seconds\n        } catch (PhpAmqpLib\\Exception\\AMQPTimeoutException $e) {\n            echo \"Timeout reached. Exiting consumer.\" . PHP_EOL;\n            break;\n        } catch (Exception $e) {\n            fwrite(STDERR, \"Error: \" . $e->getMessage() . PHP_EOL);\n            break;\n        }\n    }\n\n    $channel->close();\n    $connection->close();\n\n    return true;\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction consume_rabbitmq_messages(array $headers): bool\n{\n    if (empty($headers)) {\n        return false;\n    }\n\n    $connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');\n    $channel = $connection->channel();\n\n    $exchangeName = 'headers_exchange';\n    $channel->exchange_declare($exchangeName, 'headers', false, true, false);\n\n    list($queueName, ,) = $channel->queue_declare('', false, false, true, false);\n\n    $headersTable = new AMQPTable();\n    foreach ($headers as $header) {\n        [$key, $value] = explode('=', $header);\n        $headersTable->set($key, $value);\n    }\n\n    $channel->queue_bind($queueName, $exchangeName, '', false, $headersTable);\n\n\n    $callback = function (AMQPMessage $msg) {\n        echo \"Message Body: \" . $msg->body . PHP_EOL;\n        echo \"Message Headers: \" . json_encode($msg->get('application_headers')->getNativeData()) . PHP_EOL;\n        $msg->ack();\n    };\n\n    $channel->basic_consume($queueName, '', false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        try {\n            $channel->wait(null, false, 5); // Timeout after 5 seconds\n        } catch (PhpAmqpLib\\Exception\\AMQPTimeoutException $e) {\n            echo \"Timeout reached. Exiting consumer.\" . PHP_EOL;\n            break; \n        } catch (Exception $e) {\n            fwrite(STDERR, \"Error: \" . $e->getMessage() . PHP_EOL);\n            break;\n        }\n    }\n\n    $channel->close();\n    $connection->close();\n\n    return true;\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction consume_rabbitmq_messages(array $headers): bool\n{\n    if (empty($headers)) {\n        return false;\n    }\n\n    $connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');\n    $channel = $connection->channel();\n\n    $exchangeName = 'headers_exchange';\n    $channel->exchange_declare($exchangeName, 'headers', false, true, false);\n\n    list($queueName, ,) = $channel->queue_declare('', false, false, true, false);\n\n    $headersTable = new AMQPTable();\n    foreach ($headers as $header) {\n        [$key, $value] = explode('=', $header);\n        $headersTable->set($key, $value);\n    }\n\n    $channel->queue_bind($queueName, $exchangeName, '', false, $headersTable);\n\n\n    $callback = function (AMQPMessage $msg) {\n        echo \"Message Body: \" . $msg->body . PHP_EOL;\n        echo \"Message Headers: \" . json_encode($msg->get('application_headers')->getNativeData()) . PHP_EOL;\n        $msg->ack();\n    };\n\n    $channel->basic_consume($queueName, '', false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        try {\n            $channel->wait(null, false, 5); // Timeout after 5 seconds\n        } catch (PhpAmqpLib\\Exception\\AMQPTimeoutException $e) {\n            echo \"Timeout reached. Exiting consumer.\" . PHP_EOL;\n            break;\n        } catch (Exception $e) {\n            fwrite(STDERR, \"Error: \" . $e->getMessage() . PHP_EOL);\n            break; \n        }\n    }\n\n    $channel->close();\n    $connection->close();\n\n    return true;\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction consume_rabbitmq_messages(array $headers): bool\n{\n    if (empty($headers)) {\n        return false;\n    }\n\n    $connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');\n    $channel = $connection->channel();\n\n    $exchangeName = 'headers_exchange';\n    $channel->exchange_declare($exchangeName, 'headers', false, true, false);\n\n    list($queueName, ,) = $channel->queue_declare('', false, false, true, false);\n\n    $headersTable = new AMQPTable();\n    foreach ($headers as $header) {\n        [$key, $value] = explode('=', $header);\n        $headersTable->set($key, $value);\n    }\n\n    $channel->queue_bind($queueName, $exchangeName, '', false, $headersTable);\n\n\n    $callback = function (AMQPMessage $msg) {\n        echo \"Message Body: \" . $msg->body . PHP_EOL;\n        echo \"Message Headers: \" . json_encode($msg->get('application_headers')->getNativeData()) . PHP_EOL;\n        $msg->ack();\n    };\n\n    $channel->basic_consume($queueName, '', false, false, false, false, $callback);\n\n    while ($channel->is_consuming()) {\n        try {\n            $channel->wait(null, false, 3);\n        } catch (PhpAmqpLib\\Exception\\AMQPTimeoutException $e) {\n            echo \"Timeout reached. Exiting gracefully.\" . PHP_EOL;\n            break; \n        }\n    }\n\n\n    $channel->close();\n    $connection->close();\n\n    return true;\n}\n\n?>\n```"
    ],
    "unmatched_results": [
      "```php\n<?php\n\nfunction consume_rabbitmq_messages(array $headers): bool\n{\n    if (empty($headers)) {\n        return false;\n    }\n\n    $connection = new AMQPConnection([\n        'host' => 'localhost',\n        'port' => 5672,\n        'vhost' => '/',\n        'login' => 'guest',\n        'password' => 'guest',\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('headers_exchange');\n    $exchange->setType(AMQP_EX_TYPE_HEADERS);\n    $exchange->setFlags(AMQP_DURABLE);\n    $exchange->declareExchange();\n\n\n    $queue = new AMQPQueue($channel);\n    $queue->setFlags(AMQP_EXCLUSIVE);\n    $queueName = $queue->getName();\n    $queue->declareQueue();\n\n    $headers_array = [];\n    foreach ($headers as $header) {\n        list($key, $value) = explode('=', $header);\n        $headers_array[$key] = $value;\n    }\n\n    $queue->bind('headers_exchange', '', $headers_array);\n\n\n    $callback = function (AMQPEnvelope $message, AMQPQueue $queue) {\n        echo \"Message Body: \" . $message->getBody() . PHP_EOL;\n        echo \"Message Headers: \" . json_encode($message->getHeaders()) . PHP_EOL;\n        $queue->ack($message->getDeliveryTag());\n    };\n\n\n    $queue->consume($callback, AMQP_AUTOACK);\n\n\n    $connection->disconnect();\n    return true;\n}\n\n?>\n```"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a function that sends multiple messages to a RabbitMQ queue using PHP and measures the execution time for the operation.\n\nFunction Description: The function establishes a connection to a RabbitMQ server, creates a temporary queue, sends a specified number of messages with the given content, and returns the total time taken to complete the operation. Each message is sent through a newly created channel, and the temporary queue is automatically deleted after use.\n\nInput:\n- $max_messages: [int] - The number of messages to send.\n- $host: [string] - The hostname or IP address of the RabbitMQ server.\n- $port: [int] - The port number of the RabbitMQ server.\n- $user: [string] - The username for RabbitMQ authentication.\n- $pass: [string] - The password for RabbitMQ authentication.\n- $vhost: [string] - The virtual host to connect to on the RabbitMQ server.\n- $message_body: [string] - The content of the message to be sent.\n\nOutput:\n- [float] - The total execution time in seconds for sending all messages, or false if the connection fails.",
    "Canonical_solution": "function send_rabbitmq_messages($max_messages, $host, $port, $user, $pass, $vhost, $message_body)\n{\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n\n    $conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    if (!$conn) {\n        return false;\n    }\n\n    $time = microtime(true);\n\n    for ($i = 0; $i < $max_messages; $i++) {\n        $ch = $conn->channel();\n        list($queue,) = $ch->queue_declare('', false, false, true, true);\n        $msg = new AMQPMessage($message_body);\n        $ch->basic_publish($msg, '', $queue);\n        $ch->close();\n    }\n\n    $execution_time = microtime(true) - $time;\n    $conn->close();\n\n    return $execution_time;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 142,
    "matched_results": [],
    "unmatched_results": [
      "<?php\nfunction sendMultipleMessagesToRabbitMQ(int $max_messages, string $host, int $port, string $user, string $pass, string $vhost, string $message_body): float|false {\n    $start_time = microtime(true);\n\n    try {\n        $connection = new AMQPConnection([\n            'host' => $host,\n            'port' => $port,\n            'vhost' => $vhost,\n            'login' => $user,\n            'password' => $pass\n        ]);\n        $connection->connect();\n\n        if (!$connection->isConnected()) {\n            return false;\n        }\n\n\n        $channel = new AMQPChannel($connection);\n        $queue = new AMQPQueue($channel);\n        $queue->setFlags(AMQP_AUTODELETE);\n        $queue->declareQueue();\n\n\n        for ($i = 0; $i < $max_messages; $i++) {\n            $tempChannel = new AMQPChannel($connection);\n            $message = new AMQPMessage($message_body);\n            $tempChannel->basic_publish($message, '', $queue->getName());\n        }\n\n        $connection->disconnect();\n\n        $end_time = microtime(true);\n        return $end_time - $start_time;\n\n    } catch (AMQPConnectionException $e) {\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction sendMultipleMessagesToRabbitMQ(int $max_messages, string $host, int $port, string $user, string $pass, string $vhost, string $message_body): float|false {\n    $start_time = microtime(true);\n\n    try {\n        $connection = new AMQPConnection([\n            'host' => $host,\n            'port' => $port,\n            'vhost' => $vhost,\n            'login' => $user,\n            'password' => $pass\n        ]);\n        $connection->connect();\n\n        if (!$connection->isConnected()) {\n            return false;\n        }\n\n\n        $channel = new AMQPChannel($connection);\n        $queue = new AMQPQueue($channel);\n        $queue->setFlags(AMQP_AUTODELETE);\n        $queue->declareQueue();\n\n\n        for ($i = 0; $i < $max_messages; $i++) {\n            $tempChannel = new AMQPChannel($connection);\n            $message = new AMQPMessage($message_body);\n            $tempChannel->basic_publish($message, '', $queue->getName());\n        }\n\n        $connection->disconnect();\n        $end_time = microtime(true);\n        return $end_time - $start_time;\n\n    } catch (AMQPConnectionException $e) {\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction sendMultipleMessagesToRabbitMQ(int $max_messages, string $host, int $port, string $user, string $pass, string $vhost, string $message_body): float|false {\n    $start_time = microtime(true);\n\n    try {\n        $connection = new AMQPConnection([\n            'host' => $host,\n            'port' => $port,\n            'vhost' => $vhost,\n            'login' => $user,\n            'password' => $pass\n        ]);\n        $connection->connect();\n\n        if (!$connection->isConnected()) {\n            return false;\n        }\n\n\n        $channel = new AMQPChannel($connection);\n        $queue = new AMQPQueue($channel);\n        $queue->setFlags(AMQP_EXCLUSIVE);\n        $queue_name = $queue->getName();\n\n\n        for ($i = 0; $i < $max_messages; $i++) {\n            $channel = new AMQPChannel($connection);\n            $exchange = new AMQPExchange($channel);\n            $exchange->publish($message_body, $queue_name);\n        }\n\n        $connection->disconnect();\n        $end_time = microtime(true);\n        return $end_time - $start_time;\n\n    } catch (AMQPConnectionException $e) {\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction sendMultipleMessagesToRabbitMQ(int $max_messages, string $host, int $port, string $user, string $pass, string $vhost, string $message_body): float|false {\n    $start_time = microtime(true);\n\n    try {\n        $connection = new AMQPConnection([\n            'host' => $host,\n            'port' => $port,\n            'vhost' => $vhost,\n            'login' => $user,\n            'password' => $pass\n        ]);\n        $connection->connect();\n\n        if (!$connection->isConnected()) {\n            return false;\n        }\n\n\n        $channel = new AMQPChannel($connection);\n        $queue = new AMQPQueue($channel);\n        $queue->setFlags(AMQP_EXCLUSIVE);\n        $queue_name = $queue->getName();\n\n\n        for ($i = 0; $i < $max_messages; $i++) {\n            $tempChannel = new AMQPChannel($connection);\n            $tempQueue = new AMQPQueue($tempChannel);\n            $tempQueue->setName($queue_name);\n\n            $message = new AMQPMessage($message_body);\n            $tempQueue->publish($message);\n            $tempChannel->close();\n        }\n\n        $connection->disconnect();\n        $end_time = microtime(true);\n        return $end_time - $start_time;\n\n    } catch (AMQPConnectionException $e) {\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction sendMultipleMessagesToRabbitMQ(int $max_messages, string $host, int $port, string $user, string $pass, string $vhost, string $message_body): float|false {\n    $start_time = microtime(true);\n\n    try {\n        $connection = new AMQPConnection([\n            'host' => $host,\n            'port' => $port,\n            'vhost' => $vhost,\n            'login' => $user,\n            'password' => $pass\n        ]);\n        $connection->connect();\n\n        if (!$connection->isConnected()) {\n            return false;\n        }\n\n\n        $channel = new AMQPChannel($connection);\n        $queue = new AMQPQueue($channel);\n        $queue->setFlags(AMQP_AUTODELETE);\n        $queue->declareQueue();\n\n\n        for ($i = 0; $i < $max_messages; $i++) {\n            $tempChannel = new AMQPChannel($connection);\n            $message = new AMQPMessage($message_body);\n            $tempChannel->basic_publish($message, '', $queue->getName());\n        }\n\n        $connection->disconnect();\n        $end_time = microtime(true);\n        return $end_time - $start_time;\n\n    } catch (AMQPConnectionException $e) {\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction sendMultipleMessagesToRabbitMQ(int $max_messages, string $host, int $port, string $user, string $pass, string $vhost, string $message_body): float|false {\n    $start_time = microtime(true);\n\n    try {\n        $connection = new AMQPConnection([\n            'host' => $host,\n            'port' => $port,\n            'vhost' => $vhost,\n            'login' => $user,\n            'password' => $pass\n        ]);\n        $connection->connect();\n\n        if (!$connection->isConnected()) {\n            return false;\n        }\n\n\n        $channel = new AMQPChannel($connection);\n        $queue = new AMQPQueue($channel);\n        $queue->setFlags(AMQP_AUTODELETE);\n        $queue->declareQueue();\n\n\n        for ($i = 0; $i < $max_messages; $i++) {\n            $channel = new AMQPChannel($connection);\n            $message = new AMQPMessage($message_body);\n            $channel->basicPublish($message, '', $queue->getName());\n        }\n\n        $connection->disconnect();\n\n        $end_time = microtime(true);\n        return $end_time - $start_time;\n\n    } catch (AMQPConnectionException $e) {\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction sendMultipleMessagesToRabbitMQ(int $max_messages, string $host, int $port, string $user, string $pass, string $vhost, string $message_body): float|false {\n    $start_time = microtime(true);\n\n    try {\n        $connection = new AMQPConnection([\n            'host' => $host,\n            'port' => $port,\n            'vhost' => $vhost,\n            'login' => $user,\n            'password' => $pass\n        ]);\n        $connection->connect();\n\n        if (!$connection->isConnected()) {\n            return false;\n        }\n\n\n        $channel = new AMQPChannel($connection);\n        $queue = new AMQPQueue($channel);\n        $queue->setFlags(AMQP_EXCLUSIVE);\n        $queue_name = $queue->getName();\n\n\n        for ($i = 0; $i < $max_messages; $i++) {\n            $tempChannel = new AMQPChannel($connection);\n            $tempQueue = new AMQPQueue($tempChannel);\n            $tempQueue->setName($queue_name);\n\n            $message = new AMQPMessage($message_body);\n            $tempQueue->publish($message);\n            $tempChannel->close();\n        }\n\n        $connection->disconnect();\n        $end_time = microtime(true);\n        return $end_time - $start_time;\n\n    } catch (AMQPConnectionException $e) {\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction sendMultipleMessagesToRabbitMQ(int $max_messages, string $host, int $port, string $user, string $pass, string $vhost, string $message_body): float|false {\n    $start_time = microtime(true);\n\n    try {\n        $connection = new AMQPConnection([\n            'host' => $host,\n            'port' => $port,\n            'vhost' => $vhost,\n            'login' => $user,\n            'password' => $pass\n        ]);\n        $connection->connect();\n\n        if (!$connection->isConnected()) {\n            return false;\n        }\n\n\n        $channel = new AMQPChannel($connection);\n        $queue = new AMQPQueue($channel);\n        $queue->setFlags(AMQP_AUTODELETE);\n        $queue->declareQueue();\n\n\n        for ($i = 0; $i < $max_messages; $i++) {\n            $tempChannel = new AMQPChannel($connection);\n            $message = new AMQPMessage($message_body);\n            $tempChannel->basic_publish($message, '', $queue->getName());\n        }\n\n        $connection->disconnect();\n\n        $end_time = microtime(true);\n        return $end_time - $start_time;\n\n    } catch (AMQPConnectionException $e) {\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction sendMultipleMessagesToRabbitMQ(int $max_messages, string $host, int $port, string $user, string $pass, string $vhost, string $message_body): float|false {\n    $start_time = microtime(true);\n\n    try {\n        $connection = new AMQPConnection([\n            'host' => $host,\n            'port' => $port,\n            'vhost' => $vhost,\n            'login' => $user,\n            'password' => $pass\n        ]);\n        $connection->connect();\n\n        if (!$connection->isConnected()) {\n            return false;\n        }\n\n        $channel = new AMQPChannel($connection);\n        $queue = new AMQPQueue($channel);\n        $queue->setFlags(AMQP_AUTODELETE);\n        $queue->declareQueue();\n\n\n        for ($i = 0; $i < $max_messages; $i++) {\n            $tempChannel = new AMQPChannel($connection);\n            $message = new AMQPMessage($message_body);\n            $tempChannel->basic_publish($message, '', $queue->getName());\n        }\n\n        $connection->disconnect();\n\n        $end_time = microtime(true);\n        return $end_time - $start_time;\n\n    } catch (AMQPConnectionException $e) {\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction sendMultipleMessagesToRabbitMQ(int $max_messages, string $host, int $port, string $user, string $pass, string $vhost, string $message_body): float|false {\n    $start_time = microtime(true);\n\n    try {\n        $connection = new AMQPConnection([\n            'host' => $host,\n            'port' => $port,\n            'vhost' => $vhost,\n            'login' => $user,\n            'password' => $pass\n        ]);\n        $connection->connect();\n\n        if (!$connection->isConnected()) {\n            return false;\n        }\n\n\n        $channel = new AMQPChannel($connection);\n        $queue = new AMQPQueue($channel);\n        $queue->setFlags(AMQP_EXCLUSIVE);\n        $queue_name = $queue->getName();\n\n\n        for ($i = 0; $i < $max_messages; $i++) {\n            $temp_channel = new AMQPChannel($connection);\n            $temp_queue = new AMQPQueue($temp_channel);\n            $temp_queue->setName($queue_name);\n\n            $message = new AMQPMessage($message_body);\n            $temp_queue->publish($message);\n            $temp_channel->close();\n        }\n\n        $connection->disconnect();\n        $end_time = microtime(true);\n        return $end_time - $start_time;\n\n    } catch (AMQPConnectionException $e) {\n        return false;\n    }\n}\n?>\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement a CAPTCHA validation class that verifies user-submitted CAPTCHA responses using Google's reCAPTCHA API.\n\nClass Description: The Captcha class implements Laravel's Rule interface to provide CAPTCHA validation functionality. It sends the user's CAPTCHA response to Google's verification endpoint and checks the success status in the response.\n\nAttributes: (This class has no explicit attributes as it uses configuration values directly)\n\nMethods:\n1: passes(string $attribute, mixed $value) -> bool - Validates the CAPTCHA response by sending it to Google's verification API along with the secret key and client IP. Returns true if verification succeeds.\n   - $attribute: The name of the attribute being validated\n   - $value: The CAPTCHA response token to be validated\n\n2: message() -> string - Returns the validation error message to be displayed when CAPTCHA validation fails. The message is localized using Laravel's translation system.",
    "Canonical_solution": "use GuzzleHttp\\Client;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        if (empty($value)) {\n            return false;\n        }\n\n        $response = json_decode((new Client([\n            'timeout' => config('boilerplate.access.captcha.configs.options.timeout'),\n        ]))->post('https://www.google.com/recaptcha/api/siteverify', [\n            'form_params' => [\n                'secret' => config('boilerplate.access.captcha.configs.secret_key'),\n                'remoteip' => request()->getClientIp(),\n                'response' => $value,\n            ],\n        ])->getBody(), true);\n\n        return isset($response['success']) && $response['success'] === true;\n    }\n\n    public function message()\n    {\n        return __('The captcha was invalid.');\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        $secretKey = config('services.recaptcha.secret');\n        $clientIP = request()->ip();\n\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => $secretKey,\n            'response' => $value,\n            'remoteip' => $clientIP,\n        ]);\n\n        return $response->json('success');\n    }\n\n    public function message()\n    {\n        return __('validation.captcha');\n    }\n}\n",
      "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        $secretKey = config('services.recaptcha.secret');\n        $clientIP = request()->ip();\n\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => $secretKey,\n            'response' => $value,\n            'remoteip' => $clientIP,\n        ]);\n\n        return $response->json('success');\n    }\n\n    public function message()\n    {\n        return __('validation.captcha');\n    }\n}\n",
      "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        $secretKey = config('services.recaptcha.secret');\n        $clientIP = request()->ip();\n\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => $secretKey,\n            'response' => $value,\n            'remoteip' => $clientIP,\n        ]);\n\n        return $response->json('success');\n    }\n\n    public function message()\n    {\n        return __('validation.captcha');\n    }\n}\n",
      "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        $secretKey = config('services.recaptcha.secret');\n        $clientIP = request()->ip();\n\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => $secretKey,\n            'response' => $value,\n            'remoteip' => $clientIP,\n        ]);\n\n        return $response->json('success');\n    }\n\n    public function message()\n    {\n        return __('validation.captcha');\n    }\n}\n",
      "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        $secretKey = config('services.recaptcha.secret');\n        $clientIP = request()->ip();\n\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => $secretKey,\n            'response' => $value,\n            'remoteip' => $clientIP,\n        ]);\n\n        return $response->json('success');\n    }\n\n    public function message()\n    {\n        return __('validation.captcha');\n    }\n}\n",
      "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        $secretKey = config('services.recaptcha.secret');\n        $clientIP = request()->ip();\n\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => $secretKey,\n            'response' => $value,\n            'remoteip' => $clientIP,\n        ]);\n\n        return $response->json('success');\n    }\n\n    public function message()\n    {\n        return __('validation.captcha');\n    }\n}\n",
      "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        $secretKey = config('services.recaptcha.secret');\n        $clientIP = request()->ip();\n\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => $secretKey,\n            'response' => $value,\n            'remoteip' => $clientIP,\n        ]);\n\n        return $response->json('success');\n    }\n\n    public function message()\n    {\n        return __('validation.captcha');\n    }\n}\n",
      "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => config('services.recaptcha.secret'),\n            'response' => $value,\n            'remoteip' => request()->ip(),\n        ]);\n\n        return $response->json('success');\n    }\n\n    public function message()\n    {\n        return __('validation.captcha');\n    }\n}\n",
      "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        $secretKey = config('services.recaptcha.secret');\n        $clientIP = request()->ip();\n\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => $secretKey,\n            'response' => $value,\n            'remoteip' => $clientIP,\n        ]);\n\n        return $response->json('success');\n    }\n\n    public function message()\n    {\n        return __('validation.captcha');\n    }\n}\n",
      "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        $secretKey = config('services.recaptcha.secret');\n        $clientIP = request()->ip();\n\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => $secretKey,\n            'response' => $value,\n            'remoteip' => $clientIP,\n        ]);\n\n        return $response->json('success');\n    }\n\n    public function message()\n    {\n        return __('validation.captcha');\n    }\n}\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Implement a function that sends a delayed message to a RabbitMQ queue using PHP and the PhpAmqpLib library. The function should establish a connection to RabbitMQ, declare a delayed exchange and queue, and publish a message with a specified delay time.\n\nFunction Description: The function `send_delayed_message` sends a message to a RabbitMQ queue with a specified delay. It uses a delayed exchange to achieve the delay functionality. The function handles the connection setup, exchange and queue declaration, message creation with delay headers, and cleanup of resources.\n\nInput:\n- `$message_content` [string] - The content of the message to be sent.\n- `$delay_ms` [int] - The delay time in milliseconds before the message is delivered to the queue.\n\nOutput: None. The function does not return any value but publishes the message to the specified RabbitMQ queue with the given delay.\n\nNote: The function assumes the existence of a `config.php` file containing the RabbitMQ connection parameters (HOST, PORT, USER, PASS, VHOST).",
    "Canonical_solution": "function send_delayed_message($message_content, $delay_ms)\n{\n    require_once __DIR__ . '/config.php';\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n    use PhpAmqpLib\\Wire\\AMQPTable;\n\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $channel->exchange_declare(\n        'delayed_exchange',\n        'x-delayed-message',\n        false,\n        true,\n        false,\n        false,\n        false,\n        new AMQPTable(['x-delayed-type' => AMQPExchangeType::FANOUT])\n    );\n\n    $channel->queue_declare(\n        'delayed_queue',\n        false,\n        false,\n        false,\n        false,\n        false,\n        new AMQPTable(['x-dead-letter-exchange' => 'delayed'])\n    );\n\n    $channel->queue_bind('delayed_queue', 'delayed_exchange');\n\n    $headers = new AMQPTable(['x-delay' => $delay_ms]);\n    $message = new AMQPMessage($message_content, ['delivery_mode' => 2]);\n    $message->set('application_headers', $headers);\n    $channel->basic_publish($message, 'delayed_exchange');\n\n    $channel->close();\n    $connection->close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 142,
    "matched_results": [
      "```php\n<?php\n\nrequire_once __DIR__ . '/config.php';\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction send_delayed_message(string $message_content, int $delay_ms) {\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchange_name = 'delayed_exchange';\n    $queue_name = 'delayed_queue';\n    $routing_key = 'delayed_routing_key';\n\n    $channel->exchange_declare($exchange_name, 'x-delayed-message', false, true, false, false, false, new AMQPTable(['x-delayed-type' => 'direct']));\n    $channel->queue_declare($queue_name, false, true, false, false);\n    $channel->queue_bind($queue_name, $exchange_name, $routing_key);\n\n\n    $headers = new AMQPTable(['x-delay' => $delay_ms]);\n    $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT, 'headers' => $headers]);\n\n    $channel->basic_publish($message, $exchange_name, $routing_key);\n\n    $channel->close();\n    $connection->close();\n}\n\n\n?>\n```",
      "```php\n<?php\n\nrequire_once __DIR__ . '/config.php';\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction send_delayed_message(string $message_content, int $delay_ms) {\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchange_name = 'delayed_exchange';\n    $queue_name = 'delayed_queue';\n    $routing_key = 'delayed_routing_key';\n\n    $channel->exchange_declare($exchange_name, 'x-delayed-message', false, true, false, false, false, new AMQPTable(['x-delayed-type' => 'direct']));\n    $channel->queue_declare($queue_name, false, true, false, false);\n    $channel->queue_bind($queue_name, $exchange_name, $routing_key);\n\n\n    $headers = new AMQPTable(['x-delay' => $delay_ms]);\n    $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT, 'headers' => $headers]);\n\n    $channel->basic_publish($message, $exchange_name, $routing_key);\n\n    $channel->close();\n    $connection->close();\n}\n\n\n?>\n```",
      "```php\n<?php\n\nrequire_once __DIR__ . '/config.php';\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction send_delayed_message(string $message_content, int $delay_ms) {\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchange_name = 'delayed_exchange';\n    $queue_name = 'delayed_queue';\n    $routing_key = 'delayed_routing_key';\n\n    $channel->exchange_declare($exchange_name, 'x-delayed-message', false, true, false, false, false, new AMQPTable(['x-delayed-type' => 'direct']));\n    $channel->queue_declare($queue_name, false, true, false, false);\n    $channel->queue_bind($queue_name, $exchange_name, $routing_key);\n\n\n    $headers = new AMQPTable(['x-delay' => $delay_ms]);\n    $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT, 'headers' => $headers]);\n\n    $channel->basic_publish($message, $exchange_name, $routing_key);\n\n    $channel->close();\n    $connection->close();\n}\n\n\n?>\n```",
      "```php\n<?php\n\nrequire_once __DIR__ . '/config.php';\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction send_delayed_message(string $message_content, int $delay_ms) {\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchange_name = 'delayed_exchange';\n    $queue_name = 'delayed_queue';\n    $routing_key = 'delayed_routing_key';\n\n    $channel->exchange_declare($exchange_name, 'x-delayed-message', false, true, false, false, false, new AMQPTable(['x-delayed-type' => 'direct']));\n    $channel->queue_declare($queue_name, false, true, false, false);\n    $channel->queue_bind($queue_name, $exchange_name, $routing_key);\n\n\n    $headers = new AMQPTable(['x-delay' => $delay_ms]);\n    $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT, 'headers' => $headers]);\n\n    $channel->basic_publish($message, $exchange_name, $routing_key);\n\n    $channel->close();\n    $connection->close();\n}\n\n\n?>\n```",
      "```php\n<?php\n\nrequire_once __DIR__ . '/config.php';\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction send_delayed_message(string $message_content, int $delay_ms) {\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchange_name = 'delayed_exchange';\n    $queue_name = 'delayed_queue';\n    $routing_key = 'delayed_routing_key';\n\n    $channel->exchange_declare($exchange_name, 'x-delayed-message', false, true, false, false, false, new AMQPTable(['x-delayed-type' => 'direct']));\n    $channel->queue_declare($queue_name, false, true, false, false);\n    $channel->queue_bind($queue_name, $exchange_name, $routing_key);\n\n\n    $headers = new AMQPTable(['x-delay' => $delay_ms]);\n    $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT, 'headers' => $headers]);\n\n    $channel->basic_publish($message, $exchange_name, $routing_key);\n\n    $channel->close();\n    $connection->close();\n}\n\n\n?>\n```",
      "```php\n<?php\n\nrequire_once __DIR__ . '/config.php';\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction send_delayed_message(string $message_content, int $delay_ms) {\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchange_name = 'delayed_exchange';\n    $queue_name = 'delayed_queue';\n    $routing_key = 'delayed_routing_key';\n\n    $channel->exchange_declare($exchange_name, 'x-delayed-message', false, true, false, false, false, new AMQPTable(['x-delayed-type' => 'direct']));\n    $channel->queue_declare($queue_name, false, true, false, false);\n    $channel->queue_bind($queue_name, $exchange_name, $routing_key);\n\n\n    $headers = new AMQPTable(['x-delay' => $delay_ms]);\n    $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT, 'headers' => $headers]);\n\n    $channel->basic_publish($message, $exchange_name, $routing_key);\n\n    $channel->close();\n    $connection->close();\n}\n\n\n?>\n```",
      "```php\n<?php\n\nrequire_once __DIR__ . '/config.php';\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction send_delayed_message(string $message_content, int $delay_ms) {\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchange_name = 'delayed_exchange';\n    $queue_name = 'delayed_queue';\n    $routing_key = 'delayed_routing_key';\n\n    $channel->exchange_declare($exchange_name, 'x-delayed-message', false, true, false, false, false, new AMQPTable(['x-delayed-type' => 'direct']));\n    $channel->queue_declare($queue_name, false, true, false, false);\n    $channel->queue_bind($queue_name, $exchange_name, $routing_key);\n\n\n    $headers = new AMQPTable(['x-delay' => $delay_ms]);\n    $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT, 'headers' => $headers]);\n\n    $channel->basic_publish($message, $exchange_name, $routing_key);\n\n    $channel->close();\n    $connection->close();\n}\n\n\n?>\n```",
      "```php\n<?php\n\nrequire_once __DIR__ . '/config.php';\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction send_delayed_message(string $message_content, int $delay_ms) {\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchange_name = 'delayed_exchange';\n    $queue_name = 'delayed_queue';\n    $routing_key = 'delayed_routing_key';\n\n    $channel->exchange_declare($exchange_name, 'x-delayed-message', false, true, false, false, false, new AMQPTable(['x-delayed-type' => 'direct']));\n    $channel->queue_declare($queue_name, false, true, false, false);\n    $channel->queue_bind($queue_name, $exchange_name, $routing_key);\n\n\n    $headers = new AMQPTable(['x-delay' => $delay_ms]);\n    $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT, 'headers' => $headers]);\n\n    $channel->basic_publish($message, $exchange_name, $routing_key);\n\n    $channel->close();\n    $connection->close();\n}\n\n\n?>\n```",
      "```php\n<?php\n\nrequire_once __DIR__ . '/config.php';\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction send_delayed_message(string $message_content, int $delay_ms) {\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchange_name = 'delayed_exchange';\n    $queue_name = 'delayed_queue';\n    $routing_key = 'delayed_routing_key';\n\n    $channel->exchange_declare($exchange_name, 'x-delayed-message', false, true, false, false, false, new AMQPTable(['x-delayed-type' => 'direct']));\n    $channel->queue_declare($queue_name, false, true, false, false);\n    $channel->queue_bind($queue_name, $exchange_name, $routing_key);\n\n\n    $headers = new AMQPTable(['x-delay' => $delay_ms]);\n    $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT, 'headers' => $headers]);\n\n    $channel->basic_publish($message, $exchange_name, $routing_key);\n\n    $channel->close();\n    $connection->close();\n}\n\n\n?>\n```",
      "```php\n<?php\n\nrequire_once __DIR__ . '/config.php';\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Wire\\AMQPTable;\n\nfunction send_delayed_message(string $message_content, int $delay_ms) {\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchange_name = 'delayed_exchange';\n    $queue_name = 'delayed_queue';\n    $routing_key = 'delayed_routing_key';\n\n    $channel->exchange_declare($exchange_name, 'x-delayed-message', false, true, false, false, false, new AMQPTable(['x-delayed-type' => 'direct']));\n    $channel->queue_declare($queue_name, false, true, false, false);\n    $channel->queue_bind($queue_name, $exchange_name, $routing_key);\n\n\n    $headers = new AMQPTable(['x-delay' => $delay_ms]);\n    $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT, 'headers' => $headers]);\n\n    $channel->basic_publish($message, $exchange_name, $routing_key);\n\n    $channel->close();\n    $connection->close();\n}\n\n\n?>\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 121,
    "Instruction": "Task Description: Create a function that sends a message to a RabbitMQ queue using PHP and the PhpAmqpLib library.\n\nFunction Description: The function establishes a connection to a RabbitMQ server, declares a queue and exchange, binds them, publishes a message with persistent delivery mode, and then closes the connection. It handles errors gracefully by returning false if an exception occurs.\n\nInput:  \n- $messageBody: [string] - The content of the message to be sent  \n- $exchange: [string] - The name of the exchange (default: 'router')  \n- $queue: [string] - The name of the queue (default: 'msgs')  \n\nOutput:  \n- [bool] - Returns true if the message was successfully sent, false if an error occurred",
    "Canonical_solution": "function send_rabbitmq_message($messageBody, $exchange = 'router', $queue = 'msgs')\n{\n    include(__DIR__ . '/config.php');\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n\n    try {\n        $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n        $channel = $connection->channel();\n\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_bind($queue, $exchange);\n\n        $message = new AMQPMessage($messageBody, array(\n            'content_type' => 'text/plain',\n            'delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT\n        ));\n        \n        $channel->basic_publish($message, $exchange);\n        \n        $channel->close();\n        $connection->close();\n        \n        return true;\n    } catch (Exception $e) {\n        return false;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 142,
    "matched_results": [
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\nfunction sendMessageToRabbitMQ(string $messageBody, string $exchange = 'router', string $queue = 'msgs'): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->queue_bind($queue, $exchange, $queue);\n\n\n        $msg = new AMQPMessage($messageBody, array('delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT));\n        $channel->basic_publish($msg, $exchange, $queue);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (\\Exception $e) {\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\nfunction sendMessageToRabbitMQ(string $messageBody, string $exchange = 'router', string $queue = 'msgs'): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->queue_bind($queue, $exchange, $queue);\n\n\n        $msg = new AMQPMessage($messageBody, array('delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT));\n        $channel->basic_publish($msg, $exchange, $queue);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (\\Exception $e) {\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\nfunction sendMessageToRabbitMQ(string $messageBody, string $exchange = 'router', string $queue = 'msgs'): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->queue_bind($queue, $exchange, $queue);\n\n\n        $msg = new AMQPMessage($messageBody, array('delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT));\n        $channel->basic_publish($msg, $exchange, $queue);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (\\Exception $e) {\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\nfunction sendMessageToRabbitMQ(string $messageBody, string $exchange = 'router', string $queue = 'msgs'): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->queue_bind($queue, $exchange, $queue);\n\n\n        $msg = new AMQPMessage($messageBody, array('delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT));\n        $channel->basic_publish($msg, $exchange, $queue);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (\\Exception $e) {\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\nfunction sendMessageToRabbitMQ(string $messageBody, string $exchange = 'router', string $queue = 'msgs'): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->queue_bind($queue, $exchange, $queue);\n\n\n        $msg = new AMQPMessage($messageBody, array('delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT));\n        $channel->basic_publish($msg, $exchange, $queue);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (\\Exception $e) {\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\nfunction sendMessageToRabbitMQ(string $messageBody, string $exchange = 'router', string $queue = 'msgs'): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->queue_bind($queue, $exchange, $queue);\n\n\n        $msg = new AMQPMessage($messageBody, array('delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT));\n        $channel->basic_publish($msg, $exchange, $queue);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (\\Exception $e) {\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\nfunction sendMessageToRabbitMQ(string $messageBody, string $exchange = 'router', string $queue = 'msgs'): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->queue_bind($queue, $exchange, $queue);\n\n\n        $msg = new AMQPMessage($messageBody, array('delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT));\n        $channel->basic_publish($msg, $exchange, $queue);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (\\Exception $e) {\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\nfunction sendMessageToRabbitMQ(string $messageBody, string $exchange = 'router', string $queue = 'msgs'): bool\n{\n    try {\n        $connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->queue_bind($queue, $exchange, $queue);\n\n\n        $msg = new AMQPMessage($messageBody, array('delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT));\n        $channel->basic_publish($msg, $exchange, $queue);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n    } catch (Exception $e) {\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\nfunction sendMessageToRabbitMQ(string $messageBody, string $exchange = 'router', string $queue = 'msgs'): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->queue_bind($queue, $exchange, $queue);\n\n\n        $msg = new AMQPMessage($messageBody, array('delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT));\n        $channel->basic_publish($msg, $exchange, $queue);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (\\Exception $e) {\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\nuse PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\nfunction sendMessageToRabbitMQ(string $messageBody, string $exchange = 'router', string $queue = 'msgs'): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->queue_bind($queue, $exchange, $queue);\n\n\n        $msg = new AMQPMessage($messageBody, array('delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT));\n        $channel->basic_publish($msg, $exchange, $queue);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (\\Exception $e) {\n        return false;\n    }\n}\n\n?>\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a PHP function that publishes messages to a RabbitMQ queue in batches, measuring the total execution time for sending all messages.\n\nFunction Description: The function establishes a connection to a RabbitMQ server, declares an exchange and queue, then publishes a specified number of messages in configurable batch sizes. It handles connection blocking scenarios and returns the total execution time. A special 'quit' message is sent at the end to signal completion.\n\nInput:\n- $msg_count: [integer] - The total number of messages to publish\n- $batch_size: [integer] - The number of messages to send in each batch\n- $host: [string] - RabbitMQ server hostname\n- $port: [integer] - RabbitMQ server port\n- $user: [string] - RabbitMQ username\n- $pass: [string] - RabbitMQ password\n- $vhost: [string] - RabbitMQ virtual host\n\nOutput:\n- [float] - The total execution time in seconds for sending all messages",
    "Canonical_solution": "function publish_messages($msg_count, $batch_size, $host, $port, $user, $pass, $vhost)\n{\n    require_once __DIR__ . '/config.php';\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n    use PhpAmqpLib\\Exception\\AMQPConnectionBlockedException;\n\n    $exchange = 'bench_exchange';\n    $queue = 'bench_queue';\n\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->queue_declare($queue, false, false, false, false);\n    $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, false, false);\n    $channel->queue_bind($queue, $exchange);\n\n    $messageBody = <<<EOT\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyza\nEOT;\n\n    $message = new AMQPMessage($messageBody);\n    $time = microtime(true);\n\n    for ($i = 0; $i < $msg_count; $i++) {\n        $channel->batch_basic_publish($message, $exchange);\n\n        if ($i % $batch_size == 0) {\n            try {\n                $channel->publish_batch();\n            } catch (AMQPConnectionBlockedException $exception) {\n                do {\n                    sleep(10);\n                } while ($connection->isBlocked());\n                $channel->publish_batch();\n            }\n        }\n    }\n\n    $channel->publish_batch();\n    $channel->basic_publish(new AMQPMessage('quit'), $exchange);\n\n    $execution_time = microtime(true) - $time;\n    \n    $channel->close();\n    $connection->close();\n\n    return $execution_time;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 142,
    "matched_results": [],
    "unmatched_results": [
      "```php\n<?php\n\nfunction publish_messages_in_batches($msg_count, $batch_size, $host, $port, $user, $pass, $vhost) {\n    $start_time = microtime(true);\n\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('messages_exchange');\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->setFlags(AMQP_DURABLE);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName('messages_queue');\n    $queue->setFlags(AMQP_DURABLE);\n    $queue->declareQueue();\n    $queue->bind('messages_exchange', 'messages_routing_key');\n\n\n    for ($i = 0; $i < $msg_count; $i += $batch_size) {\n        $batch = [];\n        for ($j = 0; $j < $batch_size && $i + $j < $msg_count; $j++) {\n            $batch[] = \"Message \" . ($i + $j + 1);\n        }\n\n        foreach ($batch as $message) {\n            $exchange->publish($message, 'messages_routing_key');\n        }\n        \n    }\n\n    $exchange->publish('quit', 'messages_routing_key');\n\n    $connection->disconnect();\n\n    $end_time = microtime(true);\n    return $end_time - $start_time;\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction publish_messages_in_batches($msg_count, $batch_size, $host, $port, $user, $pass, $vhost) {\n    $start_time = microtime(true);\n\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('messages_exchange');\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->setFlags(AMQP_DURABLE);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName('messages_queue');\n    $queue->setFlags(AMQP_DURABLE);\n    $queue->declareQueue();\n    $queue->bind('messages_exchange', 'messages_routing_key');\n\n\n    for ($i = 0; $i < $msg_count; $i += $batch_size) {\n        $batch = [];\n        for ($j = 0; $j < $batch_size && $i + $j < $msg_count; $j++) {\n            $batch[] = \"Message \" . ($i + $j + 1);\n        }\n\n        foreach ($batch as $message) {\n            $exchange->publish($message, 'messages_routing_key');\n        }\n        \n    }\n\n    $exchange->publish('quit', 'messages_routing_key');\n\n    $connection->disconnect();\n\n    $end_time = microtime(true);\n    return $end_time - $start_time;\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction publish_messages_in_batches($msg_count, $batch_size, $host, $port, $user, $pass, $vhost) {\n    $start_time = microtime(true);\n\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('messages_exchange');\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->setFlags(AMQP_DURABLE);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName('messages_queue');\n    $queue->setFlags(AMQP_DURABLE);\n    $queue->declareQueue();\n    $queue->bind('messages_exchange', 'messages_routing_key');\n\n\n    for ($i = 0; $i < $msg_count; $i += $batch_size) {\n        $batch = [];\n        for ($j = 0; $j < $batch_size && $i + $j < $msg_count; $j++) {\n            $batch[] = \"Message \" . ($i + $j + 1);\n        }\n\n        foreach ($batch as $message) {\n            $exchange->publish($message, 'messages_routing_key');\n        }\n        \n    }\n\n    $exchange->publish('quit', 'messages_routing_key');\n\n    $connection->disconnect();\n\n    $end_time = microtime(true);\n    return $end_time - $start_time;\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction publish_messages_in_batches($msg_count, $batch_size, $host, $port, $user, $pass, $vhost) {\n    $start_time = microtime(true);\n\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('messages_exchange');\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->setFlags(AMQP_DURABLE);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName('messages_queue');\n    $queue->setFlags(AMQP_DURABLE);\n    $queue->declareQueue();\n    $queue->bind('messages_exchange', 'messages_routing_key');\n\n\n    for ($i = 0; $i < $msg_count; $i += $batch_size) {\n        $batch = [];\n        for ($j = 0; $j < $batch_size && $i + $j < $msg_count; $j++) {\n            $batch[] = \"Message \" . ($i + $j + 1);\n        }\n\n        foreach ($batch as $message) {\n            $exchange->publish($message, 'messages_routing_key');\n        }\n        \n    }\n\n    $exchange->publish('quit', 'messages_routing_key');\n\n    $connection->disconnect();\n\n    $end_time = microtime(true);\n    return $end_time - $start_time;\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction publish_messages_in_batches($msg_count, $batch_size, $host, $port, $user, $pass, $vhost) {\n    $start_time = microtime(true);\n\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('messages_exchange');\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->setFlags(AMQP_DURABLE);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName('messages_queue');\n    $queue->setFlags(AMQP_DURABLE);\n    $queue->declareQueue();\n    $queue->bind('messages_exchange', 'messages_routing_key');\n\n\n    for ($i = 0; $i < $msg_count; $i += $batch_size) {\n        $batch = [];\n        for ($j = 0; $j < $batch_size && $i + $j < $msg_count; $j++) {\n            $batch[] = \"Message \" . ($i + $j + 1);\n        }\n\n        foreach ($batch as $message) {\n            $exchange->publish($message, 'messages_routing_key');\n        }\n        \n    }\n\n    $exchange->publish('quit', 'messages_routing_key');\n\n    $connection->disconnect();\n\n    $end_time = microtime(true);\n    return $end_time - $start_time;\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction publishMessagesInBatches($msg_count, $batch_size, $host, $port, $user, $pass, $vhost) {\n    $start_time = microtime(true);\n\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = $channel->exchangeDeclare('test_exchange', 'direct', false, true, false);\n    $queue = $channel->queueDeclare('test_queue', false, true, false, false);\n    $channel->queueBind('test_queue', 'test_exchange', 'test_routing_key');\n\n    for ($i = 0; $i < $msg_count; $i += $batch_size) {\n        $batch = [];\n        for ($j = 0; $j < $batch_size && $i + $j < $msg_count; $j++) {\n            $batch[] = new AMQPMessage('Message ' . ($i + $j + 1));\n        }\n\n        foreach ($batch as $message) {\n            $channel->batchBasicPublish($message, 'test_exchange', 'test_routing_key');\n        }\n        $channel->publishBatch();\n    }\n\n    $channel->basicPublish(new AMQPMessage('quit'), 'test_exchange', 'test_routing_key');\n\n    $connection->disconnect();\n\n    $end_time = microtime(true);\n    return $end_time - $start_time;\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction publish_messages_in_batches($msg_count, $batch_size, $host, $port, $user, $pass, $vhost) {\n    $start_time = microtime(true);\n\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('messages_exchange');\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName('messages_queue');\n    $queue->setFlags(AMQP_DURABLE);\n    $queue->declareQueue();\n    $queue->bind('messages_exchange', 'messages_routing_key');\n\n    for ($i = 0; $i < $msg_count; $i += $batch_size) {\n        $batch = [];\n        for ($j = 0; $j < $batch_size && $i + $j < $msg_count; $j++) {\n            $batch[] = \"Message \" . ($i + $j + 1);\n        }\n\n        foreach ($batch as $message) {\n            $exchange->publish($message, 'messages_routing_key');\n        }\n    }\n\n    $exchange->publish('quit', 'messages_routing_key');\n\n    $connection->disconnect();\n\n    $end_time = microtime(true);\n    return $end_time - $start_time;\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction publish_messages_in_batches($msg_count, $batch_size, $host, $port, $user, $pass, $vhost) {\n    $start_time = microtime(true);\n\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass,\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('messages_exchange');\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->setFlags(AMQP_DURABLE);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName('messages_queue');\n    $queue->setFlags(AMQP_DURABLE);\n    $queue->declareQueue();\n    $queue->bind('messages_exchange', 'messages_routing_key');\n\n\n    for ($i = 0; $i < $msg_count; $i += $batch_size) {\n        $batch = [];\n        for ($j = 0; $j < $batch_size && $i + $j < $msg_count; $j++) {\n            $batch[] = \"Message \" . ($i + $j + 1);\n        }\n\n        foreach ($batch as $message) {\n            $exchange->publish($message, 'messages_routing_key');\n        }\n        \n    }\n\n    $exchange->publish('quit', 'messages_routing_key');\n\n    $connection->disconnect();\n\n    $end_time = microtime(true);\n    return $end_time - $start_time;\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction publish_messages_in_batches($msg_count, $batch_size, $host, $port, $user, $pass, $vhost) {\n    $start_time = microtime(true);\n\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('messages_exchange');\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName('messages_queue');\n    $queue->setFlags(AMQP_DURABLE);\n    $queue->declareQueue();\n    $queue->bind('messages_exchange', 'messages_routing_key');\n\n    for ($i = 0; $i < $msg_count; $i += $batch_size) {\n        $batch = [];\n        for ($j = 0; $j < $batch_size && $i + $j < $msg_count; $j++) {\n            $batch[] = \"Message \" . ($i + $j + 1);\n        }\n\n        foreach ($batch as $message) {\n            $exchange->publish($message, 'messages_routing_key');\n        }\n        \n        if ($connection->isConnected() && !$connection->isBlocked()) {\n          $connection->checkHeartBeat();\n        }\n    }\n\n    $exchange->publish('quit', 'messages_routing_key');\n\n    $connection->disconnect();\n\n    $end_time = microtime(true);\n    return $end_time - $start_time;\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction publishMessagesInBatches($msg_count, $batch_size, $host, $port, $user, $pass, $vhost) {\n    $start_time = microtime(true);\n\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = $channel->exchangeDeclare('test_exchange', 'direct', false, true, false);\n    $queue = $channel->queueDeclare('test_queue', false, true, false, false);\n    $channel->queueBind('test_queue', 'test_exchange', 'test_routing_key');\n\n    for ($i = 0; $i < $msg_count; $i += $batch_size) {\n        $batch = [];\n        for ($j = 0; $j < $batch_size && $i + $j < $msg_count; $j++) {\n            $batch[] = new AMQPMessage('Message ' . ($i + $j + 1));\n        }\n\n        foreach ($batch as $message) {\n            $channel->batchBasicPublish($message, 'test_exchange', 'test_routing_key');\n        }\n        $channel->publishBatch();\n    }\n\n    $channel->basicPublish(new AMQPMessage('quit'), 'test_exchange', 'test_routing_key');\n\n    $connection->disconnect();\n\n    $end_time = microtime(true);\n    return $end_time - $start_time;\n}\n\n?>\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Implement a PHP function that sends a message to a RabbitMQ queue using the PhpAmqpLib library. The function should handle connection establishment, message publishing, and resource cleanup.\n\nFunction Description: The function `send_rabbitmq_message` sends a given message to a predefined RabbitMQ queue. It establishes a connection to the RabbitMQ server, declares the necessary exchange and queue, publishes the message, and then closes the connection. The function returns a boolean indicating success or failure.\n\nInput:  \n- `$message_content` (string): The content of the message to be sent to the RabbitMQ queue.\n\nOutput:  \n- (bool): Returns `true` if the message was successfully sent, `false` if an error occurred.",
    "Canonical_solution": "function send_rabbitmq_message($message_content)\n{\n    include(__DIR__ . '/config.php');\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n\n    $exchange = 'basic_get_test';\n    $queue = 'basic_get_queue';\n\n    try {\n        $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n        $channel = $connection->channel();\n\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_bind($queue, $exchange);\n\n        $message = new AMQPMessage($message_content, array('content_type' => 'text/plain', 'delivery_mode' => 2));\n        $channel->basic_publish($message, $exchange);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n    } catch (Exception $e) {\n        return false;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 142,
    "matched_results": [
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction send_rabbitmq_message(string $message_content): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n    $exchange_name = 'my_exchange';\n    $queue_name = 'my_queue';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange_name, 'direct', false, false, false);\n        $channel->queue_declare($queue_name, false, false, false, false);\n        $channel->queue_bind($queue_name, $exchange_name, 'my_routing_key');\n\n        $message = new AMQPMessage($message_content);\n        $channel->basic_publish($message, $exchange_name, 'my_routing_key');\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (Exception $e) {\n        error_log(\"RabbitMQ Error: \" . $e->getMessage());\n        return false;\n    }\n}\n\n?>\n```\n",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction send_rabbitmq_message(string $message_content): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n    $exchange_name = 'my_exchange';\n    $queue_name = 'my_queue';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange_name, 'direct', false, false, false);\n        $channel->queue_declare($queue_name, false, false, false, false);\n        $channel->queue_bind($queue_name, $exchange_name, 'my_routing_key');\n\n        $message = new AMQPMessage($message_content);\n        $channel->basic_publish($message, $exchange_name, 'my_routing_key');\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (Exception $e) {\n        error_log(\"RabbitMQ Error: \" . $e->getMessage());\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction send_rabbitmq_message(string $message_content): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n    $exchange_name = 'my_exchange';\n    $queue_name = 'my_queue';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange_name, 'direct', false, false, false);\n        $channel->queue_declare($queue_name, false, false, false, false);\n        $channel->queue_bind($queue_name, $exchange_name, 'my_routing_key');\n\n        $message = new AMQPMessage($message_content);\n        $channel->basic_publish($message, $exchange_name, 'my_routing_key');\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (Exception $e) {\n        error_log(\"RabbitMQ Error: \" . $e->getMessage());\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction send_rabbitmq_message(string $message_content): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n    $exchange_name = 'my_exchange';\n    $queue_name = 'my_queue';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange_name, 'direct', false, true, false);\n        $channel->queue_declare($queue_name, false, true, false, false);\n        $channel->queue_bind($queue_name, $exchange_name, 'my_routing_key');\n\n        $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT]);\n        $channel->basic_publish($message, $exchange_name, 'my_routing_key');\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (Exception $e) {\n        error_log(\"RabbitMQ Error: \" . $e->getMessage());\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction send_rabbitmq_message(string $message_content): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n    $exchange_name = 'my_exchange';\n    $queue_name = 'my_queue';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange_name, 'direct', false, false, false);\n        $channel->queue_declare($queue_name, false, false, false, false);\n        $channel->queue_bind($queue_name, $exchange_name, 'my_routing_key');\n\n        $message = new AMQPMessage($message_content);\n        $channel->basic_publish($message, $exchange_name, 'my_routing_key');\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (Exception $e) {\n        error_log(\"RabbitMQ Error: \" . $e->getMessage());\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction send_rabbitmq_message(string $message_content): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n    $exchange_name = 'my_exchange';\n    $queue_name = 'my_queue';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange_name, 'direct', false, false, false);\n        $channel->queue_declare($queue_name, false, false, false, false);\n        $channel->queue_bind($queue_name, $exchange_name, 'my_routing_key');\n\n        $message = new AMQPMessage($message_content);\n        $channel->basic_publish($message, $exchange_name, 'my_routing_key');\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (Exception $e) {\n        error_log(\"RabbitMQ Error: \" . $e->getMessage());\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction send_rabbitmq_message(string $message_content): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n    $exchange_name = 'my_exchange';\n    $queue_name = 'my_queue';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange_name, 'direct', false, false, false);\n        $channel->queue_declare($queue_name, false, false, false, false);\n        $channel->queue_bind($queue_name, $exchange_name, 'my_routing_key');\n\n        $message = new AMQPMessage($message_content);\n        $channel->basic_publish($message, $exchange_name, 'my_routing_key');\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (Exception $e) {\n        error_log(\"RabbitMQ Error: \" . $e->getMessage());\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction send_rabbitmq_message(string $message_content): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n    $exchange_name = 'my_exchange';\n    $queue_name = 'my_queue';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange_name, 'direct', false, false, false);\n        $channel->queue_declare($queue_name, false, false, false, false);\n        $channel->queue_bind($queue_name, $exchange_name, 'my_routing_key');\n\n        $message = new AMQPMessage($message_content);\n        $channel->basic_publish($message, $exchange_name, 'my_routing_key');\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (Exception $e) {\n        error_log(\"RabbitMQ Error: \" . $e->getMessage());\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction send_rabbitmq_message(string $message_content): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n    $exchange_name = 'my_exchange';\n    $queue_name = 'my_queue';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange_name, 'direct', false, true, false);\n        $channel->queue_declare($queue_name, false, true, false, false);\n        $channel->queue_bind($queue_name, $exchange_name, 'my_routing_key');\n\n        $message = new AMQPMessage($message_content, ['delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT]);\n        $channel->basic_publish($message, $exchange_name, 'my_routing_key');\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (Exception $e) {\n        error_log(\"RabbitMQ Error: \" . $e->getMessage());\n        return false;\n    }\n}\n\n?>\n```",
      "```php\n<?php\n\nuse PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nfunction send_rabbitmq_message(string $message_content): bool\n{\n    $host = 'localhost';\n    $port = 5672;\n    $user = 'guest';\n    $password = 'guest';\n    $vhost = '/';\n    $exchange_name = 'my_exchange';\n    $queue_name = 'my_queue';\n\n    try {\n        $connection = new AMQPStreamConnection($host, $port, $user, $password, $vhost);\n        $channel = $connection->channel();\n\n        $channel->exchange_declare($exchange_name, 'direct', false, false, false);\n        $channel->queue_declare($queue_name, false, false, false, false);\n        $channel->queue_bind($queue_name, $exchange_name, 'my_routing_key');\n\n        $message = new AMQPMessage($message_content);\n        $channel->basic_publish($message, $exchange_name, 'my_routing_key');\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n\n    } catch (Exception $e) {\n        error_log(\"RabbitMQ Error: \" . $e->getMessage());\n        return false;\n    }\n}\n\n?>\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Implement a Redis-based session handler class that extends a base session driver and implements the SessionHandlerInterface for use in a web application framework.\n\nClass Description: The CI_Session_redis_driver class provides Redis-based session management functionality, including session data storage, retrieval, locking mechanisms, and cleanup. It handles connection management, session data persistence, and concurrency control through Redis operations.\n\nAttributes:\n- _redis: [Redis] - Instance of the Redis client used for all operations\n- _key_prefix: [string] - Prefix for all Redis keys used in session storage\n- _lock_key: [string] - Key used for the current session lock\n- _key_exists: [bool] - Flag indicating whether the current session key exists in Redis\n- _config: [array] - Configuration array containing connection parameters and settings\n- _session_id: [string] - Current session ID being handled\n- _fingerprint: [string] - MD5 hash of the current session data for change detection\n\nMethods:\n- __construct(&$params) -> [void] - Constructor that parses configuration parameters and sets up the Redis connection details\n- open($save_path, $name) -> [bool] - Opens a connection to the Redis server using configured parameters\n- read($session_id) -> [string] - Reads session data from Redis for the given session ID\n- write($session_id, $session_data) -> [bool] - Writes session data to Redis for the given session ID\n- close() -> [bool] - Closes the Redis connection and releases any locks\n- destroy($session_id) -> [bool] - Removes session data from Redis for the given session ID\n- gc($maxlifetime) -> [bool] - Garbage collection handler (not implemented for Redis)\n- _get_lock($session_id) -> [bool] - Internal method to acquire a lock for session operations\n- _release_lock() -> [bool] - Internal method to release the current session lock\n- _fail() -> [bool] - Internal method to handle operation failures\n- _success() -> [bool] - Internal method to handle operation successes",
    "Canonical_solution": "class CI_Session_redis_driver extends CI_Session_driver implements SessionHandlerInterface {\n\n    protected $_redis;\n    protected $_key_prefix = 'ci_session:';\n    protected $_lock_key;\n    protected $_key_exists = FALSE;\n\n    public function __construct(&$params)\n    {\n        parent::__construct($params);\n\n        if (empty($this->_config['save_path']))\n        {\n            log_message('error', 'Session: No Redis save path configured.');\n        }\n        elseif (preg_match('#(?:tcp://)?([^:?]+)(?:\\:(\\d+))?(\\?.+)?#', $this->_config['save_path'], $matches))\n        {\n            isset($matches[3]) OR $matches[3] = '';\n            $this->_config['save_path'] = array(\n                'host' => $matches[1],\n                'port' => empty($matches[2]) ? NULL : $matches[2],\n                'password' => preg_match('#auth=([^\\s&]+)#', $matches[3], $match) ? $match[1] : NULL,\n                'database' => preg_match('#database=(\\d+)#', $matches[3], $match) ? (int) $match[1] : NULL,\n                'timeout' => preg_match('#timeout=(\\d+\\.\\d+)#', $matches[3], $match) ? (float) $match[1] : NULL\n            );\n\n            preg_match('#prefix=([^\\s&]+)#', $matches[3], $match) && $this->_key_prefix = $match[1];\n        }\n        else\n        {\n            log_message('error', 'Session: Invalid Redis save path format: '.$this->_config['save_path']);\n        }\n\n        if ($this->_config['match_ip'] === TRUE)\n        {\n            $this->_key_prefix .= $_SERVER['REMOTE_ADDR'].':';\n        }\n    }\n\n    public function open($save_path, $name)\n    {\n        if (empty($this->_config['save_path']))\n        {\n            return $this->_fail();\n        }\n\n        $redis = new Redis();\n        if ( ! $redis->connect($this->_config['save_path']['host'], $this->_config['save_path']['port'], $this->_config['save_path']['timeout']))\n        {\n            log_message('error', 'Session: Unable to connect to Redis with the configured settings.');\n        }\n        elseif (isset($this->_config['save_path']['password']) && ! $redis->auth($this->_config['save_path']['password']))\n        {\n            log_message('error', 'Session: Unable to authenticate to Redis instance.');\n        }\n        elseif (isset($this->_config['save_path']['database']) && ! $redis->select($this->_config['save_path']['database']))\n        {\n            log_message('error', 'Session: Unable to select Redis database with index '.$this->_config['save_path']['database']);\n        }\n        else\n        {\n            $this->_redis = $redis;\n            return $this->_success;\n        }\n\n        return $this->_fail();\n    }\n\n    public function read($session_id)\n    {\n        if (isset($this->_redis) && $this->_get_lock($session_id))\n        {\n            $this->_session_id = $session_id;\n\n            $session_data = $this->_redis->get($this->_key_prefix.$session_id);\n\n            is_string($session_data)\n                ? $this->_key_exists = TRUE\n                : $session_data = '';\n\n            $this->_fingerprint = md5($session_data);\n            return $session_data;\n        }\n\n        return $this->_fail();\n    }\n\n    public function write($session_id, $session_data)\n    {\n        if ( ! isset($this->_redis, $this->_lock_key))\n        {\n            return $this->_fail();\n        }\n        elseif ($session_id !== $this->_session_id)\n        {\n            if ( ! $this->_release_lock() OR ! $this->_get_lock($session_id))\n            {\n                return $this->_fail();\n            }\n\n            $this->_key_exists = FALSE;\n            $this->_session_id = $session_id;\n        }\n\n        $this->_redis->setTimeout($this->_lock_key, 300);\n        if ($this->_fingerprint !== ($fingerprint = md5($session_data)) OR $this->_key_exists === FALSE)\n        {\n            if ($this->_redis->set($this->_key_prefix.$session_id, $session_data, $this->_config['expiration']))\n            {\n                $this->_fingerprint = $fingerprint;\n                $this->_key_exists = TRUE;\n                return $this->_success;\n            }\n\n            return $this->_fail();\n        }\n\n        return ($this->_redis->setTimeout($this->_key_prefix.$session_id, $this->_config['expiration']))\n            ? $this->_success\n            : $this->_fail();\n    }\n\n    public function close()\n    {\n        if (isset($this->_redis))\n        {\n            try {\n                if ($this->_redis->ping() === '+PONG')\n                {\n                    $this->_release_lock();\n                    if ($this->_redis->close() === FALSE)\n                    {\n                        return $this->_fail();\n                    }\n                }\n            }\n            catch (RedisException $e)\n            {\n                log_message('error', 'Session: Got RedisException on close(): '.$e->getMessage());\n            }\n\n            $this->_redis = NULL;\n            return $this->_success;\n        }\n\n        return $this->_success;\n    }\n\n    public function destroy($session_id)\n    {\n        if (isset($this->_redis, $this->_lock_key))\n        {\n            if (($result = $this->_redis->delete($this->_key_prefix.$session_id)) !== 1)\n            {\n                log_message('debug', 'Session: Redis::delete() expected to return 1, got '.var_export($result, TRUE).' instead.');\n            }\n\n            $this->_cookie_destroy();\n            return $this->_success;\n        }\n\n        return $this->_fail();\n    }\n\n    public function gc($maxlifetime)\n    {\n        return $this->_success;\n    }\n\n    protected function _get_lock($session_id)\n    {\n        if ($this->_lock_key === $this->_key_prefix.$session_id.':lock')\n        {\n            return $this->_redis->setTimeout($this->_lock_key, 300);\n        }\n\n        $lock_key = $this->_key_prefix.$session_id.':lock';\n        $attempt = 0;\n        do\n        {\n            if (($ttl = $this->_redis->ttl($lock_key)) > 0)\n            {\n                sleep(1);\n                continue;\n            }\n\n            $result = ($ttl === -2)\n                ? $this->_redis->set($lock_key, time(), array('nx', 'ex' => 300))\n                : $this->_redis->setex($lock_key, 300, time());\n\n            if ( ! $result)\n            {\n                log_message('error', 'Session: Error while trying to obtain lock for '.$this->_key_prefix.$session_id);\n                return FALSE;\n            }\n\n            $this->_lock_key = $lock_key;\n            break;\n        }\n        while (++$attempt < 30);\n\n        if ($attempt === 30)\n        {\n            log_message('error', 'Session: Unable to obtain lock for '.$this->_key_prefix.$session_id.' after 30 attempts, aborting.');\n            return FALSE;\n        }\n        elseif ($ttl === -1)\n        {\n            log_message('debug', 'Session: Lock for '.$this->_key_prefix.$session_id.' had no TTL, overriding.');\n        }\n\n        $this->_lock = TRUE;\n        return TRUE;\n    }\n\n    protected function _release_lock()\n    {\n        if (isset($this->_redis, $this->_lock_key) && $this->_lock)\n        {\n            if ( ! $this->_redis->delete($this->_lock_key))\n            {\n                log_message('error', 'Session: Error while trying to free lock for '.$this->_lock_key);\n                return FALSE;\n            }\n\n            $this->_lock_key = NULL;\n            $this->_lock = FALSE;\n        }\n\n        return TRUE;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 144,
    "matched_results": [
      "<?php\nclass CI_Session_redis_driver extends CI_Session_driver implements SessionHandlerInterface {\n\n    protected $_redis;\n    protected $_key_prefix = 'ci_session:';\n    protected $_lock_key;\n    protected $_key_exists = FALSE;\n    protected $_config = array();\n    protected $_session_id;\n    protected $_fingerprint;\n\n    public function __construct(&$params)\n    {\n        parent::__construct($params);\n\n        $this->_config = $params['config'];\n        $this->_config['save_path'] = isset($this->_config['save_path'])\n            ? $this->_config['save_path']\n            : 'tcp://127.0.0.1:6379';\n    }\n\n    public function open($save_path, $name)\n    {\n        if (empty($this->_config['save_path']))\n        {\n            return $this->_fail();\n        }\n\n        $redis = new Redis();\n        $connected = $redis->connect($this->_config['save_path']);\n\n        if ($connected)\n        {\n            if (isset($this->_config['password']) && ! $redis->auth($this->_config['password']))\n            {\n                log_message('error', 'Session: Unable to authenticate to Redis instance.');\n                return $this->_fail();\n            }\n\n            if (isset($this->_config['database']) && ! $redis->select($this->_config['database']))\n            {\n                log_message('error', 'Session: Unable to select Redis database with index ' . $this->_config['database']);\n                return $this->_fail();\n            }\n            $this->_redis = $redis;\n            return $this->_success();\n        }\n        else\n        {\n            log_message('error', 'Session: Unable to connect to Redis with the configured settings.');\n        }\n\n        return $this->_fail();\n    }\n\n    public function read($session_id)\n    {\n        if (isset($this->_redis) && $this->_get_lock($session_id))\n        {\n            $session_data = (string) $this->_redis->get($this->_key_prefix . $session_id);\n\n            $this->_fingerprint = md5($session_data);\n            $this->_key_exists = ! empty($session_data);\n            $this->_session_id = $session_id;\n\n            return $session_data;\n        }\n\n        return $this->_fail();\n    }\n\n    public function write($session_id, $session_data)\n    {\n        if ( ! isset($this->_redis, $this->_lock_key))\n        {\n            return $this->_fail();\n        }\n        elseif ($session_id !== $this->_session_id)\n        {\n            if ( ! $this->_release_lock() OR ! $this->_get_lock($session_id))\n            {\n                return $this->_fail();\n            }\n\n            $this->_key_exists = FALSE;\n            $this->_session_id = $session_id;\n        }\n\n        if (isset($this->_config['match_ip']) && $this->_config['match_ip'])\n        {\n            $session_data = $this->prep_ip($session_data);\n        }\n\n        $this->_fingerprint = md5($session_data);\n\n        if ($this->_redis->set($this->_key_prefix . $session_id, $session_data, $this->_config['expiration']))\n        {\n            $this->_key_exists = TRUE;\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    public function close()\n    {\n        if (isset($this->_redis))\n        {\n            try {\n                $this->_redis->close();\n            }\n            catch (Exception $e) {\n                return $this->_fail();\n            }\n\n            if ($this->_lock_key)\n            {\n                $this->_redis = $this->_lock_key = NULL;\n                return $this->_release_lock();\n            }\n\n            return $this->_success();\n        }\n\n        return $this->_success();\n    }\n\n    public function destroy($session_id)\n    {\n        if (isset($this->_redis, $this->_lock_key))\n        {\n            if ($this->_key_exists)\n            {\n                $this->_redis->del($this->_key_prefix . $session_id);\n                $this->_cookie_destroy();\n            }\n\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    public function gc($maxlifetime)\n    {\n        return $this->_success();\n    }\n\n    protected function _get_lock($session_id)\n    {\n        if (isset($this->_lock_key))\n        {\n            return $this->_redis->exists($this->_lock_key);\n        }\n\n        $lock_key = $this->_key_prefix . $session_id . ':lock';\n        $attempt = 0;\n\n        do\n        {\n            if ($this->_redis->setnx($lock_key, time()))\n            {\n                $this->_lock_key = $lock_key;\n                $this->_redis->expire($lock_key, 300);\n                return TRUE;\n            }\n\n            sleep(1);\n            ++$attempt;\n        }\n        while ($attempt < 30);\n\n        log_message('error', 'Session: Unable to obtain lock for session_id: ' . $session_id);\n        return FALSE;\n    }\n\n    protected function _release_lock()\n    {\n        if (isset($this->_redis, $this->_lock_key) && $this->_redis->del($this->_lock_key))\n        {\n            $this->_lock_key = NULL;\n            return TRUE;\n        }\n\n        return FALSE;\n    }\n\n    protected function _fail()\n    {\n        return isset($this->_failure_handler)\n            ? call_user_func($this->_failure_handler, $this)\n            : FALSE;\n    }\n\n    protected function _success()\n    {\n        return isset($this->_success_handler)\n            ? call_user_func($this->_success_handler, $this)\n            : TRUE;\n    }\n}\n",
      "<?php\nclass CI_Session_redis_driver extends CI_Session_driver implements SessionHandlerInterface {\n\n    protected $_redis;\n    protected $_key_prefix = 'ci_session:';\n    protected $_lock_key;\n    protected $_key_exists = FALSE;\n    protected $_config = array();\n    protected $_session_id;\n    protected $_fingerprint;\n\n    public function __construct(&$params)\n    {\n        parent::__construct($params);\n\n        $this->_config = $params['config'];\n        $this->_config['save_path'] = isset($this->_config['save_path'])\n            ? $this->_config['save_path']\n            : 'tcp://127.0.0.1:6379';\n    }\n\n    public function open($save_path, $name)\n    {\n        $this->_redis = new Redis();\n        $connected = $this->_redis->connect($this->_config['save_path']);\n\n        if ($connected)\n        {\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    public function read($session_id)\n    {\n        $this->_session_id = $session_id;\n        $this->_lock_key = $this->_key_prefix.$session_id.':lock';\n        if ($this->_get_lock($session_id))\n        {\n            $session_data = (string) $this->_redis->get($this->_key_prefix.$session_id);\n            $this->_fingerprint = md5($session_data);\n            $this->_key_exists = ! empty($session_data);\n            return $session_data;\n        }\n\n        return $this->_fail();\n    }\n\n    public function write($session_id, $session_data)\n    {\n        if ( ! isset($this->_lock_key))\n        {\n            return $this->_fail();\n        }\n        elseif ($session_id !== $this->_session_id)\n        {\n            if ( ! $this->_release_lock() OR ! $this->_get_lock($session_id))\n            {\n                return $this->_fail();\n            }\n\n            $this->_key_exists = FALSE;\n            $this->_session_id = $session_id;\n        }\n\n        if ( ! $this->_key_exists)\n        {\n            $this->_redis->sAdd($this->_config['match_ip'] ? $this->_key_prefix.$this->_config['match_ip'] : $this->_key_prefix.'index', $session_id);\n            $this->_key_exists = TRUE;\n        }\n\n        if ($this->_fingerprint !== ($fingerprint = md5($session_data)))\n        {\n            if ($this->_redis->set($this->_key_prefix.$session_id, $session_data, $this->_config['expiration']))\n            {\n                $this->_fingerprint = $fingerprint;\n                return $this->_success();\n            }\n\n            return $this->_fail();\n        }\n\n        return ($this->_redis->expire($this->_key_prefix.$session_id, $this->_config['expiration']))\n            ? $this->_success()\n            : $this->_fail();\n    }\n\n    public function close()\n    {\n        return ($this->_redis->close() && $this->_release_lock())\n            ? $this->_success()\n            : $this->_fail();\n    }\n\n    public function destroy($session_id)\n    {\n        if (isset($this->_lock_key))\n        {\n            $this->_redis->del($this->_key_prefix.$session_id);\n            $this->_redis->sRem($this->_config['match_ip'] ? $this->_key_prefix.$this->_config['match_ip'] : $this->_key_prefix.'index', $session_id);\n            $this->_cookie_destroy();\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    public function gc($maxlifetime)\n    {\n        return $this->_success();\n    }\n\n    protected function _get_lock($session_id)\n    {\n        return ($this->_redis->setnx($this->_lock_key, time()));\n    }\n\n    protected function _release_lock()\n    {\n        if (isset($this->_lock_key))\n        {\n            $this->_redis->del($this->_lock_key);\n            unset($this->_lock_key);\n            return TRUE;\n        }\n\n        return FALSE;\n    }\n\n    protected function _fail()\n    {\n        return FALSE;\n    }\n\n    protected function _success()\n    {\n        return TRUE;\n    }\n}\n",
      "<?php\nclass CI_Session_redis_driver extends CI_Session_driver implements SessionHandlerInterface {\n\n    protected $_redis;\n    protected $_key_prefix = 'ci_session:';\n    protected $_lock_key;\n    protected $_key_exists = FALSE;\n    protected $_config = array();\n    protected $_session_id;\n    protected $_fingerprint;\n\n    public function __construct(&$params)\n    {\n        parent::__construct($params);\n\n        $this->_config = $params['config'];\n        $this->_config['save_path'] = isset($this->_config['save_path'])\n            ? $this->_config['save_path']\n            : 'tcp://127.0.0.1:6379';\n    }\n\n    public function open($save_path, $name)\n    {\n        $this->_redis = new Redis();\n        $connected = $this->_redis->connect($this->_config['save_path']);\n\n        if ($connected)\n        {\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    public function read($session_id)\n    {\n        $this->_session_id = $session_id;\n        $this->_lock_key = $this->_key_prefix.$session_id.':lock';\n        if ($this->_get_lock($session_id))\n        {\n            $session_data = (string) $this->_redis->get($this->_key_prefix.$session_id);\n            $this->_fingerprint = md5($session_data);\n            $this->_key_exists = ! empty($session_data);\n            $this->_release_lock();\n            return $session_data;\n        }\n\n        return $this->_fail();\n    }\n\n    public function write($session_id, $session_data)\n    {\n        if ( ! isset($this->_lock_key))\n        {\n            $this->_lock_key = $this->_key_prefix.$session_id.':lock';\n            if ( ! $this->_get_lock($session_id))\n            {\n                return $this->_fail();\n            }\n        }\n        elseif ($session_id !== $this->_session_id)\n        {\n            if ( ! $this->_release_lock() OR ! $this->_get_lock($session_id))\n            {\n                return $this->_fail();\n            }\n        }\n\n        if (isset($this->_fingerprint) && $this->_fingerprint === md5($session_data))\n        {\n            return ( ! $this->_key_exists && $this->_redis->ttl($this->_key_prefix.$session_id) < ($this->_config['expiration'] / 2))\n                ? $this->_redis->expire($this->_key_prefix.$session_id, $this->_config['expiration'])\n                : $this->_success();\n        }\n\n        $ttl = $this->_config['expiration'];\n\n        if ($this->_redis->set($this->_key_prefix.$session_id, $session_data, $ttl))\n        {\n            $this->_fingerprint = md5($session_data);\n            $this->_key_exists = TRUE;\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    public function close()\n    {\n        return ($this->_redis->close() && $this->_release_lock())\n            ? $this->_success()\n            : $this->_fail();\n    }\n\n    public function destroy($session_id)\n    {\n        if (isset($this->_lock_key))\n        {\n            $this->_redis->del($this->_key_prefix.$session_id);\n            $this->_cookie_destroy();\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    public function gc($maxlifetime)\n    {\n        return $this->_success();\n    }\n\n    protected function _get_lock($session_id)\n    {\n        $lock_key = $this->_key_prefix.$session_id.':lock';\n        if ($this->_redis->setnx($lock_key, time()))\n        {\n            $this->_lock = TRUE;\n            return TRUE;\n        }\n\n        // If the lock is held by someone else, check if it has expired\n        $lock_time = $this->_redis->get($lock_key);\n        if (time() - $lock_time > $this->_config['match_ip'] ? 300 : 30)\n        {\n            if ($this->_redis->getSet($lock_key, time()) == $lock_time)\n            {\n                $this->_lock = TRUE;\n                return TRUE;\n            }\n        }\n\n        return FALSE;\n    }\n\n    protected function _release_lock()\n    {\n        if (isset($this->_lock_key) && $this->_lock)\n        {\n            if ($this->_redis->del($this->_lock_key))\n            {\n                $this->_lock_key = NULL;\n                $this->_lock = FALSE;\n                return TRUE;\n            }\n\n            return FALSE;\n        }\n\n        return TRUE;\n    }\n\n    protected function _fail()\n    {\n        log_message('error', __CLASS__.': Redis connection failed. Check your configuration.');\n        return FALSE;\n    }\n\n    protected function _success()\n    {\n        return TRUE;\n    }\n}\n",
      "<?php\nclass CI_Session_redis_driver extends CI_Session_driver implements SessionHandlerInterface {\n\n    protected $_redis;\n    protected $_key_prefix = 'ci_session:';\n    protected $_lock_key;\n    protected $_key_exists = FALSE;\n    protected $_config = array();\n    protected $_session_id;\n    protected $_fingerprint;\n\n    public function __construct(&$params)\n    {\n        parent::__construct($params);\n\n        $this->_config = $params['config'];\n        $this->_redis = new Redis();\n    }\n\n    public function open($save_path, $name)\n    {\n        if (empty($this->_config['host']) OR empty($this->_config['port']))\n        {\n            log_message('error', 'Session: Invalid parameters; host and port are required.');\n            return $this->_fail();\n        }\n\n        $result = $this->_redis->connect($this->_config['host'], $this->_config['port'], $this->_config['timeout'] ?? 0.25);\n\n        if ($result === TRUE && isset($this->_config['password']) && ! $this->_redis->auth($this->_config['password']))\n        {\n            log_message('error', 'Session: Authentication failure.');\n            return $this->_fail();\n        }\n        elseif ($result === TRUE && isset($this->_config['database']) && ! $this->_redis->select($this->_config['database']))\n        {\n            log_message('error', 'Session: Unable to select database.');\n            return $this->_fail();\n        }\n\n        return $result ? $this->_success() : $this->_fail();\n    }\n\n    public function read($session_id)\n    {\n        if (isset($this->_config['match_ip']) && $this->_config['match_ip'])\n        {\n            $session_id = $session_id.':'.$_SERVER['REMOTE_ADDR'];\n        }\n\n        $this->_session_id = $session_id;\n\n        $session_data = (string) $this->_redis->get($this->_key_prefix.$session_id);\n\n        $this->_fingerprint = md5($session_data);\n        $this->_key_exists = ! empty($session_data);\n\n        return $session_data;\n    }\n\n    public function write($session_id, $session_data)\n    {\n        if (isset($this->_config['match_ip']) && $this->_config['match_ip'])\n        {\n            $session_id = $session_id.':'.$_SERVER['REMOTE_ADDR'];\n        }\n\n        if ( ! isset($this->_session_id))\n        {\n            $this->_session_id = $session_id;\n        }\n\n        if ($this->_session_id !== $session_id)\n        {\n            if ( ! $this->destroy($this->_session_id))\n            {\n                return $this->_fail();\n            }\n\n            $this->_key_exists = FALSE;\n            $this->_session_id = $session_id;\n        }\n\n        if ($this->_fingerprint !== ($fingerprint = md5($session_data)))\n        {\n            if ($this->_redis->set($this->_key_prefix.$session_id, $session_data, $this->_config['expiration']))\n            {\n                $this->_fingerprint = $fingerprint;\n                return $this->_success();\n            }\n\n            return $this->_fail();\n        }\n\n        return ($this->_redis->expire($this->_key_prefix.$session_id, $this->_config['expiration']))\n            ? $this->_success()\n            : $this->_fail();\n    }\n\n    public function close()\n    {\n        return ($this->_redis->close() && $this->_release_lock()) ? $this->_success() : $this->_fail();\n    }\n\n    public function destroy($session_id)\n    {\n        if (isset($this->_config['match_ip']) && $this->_config['match_ip'])\n        {\n            $session_id = $session_id.':'.$_SERVER['REMOTE_ADDR'];\n        }\n\n        if ($this->_redis->del($this->_key_prefix.$session_id) > 0)\n        {\n            $this->_cookie_destroy();\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    public function gc($maxlifetime)\n    {\n        return $this->_success();\n    }\n\n    protected function _get_lock($session_id)\n    {\n        $this->_lock_key = $this->_key_prefix.$session_id.':lock';\n        return ($this->_redis->setnx($this->_lock_key, time())) ? $this->_success() : $this->_fail();\n    }\n\n    protected function _release_lock()\n    {\n        if (isset($this->_lock_key) && $this->_redis->del($this->_lock_key))\n        {\n            $this->_lock_key = NULL;\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    protected function _fail()\n    {\n        return FALSE;\n    }\n\n    protected function _success()\n    {\n        return TRUE;\n    }\n}\n",
      "<?php\nclass CI_Session_redis_driver extends CI_Session_driver implements SessionHandlerInterface {\n\n    protected $_redis;\n    protected $_key_prefix = 'ci_session:';\n    protected $_lock_key;\n    protected $_key_exists = FALSE;\n    protected $_config = array();\n    protected $_session_id;\n    protected $_fingerprint;\n\n    public function __construct(&$params)\n    {\n        parent::__construct($params);\n\n        $this->_config = $params['config'];\n        $this->_config['save_path'] = isset($this->_config['save_path'])\n            ? $this->_config['save_path']\n            : 'tcp://127.0.0.1:6379';\n    }\n\n    public function open($save_path, $name)\n    {\n        $this->_redis = new Redis();\n        $socket = $this->_config['save_path'];\n\n        if (preg_match('#^unix://(.+)$#', $socket, $matches))\n        {\n            $success = $this->_redis->connect($matches[1]);\n        }\n        elseif (preg_match('#(?:tcp://)?([^:]+)(?:\\:(\\d+))?#', $socket, $matches))\n        {\n            $host = $matches[1];\n            $port = isset($matches[2]) ? $matches[2] : 6379;\n            $success = $this->_redis->connect($host, $port, $this->_config['timeout'] ?? 0.0);\n        }\n        else\n        {\n            return $this->_fail();\n        }\n\n        if ($success)\n        {\n            if (isset($this->_config['password']) && ! $this->_redis->auth($this->_config['password']))\n            {\n                return $this->_fail();\n            }\n\n            if (isset($this->_config['database']) && ! $this->_redis->select($this->_config['database']))\n            {\n                return $this->_fail();\n            }\n        }\n        else\n        {\n            return $this->_fail();\n        }\n\n        return $this->_success;\n    }\n\n    public function read($session_id)\n    {\n        $this->_session_id = $session_id;\n\n        if ( ! $this->_get_lock($session_id))\n        {\n            return $this->_fail();\n        }\n\n        $session_data = (string) $this->_redis->get($this->_key_prefix.$session_id);\n        $this->_fingerprint = md5($session_data);\n        $this->_key_exists = ! empty($session_data);\n\n        return $session_data;\n    }\n\n    public function write($session_id, $session_data)\n    {\n        if ( ! isset($this->_lock_key))\n        {\n            if ( ! $this->_get_lock($session_id))\n            {\n                return $this->_fail();\n            }\n\n            $this->_session_id = $session_id;\n            $this->_fingerprint = md5('');\n        }\n        elseif ($session_id !== $this->_session_id)\n        {\n            if ( ! $this->_release_lock() OR ! $this->_get_lock($session_id))\n            {\n                return $this->_fail();\n            }\n\n            $this->_session_id = $session_id;\n            $this->_fingerprint = md5('');\n        }\n\n        if (isset($this->_fingerprint) && $this->_fingerprint === md5($session_data))\n        {\n            return $this->_success;\n        }\n\n        $ttl = $this->_config['expiration'];\n\n        if ($this->_redis->set($this->_key_prefix.$session_id, $session_data, $ttl))\n        {\n            $this->_fingerprint = md5($session_data);\n            return $this->_success;\n        }\n\n        return $this->_fail();\n    }\n\n    public function close()\n    {\n        return ($this->_redis && $this->_release_lock()) ? $this->_success : $this->_fail();\n    }\n\n    public function destroy($session_id)\n    {\n        if (isset($this->_lock_key))\n        {\n            $this->_redis->del($this->_key_prefix.$session_id);\n            $this->_cookie_destroy();\n            return $this->_release_lock() ? $this->_success : $this->_fail();\n        }\n\n        return $this->_redis->del($this->_key_prefix.$session_id) ? $this->_success : $this->_fail();\n    }\n\n    public function gc($maxlifetime)\n    {\n        return $this->_success;\n    }\n\n    protected function _get_lock($session_id)\n    {\n        $this->_lock_key = $this->_key_prefix.$session_id.':lock';\n        if ($this->_redis->setnx($this->_lock_key, time()))\n        {\n            $this->_redis->expire($this->_lock_key, 300);\n            return TRUE;\n        }\n\n\n        // If the lock is held by the same process and has not expired, extend the timeout\n        if ($this->_redis->getSet($this->_lock_key, time()) == $this->lock_value)\n        {\n            $this->_redis->expire($this->_lock_key, 300);\n            return TRUE;\n        }\n\n        return FALSE;\n    }\n\n    protected function _release_lock()\n    {\n        if (isset($this->_lock_key) && $this->_lock_key)\n        {\n            $this->_redis->del($this->_lock_key);\n            $this->_lock_key = NULL;\n            return TRUE;\n        }\n\n        return FALSE;\n    }\n\n    protected function _fail()\n    {\n        return $this->_success === TRUE ? FALSE : $this->_success;\n    }\n\n    protected function _success()\n    {\n        return $this->_success === FALSE ? TRUE : $this->_success;\n    }\n}\n",
      "<?php\nclass CI_Session_redis_driver extends CI_Session_driver implements SessionHandlerInterface {\n\n    protected $_redis;\n    protected $_key_prefix = 'ci_session:';\n    protected $_lock_key;\n    protected $_key_exists = FALSE;\n    protected $_config = array(\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0,\n        'database' => 0\n    );\n\n\n    public function __construct(&$params)\n    {\n        parent::__construct($params);\n\n        $this->_config = array_merge($this->_config, $params);\n\n        if (empty($this->_config['save_path']))\n        {\n            log_message('error', 'Session: No Redis save path configured.');\n        }\n        elseif (preg_match('#^unix://([^\\?]+)(?<options>\\?.+)?$#', $this->_config['save_path'], $matches))\n        {\n\t\t\t$this->_config['save_path'] = $matches[1];\n\t\t\tif (isset($matches['options']))\n\t\t\t{\n\t\t\t\tparse_str(ltrim($matches['options'], '?'), $options);\n\t\t\t\tif (isset($options['database']))\n\t\t\t\t{\n\t\t\t\t\t$this->_config['database'] = $options['database'];\n\t\t\t\t}\n\t\t\t\tif (isset($options['password']))\n\t\t\t\t{\n\t\t\t\t\t$this->_config['password'] = $options['password'];\n\t\t\t\t}\n\t\t\t}\n        }\n        elseif (preg_match('#(?:tcp://)?([^@]+@)?([^\\?]+)(?<options>\\?.+)?#', $this->_config['save_path'], $matches))\n        {\n            $matches[2] = explode(':', $matches[2]);\n\t\t\t$this->_config['host'] = $matches[2][0];\n\t\t\tif (isset($matches[2][1]))\n\t\t\t{\n\t\t\t\t$this->_config['port'] = $matches[2][1];\n\t\t\t}\n\t\t\tif (isset($matches[1]))\n\t\t\t{\n\t\t\t\t$matches[1] = explode(':', $matches[1]);\n\t\t\t\t$this->_config['password'] = $matches[1][0];\n\t\t\t}\n\t\t\tif (isset($matches['options']))\n\t\t\t{\n\t\t\t\tparse_str(ltrim($matches['options'], '?'), $options);\n\t\t\t\tif (isset($options['database']))\n\t\t\t\t{\n\t\t\t\t\t$this->_config['database'] = $options['database'];\n\t\t\t\t}\n\t\t\t}\n        }\n        else\n        {\n            log_message('error', 'Session: Invalid Redis save path format: ' . $this->_config['save_path']);\n        }\n    }\n\n    public function open($save_path, $name)\n    {\n        $this->_redis = new Redis();\n        try {\n            if ($this->_config['save_path'] !== 'unix://' && $this->_config['port'] !== NULL)\n            {\n                $success = $this->_redis->connect($this->_config['host'], $this->_config['port'], $this->_config['timeout']);\n            }\n            else\n            {\n                $success = $this->_redis->connect($this->_config['save_path']);\n            }\n        }\n        catch (RedisException $e)\n        {\n            log_message('error', 'Session: Unable to connect to Redis with the configured settings.');\n        }\n\n        if (isset($success) && $success)\n        {\n            if (isset($this->_config['password']) && ! $this->_redis->auth($this->_config['password']))\n            {\n                log_message('error', 'Session: Unable to authenticate to Redis instance.');\n            }\n            elseif ( ! $this->_redis->select($this->_config['database']))\n            {\n                log_message('error', 'Session: Unable to select Redis database with index ' . $this->_config['database']);\n            }\n            else\n            {\n                return $this->_success();\n            }\n        }\n\n        return $this->_fail();\n    }\n\n    public function read($session_id)\n    {\n        if (isset($this->_redis) && $this->_get_lock($session_id))\n        {\n            $session_data = (string) $this->_redis->get($this->_key_prefix.$session_id);\n\n            $this->_fingerprint = md5($session_data);\n            $this->_key_exists = ! empty($session_data);\n            $this->_session_id = $session_id;\n\n            return $session_data;\n        }\n\n        return $this->_fail();\n    }\n\n    public function write($session_id, $session_data)\n    {\n        if ( ! isset($this->_redis, $this->_lock_key))\n        {\n            return $this->_fail();\n        }\n        elseif ($session_id !== $this->_session_id)\n        {\n            if ( ! $this->_release_lock() OR ! $this->_get_lock($session_id))\n            {\n                return $this->_fail();\n            }\n\n            $this->_key_exists = FALSE;\n            $this->_session_id = $session_id;\n        }\n\n        if (isset($this->_lock_key))\n        {\n            $this->_redis->setTimeout($this->_lock_key, 300);\n            if ($this->_fingerprint !== ($fingerprint = md5($session_data)) OR $this->_key_exists === FALSE)\n            {\n                if ($this->_redis->set($this->_key_prefix.$session_id, $session_data, $this->_config['expiration']))\n                {\n                    $this->_fingerprint = $fingerprint;\n                    $this->_key_exists = TRUE;\n                    return $this->_success();\n                }\n\n                return $this->_fail();\n            }\n\n            return ($this->_redis->setTimeout($this->_key_prefix.$session_id, $this->_config['expiration']))\n                ? $this->_success()\n                : $this->_fail();\n        }\n\n        return $this->_fail();\n    }\n\n    public function close()\n    {\n        if (isset($this->_redis))\n        {\n            try {\n                if ($this->_redis->ping() === '+PONG')\n                {\n                    $this->_release_lock();\n                    if ($this->_redis->close() === TRUE)\n                    {\n                        $this->_redis = NULL;\n                        return $this->_success();\n                    }\n                }\n            }\n            catch (RedisException $e)\n            {\n                log_message('error', 'Session: Got RedisException on close(): '.$e->getMessage());\n            }\n\n            return $this->_fail();\n        }\n\n        return $this->_success();\n    }\n\n    public function destroy($session_id)\n    {\n        if (isset($this->_redis, $this->_lock_key))\n        {\n            if (($result = $this->_redis->delete($this->_key_prefix.$session_id)) !== 1)\n            {\n                log_message('debug', 'Session: Redis::delete() expected to return 1, got '.var_export($result, TRUE).' instead.');\n            }\n\n            $this->_cookie_destroy();\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    public function gc($maxlifetime)\n    {\n        return $this->_success();\n    }\n\n    protected function _get_lock($session_id)\n    {\n        if (isset($this->_lock_key))\n        {\n            return $this->_redis->setTimeout($this->_lock_key, 300);\n        }\n\n\n        $lock_key = $this->_key_prefix.$session_id.':lock';\n        $attempt = 0;\n\n        do\n        {\n            if (($ttl = $this->_redis->ttl($lock_key)) > 0)\n            {\n                sleep(1);\n                continue;\n            }\n\n            if ($this->_redis->setex($lock_key, 300, time()))\n            {\n                $this->_lock_key = $lock_key;\n                break;\n            }\n        }\n        while (++$attempt < 30);\n\n        if ($attempt === 30)\n        {\n            log_message('error', 'Session: Unable to obtain lock for '.$this->_key_prefix.$session_id.' after 30 attempts, aborting.');\n            return FALSE;\n        }\n        elseif ($ttl === -1)\n        {\n            log_message('debug', 'Session: Got negative TTL for '.$this->_key_prefix.$session_id.':lock, overriding.');\n        }\n\n        $this->_lock = TRUE;\n        return TRUE;\n    }\n\n    protected function _release_lock()\n    {\n        if (isset($this->_redis, $this->_lock_key) && $this->_lock)\n        {\n            if ( ! $this->_redis->delete($this->_lock_key))\n            {\n                log_message('error', 'Session: Error while trying to free lock for '.$this->_lock_key);\n                return FALSE;\n            }\n\n            $this->_lock_key = NULL;\n            $this->_lock = FALSE;\n        }\n\n        return TRUE;\n    }\n\n    protected function _fail()\n    {\n        return FALSE;\n    }\n    protected function _success()\n    {\n        return TRUE;\n    }\n\n}\n",
      "<?php\nclass CI_Session_redis_driver extends CI_Session_driver implements SessionHandlerInterface {\n\n    protected $_redis;\n    protected $_key_prefix = 'ci_session:';\n    protected $_lock_key;\n    protected $_key_exists = FALSE;\n    protected $_config = array(\n        'host' => 'localhost',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0,\n        'database' => 0\n    );\n\n\n    public function __construct(&$params)\n    {\n        parent::__construct($params);\n\n        $this->_config = array_merge($this->_config, $params);\n\n        if (empty($this->_config['save_path']))\n        {\n            log_message('error', 'Session: No Redis save path configured.');\n        }\n        elseif (preg_match('#^unix://([^\\?]+)(\\?.+)?$#', $this->_config['save_path'], $matches))\n        {\n            $this->_config['socket'] = $matches[1];\n        }\n        else\n        {\n            preg_match('#(?:tcp://)?([^:?]+)(?:\\:(\\d+))?(\\?.+)?#', $this->_config['save_path'], $matches);\n            isset($matches[1]) && $this->_config['host'] = $matches[1];\n            isset($matches[2]) && $this->_config['port'] = $matches[2];\n        }\n\n        if (isset($this->_config['match_ip']) && $this->_config['match_ip'] === TRUE)\n        {\n            $this->_key_prefix .= $_SERVER['REMOTE_ADDR'].':';\n        }\n    }\n\n    public function open($save_path, $name)\n    {\n        if (empty($this->_config['socket']))\n        {\n            $this->_redis = new Redis();\n            if (! $this->_redis->connect($this->_config['host'], $this->_config['port'], $this->_config['timeout']))\n            {\n                log_message('error', 'Session: Unable to connect to Redis with the configured settings.');\n            }\n        }\n        else\n        {\n            $this->_redis = new Redis();\n            if (! $this->_redis->connect($this->_config['socket']))\n            {\n                log_message('error', 'Session: Unable to connect to Redis with the configured settings.');\n            }\n        }\n\n        if (isset($this->_config['password']) && ! $this->_redis->auth($this->_config['password']))\n        {\n            log_message('error', 'Session: Unable to authenticate to Redis instance.');\n        }\n\n        if (isset($this->_config['database']) && ! $this->_redis->select($this->_config['database']))\n        {\n            log_message('error', 'Session: Unable to select Redis database with index '.$this->_config['database']);\n        }\n        return $this->_success();\n    }\n\n    public function read($session_id)\n    {\n        if (isset($this->_redis) && $this->_get_lock($session_id))\n        {\n            $session_data = (string) $this->_redis->get($this->_key_prefix.$session_id);\n            $this->_fingerprint = md5($session_data);\n            $this->_key_exists = ! empty($session_data);\n            $this->_session_id = $session_id;\n\n            return $session_data;\n        }\n\n        return $this->_fail();\n    }\n\n    public function write($session_id, $session_data)\n    {\n        if (! isset($this->_redis, $this->_lock_key))\n        {\n            return $this->_fail();\n        }\n        elseif ($session_id !== $this->_session_id)\n        {\n            if (! $this->_release_lock() OR ! $this->_get_lock($session_id))\n            {\n                return $this->_fail();\n            }\n\n            $this->_key_exists = FALSE;\n            $this->_session_id = $session_id;\n        }\n\n        if ($this->_fingerprint !== ($fingerprint = md5($session_data)) OR $this->_key_exists === FALSE)\n        {\n            if ($this->_redis->set($this->_key_prefix.$session_id, $session_data, $this->_config['expiration']))\n            {\n                $this->_fingerprint = $fingerprint;\n                $this->_key_exists = TRUE;\n                return $this->_success();\n            }\n\n            return $this->_fail();\n        }\n\n        return ($this->_redis->expire($this->_key_prefix.$session_id, $this->_config['expiration'])) ? $this->_success() : $this->_fail();\n    }\n\n    public function close()\n    {\n        if (isset($this->_redis))\n        {\n            try {\n                if ($this->_redis->ping() === '+PONG')\n                {\n                    $this->_release_lock();\n                    if ($this->_redis->close() === FALSE)\n                    {\n                        return $this->_fail();\n                    }\n                }\n            }\n            catch (RedisException $e)\n            {\n                log_message('error', 'Session: Got RedisException on close(): '.$e->getMessage());\n            }\n\n            $this->_redis = NULL;\n            return $this->_success();\n        }\n\n        return $this->_success();\n    }\n\n    public function destroy($session_id)\n    {\n        if (isset($this->_redis, $this->_lock_key))\n        {\n            if (($result = $this->_redis->del($this->_key_prefix.$session_id)) !== 1)\n            {\n                log_message('debug', 'Session: Redis::del() expected to return 1, got '.var_export($result, TRUE).' instead.');\n            }\n\n            $this->_cookie_destroy();\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    public function gc($maxlifetime)\n    {\n        return $this->_success();\n    }\n\n    protected function _get_lock($session_id)\n    {\n        if (isset($this->_lock_key))\n        {\n            return $this->_redis->expire($this->_lock_key, 300);\n        }\n\n\n        $lock_key = $this->_key_prefix.$session_id.':lock';\n        if (($this->_lock_key = $this->_redis->set($lock_key, time(), array('nx', 'ex' => 300))) === FALSE)\n        {\n            log_message('debug', 'Session: Error while trying to obtain lock for '.$this->_key_prefix.$session_id);\n            return FALSE;\n        }\n\n        $this->_lock = TRUE;\n        return TRUE;\n    }\n\n    protected function _release_lock()\n    {\n        if (isset($this->_redis, $this->_lock_key) && $this->_lock)\n        {\n            if (! $this->_redis->del($this->_lock_key))\n            {\n                log_message('error', 'Session: Error while trying to free lock for '.$this->_lock_key);\n                return FALSE;\n            }\n\n            $this->_lock_key = NULL;\n            $this->_lock = FALSE;\n        }\n\n        return TRUE;\n    }\n\n    protected function _fail()\n    {\n        isset($this->_redis) && $this->_redis->close();\n        $this->_redis = NULL;\n        return FALSE;\n    }\n\n\n    protected function _success()\n    {\n        return TRUE;\n    }\n\n}\n",
      "<?php\nclass CI_Session_redis_driver extends CI_Session_driver implements SessionHandlerInterface {\n\n    protected $_redis;\n    protected $_key_prefix = 'ci_session:';\n    protected $_lock_key;\n    protected $_key_exists = FALSE;\n    protected $_config = array(\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0,\n        'database' => 0\n    );\n\n    protected $_session_id;\n    protected $_fingerprint;\n\n    public function __construct(&$params)\n    {\n        parent::__construct($params);\n\n        $this->_config = array_merge($this->_config, $params);\n\n        if (empty($this->_config['save_path']))\n        {\n            log_message('error', 'Session: No Redis save path configured.');\n        }\n        elseif (preg_match('#^unix://([^\\?]+)(\\?.+)?$#', $this->_config['save_path'], $matches))\n        {\n            $this->_config['socket'] = $matches[1];\n        }\n        elseif (preg_match('#(?:tcp://)?([^:?]+)(?:\\:(\\d+))?(\\?.+)?#', $this->_config['save_path'], $matches))\n        {\n            $this->_config['host'] = $matches[1];\n            $this->_config['port'] = empty($matches[2]) ? 6379 : $matches[2];\n        }\n        else\n        {\n            log_message('error', 'Session: Invalid Redis save path format: ' . $this->_config['save_path']);\n        }\n\n\n    }\n\n    public function open($save_path, $name)\n    {\n        $this->_redis = new Redis();\n\n        $connected = isset($this->_config['socket'])\n            ? $this->_redis->connect($this->_config['socket'])\n            : $this->_redis->connect($this->_config['host'], $this->_config['port'], $this->_config['timeout']);\n\n        if ($connected && ! empty($this->_config['password']))\n        {\n            $connected = $this->_redis->auth($this->_config['password']);\n        }\n\n        if ($connected && $this->_config['database'] !== 0)\n        {\n            $connected = $this->_redis->select($this->_config['database']);\n        }\n\n        if ( ! $connected)\n        {\n            log_message('error', 'Session: Unable to connect to Redis with the configured settings.');\n        }\n\n        return $connected;\n    }\n\n    public function read($session_id)\n    {\n        $this->_session_id = $session_id;\n\n        $session_data = (string) $this->_redis->get($this->_key_prefix.$session_id);\n\n        $this->_fingerprint = md5($session_data);\n        $this->_key_exists = ! empty($session_data);\n\n        return $session_data;\n    }\n\n    public function write($session_id, $session_data)\n    {\n        if ( ! isset($this->_session_id))\n        {\n            $this->_session_id = $session_id;\n        }\n        elseif ($session_id !== $this->_session_id)\n        {\n            if ( ! $this->destroy($this->_session_id))\n            {\n                return $this->_fail();\n            }\n\n            $this->_session_id = $session_id;\n            $this->_key_exists = FALSE;\n        }\n\n        if ($this->_fingerprint !== ($fingerprint = md5($session_data)))\n        {\n            if ($this->_redis->set($this->_key_prefix.$session_id, $session_data, $this->_config['expiration']))\n            {\n                $this->_fingerprint = $fingerprint;\n                return $this->_success();\n            }\n\n            return $this->_fail();\n        }\n\n        return ($this->_redis->expire($this->_key_prefix.$session_id, $this->_config['expiration']))\n            ? $this->_success()\n            : $this->_fail();\n    }\n\n    public function close()\n    {\n        return ($this->_redis->close() && $this->_release_lock());\n    }\n\n    public function destroy($session_id)\n    {\n        if (isset($this->_session_id) && $session_id !== $this->_session_id)\n        {\n            if ( ! $this->destroy($this->_session_id))\n            {\n                return $this->_fail();\n            }\n        }\n\n        return ($this->_redis->del($this->_key_prefix.$session_id) === 1)\n            ? $this->_success()\n            : $this->_fail();\n    }\n\n    public function gc($maxlifetime)\n    {\n        return TRUE;\n    }\n\n    protected function _get_lock($session_id)\n    {\n        $this->_lock_key = $this->_key_prefix.$session_id.':lock';\n        return ($this->_redis->setnx($this->_lock_key, time()));\n    }\n\n    protected function _release_lock()\n    {\n        if (isset($this->_lock_key))\n        {\n            $this->_redis->del($this->_lock_key);\n            unset($this->_lock_key);\n        }\n\n        return TRUE;\n    }\n\n    protected function _fail()\n    {\n        return FALSE;\n    }\n\n    protected function _success()\n    {\n        return TRUE;\n    }\n\n}\n",
      "<?php\ndefined('BASEPATH') OR exit('No direct script access allowed');\n\nclass CI_Session_redis_driver extends CI_Session_driver implements SessionHandlerInterface {\n\n\tprotected $_redis;\n\tprotected $_key_prefix = 'ci_session:';\n\tprotected $_lock_key;\n\tprotected $_key_exists = FALSE;\n\tprotected $_config = array(\n\t\t'host' => '127.0.0.1',\n\t\t'password' => NULL,\n\t\t'port' => 6379,\n\t\t'timeout' => 0,\n\t\t'database' => 0\n\t);\n\n\tprotected $_session_id;\n\tprotected $_fingerprint;\n\n\tpublic function __construct(&$params)\n\t{\n\t\tparent::__construct($params);\n\n\t\tif (isset($params['save_path']))\n\t\t{\n\t\t\t$parameters = explode(',', $params['save_path']);\n\n\t\t\tforeach ($parameters as $parameter)\n\t\t\t{\n\t\t\t\tlist($key, $value) = explode('=', $parameter, 2);\n\t\t\t\tif ( ! isset($this->_config[$key]))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$this->_config[$key] = $value;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function open($save_path, $name)\n\t{\n\t\t$this->_redis = new Redis();\n\t\t$connected = $this->_redis->connect($this->_config['host'], $this->_config['port'], $this->_config['timeout']);\n\n\t\tif ($connected && isset($this->_config['password']) && ! $this->_redis->auth($this->_config['password']))\n\t\t{\n\t\t\tlog_message('error', 'Session: Unable to authenticate to Redis instance.');\n\t\t\treturn $this->_fail();\n\t\t}\n\n\t\tif ($connected && $this->_config['database'] !== 0 && ! $this->_redis->select($this->_config['database']))\n\t\t{\n\t\t\tlog_message('error', 'Session: Unable to select Redis database with index '.$this->_config['database']);\n\t\t\treturn $this->_fail();\n\t\t}\n\n\t\treturn $connected ? $this->_success() : $this->_fail();\n\t}\n\n\tpublic function read($session_id)\n\t{\n\t\t$this->_session_id = $session_id;\n\t\t$this->_lock_key = $this->_key_prefix.$session_id.':lock';\n\t\tif ($this->_get_lock($session_id))\n\t\t{\n\t\t\t$session_data = (string) $this->_redis->get($this->_key_prefix.$session_id);\n\t\t\t$this->_fingerprint = md5($session_data);\n\t\t\t$this->_key_exists = ! empty($session_data);\n\t\t\t$this->_release_lock();\n\t\t\treturn $session_data;\n\t\t}\n\n\t\treturn $this->_fail();\n\t}\n\n\tpublic function write($session_id, $session_data)\n\t{\n\t\tif ( ! isset($this->_lock_key))\n\t\t{\n\t\t\t$this->_lock_key = $this->_key_prefix.$session_id.':lock';\n\t\t}\n\t\telseif ($session_id !== $this->_session_id)\n\t\t{\n\t\t\tif ( ! $this->_release_lock() OR ! $this->_get_lock($session_id))\n\t\t\t{\n\t\t\t\treturn $this->_fail();\n\t\t\t}\n\n\t\t\t$this->_key_exists = FALSE;\n\t\t\t$this->_session_id = $session_id;\n\t\t}\n\n\t\tif ( ! $this->_lock_key)\n\t\t{\n\t\t\treturn $this->_fail();\n\t\t}\n\n\t\t$this->_fingerprint = md5($session_data);\n\t\tif ($this->_redis->set($this->_key_prefix.$session_id, $session_data, $this->_config['expiration']))\n\t\t{\n\t\t\t$this->_key_exists = TRUE;\n\t\t\treturn $this->_success();\n\t\t}\n\n\t\treturn $this->_fail();\n\t}\n\n\tpublic function close()\n\t{\n\t\treturn ($this->_redis->close() && $this->_release_lock()) ? $this->_success() : $this->_fail();\n\t}\n\n\tpublic function destroy($session_id)\n\t{\n\t\tif ( ! isset($this->_lock_key))\n\t\t{\n\t\t\t$this->_lock_key = $this->_key_prefix.$session_id.':lock';\n\t\t}\n\t\telseif ($session_id !== $this->_session_id)\n\t\t{\n\t\t\tif ( ! $this->_release_lock() OR ! $this->_get_lock($session_id))\n\t\t\t{\n\t\t\t\treturn $this->_fail();\n\t\t\t}\n\n\t\t\t$this->_key_exists = FALSE;\n\t\t\t$this->_session_id = $session_id;\n\t\t}\n\n\t\tif ( ! $this->_lock_key)\n\t\t{\n\t\t\treturn $this->_fail();\n\t\t}\n\n\t\treturn ($this->_redis->del($this->_key_prefix.$session_id) && $this->_release_lock())\n\t\t\t? $this->_success()\n\t\t\t: $this->_fail();\n\t}\n\n\tpublic function gc($maxlifetime)\n\t{\n\t\t// Not necessary for Redis\n\t\treturn $this->_success();\n\t}\n\n\tprotected function _get_lock($session_id)\n\t{\n\t\t// PHP 7 reuses the SessionHandler object on regeneration,\n\t\t// so we need to check here if the lock key is for the\n\t\t// correct session ID.\n\t\tif ($this->_lock_key === $this->_key_prefix.$session_id.':lock')\n\t\t{\n\t\t\treturn $this->_redis->setnx($this->_lock_key, time());\n\t\t}\n\n\t\t// If the lock key is not correct, release this lock, and try to get a new one\n\t\tif ($this->_lock_key)\n\t\t{\n\t\t\t$this->_release_lock();\n\t\t}\n\n\t\t$this->_lock_key = $this->_key_prefix.$session_id.':lock';\n\t\treturn $this->_redis->setnx($this->_lock_key, time());\n\t}\n\n\tprotected function _release_lock()\n\t{\n\t\tif (isset($this->_lock_key) && $this->_redis->del($this->_lock_key))\n\t\t{\n\t\t\t$this->_lock_key = NULL;\n\t\t\treturn TRUE;\n\t\t}\n\n\t\treturn FALSE;\n\t}\n\n\tprotected function _fail()\n\t{\n\t\tlog_message('error', 'Session: Error while executing Redis command. Ensure your Redis server is running.');\n\t\treturn FALSE;\n\t}\n\n\tprotected function _success()\n\t{\n\t\treturn TRUE;\n\t}\n}\n",
      "<?php\nclass CI_Session_redis_driver extends CI_Session_driver implements SessionHandlerInterface {\n\n    protected $_redis;\n    protected $_key_prefix = 'ci_session:';\n    protected $_lock_key;\n    protected $_key_exists = FALSE;\n    protected $_config = array(\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0,\n        'database' => 0\n    );\n\n\n    public function __construct(&$params)\n    {\n        parent::__construct($params);\n\n        $this->_config = array_merge($this->_config, $params);\n\n        if (empty($this->_config['save_path']))\n        {\n            log_message('error', 'Session: No Redis save path configured.');\n        }\n        elseif (preg_match('#^unix://([^\\?]+)(\\?.+)?$#', $this->_config['save_path'], $matches))\n        {\n            $this->_config['socket'] = $matches[1];\n        }\n        else\n        {\n            $parts = explode(':', $this->_config['save_path'], 2);\n            $this->_config['host'] = isset($parts[0]) ? $parts[0] : '127.0.0.1';\n            $this->_config['port'] = isset($parts[1]) ? $parts[1] : 6379;\n            if (isset($parts[2])) {\n                $this->_config['database'] = $parts[2];\n            }\n        }\n    }\n\n    public function open($save_path, $name)\n    {\n        $this->_redis = new Redis();\n\n        $isConnected = isset($this->_config['socket'])\n            ? $this->_redis->connect($this->_config['socket'])\n            : $this->_redis->connect($this->_config['host'], $this->_config['port'], $this->_config['timeout']);\n\n        if ($isConnected && isset($this->_config['password']) && ! $this->_redis->auth($this->_config['password']))\n        {\n            log_message('error', 'Session: Unable to authenticate to Redis instance.');\n            $isConnected = FALSE;\n        }\n\n        if ($isConnected && $this->_config['database'] !== 0 && ! $this->_redis->select($this->_config['database']))\n        {\n            log_message('error', 'Session: Unable to select Redis database with index ' . $this->_config['database']);\n            $isConnected = FALSE;\n        }\n\n        return $isConnected;\n    }\n\n    public function read($session_id)\n    {\n        if (isset($this->_redis) && $this->_get_lock($session_id))\n        {\n            $session_data = (string) $this->_redis->get($this->_key_prefix.$session_id);\n            $this->_fingerprint = md5($session_data);\n            $this->_key_exists = TRUE;\n            $this->_session_id = $session_id;\n            return $session_data;\n        }\n\n        return '';\n    }\n\n    public function write($session_id, $session_data)\n    {\n        if ( ! isset($this->_redis, $this->_lock_key))\n        {\n            return $this->_fail();\n        }\n        elseif ($session_id !== $this->_session_id)\n        {\n            if ( ! $this->_release_lock() OR ! $this->_get_lock($session_id))\n            {\n                return $this->_fail();\n            }\n\n            $this->_key_exists = FALSE;\n            $this->_session_id = $session_id;\n        }\n\n        if ($this->_fingerprint !== ($fingerprint = md5($session_data)))\n        {\n            if ($this->_redis->set($this->_key_prefix.$session_id, $session_data, $this->_config['expiration']))\n            {\n                $this->_fingerprint = $fingerprint;\n                return $this->_success();\n            }\n\n            return $this->_fail();\n        }\n\n        return ($this->_redis->expire($this->_key_prefix.$session_id, $this->_config['expiration']))\n            ? $this->_success()\n            : $this->_fail();\n    }\n\n    public function close()\n    {\n        return (isset($this->_redis) && $this->_redis->close()) ? $this->_success() : $this->_fail();\n    }\n\n    public function destroy($session_id)\n    {\n        if (isset($this->_redis, $this->_lock_key))\n        {\n            if (($result = $this->_redis->del($this->_key_prefix.$session_id)) !== 1)\n            {\n                log_message('debug', 'Session: Redis::del() expected to return 1, got '.var_export($result, TRUE).' instead.');\n            }\n\n            $this->_cookie_destroy();\n            return $this->_success();\n        }\n\n        return $this->_fail();\n    }\n\n    public function gc($maxlifetime)\n    {\n        return $this->_success();\n    }\n\n    protected function _get_lock($session_id)\n    {\n        $lock_key = $this->_key_prefix.$session_id.':lock';\n        if (($ttl = $this->_redis->ttl($lock_key)) > 0)\n        {\n            sleep(ceil($ttl / 1000));\n            return $this->_get_lock($session_id);\n        }\n\n        $result = ($this->_redis->setnx($lock_key, time())) ? $this->_redis->expire($lock_key, 300) : FALSE;\n\n        if ($result)\n        {\n            $this->_lock_key = $lock_key;\n            return TRUE;\n        }\n\n        return FALSE;\n    }\n\n    protected function _release_lock()\n    {\n        if (isset($this->_redis, $this->_lock_key) && $this->_redis->del($this->_lock_key))\n        {\n            $this->_lock_key = NULL;\n            return TRUE;\n        }\n\n        return FALSE;\n    }\n\n    protected function _fail()\n    {\n        log_message('error', 'Session: Redis operation failed.');\n        return FALSE;\n    }\n\n    protected function _success()\n    {\n        return TRUE;\n    }\n\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a PHP class that provides a Redis-based queue management system with connection handling, basic Redis operations, and error recovery mechanisms.\n\nClass Description: The `queue` class is a Redis wrapper that manages connections to Redis servers and provides common Redis operations with automatic reconnection on failure. It supports multiple Redis connections, connection pooling, and prefixing of keys.\n\nAttributes:\n- `$redis`: [static, mixed] - Placeholder for Redis instance (deprecated in favor of `$links`)\n- `$configs`: [static, array] - Stores configuration for different Redis connections\n- `$links`: [static, array] - Maintains active Redis connections\n- `$link_name`: [static, string] - Current connection name (defaults to 'default')\n- `$prefix`: [static, string] - Default prefix for Redis keys\n- `$error`: [static, string] - Stores the last error message\n\nMethods:\n- `init()` -> [bool|Redis] - Initializes Redis connection using current configuration. Returns Redis instance or false on failure.\n- `set($key, $value, $expire = 0)` -> [bool|null] - Sets a key-value pair in Redis with optional expiration. Returns true on success, null on failure.\n- `get($key)` -> [mixed|null] - Retrieves a value by key from Redis. Returns the value or null on failure.\n- `del($key)` -> [int|null] - Deletes a key from Redis. Returns number of deleted keys or null on failure.\n- `_get_default_config()` -> [array] - Retrieves default Redis configuration from global settings.\n- `clear_link()` -> [void] - Closes all active Redis connections and clears the connection pool.\n\nInput:\n- Configuration via `$GLOBALS['config']['redis']` for default connection\n- Method parameters as described above\n\nOutput:\n- For connection methods: Redis instance or boolean\n- For data operations: Various return types as described above\n- Error messages stored in `$error` property",
    "Canonical_solution": "namespace phpspider\\core;\n\nuse Exception;\nuse Redis;\n\nclass queue\n{\n    protected static $redis = NULL;\n    protected static $configs = array();\n    private static $links = array();\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!extension_loaded('redis'))\n        {\n            self::$error = 'The redis extension was not found';\n            return false;\n        }\n\n        $config = self::$link_name == 'default' ? self::_get_default_config() : self::$configs[self::$link_name];\n\n        if (empty(self::$links[self::$link_name]))\n        {\n            self::$links[self::$link_name] = new Redis();\n            if (strstr($config['host'], '.sock'))\n            {\n                if (!self::$links[self::$link_name]->connect($config['host']))\n                {\n                    self::$error = 'Unable to connect to redis server';\n                    unset(self::$links[self::$link_name]);\n                    return false;\n                }\n            }\n            else\n            {\n                if (!self::$links[self::$link_name]->connect($config['host'], $config['port'], $config['timeout']))\n                {\n                    self::$error = 'Unable to connect to redis server';\n                    unset(self::$links[self::$link_name]);\n                    return false;\n                }\n            }\n\n            if ($config['pass'])\n            {\n                if (!self::$links[self::$link_name]->auth($config['pass']))\n                {\n                    self::$error = 'Redis Server authentication failed';\n                    unset(self::$links[self::$link_name]);\n                    return false;\n                }\n            }\n\n            $prefix = empty($config['prefix']) ? self::$prefix : $config['prefix'];\n            self::$links[self::$link_name]->setOption(Redis::OPT_PREFIX, $prefix.':');\n            self::$links[self::$link_name]->setOption(Redis::OPT_READ_TIMEOUT, -1);\n            self::$links[self::$link_name]->select($config['db']);\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        self::init();\n        try\n        {\n            if (self::$links[self::$link_name])\n            {\n                if ($expire > 0)\n                {\n                    return self::$links[self::$link_name]->setex($key, $expire, $value);\n                }\n                else\n                {\n                    return self::$links[self::$link_name]->set($key, $value);\n                }\n            }\n        }\n        catch (Exception $e)\n        {\n            $msg = \"PHP Fatal error:  Uncaught exception 'RedisException' with message '\".$e->getMessage().\"'\\n\";\n            log::warn($msg);\n            if ($e->getCode() == 0) \n            {\n                self::$links[self::$link_name]->close();\n                self::$links[self::$link_name] = null;\n                usleep(100000);\n                return self::set($key, $value, $expire);\n            }\n        }\n        return NULL;\n    }\n\n    public static function get($key)\n    {\n        self::init();\n        try\n        {\n            if (self::$links[self::$link_name])\n            {\n                return self::$links[self::$link_name]->get($key);\n            }\n        }\n        catch (Exception $e)\n        {\n            $msg = \"PHP Fatal error:  Uncaught exception 'RedisException' with message '\".$e->getMessage().\"'\\n\";\n            log::warn($msg);\n            if ($e->getCode() == 0) \n            {\n                self::$links[self::$link_name]->close();\n                self::$links[self::$link_name] = null;\n                usleep(100000);\n                return self::get($key);\n            }\n        }\n        return NULL;\n    }\n\n    public static function del($key)\n    {\n        self::init();\n        try\n        {\n            if (self::$links[self::$link_name])\n            {\n                return self::$links[self::$link_name]->del($key);\n            }\n        }\n        catch (Exception $e)\n        {\n            $msg = \"PHP Fatal error:  Uncaught exception 'RedisException' with message '\".$e->getMessage().\"'\\n\";\n            log::warn($msg);\n            if ($e->getCode() == 0) \n            {\n                self::$links[self::$link_name]->close();\n                self::$links[self::$link_name] = null;\n                usleep(100000);\n                return self::del($key);\n            }\n        }\n        return NULL;\n    }\n\n    protected static function _get_default_config()\n    {\n        if (empty(self::$configs['default']))\n        {\n            if (!is_array($GLOBALS['config']['redis']))\n            {\n                exit('cls_redis.php _get_default_config()' . '没有redis配置');\n            }\n            self::$configs['default'] = $GLOBALS['config']['redis'];\n        }\n        return self::$configs['default'];\n    }\n\n    public static function clear_link()\n    {\n        if(self::$links) \n        {\n            foreach(self::$links as $k=>$v)\n            {\n                $v->close();\n                unset(self::$links[$k]);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 144,
    "matched_results": [
      "<?php\nclass queue\n{\n    public static $redis;\n    public static $configs = [];\n    public static $links = [];\n    public static $link_name = 'default';\n    public static $prefix = '';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!isset(self::$configs[self::$link_name])) {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        if (!empty(self::$links[self::$link_name]) && self::$links[self::$link_name]->ping()) {\n            return self::$links[self::$link_name];\n        }\n\n        $config = self::$configs[self::$link_name];\n        $redis = new Redis();\n        $ret = $redis->connect($config['host'], $config['port'], $config['timeout']);\n\n        if (!$ret) {\n            self::$error = 'Connect to redis server failed: ' . $redis->getLastError();\n            return false;\n        }\n\n        if (!empty($config['password']) && !$redis->auth($config['password'])) {\n            self::$error = 'Redis auth failed: ' . $redis->getLastError();\n            return false;\n        }\n\n        if (!empty($config['database']) && !$redis->select($config['database'])) {\n            self::$error = 'Select redis database failed: ' . $redis->getLastError();\n            return false;\n        }\n\n        self::$links[self::$link_name] = $redis;\n        self::$redis = &self::$links[self::$link_name];\n        return $redis;\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        if ($expire > 0) {\n            return $redis->setex($key, $expire, $value);\n        } else {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        return $redis->get($key);\n    }\n\n    public static function del($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        return $redis->del($key);\n    }\n\n\n    private static function _get_default_config()\n    {\n        $config = $GLOBALS['config']['redis'];\n        return [\n            'host' => $config['host'],\n            'port' => $config['port'],\n            'password' => $config['password'],\n            'database' => $config['database'],\n            'timeout' => $config['timeout'],\n        ];\n    }\n\n    public static function clear_link()\n    {\n        foreach (self::$links as $link) {\n            if ($link) {\n                $link->close();\n            }\n        }\n        self::$links = [];\n    }\n}\n\n?>\n",
      "<?php\nclass queue\n{\n    static $redis;\n    static $configs = [];\n    static $links = [];\n    static $link_name = 'default';\n    static $prefix = '';\n    static $error = '';\n\n    static function init()\n    {\n        if (!empty(self::$links[self::$link_name])) {\n            return self::$links[self::$link_name];\n        }\n        $config = self::$configs[self::$link_name] ?? self::_get_default_config();\n        if (empty($config)) {\n            self::$error = 'No config found for ' . self::$link_name;\n            return false;\n        }\n\n        $redis = new Redis();\n        $ret = $redis->connect($config['host'], $config['port'], $config['timeout'] ?? 1);\n        if (!$ret) {\n            self::$error = 'Connect to redis failed: ' . $redis->getLastError();\n            return false;\n        }\n\n        if (!empty($config['password']) && !$redis->auth($config['password'])) {\n            self::$error = 'Auth failed: ' . $redis->getLastError();\n            return false;\n        }\n\n        if (!empty($config['database']) && !$redis->select($config['database'])) {\n            self::$error = 'Select database failed: ' . $redis->getLastError();\n            return false;\n        }\n\n        self::$links[self::$link_name] = $redis;\n        self::$redis = $redis; // deprecated\n        return $redis;\n    }\n\n    static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        if ($expire > 0) {\n            return $redis->setex($key, $expire, $value);\n        } else {\n            return $redis->set($key, $value);\n        }\n    }\n\n    static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        return $redis->get($key);\n    }\n\n    static function del($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        return $redis->del($key);\n    }\n\n\n    static private function _get_default_config()\n    {\n        return $GLOBALS['config']['redis'] ?? [];\n    }\n\n    static function clear_link()\n    {\n        foreach (self::$links as $link) {\n            try {\n                $link->close();\n            } catch (Exception $e) {\n                // Ignore connection errors during cleanup\n            }\n        }\n        self::$links = [];\n    }\n}\n\n?>\n",
      "<?php\nclass queue\n{\n    public static $redis;\n    public static $configs = [];\n    public static $links = [];\n    public static $link_name = 'default';\n    public static $prefix = '';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!empty(self::$links[self::$link_name])) {\n            return self::$links[self::$link_name];\n        }\n\n        if (empty(self::$configs[self::$link_name])) {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        try {\n            $redis = new Redis();\n            if ($config['socket_type'] === 'unix') {\n                $success = $redis->connect($config['socket']);\n            } else {\n                $success = $redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if (!$success) {\n                self::$error = 'Failed to connect to Redis';\n                return false;\n            }\n\n            if (!empty($config['password'])) {\n                $redis->auth($config['password']);\n            }\n\n            if (!empty($config['database'])) {\n                $redis->select($config['database']);\n            }\n\n            self::$links[self::$link_name] = $redis;\n            self::$redis = &self::$links[self::$link_name]; // Deprecated\n            return $redis;\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            return false;\n        }\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            if ($expire > 0) {\n                return $redis->setex($key, $expire, $value);\n            } else {\n                return $redis->set($key, $value);\n            }\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            return $redis->get($key);\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n    public static function del($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            return $redis->del($key);\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n\n    private static function _get_default_config()\n    {\n        return $GLOBALS['config']['redis'] ?? [\n            'host' => '127.0.0.1',\n            'port' => 6379,\n            'timeout' => 0.5,\n            'password' => '',\n            'database' => 0,\n            'socket_type' => 'tcp',\n            'socket' => '/var/run/redis/redis.sock'\n        ];\n    }\n\n    public static function clear_link()\n    {\n        foreach (self::$links as $link) {\n            try {\n                $link->close();\n            } catch (Exception $e) {\n                // Ignore errors during closure\n            }\n        }\n        self::$links = [];\n    }\n}\n\n?>\n",
      "<?php\nclass queue\n{\n    static $redis;\n    static $configs = [];\n    static $links = [];\n    static $link_name = 'default';\n    static $prefix = '';\n    static $error = '';\n\n    static function init()\n    {\n        if (!empty(self::$links[self::$link_name])) {\n            return self::$links[self::$link_name];\n        }\n        $config = self::$configs[self::$link_name] ?? self::_get_default_config();\n        if (empty($config)) {\n            return false;\n        }\n\n        try {\n            $redis = new Redis();\n            if ($config['socket_type'] === 'unix') {\n                $success = $redis->connect($config['socket']);\n            } else {\n                $success = $redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if (!$success) {\n                self::$error = \"Failed to connect to Redis server.\";\n                return false;\n            }\n\n            if (!empty($config['password']) && !$redis->auth($config['password'])) {\n                self::$error = \"Redis authentication failed.\";\n                return false;\n            }\n\n            if (!empty($config['database']) && !$redis->select($config['database'])) {\n                self::$error = \"Failed to select Redis database.\";\n                return false;\n            }\n            self::$links[self::$link_name] = $redis;\n            self::$redis = $redis;\n            return $redis;\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            return false;\n        }\n    }\n\n\n    static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            if ($expire > 0) {\n                return $redis->setex($key, $expire, $value);\n            } else {\n                return $redis->set($key, $value);\n            }\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            return null;\n        }\n    }\n\n    static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            return $redis->get($key);\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            return null;\n        }\n    }\n\n    static function del($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            return $redis->del($key);\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            return null;\n        }\n    }\n\n\n    static private function _get_default_config()\n    {\n        return $GLOBALS['config']['redis'] ?? [];\n    }\n\n    static function clear_link()\n    {\n        foreach (self::$links as $link) {\n            try {\n                $link->close();\n            } catch (Exception $e) {\n                // Ignore potential errors during closure\n            }\n        }\n        self::$links = [];\n        self::$redis = null;\n    }\n}\n\n?>\n",
      "<?php\nclass queue\n{\n    public static $redis;\n    public static $configs = [];\n    public static $links = [];\n    public static $link_name = 'default';\n    public static $prefix = '';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!empty(self::$links[self::$link_name])) {\n            return self::$links[self::$link_name];\n        }\n\n        if (empty(self::$configs[self::$link_name])) {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        try {\n            self::$links[self::$link_name] = new Redis();\n            if ($config['socket_type'] === 'unix') {\n                $success = self::$links[self::$link_name]->connect($config['socket']);\n            } else {\n                $success = self::$links[self::$link_name]->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if (!$success) {\n                self::$error = 'Cannot connect to redis';\n                return false;\n            }\n\n            if (!empty($config['password'])) {\n                self::$links[self::$link_name]->auth($config['password']);\n            }\n\n            if (!empty($config['db'])) {\n                self::$links[self::$link_name]->select($config['db']);\n            }\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            return false;\n        }\n\n        self::$redis =& self::$links[self::$link_name];\n        return self::$redis;\n    }\n\n\n    public static function set($key, $value, $expire = 0)\n    {\n        if (!self::init()) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            if ($expire > 0) {\n                return self::$redis->setex($key, $expire, $value);\n            } else {\n                return self::$redis->set($key, $value);\n            }\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n    public static function get($key)\n    {\n        if (!self::init()) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            return self::$redis->get($key);\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n    public static function del($key)\n    {\n        if (!self::init()) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            return self::$redis->del($key);\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n\n    private static function _get_default_config()\n    {\n        $config = $GLOBALS['config']['redis'];\n        return [\n            'host' => !empty($config['host']) ? $config['host'] : '127.0.0.1',\n            'port' => !empty($config['port']) ? $config['port'] : 6379,\n            'timeout' => !empty($config['timeout']) ? $config['timeout'] : 0.5,\n            'password' => !empty($config['password']) ? $config['password'] : '',\n            'db' => !empty($config['db']) ? $config['db'] : 0,\n            'socket_type' => !empty($config['socket_type']) ? $config['socket_type'] : 'tcp',\n            'socket' => !empty($config['socket']) ? $config['socket'] : '/var/run/redis/redis.sock',\n        ];\n    }\n\n    public static function clear_link()\n    {\n        foreach (self::$links as $link) {\n            try {\n                if ($link) {\n                    $link->close();\n                }\n            } catch (Exception $e) {\n                // Ignore connection closing errors\n            }\n        }\n        self::$links = [];\n    }\n}\n\n?>\n",
      "<?php\nclass queue\n{\n    public static $redis;\n    public static $configs = [];\n    public static $links = [];\n    public static $link_name = 'default';\n    public static $prefix = '';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!empty(self::$links[self::$link_name])) {\n            return self::$links[self::$link_name];\n        }\n        $config = self::$configs[self::$link_name] ?? self::_get_default_config();\n        if (empty($config)) {\n            self::$error = 'No config found for ' . self::$link_name;\n            return false;\n        }\n\n        $redis = new Redis();\n        $ret = $redis->connect($config['host'], $config['port'], $config['timeout'] ?? 3);\n        if (!$ret) {\n            self::$error = 'Connect to redis failed: ' . $redis->getLastError();\n            return false;\n        }\n\n        if (!empty($config['password'])) {\n            $ret = $redis->auth($config['password']);\n            if (!$ret) {\n                self::$error = 'Auth failed: ' . $redis->getLastError();\n                return false;\n            }\n        }\n\n        if (!empty($config['database'])) {\n            $redis->select($config['database']);\n        }\n\n        self::$links[self::$link_name] = $redis;\n        self::$redis = $redis; // deprecated\n        return $redis;\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        if ($expire > 0) {\n            return $redis->setex($key, $expire, $value);\n        } else {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        return $redis->get($key);\n    }\n\n    public static function del($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        return $redis->del($key);\n    }\n\n    private static function _get_default_config()\n    {\n        return $GLOBALS['config']['redis'] ?? [];\n    }\n\n    public static function clear_link()\n    {\n        foreach (self::$links as $link) {\n            try {\n                $link->close();\n            } catch (Exception $e) {\n                // Ignore potential errors during closure\n            }\n        }\n        self::$links = [];\n    }\n}\n\n?>\n",
      "<?php\nclass queue\n{\n    static $redis;\n    static $configs = [];\n    static $links = [];\n    static $link_name = 'default';\n    static $prefix = '';\n    static $error = '';\n\n    static function init()\n    {\n        if (!empty(self::$links[self::$link_name])) {\n            return self::$links[self::$link_name];\n        }\n        $config = self::$configs[self::$link_name] ?? self::_get_default_config();\n        if (empty($config)) {\n            self::$error = 'No config found for ' . self::$link_name;\n            return false;\n        }\n\n        try {\n            $redis = new Redis();\n            if ($config['socket_type'] === 'unix') {\n                $success = $redis->connect($config['socket']);\n            } else {\n                $success = $redis->connect($config['host'], $config['port'], $config['timeout'] ?? 0.0);\n            }\n\n            if (!$success) {\n                self::$error = 'Failed to connect to Redis';\n                return false;\n            }\n\n            if (!empty($config['password']) && !$redis->auth($config['password'])) {\n                self::$error = 'Redis authentication failed';\n                return false;\n            }\n\n            if (!empty($config['db']) && !$redis->select($config['db'])) {\n                self::$error = 'Redis database selection failed';\n                return false;\n            }\n\n            self::$links[self::$link_name] = $redis;\n            self::$redis = &self::$links[self::$link_name]; // Deprecated\n            return $redis;\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            return false;\n        }\n    }\n\n\n    static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis) return null;\n        $key = self::$prefix . $key;\n        try {\n            if ($expire > 0) {\n                return $redis->setex($key, $expire, $value);\n            } else {\n                return $redis->set($key, $value);\n            }\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n    static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis) return null;\n        $key = self::$prefix . $key;\n        try {\n            return $redis->get($key);\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n    static function del($key)\n    {\n        $redis = self::init();\n        if (!$redis) return null;\n        $key = self::$prefix . $key;\n        try {\n            return $redis->del($key);\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n\n    static private function _get_default_config()\n    {\n        return $GLOBALS['config']['redis'] ?? [];\n    }\n\n    static function clear_link()\n    {\n        foreach (self::$links as $link) {\n            try {\n                $link->close();\n            } catch (Exception $e) {\n                // Ignore closing errors\n            }\n        }\n        self::$links = [];\n        self::$redis = null; // Deprecated\n    }\n}\n\n?>\n",
      "<?php\nclass queue\n{\n    public static $redis;\n    public static $configs = [];\n    public static $links = [];\n    public static $link_name = 'default';\n    public static $prefix = '';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!extension_loaded('redis')) {\n            self::$error = 'PHP Redis extension not loaded.';\n            return false;\n        }\n\n        if (!isset(self::$configs[self::$link_name])) {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        if (!isset(self::$links[self::$link_name]) || !self::$links[self::$link_name]->ping()) {\n            $redis = new Redis();\n            $ret = $config['persistent'] ? $redis->pconnect($config['host'], $config['port'], $config['timeout']) : $redis->connect($config['host'], $config['port'], $config['timeout']);\n\n            if (!$ret) {\n                self::$error = 'Failed to connect to Redis server.';\n                return false;\n            }\n\n            if ($config['password']) {\n                if (!$redis->auth($config['password'])) {\n                    self::$error = 'Redis authentication failed.';\n                    return false;\n                }\n            }\n\n            if ($config['database']) {\n                $redis->select($config['database']);\n            }\n            self::$links[self::$link_name] = $redis;\n        }\n        self::$redis =& self::$links[self::$link_name];\n        return self::$redis;\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        if (!self::init()) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        if ($expire) {\n            return self::$redis->setex($key, $expire, $value);\n        } else {\n            return self::$redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        if (!self::init()) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        return self::$redis->get($key);\n    }\n\n    public static function del($key)\n    {\n        if (!self::init()) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        return self::$redis->del($key);\n    }\n\n\n    private static function _get_default_config()\n    {\n        $config = $GLOBALS['config']['redis'] ?? [];\n        return array_merge([\n            'host' => '127.0.0.1',\n            'port' => 6379,\n            'password' => '',\n            'database' => 0,\n            'timeout' => 0.0,\n            'persistent' => false,\n        ], $config);\n    }\n\n    public static function clear_link()\n    {\n        foreach (self::$links as $link) {\n            try {\n                $link->close();\n            } catch (Exception $e) {\n                // Ignore potential exceptions during closure\n            }\n        }\n        self::$links = [];\n    }\n}\n\n?>\n",
      "<?php\nclass queue\n{\n    public static $redis;\n    public static $configs = [];\n    public static $links = [];\n    public static $link_name = 'default';\n    public static $prefix = '';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!extension_loaded('redis')) {\n            self::$error = 'PHP Redis extension not loaded.';\n            return false;\n        }\n\n        if (!isset(self::$configs[self::$link_name])) {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        if (!isset(self::$links[self::$link_name]) || !self::$links[self::$link_name]->ping()) {\n            try {\n                $redis = new Redis();\n                if ($config['socket_type'] === 'unix') {\n                    $redis->connect($config['socket']);\n                } else {\n                    $redis->connect($config['host'], $config['port'], $config['timeout']);\n                }\n\n                if (isset($config['password'])) {\n                    $redis->auth($config['password']);\n                }\n                if (isset($config['database'])) {\n                    $redis->select($config['database']);\n                }\n\n                self::$links[self::$link_name] = $redis;\n                self::$redis = &self::$links[self::$link_name]; // Deprecated\n            } catch (RedisException $e) {\n                self::$error = $e->getMessage();\n                return false;\n            }\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        if (!self::init()) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            if ($expire > 0) {\n                return self::$links[self::$link_name]->setex($key, $expire, $value);\n            } else {\n                return self::$links[self::$link_name]->set($key, $value);\n            }\n        } catch (RedisException $e) {\n            self::$error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public static function get($key)\n    {\n        if (!self::init()) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            return self::$links[self::$link_name]->get($key);\n        } catch (RedisException $e) {\n            self::$error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public static function del($key)\n    {\n        if (!self::init()) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            return self::$links[self::$link_name]->del($key);\n        } catch (RedisException $e) {\n            self::$error = $e->getMessage();\n            return null;\n        }\n    }\n\n    private static function _get_default_config()\n    {\n        return $GLOBALS['config']['redis'] ?? [\n            'socket_type' => 'tcp',\n            'host' => '127.0.0.1',\n            'port' => 6379,\n            'timeout' => 1,\n        ];\n    }\n\n    public static function clear_link()\n    {\n        foreach (self::$links as $link) {\n            try {\n                $link->close();\n            } catch (RedisException $e) {\n                // Ignore errors during cleanup\n            }\n        }\n        self::$links = [];\n    }\n}\n\n```",
      "<?php\nclass queue\n{\n    public static $redis;\n    public static $configs = [];\n    public static $links = [];\n    public static $link_name = 'default';\n    public static $prefix = '';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!empty(self::$links[self::$link_name])) {\n            return self::$links[self::$link_name];\n        }\n\n        if (empty(self::$configs[self::$link_name])) {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        try {\n            $redis = new Redis();\n            if ($config['socket_type'] === 'unix') {\n                $success = $redis->connect($config['socket']);\n            } else {\n                $success = $redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if (!$success) {\n                self::$error = 'Failed to connect to Redis';\n                return false;\n            }\n\n            if (!empty($config['password'])) {\n                $redis->auth($config['password']);\n            }\n\n            if (!empty($config['database'])) {\n                $redis->select($config['database']);\n            }\n\n            self::$links[self::$link_name] = $redis;\n            self::$redis = &self::$links[self::$link_name]; // Deprecated\n            return $redis;\n\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            return false;\n        }\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            if ($expire > 0) {\n                return $redis->setex($key, $expire, $value);\n            } else {\n                return $redis->set($key, $value);\n            }\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            return $redis->get($key);\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n    public static function del($key)\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        try {\n            return $redis->del($key);\n        } catch (Exception $e) {\n            self::$error = $e->getMessage();\n            self::clear_link();\n            return null;\n        }\n    }\n\n\n    private static function _get_default_config()\n    {\n        return $GLOBALS['config']['redis'] ?? [\n            'host' => '127.0.0.1',\n            'port' => 6379,\n            'timeout' => 0.5,\n            'password' => '',\n            'database' => 0,\n            'socket_type' => 'tcp',\n            'socket' => '/var/run/redis/redis.sock',\n        ];\n    }\n\n    public static function clear_link()\n    {\n        foreach (self::$links as $link) {\n            try {\n                $link->close();\n            } catch (Exception $e) {\n                // Ignore closing errors\n            }\n        }\n        self::$links = [];\n        self::$redis = null; // Deprecated\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a Redis cache driver class for CodeIgniter that implements basic cache operations using Redis as the backend storage.\n\nClass Description: The CI_Cache_redis class extends CI_Driver and provides an interface for caching data in Redis. It handles connection management, serialization of complex data types, and standard cache operations like get, save, delete, increment, and decrement.\n\nAttributes:\n- $_default_config: [array] - Default configuration for Redis connection\n- $_redis: [Redis] - Redis client instance\n- $_serialized: [array] - Track which keys contain serialized data\n\nMethods:\n- __construct() -> [void] - Initializes Redis connection using configuration\n- get($key) -> [mixed] - Retrieves data from cache by key\n- save($id, $data, $ttl = 60, $raw = FALSE) -> [bool] - Stores data in cache with optional TTL\n- delete($key) -> [bool] - Removes data from cache by key\n- increment($id, $offset = 1) -> [int|bool] - Increments a numeric value in cache\n- decrement($id, $offset = 1) -> [int|bool] - Decrements a numeric value in cache\n- clean() -> [bool] - Clears all cache entries\n- cache_info($type = NULL) -> [array] - Returns Redis server information\n- get_metadata($key) -> [array|bool] - Returns metadata about a cache entry\n- is_supported() -> [bool] - Checks if Redis extension is loaded\n- __destruct() -> [void] - Closes Redis connection when object is destroyed",
    "Canonical_solution": "class CI_Cache_redis extends CI_Driver\n{\n    protected static $_default_config = array(\n        'socket_type' => 'tcp',\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0\n    );\n\n    protected $_redis;\n    protected $_serialized = array();\n\n    public function __construct()\n    {\n        if ( ! $this->is_supported())\n        {\n            log_message('error', 'Cache: Failed to create Redis object; extension not loaded?');\n            return;\n        }\n\n        $CI =& get_instance();\n\n        if ($CI->config->load('redis', TRUE, TRUE))\n        {\n            $config = array_merge(self::$_default_config, $CI->config->item('redis'));\n        }\n        else\n        {\n            $config = self::$_default_config;\n        }\n\n        $this->_redis = new Redis();\n\n        try\n        {\n            if ($config['socket_type'] === 'unix')\n            {\n                $success = $this->_redis->connect($config['socket']);\n            }\n            else\n            {\n                $success = $this->_redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if ( ! $success)\n            {\n                log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n            }\n\n            if (isset($config['password']) && ! $this->_redis->auth($config['password']))\n            {\n                log_message('error', 'Cache: Redis authentication failed.');\n            }\n        }\n        catch (RedisException $e)\n        {\n            log_message('error', 'Cache: Redis connection refused ('.$e->getMessage().')');\n        }\n\n        $serialized = $this->_redis->sMembers('_ci_redis_serialized');\n        empty($serialized) OR $this->_serialized = array_flip($serialized);\n    }\n\n    public function get($key)\n    {\n        $value = $this->_redis->get($key);\n\n        if ($value !== FALSE && isset($this->_serialized[$key]))\n        {\n            return unserialize($value);\n        }\n\n        return $value;\n    }\n\n    public function save($id, $data, $ttl = 60, $raw = FALSE)\n    {\n        if (is_array($data) OR is_object($data))\n        {\n            if ( ! $this->_redis->sIsMember('_ci_redis_serialized', $id) && ! $this->_redis->sAdd('_ci_redis_serialized', $id))\n            {\n                return FALSE;\n            }\n\n            isset($this->_serialized[$id]) OR $this->_serialized[$id] = TRUE;\n            $data = serialize($data);\n        }\n        elseif (isset($this->_serialized[$id]))\n        {\n            $this->_serialized[$id] = NULL;\n            $this->_redis->sRemove('_ci_redis_serialized', $id);\n        }\n\n        return $this->_redis->set($id, $data, $ttl);\n    }\n\n    public function delete($key)\n    {\n        if ($this->_redis->delete($key) !== 1)\n        {\n            return FALSE;\n        }\n\n        if (isset($this->_serialized[$key]))\n        {\n            $this->_serialized[$key] = NULL;\n            $this->_redis->sRemove('_ci_redis_serialized', $key);\n        }\n\n        return TRUE;\n    }\n\n    public function increment($id, $offset = 1)\n    {\n        return $this->_redis->incr($id, $offset);\n    }\n\n    public function decrement($id, $offset = 1)\n    {\n        return $this->_redis->decr($id, $offset);\n    }\n\n    public function clean()\n    {\n        return $this->_redis->flushDB();\n    }\n\n    public function cache_info($type = NULL)\n    {\n        return $this->_redis->info();\n    }\n\n    public function get_metadata($key)\n    {\n        $value = $this->get($key);\n\n        if ($value !== FALSE)\n        {\n            return array(\n                'expire' => time() + $this->_redis->ttl($key),\n                'data' => $value\n            );\n        }\n\n        return FALSE;\n    }\n\n    public function is_supported()\n    {\n        return extension_loaded('redis');\n    }\n\n    public function __destruct()\n    {\n        if ($this->_redis)\n        {\n            $this->_redis->close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 144,
    "matched_results": [
      "<?php\nclass CI_Cache_redis extends CI_Driver {\n\n    protected $_default_config = array(\n        'socket_type' => 'tcp',\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0\n    );\n\n    protected $_redis;\n    protected $_serialized = array();\n\n    public function __construct()\n    {\n        $CI =& get_instance();\n        $CI->load->config('cache');\n\n        $config = array_merge($this->_default_config, $CI->config->item('redis'));\n\n        $this->_redis = new Redis();\n\n        try {\n            if ($config['socket_type'] === 'unix') {\n                $success = $this->_redis->connect($config['socket']);\n            } else {\n                $success = $this->_redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if ( ! $success) {\n                log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n            }\n\n            if (isset($config['password']) && ! $this->_redis->auth($config['password'])) {\n                log_message('error', 'Cache: Redis authentication failed.');\n            }\n        } catch (RedisException $e) {\n            log_message('error', 'Cache: Redis connection refused (' . $e->getMessage() . ')');\n        }\n\n    }\n\n    public function get($key)\n    {\n        $data = $this->_redis->get($key);\n\n        if ($data !== FALSE && isset($this->_serialized[$key]))\n        {\n            return unserialize($data);\n        }\n\n        return $data;\n    }\n\n\n    public function save($id, $data, $ttl = 60, $raw = FALSE)\n    {\n        if ( ! $raw && ! is_scalar($data))\n        {\n            $data = serialize($data);\n            $this->_serialized[$id] = TRUE;\n        }\n\n        return $this->_redis->set($id, $data, $ttl);\n    }\n\n    public function delete($key)\n    {\n        unset($this->_serialized[$key]);\n        return $this->_redis->del($key);\n    }\n\n    public function increment($id, $offset = 1)\n    {\n        return $this->_redis->incrBy($id, $offset);\n    }\n\n    public function decrement($id, $offset = 1)\n    {\n        return $this->_redis->decrBy($id, $offset);\n    }\n\n    public function clean()\n    {\n        return $this->_redis->flushDB();\n    }\n\n    public function cache_info($type = NULL)\n    {\n        return $this->_redis->info();\n    }\n\n    public function get_metadata($key)\n    {\n        $ttl = $this->_redis->ttl($key);\n\n        return ($ttl === -1 ? FALSE : array(\n            'expire' => time() + $ttl,\n            'mtime' => time()\n        ));\n    }\n\n    public function is_supported()\n    {\n        return extension_loaded('redis');\n    }\n\n    public function __destruct()\n    {\n        if ($this->_redis)\n        {\n            $this->_redis->close();\n        }\n    }\n}\n",
      "<?php\nclass CI_Cache_redis extends CI_Driver {\n\n    protected $_default_config = array(\n        'socket_type' => 'tcp',\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0\n    );\n\n    protected $_redis;\n    protected $_serialized = array();\n\n    public function __construct()\n    {\n        $CI =& get_instance();\n        $CI->load->config('cache');\n\n        $config = array_merge($this->_default_config, $CI->config->item('redis'));\n\n        $this->_redis = new Redis();\n\n        try {\n            if ($config['socket_type'] === 'unix') {\n                $success = $this->_redis->connect($config['socket']);\n            } else {\n                $success = $this->_redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if ( ! $success) {\n                log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n            }\n\n            if (isset($config['password']) && ! $this->_redis->auth($config['password'])) {\n                log_message('error', 'Cache: Redis authentication failed.');\n            }\n        } catch (RedisException $e) {\n            log_message('error', 'Cache: Redis connection refused (' . $e->getMessage() . ')');\n        }\n\n    }\n\n    public function get($key)\n    {\n        $data = $this->_redis->get($key);\n\n        if ($data !== FALSE && isset($this->_serialized[$key]))\n        {\n            return unserialize($data);\n        }\n\n        return $data;\n    }\n\n\n    public function save($id, $data, $ttl = 60, $raw = FALSE)\n    {\n        if ( ! $raw && ! is_scalar($data))\n        {\n            $data = serialize($data);\n            $this->_serialized[$id] = TRUE;\n        }\n\n        return $this->_redis->set($id, $data, $ttl);\n    }\n\n    public function delete($key)\n    {\n        unset($this->_serialized[$key]);\n        return $this->_redis->del($key);\n    }\n\n    public function increment($id, $offset = 1)\n    {\n        return $this->_redis->incrBy($id, $offset);\n    }\n\n    public function decrement($id, $offset = 1)\n    {\n        return $this->_redis->decrBy($id, $offset);\n    }\n\n    public function clean()\n    {\n        return $this->_redis->flushDB();\n    }\n\n    public function cache_info($type = NULL)\n    {\n        return $this->_redis->info();\n    }\n\n    public function get_metadata($key)\n    {\n        $ttl = $this->_redis->ttl($key);\n\n        return ($ttl === -1 ? FALSE : array(\n            'expire' => time() + $ttl,\n            'mtime' => time()\n        ));\n    }\n\n    public function is_supported()\n    {\n        return extension_loaded('redis');\n    }\n\n    public function __destruct()\n    {\n        if ($this->_redis)\n        {\n            $this->_redis->close();\n        }\n    }\n}\n",
      "<?php\ndefined('BASEPATH') OR exit('No direct script access allowed');\n\nclass CI_Cache_redis extends CI_Driver {\n\n    protected $_default_config = array(\n        'socket_type' => 'tcp',\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0\n    );\n\n    protected $_redis;\n    protected $_serialized = array();\n\n    public function __construct()\n    {\n        $CI =& get_instance();\n        $CI->load->config('cache');\n\n        $config = array_merge($this->_default_config, $CI->config->item('redis'));\n\n        $this->_redis = new Redis();\n        try {\n            if ($config['socket_type'] === 'unix') {\n                $success = $this->_redis->connect($config['socket']);\n            } else {\n                $success = $this->_redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if ( ! $success) {\n                log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n            }\n\n            if (isset($config['password']) && ! $this->_redis->auth($config['password'])) {\n                log_message('error', 'Cache: Redis authentication failed.');\n            }\n        } catch (RedisException $e) {\n            log_message('error', 'Cache: Redis connection refused (' . $e->getMessage() . ')');\n        }\n    }\n\n    public function get($key)\n    {\n        $data = $this->_redis->get($key);\n\n        if ($data !== FALSE && isset($this->_serialized[$key])) {\n            return unserialize($data);\n        }\n\n        return $data;\n    }\n\n    public function save($id, $data, $ttl = 60, $raw = FALSE)\n    {\n        if ( ! $raw && ! is_scalar($data)) {\n            $data = serialize($data);\n            $this->_serialized[$id] = TRUE;\n        }\n\n        return $this->_redis->set($id, $data, $ttl);\n    }\n\n    public function delete($key)\n    {\n        unset($this->_serialized[$key]);\n        return $this->_redis->del($key);\n    }\n\n    public function increment($id, $offset = 1)\n    {\n        return $this->_redis->incrBy($id, $offset);\n    }\n\n    public function decrement($id, $offset = 1)\n    {\n        return $this->_redis->decrBy($id, $offset);\n    }\n\n    public function clean()\n    {\n        return $this->_redis->flushDB();\n    }\n\n    public function cache_info($type = NULL)\n    {\n        return $this->_redis->info();\n    }\n\n    public function get_metadata($key)\n    {\n        $ttl = $this->_redis->ttl($key);\n\n        return ($ttl === -1 ? FALSE : array(\n            'expire' => time() + $ttl,\n            'mtime' => time()\n        ));\n    }\n\n    public function is_supported()\n    {\n        return extension_loaded('redis');\n    }\n\n    public function __destruct()\n    {\n        if ($this->_redis) {\n            $this->_redis->close();\n        }\n    }\n}\n\n",
      "<?php\ndefined('BASEPATH') OR exit('No direct script access allowed');\n\nclass CI_Cache_redis extends CI_Driver {\n\n    protected $_default_config = array(\n        'socket_type' => 'tcp',\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0\n    );\n\n    protected $_redis;\n    protected $_serialized = array();\n\n    public function __construct()\n    {\n        $CI =& get_instance();\n        $CI->load->config('cache');\n\n        $config = array_merge($this->_default_config, $CI->config->item('redis'));\n\n        $this->_redis = new Redis();\n        try {\n            if ($config['socket_type'] === 'unix') {\n                $success = $this->_redis->connect($config['socket']);\n            } else {\n                $success = $this->_redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if ( ! $success) {\n                log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n            }\n\n            if (isset($config['password']) && ! $this->_redis->auth($config['password'])) {\n                log_message('error', 'Cache: Redis authentication failed.');\n            }\n        } catch (RedisException $e) {\n            log_message('error', 'Cache: Redis connection refused (' . $e->getMessage() . ')');\n        }\n    }\n\n    public function get($key)\n    {\n        $data = $this->_redis->get($key);\n\n        if ($data !== FALSE && isset($this->_serialized[$key]))\n        {\n            return unserialize($data);\n        }\n\n        return $data;\n    }\n\n    public function save($id, $data, $ttl = 60, $raw = FALSE)\n    {\n        if ( ! $raw && ! is_scalar($data))\n        {\n            $data = serialize($data);\n            $this->_serialized[$id] = TRUE;\n        }\n\n        return $this->_redis->set($id, $data, $ttl);\n    }\n\n    public function delete($key)\n    {\n        unset($this->_serialized[$key]);\n        return $this->_redis->del($key);\n    }\n\n    public function increment($id, $offset = 1)\n    {\n        return $this->_redis->incrBy($id, $offset);\n    }\n\n    public function decrement($id, $offset = 1)\n    {\n        return $this->_redis->decrBy($id, $offset);\n    }\n\n    public function clean()\n    {\n        return $this->_redis->flushDB();\n    }\n\n    public function cache_info($type = NULL)\n    {\n        return $this->_redis->info();\n    }\n\n    public function get_metadata($key)\n    {\n        $ttl = $this->_redis->ttl($key);\n\n        return ($ttl === -1 ? FALSE : array(\n            'expire' => time() + $ttl,\n            'mtime' => time()\n        ));\n    }\n\n    public function is_supported()\n    {\n        return extension_loaded('redis');\n    }\n\n    public function __destruct()\n    {\n        if ($this->_redis)\n        {\n            $this->_redis->close();\n        }\n    }\n}\n",
      "<?php\nclass CI_Cache_redis extends CI_Driver {\n\n    protected $_default_config = array(\n        'socket_type' => 'tcp',\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0\n    );\n\n    protected $_redis;\n    protected $_serialized = array();\n\n    public function __construct()\n    {\n        $CI =& get_instance();\n        $CI->load->config('cache');\n\n        $config = array_merge($this->_default_config, $CI->config->item('redis'));\n\n        $this->_redis = new Redis();\n\n        try {\n            if ($config['socket_type'] === 'unix') {\n                $success = $this->_redis->connect($config['socket']);\n            } else {\n                $success = $this->_redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if ( ! $success) {\n                log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n            }\n\n            if (isset($config['password']) && ! $this->_redis->auth($config['password'])) {\n                log_message('error', 'Cache: Redis authentication failed.');\n            }\n        } catch (RedisException $e) {\n            log_message('error', 'Cache: Redis connection refused (' . $e->getMessage() . ')');\n        }\n\n    }\n\n    public function get($key)\n    {\n        $data = $this->_redis->get($key);\n\n        if ($data !== FALSE && isset($this->_serialized[$key]))\n        {\n            return unserialize($data);\n        }\n\n        return $data;\n    }\n\n\n    public function save($id, $data, $ttl = 60, $raw = FALSE)\n    {\n        if ( ! $raw && ! is_scalar($data))\n        {\n            $data = serialize($data);\n            $this->_serialized[$id] = TRUE;\n        }\n\n        return $this->_redis->set($id, $data, $ttl);\n    }\n\n    public function delete($key)\n    {\n        unset($this->_serialized[$key]);\n        return $this->_redis->del($key);\n    }\n\n    public function increment($id, $offset = 1)\n    {\n        return $this->_redis->incrBy($id, $offset);\n    }\n\n    public function decrement($id, $offset = 1)\n    {\n        return $this->_redis->decrBy($id, $offset);\n    }\n\n    public function clean()\n    {\n        return $this->_redis->flushDB();\n    }\n\n    public function cache_info($type = NULL)\n    {\n        return $this->_redis->info();\n    }\n\n    public function get_metadata($key)\n    {\n        $ttl = $this->_redis->ttl($key);\n\n        return ($ttl === -1 ? FALSE : array(\n            'expire' => time() + $ttl,\n            'mtime' => time()\n        ));\n    }\n\n    public function is_supported()\n    {\n        return extension_loaded('redis');\n    }\n\n    public function __destruct()\n    {\n        if ($this->_redis)\n        {\n            $this->_redis->close();\n        }\n    }\n}\n",
      "<?php\nclass CI_Cache_redis extends CI_Driver {\n\n    protected $_default_config = array(\n        'socket_type' => 'tcp',\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0\n    );\n\n    protected $_redis;\n    protected $_serialized = array();\n\n    public function __construct()\n    {\n        $CI =& get_instance();\n        $CI->load->config('cache');\n\n        $config = array_merge($this->_default_config, $CI->config->item('redis'));\n\n        $this->_redis = new Redis();\n\n        try {\n            if ($config['socket_type'] === 'unix') {\n                $success = $this->_redis->connect($config['socket']);\n            } else {\n                $success = $this->_redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if ( ! $success) {\n                log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n            }\n\n            if (isset($config['password']) && ! $this->_redis->auth($config['password'])) {\n                log_message('error', 'Cache: Redis authentication failed.');\n            }\n        } catch (RedisException $e) {\n            log_message('error', 'Cache: Redis connection refused (' . $e->getMessage() . ')');\n        }\n\n    }\n\n    public function get($key)\n    {\n        $data = $this->_redis->get($key);\n\n        if ($data !== FALSE && isset($this->_serialized[$key]))\n        {\n            return unserialize($data);\n        }\n\n        return $data;\n    }\n\n\n    public function save($id, $data, $ttl = 60, $raw = FALSE)\n    {\n        if ( ! $raw && ! is_scalar($data))\n        {\n            $data = serialize($data);\n            $this->_serialized[$id] = TRUE;\n        }\n\n        return $this->_redis->set($id, $data, $ttl);\n    }\n\n    public function delete($key)\n    {\n        unset($this->_serialized[$key]);\n        return $this->_redis->del($key);\n    }\n\n    public function increment($id, $offset = 1)\n    {\n        return $this->_redis->incrBy($id, $offset);\n    }\n\n    public function decrement($id, $offset = 1)\n    {\n        return $this->_redis->decrBy($id, $offset);\n    }\n\n    public function clean()\n    {\n        return $this->_redis->flushDB();\n    }\n\n    public function cache_info($type = NULL)\n    {\n        return $this->_redis->info();\n    }\n\n    public function get_metadata($key)\n    {\n        $ttl = $this->_redis->ttl($key);\n\n        return ($ttl === -1) ? FALSE : array(\n            'expire' => time() + $ttl,\n            'mtime' => time()\n        );\n    }\n\n    public function is_supported()\n    {\n        return extension_loaded('redis');\n    }\n\n    public function __destruct()\n    {\n        if ($this->_redis)\n        {\n            $this->_redis->close();\n        }\n    }\n}\n",
      "<?php\ndefined('BASEPATH') OR exit('No direct script access allowed');\n\nclass CI_Cache_redis extends CI_Driver {\n\n    protected $_default_config = array(\n        'socket_type' => 'tcp',\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0\n    );\n\n    protected $_redis;\n    protected $_serialized = array();\n\n    public function __construct()\n    {\n        $CI =& get_instance();\n        $CI->load->config('cache');\n\n        $config = array_merge($this->_default_config, $CI->config->item('redis'));\n\n        $this->_redis = new Redis();\n        try {\n            if ($config['socket_type'] === 'unix') {\n                $success = $this->_redis->connect($config['socket']);\n            } else {\n                $success = $this->_redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if ( ! $success) {\n                log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n            }\n\n            if (isset($config['password']) && ! $this->_redis->auth($config['password'])) {\n                log_message('error', 'Cache: Redis authentication failed.');\n            }\n        } catch (RedisException $e) {\n            log_message('error', 'Cache: Redis connection refused (' . $e->getMessage() . ')');\n        }\n\n    }\n\n    public function get($key)\n    {\n        $data = $this->_redis->get($key);\n\n        if ($data !== FALSE && isset($this->_serialized[$key]))\n        {\n            return unserialize($data);\n        }\n\n        return $data;\n    }\n\n    public function save($id, $data, $ttl = 60, $raw = FALSE)\n    {\n        if ( ! $raw && ! is_scalar($data))\n        {\n            $data = serialize($data);\n            $this->_serialized[$id] = TRUE;\n        }\n\n        return $this->_redis->set($id, $data, $ttl);\n    }\n\n    public function delete($key)\n    {\n        unset($this->_serialized[$key]);\n        return $this->_redis->del($key);\n    }\n\n    public function increment($id, $offset = 1)\n    {\n        return $this->_redis->incrBy($id, $offset);\n    }\n\n    public function decrement($id, $offset = 1)\n    {\n        return $this->_redis->decrBy($id, $offset);\n    }\n\n    public function clean()\n    {\n        return $this->_redis->flushDB();\n    }\n\n    public function cache_info($type = NULL)\n    {\n        return $this->_redis->info();\n    }\n\n    public function get_metadata($key)\n    {\n        $ttl = $this->_redis->ttl($key);\n\n        return ($ttl === -1 ? FALSE : array(\n            'expire' => time() + $ttl,\n            'mtime' => time()\n        ));\n    }\n\n    public function is_supported()\n    {\n        return extension_loaded('redis');\n    }\n\n    public function __destruct()\n    {\n        if ($this->_redis)\n        {\n            $this->_redis->close();\n        }\n    }\n}\n",
      "<?php\ndefined('BASEPATH') OR exit('No direct script access allowed');\n\nclass CI_Cache_redis extends CI_Driver {\n\n    protected $_default_config = array(\n        'socket_type' => 'tcp',\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0\n    );\n\n    protected $_redis;\n    protected $_serialized = array();\n\n    public function __construct()\n    {\n        $CI =& get_instance();\n        $CI->load->config('cache');\n\n        $config = array_merge($this->_default_config, $CI->config->item('redis'));\n\n        $this->_redis = new Redis();\n        try {\n            if ($config['socket_type'] === 'unix') {\n                $success = $this->_redis->connect($config['socket']);\n            } else {\n                $success = $this->_redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if ( ! $success) {\n                log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n            }\n\n            if (isset($config['password']) && ! $this->_redis->auth($config['password'])) {\n                log_message('error', 'Cache: Redis authentication failed.');\n            }\n        } catch (RedisException $e) {\n            log_message('error', 'Cache: Redis connection failed (' . $e->getMessage() . ').');\n        }\n    }\n\n    public function get($key)\n    {\n        $data = $this->_redis->get($key);\n\n        if ($data !== FALSE && isset($this->_serialized[$key])) {\n            return unserialize($data);\n        }\n\n        return $data;\n    }\n\n    public function save($id, $data, $ttl = 60, $raw = FALSE)\n    {\n        if ( ! $raw && ! is_scalar($data)) {\n            $data = serialize($data);\n            $this->_serialized[$id] = TRUE;\n        }\n\n        return $this->_redis->set($id, $data, $ttl);\n    }\n\n    public function delete($key)\n    {\n        unset($this->_serialized[$key]);\n        return $this->_redis->del($key);\n    }\n\n    public function increment($id, $offset = 1)\n    {\n        return $this->_redis->incrBy($id, $offset);\n    }\n\n    public function decrement($id, $offset = 1)\n    {\n        return $this->_redis->decrBy($id, $offset);\n    }\n\n    public function clean()\n    {\n        return $this->_redis->flushDB();\n    }\n\n    public function cache_info($type = NULL)\n    {\n        return $this->_redis->info();\n    }\n\n    public function get_metadata($key)\n    {\n        $ttl = $this->_redis->ttl($key);\n\n        return ($ttl === -1 ? FALSE : array(\n            'expire' => time() + $ttl,\n            'mtime' => time()\n        ));\n    }\n\n    public function is_supported()\n    {\n        return extension_loaded('redis');\n    }\n\n    public function __destruct()\n    {\n        if ($this->_redis) {\n            $this->_redis->close();\n        }\n    }\n}\n",
      "<?php\ndefined('BASEPATH') OR exit('No direct script access allowed');\n\nclass CI_Cache_redis extends CI_Driver {\n\n    protected $_default_config = array(\n        'socket_type' => 'tcp',\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0\n    );\n\n    protected $_redis;\n    protected $_serialized = array();\n\n    public function __construct()\n    {\n        $CI =& get_instance();\n        $CI->load->config('cache');\n\n        $config = array_merge($this->_default_config, $CI->config->item('redis'));\n\n        $this->_redis = new Redis();\n        try {\n            if ($config['socket_type'] === 'unix') {\n                $success = $this->_redis->connect($config['socket']);\n            } else {\n                $success = $this->_redis->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if ( ! $success) {\n                log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n            }\n\n            if (isset($config['password']) && ! $this->_redis->auth($config['password'])) {\n                log_message('error', 'Cache: Redis authentication failed.');\n            }\n        } catch (RedisException $e) {\n            log_message('error', 'Cache: Redis connection refused (' . $e->getMessage() . ')');\n        }\n    }\n\n    public function get($key)\n    {\n        $data = $this->_redis->get($key);\n\n        if ($data !== FALSE && isset($this->_serialized[$key]))\n        {\n            return unserialize($data);\n        }\n\n        return $data;\n    }\n\n    public function save($id, $data, $ttl = 60, $raw = FALSE)\n    {\n        if ( ! $raw && ! is_scalar($data))\n        {\n            $data = serialize($data);\n            $this->_serialized[$id] = TRUE;\n        }\n\n        return $this->_redis->set($id, $data, $ttl);\n    }\n\n    public function delete($key)\n    {\n        unset($this->_serialized[$key]);\n        return $this->_redis->del($key);\n    }\n\n    public function increment($id, $offset = 1)\n    {\n        return $this->_redis->incrBy($id, $offset);\n    }\n\n    public function decrement($id, $offset = 1)\n    {\n        return $this->_redis->decrBy($id, $offset);\n    }\n\n    public function clean()\n    {\n        return $this->_redis->flushDB();\n    }\n\n    public function cache_info($type = NULL)\n    {\n        return $this->_redis->info();\n    }\n\n    public function get_metadata($key)\n    {\n        $ttl = $this->_redis->ttl($key);\n\n        return ($ttl === -1 ? FALSE : array(\n            'expire' => time() + $ttl,\n            'mtime' => time()\n        ));\n    }\n\n    public function is_supported()\n    {\n        return extension_loaded('redis');\n    }\n\n    public function __destruct()\n    {\n        if ($this->_redis)\n        {\n            $this->_redis->close();\n        }\n    }\n}\n",
      "<?php\nclass CI_Cache_redis extends CI_Driver {\n\n    protected $_default_config = array(\n        'socket_type' => 'tcp',\n        'host' => '127.0.0.1',\n        'password' => NULL,\n        'port' => 6379,\n        'timeout' => 0\n    );\n\n    protected $_redis;\n    protected $_serialized = array();\n\n    public function __construct()\n    {\n        $CI =& get_instance();\n        $CI->load->config('cache');\n\n        $config = array_merge($this->_default_config, $CI->config->item('redis'));\n\n        if (isset($config['socket_type']))\n        {\n            switch ($config['socket_type'])\n            {\n                case 'tcp':\n                    $this->_redis = new Redis();\n                    if ( ! $this->_redis->connect($config['host'], $config['port'], $config['timeout']))\n                    {\n                        log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n                    }\n                    break;\n                case 'unix':\n                    $this->_redis = new Redis();\n                    if ( ! $this->_redis->connect($config['socket']))\n                    {\n                        log_message('error', 'Cache: Redis connection failed. Check your configuration.');\n                    }\n                    break;\n                default:\n                    log_message('error', 'Cache: Invalid socket type in config.');\n                    return;\n            }\n\n            if (isset($config['password']) && ! $this->_redis->auth($config['password']))\n            {\n                log_message('error', 'Cache: Redis authentication failed.');\n            }\n        }\n        else\n        {\n            log_message('error', 'Cache: Missing socket type in config.');\n        }\n    }\n\n    public function get($key)\n    {\n        $data = $this->_redis->get($key);\n        return (isset($this->_serialized[$key])) ? unserialize($data) : $data;\n    }\n\n    public function save($id, $data, $ttl = 60, $raw = FALSE)\n    {\n        if ( ! $raw && ! is_scalar($data))\n        {\n            $data = serialize($data);\n            $this->_serialized[$id] = TRUE;\n        }\n\n        return $this->_redis->set($id, $data, $ttl);\n    }\n\n    public function delete($key)\n    {\n        unset($this->_serialized[$key]);\n        return $this->_redis->del($key);\n    }\n\n    public function increment($id, $offset = 1)\n    {\n        return $this->_redis->incrBy($id, $offset);\n    }\n\n    public function decrement($id, $offset = 1)\n    {\n        return $this->_redis->decrBy($id, $offset);\n    }\n\n    public function clean()\n    {\n        return $this->_redis->flushDB();\n    }\n\n    public function cache_info($type = NULL)\n    {\n        return $this->_redis->info();\n    }\n\n    public function get_metadata($key)\n    {\n        $ttl = $this->_redis->ttl($key);\n        return ($ttl === -1) ? FALSE : array('expire' => time() + $ttl);\n    }\n\n    public function is_supported()\n    {\n        return extension_loaded('redis');\n    }\n\n    public function __destruct()\n    {\n        if ($this->_redis)\n        {\n            $this->_redis->close();\n        }\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 127,
    "Instruction": "Task Description: Create a Redis wrapper class in PHP that provides a simplified interface for connecting to and interacting with a Redis server, including connection management, basic operations, and error handling.\n\nClass Description: The cls_redis class is a singleton-style wrapper for PHP's Redis extension that manages Redis connections, provides common Redis operations, and handles connection errors gracefully. It supports multiple connection configurations, automatic reconnection on failure, and key prefixing.\n\nAttributes:\n\nAttribute1: protected static $redis - Redis - Singleton Redis instance (deprecated)\nAttribute2: protected static $configs - array - Stores Redis connection configurations\nAttribute3: private static $links - array - Maintains active Redis connections\nAttribute4: private static $link_name - string - Current connection name (default 'default')\nAttribute5: public static $prefix - string - Default key prefix ('phpspider')\nAttribute6: public static $error - string - Stores last error message\n\nMethods:\n\nMethod1: init() -> Redis|false - Initializes and returns a Redis connection instance\nMethod2: set(string $key, mixed $value, int $expire = 0) -> bool|null - Stores a value in Redis with optional expiration\nMethod3: get(string $key) -> mixed|null - Retrieves a value from Redis by key\nMethod4: clear_link() -> void - Closes all active Redis connections\nMethod5: _get_default_config() -> array - Retrieves default Redis configuration from global settings",
    "Canonical_solution": "class cls_redis\n{\n    protected static $redis = NULL;\n    protected static $configs = array();\n    private static $links = array();\n    private static $link_name = 'default';\n    public static $prefix = \"phpspider\";\n    public static $error = \"\";\n\n    public static function init()\n    {\n        if (!extension_loaded(\"redis\"))\n        {\n            self::$error = \"The redis extension was not found\";\n            return false;\n        }\n\n        $config = self::$link_name == 'default' ? self::_get_default_config() : self::$configs[self::$link_name];\n\n        if (empty(self::$links[self::$link_name]))\n        {\n            self::$links[self::$link_name] = new Redis();\n            if (!self::$links[self::$link_name]->connect($config['host'], $config['port'], $config['timeout']))\n            {\n                self::$error = \"Unable to connect to redis server\\nPlease check the configuration file config/inc_config.php\";\n                unset(self::$links[self::$link_name]);\n                return false;\n            }\n\n            if ($config['pass'])\n            {\n                if (!self::$links[self::$link_name]->auth($config['pass'])) \n                {\n                    self::$error = \"Redis Server authentication failed\\nPlease check the configuration file config/inc_config.php\";\n                    unset(self::$links[self::$link_name]);\n                    return false;\n                }\n            }\n\n            $prefix = empty($config['prefix']) ? self::$prefix : $config['prefix'];\n            self::$links[self::$link_name]->setOption(Redis::OPT_PREFIX, $prefix . \":\");\n            self::$links[self::$link_name]->setOption(Redis::OPT_READ_TIMEOUT, -1);\n            self::$links[self::$link_name]->select($config['db']);\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        self::init();\n        try\n        {\n            if (self::$links[self::$link_name])\n            {\n                if ($expire > 0)\n                {\n                    return self::$links[self::$link_name]->setex($key, $expire, $value);\n                }\n                else\n                {\n                    return self::$links[self::$link_name]->set($key, $value);\n                }\n            }\n        }\n        catch (Exception $e)\n        {\n            $msg = \"PHP Fatal error: Uncaught exception 'RedisException' with message '\".$e->getMessage().\"'\\n\";\n            log::warn($msg);\n            if ($e->getCode() == 0) \n            {\n                self::$links[self::$link_name]->close();\n                self::$links[self::$link_name] = null;\n                usleep(100000);\n                return self::set($key, $value, $expire);\n            }\n        }\n        return NULL;\n    }\n\n    public static function get($key)\n    {\n        self::init();\n        try\n        {\n            if (self::$links[self::$link_name])\n            {\n                return self::$links[self::$link_name]->get($key);\n            }\n        }\n        catch (Exception $e)\n        {\n            $msg = \"PHP Fatal error: Uncaught exception 'RedisException' with message '\".$e->getMessage().\"'\\n\";\n            log::warn($msg);\n            if ($e->getCode() == 0) \n            {\n                self::$links[self::$link_name]->close();\n                self::$links[self::$link_name] = null;\n                usleep(100000);\n                return self::get($key);\n            }\n        }\n        return NULL;\n    }\n\n    public static function clear_link()\n    {\n        if(self::$links) \n        {\n            foreach(self::$links as $k=>$v)\n            {\n                $v->close();\n                unset(self::$links[$k]);\n            }\n        }\n    }\n\n    protected static function _get_default_config()\n    {\n        if (empty(self::$configs['default']))\n        {\n            if (!is_array($GLOBALS['config']['redis']))\n            {\n                exit('cls_redis.php _get_default_config()' . '没有redis配置');\n            }\n            self::$configs['default'] = $GLOBALS['config']['redis'];\n        }\n        return self::$configs['default'];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 144,
    "matched_results": [
      "<?php\n\nclass cls_redis\n{\n    protected static $redis;\n    protected static $configs = [];\n    private static $links = [];\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!isset(self::$links[self::$link_name]))\n        {\n            $config = self::_get_default_config();\n            if (empty($config))\n            {\n                return false;\n            }\n\n            self::$configs[self::$link_name] = $config;\n\n            $redis = new Redis();\n            if (!$redis->connect($config['host'], $config['port'], $config['timeout']))\n            {\n                self::$error = \"Cannot connect to Redis server: {$config['host']}:{$config['port']}\";\n                return false;\n            }\n\n            if (isset($config['password']) && !empty($config['password']))\n            {\n                if (!$redis->auth($config['password']))\n                {\n                    self::$error = \"Redis authentication failed: {$config['host']}:{$config['port']}\";\n                    return false;\n                }\n            }\n\n            if (isset($config['database']) && !empty($config['database']))\n            {\n                $redis->select($config['database']);\n            }\n\n            self::$links[self::$link_name] = $redis;\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        if ($expire > 0)\n        {\n            return $redis->setex($key, $expire, $value);\n        }\n        else\n        {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        return $redis->get($key);\n    }\n\n    public static function clear_link()\n    {\n        foreach (self::$links as $name => $link)\n        {\n            $link->close();\n            unset(self::$links[$name]);\n        }\n    }\n\n    private static function _get_default_config()\n    {\n        $config = $GLOBALS['config']['redis'];\n        if (empty($config) || empty($config['host']) || empty($config['port']))\n        {\n            self::$error = \"Redis configuration is missing or incomplete.\";\n            return [];\n        }\n        return $config;\n    }\n}\n\n?>\n",
      "<?php\n\nclass cls_redis\n{\n    protected static $redis;\n    protected static $configs = [];\n    private static $links = [];\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!extension_loaded('redis'))\n        {\n            self::$error = \"Redis extension not loaded.\";\n            return false;\n        }\n\n        if (!isset(self::$configs[self::$link_name]))\n        {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        if (!isset(self::$links[self::$link_name]) || !(self::$links[self::$link_name] instanceof Redis) || !self::$links[self::$link_name]->ping())\n        {\n            try\n            {\n                $redis = new Redis();\n                if ($config['persistent'])\n                {\n                    $redis->pconnect($config['host'], $config['port'], $config['timeout'], self::$link_name);\n                }\n                else\n                {\n                    $redis->connect($config['host'], $config['port'], $config['timeout']);\n                }\n\n                if ($config['password'])\n                {\n                    $redis->auth($config['password']);\n                }\n                $redis->setOption(Redis::OPT_PREFIX, self::$prefix . \":\");\n                self::$links[self::$link_name] = $redis;\n            }\n            catch (Exception $e)\n            {\n                self::$error = $e->getMessage();\n                return false;\n            }\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        if ($expire > 0)\n        {\n            return $redis->setex($key, $expire, $value);\n        }\n        else\n        {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n        return $redis->get($key);\n    }\n\n    public static function clear_link()\n    {\n        foreach(self::$links as $name => $link)\n        {\n            if ($link instanceof Redis)\n            {\n                try {\n                    $link->close();\n                } catch (Exception $e) {\n                    // Ignore potential exceptions during closure\n                }\n            }\n            unset(self::$links[$name]);\n        }\n    }\n\n    private static function _get_default_config()\n    {\n        $config = [\n            'host' => '127.0.0.1',\n            'port' => 6379,\n            'password' => '',\n            'timeout' => 1,\n            'persistent' => false,\n        ];\n        $config = $GLOBALS['config']['redis'] ?? $config;\n        return $config;\n    }\n}\n\n",
      "<?php\n\nclass cls_redis\n{\n    protected static $redis;\n    protected static $configs = [];\n    private static $links = [];\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!isset(self::$configs[self::$link_name]))\n        {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        if (!isset(self::$links[self::$link_name]) || !(self::$links[self::$link_name] instanceof Redis))\n        {\n            try\n            {\n                $redis = new Redis();\n                if (!$redis->connect($config['host'], $config['port'], $config['timeout']))\n                {\n                    throw new RedisException(\"connect to redis failed\");\n                }\n\n                if (isset($config['password']) && $config['password'] != '')\n                {\n                    if (!$redis->auth($config['password']))\n                    {\n                        throw new RedisException(\"redis auth failed\");\n                    }\n                }\n\n                if (isset($config['database']) && $config['database'] != 0)\n                {\n                    if (!$redis->select($config['database']))\n                    {\n                        throw new RedisException(\"select redis database failed\");\n                    }\n                }\n                self::$links[self::$link_name] = $redis;\n            }\n            catch (RedisException $e)\n            {\n                self::$error = $e->getMessage();\n                return false;\n            }\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        if ($expire > 0)\n        {\n            return $redis->setex($key, $expire, $value);\n        }\n        else\n        {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        return $redis->get($key);\n    }\n\n    public static function clear_link()\n    {\n        foreach(self::$links as $name => $link)\n        {\n            if ($link instanceof Redis)\n            {\n                $link->close();\n            }\n            unset(self::$links[$name]);\n        }\n    }\n\n\n    private static function _get_default_config()\n    {\n        $config = $GLOBALS['config']['redis'];\n        if (empty($config['host']))\n        {\n            throw new RedisException(\"redis config host not found\");\n        }\n        if (empty($config['port']))\n        {\n            throw new RedisException(\"redis config port not found\");\n        }\n\n        return $config;\n    }\n}\n\n?>\n",
      "<?php\n\nclass cls_redis\n{\n    protected static $redis;\n    protected static $configs = [];\n    private static $links = [];\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!isset(self::$configs[self::$link_name]))\n        {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        if (!isset(self::$links[self::$link_name]) || !(self::$links[self::$link_name] instanceof Redis))\n        {\n            try\n            {\n                $redis = new Redis();\n                if (!$redis->connect($config['host'], $config['port'], $config['timeout']))\n                {\n                    throw new RedisException(\"connect to redis {$config['host']}:{$config['port']} fail\");\n                }\n\n                if (isset($config['password']) && $config['password'] != '' && !$redis->auth($config['password']))\n                {\n                    throw new RedisException(\"auth to redis fail\");\n                }\n\n                if (isset($config['db']) && $config['db'] != 0 && !$redis->select($config['db']))\n                {\n                    throw new RedisException(\"select db {$config['db']} fail\");\n                }\n\n                self::$links[self::$link_name] = $redis;\n            }\n            catch (RedisException $e)\n            {\n                self::$error = $e->getMessage();\n                return false;\n            }\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        if ($expire > 0)\n        {\n            return $redis->setex($key, $expire, $value);\n        }\n        else\n        {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        return $redis->get($key);\n    }\n\n    public static function clear_link()\n    {\n        foreach(self::$links as $name => $link)\n        {\n            if ($link instanceof Redis)\n            {\n                $link->close();\n            }\n            unset(self::$links[$name]);\n        }\n    }\n\n\n    private static function _get_default_config()\n    {\n        $config = $GLOBALS['config']['redis'];\n        if (empty($config['host']))\n        {\n            throw new RedisException(\"redis config host not found\");\n        }\n        if (empty($config['port']))\n        {\n            throw new RedisException(\"redis config port not found\");\n        }\n        return $config;\n    }\n}\n\n?>\n",
      "<?php\n\nclass cls_redis\n{\n    protected static $redis;\n    protected static $configs = [];\n    private static $links = [];\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!extension_loaded('redis'))\n        {\n            self::$error = \"Redis extension not loaded.\";\n            return false;\n        }\n\n        if (!isset(self::$configs[self::$link_name]))\n        {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        if (!isset(self::$links[self::$link_name]) || !(self::$links[self::$link_name] instanceof Redis) || !self::$links[self::$link_name]->ping())\n        {\n            try\n            {\n                $redis = new Redis();\n                if ($config['persistent'])\n                {\n                    $redis->pconnect($config['host'], $config['port'], $config['timeout'], self::$link_name);\n                }\n                else\n                {\n                    $redis->connect($config['host'], $config['port'], $config['timeout']);\n                }\n\n                if ($config['password'])\n                {\n                    $redis->auth($config['password']);\n                }\n                $redis->setOption(Redis::OPT_PREFIX, self::$prefix . \":\");\n                self::$links[self::$link_name] = $redis;\n            }\n            catch (Exception $e)\n            {\n                self::$error = $e->getMessage();\n                return false;\n            }\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        if ($expire > 0)\n        {\n            return $redis->setex($key, $expire, $value);\n        }\n        else\n        {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n        return $redis->get($key);\n    }\n\n\n    public static function clear_link()\n    {\n        foreach(self::$links as $name => $link)\n        {\n            try {\n                $link->close();\n            } catch (Exception $e) {\n                // Ignore connection closing errors\n            }\n            unset(self::$links[$name]);\n        }\n    }\n\n    private static function _get_default_config()\n    {\n        $config = [\n            'host' => '127.0.0.1',\n            'port' => 6379,\n            'password' => '',\n            'timeout' => 0.5,\n            'persistent' => true,\n        ];\n        return $config;\n    }\n}\n\n",
      "<?php\n\nclass cls_redis\n{\n    protected static $redis;\n    protected static $configs = [];\n    private static $links = [];\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!isset(self::$configs[self::$link_name]))\n        {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        if (!isset(self::$links[self::$link_name]) || !(self::$links[self::$link_name] instanceof Redis))\n        {\n            try\n            {\n                $redis = new Redis();\n                if (!$redis->connect($config['host'], $config['port'], $config['timeout']))\n                {\n                    throw new RedisException(\"Connect to redis failed.\");\n                }\n\n                if (isset($config['password']) && $config['password'] != '' && !$redis->auth($config['password']))\n                {\n                    throw new RedisException(\"Redis auth failed.\");\n                }\n\n                if (isset($config['db']) && $config['db'] != 0 && !$redis->select($config['db']))\n                {\n                    throw new RedisException(\"Select redis db failed.\");\n                }\n\n                self::$links[self::$link_name] = $redis;\n            }\n            catch (RedisException $e)\n            {\n                self::$error = $e->getMessage();\n                return false;\n            }\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        if ($expire > 0)\n        {\n            return $redis->setex($key, $expire, $value);\n        }\n        else\n        {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        return $redis->get($key);\n    }\n\n    public static function clear_link()\n    {\n        foreach (self::$links as $name => $link)\n        {\n            if ($link instanceof Redis)\n            {\n                $link->close();\n            }\n            unset(self::$links[$name]);\n        }\n    }\n\n    private static function _get_default_config()\n    {\n        $config = $GLOBALS['config']['redis'];\n        return [\n            'host' => $config['host'],\n            'port' => $config['port'],\n            'password' => isset($config['pass']) ? $config['pass'] : '',\n            'db' => isset($config['db']) ? $config['db'] : 0,\n            'timeout' => isset($config['timeout']) ? $config['timeout'] : 5,\n        ];\n    }\n}\n\n?>\n",
      "<?php\n\nclass cls_redis\n{\n    protected static $redis;\n    protected static $configs = [];\n    private static $links = [];\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!isset(self::$links[self::$link_name]))\n        {\n            $config = self::_get_default_config();\n            if (empty($config))\n            {\n                return false;\n            }\n\n            self::$configs[self::$link_name] = $config;\n\n            $redis = new Redis();\n            if (!$redis->connect($config['host'], $config['port'], $config['timeout']))\n            {\n                self::$error = \"Cannot connect to Redis server: {$config['host']}:{$config['port']}\";\n                return false;\n            }\n\n            if (!empty($config['password']) && !$redis->auth($config['password']))\n            {\n                self::$error = \"Redis authentication failed: {$config['host']}:{$config['port']}\";\n                return false;\n            }\n\n            if (isset($config['database']) && !$redis->select($config['database']))\n            {\n                self::$error = \"Redis select database failed: {$config['host']}:{$config['port']}\";\n                return false;\n            }\n\n            self::$links[self::$link_name] = $redis;\n        }\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        if ($expire > 0)\n        {\n            return $redis->setex($key, $expire, $value);\n        }\n        else\n        {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        return $redis->get($key);\n    }\n\n    public static function clear_link()\n    {\n        foreach (self::$links as $name => $link)\n        {\n            if ($link)\n            {\n                $link->close();\n            }\n            unset(self::$links[$name]);\n        }\n    }\n\n\n    private static function _get_default_config()\n    {\n        $config = $GLOBALS['config']['redis'];\n        if (empty($config['host']) || empty($config['port']))\n        {\n            self::$error = \"Redis config not found.\";\n            return [];\n        }\n        return $config;\n    }\n}\n\n",
      "<?php\n\nclass cls_redis\n{\n    protected static $redis;\n    protected static $configs = [];\n    private static $links = [];\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!isset(self::$links[self::$link_name]))\n        {\n            $config = self::_get_default_config();\n            if (empty($config))\n            {\n                return false;\n            }\n\n            self::$configs[self::$link_name] = $config;\n\n            $redis = new Redis();\n            if (!$redis->connect($config['host'], $config['port'], $config['timeout']))\n            {\n                self::$error = \"Cannot connect to Redis server: {$config['host']}:{$config['port']}\";\n                return false;\n            }\n\n            if (isset($config['password']) && !empty($config['password']))\n            {\n                if (!$redis->auth($config['password']))\n                {\n                    self::$error = \"Redis authentication failed: {$config['password']}\";\n                    return false;\n                }\n            }\n\n            if (isset($config['database']) && !empty($config['database']))\n            {\n                if (!$redis->select($config['database']))\n                {\n                    self::$error = \"Redis database selection failed: {$config['database']}\";\n                    return false;\n                }\n            }\n\n            self::$links[self::$link_name] = $redis;\n        }\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        if ($expire > 0)\n        {\n            return $redis->setex($key, $expire, $value);\n        }\n        else\n        {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        return $redis->get($key);\n    }\n\n    public static function clear_link()\n    {\n        foreach (self::$links as $name => $link)\n        {\n            if ($link)\n            {\n                $link->close();\n                unset(self::$links[$name]);\n            }\n        }\n    }\n\n    private static function _get_default_config()\n    {\n        $config = $GLOBALS['config']['redis'];\n        if (empty($config) || empty($config['host']) || empty($config['port']))\n        {\n            self::$error = \"Redis configuration is missing or incomplete.\";\n            return [];\n        }\n        return $config;\n    }\n}\n\n?>\n",
      "<?php\n\nclass cls_redis\n{\n    protected static $redis; // deprecated\n    protected static $configs = [];\n    private static $links = [];\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!isset(self::$configs[self::$link_name]))\n        {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        if (!isset(self::$links[self::$link_name]) || !(self::$links[self::$link_name] instanceof Redis))\n        {\n            try\n            {\n                $redis = new Redis();\n                if (!$redis->connect($config['host'], $config['port'], $config['timeout']))\n                {\n                    throw new RedisException(\"Connect to redis failed.\");\n                }\n\n                if (isset($config['password']) && $config['password'] != '')\n                {\n                    if (!$redis->auth($config['password']))\n                    {\n                        throw new RedisException(\"Redis auth failed.\");\n                    }\n                }\n\n                if (isset($config['database']) && $config['database'] != 0)\n                {\n                    if (!$redis->select($config['database']))\n                    {\n                        throw new RedisException(\"Select redis database failed.\");\n                    }\n                }\n\n                self::$links[self::$link_name] = $redis;\n            }\n            catch (RedisException $e)\n            {\n                self::$error = $e->getMessage();\n                return false;\n            }\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        if ($expire > 0)\n        {\n            return $redis->setex($key, $expire, $value);\n        }\n        else\n        {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        return $redis->get($key);\n    }\n\n    public static function clear_link()\n    {\n        foreach(self::$links as $name => $link)\n        {\n            if ($link instanceof Redis)\n            {\n                $link->close();\n            }\n            unset(self::$links[$name]);\n        }\n    }\n\n    private static function _get_default_config()\n    {\n        $config = $GLOBALS['config']['redis'];\n        return [\n            'host' => $config['host'],\n            'port' => $config['port'],\n            'password' => isset($config['pass']) ? $config['pass'] : '',\n            'timeout' => isset($config['timeout']) ? $config['timeout'] : 5,\n            'database' => isset($config['database']) ? $config['database'] : 0,\n        ];\n    }\n}\n\n?>\n",
      "<?php\n\nclass cls_redis\n{\n    protected static $redis; // deprecated\n    protected static $configs = [];\n    private static $links = [];\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!isset(self::$configs[self::$link_name]))\n        {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        $config = self::$configs[self::$link_name];\n\n        if (!isset(self::$links[self::$link_name]) || !(self::$links[self::$link_name] instanceof Redis))\n        {\n            try\n            {\n                $redis = new Redis();\n                if (!$redis->connect($config['host'], $config['port'], $config['timeout']))\n                {\n                    throw new RedisException(\"Connect to redis failed.\");\n                }\n\n                if (isset($config['password']) && $config['password'] != '')\n                {\n                    if (!$redis->auth($config['password']))\n                    {\n                        throw new RedisException(\"Redis auth failed.\");\n                    }\n                }\n\n                if (isset($config['database']) && $config['database'] != 0)\n                {\n                    if (!$redis->select($config['database']))\n                    {\n                        throw new RedisException(\"Select redis database failed.\");\n                    }\n                }\n                self::$links[self::$link_name] = $redis;\n            }\n            catch (RedisException $e)\n            {\n                self::$error = $e->getMessage();\n                return false;\n            }\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n\n        $key = self::$prefix . $key;\n        if ($expire > 0)\n        {\n            return $redis->setex($key, $expire, $value);\n        }\n        else\n        {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get($key)\n    {\n        $redis = self::init();\n        if (!$redis)\n        {\n            return null;\n        }\n        $key = self::$prefix . $key;\n        return $redis->get($key);\n    }\n\n    public static function clear_link()\n    {\n        foreach(self::$links as $name => $link)\n        {\n            if ($link instanceof Redis)\n            {\n                try {\n                    $link->close();\n                } catch (RedisException $e) {\n                    // Ignore potential exceptions during closure\n                }\n            }\n            unset(self::$links[$name]);\n        }\n    }\n\n    private static function _get_default_config()\n    {\n        $config = $GLOBALS['config']['redis'];\n        if (empty($config['host']))\n        {\n            throw new RedisException(\"Redis host not defined.\");\n        }\n        return $config;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 128,
    "Instruction": "Task Description: Create a PHP class that implements a Redis client connection using TCP sockets and the phpiredis extension for efficient communication with a Redis server.\n\nClass Description: PhpiredisSocketConnection is a Redis client connection class that handles TCP socket communication with a Redis server. It manages socket creation, connection, data transmission, and response parsing using the phpiredis extension for optimal performance.\n\nAttributes:\n- reader: [resource] - The phpiredis reader resource used for parsing Redis protocol responses\n- parameters: [ParametersInterface] - Connection parameters including host, port, timeout, etc.\n\nMethods:\n- __construct(ParametersInterface $parameters) -> [void] - Initializes the connection and verifies required extensions\n- __destruct() -> [void] - Cleans up resources when the object is destroyed\n- assertExtensions() -> [void] - Verifies required PHP extensions are loaded\n- createReader() -> [resource] - Creates and configures a phpiredis reader resource\n- getStatusHandler() -> [callable] - Returns the handler for status responses\n- getErrorHandler() -> [callable] - Returns the handler for error responses\n- createResource() -> [resource] - Creates and connects the socket resource\n- connectWithTimeout(resource $socket, string $address, ParametersInterface $parameters) -> [void] - Establishes connection with timeout handling\n- write(string $buffer) -> [void] - Writes data to the socket connection\n- read() -> [mixed] - Reads and parses response from the server\n- writeRequest(CommandInterface $command) -> [void] - Formats and writes a Redis command to the server",
    "Canonical_solution": "use Predis\\Command\\CommandInterface;\nuse Predis\\NotSupportedException;\nuse Predis\\Response\\Error as ErrorResponse;\nuse Predis\\Response\\ErrorInterface as ErrorResponseInterface;\nuse Predis\\Response\\Status as StatusResponse;\n\nclass PhpiredisSocketConnection extends AbstractConnection\n{\n    private $reader;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        parent::__construct($parameters);\n        $this->reader = $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        parent::__destruct();\n        phpiredis_reader_destroy($this->reader);\n    }\n\n    protected function assertExtensions()\n    {\n        if (!extension_loaded('sockets')) {\n            throw new NotSupportedException(\n                'The \"sockets\" extension is required by this connection backend.'\n            );\n        }\n\n        if (!extension_loaded('phpiredis')) {\n            throw new NotSupportedException(\n                'The \"phpiredis\" extension is required by this connection backend.'\n            );\n        }\n    }\n\n    private function createReader()\n    {\n        $reader = phpiredis_reader_create();\n        phpiredis_reader_set_status_handler($reader, $this->getStatusHandler());\n        phpiredis_reader_set_error_handler($reader, $this->getErrorHandler());\n        return $reader;\n    }\n\n    protected function getStatusHandler()\n    {\n        static $statusHandler;\n\n        if (!$statusHandler) {\n            $statusHandler = function ($payload) {\n                return StatusResponse::get($payload);\n            };\n        }\n\n        return $statusHandler;\n    }\n\n    protected function getErrorHandler()\n    {\n        static $errorHandler;\n\n        if (!$errorHandler) {\n            $errorHandler = function ($errorMessage) {\n                return new ErrorResponse($errorMessage);\n            };\n        }\n\n        return $errorHandler;\n    }\n\n    protected function createResource()\n    {\n        $parameters = $this->parameters;\n\n        if ($parameters->scheme === 'unix') {\n            $address = $parameters->path;\n            $domain = AF_UNIX;\n            $protocol = 0;\n        } else {\n            if (false === $address = self::getAddress($parameters)) {\n                $this->onConnectionError(\"Cannot resolve the address of '$parameters->host'.\");\n            }\n\n            $domain = filter_var($address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) ? AF_INET6 : AF_INET;\n            $protocol = SOL_TCP;\n        }\n\n        if (false === $socket = @socket_create($domain, SOCK_STREAM, $protocol)) {\n            $this->emitSocketError();\n        }\n\n        $this->setSocketOptions($socket, $parameters);\n        $this->connectWithTimeout($socket, $address, $parameters);\n\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        socket_set_nonblock($socket);\n\n        if (@socket_connect($socket, $address, (int) $parameters->port) === false) {\n            $error = socket_last_error();\n            if ($error != SOCKET_EINPROGRESS && $error != SOCKET_EALREADY) {\n                $this->emitSocketError();\n            }\n        }\n\n        socket_set_block($socket);\n\n        $null = null;\n        $selectable = array($socket);\n\n        $timeout = (isset($parameters->timeout) ? (float) $parameters->timeout : 5.0);\n        $timeoutSecs = floor($timeout);\n        $timeoutUSecs = ($timeout - $timeoutSecs) * 1000000;\n\n        $selected = socket_select($selectable, $selectable, $null, $timeoutSecs, $timeoutUSecs);\n\n        if ($selected === 2) {\n            $this->onConnectionError('Connection refused.', SOCKET_ECONNREFUSED);\n        }\n\n        if ($selected === 0) {\n            $this->onConnectionError('Connection timed out.', SOCKET_ETIMEDOUT);\n        }\n\n        if ($selected === false) {\n            $this->emitSocketError();\n        }\n    }\n\n    protected function write($buffer)\n    {\n        $socket = $this->getResource();\n\n        while (($length = strlen($buffer)) > 0) {\n            $written = socket_write($socket, $buffer, $length);\n\n            if ($length === $written) {\n                return;\n            }\n\n            if ($written === false) {\n                $this->onConnectionError('Error while writing bytes to the server.');\n            }\n\n            $buffer = substr($buffer, $written);\n        }\n    }\n\n    public function read()\n    {\n        $socket = $this->getResource();\n        $reader = $this->reader;\n\n        while (PHPIREDIS_READER_STATE_INCOMPLETE === $state = phpiredis_reader_get_state($reader)) {\n            if (@socket_recv($socket, $buffer, 4096, 0) === false || $buffer === '' || $buffer === null) {\n                $this->emitSocketError();\n            }\n\n            phpiredis_reader_feed($reader, $buffer);\n        }\n\n        if ($state === PHPIREDIS_READER_STATE_COMPLETE) {\n            return phpiredis_reader_get_reply($reader);\n        } else {\n            $this->onProtocolError(phpiredis_reader_get_error($reader));\n            return;\n        }\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getId());\n        $this->write(phpiredis_format_command($arguments));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 137,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nclass PhpiredisSocketConnection\n{\n    private $reader;\n    private $parameters;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        $this->parameters = $parameters;\n        $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        $this->reader = null;\n    }\n\n    private function assertExtensions()\n    {\n        if (!extension_loaded('redis')) {\n            throw new \\Exception('phpiredis extension is required.');\n        }\n    }\n\n    private function createReader()\n    {\n        $this->reader = new \\Redis();\n        $this->reader->set_status_handler($this->getStatusHandler());\n        $this->reader->set_error_handler($this->getErrorHandler());\n    }\n\n    private function getStatusHandler()\n    {\n        return function ($i, $s) {\n            return $s;\n        };\n    }\n\n    private function getErrorHandler()\n    {\n        return function ($i, $s) {\n            throw new \\Exception($s);\n        };\n    }\n\n\n    public function createResource()\n    {\n        $socket = stream_socket_client(\n            $this->parameters->getHost() . ':' . $this->parameters->getPort(),\n            $errno,\n            $errstr,\n            $this->parameters->getTimeout(),\n            STREAM_CLIENT_CONNECT\n        );\n\n        if (!$socket) {\n            throw new \\Exception($errstr, $errno);\n        }\n\n        $this->connectWithTimeout($socket, $this->parameters->getHost() . ':' . $this->parameters->getPort(), $this->parameters);\n\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        stream_set_timeout($socket, $parameters->getTimeout());\n    }\n\n    public function write(string $buffer)\n    {\n        $socket = $this->createResource();\n        fwrite($socket, $buffer);\n    }\n\n    public function read()\n    {\n        $socket = $this->createResource();\n        $response = $this->reader->_read_from_stream($socket);\n        return $response;\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getName());\n        $payload = '*' . count($arguments) . \"\\r\\n\";\n        foreach ($arguments as $argument) {\n            $payload .= '$' . strlen($argument) . \"\\r\\n\" . $argument . \"\\r\\n\";\n        }\n        $this->write($payload);\n    }\n}\n\ninterface ParametersInterface\n{\n    public function getHost(): string;\n    public function getPort(): int;\n    public function getTimeout(): float;\n}\n\ninterface CommandInterface\n{\n    public function getName(): string;\n    public function getArguments(): array;\n}\n",
      "<?php\n\nclass PhpiredisSocketConnection\n{\n    private $reader;\n    private $parameters;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        $this->parameters = $parameters;\n        $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        $this->reader = null;\n    }\n\n    private function assertExtensions()\n    {\n        if (!extension_loaded('redis')) {\n            throw new \\Exception('The redis extension is required.');\n        }\n        if (!class_exists('Redis')) {\n            throw new \\Exception('phpiredis is required.');\n        }\n    }\n\n\n    private function createReader()\n    {\n        $this->reader = new \\Redis();\n        $this->reader->set_status_handler($this->getStatusHandler());\n        $this->reader->set_error_handler($this->getErrorHandler());\n    }\n\n    private function getStatusHandler()\n    {\n        return function ($i, $s) {\n            return $s;\n        };\n    }\n\n    private function getErrorHandler()\n    {\n        return function ($i, $s) {\n            throw new \\Exception($s);\n        };\n    }\n\n\n    public function createResource()\n    {\n        $socket = stream_socket_client(\n            $this->parameters->getHost() . ':' . $this->parameters->getPort(),\n            $errno,\n            $errstr,\n            $this->parameters->getTimeout()\n        );\n\n        if (!$socket) {\n            throw new \\Exception($errstr, $errno);\n        }\n\n        $this->connectWithTimeout($socket, $this->parameters->getHost(), $this->parameters);\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        stream_set_timeout($socket, $timeout = (int)$parameters->getTimeout());\n        $info = stream_get_meta_data($socket);\n\n        if (!$info['timed_out'] && !empty($address)) {\n            $this->reader->connect($address, $parameters->getPort(), $parameters->getTimeout());\n        } else {\n            throw new \\Exception('Connection timed out.');\n        }\n    }\n\n\n    public function write(string $buffer)\n    {\n        $this->reader->_sock = $this->createResource();\n        $this->reader->write($buffer);\n    }\n\n    public function read()\n    {\n        return $this->reader->read();\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $buffer = $command->getPreparedId() . \"\\r\\n\";\n        $this->write($buffer);\n    }\n}\n\ninterface ParametersInterface\n{\n    public function getHost(): string;\n    public function getPort(): int;\n    public function getTimeout(): float;\n}\n\ninterface CommandInterface\n{\n    public function getPreparedId(): string;\n}\n",
      "<?php\n\nclass PhpiredisSocketConnection\n{\n    private $reader;\n    private $parameters;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        $this->parameters = $parameters;\n        $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        $this->reader = null;\n    }\n\n    private function assertExtensions()\n    {\n        if (!extension_loaded('redis')) {\n            throw new \\Exception('phpiredis extension is required.');\n        }\n    }\n\n    private function createReader()\n    {\n        $this->reader = new \\Redis();\n        $this->reader->set_status_handler($this->getStatusHandler());\n        $this->reader->set_error_handler($this->getErrorHandler());\n    }\n\n    private function getStatusHandler()\n    {\n        return function ($i, $s) {\n            return $s;\n        };\n    }\n\n    private function getErrorHandler()\n    {\n        return function ($i, $s) {\n            throw new \\Exception($s);\n        };\n    }\n\n\n    public function createResource()\n    {\n        $socket = stream_socket_client(\n            $this->parameters->getHost() . ':' . $this->parameters->getPort(),\n            $errno,\n            $errstr,\n            $this->parameters->getTimeout()\n        );\n\n        if (!$socket) {\n            throw new \\Exception($errstr, $errno);\n        }\n\n        $this->connectWithTimeout($socket, $this->parameters->getHost(), $this->parameters);\n\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        stream_set_timeout($socket, $parameters->getTimeout());\n    }\n\n    public function write(string $buffer)\n    {\n        $socket = $this->createResource();\n        fwrite($socket, $buffer);\n    }\n\n    public function read()\n    {\n        $socket = $this->createResource();\n        $response = $this->reader->_read_from_stream($socket);\n        return $response;\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getName());\n        $payload = '*' . count($arguments) . \"\\r\\n\";\n        foreach ($arguments as $argument) {\n            $payload .= '$' . strlen($argument) . \"\\r\\n\" . $argument . \"\\r\\n\";\n        }\n        $this->write($payload);\n    }\n}\n\ninterface ParametersInterface {\n    public function getHost(): string;\n    public function getPort(): int;\n    public function getTimeout(): float;\n}\n\ninterface CommandInterface {\n    public function getName(): string;\n    public function getArguments(): array;\n}\n",
      "<?php\n\nclass PhpiredisSocketConnection\n{\n    private $reader;\n    private $parameters;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        $this->parameters = $parameters;\n        $this->createReader();\n        $this->createResource();\n    }\n\n    public function __destruct()\n    {\n        fclose($this->reader->stream);\n    }\n\n    private function assertExtensions()\n    {\n        if (!extension_loaded('phpiredis')) {\n            throw new \\Exception('phpiredis extension is required.');\n        }\n    }\n\n    private function createReader()\n    {\n        $this->reader = new \\phpiredis_reader;\n        $this->reader->setHandlers(\n            'status',\n            $this->getStatusHandler()\n        );\n        $this->reader->setHandlers(\n            'error',\n            $this->getErrorHandler()\n        );\n    }\n\n    private function getStatusHandler()\n    {\n        return function ($payload) {\n            return $payload;\n        };\n    }\n\n    private function getErrorHandler()\n    {\n        return function ($payload) {\n            throw new \\Exception($payload);\n        };\n    }\n\n\n    private function createResource()\n    {\n        $address = $this->parameters->getHost() . ':' . $this->parameters->getPort();\n        $socket = stream_socket_client(\n            \"tcp://\" . $address,\n            $errno,\n            $errstr,\n            $this->parameters->getTimeout()\n        );\n\n        if (!$socket) {\n            throw new \\Exception(\"Could not connect to Redis at {$address}: {$errstr} ({$errno})\");\n        }\n\n        $this->reader->stream = $socket;\n    }\n\n\n    public function write(string $buffer)\n    {\n        $bytesWritten = fwrite($this->reader->stream, $buffer);\n        if ($bytesWritten === false || $bytesWritten !== strlen($buffer)) {\n            throw new \\Exception('Failed to write entire buffer to stream.');\n        }\n    }\n\n    public function read()\n    {\n        while ($data = fread($this->reader->stream, 4096)) {\n            $this->reader->feed($data);\n            while ($reply = $this->reader->getReply()) {\n                return $reply;\n            }\n        }\n        throw new \\Exception('Connection closed unexpectedly.');\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getName());\n        $payload = '*' . count($arguments) . \"\\r\\n\";\n        foreach ($arguments as $argument) {\n            $payload .= '$' . strlen($argument) . \"\\r\\n\" . $argument . \"\\r\\n\";\n        }\n        $this->write($payload);\n    }\n}\n\ninterface ParametersInterface\n{\n    public function getHost(): string;\n    public function getPort(): int;\n    public function getTimeout(): float;\n}\n\ninterface CommandInterface\n{\n    public function getName(): string;\n    public function getArguments(): array;\n}\n",
      "<?php\n\nclass PhpiredisSocketConnection\n{\n    private $reader;\n    private $parameters;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        $this->parameters = $parameters;\n        $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        $this->reader = null;\n    }\n\n    private function assertExtensions()\n    {\n        if (!extension_loaded('redis')) {\n            throw new \\Exception('phpiredis extension is required.');\n        }\n    }\n\n    private function createReader()\n    {\n        $this->reader = new \\Redis();\n        $this->reader->set_status_handler($this->getStatusHandler());\n        $this->reader->set_error_handler($this->getErrorHandler());\n    }\n\n    private function getStatusHandler()\n    {\n        return function ($i, $s) {\n            return $s;\n        };\n    }\n\n    private function getErrorHandler()\n    {\n        return function ($i, $s) {\n            throw new \\Exception($s);\n        };\n    }\n\n\n    public function createResource()\n    {\n        $socket = stream_socket_client(\n            $this->parameters->getHost() . ':' . $this->parameters->getPort(),\n            $errno,\n            $errstr,\n            $this->parameters->getTimeout()\n        );\n\n        if (!$socket) {\n            throw new \\Exception($errstr, $errno);\n        }\n\n        $this->connectWithTimeout($socket, $this->parameters->getHost(), $this->parameters);\n\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        stream_set_timeout($socket, $parameters->getTimeout());\n        $this->reader->connect($address, $parameters->getPort(), $parameters->getTimeout());\n    }\n\n    public function write(string $buffer)\n    {\n        $this->reader->_sock = $this->createResource();\n        $this->reader->write($buffer);\n    }\n\n    public function read()\n    {\n        return $this->reader->read();\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getName());\n        $this->write($this->reader->_serialize($arguments));\n    }\n}\n\ninterface ParametersInterface {\n    public function getHost(): string;\n    public function getPort(): int;\n    public function getTimeout(): float;\n}\n\ninterface CommandInterface {\n    public function getName(): string;\n    public function getArguments(): array;\n}\n",
      "<?php\n\nclass PhpiredisSocketConnection\n{\n    private $reader;\n    private $parameters;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        $this->parameters = $parameters;\n        $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        $this->reader = null;\n    }\n\n    private function assertExtensions()\n    {\n        if (!extension_loaded('redis')) {\n            throw new \\Exception('phpiredis extension is required.');\n        }\n    }\n\n    private function createReader()\n    {\n        $this->reader = new \\Redis();\n        $this->reader->set_status_handler($this->getStatusHandler());\n        $this->reader->set_error_handler($this->getErrorHandler());\n    }\n\n    private function getStatusHandler()\n    {\n        return function ($i, $s) {\n            return $s;\n        };\n    }\n\n    private function getErrorHandler()\n    {\n        return function ($i, $s) {\n            throw new \\Exception($s);\n        };\n    }\n\n\n    public function createResource()\n    {\n        $socket = stream_socket_client(\n            $this->parameters->getHost() . ':' . $this->parameters->getPort(),\n            $errno,\n            $errstr,\n            $this->parameters->getTimeout(),\n            STREAM_CLIENT_CONNECT\n        );\n\n        if (!$socket) {\n            throw new \\Exception($errstr, $errno);\n        }\n\n        $this->connectWithTimeout($socket, $this->parameters->getHost() . ':' . $this->parameters->getPort(), $this->parameters);\n\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        stream_set_timeout($socket, $parameters->getTimeout());\n    }\n\n    public function write(string $buffer)\n    {\n        $socket = $this->createResource();\n        fwrite($socket, $buffer);\n    }\n\n    public function read()\n    {\n        $socket = $this->createResource();\n        $response = $this->reader->_read_from_stream($socket);\n        return $response;\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getName());\n        $payload = '*' . count($arguments) . \"\\r\\n\";\n        foreach ($arguments as $argument) {\n            $payload .= '$' . strlen($argument) . \"\\r\\n\" . $argument . \"\\r\\n\";\n        }\n        $this->write($payload);\n    }\n}\n\ninterface ParametersInterface\n{\n    public function getHost(): string;\n    public function getPort(): int;\n    public function getTimeout(): float;\n}\n\ninterface CommandInterface\n{\n    public function getName(): string;\n    public function getArguments(): array;\n}\n",
      "<?php\n\nclass PhpiredisSocketConnection\n{\n    private $reader;\n    private $parameters;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        $this->parameters = $parameters;\n        $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        $this->reader = null;\n    }\n\n    private function assertExtensions()\n    {\n        if (!extension_loaded('redis')) {\n            throw new \\Exception('phpiredis extension is required.');\n        }\n    }\n\n    private function createReader()\n    {\n        $this->reader = new \\Redis();\n        $this->reader->set_status_handler($this->getStatusHandler());\n        $this->reader->set_error_handler($this->getErrorHandler());\n    }\n\n    private function getStatusHandler()\n    {\n        return function ($i, $s) {\n            return $s;\n        };\n    }\n\n    private function getErrorHandler()\n    {\n        return function ($i, $s) {\n            throw new \\Exception($s);\n        };\n    }\n\n\n    private function createResource()\n    {\n        $address = $this->parameters->getHost() . ':' . $this->parameters->getPort();\n        $socket = stream_socket_client(\"tcp://\" . $address, $errno, $errstr, $this->parameters->getTimeout());\n\n        if (!$socket) {\n            throw new \\Exception(\"Connection failed: $errstr ($errno)\");\n        }\n\n        $this->connectWithTimeout($socket, $address, $this->parameters);\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        stream_set_timeout($socket, $parameters->getTimeout());\n    }\n\n    public function write(string $buffer)\n    {\n        $socket = $this->createResource();\n        fwrite($socket, $buffer);\n    }\n\n    public function read()\n    {\n        $socket = $this->createResource();\n        $response = $this->reader->_read_from_stream($socket);\n        return $response;\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getName());\n        $payload = '*' . count($arguments) . \"\\r\\n\";\n        foreach ($arguments as $argument) {\n            $payload .= '$' . strlen($argument) . \"\\r\\n\" . $argument . \"\\r\\n\";\n        }\n        $this->write($payload);\n    }\n}\n\ninterface ParametersInterface {\n    public function getHost(): string;\n    public function getPort(): int;\n    public function getTimeout(): float;\n}\n\ninterface CommandInterface {\n    public function getName(): string;\n    public function getArguments(): array;\n}\n",
      "<?php\n\nclass PhpiredisSocketConnection\n{\n    private $reader;\n    private $parameters;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        $this->parameters = $parameters;\n        $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        $this->reader = null;\n    }\n\n    private function assertExtensions()\n    {\n        if (!extension_loaded('phpiredis')) {\n            throw new \\Exception('phpiredis extension is required.');\n        }\n    }\n\n    private function createReader()\n    {\n        $this->reader = phpiredis_reader_create();\n        phpiredis_reader_set_status_handler($this->reader, $this->getStatusHandler());\n        phpiredis_reader_set_error_handler($this->reader, $this->getErrorHandler());\n    }\n\n    private function getStatusHandler()\n    {\n        return function ($reader, $status) {\n            return $status;\n        };\n    }\n\n    private function getErrorHandler()\n    {\n        return function ($reader, $error) {\n            throw new \\Exception($error);\n        };\n    }\n\n    private function createResource()\n    {\n        $address = $this->parameters->getHost() . ':' . $this->parameters->getPort();\n        $socket = stream_socket_client(\"tcp://\" . $address, $errno, $errstr, $this->parameters->getTimeout());\n\n        if (!$socket) {\n            throw new \\Exception(\"Connection failed: $errstr ($errno)\");\n        }\n\n        $this->connectWithTimeout($socket, $address, $this->parameters);\n\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, $parameters)\n    {\n        stream_set_timeout($socket, $parameters->getTimeout());\n        $timeout = $parameters->getTimeout();\n        $endTime = microtime(true) + $timeout;\n        while (!@stream_socket_get_name($socket, true) && microtime(true) < $endTime) {\n            usleep(10000); // Wait 10ms\n        }\n\n        if (!@stream_socket_get_name($socket, true)) {\n            throw new \\Exception(\"Connection to $address timed out after $timeout seconds.\");\n        }\n    }\n\n\n    private function write(string $buffer)\n    {\n        $socket = $this->createResource();\n        fwrite($socket, $buffer);\n        fclose($socket);\n    }\n\n    public function read()\n    {\n        $socket = $this->createResource();\n        $reply = phpiredis_reader_get_reply($this->reader, $socket);\n        fclose($socket);\n        return $reply;\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $buffer = $command->getPreparedString();\n        $this->write($buffer);\n    }\n}\n\ninterface ParametersInterface {\n    public function getHost(): string;\n    public function getPort(): int;\n    public function getTimeout(): float;\n}\n\ninterface CommandInterface {\n    public function getPreparedString(): string;\n}\n",
      "<?php\n\nclass PhpiredisSocketConnection\n{\n    private $reader;\n    private $parameters;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        $this->parameters = $parameters;\n        $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        $this->reader = null;\n    }\n\n    private function assertExtensions()\n    {\n        if (!extension_loaded('redis')) {\n            throw new \\Exception('phpiredis extension is required.');\n        }\n    }\n\n    private function createReader()\n    {\n        $this->reader = new \\Redis();\n        $this->reader->setOption(\\Redis::OPT_SERIALIZER, \\Redis::SERIALIZER_NONE);\n    }\n\n\n    private function getStatusHandler()\n    {\n        return function ($response) {\n            return $response;\n        };\n    }\n\n    private function getErrorHandler()\n    {\n        return function ($response) {\n            throw new \\Exception($response);\n        };\n    }\n\n    public function createResource()\n    {\n        $socket = stream_socket_client(\n            $this->parameters->getHost() . ':' . $this->parameters->getPort(),\n            $errno,\n            $errstr,\n            $this->parameters->getTimeout(),\n            STREAM_CLIENT_CONNECT\n        );\n\n        if (!$socket) {\n            throw new \\Exception($errstr, $errno);\n        }\n\n        $this->connectWithTimeout($socket, $this->parameters->getHost(), $this->parameters);\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        stream_set_timeout($socket, $parameters->getTimeout());\n    }\n\n    public function write(string $buffer)\n    {\n        $bytesWritten = fwrite($this->reader->_sock, $buffer);\n        if ($bytesWritten === false || $bytesWritten !== strlen($buffer)) {\n            throw new \\Exception('Failed to write entire buffer.');\n        }\n    }\n\n    public function read()\n    {\n        $response = $this->reader->_read_from_socket();\n        if ($response === null) {\n            throw new \\Exception('Failed to read from socket.');\n        }\n        return $response;\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getName());\n        $payload = '*' . count($arguments) . \"\\r\\n\";\n        foreach ($arguments as $argument) {\n            $payload .= '$' . strlen($argument) . \"\\r\\n\" . $argument . \"\\r\\n\";\n        }\n        $this->write($payload);\n    }\n}\n\ninterface ParametersInterface {\n    public function getHost(): string;\n    public function getPort(): int;\n    public function getTimeout(): float;\n}\n\ninterface CommandInterface {\n    public function getName(): string;\n    public function getArguments(): array;\n}\n",
      "<?php\n\nclass PhpiredisSocketConnection\n{\n    private $reader;\n    private $parameters;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        $this->parameters = $parameters;\n        $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        $this->reader = null;\n    }\n\n    private function assertExtensions()\n    {\n        if (!extension_loaded('redis')) {\n            throw new \\Exception('phpiredis extension is required.');\n        }\n    }\n\n    private function createReader()\n    {\n        $this->reader = new \\Redis();\n        $this->reader->set_status_handler($this->getStatusHandler());\n        $this->reader->set_error_handler($this->getErrorHandler());\n    }\n\n    private function getStatusHandler()\n    {\n        return function ($i, $s) {\n            return $s;\n        };\n    }\n\n    private function getErrorHandler()\n    {\n        return function ($i, $s) {\n            throw new \\Exception($s);\n        };\n    }\n\n\n    protected function createResource()\n    {\n        $address = $this->parameters->getHost() . ':' . $this->parameters->getPort();\n        $socket = stream_socket_client(\"tcp://\" . $address, $errno, $errstr, $this->parameters->getTimeout());\n\n        if (!$socket) {\n            throw new \\Exception(\"Connection to Redis failed: $errstr ($errno)\");\n        }\n\n        $this->connectWithTimeout($socket, $address, $this->parameters);\n\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        stream_set_timeout($socket, $parameters->getTimeout());\n    }\n\n    public function write(string $buffer)\n    {\n        $socket = $this->createResource();\n        fwrite($socket, $buffer);\n    }\n\n    public function read()\n    {\n        $socket = $this->createResource();\n        $response = $this->reader->_read_from_stream($socket);\n        return $response;\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getName());\n        $payload = '*' . count($arguments) . \"\\r\\n\";\n        foreach ($arguments as $argument) {\n            $payload .= '$' . strlen($argument) . \"\\r\\n\" . $argument . \"\\r\\n\";\n        }\n        $this->write($payload);\n    }\n}\n\ninterface ParametersInterface {\n    public function getHost(): string;\n    public function getPort(): int;\n    public function getTimeout(): float;\n}\n\ninterface CommandInterface {\n    public function getName(): string;\n    public function getArguments(): array;\n}\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Implement a Radius class in PHP that handles RADIUS protocol communication for authentication and accounting purposes using UDP sockets.\n\nClass Description: The Radius class provides functionality to communicate with a RADIUS server for authentication (Access-Request) and accounting operations. It handles packet construction, socket communication, and response parsing according to RADIUS protocol standards.\n\nAttributes:\n\n_ip_radius_server: [string] - IP address of the RADIUS server\n_shared_secret: [string] - Shared secret for communication with RADIUS server\n_radius_suffix: [string] - Suffix to append to usernames\n_udp_timeout: [int] - Timeout for UDP operations in seconds\n_authentication_port: [int] - Port for authentication requests (default 1812)\n_accounting_port: [int] - Port for accounting requests (default 1813)\n_nas_ip_address: [string] - NAS IP address to send in requests\n_nas_port: [int] - NAS port to send in requests\n_encrypted_password: [string] - Encrypted password for authentication\n_user_ip_address: [string] - User's IP address\n_request_authenticator: [string] - Request authenticator value\n_response_authenticator: [string] - Response authenticator value\n_username: [string] - Username for authentication\n_password: [string] - Password for authentication\n_identifier_to_send: [int] - Packet identifier to send\n_identifier_received: [int] - Received packet identifier\n_radius_packet_to_send: [int] - RADIUS packet code to send\n_radius_packet_received: [int] - Received RADIUS packet code\n_attributes_to_send: [array] - Attributes to include in outgoing packets\n_attributes_received: [array] - Attributes received from server\n_socket_to_server: [resource] - Socket connection to server\n_debug_mode: [bool] - Debug mode flag\ndebug_text: [array] - Debug messages\n_attributes_info: [array] - RADIUS attribute information\n_radius_packet_info: [array] - RADIUS packet type information\n_last_error_code: [int] - Last error code\n_last_error_message: [string] - Last error message\n\nMethods:\n\n__construct: [function]($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813) -> [void] - Initializes the Radius object with server details and default values\n\nAccessRequest: [function]($username = '', $password = '', $udp_timeout = 0, $state = NULL) -> [bool] - Sends an Access-Request to the RADIUS server and returns true if authentication is successful (Access-Accept received)\n\nSetIpRadiusServer: [function]($ip_radius_server) -> [void] - Sets the RADIUS server IP address\n\nSetSharedSecret: [function]($shared_secret) -> [void] - Sets the shared secret for RADIUS communication\n\nSetAuthenticationPort: [function]($authentication_port) -> [void] - Sets the authentication port\n\nSetAccountingPort: [function]($accounting_port) -> [void] - Sets the accounting port\n\nSetRadiusSuffix: [function]($radius_suffix) -> [void] - Sets the username suffix\n\nSetUdpTimeout: [function]($udp_timeout) -> [void] - Sets the UDP timeout value\n\nSetUsername: [function]($username = '') -> [void] - Sets the username for authentication\n\nSetPassword: [function]($password = '') -> [void] - Sets the password for authentication\n\nSetNasIpAddress: [function]($nas_ip_address = '') -> [void] - Sets the NAS IP address\n\nSetNasPort: [function]($nas_port = 0) -> [void] - Sets the NAS port\n\nSetPacketCodeToSend: [function]($packet_code) -> [void] - Sets the RADIUS packet code to send\n\nSetAttribute: [function]($attribute_type, $attribute_value) -> [void] - Adds an attribute to the outgoing packet\n\nGetNextIdentifier: [function]() -> [int] - Returns the next packet identifier\n\nGenerateRequestAuthenticator: [function]() -> [void] - Generates a new request authenticator\n\nDecodeAttribute: [function]($attribute_raw_value, $attribute_type) -> [mixed] - Decodes a received attribute value\n\nClearLastError: [function]() -> [void] - Clears the last error information\n\nClearDataToSend: [function]() -> [void] - Clears all data to be sent\n\nClearDataReceived: [function]() -> [void] - Clears all received data",
    "Canonical_solution": "class Radius\n{\n    var $_ip_radius_server;\n    var $_shared_secret;\n    var $_radius_suffix;\n    var $_udp_timeout;\n    var $_authentication_port;\n    var $_accounting_port;\n    var $_nas_ip_address;\n    var $_nas_port;\n    var $_encrypted_password;\n    var $_user_ip_address;\n    var $_request_authenticator;\n    var $_response_authenticator;\n    var $_username;\n    var $_password;\n    var $_identifier_to_send;\n    var $_identifier_received;\n    var $_radius_packet_to_send;\n    var $_radius_packet_received;\n    var $_attributes_to_send;\n    var $_attributes_received;\n    var $_socket_to_server;\n    var $_debug_mode;\n    var $debug_text = [];\n    var $_attributes_info;\n    var $_radius_packet_info;\n    var $_last_error_code;\n    var $_last_error_message;\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_radius_packet_info[1] = 'Access-Request';\n        $this->_radius_packet_info[2] = 'Access-Accept';\n        $this->_radius_packet_info[3] = 'Access-Reject';\n        $this->_radius_packet_info[4] = 'Accounting-Request';\n        $this->_radius_packet_info[5] = 'Accounting-Response';\n        $this->_radius_packet_info[11] = 'Access-Challenge';\n        $this->_radius_packet_info[12] = 'Status-Server (experimental)';\n        $this->_radius_packet_info[13] = 'Status-Client (experimental)';\n        $this->_radius_packet_info[255] = 'Reserved';\n\n        $this->_identifier_to_send = 0;\n        $this->_user_ip_address = (isset($_SERVER['REMOTE_ADDR']) ? $_SERVER['REMOTE_ADDR'] : '0.0.0.0');\n\n        $this->GenerateRequestAuthenticator();\n        $this->SetIpRadiusServer($ip_radius_server);\n        $this->SetSharedSecret($shared_secret);\n        $this->SetAuthenticationPort($authentication_port);\n        $this->SetAccountingPort($accounting_port);\n        $this->SetRadiusSuffix($radius_suffix);\n        $this->SetUdpTimeout($udp_timeout);\n        $this->SetUsername();\n        $this->SetPassword();\n        $this->SetNasIpAddress();\n        $this->SetNasPort();\n\n        $this->ClearLastError();\n        $this->ClearDataToSend();\n        $this->ClearDataReceived();\n    }\n\n    function AccessRequest($username = '', $password = '', $udp_timeout = 0, $state = NULL)\n    {\n        $this->ClearDataReceived();\n        $this->ClearLastError();\n\n        $this->SetPacketCodeToSend(1);\n\n        if (0 < strlen($username))\n        {\n            $this->SetUsername($username);\n        }\n\n        if (0 < strlen($password))\n        {\n            $this->SetPassword($password);\n        }\n\n        if ($state !== NULL)\n        {\n            $this->SetAttribute(24, $state);\n        }\n        else\n        {\n            $this->SetAttribute(6, 1);\n        }\n\n        if (intval($udp_timeout) > 0)\n        {\n            $this->SetUdpTimeout($udp_timeout);\n        }\n\n        $attributes_content = '';\n        $attribute_count1 = count((array)$this->_attributes_to_send);\n        for ($attributes_loop = 0; $attributes_loop < $attribute_count1; $attributes_loop++)\n        {\n            $attributes_content .= $this->_attributes_to_send[$attributes_loop];\n        }\n\n        $packet_length  = 4;\n        $packet_length += strlen($this->_request_authenticator);\n        $packet_length += strlen($attributes_content);\n\n        $packet_data  = chr($this->_radius_packet_to_send);\n        $packet_data .= chr($this->GetNextIdentifier());\n        $packet_data .= chr(intval($packet_length / 256));\n        $packet_data .= chr(intval($packet_length % 256));\n        $packet_data .= $this->_request_authenticator;\n        $packet_data .= $attributes_content;\n\n        $_socket_to_server = socket_create(AF_INET, SOCK_DGRAM, 17);\n\n        if ($_socket_to_server === FALSE)\n        {\n            $this->_last_error_code    = socket_last_error();\n            $this->_last_error_message = socket_strerror($this->_last_error_code);\n        }\n        elseif (FALSE === socket_connect($_socket_to_server, $this->_ip_radius_server, $this->_authentication_port))\n        {\n            $this->_last_error_code    = socket_last_error();\n            $this->_last_error_message = socket_strerror($this->_last_error_code);\n        }\n        elseif (FALSE === socket_write($_socket_to_server, $packet_data, $packet_length))\n        {\n            $this->_last_error_code    = socket_last_error();\n            $this->_last_error_message = socket_strerror($this->_last_error_code);\n        }\n        else\n        {\n            $read_socket_array   = array($_socket_to_server);\n            $write_socket_array  = NULL;\n            $except_socket_array = NULL;\n\n            $received_packet = chr(0);\n\n            if (!(FALSE === socket_select($read_socket_array, $write_socket_array, $except_socket_array, $this->_udp_timeout)))\n            {\n                if (in_array($_socket_to_server, $read_socket_array))\n                {\n                    if (FALSE === ($received_packet = @socket_read($_socket_to_server, 1024)))\n                    {\n                        $received_packet = chr(0);\n                        $this->_last_error_code    = socket_last_error();\n                        $this->_last_error_message = socket_strerror($this->_last_error_code);\n                    }\n                    else\n                    {\n                        socket_close($_socket_to_server);\n                    }\n                }\n            }\n            else\n            {\n                socket_close($_socket_to_server);\n            }\n        }\n\n        $this->_radius_packet_received = intval(ord(substr($received_packet, 0, 1)));\n\n        if ($this->_radius_packet_received > 0)\n        {\n            $this->_identifier_received = intval(ord(substr($received_packet, 1, 1)));\n            $packet_length = (intval(ord(substr($received_packet, 2, 1))) * 256) + (intval(ord(substr($received_packet, 3, 1)));\n            $this->_response_authenticator = substr($received_packet, 4, 16);\n            $attributes_content = substr($received_packet, 20, ($packet_length - 4 - 16));\n            while (strlen($attributes_content) > 2)\n            {\n                $attribute_type = intval(ord(substr($attributes_content, 0, 1)));\n                $attribute_length = intval(ord(substr($attributes_content, 1, 1)));\n                $attribute_raw_value = substr($attributes_content, 2, $attribute_length - 2);\n                $attributes_content = substr($attributes_content, $attribute_length);\n\n                $attribute_value = $this->DecodeAttribute($attribute_raw_value, $attribute_type);\n\n                $this->_attributes_received[] = array($attribute_type, $attribute_value);\n            }\n        }\n\n        return (2 == ($this->_radius_packet_received));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 137,
    "matched_results": [],
    "unmatched_results": [
      "```php\n<?php\n\nclass Radius\n{\n    private $_ip_radius_server = '127.0.0.1';\n    private $_shared_secret = '';\n    private $_radius_suffix = '';\n    private $_udp_timeout = 5;\n    private $_authentication_port = 1812;\n    private $_accounting_port = 1813;\n    private $_nas_ip_address = '';\n    private $_nas_port = 0;\n\n    private $_encrypted_password = '';\n    private $_user_ip_address = '';\n\n\n    private $_request_authenticator = '';\n    private $_response_authenticator = '';\n\n    private $_username = '';\n    private $_password = '';\n\n    private $_identifier_to_send = 1;\n    private $_identifier_received = 0;\n\n    private $_radius_packet_to_send = 0;\n    private $_radius_packet_received = 0;\n\n    private $_attributes_to_send = [];\n    private $_attributes_received = [];\n\n    private $_socket_to_server;\n\n    private $_debug_mode = false;\n    public $debug_text = [];\n\n    private $_attributes_info = [];\n    private $_radius_packet_info = [];\n\n    private $_last_error_code = 0;\n    private $_last_error_message = '';\n\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n\n        // ... (rest of the methods implementation as described in the prompt)\n    }\n\n    // ... (Implementation of other methods: AccessRequest, SetIpRadiusServer, etc.)\n\n}\n\n```\n",
      "```php\n<?php\n\nclass Radius\n{\n    private $_ip_radius_server = '127.0.0.1';\n    private $_shared_secret = '';\n    private $_radius_suffix = '';\n    private $_udp_timeout = 5;\n    private $_authentication_port = 1812;\n    private $_accounting_port = 1813;\n    private $_nas_ip_address = '';\n    private $_nas_port = 0;\n\n    private $_encrypted_password = '';\n    private $_user_ip_address = '';\n\n    private $_request_authenticator = '';\n    private $_response_authenticator = '';\n\n    private $_username = '';\n    private $_password = '';\n\n\n    private $_identifier_to_send = 1;\n    private $_identifier_received = 0;\n\n    private $_radius_packet_to_send = 0;\n    private $_radius_packet_received = 0;\n\n    private $_attributes_to_send = [];\n    private $_attributes_received = [];\n\n    private $_socket_to_server;\n\n    private $_debug_mode = false;\n    public $debug_text = [];\n\n    private $_attributes_info = [];\n    private $_radius_packet_info = [];\n\n    private $_last_error_code = 0;\n    private $_last_error_message = '';\n\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n\n        // ... (Implementation for loading attribute and packet info)\n    }\n\n    public function AccessRequest($username = '', $password = '', $udp_timeout = 0, $state = NULL)\n    {\n        // ... (Implementation for Access-Request)\n    }\n\n\n    // Setters\n    public function SetIpRadiusServer($ip_radius_server) { $this->_ip_radius_server = $ip_radius_server;}\n    public function SetSharedSecret($shared_secret) { $this->_shared_secret = $shared_secret;}\n    public function SetAuthenticationPort($authentication_port) { $this->_authentication_port = $authentication_port;}\n    public function SetAccountingPort($accounting_port) { $this->_accounting_port = $accounting_port;}\n    public function SetRadiusSuffix($radius_suffix) { $this->_radius_suffix = $radius_suffix;}\n    public function SetUdpTimeout($udp_timeout) { $this->_udp_timeout = $udp_timeout;}\n    public function SetUsername($username = '') { $this->_username = $username;}\n    public function SetPassword($password = '') { $this->_password = $password;}\n    public function SetNasIpAddress($nas_ip_address = '') { $this->_nas_ip_address = $nas_ip_address;}\n    public function SetNasPort($nas_port = 0) { $this->_nas_port = $nas_port;}\n    public function SetPacketCodeToSend($packet_code) { $this->_radius_packet_to_send = $packet_code;}\n    public function SetAttribute($attribute_type, $attribute_value) { $this->_attributes_to_send[$attribute_type] = $attribute_value;}\n\n    public function GetNextIdentifier() { return $this->_identifier_to_send++;}\n    public function GenerateRequestAuthenticator() { $this->_request_authenticator = random_bytes(16);}\n    public function DecodeAttribute($attribute_raw_value, $attribute_type) { /* ... */ }\n    public function ClearLastError() { $this->_last_error_code = 0; $this->_last_error_message = '';}\n    public function ClearDataToSend() { /* ... */ }\n    public function ClearDataReceived() { /* ... */ }\n\n}\n\n```",
      "```php\n<?php\n\nclass Radius\n{\n    private $_ip_radius_server = '127.0.0.1';\n    private $_shared_secret = '';\n    private $_radius_suffix = '';\n    private $_udp_timeout = 5;\n    private $_authentication_port = 1812;\n    private $_accounting_port = 1813;\n    private $_nas_ip_address = '';\n    private $_nas_port = 0;\n\n    private $_encrypted_password = '';\n    private $_user_ip_address = '';\n\n\n    private $_request_authenticator = '';\n    private $_response_authenticator = '';\n\n    private $_username = '';\n    private $_password = '';\n\n    private $_identifier_to_send = 1;\n    private $_identifier_received = 0;\n\n    private $_radius_packet_to_send = 0;\n    private $_radius_packet_received = 0;\n\n    private $_attributes_to_send = [];\n    private $_attributes_received = [];\n\n    private $_socket_to_server;\n\n    private $_debug_mode = false;\n    public $debug_text = [];\n\n    private $_attributes_info = [];\n    private $_radius_packet_info = [];\n\n    private $_last_error_code = 0;\n    private $_last_error_message = '';\n\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n\n        // ... (rest of the methods implementation as described in the prompt)\n    }\n\n    // ... (Implementation of AccessRequest, SetIpRadiusServer, SetSharedSecret, etc.)\n\n    public function AccessRequest($username = '', $password = '', $udp_timeout = 0, $state = NULL)\n    {\n        // ... (Implementation)\n    }\n\n    // ... (Implementation of other methods)\n}\n\n```",
      "```php\n<?php\n\nclass Radius\n{\n    private $_ip_radius_server = '127.0.0.1';\n    private $_shared_secret = '';\n    private $_radius_suffix = '';\n    private $_udp_timeout = 5;\n    private $_authentication_port = 1812;\n    private $_accounting_port = 1813;\n    private $_nas_ip_address = '';\n    private $_nas_port = 0;\n\n    private $_encrypted_password = '';\n    private $_user_ip_address = '';\n\n\n    private $_request_authenticator = '';\n    private $_response_authenticator = '';\n\n    private $_username = '';\n    private $_password = '';\n\n\n    private $_identifier_to_send = 1;\n    private $_identifier_received = 0;\n\n    private $_radius_packet_to_send = 0;\n    private $_radius_packet_received = 0;\n\n\n    private $_attributes_to_send = [];\n    private $_attributes_received = [];\n\n\n    private $_socket_to_server;\n\n    private $_debug_mode = false;\n    public $debug_text = [];\n\n    private $_attributes_info = [];\n    private $_radius_packet_info = [];\n\n    private $_last_error_code = 0;\n    private $_last_error_message = '';\n\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n\n        // ... (rest of the methods implementation as described in the prompt)\n    }\n\n    // ... (Implementation of other methods: AccessRequest, SetIpRadiusServer, etc.)\n\n}\n\n```\n",
      "```php\n<?php\n\nclass Radius\n{\n    private $_ip_radius_server = '127.0.0.1';\n    private $_shared_secret = '';\n    private $_radius_suffix = '';\n    private $_udp_timeout = 5;\n    private $_authentication_port = 1812;\n    private $_accounting_port = 1813;\n    private $_nas_ip_address = '';\n    private $_nas_port = 0;\n\n    private $_encrypted_password = '';\n    private $_user_ip_address = '';\n\n\n    private $_request_authenticator = '';\n    private $_response_authenticator = '';\n\n    private $_username = '';\n    private $_password = '';\n\n    private $_identifier_to_send = 1;\n    private $_identifier_received = 0;\n\n    private $_radius_packet_to_send = 0;\n    private $_radius_packet_received = 0;\n\n    private $_attributes_to_send = [];\n    private $_attributes_received = [];\n\n    private $_socket_to_server;\n\n    private $_debug_mode = false;\n    public $debug_text = [];\n\n    private $_attributes_info = [];\n    private $_radius_packet_info = [];\n\n    private $_last_error_code = 0;\n    private $_last_error_message = '';\n\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n\n        // ... (rest of the methods implementation as described in the prompt)\n    }\n\n    // ... (Implementation of AccessRequest, SetIpRadiusServer, SetSharedSecret, etc.)\n\n}\n\n```\n",
      "```php\n<?php\n\nclass Radius\n{\n    private $_ip_radius_server = '127.0.0.1';\n    private $_shared_secret = '';\n    private $_radius_suffix = '';\n    private $_udp_timeout = 5;\n    private $_authentication_port = 1812;\n    private $_accounting_port = 1813;\n    private $_nas_ip_address = '';\n    private $_nas_port = 0;\n\n    private $_encrypted_password = '';\n    private $_user_ip_address = '';\n\n\n    private $_request_authenticator = '';\n    private $_response_authenticator = '';\n\n    private $_username = '';\n    private $_password = '';\n\n    private $_identifier_to_send = 1;\n    private $_identifier_received = 0;\n\n    private $_radius_packet_to_send = 0;\n    private $_radius_packet_received = 0;\n\n    private $_attributes_to_send = [];\n    private $_attributes_received = [];\n\n    private $_socket_to_server;\n\n    private $_debug_mode = false;\n    public $debug_text = [];\n\n    private $_attributes_info = [];\n    private $_radius_packet_info = [];\n\n    private $_last_error_code = 0;\n    private $_last_error_message = '';\n\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n\n        // ... (rest of the methods implementation as described in the prompt)\n    }\n\n    // ... (Implementation of AccessRequest, SetIpRadiusServer, SetSharedSecret, etc.)\n\n}\n\n```\n",
      "```php\n<?php\n\nclass Radius\n{\n    private $_ip_radius_server = '127.0.0.1';\n    private $_shared_secret = '';\n    private $_radius_suffix = '';\n    private $_udp_timeout = 5;\n    private $_authentication_port = 1812;\n    private $_accounting_port = 1813;\n    private $_nas_ip_address = '';\n    private $_nas_port = 0;\n\n    private $_encrypted_password = '';\n    private $_user_ip_address = '';\n\n\n    private $_request_authenticator = '';\n    private $_response_authenticator = '';\n\n    private $_username = '';\n    private $_password = '';\n\n    private $_identifier_to_send = 1;\n    private $_identifier_received = 0;\n\n    private $_radius_packet_to_send = 0;\n    private $_radius_packet_received = 0;\n\n    private $_attributes_to_send = [];\n    private $_attributes_received = [];\n\n    private $_socket_to_server;\n\n    private $_debug_mode = false;\n    public $debug_text = [];\n\n    private $_attributes_info = [];\n    private $_radius_packet_info = [];\n\n    private $_last_error_code = 0;\n    private $_last_error_message = '';\n\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n\n        // ... (Implementation for loading attribute and packet info)\n    }\n\n    public function AccessRequest($username = '', $password = '', $udp_timeout = 0, $state = NULL)\n    {\n        // ... (Implementation for Access-Request)\n    }\n\n\n    // Setters\n    public function SetIpRadiusServer($ip_radius_server) { $this->_ip_radius_server = $ip_radius_server;}\n    public function SetSharedSecret($shared_secret) { $this->_shared_secret = $shared_secret;}\n    public function SetAuthenticationPort($authentication_port) { $this->_authentication_port = $authentication_port;}\n    public function SetAccountingPort($accounting_port) { $this->_accounting_port = $accounting_port;}\n    public function SetRadiusSuffix($radius_suffix) { $this->_radius_suffix = $radius_suffix;}\n    public function SetUdpTimeout($udp_timeout) { $this->_udp_timeout = $udp_timeout;}\n    public function SetUsername($username = '') { $this->_username = $username;}\n    public function SetPassword($password = '') { $this->_password = $password;}\n    public function SetNasIpAddress($nas_ip_address = '') { $this->_nas_ip_address = $nas_ip_address;}\n    public function SetNasPort($nas_port = 0) { $this->_nas_port = $nas_port;}\n    public function SetPacketCodeToSend($packet_code) { $this->_radius_packet_to_send = $packet_code;}\n    public function SetAttribute($attribute_type, $attribute_value) { $this->_attributes_to_send[$attribute_type] = $attribute_value;}\n\n\n    public function GetNextIdentifier()\n    {\n        return $this->_identifier_to_send++;\n    }\n\n    public function GenerateRequestAuthenticator()\n    {\n        // ... (Implementation for generating request authenticator)\n    }\n\n    public function DecodeAttribute($attribute_raw_value, $attribute_type)\n    {\n        // ... (Implementation for decoding attributes)\n    }\n\n    public function ClearLastError()\n    {\n        $this->_last_error_code = 0;\n        $this->_last_error_message = '';\n    }\n\n    public function ClearDataToSend()\n    {\n        // ... (Implementation for clearing data to send)\n    }\n\n    public function ClearDataReceived()\n    {\n        // ... (Implementation for clearing received data)\n    }\n}\n\n```",
      "```php\n<?php\n\nclass Radius\n{\n    private $_ip_radius_server = '127.0.0.1';\n    private $_shared_secret = '';\n    private $_radius_suffix = '';\n    private $_udp_timeout = 5;\n    private $_authentication_port = 1812;\n    private $_accounting_port = 1813;\n    private $_nas_ip_address = '';\n    private $_nas_port = 0;\n\n    private $_encrypted_password = '';\n    private $_user_ip_address = '';\n\n\n    private $_request_authenticator = '';\n    private $_response_authenticator = '';\n\n    private $_username = '';\n    private $_password = '';\n\n    private $_identifier_to_send = 1;\n    private $_identifier_received = 0;\n\n    private $_radius_packet_to_send = 0;\n    private $_radius_packet_received = 0;\n\n    private $_attributes_to_send = [];\n    private $_attributes_received = [];\n\n    private $_socket_to_server;\n\n    private $_debug_mode = false;\n    public $debug_text = [];\n\n    private $_attributes_info = [];\n    private $_radius_packet_info = [];\n\n    private $_last_error_code = 0;\n    private $_last_error_message = '';\n\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n\n        // ... (Implementation for loading attribute and packet info)\n    }\n\n    public function AccessRequest($username = '', $password = '', $udp_timeout = 0, $state = NULL)\n    {\n        // ... (Implementation for Access-Request)\n    }\n\n\n    // Setters\n    public function SetIpRadiusServer($ip_radius_server) { $this->_ip_radius_server = $ip_radius_server;}\n    public function SetSharedSecret($shared_secret) { $this->_shared_secret = $shared_secret;}\n    public function SetAuthenticationPort($authentication_port) { $this->_authentication_port = $authentication_port;}\n    public function SetAccountingPort($accounting_port) { $this->_accounting_port = $accounting_port;}\n    public function SetRadiusSuffix($radius_suffix) { $this->_radius_suffix = $radius_suffix;}\n    public function SetUdpTimeout($udp_timeout) { $this->_udp_timeout = $udp_timeout;}\n    public function SetUsername($username = '') { $this->_username = $username;}\n    public function SetPassword($password = '') { $this->_password = $password;}\n    public function SetNasIpAddress($nas_ip_address = '') { $this->_nas_ip_address = $nas_ip_address;}\n    public function SetNasPort($nas_port = 0) { $this->_nas_port = $nas_port;}\n    public function SetPacketCodeToSend($packet_code) { $this->_radius_packet_to_send = $packet_code;}\n    public function SetAttribute($attribute_type, $attribute_value) { $this->_attributes_to_send[$attribute_type] = $attribute_value;}\n\n    public function GetNextIdentifier() { return $this->_identifier_to_send++;}\n\n    public function GenerateRequestAuthenticator() { $this->_request_authenticator = random_bytes(16);}\n\n    public function DecodeAttribute($attribute_raw_value, $attribute_type) { /* ... */ }\n\n    public function ClearLastError() { $this->_last_error_code = 0; $this->_last_error_message = '';}\n\n    public function ClearDataToSend() { /* ... */ }\n\n    public function ClearDataReceived() { /* ... */ }\n\n}\n\n```",
      "```php\n<?php\n\nclass Radius\n{\n    private $_ip_radius_server = '127.0.0.1';\n    private $_shared_secret = '';\n    private $_radius_suffix = '';\n    private $_udp_timeout = 5;\n    private $_authentication_port = 1812;\n    private $_accounting_port = 1813;\n    private $_nas_ip_address = '';\n    private $_nas_port = 0;\n\n    private $_encrypted_password = '';\n    private $_user_ip_address = '';\n\n\n    private $_request_authenticator = '';\n    private $_response_authenticator = '';\n\n    private $_username = '';\n    private $_password = '';\n\n    private $_identifier_to_send = 1;\n    private $_identifier_received = 0;\n\n    private $_radius_packet_to_send = 0;\n    private $_radius_packet_received = 0;\n\n    private $_attributes_to_send = [];\n    private $_attributes_received = [];\n\n    private $_socket_to_server;\n\n    private $_debug_mode = false;\n    public $debug_text = [];\n\n    private $_attributes_info = [];\n    private $_radius_packet_info = [];\n\n    private $_last_error_code = 0;\n    private $_last_error_message = '';\n\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n\n        // ... (rest of the methods implementation as described in the prompt)\n    }\n\n    // ... (Implementation of AccessRequest, SetIpRadiusServer, SetSharedSecret, etc.)\n\n}\n\n```\n",
      "```php\n<?php\n\nclass Radius\n{\n    private $_ip_radius_server = '127.0.0.1';\n    private $_shared_secret = '';\n    private $_radius_suffix = '';\n    private $_udp_timeout = 5;\n    private $_authentication_port = 1812;\n    private $_accounting_port = 1813;\n    private $_nas_ip_address = '';\n    private $_nas_port = 0;\n\n    private $_encrypted_password = '';\n    private $_user_ip_address = '';\n\n\n    private $_request_authenticator = '';\n    private $_response_authenticator = '';\n\n    private $_username = '';\n    private $_password = '';\n\n    private $_identifier_to_send = 1;\n    private $_identifier_received = 0;\n\n    private $_radius_packet_to_send = 0;\n    private $_radius_packet_received = 0;\n\n\n    private $_attributes_to_send = [];\n    private $_attributes_received = [];\n\n    private $_socket_to_server;\n\n    private $_debug_mode = false;\n    public $debug_text = [];\n\n    private $_attributes_info = [];\n    private $_radius_packet_info = [];\n\n    private $_last_error_code = 0;\n    private $_last_error_message = '';\n\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n\n        // ... (rest of the methods implementation as described in the prompt)\n    }\n\n    // ... (Implementation of AccessRequest, SetIpRadiusServer, SetSharedSecret, etc.)\n\n    public function AccessRequest($username = '', $password = '', $udp_timeout = 0, $state = NULL)\n    {\n        // ... (Implementation of AccessRequest method)\n    }\n\n    // ... (Implementation of other methods)\n}\n\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using Symfony's HTTP client components to handle HTTP requests and responses.\n\nClass Description: The HttpClientKernel class is an implementation of HttpKernelInterface that provides HTTP client capabilities using Symfony's HTTP client components. It handles HTTP requests by sending them to a remote server and returning the response, supporting various request methods, headers, cookies, and body content (including form data and file uploads).\n\nAttributes:\n- client: [HttpClientInterface] - The Symfony HTTP client instance used to send requests\n\nMethods:\n- __construct(?HttpClientInterface $client = null) -> [void] - Initializes the HTTP client. If no client is provided, creates a default HttpClient instance. Throws an exception if the HttpClient component is not installed.\n- handle(Request $request, int $type = HttpKernelInterface::MAIN_REQUEST, bool $catch = true) -> [Response] - Processes an HTTP request by sending it to the target server and returns the response. Handles headers, cookies, and request body preparation.\n- getBody(Request $request) -> [?AbstractPart] - Prepares the request body content. Returns null for GET/HEAD requests, a TextPart for raw content, or a FormDataPart for form data including file uploads. Throws an exception if the Mime component is not installed when needed.\n- getHeaders(Request $request) -> [array] - Extracts and formats headers from the request object, including cookies, into an array suitable for the HTTP client.",
    "Canonical_solution": "use Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (null === $client && !class_exists(HttpClient::class)) {\n            throw new \\LogicException(sprintf('You cannot use \"%s\" as the HttpClient component is not installed. Try running \"composer require symfony/http-client\".', __CLASS__));\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = HttpKernelInterface::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $headers = $this->getHeaders($request);\n        $body = '';\n        if (null !== $part = $this->getBody($request)) {\n            $headers = array_merge($headers, $part->getPreparedHeaders()->toArray());\n            $body = $part->bodyToIterable();\n        }\n        $response = $this->client->request($request->getMethod(), $request->getUri(), [\n            'headers' => $headers,\n            'body' => $body,\n        ] + $request->attributes->get('http_client_options', []));\n\n        $response = new Response($response->getContent(!$catch), $response->getStatusCode(), $response->getHeaders(!$catch));\n\n        $response->headers->remove('X-Body-File');\n        $response->headers->remove('X-Body-Eval');\n        $response->headers->remove('X-Content-Digest');\n\n        $response->headers = new class($response->headers->all()) extends ResponseHeaderBag {\n            protected function computeCacheControlValue(): string\n            {\n                return $this->getCacheControlHeader();\n            }\n        };\n\n        return $response;\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (\\in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        if (!class_exists(AbstractPart::class)) {\n            throw new \\LogicException('You cannot pass non-empty bodies as the Mime component is not installed. Try running \"composer require symfony/mime\".');\n        }\n\n        if ($content = $request->getContent()) {\n            return new TextPart($content, 'utf-8', 'plain', '8bit');\n        }\n\n        $fields = $request->request->all();\n        foreach ($request->files->all() as $name => $file) {\n            $fields[$name] = DataPart::fromPath($file->getPathname(), $file->getClientOriginalName(), $file->getClientMimeType());\n        }\n\n        return new FormDataPart($fields);\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers as $key => $value) {\n            $headers[$key] = $value;\n        }\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name.'='.$value;\n        }\n        if ($cookies) {\n            $headers['cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 134,
    "matched_results": [
      "<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ClientExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\RedirectionExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ServerExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (!class_exists(HttpClient::class)) {\n            throw new \\LogicException('The HttpClient component is not installed. Try running \"composer require symfony/http-client\".');\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        try {\n            $response = $this->client->request(\n                $request->getMethod(),\n                $request->getUri(),\n                [\n                    'headers' => $this->getHeaders($request),\n                    'body' => $this->getBody($request),\n                ]\n            );\n\n            return new Response(\n                $response->getContent(false),\n                $response->getStatusCode(),\n                $response->getHeaders(false)\n            );\n\n        } catch (TransportExceptionInterface $e) {\n            throw new \\RuntimeException('Transport error: ' . $e->getMessage(), 0, $e);\n        } catch (ClientExceptionInterface | RedirectionExceptionInterface | ServerExceptionInterface $e) {\n            throw new \\RuntimeException('HTTP error: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n\n    }\n\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false) {\n            return new TextPart($content, $request->headers->get('Content-Type'));\n        }\n\n\n        if ($request->files->count() > 0) {\n            if (!class_exists(FormDataPart::class)) {\n                throw new \\LogicException('The Mime component is not installed. Try running \"composer require symfony/mime\".');\n            }\n\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[] = [$key, $value];\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[] = [$key, DataPart::fromPath($file->getPathname()), $file->getClientOriginalName(), $file->getClientMimeType()];\n            }\n\n            return new FormDataPart($formData);\n        }\n\n        return null;\n\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            if (strtolower($name) === 'cookie') {\n                continue;\n            }\n            $headers[$name] = $values;\n        }\n\n        if ($request->cookies->count()) {\n            $cookies = [];\n            foreach ($request->cookies->all() as $name => $value) {\n                $cookies[] = $name . '=' . $value;\n            }\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ClientExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\RedirectionExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ServerExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (!class_exists(HttpClient::class)) {\n            throw new \\LogicException('The HttpClient component is not installed. Try running \"composer require symfony/http-client\".');\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        try {\n            $response = $this->client->request(\n                $request->getMethod(),\n                $request->getUri(),\n                [\n                    'headers' => $this->getHeaders($request),\n                    'body' => $this->getBody($request),\n                ]\n            );\n\n            return new Response(\n                $response->getContent(false),\n                $response->getStatusCode(),\n                $response->getHeaders()\n            );\n\n        } catch (TransportExceptionInterface $e) {\n            throw new \\RuntimeException('Transport error: ' . $e->getMessage(), 0, $e);\n        } catch (ClientExceptionInterface | RedirectionExceptionInterface | ServerExceptionInterface $e) {\n            throw new \\RuntimeException('HTTP error: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n    }\n\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false) {\n            return new TextPart($content, $request->headers->get('Content-Type'));\n        }\n\n        if ($request->files->count() > 0) {\n            if (!class_exists(FormDataPart::class)) {\n                throw new \\LogicException('The Mime component is not installed. Try running \"composer require symfony/mime\".');\n            }\n\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[] = ['name' => $key, 'content' => $value];\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[] = ['name' => $key, 'content' => $file->getContent(), 'filename' => $file->getClientOriginalName()];\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            if (strtolower($name) === 'cookie') {\n                continue;\n            }\n            $headers[$name] = $values;\n        }\n\n        foreach ($request->cookies->all() as $name => $value) {\n            $headers['cookie'][] = $name . '=' . $value;\n        }\n\n        return $headers;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ClientExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\RedirectionExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ServerExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (!class_exists(HttpClient::class)) {\n            throw new \\LogicException('The HttpClient component is not installed. Try running \"composer require symfony/http-client\".');\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        try {\n            $response = $this->client->request(\n                $request->getMethod(),\n                $request->getUri(),\n                [\n                    'headers' => $this->getHeaders($request),\n                    'body' => $this->getBody($request),\n                ]\n            );\n\n            return new Response(\n                $response->getContent(false),\n                $response->getStatusCode(),\n                $response->getHeaders()\n            );\n\n        } catch (TransportExceptionInterface $e) {\n            throw new \\RuntimeException('Transport error: ' . $e->getMessage(), 0, $e);\n        } catch (ClientExceptionInterface | RedirectionExceptionInterface | ServerExceptionInterface $e) {\n            throw new \\RuntimeException('HTTP error: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n\n    }\n\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== null) {\n            return new TextPart($content, $request->headers->get('Content-Type'));\n        }\n\n        if ($request->files->count() > 0) {\n            if (!class_exists(FormDataPart::class)) {\n                throw new \\LogicException('The Mime component is not installed. Try running \"composer require symfony/mime\".');\n            }\n\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[] = [$key, $value];\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[] = [$key, DataPart::fromPath($file->getPathname()), $file->getClientOriginalName(), $file->getClientMimeType()];\n            }\n\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            if (strtolower($name) === 'cookie') {\n                continue;\n            }\n            $headers[$name] = $values;\n        }\n\n        if ($request->cookies->count()) {\n            $cookies = [];\n            foreach ($request->cookies->all() as $name => $value) {\n                $cookies[] = $name . '=' . $value;\n            }\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ClientExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\RedirectionExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ServerExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (!class_exists(HttpClient::class)) {\n            throw new \\LogicException('The HttpClient component is not installed. Try running \"composer require symfony/http-client\".');\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        try {\n            $response = $this->client->request(\n                $request->getMethod(),\n                $request->getUri(),\n                [\n                    'headers' => $this->getHeaders($request),\n                    'body' => $this->getBody($request),\n                ]\n            );\n\n            return new Response(\n                $response->getContent(false),\n                $response->getStatusCode(),\n                $response->getHeaders()\n            );\n\n        } catch (TransportExceptionInterface $e) {\n            throw new \\RuntimeException('Transport error: ' . $e->getMessage(), 0, $e);\n        } catch (ClientExceptionInterface | RedirectionExceptionInterface | ServerExceptionInterface $e) {\n            throw new \\RuntimeException('HTTP error: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n\n    }\n\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== null) {\n            return new TextPart($content, $request->headers->get('Content-Type'));\n        }\n\n        if ($request->files->count() > 0) {\n            if (!class_exists(FormDataPart::class)) {\n                throw new \\LogicException('The Mime component is not installed. Try running \"composer require symfony/mime\".');\n            }\n\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[] = [$key, $value];\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[] = [$key, DataPart::fromPath($file->getPathname()), $file->getClientOriginalName(), $file->getClientMimeType()];\n            }\n\n            return new FormDataPart($formData);\n        }\n\n        return null;\n\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            if (strtolower($name) === 'cookie') {\n                continue;\n            }\n            $headers[$name] = $values;\n        }\n\n        if ($request->cookies->count()) {\n            $cookies = [];\n            foreach ($request->cookies->all() as $name => $value) {\n                $cookies[] = $name . '=' . $value;\n            }\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ClientExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\RedirectionExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ServerExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (!class_exists(HttpClient::class)) {\n            throw new \\LogicException('The HttpClient component is not installed. Try running \"composer require symfony/http-client\".');\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        try {\n            $response = $this->client->request(\n                $request->getMethod(),\n                $request->getUri(),\n                [\n                    'headers' => $this->getHeaders($request),\n                    'body' => $this->getBody($request),\n                ]\n            );\n\n            return new Response(\n                $response->getContent(false),\n                $response->getStatusCode(),\n                $response->getHeaders(false)\n            );\n        } catch (TransportExceptionInterface $e) {\n            throw new \\RuntimeException('Transport error: ' . $e->getMessage(), 0, $e);\n        } catch (ClientExceptionInterface|RedirectionExceptionInterface|ServerExceptionInterface $e) {\n            throw new \\RuntimeException('HTTP error: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n    }\n\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false) {\n            return new TextPart($content, $request->headers->get('Content-Type'));\n        }\n\n        if ($request->files->count() > 0) {\n            if (!class_exists(FormDataPart::class)) {\n                throw new \\LogicException('The Mime component is not installed. Try running \"composer require symfony/mime\".');\n            }\n\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[] = ['name' => $key, 'content' => $value];\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[] = ['name' => $key, 'content' => $file->getContent(), 'filename' => $file->getClientOriginalName()];\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            if (strtolower($name) === 'cookie') {\n                continue;\n            }\n            $headers[$name] = $values;\n        }\n\n        foreach ($request->cookies->all() as $name => $value) {\n            $headers['cookie'][] = $name . '=' . $value;\n        }\n\n        return $headers;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ClientExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\RedirectionExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ServerExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (!class_exists(HttpClient::class)) {\n            throw new \\LogicException('The HttpClient component is not installed. Try running \"composer require symfony/http-client\".');\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        try {\n            $response = $this->client->request(\n                $request->getMethod(),\n                $request->getUri(),\n                [\n                    'headers' => $this->getHeaders($request),\n                    'body' => $this->getBody($request),\n                ]\n            );\n\n            return new Response(\n                $response->getContent(false),\n                $response->getStatusCode(),\n                $response->getHeaders()\n            );\n\n        } catch (TransportExceptionInterface $e) {\n            throw new \\RuntimeException('Transport error: ' . $e->getMessage(), 0, $e);\n        } catch (ClientExceptionInterface | RedirectionExceptionInterface | ServerExceptionInterface $e) {\n            throw new \\RuntimeException('HTTP error: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n\n    }\n\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== null) {\n            return new TextPart($content, $request->headers->get('Content-Type'));\n        }\n\n        if ($request->files->count() > 0) {\n            if (!class_exists(FormDataPart::class)) {\n                throw new \\LogicException('The Mime component is not installed. Try running \"composer require symfony/mime\".');\n            }\n\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[] = [$key, $value];\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[] = [$key, DataPart::fromPath($file->getPathname()), $file->getClientOriginalName(), $file->getClientMimeType()];\n            }\n\n            return new FormDataPart($formData);\n        }\n\n        return null;\n\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            if (strtolower($name) === 'cookie') {\n                continue;\n            }\n            $headers[$name] = $values;\n        }\n\n        foreach ($request->cookies->all() as $name => $value) {\n            $headers['cookie'][] = $name . '=' . $value;\n        }\n\n        return $headers;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ClientExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\RedirectionExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ServerExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (!class_exists(HttpClient::class)) {\n            throw new \\LogicException('The HttpClient component is not installed. Try running \"composer require symfony/http-client\".');\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        try {\n            $response = $this->client->request(\n                $request->getMethod(),\n                $request->getUri(),\n                [\n                    'headers' => $this->getHeaders($request),\n                    'body' => $this->getBody($request),\n                ]\n            );\n\n            return new Response(\n                $response->getContent(false),\n                $response->getStatusCode(),\n                $response->getHeaders()\n            );\n\n        } catch (TransportExceptionInterface $e) {\n            throw new \\RuntimeException('Transport error: ' . $e->getMessage(), 0, $e);\n        } catch (ClientExceptionInterface | RedirectionExceptionInterface | ServerExceptionInterface $e) {\n            throw new \\RuntimeException('HTTP error: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n\n    }\n\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== null) {\n            return new TextPart($content, $request->headers->get('Content-Type'));\n        }\n\n        if ($request->files->count() > 0) {\n            if (!class_exists(FormDataPart::class)) {\n                throw new \\LogicException('The Mime component is not installed. Try running \"composer require symfony/mime\".');\n            }\n\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[] = ['name' => $key, 'content' => $value];\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[] = ['name' => $key, 'content' => $file->getContent(), 'filename' => $file->getClientOriginalName()];\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            if (strtolower($name) === 'cookie') {\n                continue;\n            }\n            $headers[$name] = $values;\n        }\n\n        foreach ($request->cookies->all() as $name => $value) {\n            $headers['cookie'][] = $name . '=' . $value;\n        }\n\n        return $headers;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ClientExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\RedirectionExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ServerExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (!class_exists(HttpClient::class)) {\n            throw new \\LogicException('The HttpClient component is not installed. Try running \"composer require symfony/http-client\".');\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        try {\n            $response = $this->client->request(\n                $request->getMethod(),\n                $request->getUri(),\n                [\n                    'headers' => $this->getHeaders($request),\n                    'body' => $this->getBody($request),\n                ]\n            );\n\n            return new Response(\n                $response->getContent(false),\n                $response->getStatusCode(),\n                $response->getHeaders(false)\n            );\n\n        } catch (TransportExceptionInterface $e) {\n            throw new \\RuntimeException('Transport error: ' . $e->getMessage(), 0, $e);\n        } catch (ClientExceptionInterface | RedirectionExceptionInterface | ServerExceptionInterface $e) {\n            throw new \\RuntimeException('HTTP error: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n\n    }\n\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false) {\n            return new TextPart($content, $request->headers->get('Content-Type'));\n        }\n\n        if ($request->files->count() > 0) {\n            if (!class_exists(FormDataPart::class)) {\n                throw new \\LogicException('The Mime component is not installed. Try running \"composer require symfony/mime\".');\n            }\n\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[] = [$key, $value];\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[] = [$key, DataPart::fromPath($file->getPathname()), $file->getClientOriginalName(), $file->getClientMimeType()];\n            }\n\n            return new FormDataPart($formData);\n        }\n\n        return null;\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            if (strtolower($name) === 'cookie') {\n                continue;\n            }\n            $headers[$name] = $values;\n        }\n\n        if ($request->cookies->count()) {\n            $cookies = [];\n            foreach ($request->cookies->all() as $name => $value) {\n                $cookies[] = $name . '=' . $value;\n            }\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ClientExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\RedirectionExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ServerExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (!class_exists(HttpClient::class)) {\n            throw new \\LogicException('The HttpClient component is not installed. Try running \"composer require symfony/http-client\".');\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        try {\n            $response = $this->client->request(\n                $request->getMethod(),\n                $request->getUri(),\n                [\n                    'headers' => $this->getHeaders($request),\n                    'body' => $this->getBody($request),\n                ]\n            );\n\n            return new Response(\n                $response->getContent(false),\n                $response->getStatusCode(),\n                $response->getHeaders()\n            );\n\n        } catch (TransportExceptionInterface $e) {\n            throw new \\RuntimeException('Transport error: ' . $e->getMessage(), 0, $e);\n        } catch (ClientExceptionInterface | RedirectionExceptionInterface | ServerExceptionInterface $e) {\n            throw new \\RuntimeException('HTTP error: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n\n    }\n\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false) {\n            return new TextPart($content, $request->headers->get('Content-Type'));\n        }\n\n        if ($request->files->count() > 0) {\n            if (!class_exists(FormDataPart::class)) {\n                throw new \\LogicException('The Mime component is not installed. Try running \"composer require symfony/mime\".');\n            }\n\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[] = [$key, $value];\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[] = [$key, DataPart::fromPath($file->getPathname()), $file->getClientOriginalName(), $file->getClientMimeType()];\n            }\n\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            if (strtolower($name) === 'cookie') {\n                continue;\n            }\n            $headers[$name] = $values;\n        }\n\n        foreach ($request->cookies->all() as $name => $value) {\n            $headers['cookie'][] = $name . '=' . $value;\n        }\n\n        return $headers;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ClientExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\RedirectionExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\ServerExceptionInterface;\nuse Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(?HttpClientInterface $client = null)\n    {\n        if (!class_exists(HttpClient::class)) {\n            throw new \\LogicException('The HttpClient component is not installed. Try running \"composer require symfony/http-client\".');\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        try {\n            $response = $this->client->request(\n                $request->getMethod(),\n                $request->getUri(),\n                [\n                    'headers' => $this->getHeaders($request),\n                    'body' => $this->getBody($request),\n                ]\n            );\n\n            return new Response(\n                $response->getContent(false),\n                $response->getStatusCode(),\n                $response->getHeaders()\n            );\n        } catch (TransportExceptionInterface $e) {\n            throw new \\RuntimeException('Transport error: ' . $e->getMessage(), 0, $e);\n        } catch (ClientExceptionInterface|RedirectionExceptionInterface|ServerExceptionInterface $e) {\n            throw new \\RuntimeException('HTTP error: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n\n    }\n\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== null) {\n            return new TextPart($content, $request->headers->get('Content-Type'));\n        }\n\n        if ($request->files->count() > 0) {\n            if (!class_exists(FormDataPart::class)) {\n                throw new \\LogicException('The Mime component is not installed. Try running \"composer require symfony/mime\".');\n            }\n\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[] = [$key, $value];\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[] = [$key, DataPart::fromPath($file->getPathname(), $file->getClientOriginalName(), $file->getClientMimeType())];\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            if (strtolower($name) === 'cookie') {\n                continue;\n            }\n            $headers[$name] = $values;\n        }\n\n        foreach ($request->cookies->all() as $name => $value) {\n            $headers['cookie'][] = $name . '=' . $value;\n        }\n\n        return $headers;\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 130,
    "Instruction": "Task Description: Implement a UDP scraper class for interacting with BitTorrent trackers to scrape torrent statistics using UDP protocol.\n\nClass Description: UdpScraper is a class that handles communication with BitTorrent trackers via UDP protocol to retrieve scrape information (seeders, leechers, downloads) for given torrent info hashes. It manages socket connections, transaction IDs, and packet formatting according to the UDP tracker protocol.\n\nAttributes:\n- currentConnectionId: [string] - The connection ID received from the tracker after initial connection\n- transactionId: [int] - The current transaction ID used for request/response tracking\n- socket: [resource|null] - The UDP socket resource for communication\n- timeout: [int] - Socket timeout in seconds for send/receive operations\n\nMethods:\n- scrape([Tracker $tracker, array $hashes]) -> [array] - Main method to scrape multiple torrent hashes by splitting them into chunks\n- scrapeChunk([Tracker $tracker, array $hashes]) -> [array] - Scrapes a chunk of torrent hashes (max 74 at a time)\n- initSocket() -> [resource] - Initializes and returns a UDP socket\n- connect([string $domain, int $port]) -> [void] - Connects the socket to the tracker\n- generateTransactionId() -> [void] - Generates a random transaction ID\n- startTransaction() -> [void] - Initiates connection with the tracker and establishes connection ID\n- scrapeHashes([array $hashes]) -> [array] - Sends scrape request for given hashes and processes response\n- request([string $packet, int $readLength]) -> [string] - Sends packet and reads response with timeout\n- closeSocket() -> [void] - Closes the socket and resets connection state\n- checkError([string $response]) -> [void] - Checks for and handles error responses from tracker",
    "Canonical_solution": "namespace common\\modules\\torrent_scraper\\models;\n\nuse common\\models\\ScraperException;\n\nclass UdpScraper extends BaseScraper\n{\n    const ACTION_CONNECT = 0;\n    const ACTION_ANNOUNCE = 1;\n    const ACTION_SCRAPE = 2;\n    const ACTION_ERROR = 3;\n\n    const CONNECTION_ID = \"\\x00\\x00\\x04\\x17\\x27\\x10\\x19\\x80\";\n\n    protected $currentConnectionId = null;\n    protected $transactionId = null;\n    protected $socket = null;\n    protected $timeout = 15;\n\n    public function scrape(Tracker $tracker, array $hashes)\n    {\n        $chunks = array_chunk($hashes, 74);\n        $result = [];\n        foreach ($chunks as $chunk) {\n            $result = array_merge($result, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $result;\n    }\n\n    public function scrapeChunk(Tracker $tracker, $hashes)\n    {\n        $this->initSocket();\n        $this->connect($tracker->host, $tracker->port);\n        $this->startTransaction();\n        $torrents = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $torrents;\n    }\n\n    protected function initSocket()\n    {\n        if ($this->socket === null) {\n            $socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n            if ($socket === false) {\n                throw new UdpScraperException(socket_strerror(socket_last_error()));\n            }\n            $this->socket = $socket;\n        }\n        return $this->socket;\n    }\n\n    protected function connect($domain, $port)\n    {\n        if (socket_connect($this->socket, $domain, $port) === false) {\n            throw new UdpScraperException(socket_strerror(socket_last_error($this->socket)));\n        }\n    }\n\n    protected function generateTransactionId()\n    {\n        $this->transactionId = mt_rand(0, 65535);\n    }\n\n    protected function startTransaction()\n    {\n        $this->generateTransactionId();\n        $packet = static::CONNECTION_ID . pack('N', static::ACTION_CONNECT) . pack('N', $this->transactionId);\n        $res = $this->request($packet, 16);\n        if (strlen($res) < 1) {\n            throw new UdpScraperException('No connection response.');\n        }\n        if (strlen($res) < 16) {\n            throw new UdpScraperException('Too short connection response.');\n        }\n        $resUnpacked = unpack(\"Naction/Ntransid\", $res);\n\n        if ($resUnpacked['action'] != static::ACTION_CONNECT || $resUnpacked['transid'] != $this->transactionId) {\n            throw new UdpScraperException('Invalid connection response.');\n        }\n\n        $this->currentConnectionId = substr($res, 8, 8);\n    }\n\n    protected function scrapeHashes($hashes)\n    {\n        $hashString = '';\n        foreach ($hashes as $hash) {\n            $hashString .= pack('H*', $hash);\n        }\n\n        $packet = $this->currentConnectionId . pack(\"N\", static::ACTION_SCRAPE) . pack(\"N\", $this->transactionId) . $hashString;\n\n        $readLength = 8 + (12 * count($hashes));\n\n        $res = $this->request($packet, $readLength);\n\n        if (strlen($res) < 1) {\n            throw new UdpScraperException('No scrape response.');\n        }\n        if (strlen($res) < 8) {\n            throw new UdpScraperException('Too short scrape response.');\n        }\n\n        $resUnpacked = unpack(\"Naction/Ntransid\", $res);\n\n        if ($resUnpacked['action'] == static::ACTION_ERROR) {\n            $this->checkError($res);\n        }\n\n        if (strlen($res) < $readLength) {\n            throw new UdpScraperException('Too short scrape response.');\n        }\n\n        $torrents = [];\n        $index = 8;\n        foreach ($hashes as $hash) {\n            $resUnpacked = unpack(\"Ncomplete/Ndownloaded/Nincomplete\", substr($res, $index, 12));\n            $torrents[$hash] = $resUnpacked;\n            $index = $index + 12;\n        }\n        return $torrents;\n    }\n\n    protected function request($packet, $readLength)\n    {\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n\n        if (socket_write($this->socket, $packet, strlen($packet)) === false) {\n            throw new UdpScraperException(socket_strerror(socket_last_error($this->socket)));\n        }\n\n        $res = socket_read($this->socket, $readLength, PHP_BINARY_READ);\n        return $res;\n    }\n\n    protected function closeSocket()\n    {\n        if ($this->socket) {\n            socket_close($this->socket);\n            $this->socket = null;\n            $this->transactionId = null;\n            $this->currentConnectionId = null;\n        }\n    }\n\n    protected function checkError($response)\n    {\n        $unpacked = unpack(\"Naction/Ntransid/H*error\", $response);\n        throw new UdpScraperException($unpacked['error']);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 137,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nclass UdpScraper\n{\n    private $currentConnectionId;\n    private $transactionId;\n    private $socket;\n    private $timeout = 5;\n\n    public function scrape(Tracker $tracker, array $hashes)\n    {\n        $results = [];\n        $chunks = array_chunk($hashes, 74);\n        foreach ($chunks as $chunk) {\n            $results = array_merge($results, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $results;\n    }\n\n    private function scrapeChunk(Tracker $tracker, array $hashes)\n    {\n        $this->initSocket();\n        $this->connect($tracker->domain, $tracker->port);\n        $this->startTransaction();\n        $results = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $results;\n    }\n\n\n    private function initSocket()\n    {\n        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, array('sec' => $this->timeout, 'usec' => 0));\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, array('sec' => $this->timeout, 'usec' => 0));\n        return $this->socket;\n    }\n\n    private function connect($domain, $port)\n    {\n        socket_connect($this->socket, $domain, $port);\n    }\n\n    private function generateTransactionId()\n    {\n        $this->transactionId = random_int(0, PHP_INT_MAX);\n    }\n\n    private function startTransaction()\n    {\n        $this->generateTransactionId();\n        $connectionRequest = pack(\"NN\", 0x41727101, $this->transactionId);\n        $response = $this->request($connectionRequest, 16);\n        $this->currentConnectionId = substr($response, 8, 8);\n    }\n\n    private function scrapeHashes(array $hashes)\n    {\n        $this->generateTransactionId();\n        $packet = pack(\"NN\", 0x80000002, $this->transactionId) . $this->currentConnectionId;\n        foreach ($hashes as $hash) {\n            $packet .= $hash;\n        }\n\n        $response = $this->request($packet, 8 + 12 * count($hashes));\n        $results = [];\n        for ($i = 0; $i < count($hashes); $i++) {\n            $offset = 8 + $i * 12;\n            $seeds = unpack(\"N\", substr($response, $offset, 4))[1];\n            $completed = unpack(\"N\", substr($response, $offset + 4, 4))[1];\n            $leechers = unpack(\"N\", substr($response, $offset + 8, 4))[1];\n            $results[$hashes[$i]] = ['seeds' => $seeds, 'completed' => $completed, 'leechers' => $leechers];\n        }\n        return $results;\n    }\n\n\n    private function request($packet, $readLength)\n    {\n        socket_send($this->socket, $packet, strlen($packet), 0);\n        socket_recv($this->socket, $response, $readLength, 0);\n        return $response;\n    }\n\n    private function closeSocket()\n    {\n        socket_close($this->socket);\n        $this->socket = null;\n        $this->currentConnectionId = null;\n    }\n\n    private function checkError($response)\n    {\n        if (substr($response, 0, 4) === pack('N', 0x00000003)) {\n            throw new Exception('Tracker error: ' . substr($response, 8));\n        }\n    }\n}\n\nclass Tracker {\n    public $domain;\n    public $port;\n\n    public function __construct($domain, $port) {\n        $this->domain = $domain;\n        $this->port = $port;\n    }\n}\n",
      "<?php\n\nclass UdpScraper\n{\n    private $currentConnectionId;\n    private $transactionId;\n    private $socket;\n    private $timeout = 5;\n\n    public function scrape(Tracker $tracker, array $hashes)\n    {\n        $results = [];\n        $chunks = array_chunk($hashes, 74);\n        foreach ($chunks as $chunk) {\n            $results = array_merge($results, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $results;\n    }\n\n    private function scrapeChunk(Tracker $tracker, array $hashes)\n    {\n        $this->initSocket();\n        $this->connect($tracker->domain, $tracker->port);\n        $this->startTransaction();\n        $results = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $results;\n    }\n\n\n    private function initSocket()\n    {\n        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n        return $this->socket;\n    }\n\n    private function connect($domain, $port)\n    {\n        socket_connect($this->socket, $domain, $port);\n    }\n\n    private function generateTransactionId()\n    {\n        $this->transactionId = random_int(0, PHP_INT_MAX);\n    }\n\n    private function startTransaction()\n    {\n        $this->generateTransactionId();\n        $connectionRequest = pack(\"N\", 0x41727101) . pack(\"N\", $this->transactionId);\n        $response = $this->request($connectionRequest, 16);\n        $this->currentConnectionId = substr($response, 4, 8);\n    }\n\n    private function scrapeHashes(array $hashes)\n    {\n        $this->generateTransactionId();\n        $scrapeRequest = $this->currentConnectionId . pack(\"N\", 2) . pack(\"N\", $this->transactionId);\n        foreach ($hashes as $hash) {\n            $scrapeRequest .= $hash;\n        }\n\n        $response = $this->request($scrapeRequest, 8 + (12 * count($hashes)));\n        $results = [];\n        for ($i = 0; $i < count($hashes); $i++) {\n            $offset = 8 + ($i * 12);\n            $seeds = unpack(\"N\", substr($response, $offset, 4))[1];\n            $completed = unpack(\"N\", substr($response, $offset + 4, 4))[1];\n            $leechers = unpack(\"N\", substr($response, $offset + 8, 4))[1];\n            $results[$hashes[$i]] = ['seeds' => $seeds, 'completed' => $completed, 'leechers' => $leechers];\n        }\n        return $results;\n    }\n\n\n    private function request($packet, $readLength)\n    {\n        socket_send($this->socket, $packet, strlen($packet), 0);\n        socket_recv($this->socket, $response, $readLength, 0);\n        return $response;\n    }\n\n    private function closeSocket()\n    {\n        socket_close($this->socket);\n        $this->socket = null;\n        $this->currentConnectionId = null;\n    }\n\n    private function checkError($response)\n    {\n        if (strlen($response) < 8) {\n            throw new Exception(\"Invalid tracker response.\");\n        }\n        $action = unpack(\"N\", substr($response, 0, 4))[1];\n        if ($action == 3) {\n            $error = substr($response, 8);\n            throw new Exception(\"Tracker error: \" . $error);\n        }\n    }\n}\n\nclass Tracker {\n    public $domain;\n    public $port;\n\n    public function __construct($domain, $port) {\n        $this->domain = $domain;\n        $this->port = $port;\n    }\n}\n",
      "<?php\n\nclass UdpScraper\n{\n    private $currentConnectionId;\n    private $transactionId;\n    private $socket;\n    private $timeout = 5;\n\n    public function scrape(Tracker $tracker, array $hashes)\n    {\n        $results = [];\n        $chunks = array_chunk($hashes, 74);\n        foreach ($chunks as $chunk) {\n            $results = array_merge($results, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $results;\n    }\n\n    private function scrapeChunk(Tracker $tracker, array $hashes)\n    {\n        $this->initSocket();\n        $this->connect($tracker->domain, $tracker->port);\n        $this->startTransaction();\n        $results = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $results;\n    }\n\n\n    private function initSocket()\n    {\n        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, array('sec' => $this->timeout, 'usec' => 0));\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, array('sec' => $this->timeout, 'usec' => 0));\n        return $this->socket;\n    }\n\n    private function connect($domain, $port)\n    {\n        socket_connect($this->socket, $domain, $port);\n    }\n\n    private function generateTransactionId()\n    {\n        $this->transactionId = random_int(0, PHP_INT_MAX);\n    }\n\n    private function startTransaction()\n    {\n        $this->generateTransactionId();\n        $connectionRequest = pack(\"NN\", 0x41727101, $this->transactionId);\n        $response = $this->request($connectionRequest, 16);\n        $this->currentConnectionId = substr($response, 8, 8);\n    }\n\n    private function scrapeHashes(array $hashes)\n    {\n        $this->generateTransactionId();\n        $packet = pack(\"NN\", 0x80000002, $this->transactionId) . $this->currentConnectionId;\n        foreach ($hashes as $hash) {\n            $packet .= $hash;\n        }\n        $response = $this->request($packet, 8 + (12 * count($hashes)));\n        $results = [];\n        for ($i = 0; $i < count($hashes); $i++) {\n            $offset = 8 + ($i * 12);\n            $seeds = unpack(\"N\", substr($response, $offset, 4))[1];\n            $completed = unpack(\"N\", substr($response, $offset + 4, 4))[1];\n            $leechers = unpack(\"N\", substr($response, $offset + 8, 4))[1];\n            $results[$hashes[$i]] = ['seeds' => $seeds, 'completed' => $completed, 'leechers' => $leechers];\n        }\n        return $results;\n    }\n\n    private function request($packet, $readLength)\n    {\n        socket_send($this->socket, $packet, strlen($packet), 0);\n        socket_recv($this->socket, $response, $readLength, 0);\n        return $response;\n    }\n\n    private function closeSocket()\n    {\n        socket_close($this->socket);\n        $this->socket = null;\n        $this->currentConnectionId = null;\n    }\n\n    private function checkError($response)\n    {\n        if (substr($response, 0, 4) === pack('N', 0x80000003)) {\n            throw new Exception('Tracker error: ' . substr($response, 8));\n        }\n    }\n}\n\nclass Tracker {\n    public $domain;\n    public $port;\n\n    public function __construct($domain, $port) {\n        $this->domain = $domain;\n        $this->port = $port;\n    }\n}\n",
      "<?php\n\nclass UdpScraper\n{\n    private $currentConnectionId;\n    private $transactionId;\n    private $socket;\n    private $timeout = 5;\n\n    public function scrape(Tracker $tracker, array $hashes)\n    {\n        $results = [];\n        $chunks = array_chunk($hashes, 74);\n        foreach ($chunks as $chunk) {\n            $results = array_merge($results, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $results;\n    }\n\n    private function scrapeChunk(Tracker $tracker, array $hashes)\n    {\n        $this->initSocket();\n        $this->connect($tracker->domain, $tracker->port);\n        $this->startTransaction();\n        $results = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $results;\n    }\n\n\n    private function initSocket()\n    {\n        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n        return $this->socket;\n    }\n\n    private function connect($domain, $port)\n    {\n        socket_connect($this->socket, $domain, $port);\n    }\n\n    private function generateTransactionId()\n    {\n        $this->transactionId = random_int(0, PHP_INT_MAX);\n    }\n\n    private function startTransaction()\n    {\n        $this->generateTransactionId();\n        $connectionRequest = pack(\"NN\", 0x41727101, $this->transactionId);\n        $response = $this->request($connectionRequest, 16);\n        $this->currentConnectionId = substr($response, 8, 8);\n    }\n\n    private function scrapeHashes(array $hashes)\n    {\n        $this->generateTransactionId();\n        $packet = pack(\"NN\", 0x80000000 | 2, $this->transactionId) . $this->currentConnectionId;\n        foreach ($hashes as $hash) {\n            $packet .= $hash;\n        }\n\n        $response = $this->request($packet, 8 + 12 * count($hashes));\n        $results = [];\n        for ($i = 0; $i < count($hashes); $i++) {\n            $offset = 8 + $i * 12;\n            $seeds = unpack(\"N\", substr($response, $offset, 4))[1];\n            $completed = unpack(\"N\", substr($response, $offset + 4, 4))[1];\n            $leechers = unpack(\"N\", substr($response, $offset + 8, 4))[1];\n            $results[$hashes[$i]] = ['seeds' => $seeds, 'completed' => $completed, 'leechers' => $leechers];\n        }\n        return $results;\n    }\n\n\n    private function request($packet, $readLength)\n    {\n        socket_send($this->socket, $packet, strlen($packet), 0);\n        socket_recv($this->socket, $response, $readLength, 0);\n        return $response;\n    }\n\n    private function closeSocket()\n    {\n        socket_close($this->socket);\n        $this->socket = null;\n        $this->currentConnectionId = null;\n    }\n\n    private function checkError($response)\n    {\n        if (substr($response, 0, 4) === pack(\"N\", 3)) {\n            throw new Exception(\"Tracker error: \" . substr($response, 8));\n        }\n    }\n}\n\nclass Tracker {\n    public $domain;\n    public $port;\n\n    public function __construct($domain, $port) {\n        $this->domain = $domain;\n        $this->port = $port;\n    }\n}\n",
      "<?php\n\nclass UdpScraper\n{\n    private $currentConnectionId;\n    private $transactionId;\n    private $socket;\n    private int $timeout = 5;\n\n    public function scrape(Tracker $tracker, array $hashes): array\n    {\n        $results = [];\n        $chunks = array_chunk($hashes, 74);\n        foreach ($chunks as $chunk) {\n            $results = array_merge($results, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $results;\n    }\n\n    private function scrapeChunk(Tracker $tracker, array $hashes): array\n    {\n        $this->initSocket();\n        $this->connect($tracker->domain, $tracker->port);\n        $this->startTransaction();\n        $results = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $results;\n    }\n\n\n    private function initSocket()\n    {\n        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n    }\n\n    private function connect(string $domain, int $port): void\n    {\n        socket_connect($this->socket, $domain, $port);\n    }\n\n    private function generateTransactionId(): void\n    {\n        $this->transactionId = random_int(0, PHP_INT_MAX);\n    }\n\n    private function startTransaction(): void\n    {\n        $this->generateTransactionId();\n        $connectionRequest = pack('qN', 0x41727101980, 0);\n        $connectionResponse = $this->request($connectionRequest, 16);\n        $this->currentConnectionId = substr($connectionResponse, 8, 8);\n    }\n\n    private function scrapeHashes(array $hashes): array\n    {\n        $packet = pack('qN', $this->currentConnectionId, 2) . pack('N', $this->transactionId);\n        foreach ($hashes as $hash) {\n            $packet .= $hash;\n        }\n        $response = $this->request($packet, 8 + (12 * count($hashes)));\n        $results = [];\n        for ($i = 0; $i < count($hashes); $i++) {\n            $offset = 8 + ($i * 12);\n            $seeds = unpack('N', substr($response, $offset, 4))[1];\n            $completed = unpack('N', substr($response, $offset + 4, 4))[1];\n            $leechers = unpack('N', substr($response, $offset + 8, 4))[1];\n            $results[$hashes[$i]] = ['seeds' => $seeds, 'completed' => $completed, 'leechers' => $leechers];\n        }\n        return $results;\n    }\n\n\n    private function request(string $packet, int $readLength): string\n    {\n        socket_send($this->socket, $packet, strlen($packet), 0);\n        socket_recv($this->socket, $response, $readLength, 0);\n        $this->checkError($response);\n        return $response;\n    }\n\n    private function closeSocket(): void\n    {\n        socket_close($this->socket);\n        $this->socket = null;\n        $this->currentConnectionId = null;\n    }\n\n    private function checkError(string $response): void\n    {\n        if (strlen($response) >= 8 && unpack('N', substr($response, 0, 4))[1] == 3) {\n            throw new Exception('Tracker error: ' . substr($response, 8));\n        }\n    }\n}\n\nclass Tracker {\n    public string $domain;\n    public int $port;\n\n    public function __construct(string $domain, int $port)\n    {\n        $this->domain = $domain;\n        $this->port = $port;\n    }\n}\n",
      "<?php\n\nclass UdpScraper\n{\n    private $currentConnectionId;\n    private $transactionId;\n    private $socket;\n    private int $timeout = 5;\n\n    public function scrape(Tracker $tracker, array $hashes): array\n    {\n        $results = [];\n        $chunks = array_chunk($hashes, 74);\n        foreach ($chunks as $chunk) {\n            $results = array_merge($results, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $results;\n    }\n\n    private function scrapeChunk(Tracker $tracker, array $hashes): array\n    {\n        $this->initSocket();\n        $this->connect($tracker->domain, $tracker->port);\n        $this->startTransaction();\n        $results = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $results;\n    }\n\n\n    private function initSocket()\n    {\n        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n    }\n\n    private function connect(string $domain, int $port): void\n    {\n        socket_connect($this->socket, $domain, $port);\n    }\n\n    private function generateTransactionId(): void\n    {\n        $this->transactionId = random_int(0, PHP_INT_MAX);\n    }\n\n    private function startTransaction(): void\n    {\n        $this->generateTransactionId();\n        $connectionRequest = pack('QNN', 0x41727101980, 0, $this->transactionId);\n        $response = $this->request($connectionRequest, 16);\n        $this->currentConnectionId = unpack('Q', substr($response, 8, 8))[1];\n    }\n\n    private function scrapeHashes(array $hashes): array\n    {\n        $packet = pack('QNN', $this->currentConnectionId, 2, $this->transactionId);\n        foreach ($hashes as $hash) {\n            $packet .= pack('H*', $hash);\n        }\n\n        $response = $this->request($packet, 8 + 12 * count($hashes));\n        $results = [];\n        for ($i = 0; $i < count($hashes); $i++) {\n            $offset = 8 + $i * 12;\n            $data = unpack('Nseeders/Ncompleted/Nleechers', substr($response, $offset, 12));\n            $results[$hashes[$i]] = $data;\n        }\n        return $results;\n    }\n\n\n    private function request(string $packet, int $readLength): string\n    {\n        socket_send($this->socket, $packet, strlen($packet), 0);\n        socket_recv($this->socket, $response, $readLength, 0);\n        return $response;\n    }\n\n    private function closeSocket(): void\n    {\n        socket_close($this->socket);\n        $this->socket = null;\n        $this->currentConnectionId = null;\n    }\n\n    private function checkError(string $response): void\n    {\n        if (unpack('N', substr($response, 0, 4))[1] == 3) {\n            throw new Exception('Tracker error: ' . substr($response, 8));\n        }\n    }\n}\n\nclass Tracker {\n    public string $domain;\n    public int $port;\n\n    public function __construct(string $domain, int $port)\n    {\n        $this->domain = $domain;\n        $this->port = $port;\n    }\n}\n",
      "<?php\n\nclass UdpScraper\n{\n    private $currentConnectionId;\n    private $transactionId;\n    private $socket;\n    private int $timeout = 5;\n\n    public function scrape(Tracker $tracker, array $hashes): array\n    {\n        $results = [];\n        $chunks = array_chunk($hashes, 74);\n        foreach ($chunks as $chunk) {\n            $results = array_merge($results, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $results;\n    }\n\n    private function scrapeChunk(Tracker $tracker, array $hashes): array\n    {\n        $this->initSocket();\n        $this->connect($tracker->domain, $tracker->port);\n        $this->startTransaction();\n        $results = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $results;\n    }\n\n\n    private function initSocket()\n    {\n        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n    }\n\n    private function connect(string $domain, int $port): void\n    {\n        socket_connect($this->socket, $domain, $port);\n    }\n\n    private function generateTransactionId(): void\n    {\n        $this->transactionId = random_int(0, PHP_INT_MAX);\n    }\n\n    private function startTransaction(): void\n    {\n        $this->generateTransactionId();\n        $connectionRequest = pack(\"NN\", 0x41727101, $this->transactionId);\n        $response = $this->request($connectionRequest, 16);\n        $this->currentConnectionId = substr($response, 8, 8);\n    }\n\n    private function scrapeHashes(array $hashes): array\n    {\n        $packet = $this->currentConnectionId . pack(\"NN\", 2, $this->transactionId);\n        foreach ($hashes as $hash) {\n            $packet .= $hash;\n        }\n\n        $response = $this->request($packet, 8 + 12 * count($hashes));\n        $results = [];\n        for ($i = 0; $i < count($hashes); $i++) {\n            $offset = 8 + $i * 12;\n            $seeds = unpack(\"N\", substr($response, $offset, 4))[1];\n            $completed = unpack(\"N\", substr($response, $offset + 4, 4))[1];\n            $leechers = unpack(\"N\", substr($response, $offset + 8, 4))[1];\n            $results[$hashes[$i]] = ['seeds' => $seeds, 'completed' => $completed, 'leechers' => $leechers];\n        }\n        return $results;\n    }\n\n\n    private function request(string $packet, int $readLength): string\n    {\n        socket_send($this->socket, $packet, strlen($packet), 0);\n        socket_recv($this->socket, $response, $readLength, 0);\n        return $response;\n    }\n\n    private function closeSocket(): void\n    {\n        socket_close($this->socket);\n        $this->socket = null;\n        $this->currentConnectionId = null;\n    }\n\n    private function checkError(string $response): void\n    {\n        if (strlen($response) < 8) {\n            throw new Exception(\"Invalid tracker response.\");\n        }\n        $action = unpack(\"N\", substr($response, 0, 4))[1];\n        $transactionId = unpack(\"N\", substr($response, 4, 4))[1];\n\n        if ($transactionId != $this->transactionId) {\n            throw new Exception(\"Invalid transaction ID.\");\n        }\n\n        if ($action == 3) {\n            $error = substr($response, 8);\n            throw new Exception(\"Tracker error: \" . $error);\n        }\n    }\n}\n\nclass Tracker {\n    public string $domain;\n    public int $port;\n\n    public function __construct(string $domain, int $port) {\n        $this->domain = $domain;\n        $this->port = $port;\n    }\n}\n",
      "<?php\n\nclass UdpScraper\n{\n    private $currentConnectionId;\n    private $transactionId;\n    private $socket;\n    private int $timeout = 5;\n\n    public function scrape(Tracker $tracker, array $hashes): array\n    {\n        $results = [];\n        $chunks = array_chunk($hashes, 74);\n        foreach ($chunks as $chunk) {\n            $results = array_merge($results, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $results;\n    }\n\n    private function scrapeChunk(Tracker $tracker, array $hashes): array\n    {\n        $this->initSocket();\n        $this->connect($tracker->domain, $tracker->port);\n        $this->startTransaction();\n        $results = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $results;\n    }\n\n\n    private function initSocket()\n    {\n        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, array('sec' => $this->timeout, 'usec' => 0));\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, array('sec' => $this->timeout, 'usec' => 0));\n    }\n\n    private function connect(string $domain, int $port): void\n    {\n        socket_connect($this->socket, $domain, $port);\n    }\n\n    private function generateTransactionId(): void\n    {\n        $this->transactionId = random_int(0, PHP_INT_MAX);\n    }\n\n    private function startTransaction(): void\n    {\n        $this->generateTransactionId();\n        $connectionRequest = pack(\"NN\", 0x41727101, $this->transactionId);\n        $response = $this->request($connectionRequest, 16);\n        $this->currentConnectionId = substr($response, 8, 8);\n    }\n\n    private function scrapeHashes(array $hashes): array\n    {\n        $scrapeRequest = pack(\"NN\", 0x80000000, $this->transactionId) . $this->currentConnectionId;\n        foreach ($hashes as $hash) {\n            $scrapeRequest .= $hash;\n        }\n\n        $response = $this->request($scrapeRequest, 8 + (12 * count($hashes)));\n        $results = [];\n        for ($i = 0; $i < count($hashes); $i++) {\n            $offset = 8 + ($i * 12);\n            $seeds = unpack(\"N\", substr($response, $offset, 4))[1];\n            $completed = unpack(\"N\", substr($response, $offset + 4, 4))[1];\n            $leechers = unpack(\"N\", substr($response, $offset + 8, 4))[1];\n            $results[$hashes[$i]] = ['seeds' => $seeds, 'completed' => $completed, 'leechers' => $leechers];\n        }\n        return $results;\n    }\n\n\n    private function request(string $packet, int $readLength): string\n    {\n        socket_send($this->socket, $packet, strlen($packet), 0);\n        socket_recv($this->socket, $response, $readLength, 0);\n        return $response;\n    }\n\n    private function closeSocket(): void\n    {\n        socket_close($this->socket);\n        $this->socket = null;\n        $this->currentConnectionId = null;\n    }\n\n    private function checkError(string $response): void\n    {\n        if (substr($response, 0, 4) === pack('N', 0x00000003)) {\n            $errorMessage = substr($response, 8);\n            throw new Exception(\"Tracker error: \" . $errorMessage);\n        }\n    }\n}\n\nclass Tracker {\n    public string $domain;\n    public int $port;\n\n    public function __construct(string $domain, int $port)\n    {\n        $this->domain = $domain;\n        $this->port = $port;\n    }\n}\n",
      "<?php\n\nclass UdpScraper\n{\n    private $currentConnectionId;\n    private $transactionId;\n    private $socket;\n    private $timeout = 5;\n\n    public function scrape(Tracker $tracker, array $hashes)\n    {\n        $results = [];\n        $chunks = array_chunk($hashes, 74);\n        foreach ($chunks as $chunk) {\n            $results = array_merge($results, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $results;\n    }\n\n    private function scrapeChunk(Tracker $tracker, array $hashes)\n    {\n        $this->initSocket();\n        $this->connect($tracker->domain, $tracker->port);\n        $this->startTransaction();\n        $results = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $results;\n    }\n\n\n    private function initSocket()\n    {\n        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, array('sec' => $this->timeout, 'usec' => 0));\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, array('sec' => $this->timeout, 'usec' => 0));\n        return $this->socket;\n    }\n\n    private function connect($domain, $port)\n    {\n        socket_connect($this->socket, $domain, $port);\n    }\n\n    private function generateTransactionId()\n    {\n        $this->transactionId = random_int(0, PHP_INT_MAX);\n    }\n\n    private function startTransaction()\n    {\n        $this->generateTransactionId();\n        $connectionRequest = pack('Nnn', 0x41727101, 0, $this->transactionId);\n        $response = $this->request($connectionRequest, 16);\n        $responseData = unpack('Naction/NtransactionId/NconnectionId', $response);\n        if ($responseData['action'] !== 0 || $responseData['transactionId'] !== $this->transactionId) {\n            throw new Exception('Invalid connection response.');\n        }\n        $this->currentConnectionId = $responseData['connectionId'];\n    }\n\n    private function scrapeHashes(array $hashes)\n    {\n        $this->generateTransactionId();\n        $request = pack('Nnn', 0x80000000 | $this->currentConnectionId, 2, $this->transactionId);\n        foreach ($hashes as $hash) {\n            $request .= pack('H*', $hash);\n        }\n\n        $response = $this->request($request, 8 + (12 * count($hashes)));\n        $responseData = unpack('Naction/NtransactionId', $response);\n\n        if ($responseData['action'] !== 2 || $responseData['transactionId'] !== $this->transactionId) {\n            throw new Exception('Invalid scrape response.');\n        }\n\n        $results = [];\n        $response = substr($response, 8);\n        foreach ($hashes as $hash) {\n            $stats = unpack('Nseeds/Ncompleted/Nleechers', $response);\n            $results[$hash] = $stats;\n            $response = substr($response, 12);\n        }\n        return $results;\n    }\n\n\n    private function request(string $packet, int $readLength): string\n    {\n        socket_send($this->socket, $packet, strlen($packet), 0);\n        socket_recv($this->socket, $response, $readLength, 0);\n        return $response;\n    }\n\n    private function closeSocket()\n    {\n        socket_close($this->socket);\n        $this->socket = null;\n        $this->currentConnectionId = null;\n    }\n}\n\nclass Tracker {\n    public $domain;\n    public $port;\n\n    public function __construct($domain, $port) {\n        $this->domain = $domain;\n        $this->port = $port;\n    }\n}\n",
      "<?php\n\nclass UdpScraper\n{\n    private $currentConnectionId;\n    private $transactionId;\n    private $socket;\n    private $timeout = 5;\n\n    public function scrape(Tracker $tracker, array $hashes)\n    {\n        $results = [];\n        $chunks = array_chunk($hashes, 74);\n        foreach ($chunks as $chunk) {\n            $results = array_merge($results, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $results;\n    }\n\n    private function scrapeChunk(Tracker $tracker, array $hashes)\n    {\n        $this->initSocket();\n        $this->connect($tracker->domain, $tracker->port);\n        $this->startTransaction();\n        $results = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $results;\n    }\n\n\n    private function initSocket()\n    {\n        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, array('sec' => $this->timeout, 'usec' => 0));\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, array('sec' => $this->timeout, 'usec' => 0));\n        return $this->socket;\n    }\n\n    private function connect($domain, $port)\n    {\n        socket_connect($this->socket, $domain, $port);\n    }\n\n    private function generateTransactionId()\n    {\n        $this->transactionId = random_int(0, PHP_INT_MAX);\n    }\n\n    private function startTransaction()\n    {\n        $this->generateTransactionId();\n        $connectionRequest = pack(\"N\", 0x41727101) . pack(\"N\", $this->transactionId);\n        $response = $this->request($connectionRequest, 16);\n        $this->currentConnectionId = substr($response, 4, 8);\n    }\n\n    private function scrapeHashes(array $hashes)\n    {\n        $this->generateTransactionId();\n        $scrapeRequest = $this->currentConnectionId . pack(\"N\", 2) . pack(\"N\", $this->transactionId);\n        foreach ($hashes as $hash) {\n            $scrapeRequest .= $hash;\n        }\n        $response = $this->request($scrapeRequest, 8 + (12 * count($hashes)));\n        $results = [];\n        for ($i = 0; $i < count($hashes); $i++) {\n            $offset = 8 + ($i * 12);\n            $seeds = unpack(\"N\", substr($response, $offset, 4))[1];\n            $completed = unpack(\"N\", substr($response, $offset + 4, 4))[1];\n            $leechers = unpack(\"N\", substr($response, $offset + 8, 4))[1];\n            $results[$hashes[$i]] = ['seeds' => $seeds, 'completed' => $completed, 'leechers' => $leechers];\n        }\n        return $results;\n    }\n\n\n    private function request(string $packet, int $readLength)\n    {\n        socket_send($this->socket, $packet, strlen($packet), 0);\n        socket_recv($this->socket, $response, $readLength, 0);\n        return $response;\n    }\n\n    private function closeSocket()\n    {\n        socket_close($this->socket);\n        $this->socket = null;\n        $this->currentConnectionId = null;\n    }\n\n    private function checkError(string $response)\n    {\n        if (strlen($response) >= 8 && unpack(\"N\", substr($response, 0, 4))[1] == 3) {\n            throw new Exception(\"Tracker error: \" . substr($response, 8));\n        }\n    }\n}\n\nclass Tracker {\n    public function __construct(public string $domain, public int $port){}\n}\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 131,
    "Instruction": "Task Description: Create a PHP function that implements a basic TCP socket server capable of handling client connections, executing commands, and managing directory changes.\n\nFunction Description: The function starts a TCP socket server on a specified port, accepts client connections, and provides an interactive shell-like interface. It handles 'cd' commands for directory navigation, 'exit'/'quit' commands for termination, and executes other system commands. The server sends command outputs and current working directory information back to the client.\n\nInput:\n- $port: integer - The port number to bind the server socket to\n- $wpxf_disabled: array - List of disabled functions/callables\n- $wpxf_exec: callable - Function to execute system commands\n\nOutput: None (The function runs indefinitely until the client disconnects or sends an exit command)",
    "Canonical_solution": "function start_socket_server($port, $wpxf_disabled, $wpxf_exec)\n{\n    $scl = 'socket_create_listen';\n    if (is_callable($scl) && !in_array($scl, $wpxf_disabled)) {\n        $sock = @$scl($port);\n    } else {\n        $sock = @socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n        $ret = @socket_bind($sock, 0, $port);\n        $ret = @socket_listen($sock, 5);\n    }\n\n    $msg_sock = @socket_accept($sock);\n    @socket_close($sock);\n\n    $output = getcwd() . ' > ';\n    @socket_write($msg_sock, $output, strlen($output));\n\n    while (false !== @socket_select($r = array($msg_sock), $w = null, $e = null, null)) {\n        $output = '';\n        $cmd = @socket_read($msg_sock, 2048, PHP_NORMAL_READ);\n\n        if (false === $cmd) {\n            break;\n        }\n        if (substr($cmd, 0, 3) == 'cd ') {\n            chdir(substr($cmd, 3, -1));\n            $output = getcwd() . ' > ';\n        } elseif (substr($cmd, 0, 4) == 'quit' || substr($cmd, 0, 4) == 'exit') {\n            break;\n        } else {\n            if (false === strpos(strtolower(PHP_OS), 'win')) {\n                $cmd = rtrim($cmd) . ' 2>&1';\n            }\n\n            $output = $wpxf_exec($cmd);\n            $output .= getcwd() . ' > ';\n        }\n\n        @socket_write($msg_sock, $output, strlen($output));\n    }\n\n    @socket_close($msg_sock);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 136,
    "matched_results": [
      "```php\n<?php\nfunction tcp_server($port, $wpxf_disabled, $wpxf_exec) {\n    set_time_limit(0);\n    $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n    socket_bind($socket, '0.0.0.0', $port);\n    socket_listen($socket);\n    $client = socket_accept($socket);\n    $cwd = getcwd();\n    socket_write($client, \"Connected. Current directory: {$cwd}\\n\");\n    while (true) {\n        socket_write($client, \"{$cwd} $ \");\n        $command = trim(socket_read($client, 1024));\n        if ($command === 'exit' || $command === 'quit') {\n            break;\n        }\n        if (strpos($command, 'cd ') === 0) {\n            $new_dir = substr($command, 3);\n            if (chdir($new_dir)) {\n                $cwd = getcwd();\n                socket_write($client, \"Changed directory to {$cwd}\\n\");\n            } else {\n                socket_write($client, \"Error: No such directory\\n\");\n            }\n        } else {\n            $output = call_user_func($wpxf_exec, $command);\n            socket_write($client, $output);\n        }\n    }\n    socket_close($client);\n    socket_close($socket);\n}\n?>\n```",
      "```php\n<?php\nfunction tcp_server($port, $wpxf_disabled, $wpxf_exec) {\n    set_time_limit(0);\n    $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n    socket_bind($socket, '0.0.0.0', $port);\n    socket_listen($socket);\n    $client = socket_accept($socket);\n    $cwd = getcwd();\n    socket_write($client, \"Connected. Current directory: {$cwd}\\n\");\n    while (true) {\n        socket_write($client, \"{$cwd} $ \");\n        $command = trim(socket_read($client, 1024));\n        if ($command === 'exit' || $command === 'quit') {\n            break;\n        } elseif (strpos($command, 'cd ') === 0) {\n            $new_dir = substr($command, 3);\n            if (chdir($new_dir)) {\n                $cwd = getcwd();\n                socket_write($client, \"Changed directory to {$cwd}\\n\");\n            } else {\n                socket_write($client, \"Error: No such directory\\n\");\n            }\n        } else {\n            if (in_array($command, $wpxf_disabled)) {\n                socket_write($client, \"Error: Command disabled\\n\");\n            } else {\n                $output = $wpxf_exec($command);\n                socket_write($client, $output);\n            }\n        }\n    }\n    socket_close($client);\n    socket_close($socket);\n}\n\n?>\n```",
      "```php\n<?php\nfunction tcp_server($port, $wpxf_disabled, $wpxf_exec) {\n    set_time_limit(0);\n    $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n    socket_bind($socket, '0.0.0.0', $port);\n    socket_listen($socket);\n    $client = socket_accept($socket);\n    $cwd = getcwd();\n    socket_write($client, \"Connected. Current directory: {$cwd}\\n\");\n    while (true) {\n        socket_write($client, \"{$cwd} > \");\n        $command = trim(socket_read($client, 1024));\n        if ($command === 'exit' || $command === 'quit') {\n            break;\n        } elseif (strpos($command, 'cd ') === 0) {\n            $new_dir = substr($command, 3);\n            if (chdir($new_dir)) {\n                $cwd = getcwd();\n                socket_write($client, \"Changed directory to {$cwd}\\n\");\n            } else {\n                socket_write($client, \"Error: No such directory\\n\");\n            }\n        } else {\n            if (in_array($command, $wpxf_disabled)) {\n                socket_write($client, \"Error: Command disabled\\n\");\n            } else {\n                $output = $wpxf_exec($command);\n                socket_write($client, $output);\n            }\n        }\n    }\n    socket_close($client);\n    socket_close($socket);\n}\n?>\n```",
      "```php\n<?php\nfunction tcp_server($port, $wpxf_disabled, $wpxf_exec) {\n    set_time_limit(0);\n    $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n    socket_bind($socket, '0.0.0.0', $port);\n    socket_listen($socket);\n    $client = socket_accept($socket);\n    $cwd = getcwd();\n    socket_write($client, \"Connected. Current directory: {$cwd}\\n\");\n\n    while (true) {\n        socket_write($client, \"{$cwd} $ \");\n        $command = trim(socket_read($client, 1024));\n\n        if ($command === 'exit' || $command === 'quit') {\n            socket_write($client, \"Goodbye!\\n\");\n            break;\n        }\n\n        if (strpos($command, 'cd ') === 0) {\n            $new_dir = substr($command, 3);\n            if (chdir($new_dir)) {\n                $cwd = getcwd();\n                socket_write($client, \"Changed directory to: {$cwd}\\n\");\n            } else {\n                socket_write($client, \"Error: Invalid directory.\\n\");\n            }\n        } else {\n            $output = call_user_func($wpxf_exec, $command);\n            socket_write($client, $output);\n        }\n    }\n\n    socket_close($client);\n    socket_close($socket);\n}\n?>\n```",
      "```php\n<?php\nfunction tcp_server($port, $wpxf_disabled, $wpxf_exec) {\n    set_time_limit(0);\n    $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n    socket_bind($socket, '0.0.0.0', $port);\n    socket_listen($socket);\n    $client = socket_accept($socket);\n    $cwd = getcwd();\n    socket_write($client, \"Connected. Current directory: {$cwd}\\n\");\n    while (true) {\n        socket_write($client, \"{$cwd} > \");\n        $command = trim(socket_read($client, 1024));\n        if ($command === 'exit' || $command === 'quit') {\n            socket_write($client, \"Exiting...\\n\");\n            break;\n        }\n        if (strpos($command, 'cd ') === 0) {\n            $new_dir = substr($command, 3);\n            if (chdir($new_dir)) {\n                $cwd = getcwd();\n                socket_write($client, \"Changed directory to {$cwd}\\n\");\n            } else {\n                socket_write($client, \"Error: Invalid directory\\n\");\n            }\n        } else {\n            $output = call_user_func($wpxf_exec, $command);\n            socket_write($client, $output);\n        }\n    }\n    socket_close($client);\n    socket_close($socket);\n}\n?>\n```",
      "```php\n<?php\nfunction tcp_server($port, $wpxf_disabled, $wpxf_exec) {\n    set_time_limit(0);\n    $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n    socket_bind($socket, '0.0.0.0', $port);\n    socket_listen($socket);\n    $client = socket_accept($socket);\n    $cwd = getcwd();\n    socket_write($client, \"Current Directory: \" . $cwd . \"\\n\");\n    while (true) {\n        socket_write($client, \"$ \");\n        $command = trim(socket_read($client, 1024));\n        if ($command === 'exit' || $command === 'quit') {\n            break;\n        }\n        if (strpos($command, 'cd ') === 0) {\n            $dir = substr($command, 3);\n            if (chdir($dir)) {\n                $cwd = getcwd();\n                socket_write($client, \"Current Directory: \" . $cwd . \"\\n\");\n            } else {\n                socket_write($client, \"Error: Invalid directory.\\n\");\n            }\n        } else {\n            $output = call_user_func($wpxf_exec, $command);\n            socket_write($client, $output);\n        }\n    }\n    socket_close($client);\n    socket_close($socket);\n}\n?>\n```",
      "```php\n<?php\nfunction tcp_server($port, $wpxf_disabled, $wpxf_exec) {\n    set_time_limit(0);\n    $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n    socket_bind($socket, '0.0.0.0', $port);\n    socket_listen($socket);\n    $client = socket_accept($socket);\n    $cwd = getcwd();\n    socket_write($client, \"Connected. Current directory: {$cwd}\\n\");\n\n    while (true) {\n        socket_write($client, \"{$cwd} $ \");\n        $command = trim(socket_read($client, 1024));\n\n        if ($command === 'exit' || $command === 'quit') {\n            socket_write($client, \"Goodbye!\\n\");\n            break;\n        }\n\n        if (strpos($command, 'cd ') === 0) {\n            $new_dir = substr($command, 3);\n            if (chdir($new_dir)) {\n                $cwd = getcwd();\n                socket_write($client, \"Changed directory to {$cwd}\\n\");\n            } else {\n                socket_write($client, \"Error: No such directory\\n\");\n            }\n        } else {\n            $output = call_user_func($wpxf_exec, $command);\n            socket_write($client, $output);\n        }\n    }\n    socket_close($client);\n    socket_close($socket);\n}\n\n?>\n```",
      "```php\n<?php\nfunction tcp_server($port, $wpxf_disabled, $wpxf_exec) {\n    set_time_limit(0);\n    $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n    socket_bind($socket, '0.0.0.0', $port);\n    socket_listen($socket);\n    $client = socket_accept($socket);\n    $cwd = getcwd();\n    socket_write($client, \"Current Directory: \" . $cwd . \"\\n\");\n    while (true) {\n        socket_write($client, \"$ \");\n        $command = trim(socket_read($client, 1024));\n        if ($command === 'exit' || $command === 'quit') {\n            break;\n        } elseif (strpos($command, 'cd ') === 0) {\n            $new_dir = substr($command, 3);\n            if (chdir($new_dir)) {\n                $cwd = getcwd();\n                socket_write($client, \"Current Directory: \" . $cwd . \"\\n\");\n            } else {\n                socket_write($client, \"Error: Invalid directory.\\n\");\n            }\n        } else {\n            $output = call_user_func($wpxf_exec, $command);\n            socket_write($client, $output);\n        }\n    }\n    socket_close($client);\n    socket_close($socket);\n}\n?>\n```",
      "```php\n<?php\nfunction tcp_server($port, $wpxf_disabled, $wpxf_exec) {\n    set_time_limit(0);\n    $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n    socket_bind($socket, '0.0.0.0', $port);\n    socket_listen($socket);\n    $client = socket_accept($socket);\n    $cwd = getcwd();\n    socket_write($client, \"Connected. Current directory: {$cwd}\\n\");\n\n    while (true) {\n        socket_write($client, \"{$cwd} $ \");\n        $command = trim(socket_read($client, 1024));\n\n        if ($command === 'exit' || $command === 'quit') {\n            socket_write($client, \"Goodbye!\\n\");\n            break;\n        }\n\n        if (strpos($command, 'cd ') === 0) {\n            $new_dir = substr($command, 3);\n            if (chdir($new_dir)) {\n                $cwd = getcwd();\n                socket_write($client, \"Changed directory to {$cwd}\\n\");\n            } else {\n                socket_write($client, \"Error: No such directory\\n\");\n            }\n        } else {\n            $output = call_user_func($wpxf_exec, $command);\n            socket_write($client, $output);\n        }\n    }\n\n    socket_close($client);\n    socket_close($socket);\n}\n?>\n```",
      "```php\n<?php\nfunction tcp_server($port, $wpxf_disabled, $wpxf_exec) {\n    set_time_limit(0);\n    $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n    socket_bind($socket, '0.0.0.0', $port);\n    socket_listen($socket);\n    $client = socket_accept($socket);\n    $cwd = getcwd();\n    socket_write($client, \"Current Directory: \" . $cwd . \"\\n\");\n    while (true) {\n        $command = trim(socket_read($client, 1024));\n        if ($command === 'exit' || $command === 'quit') {\n            break;\n        } elseif (strpos($command, 'cd ') === 0) {\n            $new_dir = substr($command, 3);\n            if (chdir($new_dir)) {\n                $cwd = getcwd();\n                socket_write($client, \"Current Directory: \" . $cwd . \"\\n\");\n            } else {\n                socket_write($client, \"Error: Could not change directory to \" . $new_dir . \"\\n\");\n            }\n        } else {\n            $output = call_user_func($wpxf_exec, $command);\n            socket_write($client, $output);\n            socket_write($client, \"Current Directory: \" . $cwd . \"\\n\");\n        }\n    }\n    socket_close($client);\n    socket_close($socket);\n}\n?>\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a MySQL proxy class that handles communication between a client and MySQL server using Swoole's coroutine client for TCP/UDP communication, implementing authentication and packet handling.\n\nClass Description: MysqlProxy - A class that manages MySQL protocol communication between client and server, handling connection establishment, authentication, packet processing, and error handling.\n\nAttributes:\n\nisDuplex: [bool] - Indicates whether duplex communication is supported by Swoole version\nserver: [swoole_server] - Swoole server instance\nserverFd: [int] - File descriptor of the server connection\ncharset: [string] - Character set for MySQL communication\naccount: [array] - MySQL account credentials\nauth: [bool] - Authentication status flag\nchan: [Swoole\\Coroutine\\Channel] - Coroutine channel for communication\nserverPublicKey: [string] - Server's public key for authentication\nsalt: [array] - Salt used for password encryption\nconnected: [bool] - Connection status flag\ntimeout: [float] - Connection timeout value\nmysqlClient: [Swoole\\Coroutine\\Channel] - Channel for MySQL client communication\nmysqlServer: [HandshakePacket] - Server handshake information\nclient: [Swoole\\Coroutine\\Client] - Coroutine client instance\n\nMethods:\n\n__construct: [function](swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan) -> [void] - Initializes the proxy with server, file descriptor and channel\nconnect: [function](string $host, int $port, float $timeout = 0.1, int $tryStep = 0) -> [Client|bool] - Establishes connection to MySQL server with retry logic\nonClientReceive: [function](Swoole\\Coroutine\\Client $cli, string $data) -> [void] - Handles incoming data from MySQL server\nprocessAuth: [function](string $pluginName) -> [array] - Processes authentication based on plugin type\nsend: [function](...$data) -> [bool] - Sends data to MySQL server\nrecv: [function](&$remain) -> [mixed] - Receives data from MySQL server\nonClientClose: [function](Swoole\\Coroutine\\Client $cli) -> [void] - Handles client connection closure\nonClientError: [function](Swoole\\Coroutine\\Client $cli) -> [void] - Handles client errors",
    "Canonical_solution": "use Swoole\\Coroutine\\Client;\nuse SMProxy\\MysqlPacket\\AuthPacket;\nuse SMProxy\\MysqlPacket\\BinaryPacket;\nuse SMProxy\\MysqlPacket\\ErrorPacket;\nuse SMProxy\\MysqlPacket\\HandshakePacket;\nuse SMProxy\\MysqlPacket\\MySQLMessage;\nuse SMProxy\\MysqlPacket\\OkPacket;\nuse SMProxy\\MysqlPacket\\Util\\Capabilities;\nuse SMProxy\\MysqlPacket\\Util\\CharsetUtil;\nuse SMProxy\\MysqlPacket\\Util\\SecurityUtil;\nuse SMProxy\\MysqlPool\\MySQLException;\nuse SMProxy\\MysqlPool\\MySQLPool;\n\nclass MysqlProxy\n{\n    private $isDuplex;\n    public $server;\n    public $serverFd;\n    public $charset;\n    public $account;\n    public $auth = false;\n    public $chan;\n    public $serverPublicKey;\n    public $salt;\n    public $connected = false;\n    public $timeout = 0.1;\n    public $mysqlClient;\n    public $mysqlServer;\n    public $client;\n\n    public function __construct(\\swoole_server $server, int $fd, \\Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n        $this->client = new Client(CONFIG['server']['swoole_client_sock_setting']['sock_type'] ?? SWOOLE_SOCK_TCP);\n        $this->client->set(CONFIG['server']['swoole_client_setting'] ?? []);\n        $this->client->set(packageLengthSetting());\n        $this->isDuplex = version_compare(SWOOLE_VERSION, '4.2.13', '>=');\n        if (!$this->isDuplex) {\n            $this->mysqlClient = new Channel(1);\n        }\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3) {\n                $this->client->close();\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            } else {\n                $this->onClientError($this->client);\n                return false;\n            }\n        } else {\n            if (!$this->isDuplex) {\n                $this->mysqlClient->push($this->client);\n            }\n            self::go(function () {\n                $remain = '';\n                while (true) {\n                    $data = $this->recv($remain);\n                    if ($data === '' || $data === false) {\n                        break;\n                    }\n                }\n            });\n            return $this->client;\n        }\n    }\n\n    public function onClientReceive(\\Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        self::go(function () use ($cli, $data) {\n            $fd = $this->serverFd;\n            $binaryPacket = new BinaryPacket();\n            $binaryPacket->data = getBytes($data);\n            $binaryPacket->packetLength = $binaryPacket->calcPacketSize();\n            if (isset($binaryPacket->data[4])) {\n                $send = true;\n                if ($binaryPacket->data[4] == ErrorPacket::$FIELD_COUNT) {\n                    $errorPacket = new ErrorPacket();\n                    $errorPacket->read($binaryPacket);\n                    $data = getString($errorPacket->write());\n                } elseif (!$this->connected) {\n                    if ($binaryPacket->data[4] == OkPacket::$FIELD_COUNT) {\n                        $send = false;\n                        $this->connected = true;\n                        $this->chan->push($this);\n                    } elseif ($binaryPacket->data[4] == 0x01) {\n                        if ($binaryPacket->packetLength == 6) {\n                            if ($binaryPacket->data[$binaryPacket->packetLength - 1] == 4) {\n                                $data = getString(array_merge(getMysqlPackSize(1), [3, 2]));\n                                $this->send($data);\n                            }\n                        } else {\n                            $this->serverPublicKey = substr($data, 5, strlen($data) - 2);\n                            $encryptData = SecurityUtil::sha2RsaEncrypt($this->account['password'], $this->salt, $this->serverPublicKey);\n                            $data = getString(array_merge(getMysqlPackSize(strlen($encryptData)), [5])) . $encryptData;\n                            $this->send($data);\n                        }\n                        $send = false;\n                    } elseif ($binaryPacket->data[4] == 0xfe) {\n                        $mm = new MySQLMessage($binaryPacket->data);\n                        $mm->move(5);\n                        $pluginName = $mm->readStringWithNull();\n                        $this->salt = $mm->readBytesWithNull();\n                        $password = $this->processAuth($pluginName ?: 'mysql_native_password');\n                        $this->send(getString(array_merge(getMysqlPackSize(count($password)), [3], $password)));\n                        $send = false;\n                    } elseif (!$this->auth) {\n                        $handshakePacket = (new HandshakePacket())->read($binaryPacket);\n                        $this->mysqlServer = $handshakePacket;\n                        $this->salt = array_merge($handshakePacket->seed, $handshakePacket->restOfScrambleBuff);\n                        $password = $this->processAuth($handshakePacket->pluginName);\n                        $clientFlag = Capabilities::CLIENT_CAPABILITIES;\n                        $authPacket = new AuthPacket();\n                        $authPacket->pluginName = $handshakePacket->pluginName;\n                        $authPacket->packetId = 1;\n                        if (isset($this->database) && $this->database) {\n                            $authPacket->database = $this->database;\n                        } else {\n                            $authPacket->database = 0;\n                        }\n                        if ($authPacket->database) {\n                            $clientFlag |= Capabilities::CLIENT_CONNECT_WITH_DB;\n                        }\n                        if (version_compare($handshakePacket->serverVersion, '5.0', '>=')) {\n                            $clientFlag |= Capabilities::CLIENT_MULTI_RESULTS;\n                        }\n                        $authPacket->clientFlags = $clientFlag;\n                        $authPacket->serverCapabilities = $handshakePacket->serverCapabilities;\n                        $authPacket->maxPacketSize =\n                            CONFIG['server']['swoole_client_setting']['package_max_length'] ?? 16777215;\n                        $authPacket->charsetIndex = CharsetUtil::getIndex($this->charset ?? 'utf8mb4');\n                        $authPacket->user = $this->account['user'];\n                        $authPacket->password = $password;\n                        $this->auth = true;\n                        $this->send(getString($authPacket->write()));\n                        $send = false;\n                    }\n                }\n                if ($send && $this->server->exist($fd)) {\n                    $this->server->send($fd, $data);\n                }\n            }\n        });\n    }\n\n    public function processAuth(string $pluginName)\n    {\n        switch ($pluginName) {\n            case 'mysql_native_password':\n                $password = SecurityUtil::scramble411($this->account['password'], $this->salt);\n                break;\n            case 'caching_sha2_password':\n                $password = SecurityUtil::scrambleSha256($this->account['password'], $this->salt);\n                break;\n            case 'sha256_password':\n                throw new MySQLException('Sha256_password plugin is not supported yet');\n                break;\n            case 'mysql_old_password':\n                throw new MySQLException('mysql_old_password plugin is not supported yet');\n                break;\n            case 'mysql_clear_password':\n                $password = array_merge(getBytes($this->account['password']), [0]);\n                break;\n            default:\n                $password = SecurityUtil::scramble411($this->account['password'], $this->salt);\n                break;\n        }\n        return $password;\n    }\n\n    public function send(...$data)\n    {\n        if ($this->isDuplex) {\n            if ($this->client->isConnected()) {\n                return $this->client->send(...$data);\n            } else {\n                return false;\n            }\n        } else {\n            $client = self::coPop($this->mysqlClient);\n            if ($client === false) {\n                return false;\n            }\n            if ($client->isConnected()) {\n                $result = $client->send(...$data);\n                $this->mysqlClient->push($client);\n                return $result;\n            }\n            return false;\n        }\n    }\n\n    public function recv(&$remain)\n    {\n        if ($this->isDuplex) {\n            $client = $this->client;\n            $data = $client->recv(-1);\n        } else {\n            $client = self::coPop($this->mysqlClient, $this->timeout);\n            if ($client === false) {\n                return false;\n            }\n            if ($client->isConnected()) {\n                $data = $client->recv($this->timeout / 500);\n            } else {\n                $data = '';\n            }\n            $this->mysqlClient->push($client);\n            if ($data === false && $client->errCode == 110) {\n                $data = true;\n            }\n            if ($data === '' || $data === false) {\n                $this->mysqlClient->close();\n            }\n        }\n        if ($data === '' || $data === false) {\n            $this->onClientClose($client);\n        } elseif (is_string($data)) {\n            $this->onClientReceive($client, $data);\n        }\n        return $data;\n    }\n\n    public function onClientClose(\\Swoole\\Coroutine\\Client $cli)\n    {\n        MySQLPool::destruct($cli, $this->connName);\n    }\n\n    public function onClientError(\\Swoole\\Coroutine\\Client $cli)\n    {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 139,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nclass MysqlProxy\n{\n    public $isDuplex;\n    private $server;\n    private $serverFd;\n    private $charset = 'utf8mb4';\n    private $account = [];\n    private $auth = false;\n    private $chan;\n    private $serverPublicKey;\n    private $salt;\n    private $connected = false;\n    private $timeout;\n    private $mysqlClient;\n    private $mysqlServer;\n    private $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->isDuplex = method_exists($server, 'isDuplex');\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3) {\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            }\n            return false;\n        }\n        $this->connected = true;\n        return $this->client;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        if (!$this->auth) {\n            $this->mysqlServer = new HandshakePacket($data);\n            $this->salt = $this->mysqlServer->salt;\n            $this->serverPublicKey = $this->mysqlServer->serverPublicKey;\n            $authData = $this->processAuth($this->mysqlServer->pluginName);\n            $this->send($authData);\n            $this->auth = true;\n            return;\n        }\n        $this->chan->push(['data' => $data, 'from' => $this->serverFd]);\n    }\n\n\n    private function processAuth(string $pluginName)\n    {\n        $packet = new AuthPacket();\n        $packet->pluginName = $pluginName;\n        $packet->clientFlags = MysqlConstant::CLIENT_CAPABILITIES;\n        $packet->maxPacketSize = MysqlConstant::MAX_PACKET_SIZE;\n        $packet->charsetIndex = MysqlConstant::CHARSET_UTF8MB4;\n        $packet->user = $this->account['user'];\n        $packet->password = $this->account['password'];\n        $packet->database = $this->account['database'];\n\n        if ($pluginName === 'mysql_native_password') {\n            $packet->password = Authentication::nativePassword($packet->password, $this->salt);\n        } elseif ($pluginName === 'caching_sha2_password') {\n            $packet->password = Authentication::sha256Password($packet->password, $this->salt, $this->serverPublicKey);\n        }\n        return $packet->pack();\n    }\n\n    public function send(...$data)\n    {\n        if ($this->connected) {\n            return $this->client->send(implode('', $data));\n        }\n        return false;\n    }\n\n    public function recv(&$remain)\n    {\n        return PacketSplitter::split($this->client, $remain);\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'close', 'from' => $this->serverFd]);\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'error', 'from' => $this->serverFd]);\n    }\n\n    public function setAccount(array $account)\n    {\n        $this->account = $account;\n    }\n}\n\n\n// Placeholder classes for compilation\n\nclass HandshakePacket\n{\n    public $pluginName;\n    public $salt;\n    public $serverPublicKey;\n\n    public function __construct($data)\n    {\n        // Placeholder constructor\n    }\n}\n\nclass AuthPacket\n{\n    public $pluginName;\n    public $clientFlags;\n    public $maxPacketSize;\n    public $charsetIndex;\n    public $user;\n    public $password;\n    public $database;\n\n    public function pack()\n    {\n        // Placeholder pack method\n        return '';\n    }\n}\n\nclass MysqlConstant\n{\n    const CLIENT_CAPABILITIES = 0;\n    const MAX_PACKET_SIZE = 0;\n    const CHARSET_UTF8MB4 = 0;\n}\n\nclass Authentication\n{\n    public static function nativePassword($password, $salt)\n    {\n        // Placeholder nativePassword method\n        return '';\n    }\n\n    public static function sha256Password($password, $salt, $publicKey)\n    {\n        // Placeholder sha256Password method\n        return '';\n    }\n}\n\nclass PacketSplitter\n{\n    public static function split($client, &$remain)\n    {\n        // Placeholder split method\n        return '';\n    }\n}\n",
      "<?php\n\nclass MysqlProxy\n{\n    public $isDuplex;\n    private $server;\n    private $serverFd;\n    private $charset;\n    private $account;\n    private $auth = false;\n    private $chan;\n    private $serverPublicKey;\n    private $salt;\n    private $connected = false;\n    private $timeout;\n    private $mysqlClient;\n    private $mysqlServer;\n    private $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->isDuplex = method_exists($server, 'isDuplex');\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3) {\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            }\n            return false;\n        }\n        $this->connected = true;\n        return $this->client;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        if (!$this->auth) {\n            $this->mysqlServer = new HandshakePacket($data);\n            $this->salt = $this->mysqlServer->salt;\n            $this->serverPublicKey = $this->mysqlServer->serverPublicKey;\n            $this->charset = $this->account['charset'];\n            $authData = $this->processAuth($this->mysqlServer->pluginName);\n            $this->send($authData);\n            $this->auth = true;\n            return;\n        }\n        $this->chan->push(['data' => $data, 'from' => $this->serverFd]);\n    }\n\n    private function processAuth(string $pluginName)\n    {\n        $packet = new AuthPacket();\n        $packet->pluginName = $pluginName;\n        $packet->clientFlags = $this->mysqlServer->clientFlags;\n        $packet->maxPacketSize = $this->mysqlServer->maxPacketSize;\n        $packet->charsetIndex = $this->charset;\n        $packet->user = $this->account['user'];\n        $packet->database = $this->account['database'];\n\n        if ($pluginName === 'mysql_native_password') {\n            $password = $this->account['password'];\n            if ($password !== '') {\n                $hash = sha1($password, true);\n                $doubleHash = sha1($hash, true);\n                $packet->password = xor_strings($doubleHash, sha1($this->salt . $doubleHash, true));\n            }\n        }\n        return $packet->pack();\n    }\n\n\n    public function send(...$data)\n    {\n        if ($this->connected) {\n            return $this->client->send(implode('', $data));\n        }\n        return false;\n    }\n\n    public function recv(&$remain)\n    {\n        return $this->client->recv($this->timeout);\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'close', 'from' => $this->serverFd]);\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'error', 'from' => $this->serverFd]);\n    }\n\n    public function setAccount(array $account)\n    {\n        $this->account = $account;\n    }\n}\n\n// Helper functions (place these outside the class definition)\nfunction xor_strings($s1, $s2)\n{\n    $s1_len = strlen($s1);\n    $s2_len = strlen($s2);\n    $len = min($s1_len, $s2_len);\n    $result = '';\n    for ($i = 0; $i < $len; $i++) {\n        $result .= chr(ord($s1[$i]) ^ ord($s2[$i]));\n    }\n    return $result;\n}\n\n\nclass HandshakePacket\n{\n    // ... (Implementation for HandshakePacket)\n}\n\nclass AuthPacket\n{\n    // ... (Implementation for AuthPacket)\n}\n",
      "<?php\n\nclass MysqlProxy\n{\n    public $isDuplex;\n    private $server;\n    private $serverFd;\n    private $charset = 'utf8mb4';\n    private $account = [];\n    private $auth = false;\n    private $chan;\n    private $serverPublicKey;\n    private $salt;\n    private $connected = false;\n    private $timeout;\n    private $mysqlClient;\n    private $mysqlServer;\n    private $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->isDuplex = method_exists($server, 'isDuplex');\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3 && $this->client->errCode != 111) {\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            }\n            return false;\n        }\n        $this->connected = true;\n        return $this->client;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        if (!$this->auth) {\n            $this->mysqlServer = new HandshakePacket($data);\n            $this->salt = $this->mysqlServer->salt;\n            $this->serverPublicKey = $this->mysqlServer->serverPublicKey;\n            $authData = $this->processAuth($this->mysqlServer->pluginName);\n            $this->send($authData);\n        } else {\n            if ($this->isDuplex) {\n                $this->server->send($this->serverFd, $data);\n            } else {\n                $this->chan->push($data);\n            }\n        }\n    }\n\n    private function processAuth(string $pluginName)\n    {\n        $packet = new AuthPacket();\n        $packet->pluginName = $pluginName;\n        $packet->clientFlags = $this->mysqlServer->clientFlags;\n        $packet->maxPacketSize = $this->mysqlServer->maxPacketSize;\n        $packet->charsetIndex = $this->mysqlServer->charsetIndex;\n        $packet->user = $this->account['user'];\n        $packet->database = $this->account['database'];\n\n        if ($pluginName === 'mysql_native_password') {\n            $password = $this->account['password'];\n            if ($password !== '') {\n                $hash = sha1($password, true);\n                $packet->password = sha1($this->salt . sha1($hash, true), true) ^ $hash;\n            }\n        } elseif ($pluginName === 'caching_sha2_password') {\n            // Implement caching_sha2_password authentication if needed\n        }\n\n        return $packet->pack();\n    }\n\n\n    public function send(...$data)\n    {\n        return $this->client->send(implode('', $data));\n    }\n\n    public function recv(&$remain)\n    {\n        return $this->client->recv($this->timeout, $remain);\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->server->close($this->serverFd);\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->server->close($this->serverFd);\n    }\n}\n\n\nclass HandshakePacket\n{\n    // Implementation for HandshakePacket parsing\n}\n\nclass AuthPacket\n{\n    // Implementation for AuthPacket creation\n}\n",
      "<?php\n\nclass MysqlProxy\n{\n    public $isDuplex;\n    private $server;\n    private $serverFd;\n    private $charset;\n    private $account;\n    private $auth = false;\n    private $chan;\n    private $serverPublicKey;\n    private $salt;\n    private $connected = false;\n    private $timeout;\n    private $mysqlClient;\n    private $mysqlServer;\n    private $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->isDuplex = method_exists($server, 'send');\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3) {\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            }\n            return false;\n        }\n        $this->connected = true;\n        return $this->client;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        if (!$this->auth) {\n            $this->mysqlServer = new HandshakePacket($data);\n            $this->salt = $this->mysqlServer->salt;\n            $this->serverPublicKey = $this->mysqlServer->serverPublicKey;\n            $authData = $this->processAuth($this->mysqlServer->pluginName);\n            $this->send($authData);\n            $this->auth = true;\n            return;\n        }\n        $this->chan->push(['data' => $data, 'from' => $this->serverFd]);\n    }\n\n\n    private function processAuth(string $pluginName)\n    {\n        $packet = new AuthPacket();\n        $packet->pluginName = $pluginName;\n        $packet->clientFlags = Capabilities::CLIENT_PROTOCOL_41 | Capabilities::CLIENT_PLUGIN_AUTH | Capabilities::CLIENT_SECURE_CONNECTION | Capabilities::CLIENT_CONNECT_WITH_DB;\n        $packet->maxPacketSize = 4194304;\n        $packet->charsetNumber = $this->charset ? $this->charset : 33;\n        $packet->user = $this->account['user'];\n        $packet->database = $this->account['database'];\n\n        if ($pluginName === 'mysql_native_password') {\n            $packet->password = Authentication::nativePassword($this->account['password'], $this->salt);\n        } elseif ($pluginName === 'caching_sha2_password') {\n            $packet->password = Authentication::sha256Password($this->account['password'], $this->salt, $this->serverPublicKey);\n        }\n        return $packet->pack();\n    }\n\n    public function send(...$data)\n    {\n        return $this->client->send(implode('', $data));\n    }\n\n    public function recv(&$remain)\n    {\n        return PacketSplitter::split($this->client, $remain);\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'closed', 'from' => $this->serverFd]);\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'error', 'from' => $this->serverFd]);\n    }\n}\n",
      "<?php\n\nclass MysqlProxy\n{\n    public $isDuplex;\n    private $server;\n    private $serverFd;\n    private $charset = 'utf8mb4';\n    private $account = [];\n    private $auth = false;\n    private $chan;\n    private $serverPublicKey;\n    private $salt;\n    private $connected = false;\n    private $timeout;\n    private $mysqlClient;\n    private $mysqlServer;\n    private $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->isDuplex = method_exists($server, 'isDuplex');\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3) {\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            }\n            return false;\n        }\n        $this->connected = true;\n        return $this->client;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        if (!$this->auth) {\n            $this->mysqlServer = new HandshakePacket($data);\n            $this->salt = $this->mysqlServer->salt;\n            $this->serverPublicKey = $this->mysqlServer->serverPublicKey;\n            $authData = $this->processAuth($this->mysqlServer->pluginName);\n            $this->send($authData);\n        } else {\n            $this->chan->push(['data' => $data, 'from' => $this->serverFd]);\n        }\n    }\n\n\n    private function processAuth(string $pluginName)\n    {\n        $packet = new AuthPacket();\n        $packet->pluginName = $pluginName;\n        $packet->clientFlags = Capabilities::CLIENT_PROTOCOL_41 | Capabilities::CLIENT_PLUGIN_AUTH |\n            Capabilities::CLIENT_SECURE_CONNECTION | Capabilities::CLIENT_CONNECT_WITH_DB |\n            Capabilities::CLIENT_DEPRECATE_EOF;\n        $packet->maxPacketSize = 4194304;\n        $packet->charsetNumber = CharacterSet::UTF8MB4_GENERAL_CI;\n        $packet->account = $this->account;\n        $packet->authData = Authentication::scramble411($this->account['password'], $this->salt, $this->serverPublicKey);\n        $packet->database = $this->account['database'];\n\n        return $packet->pack();\n    }\n\n\n    public function send(...$data)\n    {\n        if ($this->connected) {\n            return $this->client->send(implode('', $data));\n        }\n        return false;\n    }\n\n    public function recv(&$remain)\n    {\n        return PacketSplitter::split($this->client, $remain);\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'close', 'from' => $this->serverFd]);\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'error', 'from' => $this->serverFd]);\n    }\n}\n\n\n// Placeholder classes for HandshakePacket, AuthPacket, Capabilities, CharacterSet, Authentication, and PacketSplitter.\n// These would need to be fully implemented based on the MySQL protocol.\n\nclass HandshakePacket {}\nclass AuthPacket {}\nclass Capabilities {}\nclass CharacterSet {}\nclass Authentication {\n    public static function scramble411($password, $salt, $serverPublicKey) {}\n}\nclass PacketSplitter {\n    public static function split($client, &$remain) {}\n}\n",
      "<?php\n\nclass MysqlProxy\n{\n    public $isDuplex;\n    private $server;\n    private $serverFd;\n    private $charset;\n    private $account;\n    private $auth = false;\n    private $chan;\n    private $serverPublicKey;\n    private $salt;\n    private $connected = false;\n    private $timeout;\n    private $mysqlClient;\n    private $mysqlServer;\n    private $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->isDuplex = method_exists($server, 'isDuplex');\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3) {\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            }\n            return false;\n        }\n        $this->connected = true;\n        return $this->client;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        if (!$this->auth) {\n            $this->mysqlServer = new HandshakePacket($data);\n            $this->salt = $this->mysqlServer->salt;\n            $this->serverPublicKey = $this->mysqlServer->serverPublicKey;\n            $authData = $this->processAuth($this->mysqlServer->pluginName);\n            $this->send($authData);\n            $this->auth = true;\n            return;\n        }\n        $this->chan->push(['data' => $data, 'from' => $this->serverFd]);\n    }\n\n\n    private function processAuth(string $pluginName)\n    {\n        $packet = new AuthPacket();\n        $packet->pluginName = $pluginName;\n        $packet->clientFlags = $this->mysqlServer->clientFlags;\n        $packet->maxPacketSize = $this->mysqlServer->maxPacketSize;\n        $packet->charsetIndex = $this->charset ? $this->charset : $this->mysqlServer->charsetIndex;\n        $packet->user = $this->account['user'];\n        $packet->database = $this->account['database'];\n\n        if ($pluginName === 'mysql_native_password') {\n            $packet->password = authentication::scramble411($this->account['password'], $this->salt);\n        } elseif ($pluginName === 'caching_sha2_password') {\n            $packet->password = authentication::scrambleSha256($this->account['password'], $this->salt, $this->serverPublicKey);\n        }\n        return $packet->pack();\n    }\n\n    public function send(...$data)\n    {\n        if ($this->connected) {\n            return $this->client->send(implode('', $data));\n        }\n        return false;\n    }\n\n    public function recv(&$remain)\n    {\n        if ($this->connected) {\n            return $this->client->recv($this->timeout, $remain);\n        }\n        return false;\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'close', 'from' => $this->serverFd]);\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'error', 'from' => $this->serverFd]);\n    }\n\n    public function setAccount(array $account)\n    {\n        $this->account = $account;\n    }\n\n    public function setCharset(int $charset)\n    {\n        $this->charset = $charset;\n    }\n}\n\n\nclass HandshakePacket\n{\n    // Implementation for HandshakePacket\n}\n\nclass AuthPacket\n{\n    // Implementation for AuthPacket\n}\n\nnamespace authentication;\n\nfunction scramble411($password, $salt)\n{\n    // Implementation for scramble411\n}\n\nfunction scrambleSha256($password, $salt, $publicKey)\n{\n    // Implementation for scrambleSha256\n}\n",
      "<?php\n\nclass MysqlProxy\n{\n    public $isDuplex;\n    private $server;\n    private $serverFd;\n    private $charset = 'utf8mb4';\n    private $account = [];\n    private $auth = false;\n    private $chan;\n    private $serverPublicKey;\n    private $salt;\n    private $connected = false;\n    private $timeout;\n    private $mysqlClient;\n    private $mysqlServer;\n    private $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->isDuplex = method_exists($server, 'isDuplex');\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3 && $this->client->errCode != 111) {\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            }\n            return false;\n        }\n        $this->connected = true;\n        return $this->client;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        if (!$this->auth) {\n            $this->mysqlServer = new HandshakePacket($data);\n            $this->salt = $this->mysqlServer->salt;\n            $this->serverPublicKey = $this->mysqlServer->serverPublicKey;\n            $authData = $this->processAuth($this->mysqlServer->pluginName);\n            $this->send($authData);\n        } else {\n            $this->chan->push(['data' => $data, 'from' => $this->serverFd]);\n        }\n\n    }\n\n    private function processAuth(string $pluginName)\n    {\n        $packet = new AuthPacket();\n        $packet->pluginName = $pluginName;\n        $packet->clientFlags = Capabilities::CLIENT_PROTOCOL_41 | Capabilities::CLIENT_PLUGIN_AUTH |\n            Capabilities::CLIENT_SECURE_CONNECTION | Capabilities::CLIENT_CONNECT_WITH_DB |\n            Capabilities::CLIENT_DEPRECATE_EOF;\n        $packet->maxPacketSize = 4194304;\n        $packet->charsetNumber = CharacterSet::UTF8MB4_GENERAL_CI;\n        $packet->account = $this->account;\n        $packet->salt = $this->salt;\n\n        if ($pluginName === 'mysql_native_password') {\n            $packet->password = Authentication::nativePassword($this->account['password'], $this->salt);\n        } elseif ($pluginName === 'caching_sha2_password') {\n            $packet->password = Authentication::sha256Password($this->account['password'], $this->salt, $this->serverPublicKey);\n        }\n        return $packet->pack();\n    }\n\n\n    public function send(...$data)\n    {\n        return $this->client->send(implode('', $data));\n    }\n\n    public function recv(&$remain)\n    {\n        return PacketSplitter::split($this->client, $remain);\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['data' => null, 'from' => $this->serverFd]);\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['data' => null, 'from' => $this->serverFd]);\n    }\n}\n",
      "<?php\n\nclass MysqlProxy\n{\n    public $isDuplex;\n    private $server;\n    private $serverFd;\n    private $charset;\n    private $account;\n    private $auth = false;\n    private $chan;\n    private $serverPublicKey;\n    private $salt;\n    private $connected = false;\n    private $timeout;\n    private $mysqlClient;\n    private $mysqlServer;\n    private $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->isDuplex = method_exists($server, 'isDuplex');\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3) {\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            }\n            return false;\n        }\n        $this->connected = true;\n        $this->mysqlServer = (new HandshakePacket())->unpack($this->recv());\n        $this->salt = $this->mysqlServer->salt;\n        if ($this->isDuplex) {\n            go(function () {\n                while ($this->connected && $data = $this->client->recv(-1)) {\n                    $this->onClientReceive($this->client, $data);\n                }\n            });\n        }\n        return $this->client;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        $this->chan->push($data);\n    }\n\n\n    public function processAuth(string $pluginName)\n    {\n        switch ($pluginName) {\n            case 'mysql_native_password':\n                $authData = auth_plugin_mysql_native_password($this->account['password'], $this->salt);\n                break;\n\n            default:\n                throw new \\Exception(\"Unsupported plugin: {$pluginName}\");\n        }\n        return $authData;\n    }\n\n    public function send(...$data)\n    {\n        if ($this->connected) {\n            return $this->client->send(pack(...$data));\n        }\n        return false;\n    }\n\n    public function recv(&$remain = null)\n    {\n        if ($this->connected) {\n            return $this->client->recv($this->timeout);\n        }\n        return false;\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n    }\n}\n\nclass HandshakePacket\n{\n    public $salt;\n\n    public function unpack($data)\n    {\n        // Implementation for unpacking handshake packet\n        return $this;\n    }\n}\n\nfunction auth_plugin_mysql_native_password($password, $salt)\n{\n    // Implementation for mysql_native_password authentication\n    return [];\n}\n\n",
      "<?php\n\nclass MysqlProxy\n{\n    public $isDuplex;\n    private $server;\n    private $serverFd;\n    private $charset = 'utf8mb4';\n    private $account = [];\n    private $auth = false;\n    private $chan;\n    private $serverPublicKey;\n    private $salt;\n    private $connected = false;\n    private $timeout;\n    private $mysqlClient;\n    private $mysqlServer;\n    private $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->isDuplex = method_exists($server, 'isDuplex');\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3 && $this->client->errCode != 111) {\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            }\n            return false;\n        }\n        $this->connected = true;\n        return $this->client;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        if (!$this->auth) {\n            $this->mysqlServer = new HandshakePacket($data);\n            $this->salt = $this->mysqlServer->salt;\n            $this->serverPublicKey = $this->mysqlServer->serverPublicKey;\n            $authData = $this->processAuth($this->mysqlServer->pluginName);\n            $this->send($authData);\n        } else {\n            $this->chan->push(['data' => $data, 'from' => $this->serverFd]);\n        }\n\n    }\n\n    private function processAuth(string $pluginName)\n    {\n        $packet = new AuthPacket();\n        $packet->pluginName = $pluginName;\n        $packet->clientFlags = Capabilities::CLIENT_PROTOCOL_41 | Capabilities::CLIENT_PLUGIN_AUTH |\n            Capabilities::CLIENT_SECURE_CONNECTION | Capabilities::CLIENT_CONNECT_WITH_DB |\n            Capabilities::CLIENT_DEPRECATE_EOF;\n        $packet->maxPacketSize = 4194304;\n        $packet->charsetNumber = CharsetUtil::getNumber($this->charset);\n        $packet->user = $this->account['user'];\n        $packet->database = $this->account['database'];\n\n        if ($pluginName === 'mysql_native_password') {\n            $password = $this->account['password'];\n            $hash = sha1($password, true);\n            $doubleHash = sha1($hash, true);\n            $packet->authResponse = xor_string($doubleHash, sha1($this->salt . $doubleHash, true));\n\n        } elseif ($pluginName === 'caching_sha2_password') {\n            $packet->authResponse = Authentication::cachingSha2Password($this->account['password'], $this->salt, $this->serverPublicKey);\n        }\n\n        return $packet->pack();\n    }\n\n\n    public function send(...$data)\n    {\n        if ($this->connected) {\n            return $this->client->send(implode('', $data));\n        }\n        return false;\n    }\n\n    public function recv(&$remain)\n    {\n        if ($this->connected) {\n            return PacketSplitter::split($this->client, $remain);\n        }\n        return false;\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'close', 'from' => $this->serverFd]);\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'error', 'from' => $this->serverFd]);\n    }\n}\n",
      "<?php\n\nclass MysqlProxy\n{\n    public $isDuplex;\n    private $server;\n    private $serverFd;\n    private $charset = 'utf8mb4';\n    private $account = [];\n    private $auth = false;\n    private $chan;\n    private $serverPublicKey;\n    private $salt;\n    private $connected = false;\n    private $timeout;\n    private $mysqlClient;\n    private $mysqlServer;\n    private $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->isDuplex = method_exists($server, 'send');\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3) {\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            }\n            return false;\n        }\n        $this->connected = true;\n        return $this->client;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        if (!$this->auth) {\n            $this->mysqlServer = new HandshakePacket($data);\n            $this->salt = $this->mysqlServer->salt;\n            $this->serverPublicKey = $this->mysqlServer->serverPublicKey;\n            $authData = $this->processAuth($this->mysqlServer->pluginName);\n            $this->send($authData);\n            $this->auth = true;\n            return;\n        }\n        $this->chan->push(['data' => $data, 'from' => $this->serverFd]);\n    }\n\n\n    private function processAuth(string $pluginName)\n    {\n        $packet = new AuthPacket();\n        $packet->pluginName = $pluginName;\n        $packet->clientFlags = $this->mysqlServer->clientFlags;\n        $packet->maxPacketSize = $this->mysqlServer->maxPacketSize;\n        $packet->charsetIndex = $this->mysqlServer->charsetIndex;\n        $packet->user = $this->account['user'];\n        $packet->database = $this->account['database'];\n\n        if ($pluginName === 'mysql_native_password') {\n            $password = $this->account['password'];\n            if ($password !== '') {\n                $hash = sha1($password, true);\n                $packet->password = sha1($this->salt . sha1($hash, true), true) ^ $hash;\n            }\n        } elseif ($pluginName === 'caching_sha2_password') {\n            $password = $this->account['password'];\n            if ($password !== '') {\n                $packet->password = Authentication::scrambleSHA256Password($password, $this->salt, $this->serverPublicKey);\n            }\n        }\n        return $packet->pack();\n    }\n\n    public function send(...$data)\n    {\n        if ($this->connected) {\n            return $this->client->send(implode('', $data));\n        }\n        return false;\n    }\n\n    public function recv(&$remain)\n    {\n        return $this->client->recv($this->timeout, $remain);\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'close', 'from' => $this->serverFd]);\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->chan->push(['status' => 'error', 'from' => $this->serverFd]);\n    }\n\n    public function setAccount(array $account)\n    {\n        $this->account = $account;\n    }\n}\n\n\nclass HandshakePacket\n{\n    public $serverVersion;\n    public $connectionId;\n    public $salt;\n    public $clientFlags;\n    public $charsetIndex;\n    public $serverStatus;\n    public $capabilityFlags;\n    public $pluginName;\n    public $maxPacketSize;\n    public $serverPublicKey;\n\n    public function __construct(string $data)\n    {\n        // Implementation for parsing handshake packet from $data\n    }\n}\n\nclass AuthPacket\n{\n    public $clientFlags;\n    public $maxPacketSize;\n    public $charsetIndex;\n    public $user;\n    public $password;\n    public $database;\n    public $pluginName;\n\n    public function pack()\n    {\n        // Implementation for packing authentication data\n    }\n}\n\nclass Authentication\n{\n    public static function scrambleSHA256Password($password, $salt, $publicKey)\n    {\n        // Implementation for SHA256 password scrambling\n    }\n}\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 133,
    "Instruction": "Task Description: Create a PHP class that implements a JSON-RPC client using Swoole's coroutine-based TCP client for asynchronous communication with a JSON-RPC server. The class should handle connection management, request/response serialization, and middleware processing.\n\nClass Description: The Connection class provides a JSON-RPC client implementation using Swoole's coroutine client for TCP communication. It manages the connection lifecycle, handles JSON-RPC protocol serialization/deserialization, and supports middleware processing for requests.\n\nAttributes:\n- host: [string] - The hostname or IP address of the JSON-RPC server\n- port: [int] - The port number of the JSON-RPC server\n- timeout: [float] - Connection timeout in seconds\n- callTimeout: [float] - Timeout for RPC calls in seconds\n- middleware: [array] - Array of middleware objects to process requests\n- client: [Swoole\\Coroutine\\Client] - The Swoole coroutine client instance (protected)\n\nMethods:\n- __construct([array $config = []]) -> [void] - Constructor that initializes the connection with optional configuration\n- connect() -> [void] - Establishes a TCP connection to the JSON-RPC server\n- call([Request $request]) -> [Response] - Sends a JSON-RPC request and returns the response, processing through middleware\n- close() -> [void] - Closes the connection to the server\n- recv([float $timeout = -1]) -> [string] - Receives data from the server with optional timeout (protected)\n- send([string $data]) -> [void] - Sends data to the server (protected)",
    "Canonical_solution": "use Mix\\Bean\\BeanInjector;\nuse Mix\\JsonRpc\\Constants;\nuse Mix\\JsonRpc\\Exception\\DeserializeException;\nuse Mix\\JsonRpc\\Helper\\JsonRpcHelper;\nuse Mix\\JsonRpc\\Middleware\\MiddlewareDispatcher;\nuse Mix\\JsonRpc\\Middleware\\MiddlewareInterface;\nuse Mix\\JsonRpc\\Message\\Request;\nuse Mix\\JsonRpc\\Message\\Response;\nuse Swoole\\Coroutine\\Client;\n\nclass Connection\n{\n    public $host = '';\n    public $port = 0;\n    public $timeout = 0.0;\n    public $callTimeout = 10.0;\n    public $middleware = [];\n    protected $client;\n\n    public function __construct(array $config = [])\n    {\n        BeanInjector::inject($this, $config);\n    }\n\n    public function connect()\n    {\n        $host    = $this->host;\n        $port    = $this->port;\n        $timeout = $this->timeout;\n        $client  = new Client(SWOOLE_SOCK_TCP);\n        $client->set([\n            'open_eof_check' => true,\n            'package_eof'    => Constants::EOF,\n        ]);\n        if (!$client->connect($host, $port, $timeout)) {\n            throw new \\Swoole\\Exception(sprintf(\"JSON-RPC: %s (host:%s, port: %s)\", $client->errMsg, $host, $port), $client->errCode);\n        }\n        $this->client = $client;\n    }\n\n    public function call(Request $request)\n    {\n        $process              = function (Request $request) {\n            $jsonString = JsonRpcHelper::encode($request) . Constants::EOF;\n            $this->send($jsonString);\n            $data = $this->recv($this->callTimeout);\n            return JsonRpcHelper::deserializeResponse($data);\n        };\n        $middlewareDispatcher = new MiddlewareDispatcher($this->middleware, $process, $request);\n        return $middlewareDispatcher->dispatch();\n    }\n\n    public function close()\n    {\n        if (!$this->client->close()) {\n            $errMsg  = $this->client->errMsg;\n            $errCode = $this->client->errCode;\n            if ($errMsg == '' && $errCode == 0) {\n                return;\n            }\n            throw new \\Swoole\\Exception($errMsg, $errCode);\n        }\n    }\n\n    protected function recv(float $timeout = -1)\n    {\n        $data = $this->client->recv($timeout);\n        if ($data === false) {\n            $client = $this->client;\n            throw new \\Swoole\\Exception($client->errMsg, $client->errCode);\n        }\n        if ($data === \"\") {\n            $errCode = stripos(PHP_OS, 'Darwin') !== false ? 54 : 104;\n            $errMsg  = swoole_strerror($errCode, 9);\n            throw new \\Swoole\\Exception($errMsg, $errCode);\n        }\n        return $data;\n    }\n\n    protected function send(string $data)\n    {\n        $len  = strlen($data);\n        $size = $this->client->send($data);\n        if ($size === false) {\n            throw new \\Swoole\\Exception($this->client->errMsg, $this->client->errCode);\n        }\n        if ($len !== $size) {\n            throw new \\Swoole\\Exception('The sending data is incomplete, it may be that the socket has been closed by the peer.');\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 139,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nclass Connection\n{\n    protected $host;\n    protected $port;\n    protected $timeout;\n    protected $callTimeout;\n    protected $middleware = [];\n    protected $client;\n\n    public function __construct(array $config = [])\n    {\n        $this->host = $config['host'] ?? '127.0.0.1';\n        $this->port = $config['port'] ?? 9501;\n        $this->timeout = $config['timeout'] ?? 1.0;\n        $this->callTimeout = $config['callTimeout'] ?? 3.0;\n        $this->middleware = $config['middleware'] ?? [];\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n    }\n\n    public function connect()\n    {\n        if (!$this->client->connect($this->host, $this->port, $this->timeout)) {\n            throw new \\RuntimeException(\"Connection failed: {$this->client->errCode}\");\n        }\n    }\n\n    public function call(Request $request)\n    {\n        foreach ($this->middleware as $mw) {\n            $request = $mw->process($request);\n        }\n\n        $requestId = uniqid();\n        $requestData = json_encode([\n            'jsonrpc' => '2.0',\n            'method' => $request->getMethod(),\n            'params' => $request->getParams(),\n            'id' => $requestId,\n        ]);\n\n        $this->send($requestData);\n\n        $response = $this->recv($this->callTimeout);\n\n        if (!$response) {\n            throw new \\RuntimeException('RPC call timeout');\n        }\n\n        $responseData = json_decode($response, true);\n\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            throw new \\RuntimeException('Invalid JSON response');\n        }\n\n        if ($responseData['id'] != $requestId) {\n            throw new \\RuntimeException('Response ID mismatch');\n        }\n\n        return new Response($responseData['result'] ?? null, $responseData['error'] ?? null);\n    }\n\n    public function close()\n    {\n        $this->client->close();\n    }\n\n    protected function recv(float $timeout = -1)\n    {\n        return $this->client->recv($timeout);\n    }\n\n    protected function send(string $data)\n    {\n        if (!$this->client->send($data)) {\n            throw new \\RuntimeException(\"Send failed: {$this->client->errCode}\");\n        }\n    }\n}\n\nclass Request\n{\n    protected $method;\n    protected $params;\n\n    public function __construct(string $method, array $params = [])\n    {\n        $this->method = $method;\n        $this->params = $params;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getParams(): array\n    {\n        return $this->params;\n    }\n}\n\nclass Response\n{\n    protected $result;\n    protected $error;\n\n    public function __construct($result = null, $error = null)\n    {\n        $this->result = $result;\n        $this->error = $error;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n\n    public function getError()\n    {\n        return $this->error;\n    }\n}\n",
      "<?php\n\nclass Connection\n{\n    protected $host;\n    protected $port;\n    protected $timeout;\n    protected $callTimeout;\n    protected $middleware = [];\n    protected $client;\n\n    public function __construct(array $config = [])\n    {\n        $this->host = $config['host'] ?? '127.0.0.1';\n        $this->port = $config['port'] ?? 9501;\n        $this->timeout = $config['timeout'] ?? 3.0;\n        $this->callTimeout = $config['callTimeout'] ?? 3.0;\n        $this->middleware = $config['middleware'] ?? [];\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n    }\n\n    public function connect()\n    {\n        if (!$this->client->connect($this->host, $this->port, $this->timeout)) {\n            throw new \\RuntimeException(\"Connection failed: {$this->client->errCode}\");\n        }\n    }\n\n    public function call(Request $request)\n    {\n        foreach ($this->middleware as $mw) {\n            $request = $mw->process($request);\n        }\n\n        $requestId = uniqid();\n        $requestData = json_encode([\n            'jsonrpc' => '2.0',\n            'method' => $request->getMethod(),\n            'params' => $request->getParams(),\n            'id' => $requestId,\n        ]);\n\n        $this->send($requestData);\n\n        $responseData = $this->recv($this->callTimeout);\n        if (!$responseData) {\n            throw new \\RuntimeException('Read timeout');\n        }\n\n        $response = json_decode($responseData, true);\n\n        if ($response['id'] != $requestId) {\n            throw new \\RuntimeException('Invalid response ID');\n        }\n\n        return new Response($response['result'] ?? null, $response['error'] ?? null);\n    }\n\n    public function close()\n    {\n        $this->client->close();\n    }\n\n    protected function recv(float $timeout = -1)\n    {\n        return $this->client->recv($timeout);\n    }\n\n    protected function send(string $data)\n    {\n        if (!$this->client->send($data)) {\n            throw new \\RuntimeException(\"Send failed: {$this->client->errCode}\");\n        }\n    }\n}\n\nclass Request\n{\n    protected $method;\n    protected $params;\n\n    public function __construct($method, $params)\n    {\n        $this->method = $method;\n        $this->params = $params;\n    }\n\n    public function getMethod()\n    {\n        return $this->method;\n    }\n\n    public function getParams()\n    {\n        return $this->params;\n    }\n}\n\nclass Response\n{\n    protected $result;\n    protected $error;\n\n    public function __construct($result, $error)\n    {\n        $this->result = $result;\n        $this->error = $error;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n\n    public function getError()\n    {\n        return $this->error;\n    }\n}\n",
      "<?php\n\nclass Connection\n{\n    protected $host;\n    protected $port;\n    protected $timeout;\n    protected $callTimeout;\n    protected $middleware = [];\n    protected $client;\n\n    public function __construct(array $config = [])\n    {\n        $this->host = $config['host'] ?? '127.0.0.1';\n        $this->port = $config['port'] ?? 9501;\n        $this->timeout = $config['timeout'] ?? 1.0;\n        $this->callTimeout = $config['callTimeout'] ?? 3.0;\n        $this->middleware = $config['middleware'] ?? [];\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n    }\n\n    public function connect()\n    {\n        if (!$this->client->connect($this->host, $this->port, $this->timeout)) {\n            throw new Exception(\"connect failed. Error: {$this->client->errCode}\\n\");\n        }\n    }\n\n    public function call(Request $request)\n    {\n        foreach ($this->middleware as $mw) {\n            $request = $mw->process($request);\n        }\n\n        $requestId = uniqid();\n        $requestData = json_encode([\n            'jsonrpc' => '2.0',\n            'method' => $request->getMethod(),\n            'params' => $request->getParams(),\n            'id' => $requestId,\n        ]);\n\n        $this->send($requestData);\n\n        $responseData = $this->recv($this->callTimeout);\n        if ($responseData === false) {\n            throw new Exception(\"recv failed. Error: {$this->client->errCode}\\n\");\n        }\n\n        $response = json_decode($responseData, true);\n\n        if ($response['id'] != $requestId) {\n            throw new Exception(\"Invalid response ID\");\n        }\n\n        return new Response($response['result'] ?? null, $response['error'] ?? null);\n    }\n\n\n    public function close()\n    {\n        $this->client->close();\n    }\n\n    protected function recv(float $timeout = -1)\n    {\n        return $this->client->recv($timeout);\n    }\n\n    protected function send(string $data)\n    {\n        if ($this->client->send($data) === false) {\n            throw new Exception(\"send failed. Error: {$this->client->errCode}\\n\");\n        }\n    }\n}\n\nclass Request\n{\n    protected $method;\n    protected $params;\n\n    public function __construct($method, $params)\n    {\n        $this->method = $method;\n        $this->params = $params;\n    }\n\n    public function getMethod()\n    {\n        return $this->method;\n    }\n\n    public function getParams()\n    {\n        return $this->params;\n    }\n}\n\nclass Response\n{\n    protected $result;\n    protected $error;\n\n    public function __construct($result, $error)\n    {\n        $this->result = $result;\n        $this->error = $error;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n\n    public function getError()\n    {\n        return $this->error;\n    }\n}\n",
      "<?php\n\nclass Connection\n{\n    protected $host;\n    protected $port;\n    protected $timeout;\n    protected $callTimeout;\n    protected $middleware = [];\n    protected $client;\n\n    public function __construct(array $config = [])\n    {\n        $this->host = $config['host'] ?? '127.0.0.1';\n        $this->port = $config['port'] ?? 9501;\n        $this->timeout = $config['timeout'] ?? 1.0;\n        $this->callTimeout = $config['callTimeout'] ?? 3.0;\n    }\n\n    public function connect()\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        if (!$this->client->connect($this->host, $this->port, $this->timeout)) {\n            throw new \\RuntimeException(\"Connection failed: {$this->client->errCode}\");\n        }\n    }\n\n    public function call(Request $request)\n    {\n        foreach ($this->middleware as $middleware) {\n            $request = $middleware->process($request);\n        }\n\n        $requestId = uniqid();\n        $requestData = json_encode([\n            'jsonrpc' => '2.0',\n            'method' => $request->getMethod(),\n            'params' => $request->getParams(),\n            'id' => $requestId,\n        ]);\n\n        $this->send($requestData);\n\n        $response = $this->recv($this->callTimeout);\n\n        if ($response === false) {\n            throw new \\RuntimeException(\"Read timeout\");\n        }\n\n        $responseData = json_decode($response, true);\n\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            throw new \\RuntimeException(\"Invalid JSON response: \" . json_last_error_msg());\n        }\n\n        if ($responseData['id'] !== $requestId) {\n            throw new \\RuntimeException(\"Response ID mismatch\");\n        }\n\n        return new Response($responseData['result'] ?? null, $responseData['error'] ?? null);\n    }\n\n    public function close()\n    {\n        if ($this->client) {\n            $this->client->close();\n        }\n    }\n\n    protected function recv(float $timeout = -1)\n    {\n        return $this->client->recv($timeout);\n    }\n\n    protected function send(string $data)\n    {\n        if (!$this->client->send($data)) {\n            throw new \\RuntimeException(\"Send failed: {$this->client->errCode}\");\n        }\n    }\n}\n\nclass Request\n{\n    protected $method;\n    protected $params;\n\n    public function __construct(string $method, array $params = [])\n    {\n        $this->method = $method;\n        $this->params = $params;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getParams(): array\n    {\n        return $this->params;\n    }\n}\n\nclass Response\n{\n    protected $result;\n    protected $error;\n\n    public function __construct($result = null, $error = null)\n    {\n        $this->result = $result;\n        $this->error = $error;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n\n    public function getError()\n    {\n        return $this->error;\n    }\n}\n",
      "<?php\n\nclass Connection\n{\n    protected $host;\n    protected $port;\n    protected $timeout;\n    protected $callTimeout;\n    protected $middleware = [];\n    protected $client;\n\n    public function __construct(array $config = [])\n    {\n        $this->host = $config['host'] ?? '127.0.0.1';\n        $this->port = $config['port'] ?? 9501;\n        $this->timeout = $config['timeout'] ?? 1.0;\n        $this->callTimeout = $config['callTimeout'] ?? 3.0;\n    }\n\n    public function connect()\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        if (!$this->client->connect($this->host, $this->port, $this->timeout)) {\n            throw new \\RuntimeException(\"Connection failed: {$this->client->errCode}\");\n        }\n    }\n\n    public function call(Request $request)\n    {\n        foreach ($this->middleware as $middleware) {\n            $request = $middleware->process($request);\n        }\n\n        $requestId = uniqid();\n        $requestData = json_encode([\n            'jsonrpc' => '2.0',\n            'method' => $request->getMethod(),\n            'params' => $request->getParams(),\n            'id' => $requestId,\n        ]);\n\n        $this->send($requestData);\n\n        $response = $this->recv($this->callTimeout);\n        if ($response === false) {\n            throw new \\RuntimeException(\"Read timeout\");\n        }\n\n        $responseData = json_decode($response, true);\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            throw new \\RuntimeException(\"Invalid JSON response\");\n        }\n\n        return new Response($responseData['result'] ?? null, $responseData['error'] ?? null, $responseData['id'] ?? null);\n    }\n\n    public function close()\n    {\n        if ($this->client) {\n            $this->client->close();\n        }\n    }\n\n    protected function recv(float $timeout = -1)\n    {\n        return $this->client->recv($timeout);\n    }\n\n    protected function send(string $data)\n    {\n        if (!$this->client->send($data)) {\n            throw new \\RuntimeException(\"Send failed: {$this->client->errCode}\");\n        }\n    }\n}\n\nclass Request\n{\n    protected $method;\n    protected $params;\n\n    public function __construct(string $method, array $params = [])\n    {\n        $this->method = $method;\n        $this->params = $params;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getParams(): array\n    {\n        return $this->params;\n    }\n}\n\nclass Response\n{\n    protected $result;\n    protected $error;\n    protected $id;\n\n    public function __construct($result = null, $error = null, $id = null)\n    {\n        $this->result = $result;\n        $this->error = $error;\n        $this->id = $id;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n\n    public function getError()\n    {\n        return $this->error;\n    }\n}\n",
      "<?php\n\nclass Connection\n{\n    protected $host;\n    protected $port;\n    protected $timeout;\n    protected $callTimeout;\n    protected $middleware = [];\n    protected $client;\n\n    public function __construct(array $config = [])\n    {\n        $this->host = $config['host'] ?? '127.0.0.1';\n        $this->port = $config['port'] ?? 9501;\n        $this->timeout = $config['timeout'] ?? 1.0;\n        $this->callTimeout = $config['callTimeout'] ?? 3.0;\n    }\n\n    public function connect()\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        if (!$this->client->connect($this->host, $this->port, $this->timeout)) {\n            throw new \\RuntimeException(\"Connection failed: {$this->client->errCode}\");\n        }\n    }\n\n    public function call(Request $request)\n    {\n        foreach ($this->middleware as $middleware) {\n            $request = $middleware->process($request);\n        }\n\n        $requestId = uniqid();\n        $requestData = json_encode([\n            'jsonrpc' => '2.0',\n            'method' => $request->getMethod(),\n            'params' => $request->getParams(),\n            'id' => $requestId,\n        ]);\n\n        $this->send($requestData);\n\n        $response = $this->recv($this->callTimeout);\n\n        if (!$response) {\n            throw new \\RuntimeException('No response received from server.');\n        }\n\n        $responseData = json_decode($response, true);\n\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            throw new \\RuntimeException('Invalid JSON response received from server.');\n        }\n\n        if ($responseData['id'] != $requestId) {\n            throw new \\RuntimeException('Response ID mismatch.');\n        }\n\n        return new Response($responseData['result'] ?? null, $responseData['error'] ?? null);\n    }\n\n    public function close()\n    {\n        if ($this->client && $this->client->isConnected()) {\n            $this->client->close();\n        }\n    }\n\n    protected function recv(float $timeout = -1)\n    {\n        return $this->client->recv($timeout);\n    }\n\n    protected function send(string $data)\n    {\n        if (!$this->client->send($data)) {\n            throw new \\RuntimeException(\"Send failed: {$this->client->errCode}\");\n        }\n    }\n}\n\nclass Request\n{\n    protected $method;\n    protected $params;\n\n    public function __construct(string $method, array $params = [])\n    {\n        $this->method = $method;\n        $this->params = $params;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getParams(): array\n    {\n        return $this->params;\n    }\n}\n\nclass Response\n{\n    protected $result;\n    protected $error;\n\n    public function __construct($result = null, $error = null)\n    {\n        $this->result = $result;\n        $this->error = $error;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n\n    public function getError()\n    {\n        return $this->error;\n    }\n}\n",
      "<?php\n\nclass Connection\n{\n    protected $host;\n    protected $port;\n    protected $timeout;\n    protected $callTimeout;\n    protected $middleware = [];\n    protected $client;\n\n    public function __construct(array $config = [])\n    {\n        $this->host = $config['host'] ?? '127.0.0.1';\n        $this->port = $config['port'] ?? 9501;\n        $this->timeout = $config['timeout'] ?? 1.0;\n        $this->callTimeout = $config['callTimeout'] ?? 3.0;\n        $this->middleware = $config['middleware'] ?? [];\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n    }\n\n    public function connect()\n    {\n        if (!$this->client->connect($this->host, $this->port, $this->timeout)) {\n            throw new \\RuntimeException(\"Connection failed: {$this->client->errMsg}\");\n        }\n    }\n\n    public function call(Request $request)\n    {\n        foreach ($this->middleware as $mw) {\n            $request = $mw->process($request);\n        }\n\n        $requestId = uniqid();\n        $requestData = json_encode([\n            'jsonrpc' => '2.0',\n            'method' => $request->getMethod(),\n            'params' => $request->getParams(),\n            'id' => $requestId,\n        ]);\n\n        $this->send($requestData);\n\n        $responseData = $this->recv($this->callTimeout);\n        if (!$responseData) {\n            throw new \\RuntimeException(\"Call timeout\");\n        }\n\n        $response = json_decode($responseData, true);\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            throw new \\RuntimeException(\"Invalid JSON response: \" . json_last_error_msg());\n        }\n\n        if ($response['id'] != $requestId) {\n            throw new \\RuntimeException(\"Response ID mismatch\");\n        }\n\n        return new Response($response['result'] ?? null, $response['error'] ?? null);\n    }\n\n    public function close()\n    {\n        $this->client->close();\n    }\n\n    protected function recv(float $timeout = -1)\n    {\n        return $this->client->recv($timeout);\n    }\n\n    protected function send(string $data)\n    {\n        if (!$this->client->send($data)) {\n            throw new \\RuntimeException(\"Send failed: {$this->client->errMsg}\");\n        }\n    }\n}\n\nclass Request\n{\n    protected $method;\n    protected $params;\n\n    public function __construct(string $method, array $params = [])\n    {\n        $this->method = $method;\n        $this->params = $params;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getParams(): array\n    {\n        return $this->params;\n    }\n}\n\nclass Response\n{\n    protected $result;\n    protected $error;\n\n    public function __construct($result = null, $error = null)\n    {\n        $this->result = $result;\n        $this->error = $error;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n\n    public function getError()\n    {\n        return $this->error;\n    }\n}\n",
      "<?php\n\nclass Connection\n{\n    protected $host;\n    protected $port;\n    protected $timeout;\n    protected $callTimeout;\n    protected $middleware = [];\n    protected $client;\n\n    public function __construct(array $config = [])\n    {\n        $this->host = $config['host'] ?? '127.0.0.1';\n        $this->port = $config['port'] ?? 9501;\n        $this->timeout = $config['timeout'] ?? 1.0;\n        $this->callTimeout = $config['callTimeout'] ?? 3.0;\n    }\n\n    public function connect()\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        if (!$this->client->connect($this->host, $this->port, $this->timeout)) {\n            throw new Exception(\"connect failed. Error: {$this->client->errCode}\\n\");\n        }\n    }\n\n    public function call(Request $request)\n    {\n        foreach ($this->middleware as $mw) {\n            $request = $mw->process($request);\n        }\n\n        $requestId = uniqid();\n        $requestData = json_encode([\n            'jsonrpc' => '2.0',\n            'method' => $request->getMethod(),\n            'params' => $request->getParams(),\n            'id' => $requestId,\n        ]);\n\n        $this->send($requestData);\n\n        $response = $this->recv($this->callTimeout);\n\n        if ($response === false) {\n            throw new Exception(\"recv failed. Error: {$this->client->errCode}\\n\");\n        }\n\n        $responseData = json_decode($response, true);\n\n        if ($responseData['id'] != $requestId) {\n            throw new Exception(\"Invalid response ID\");\n        }\n\n        return new Response($responseData['result'] ?? null, $responseData['error'] ?? null);\n    }\n\n    public function close()\n    {\n        if ($this->client) {\n            $this->client->close();\n        }\n    }\n\n    protected function recv(float $timeout = -1)\n    {\n        return $this->client->recv($timeout);\n    }\n\n    protected function send(string $data)\n    {\n        $this->client->send($data);\n    }\n}\n\nclass Request\n{\n    protected $method;\n    protected $params;\n\n    public function __construct($method, $params)\n    {\n        $this->method = $method;\n        $this->params = $params;\n    }\n\n    public function getMethod()\n    {\n        return $this->method;\n    }\n\n    public function getParams()\n    {\n        return $this->params;\n    }\n}\n\nclass Response\n{\n    protected $result;\n    protected $error;\n\n    public function __construct($result, $error)\n    {\n        $this->result = $result;\n        $this->error = $error;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n\n    public function getError()\n    {\n        return $this->error;\n    }\n}\n",
      "<?php\n\nclass Connection\n{\n    protected $host;\n    protected $port;\n    protected $timeout;\n    protected $callTimeout;\n    protected $middleware = [];\n    protected $client;\n\n    public function __construct(array $config = [])\n    {\n        $this->host = $config['host'] ?? '127.0.0.1';\n        $this->port = $config['port'] ?? 9501;\n        $this->timeout = $config['timeout'] ?? 1.0;\n        $this->callTimeout = $config['callTimeout'] ?? 3.0;\n        $this->middleware = $config['middleware'] ?? [];\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n    }\n\n    public function connect()\n    {\n        if (!$this->client->connect($this->host, $this->port, $this->timeout)) {\n            throw new \\RuntimeException(\"Connection failed. Error: {$this->client->errCode}\");\n        }\n    }\n\n    public function call(Request $request)\n    {\n        foreach ($this->middleware as $mw) {\n            $request = $mw->process($request);\n        }\n\n        $requestId = uniqid();\n        $requestData = json_encode([\n            'jsonrpc' => '2.0',\n            'method' => $request->getMethod(),\n            'params' => $request->getParams(),\n            'id' => $requestId,\n        ]);\n\n        $this->send($requestData);\n\n        $response = $this->recv($this->callTimeout);\n\n        if (!$response) {\n            throw new \\RuntimeException('No response received from server.');\n        }\n\n        $responseData = json_decode($response, true);\n\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            throw new \\RuntimeException('Invalid JSON response received: ' . json_last_error_msg());\n        }\n\n        if ($responseData['id'] != $requestId) {\n            throw new \\RuntimeException('Response ID mismatch.');\n        }\n\n        return new Response($responseData['result'] ?? null, $responseData['error'] ?? null);\n    }\n\n    public function close()\n    {\n        $this->client->close();\n    }\n\n    protected function recv(float $timeout = -1)\n    {\n        return $this->client->recv($timeout);\n    }\n\n    protected function send(string $data)\n    {\n        if (!$this->client->send($data)) {\n            throw new \\RuntimeException(\"Failed to send data. Error: {$this->client->errCode}\");\n        }\n    }\n}\n\nclass Request\n{\n    protected $method;\n    protected $params;\n\n    public function __construct(string $method, array $params = [])\n    {\n        $this->method = $method;\n        $this->params = $params;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getParams(): array\n    {\n        return $this->params;\n    }\n}\n\nclass Response\n{\n    protected $result;\n    protected $error;\n\n    public function __construct($result = null, $error = null)\n    {\n        $this->result = $result;\n        $this->error = $error;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n\n    public function getError()\n    {\n        return $this->error;\n    }\n}\n",
      "<?php\n\nclass Connection\n{\n    protected $host;\n    protected $port;\n    protected $timeout;\n    protected $callTimeout;\n    protected $middleware = [];\n    protected $client;\n\n    public function __construct(array $config = [])\n    {\n        $this->host = $config['host'] ?? '127.0.0.1';\n        $this->port = $config['port'] ?? 9501;\n        $this->timeout = $config['timeout'] ?? 1.0;\n        $this->callTimeout = $config['callTimeout'] ?? 3.0;\n        $this->middleware = $config['middleware'] ?? [];\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n    }\n\n    public function connect()\n    {\n        if (!$this->client->connect($this->host, $this->port, $this->timeout)) {\n            throw new \\RuntimeException(\"Connection failed. Error: {$this->client->errCode}\");\n        }\n    }\n\n    public function call(Request $request)\n    {\n        foreach ($this->middleware as $mw) {\n            $request = $mw->process($request);\n        }\n\n        $requestId = uniqid();\n        $requestData = json_encode([\n            'jsonrpc' => '2.0',\n            'method' => $request->getMethod(),\n            'params' => $request->getParams(),\n            'id' => $requestId,\n        ]);\n\n        $this->send($requestData);\n\n        $response = $this->recv($this->callTimeout);\n\n        if ($response === false) {\n            throw new \\RuntimeException(\"Read timeout\");\n        }\n\n        $responseData = json_decode($response, true);\n\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            throw new \\RuntimeException(\"Invalid JSON response: \" . json_last_error_msg());\n        }\n\n        if ($responseData['id'] != $requestId) {\n            throw new \\RuntimeException(\"Response ID mismatch\");\n        }\n\n        return new Response($responseData['result'] ?? null, $responseData['error'] ?? null);\n    }\n\n    public function close()\n    {\n        $this->client->close();\n    }\n\n    protected function recv(float $timeout = -1)\n    {\n        return $this->client->recv($timeout);\n    }\n\n    protected function send(string $data)\n    {\n        if ($this->client->send($data) === false) {\n            throw new \\RuntimeException(\"Send failed. Error: {$this->client->errCode}\");\n        }\n    }\n}\n\nclass Request\n{\n    protected $method;\n    protected $params;\n\n    public function __construct(string $method, array $params = [])\n    {\n        $this->method = $method;\n        $this->params = $params;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getParams(): array\n    {\n        return $this->params;\n    }\n}\n\nclass Response\n{\n    protected $result;\n    protected $error;\n\n    public function __construct($result = null, $error = null)\n    {\n        $this->result = $result;\n        $this->error = $error;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n\n    public function getError()\n    {\n        return $this->error;\n    }\n}\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 134,
    "Instruction": "Task Description: Create a WebSocket server in PHP using stream_socket_server that handles client connections, processes requests, and sends responses.\n\nClass Description: The Server class implements a WebSocket server that listens for incoming connections, handles client requests through callbacks, and manages socket communication. It supports non-blocking operations and provides hooks for custom logic.\n\nAttributes:\n- host: string - The host address to bind the server to\n- port: int - The port number to listen on\n- output: OutputInterface - Interface for debug and status output\n- stop: bool - Flag to control server shutdown\n- socket: resource - The main server socket resource\n- clientSockets: array - Array of connected client sockets\n- afterCallback: Closure - Callback executed after server starts\n- tickerCallback: Closure - Periodic callback during server loop\n- routerCallback: Closure - Request routing callback\n\nMethods:\n- __construct(string $host, int $port, OutputInterface $output) -> void - Initializes server with host, port and output interface\n- checkRequiredExtensionsExists() -> void - Validates required PHP extensions are loaded\n- run() -> void - Starts the server main loop\n- createServerSocket() -> resource - Creates and configures the server socket\n- updatePort() -> void - Updates the port number from actual socket binding\n- acceptNewConnections() -> void - Accepts new client connections\n- handleClientRequests() -> void - Processes requests from connected clients\n- readClientRequest(resource $clientSocket) -> string - Reads complete request from client\n- parseRequest(string $request) -> array - Parses request into path and payload\n- sendResponse(resource $clientSocket, Response $response) -> void - Sends formatted response to client\n- closeClientSocket(resource $clientSocket, int $key) -> void - Closes and removes client socket\n- afterRun(Closure $param) -> void - Sets after-start callback\n- ticker(Closure $param) -> void - Sets periodic tick callback\n- router(Closure $param) -> void - Sets request routing callback\n- stop() -> void - Signals server to stop",
    "Canonical_solution": "use Closure;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\nclass Server\n{\n    private string $host;\n    private int $port;\n    private OutputInterface $output;\n    private bool $stop = false;\n    private $socket;\n    private array $clientSockets = [];\n    private Closure $afterCallback;\n    private Closure $tickerCallback;\n    private Closure $routerCallback;\n\n    public function __construct($host, $port, OutputInterface $output)\n    {\n        self::checkRequiredExtensionsExists();\n        $this->host = $host;\n        $this->port = $port;\n        $this->output = $output;\n    }\n\n    public static function checkRequiredExtensionsExists(): void\n    {\n        if (!function_exists('socket_import_stream')) {\n            throw new Exception('Required PHP extension \"sockets\" is not loaded');\n        }\n        if (!function_exists('stream_set_blocking')) {\n            throw new Exception('Required PHP extension \"stream\" is not loaded');\n        }\n    }\n\n    public function run(): void\n    {\n        try {\n            $this->socket = $this->createServerSocket();\n            $this->updatePort();\n            if ($this->output->isDebug()) {\n                $this->output->writeln(\"[master] Starting server at http://{$this->host}:{$this->port}\");\n            }\n\n            ($this->afterCallback)($this->port);\n\n            while (true) {\n                $this->acceptNewConnections();\n                $this->handleClientRequests();\n                usleep(16_000);\n                ($this->tickerCallback)();\n                if ($this->stop) {\n                    break;\n                }\n            }\n\n            if ($this->output->isDebug()) {\n                $this->output->writeln(\"[master] Stopping server at http://{$this->host}:{$this->port}\");\n            }\n        } finally {\n            if (isset($this->socket)) {\n                fclose($this->socket);\n            }\n        }\n    }\n\n    private function createServerSocket()\n    {\n        $server = stream_socket_server(\"tcp://{$this->host}:{$this->port}\", $errno, $errstr);\n        if (!$server) {\n            throw new Exception(\"Socket creation failed: $errstr ($errno)\");\n        }\n        if (!stream_set_blocking($server, false)) {\n            throw new Exception(\"Failed to set server socket to non-blocking mode\");\n        }\n        return $server;\n    }\n\n    private function updatePort(): void\n    {\n        $name = stream_socket_get_name($this->socket, false);\n        if ($name) {\n            list(, $port) = explode(':', $name);\n            $this->port = (int) $port;\n        } else {\n            throw new Exception(\"Failed to get the assigned port\");\n        }\n    }\n\n    private function acceptNewConnections(): void\n    {\n        $newClientSocket = @stream_socket_accept($this->socket, 0);\n        if ($newClientSocket) {\n            if (!stream_set_blocking($newClientSocket, false)) {\n                throw new Exception(\"Failed to set client socket to non-blocking mode\");\n            }\n            $this->clientSockets[] = $newClientSocket;\n        }\n    }\n\n    private function handleClientRequests(): void\n    {\n        foreach ($this->clientSockets as $key => $clientSocket) {\n            if (feof($clientSocket)) {\n                $this->closeClientSocket($clientSocket, $key);\n                continue;\n            }\n\n            $request = $this->readClientRequest($clientSocket);\n            list($path, $payload) = $this->parseRequest($request);\n            $response = ($this->routerCallback)($path, $payload);\n            $this->sendResponse($clientSocket, $response);\n            $this->closeClientSocket($clientSocket, $key);\n        }\n    }\n\n    private function readClientRequest($clientSocket)\n    {\n        $request = '';\n        while (($chunk = @fread($clientSocket, 1024)) !== false) {\n            $request .= $chunk;\n            if (strpos($request, \"\\r\\n\\r\\n\") !== false) {\n                break;\n            }\n        }\n        if ($chunk === false && !feof($clientSocket)) {\n            throw new Exception(\"Socket read failed\");\n        }\n        return $request;\n    }\n\n    private function parseRequest($request)\n    {\n        $lines = explode(\"\\r\\n\", $request);\n        $requestLine = $lines[0];\n        $parts = explode(' ', $requestLine);\n        if (count($parts) !== 3) {\n            throw new Exception(\"Malformed request line: $requestLine\");\n        }\n        $path = $parts[1];\n\n        $headers = [];\n        for ($i = 1; $i < count($lines); $i++) {\n            $line = $lines[$i];\n            if (empty($line)) {\n                break;\n            }\n            [$key, $value] = explode(':', $line, 2);\n            $headers[$key] = trim($value);\n        }\n        if (empty($headers['Content-Type']) || $headers['Content-Type'] !== 'application/json') {\n            throw new Exception(\"Malformed request: invalid Content-Type\");\n        }\n\n        $payload = json_decode(implode(\"\\n\", array_slice($lines, $i + 1)), true, flags: JSON_THROW_ON_ERROR);\n        return [$path, $payload];\n    }\n\n    private function sendResponse($clientSocket, Response $response)\n    {\n        $code = $response->getStatus();\n        $content = json_encode($response->getBody(), flags: JSON_PRETTY_PRINT);\n        $headers = \"HTTP/1.1 $code OK\\r\\n\" .\n            \"Content-Type: application/json\\r\\n\" .\n            \"Content-Length: \" . strlen($content) . \"\\r\\n\" .\n            \"Connection: close\\r\\n\\r\\n\";\n        fwrite($clientSocket, $headers . $content);\n    }\n\n    private function closeClientSocket($clientSocket, $key): void\n    {\n        fclose($clientSocket);\n        unset($this->clientSockets[$key]);\n    }\n\n    public function afterRun(Closure $param): void\n    {\n        $this->afterCallback = $param;\n    }\n\n    public function ticker(Closure $param): void\n    {\n        $this->tickerCallback = $param;\n    }\n\n    public function router(Closure $param)\n    {\n        $this->routerCallback = $param;\n    }\n\n    public function stop(): void\n    {\n        $this->stop = true;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 129,
    "matched_results": [
      "<?php\n\nclass Server\n{\n    private string $host;\n    private int $port;\n    private OutputInterface $output;\n    private bool $stop = false;\n    private $socket;\n    private array $clientSockets = [];\n    private $afterCallback;\n    private $tickerCallback;\n    private $routerCallback;\n\n    public function __construct(string $host, int $port, OutputInterface $output)\n    {\n        $this->host = $host;\n        $this->port = $port;\n        $this->output = $output;\n    }\n\n    public function checkRequiredExtensionsExists(): void\n    {\n        if (!extension_loaded('sockets')) {\n            throw new \\Exception(\"The sockets extension is required for this server.\");\n        }\n    }\n\n    public function run(): void\n    {\n        $this->createServerSocket();\n        $this->updatePort();\n\n        if ($this->afterCallback) {\n            ($this->afterCallback)();\n        }\n\n        while (!$this->stop) {\n            $this->acceptNewConnections();\n            $this->handleClientRequests();\n\n            if ($this->tickerCallback) {\n                ($this->tickerCallback)();\n            }\n\n            usleep(1000);\n        }\n\n        fclose($this->socket);\n    }\n\n    private function createServerSocket()\n    {\n        $this->socket = stream_socket_server(\"tcp://{$this->host}:{$this->port}\", $errno, $errstr);\n        if (!$this->socket) {\n            throw new \\Exception(\"Could not create server socket: [$errno] $errstr\");\n        }\n        stream_set_blocking($this->socket, false);\n    }\n\n    private function updatePort(): void\n    {\n        $name = stream_socket_get_name($this->socket, false);\n        $this->port = (int)substr(strrchr($name, ':'), 1);\n    }\n\n\n    private function acceptNewConnections(): void\n    {\n        $newSocket = @stream_socket_accept($this->socket, 0);\n        if ($newSocket) {\n            stream_set_blocking($newSocket, false);\n            $this->clientSockets[] = $newSocket;\n        }\n    }\n\n    private function handleClientRequests(): void\n    {\n        foreach ($this->clientSockets as $key => $clientSocket) {\n            $request = $this->readClientRequest($clientSocket);\n            if ($request !== false && $request !== '') {\n                $parsedRequest = $this->parseRequest($request);\n                if ($this->routerCallback) {\n                    $response = ($this->routerCallback)($parsedRequest['path'], $parsedRequest['payload'], $clientSocket);\n                    $this->sendResponse($clientSocket, $response);\n                }\n            }\n        }\n    }\n\n    private function readClientRequest($clientSocket): string|false\n    {\n        return @fread($clientSocket, 8192);\n    }\n\n    private function parseRequest(string $request): array\n    {\n        $parts = explode(\"\\r\\n\\r\\n\", $request, 2);\n        $headers = $parts[0];\n        $payload = $parts[1] ?? '';\n        preg_match('/GET (.*?) HTTP/', $headers, $matches);\n        $path = $matches[1] ?? '/';\n\n        return ['path' => $path, 'payload' => $payload];\n    }\n\n    private function sendResponse(resource $clientSocket, Response $response): void\n    {\n        fwrite($clientSocket, (string)$response);\n    }\n\n    private function closeClientSocket(resource $clientSocket, int $key): void\n    {\n        fclose($clientSocket);\n        unset($this->clientSockets[$key]);\n    }\n\n    public function afterRun(Closure $param): void\n    {\n        $this->afterCallback = $param;\n    }\n\n    public function ticker(Closure $param): void\n    {\n        $this->tickerCallback = $param;\n    }\n\n    public function router(Closure $param): void\n    {\n        $this->routerCallback = $param;\n    }\n\n    public function stop(): void\n    {\n        $this->stop = true;\n    }\n}\n\ninterface OutputInterface {}\nclass Response {\n    public function __construct(private string $body, private int $statusCode = 200, private array $headers = []) {}\n    public function __toString(): string {\n        $headersString = implode(\"\\r\\n\", array_map(fn($key, $value) => \"$key: $value\", array_keys($this->headers), $this->headers));\n        return \"HTTP/1.1 {$this->statusCode} OK\\r\\n{$headersString}\\r\\n\\r\\n{$this->body}\";\n    }\n}\n",
      "<?php\n\nclass Server\n{\n    private string $host;\n    private int $port;\n    private OutputInterface $output;\n    private bool $stop = false;\n    private $socket;\n    private array $clientSockets = [];\n    private $afterCallback;\n    private $tickerCallback;\n    private $routerCallback;\n\n    public function __construct(string $host, int $port, OutputInterface $output)\n    {\n        $this->host = $host;\n        $this->port = $port;\n        $this->output = $output;\n    }\n\n    public function checkRequiredExtensionsExists(): void\n    {\n        if (!extension_loaded('sockets')) {\n            throw new \\Exception(\"The sockets extension is required for this server.\");\n        }\n    }\n\n\n    public function run(): void\n    {\n        $this->createServerSocket();\n\n        if ($this->afterCallback) {\n            ($this->afterCallback)();\n        }\n\n        while (!$this->stop) {\n            $read = $this->clientSockets;\n            $read[] = $this->socket;\n            $write = null;\n            $except = null;\n\n            if (@stream_select($read, $write, $except, 0, 5000) > 0) {\n                $this->acceptNewConnections();\n                $this->handleClientRequests();\n            }\n\n            if ($this->tickerCallback) {\n                ($this->tickerCallback)();\n            }\n        }\n\n        fclose($this->socket);\n    }\n\n    private function createServerSocket()\n    {\n        $this->socket = stream_socket_server(\"tcp://{$this->host}:{$this->port}\", $errno, $errstr);\n\n        if (!$this->socket) {\n            throw new \\Exception(\"Could not create server socket: [$errno] $errstr\");\n        }\n\n        stream_set_blocking($this->socket, false);\n        $this->updatePort();\n    }\n\n    private function updatePort(): void\n    {\n        $name = stream_socket_get_name($this->socket, false);\n        $this->port = (int)substr(strrchr($name, ':'), 1);\n    }\n\n    private function acceptNewConnections(): void\n    {\n        if (in_array($this->socket, $read)) {\n            $clientSocket = stream_socket_accept($this->socket);\n\n            if ($clientSocket) {\n                stream_set_blocking($clientSocket, false);\n                $this->clientSockets[] = $clientSocket;\n            }\n\n            $key = array_search($this->socket, $read);\n            unset($read[$key]);\n        }\n    }\n\n    private function handleClientRequests(): void\n    {\n        foreach ($read as $clientSocket) {\n            $request = $this->readClientRequest($clientSocket);\n\n            if ($request !== false) {\n                if ($request === \"\") {\n                    $this->closeClientSocket($clientSocket, $clientSocket);\n                    continue;\n                }\n                [$path, $payload] = $this->parseRequest($request);\n                $response = ($this->routerCallback)($path, $payload, $clientSocket);\n                $this->sendResponse($clientSocket, $response);\n            }\n        }\n    }\n\n    private function readClientRequest($clientSocket): string|false\n    {\n        $buffer = \"\";\n        while (true) {\n            $data = fread($clientSocket, 1024);\n            if ($data === false || $data === \"\") {\n                return $data;\n            }\n            $buffer .= $data;\n            if (strpos($buffer, \"\\r\\n\\r\\n\") !== false) {\n                break;\n            }\n        }\n        return $buffer;\n    }\n\n    private function parseRequest(string $request): array\n    {\n        $lines = explode(\"\\r\\n\", $request);\n        $firstLine = explode(\" \", $lines[0]);\n        $path = $firstLine[1];\n        $payload = \"\";\n        return [$path, $payload];\n    }\n\n    private function sendResponse(resource $clientSocket, Response $response): void\n    {\n        fwrite($clientSocket, (string)$response);\n    }\n\n    private function closeClientSocket($clientSocket, int $key): void\n    {\n        fclose($clientSocket);\n        unset($this->clientSockets[$key]);\n    }\n\n    public function afterRun(Closure $param): void\n    {\n        $this->afterCallback = $param;\n    }\n\n    public function ticker(Closure $param): void\n    {\n        $this->tickerCallback = $param;\n    }\n\n    public function router(Closure $param): void\n    {\n        $this->routerCallback = $param;\n    }\n\n    public function stop(): void\n    {\n        $this->stop = true;\n    }\n}\n\ninterface OutputInterface {}\nclass Response {\n    private $body;\n    public function __construct($body) {\n        $this->body = $body;\n    }\n    public function __toString() {\n        return $this->body;\n    }\n}\n",
      "<?php\n\nclass Server\n{\n    private string $host;\n    private int $port;\n    private OutputInterface $output;\n    private bool $stop = false;\n    private $socket;\n    private array $clientSockets = [];\n    private $afterCallback;\n    private $tickerCallback;\n    private $routerCallback;\n\n    public function __construct(string $host, int $port, OutputInterface $output)\n    {\n        $this->host = $host;\n        $this->port = $port;\n        $this->output = $output;\n    }\n\n    public function checkRequiredExtensionsExists(): void\n    {\n        if (!extension_loaded('sockets')) {\n            throw new \\Exception(\"The sockets extension is required for this server.\");\n        }\n    }\n\n    public function run(): void\n    {\n        $this->createServerSocket();\n\n        if (is_callable($this->afterCallback)) {\n            ($this->afterCallback)();\n        }\n\n        while (!$this->stop) {\n            $read = $this->clientSockets;\n            $read[] = $this->socket;\n            $write = null;\n            $except = null;\n\n            if (@stream_select($read, $write, $except, 0, 10000) > 0) {\n                $this->acceptNewConnections();\n                $this->handleClientRequests();\n            }\n\n            if (is_callable($this->tickerCallback)) {\n                ($this->tickerCallback)();\n            }\n        }\n\n        fclose($this->socket);\n    }\n\n    private function createServerSocket()\n    {\n        $this->socket = stream_socket_server(\"tcp://{$this->host}:{$this->port}\", $errno, $errstr);\n\n        if (!$this->socket) {\n            throw new \\Exception(\"Could not create server socket: [$errno] $errstr\");\n        }\n\n        stream_set_blocking($this->socket, false);\n        $this->updatePort();\n    }\n\n    private function updatePort(): void\n    {\n        $name = stream_socket_get_name($this->socket, false);\n        $this->port = (int)substr(strrchr($name, ':'), 1);\n    }\n\n    private function acceptNewConnections(): void\n    {\n        if (in_array($this->socket, $read)) {\n            $clientSocket = stream_socket_accept($this->socket);\n            if ($clientSocket) {\n                stream_set_blocking($clientSocket, false);\n                $this->clientSockets[] = $clientSocket;\n            }\n        }\n    }\n\n    private function handleClientRequests(): void\n    {\n        foreach ($this->clientSockets as $key => $clientSocket) {\n            if (in_array($clientSocket, $read)) {\n                try {\n                    $request = $this->readClientRequest($clientSocket);\n                    if ($request !== false && $request !== '') {\n                        list($path, $payload) = $this->parseRequest($request);\n                        $response = ($this->routerCallback)($path, $payload, $clientSocket);\n                        $this->sendResponse($clientSocket, $response);\n                    }\n                } catch (\\Exception $e) {\n                    $this->output->writeln($e->getMessage());\n                    $this->closeClientSocket($clientSocket, $key);\n                }\n            }\n        }\n    }\n\n\n    private function readClientRequest($clientSocket): string|false\n    {\n        $buffer = '';\n        while (!feof($clientSocket)) {\n            $data = fread($clientSocket, 1024);\n            if ($data === false || $data === '') {\n                return $buffer;\n            }\n            $buffer .= $data;\n            if (strpos($buffer, \"\\r\\n\\r\\n\") !== false) {\n                return $buffer;\n            }\n        }\n        return $buffer;\n    }\n\n    private function parseRequest(string $request): array\n    {\n        $lines = explode(\"\\r\\n\", $request);\n        $firstLine = explode(' ', $lines[0]);\n        $path = $firstLine[1];\n        $payload = \"\";\n        return [$path, $payload];\n    }\n\n    private function sendResponse(resource $clientSocket, Response $response): void\n    {\n        fwrite($clientSocket, (string)$response);\n    }\n\n    private function closeClientSocket(resource $clientSocket, int $key): void\n    {\n        fclose($clientSocket);\n        unset($this->clientSockets[$key]);\n    }\n\n    public function afterRun(Closure $param): void\n    {\n        $this->afterCallback = $param;\n    }\n\n    public function ticker(Closure $param): void\n    {\n        $this->tickerCallback = $param;\n    }\n\n    public function router(Closure $param): void\n    {\n        $this->routerCallback = $param;\n    }\n\n    public function stop(): void\n    {\n        $this->stop = true;\n    }\n}\n\ninterface OutputInterface\n{\n    public function writeln(string $message);\n}\n\nclass Response\n{\n    private string $body;\n    private array $headers = [];\n    private string $protocolVersion = '1.1';\n    private int $statusCode = 200;\n    private string $statusText = 'OK';\n\n    public function __construct(string $body = '', int $statusCode = 200, array $headers = [])\n    {\n        $this->body = $body;\n        $this->statusCode = $statusCode;\n        $this->headers = $headers;\n        $this->statusText = $this->getStatusTextForCode($statusCode);\n    }\n\n    private function getStatusTextForCode(int $code): string\n    {\n        $statusTexts = [\n            200 => 'OK',\n            404 => 'Not Found',\n            500 => 'Internal Server Error',\n        ];\n        return $statusTexts[$code] ?? 'Unknown Status';\n    }\n\n    public function __toString(): string\n    {\n        $headers = '';\n        foreach ($this->headers as $name => $value) {\n            $headers .= \"$name: $value\\r\\n\";\n        }\n        return \"HTTP/{$this->protocolVersion} {$this->statusCode} {$this->statusText}\\r\\n{$headers}\\r\\n{$this->body}\";\n    }\n}\n",
      "<?php\n\nclass Server\n{\n    private string $host;\n    private int $port;\n    private OutputInterface $output;\n    private bool $stop = false;\n    private $socket;\n    private array $clientSockets = [];\n    private Closure $afterCallback;\n    private Closure $tickerCallback;\n    private Closure $routerCallback;\n\n\n    public function __construct(string $host, int $port, OutputInterface $output)\n    {\n        $this->host = $host;\n        $this->port = $port;\n        $this->output = $output;\n    }\n\n    public function checkRequiredExtensionsExists(): void\n    {\n        if (!extension_loaded('sockets')) {\n            throw new \\Exception(\"The sockets extension is not loaded.\");\n        }\n    }\n\n    public function run(): void\n    {\n        $this->createServerSocket();\n\n        $this->afterCallback && ($this->afterCallback)();\n\n        while (!$this->stop) {\n            $this->acceptNewConnections();\n            $this->handleClientRequests();\n\n            $this->tickerCallback && ($this->tickerCallback)();\n        }\n\n        fclose($this->socket);\n    }\n\n    private function createServerSocket()\n    {\n        $this->socket = stream_socket_server(\"tcp://{$this->host}:{$this->port}\", $errno, $errstr);\n\n        if (!$this->socket) {\n            throw new \\Exception(\"Could not create server socket: [$errno] $errstr\");\n        }\n\n        stream_set_blocking($this->socket, false);\n        $this->updatePort();\n    }\n\n    private function updatePort(): void\n    {\n        $name = stream_socket_get_name($this->socket, false);\n        $this->port = (int)substr(strrchr($name, ':'), 1);\n    }\n\n\n    private function acceptNewConnections(): void\n    {\n        $newSocket = stream_socket_accept($this->socket, 0);\n        if ($newSocket) {\n            stream_set_blocking($newSocket, false);\n            $this->clientSockets[] = $newSocket;\n        }\n    }\n\n    private function handleClientRequests(): void\n    {\n        foreach ($this->clientSockets as $key => $clientSocket) {\n            $request = $this->readClientRequest($clientSocket);\n\n            if ($request !== false && $request !== '') {\n                [$path, $payload] = $this->parseRequest($request);\n\n                $response = ($this->routerCallback)($path, $payload);\n\n                $this->sendResponse($clientSocket, $response);\n            }\n        }\n    }\n\n    private function readClientRequest($clientSocket): string|false\n    {\n        return fread($clientSocket, 8192);\n    }\n\n    private function parseRequest(string $request): array\n    {\n        $parts = explode(\"\\r\\n\\r\\n\", $request, 2);\n        $headers = explode(\"\\r\\n\", $parts[0]);\n        $path = parse_url($headers[0], PHP_URL_PATH);\n        $payload = $parts[1] ?? '';\n        return [$path, $payload];\n    }\n\n    private function sendResponse($clientSocket, Response $response): void\n    {\n        fwrite($clientSocket, (string)$response);\n    }\n\n\n    private function closeClientSocket($clientSocket, int $key): void\n    {\n        fclose($clientSocket);\n        unset($this->clientSockets[$key]);\n    }\n\n    public function afterRun(Closure $param): void\n    {\n        $this->afterCallback = $param;\n    }\n\n    public function ticker(Closure $param): void\n    {\n        $this->tickerCallback = $param;\n    }\n\n    public function router(Closure $param): void\n    {\n        $this->routerCallback = $param;\n    }\n\n    public function stop(): void\n    {\n        $this->stop = true;\n    }\n}\n\ninterface OutputInterface {}\nclass Response {\n    public function __construct(private string $body){}\n    public function __toString(): string { return $this->body; }\n}\n",
      "<?php\n\nclass Server\n{\n    private string $host;\n    private int $port;\n    private OutputInterface $output;\n    private bool $stop = false;\n    private $socket;\n    private array $clientSockets = [];\n    private $afterCallback;\n    private $tickerCallback;\n    private $routerCallback;\n\n    public function __construct(string $host, int $port, OutputInterface $output)\n    {\n        $this->host = $host;\n        $this->port = $port;\n        $this->output = $output;\n    }\n\n    public function checkRequiredExtensionsExists(): void\n    {\n        if (!extension_loaded('sockets')) {\n            throw new \\Exception(\"The extension 'sockets' is required.\");\n        }\n    }\n\n    public function run(): void\n    {\n        $this->createServerSocket();\n\n        if (is_callable($this->afterCallback)) {\n            ($this->afterCallback)();\n        }\n\n        while (!$this->stop) {\n            $read = $this->clientSockets;\n            $read[] = $this->socket;\n            $write = null;\n            $except = null;\n\n            if (@stream_select($read, $write, $except, 0, 10000) > 0) {\n                $this->acceptNewConnections();\n                $this->handleClientRequests();\n            }\n\n            if (is_callable($this->tickerCallback)) {\n                ($this->tickerCallback)();\n            }\n        }\n\n        fclose($this->socket);\n    }\n\n    private function createServerSocket()\n    {\n        $this->socket = stream_socket_server(\"tcp://{$this->host}:{$this->port}\", $errno, $errstr);\n        if (!$this->socket) {\n            throw new \\Exception(\"Could not create server socket: {$errstr}\");\n        }\n        stream_set_blocking($this->socket, false);\n        $this->updatePort();\n    }\n\n    private function updatePort(): void\n    {\n        $name = stream_socket_get_name($this->socket, false);\n        $this->port = (int)substr(strrchr($name, ':'), 1);\n    }\n\n    private function acceptNewConnections(): void\n    {\n        if (in_array($this->socket, $read)) {\n            $clientSocket = stream_socket_accept($this->socket);\n            if ($clientSocket) {\n                stream_set_blocking($clientSocket, false);\n                $this->clientSockets[] = $clientSocket;\n            }\n        }\n    }\n\n    private function handleClientRequests(): void\n    {\n        foreach ($this->clientSockets as $key => $clientSocket) {\n            if (in_array($clientSocket, $read)) {\n                try {\n                    $request = $this->readClientRequest($clientSocket);\n                    if ($request !== false && $request !== '') {\n                        list($path, $payload) = $this->parseRequest($request);\n                        $response = ($this->routerCallback)($path, $payload);\n                        $this->sendResponse($clientSocket, $response);\n                    }\n                } catch (\\Exception $e) {\n                    $this->output->writeln($e->getMessage());\n                    $this->closeClientSocket($clientSocket, $key);\n                }\n            }\n        }\n    }\n\n\n    private function readClientRequest($clientSocket): string|false\n    {\n        $buffer = '';\n        while (true) {\n            $data = fread($clientSocket, 1024);\n            if ($data === false || $data === '') {\n                break;\n            }\n            $buffer .= $data;\n            if (strpos($buffer, \"\\r\\n\\r\\n\") !== false) {\n                break;\n            }\n        }\n        return $buffer;\n    }\n\n    private function parseRequest(string $request): array\n    {\n        $lines = explode(\"\\r\\n\", $request);\n        $firstLine = explode(' ', $lines[0]);\n        $path = $firstLine[1];\n        $payload = '';\n        return [$path, $payload];\n    }\n\n    private function sendResponse(resource $clientSocket, Response $response): void\n    {\n        fwrite($clientSocket, (string)$response);\n    }\n\n    private function closeClientSocket(resource $clientSocket, int $key): void\n    {\n        fclose($clientSocket);\n        unset($this->clientSockets[$key]);\n    }\n\n    public function afterRun(Closure $param): void\n    {\n        $this->afterCallback = $param;\n    }\n\n    public function ticker(Closure $param): void\n    {\n        $this->tickerCallback = $param;\n    }\n\n    public function router(Closure $param): void\n    {\n        $this->routerCallback = $param;\n    }\n\n    public function stop(): void\n    {\n        $this->stop = true;\n    }\n}\n\ninterface OutputInterface\n{\n    public function writeln(string $message): void;\n}\n\nclass Response\n{\n    private string $body;\n    private int $statusCode;\n    private array $headers;\n\n    public function __construct(string $body = '', int $statusCode = 200, array $headers = [])\n    {\n        $this->body = $body;\n        $this->statusCode = $statusCode;\n        $this->headers = $headers;\n    }\n\n    public function __toString(): string\n    {\n        $response = \"HTTP/1.1 {$this->statusCode} OK\\r\\n\";\n        foreach ($this->headers as $header => $value) {\n            $response .= \"{$header}: {$value}\\r\\n\";\n        }\n        $response .= \"\\r\\n{$this->body}\";\n        return $response;\n    }\n}\n",
      "<?php\n\nclass Server\n{\n    private string $host;\n    private int $port;\n    private OutputInterface $output;\n    private bool $stop = false;\n    private $socket;\n    private array $clientSockets = [];\n    private $afterCallback;\n    private $tickerCallback;\n    private $routerCallback;\n\n    public function __construct(string $host, int $port, OutputInterface $output)\n    {\n        $this->host = $host;\n        $this->port = $port;\n        $this->output = $output;\n    }\n\n    public function checkRequiredExtensionsExists(): void\n    {\n        if (!extension_loaded('sockets')) {\n            throw new \\Exception(\"The sockets extension is required for this example.\");\n        }\n    }\n\n\n    public function run(): void\n    {\n        $this->createServerSocket();\n\n        if ($this->afterCallback) {\n            ($this->afterCallback)();\n        }\n\n        while (!$this->stop) {\n            $read = $this->clientSockets;\n            $read[] = $this->socket;\n            $write = null;\n            $except = null;\n\n            if (@stream_select($read, $write, $except, 0, 10000) > 0) {\n                $this->acceptNewConnections();\n                $this->handleClientRequests();\n            }\n\n            if ($this->tickerCallback) {\n                ($this->tickerCallback)();\n            }\n        }\n\n        fclose($this->socket);\n    }\n\n    private function createServerSocket()\n    {\n        $this->socket = stream_socket_server(\"tcp://{$this->host}:{$this->port}\", $errno, $errstr);\n\n        if (!$this->socket) {\n            throw new \\Exception(\"Could not create server socket: [$errno] $errstr\");\n        }\n\n        stream_set_blocking($this->socket, false);\n        $this->updatePort();\n    }\n\n    private function updatePort(): void\n    {\n        $name = stream_socket_get_name($this->socket, false);\n        $this->port = (int)substr(strrchr($name, ':'), 1);\n    }\n\n    private function acceptNewConnections(): void\n    {\n        if (in_array($this->socket, $read)) {\n            $clientSocket = stream_socket_accept($this->socket);\n\n            if ($clientSocket) {\n                stream_set_blocking($clientSocket, false);\n                $this->clientSockets[] = $clientSocket;\n            }\n\n            $key = array_search($this->socket, $read);\n            unset($read[$key]);\n        }\n    }\n\n    private function handleClientRequests(): void\n    {\n        foreach ($read as $clientSocket) {\n            $request = $this->readClientRequest($clientSocket);\n\n            if ($request !== false) {\n                if ($request === '') {\n                    $this->closeClientSocket($clientSocket, $key);\n                    continue;\n                }\n\n                [$path, $payload] = $this->parseRequest($request);\n\n                $response = ($this->routerCallback)($path, $payload);\n                $this->sendResponse($clientSocket, $response);\n            }\n        }\n    }\n\n    private function readClientRequest($clientSocket): string|false\n    {\n        $buffer = '';\n        while (!feof($clientSocket)) {\n            $data = fread($clientSocket, 8192);\n            if ($data === false || strlen($data) === 0) {\n                return '';\n            }\n            $buffer .= $data;\n            if (strpos($buffer, \"\\r\\n\\r\\n\") !== false) {\n                break;\n            }\n        }\n        return $buffer;\n    }\n\n\n    private function parseRequest(string $request): array\n    {\n        $lines = explode(\"\\r\\n\", $request);\n        $firstLine = explode(' ', $lines[0]);\n        $path = $firstLine[1];\n        $payload = '';\n\n        return [$path, $payload];\n    }\n\n    private function sendResponse(resource $clientSocket, Response $response): void\n    {\n        fwrite($clientSocket, (string)$response);\n    }\n\n    private function closeClientSocket(resource $clientSocket, int $key): void\n    {\n        fclose($clientSocket);\n        unset($this->clientSockets[$key]);\n    }\n\n    public function afterRun(Closure $param): void\n    {\n        $this->afterCallback = $param;\n    }\n\n    public function ticker(Closure $param): void\n    {\n        $this->tickerCallback = $param;\n    }\n\n    public function router(Closure $param): void\n    {\n        $this->routerCallback = $param;\n    }\n\n    public function stop(): void\n    {\n        $this->stop = true;\n    }\n}\n\ninterface OutputInterface {}\nclass Response {\n    public function __toString(): string { return '';}\n}\n",
      "<?php\n\nclass Server\n{\n    private string $host;\n    private int $port;\n    private OutputInterface $output;\n    private bool $stop = false;\n    private $socket;\n    private array $clientSockets = [];\n    private $afterCallback;\n    private $tickerCallback;\n    private $routerCallback;\n\n    public function __construct(string $host, int $port, OutputInterface $output)\n    {\n        $this->host = $host;\n        $this->port = $port;\n        $this->output = $output;\n    }\n\n    public function checkRequiredExtensionsExists(): void\n    {\n        if (!extension_loaded('sockets')) {\n            throw new \\Exception(\"The sockets extension is required for this server.\");\n        }\n    }\n\n    public function run(): void\n    {\n        $this->createServerSocket();\n\n        if (is_callable($this->afterCallback)) {\n            ($this->afterCallback)();\n        }\n\n        while (!$this->stop) {\n            $read = array_merge([$this->socket], $this->clientSockets);\n            $write = $except = null;\n            if (@stream_select($read, $write, $except, 0, 200000) > 0) { // Check for new connections/requests\n                if (in_array($this->socket, $read)) {\n                    $this->acceptNewConnections();\n                    unset($read[array_search($this->socket, $read)]);\n                }\n                $this->handleClientRequests($read);\n            }\n\n            if (is_callable($this->tickerCallback)) {\n                ($this->tickerCallback)();\n            }\n        }\n\n        fclose($this->socket);\n    }\n\n    private function createServerSocket()\n    {\n        $this->socket = stream_socket_server(\"tcp://{$this->host}:{$this->port}\", $errno, $errstr);\n        if (!$this->socket) {\n            throw new \\Exception(\"Could not create server socket: [$errno] $errstr\");\n        }\n        stream_set_blocking($this->socket, false);\n        $this->updatePort();\n    }\n\n    private function updatePort(): void\n    {\n        $name = stream_socket_get_name($this->socket, false);\n        $this->port = (int)substr(strrchr($name, ':'), 1);\n    }\n\n    private function acceptNewConnections(): void\n    {\n        $clientSocket = stream_socket_accept($this->socket);\n        if ($clientSocket) {\n            stream_set_blocking($clientSocket, false);\n            $this->clientSockets[] = $clientSocket;\n        }\n    }\n\n    private function handleClientRequests(array $read): void\n    {\n        foreach ($read as $clientSocket) {\n            $request = $this->readClientRequest($clientSocket);\n            if ($request !== false && $request !== '') {\n                $parsedRequest = $this->parseRequest($request);\n                $response = new Response();\n                if (is_callable($this->routerCallback)) {\n                    ($this->routerCallback)($parsedRequest, $response);\n                }\n                $this->sendResponse($clientSocket, $response);\n            } else {\n                $key = array_search($clientSocket, $this->clientSockets);\n                if ($key !== false) {\n                    $this->closeClientSocket($clientSocket, $key);\n                }\n            }\n        }\n    }\n\n\n    private function readClientRequest($clientSocket): string|false\n    {\n        $buffer = '';\n        while (!feof($clientSocket)) {\n            $data = fread($clientSocket, 1024);\n            if ($data === false || $data === '') {\n                return false; // Connection closed or error\n            }\n            $buffer .= $data;\n            if (strpos($buffer, \"\\r\\n\\r\\n\") !== false) {\n                break; // End of request headers\n            }\n        }\n        return $buffer;\n    }\n\n    private function parseRequest(string $request): array\n    {\n        $lines = explode(\"\\r\\n\", $request);\n        $firstLine = explode(' ', $lines[0]);\n        $path = $firstLine[1];\n        $payload = \"\";\n\n        return ['path' => $path, 'payload' => $payload];\n    }\n\n    private function sendResponse($clientSocket, Response $response): void\n    {\n        fwrite($clientSocket, (string)$response);\n    }\n\n    private function closeClientSocket($clientSocket, int $key): void\n    {\n        fclose($clientSocket);\n        unset($this->clientSockets[$key]);\n    }\n\n    public function afterRun(Closure $param): void\n    {\n        $this->afterCallback = $param;\n    }\n\n    public function ticker(Closure $param): void\n    {\n        $this->tickerCallback = $param;\n    }\n\n    public function router(Closure $param): void\n    {\n        $this->routerCallback = $param;\n    }\n\n    public function stop(): void\n    {\n        $this->stop = true;\n    }\n}\n\nclass Response\n{\n    private string $response = '';\n\n    public function send(string $message): void\n    {\n        $this->response = $message;\n    }\n\n    public function __toString(): string\n    {\n        return $this->response;\n    }\n}\n\ninterface OutputInterface\n{\n    public function write(string $message): void;\n}\n",
      "<?php\n\nclass Server\n{\n    private string $host;\n    private int $port;\n    private OutputInterface $output;\n    private bool $stop = false;\n    private $socket;\n    private array $clientSockets = [];\n    private $afterCallback;\n    private $tickerCallback;\n    private $routerCallback;\n\n    public function __construct(string $host, int $port, OutputInterface $output)\n    {\n        $this->host = $host;\n        $this->port = $port;\n        $this->output = $output;\n    }\n\n    public function checkRequiredExtensionsExists(): void\n    {\n        if (!extension_loaded('sockets')) {\n            throw new \\Exception(\"The sockets extension is required for this server.\");\n        }\n    }\n\n\n    public function run(): void\n    {\n        $this->createServerSocket();\n\n        if (is_callable($this->afterCallback)) {\n            ($this->afterCallback)();\n        }\n\n        while (!$this->stop) {\n            $this->acceptNewConnections();\n            $this->handleClientRequests();\n\n            if (is_callable($this->tickerCallback)) {\n                ($this->tickerCallback)();\n            }\n\n            usleep(1000);\n        }\n\n        fclose($this->socket);\n    }\n\n    private function createServerSocket()\n    {\n        $this->socket = stream_socket_server(\"tcp://{$this->host}:{$this->port}\", $errno, $errstr);\n\n        if (!$this->socket) {\n            throw new \\Exception(\"Could not create server socket: [$errno] $errstr\");\n        }\n\n        stream_set_blocking($this->socket, false);\n        $this->updatePort();\n    }\n\n    private function updatePort(): void\n    {\n        $name = stream_socket_get_name($this->socket, false);\n        $this->port = (int)substr(strrchr($name, ':'), 1);\n    }\n\n\n    private function acceptNewConnections(): void\n    {\n        $newSocket = @stream_socket_accept($this->socket, 0);\n        if ($newSocket) {\n            stream_set_blocking($newSocket, false);\n            $this->clientSockets[] = $newSocket;\n        }\n    }\n\n    private function handleClientRequests(): void\n    {\n        foreach ($this->clientSockets as $key => $clientSocket) {\n            $request = $this->readClientRequest($clientSocket);\n            if ($request !== false && $request !== '') {\n                $parsedRequest = $this->parseRequest($request);\n                $response = new Response();\n\n                if (is_callable($this->routerCallback)) {\n                    ($this->routerCallback)($parsedRequest, $response);\n                }\n\n                $this->sendResponse($clientSocket, $response);\n            }\n        }\n    }\n\n    private function readClientRequest($clientSocket): string|false\n    {\n        return @fread($clientSocket, 8192);\n    }\n\n    private function parseRequest(string $request): array\n    {\n        $parts = explode(\"\\r\\n\\r\\n\", $request, 2);\n        $headers = explode(\"\\r\\n\", $parts[0]);\n        $path = explode(\" \", $headers[0])[1];\n        $payload = $parts[1] ?? '';\n        return ['path' => $path, 'payload' => $payload];\n    }\n\n\n    private function sendResponse($clientSocket, Response $response): void\n    {\n        fwrite($clientSocket, (string)$response);\n    }\n\n    private function closeClientSocket($clientSocket, int $key): void\n    {\n        fclose($clientSocket);\n        unset($this->clientSockets[$key]);\n    }\n\n    public function afterRun(Closure $param): void\n    {\n        $this->afterCallback = $param;\n    }\n\n    public function ticker(Closure $param): void\n    {\n        $this->tickerCallback = $param;\n    }\n\n    public function router(Closure $param): void\n    {\n        $this->routerCallback = $param;\n    }\n\n    public function stop(): void\n    {\n        $this->stop = true;\n    }\n}\n\nclass Response\n{\n    private string $response = '';\n\n    public function send(string $message): void\n    {\n        $this->response = $message;\n    }\n\n    public function __toString(): string\n    {\n        return $this->response;\n    }\n}\n\ninterface OutputInterface\n{\n    public function write(string $message): void;\n}\n",
      "<?php\n\nclass Server\n{\n    private string $host;\n    private int $port;\n    private OutputInterface $output;\n    private bool $stop = false;\n    private $socket;\n    private array $clientSockets = [];\n    private $afterCallback;\n    private $tickerCallback;\n    private $routerCallback;\n\n    public function __construct(string $host, int $port, OutputInterface $output)\n    {\n        $this->host = $host;\n        $this->port = $port;\n        $this->output = $output;\n    }\n\n    public function checkRequiredExtensionsExists(): void\n    {\n        if (!extension_loaded('sockets')) {\n            throw new \\Exception(\"The sockets extension is required for this example.\");\n        }\n    }\n\n    public function run(): void\n    {\n        $this->createServerSocket();\n\n        $this->afterRun($this->afterCallback);\n\n        while (!$this->stop) {\n            $this->acceptNewConnections();\n            $this->handleClientRequests();\n\n            $this->ticker($this->tickerCallback);\n        }\n\n        fclose($this->socket);\n    }\n\n    private function createServerSocket()\n    {\n        $this->socket = stream_socket_server(\"tcp://{$this->host}:{$this->port}\", $errno, $errstr);\n\n        if (!$this->socket) {\n            throw new \\Exception(\"Could not create server socket: [$errno] $errstr\");\n        }\n\n        stream_set_blocking($this->socket, false);\n        $this->updatePort();\n    }\n\n    private function updatePort(): void\n    {\n        $name = stream_socket_get_name($this->socket, false);\n        $this->port = (int)substr(strrchr($name, ':'), 1);\n    }\n\n\n    private function acceptNewConnections(): void\n    {\n        $newSocket = @stream_socket_accept($this->socket, 0);\n        if ($newSocket) {\n            stream_set_blocking($newSocket, false);\n            $this->clientSockets[] = $newSocket;\n        }\n    }\n\n    private function handleClientRequests(): void\n    {\n        foreach ($this->clientSockets as $key => $clientSocket) {\n            $request = $this->readClientRequest($clientSocket);\n            if ($request !== false && $request !== '') {\n                [$path, $payload] = $this->parseRequest($request);\n                $response = ($this->routerCallback)($path, $payload, $clientSocket);\n                $this->sendResponse($clientSocket, $response);\n            }\n        }\n    }\n\n    private function readClientRequest($clientSocket): string|false\n    {\n        return @fread($clientSocket, 8192);\n    }\n\n    private function parseRequest(string $request): array\n    {\n        $lines = explode(\"\\r\\n\", $request);\n        $firstLine = explode(' ', $lines[0]);\n        $path = $firstLine[1];\n        $payload = json_decode(file_get_contents('php://input'), true);\n        return [$path, $payload];\n    }\n\n    private function sendResponse($clientSocket, Response $response): void\n    {\n        $data = $response->format();\n        @fwrite($clientSocket, $data);\n    }\n\n    private function closeClientSocket($clientSocket, int $key): void\n    {\n        fclose($clientSocket);\n        unset($this->clientSockets[$key]);\n    }\n\n    public function afterRun(Closure $param): void\n    {\n        $this->afterCallback = $param;\n    }\n\n    public function ticker(Closure $param): void\n    {\n        $this->tickerCallback = $param;\n    }\n\n    public function router(Closure $param): void\n    {\n        $this->routerCallback = $param;\n    }\n\n    public function stop(): void\n    {\n        $this->stop = true;\n    }\n}\n\ninterface OutputInterface {}\nclass Response {\n    public function format() {}\n}\n",
      "<?php\n\nclass Server\n{\n    private string $host;\n    private int $port;\n    private OutputInterface $output;\n    private bool $stop = false;\n    private $socket;\n    private array $clientSockets = [];\n    private $afterCallback;\n    private $tickerCallback;\n    private $routerCallback;\n\n    public function __construct(string $host, int $port, OutputInterface $output)\n    {\n        $this->host = $host;\n        $this->port = $port;\n        $this->output = $output;\n    }\n\n    public function checkRequiredExtensionsExists(): void\n    {\n        if (!extension_loaded('sockets')) {\n            throw new \\Exception(\"The extension 'sockets' is required.\");\n        }\n    }\n\n\n    public function run(): void\n    {\n        $this->createServerSocket();\n\n        if ($this->afterCallback) {\n            ($this->afterCallback)();\n        }\n\n        while (!$this->stop) {\n            $read = $this->clientSockets;\n            $read[] = $this->socket;\n            $write = null;\n            $except = null;\n\n            if (@stream_select($read, $write, $except, 0, 10000) > 0) {\n                $this->acceptNewConnections();\n                $this->handleClientRequests();\n            }\n\n            if ($this->tickerCallback) {\n                ($this->tickerCallback)();\n            }\n        }\n\n        fclose($this->socket);\n    }\n\n    private function createServerSocket()\n    {\n        $this->socket = stream_socket_server(\"tcp://{$this->host}:{$this->port}\", $errno, $errstr);\n\n        if (!$this->socket) {\n            throw new \\Exception(\"Could not create server socket: [$errno] $errstr\");\n        }\n\n        stream_set_blocking($this->socket, false);\n        $this->updatePort();\n    }\n\n    private function updatePort(): void\n    {\n        $name = stream_socket_get_name($this->socket, false);\n        $this->port = (int)substr(strrchr($name, ':'), 1);\n    }\n\n    private function acceptNewConnections(): void\n    {\n        if (in_array($this->socket, $read)) {\n            $clientSocket = stream_socket_accept($this->socket);\n\n            if ($clientSocket) {\n                stream_set_blocking($clientSocket, false);\n                $this->clientSockets[] = $clientSocket;\n            }\n\n            $key = array_search($this->socket, $read);\n            unset($read[$key]);\n        }\n    }\n\n    private function handleClientRequests(): void\n    {\n        foreach ($read as $clientSocket) {\n            $request = $this->readClientRequest($clientSocket);\n\n            if ($request !== false) {\n                if ($request === '') {\n                    $this->closeClientSocket($clientSocket, $key);\n                    continue;\n                }\n\n                [$path, $payload] = $this->parseRequest($request);\n\n                $response = ($this->routerCallback)($path, $payload);\n\n                $this->sendResponse($clientSocket, $response);\n            }\n        }\n    }\n\n    private function readClientRequest($clientSocket): string|false\n    {\n        $buffer = '';\n        while (!feof($clientSocket)) {\n            $data = fread($clientSocket, 1024);\n            if ($data === false || $data === '') {\n                return false;\n            }\n            $buffer .= $data;\n            if (strpos($buffer, \"\\r\\n\\r\\n\") !== false) {\n                break;\n            }\n        }\n        return $buffer;\n    }\n\n    private function parseRequest(string $request): array\n    {\n        $lines = explode(\"\\r\\n\", $request);\n        $firstLine = explode(' ', $lines[0]);\n        $path = $firstLine[1];\n        $payload = '';\n        return [$path, $payload];\n    }\n\n\n    private function sendResponse(resource $clientSocket, Response $response): void\n    {\n        fwrite($clientSocket, (string)$response);\n    }\n\n    private function closeClientSocket(resource $clientSocket, int $key): void\n    {\n        fclose($clientSocket);\n        unset($this->clientSockets[$key]);\n    }\n\n    public function afterRun(Closure $param): void\n    {\n        $this->afterCallback = $param;\n    }\n\n    public function ticker(Closure $param): void\n    {\n        $this->tickerCallback = $param;\n    }\n\n    public function router(Closure $param): void\n    {\n        $this->routerCallback = $param;\n    }\n\n    public function stop(): void\n    {\n        $this->stop = true;\n    }\n}\n\ninterface OutputInterface {}\nclass Response {\n    public function __toString(): string {\n        return \"HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\\r\\n\\r\\n\";\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a function that executes a shell command and captures its output using PHP's proc_open for inter-process communication.\n\nFunction Description: The function executes a given shell command as a subprocess and returns its standard output. It handles both string and array command formats, manages Windows code page settings if applicable, and ensures proper cleanup of resources. The function returns null if proc_open is unavailable or if process creation fails.\n\nInput: \n- $command: string|array - The shell command to execute, either as a string or array of arguments\n\nOutput: \n- ?string - The captured standard output from the command, or null if execution failed",
    "Canonical_solution": "function readFromProcess(string|array $command): ?string\n{\n    if (!\\function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    $cp = \\function_exists('sapi_windows_cp_set') ? sapi_windows_cp_get() : 0;\n\n    $process = proc_open($command, $descriptorspec, $pipes, null, null, ['suppress_errors' => true]);\n    if (!\\is_resource($process)) {\n        return null;\n    }\n\n    $info = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n    proc_close($process);\n\n    if ($cp) {\n        sapi_windows_cp_set($cp);\n    }\n\n    return $info;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "<?php\n\nfunction executeShellCommand($command) {\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'], // stdin\n        1 => ['pipe', 'w'], // stdout\n        2 => ['pipe', 'w'], // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $returnCode = proc_close($process);\n\n    if ($returnCode !== 0 && $error) {\n        trigger_error($error, E_USER_WARNING);\n    }\n\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n        $output = mb_convert_encoding($output, 'UTF-8', 'Windows-1252');\n    }\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction executeShellCommand($command) {\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'], // stdin\n        1 => ['pipe', 'w'], // stdout\n        2 => ['pipe', 'w'], // stderr\n    ];\n\n    $pipes = [];\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $returnCode = proc_close($process);\n\n    if ($returnCode !== 0 && $error) {\n        trigger_error($error, E_USER_WARNING);\n    }\n\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction executeShellCommand($command) {\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_value = proc_close($process);\n\n    if ($return_value !== 0) {\n      trigger_error(\"Command execution failed with return code: \" . $return_value . \"\\nError: \" . $error, E_USER_WARNING);\n    }\n\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction executeShellCommand($command) {\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'], // stdin\n        1 => ['pipe', 'w'], // stdout\n        2 => ['pipe', 'w'], // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $returnCode = proc_close($process);\n\n    if ($returnCode !== 0) {\n      trigger_error(\"Command failed with code $returnCode. Error: $error\", E_USER_WARNING);\n    }\n\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n        $output = mb_convert_encoding($output, 'UTF-8', 'Windows-1252');\n    }\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction executeShellCommand($command) {\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'], // stdin\n        1 => ['pipe', 'w'], // stdout\n        2 => ['pipe', 'w'], // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $returnCode = proc_close($process);\n\n    if ($returnCode !== 0) {\n      trigger_error(\"Command failed with exit code: \" . $returnCode . \"\\nError: \" . $error, E_USER_WARNING);\n    }\n\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n        $output = mb_convert_encoding($output, 'UTF-8', 'Windows-1252');\n    }\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction executeShellCommand($command) {\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_value = proc_close($process);\n\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n        $output = mb_convert_encoding($output, 'UTF-8', 'Windows-1252');\n    }\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction executeShellCommand($command) {\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'], // stdin\n        1 => ['pipe', 'w'], // stdout\n        2 => ['pipe', 'w'], // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $returnCode = proc_close($process);\n\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n        $output = mb_convert_encoding($output, 'UTF-8', 'Windows-1252');\n    }\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction executeShellCommand($command) {\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'], // stdin\n        1 => ['pipe', 'w'], // stdout\n        2 => ['pipe', 'w'], // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $returnCode = proc_close($process);\n\n    if ($returnCode !== 0 && $error) {\n        trigger_error($error, E_USER_WARNING);\n    }\n\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n        $output = mb_convert_encoding($output, 'UTF-8', 'Windows-1252');\n    }\n    \n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction executeShellCommand($command) {\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_value = proc_close($process);\n\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n        $output = mb_convert_encoding($output, 'UTF-8', 'Windows-1252');\n    }\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction executeShellCommand($command) {\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $returnCode = proc_close($process);\n\n    if ($returnCode !== 0 && $error) {\n        trigger_error($error, E_USER_WARNING);\n    }\n\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n        $output = mb_convert_encoding($output, 'UTF-8', 'Windows-1252');\n    }\n\n    return $output;\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a function that generates an image from a DOT script using the Graphviz `dot` command-line tool through inter-process communication in PHP.\n\nFunction Description: The function takes a DOT script and an image type as input, executes the `dot` command with the specified type, and returns the generated image data. It handles the subprocess communication using pipes for stdin, stdout, and stderr, ensuring proper resource cleanup and error handling.\n\nInput: \n- $dot_script: string - The DOT language script to be processed by Graphviz\n- $type: string - The output image type (e.g., 'png', 'svg', 'jpg')\n\nOutput: \n- Returns: string - The binary data of the generated image\n- On error: Prints error message to stderr and exits the program",
    "Canonical_solution": "function xhprof_generate_image_by_dot($dot_script, $type) {\n  $descriptorspec = array(\n       // stdin is a pipe that the child will read from\n       0 => array(\"pipe\", \"r\"),\n       // stdout is a pipe that the child will write to\n       1 => array(\"pipe\", \"w\"),\n       // stderr is a pipe that the child will write to\n       2 => array(\"pipe\", \"w\")\n       );\n\n  $cmd = \" dot -T\".$type;\n\n  $process = proc_open( $cmd, $descriptorspec, $pipes, sys_get_temp_dir(), array( 'PATH' => getenv( 'PATH' ) );\n  if (is_resource($process)) {\n    fwrite($pipes[0], $dot_script);\n    fclose($pipes[0]);\n\n    $output = stream_get_contents($pipes[1]);\n\n    $err = stream_get_contents($pipes[2]);\n    if (!empty($err)) {\n      print \"failed to execute cmd: \\\"$cmd\\\". stderr: `$err'\\n\";\n      exit;\n    }\n\n    fclose($pipes[2]);\n    fclose($pipes[1]);\n    proc_close($process);\n    return $output;\n  }\n  print \"failed to execute cmd \\\"$cmd\\\"\";\n  exit();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "<?php\n\nfunction generate_image_from_dot($dot_script, $type) {\n    $descriptorspec = array(\n        0 => array(\"pipe\", \"r\"),  // stdin\n        1 => array(\"pipe\", \"w\"),  // stdout\n        2 => array(\"pipe\", \"w\"),  // stderr\n    );\n\n    $process = proc_open(\"dot -T\" . $type, $descriptorspec, $pipes);\n\n    if (is_resource($process)) {\n        fwrite($pipes[0], $dot_script);\n        fclose($pipes[0]);\n\n        $image_data = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error_message = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_value = proc_close($process);\n\n        if ($return_value !== 0) {\n            fwrite(STDERR, \"Error generating image: \" . $error_message);\n            exit(1);\n        }\n\n        return $image_data;\n    } else {\n        fwrite(STDERR, \"Error opening process.\");\n        exit(1);\n    }\n}\n\n?>\n",
      "<?php\n\nfunction generate_image_from_dot($dot_script, $type) {\n    $descriptorspec = array(\n        0 => array(\"pipe\", \"r\"),  // stdin\n        1 => array(\"pipe\", \"w\"),  // stdout\n        2 => array(\"pipe\", \"w\"),  // stderr\n    );\n\n    $process = proc_open(\"dot -T\" . escapeshellarg($type), $descriptorspec, $pipes);\n\n    if (is_resource($process)) {\n        fwrite($pipes[0], $dot_script);\n        fclose($pipes[0]);\n\n        $image_data = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error_message = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_value = proc_close($process);\n\n        if ($return_value !== 0) {\n            fwrite(STDERR, \"Error generating image: \" . $error_message);\n            exit(1);\n        }\n\n        return $image_data;\n    } else {\n        fwrite(STDERR, \"Error opening process.\");\n        exit(1);\n    }\n}\n\n?>\n",
      "<?php\n\nfunction generate_image_from_dot($dot_script, $type) {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open(\"dot -T\" . escapeshellarg($type), $descriptorspec, $pipes);\n\n    if (is_resource($process)) {\n        fwrite($pipes[0], $dot_script);\n        fclose($pipes[0]);\n\n        $image_data = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error_message = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_value = proc_close($process);\n\n        if ($return_value !== 0) {\n            fwrite(STDERR, \"Error generating image: \" . $error_message);\n            exit(1);\n        }\n\n        return $image_data;\n    } else {\n        fwrite(STDERR, \"Error opening process.\");\n        exit(1);\n    }\n}\n\n?>\n",
      "<?php\n\nfunction generate_image_from_dot($dot_script, $type) {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open(\"dot -T\" . escapeshellarg($type), $descriptorspec, $pipes);\n\n    if (is_resource($process)) {\n        fwrite($pipes[0], $dot_script);\n        fclose($pipes[0]);\n\n        $image_data = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error_message = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_value = proc_close($process);\n\n        if ($return_value !== 0) {\n            fwrite(STDERR, \"Error generating image: \" . $error_message);\n            exit(1);\n        }\n\n        return $image_data;\n    } else {\n        fwrite(STDERR, \"Error opening process.\");\n        exit(1);\n    }\n}\n\n?>\n",
      "<?php\n\nfunction generate_image_from_dot($dot_script, $type) {\n    $descriptorspec = array(\n        0 => array(\"pipe\", \"r\"),  // stdin\n        1 => array(\"pipe\", \"w\"),  // stdout\n        2 => array(\"pipe\", \"w\")   // stderr\n    );\n\n    $process = proc_open(\"dot -T\" . $type, $descriptorspec, $pipes);\n\n    if (is_resource($process)) {\n        fwrite($pipes[0], $dot_script);\n        fclose($pipes[0]);\n\n        $image_data = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error_message = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_value = proc_close($process);\n\n        if ($return_value != 0) {\n            fwrite(STDERR, \"Error generating image: \" . $error_message);\n            exit(1);\n        }\n\n        return $image_data;\n    } else {\n        fwrite(STDERR, \"Error opening process.\");\n        exit(1);\n    }\n}\n\n?>\n",
      "<?php\n\nfunction generate_image_from_dot($dot_script, $type) {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open(\"dot -T\" . escapeshellarg($type), $descriptorspec, $pipes);\n\n    if (is_resource($process)) {\n        fwrite($pipes[0], $dot_script);\n        fclose($pipes[0]);\n\n        $image_data = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error_message = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_value = proc_close($process);\n\n        if ($return_value !== 0) {\n            fwrite(STDERR, \"Error generating image: \" . $error_message);\n            exit(1);\n        }\n\n        return $image_data;\n    } else {\n        fwrite(STDERR, \"Error opening process.\");\n        exit(1);\n    }\n}\n\n?>\n",
      "<?php\n\nfunction generate_image_from_dot($dot_script, $type) {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open(\"dot -T\" . escapeshellarg($type), $descriptorspec, $pipes);\n\n    if (is_resource($process)) {\n        fwrite($pipes[0], $dot_script);\n        fclose($pipes[0]);\n\n        $image_data = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error_message = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_value = proc_close($process);\n\n        if ($return_value !== 0) {\n            fwrite(STDERR, \"Error generating image: \" . $error_message);\n            exit(1);\n        }\n\n        return $image_data;\n    } else {\n        fwrite(STDERR, \"Error opening process.\");\n        exit(1);\n    }\n}\n\n?>\n",
      "<?php\n\nfunction generate_image_from_dot($dot_script, $type) {\n    $descriptorspec = array(\n        0 => array(\"pipe\", \"r\"),  // stdin\n        1 => array(\"pipe\", \"w\"),  // stdout\n        2 => array(\"pipe\", \"w\"),  // stderr\n    );\n\n    $process = proc_open(\"dot -T\" . $type, $descriptorspec, $pipes);\n\n    if (is_resource($process)) {\n        fwrite($pipes[0], $dot_script);\n        fclose($pipes[0]);\n\n        $image_data = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error_message = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_value = proc_close($process);\n\n        if ($return_value != 0) {\n            fwrite(STDERR, \"Error generating image: \" . $error_message);\n            exit(1);\n        }\n\n        return $image_data;\n    } else {\n        fwrite(STDERR, \"Error opening process.\");\n        exit(1);\n    }\n}\n\n?>\n",
      "<?php\n\nfunction generate_image_from_dot($dot_script, $type) {\n    $descriptorspec = array(\n        0 => array(\"pipe\", \"r\"),  // stdin\n        1 => array(\"pipe\", \"w\"),  // stdout\n        2 => array(\"pipe\", \"w\"),  // stderr\n    );\n\n    $process = proc_open(\"dot -T\" . $type, $descriptorspec, $pipes);\n\n    if (is_resource($process)) {\n        fwrite($pipes[0], $dot_script);\n        fclose($pipes[0]);\n\n        $image_data = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error_message = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_value = proc_close($process);\n\n        if ($return_value !== 0) {\n            fwrite(STDERR, \"Error generating image: \" . $error_message);\n            exit(1);\n        }\n\n        return $image_data;\n    } else {\n        fwrite(STDERR, \"Error opening process.\");\n        exit(1);\n    }\n}\n\n?>\n",
      "<?php\n\nfunction generate_image_from_dot($dot_script, $type) {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open(\"dot -T\" . escapeshellarg($type), $descriptorspec, $pipes);\n\n    if (is_resource($process)) {\n        fwrite($pipes[0], $dot_script);\n        fclose($pipes[0]);\n\n        $image_data = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error_message = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_value = proc_close($process);\n\n        if ($return_value !== 0) {\n            fwrite(STDERR, \"Error generating image: \" . $error_message);\n            exit(1);\n        }\n\n        return $image_data;\n    } else {\n        fwrite(STDERR, \"Error opening process.\");\n        exit(1);\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a PHP class that manages a subprocess using proc_open, providing methods to initialize, communicate with, and terminate the process, while handling errors and resource cleanup.\n\nClass Description: The ProcessStream class manages a subprocess execution through pipes for stdin, stdout, and stderr communication. It handles process initialization, error checking, and proper resource cleanup.\n\nAttributes:\n- command: string - The command to be executed in the subprocess\n- stream: resource - The process resource created by proc_open\n- in: resource - The stdin pipe for writing to the subprocess\n- out: resource - The stdout pipe for reading from the subprocess\n\nMethods:\n- setCommand(string $command) -> void - Sets the command to be executed by the subprocess\n- initialize() -> void - Starts the subprocess, sets up communication pipes, and checks for startup errors\n- terminate() -> void - Closes all pipes and terminates the subprocess\n- getReadConnectionDescription() -> string - Returns a description of the process connection (for logging/debugging)",
    "Canonical_solution": "namespace Symfony\\Component\\Mailer\\Transport\\Smtp\\Stream;\n\nuse Symfony\\Component\\Mailer\\Exception\\TransportException;\n\nfinal class ProcessStream extends AbstractStream\n{\n    private string $command;\n\n    public function setCommand(string $command)\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorSpec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n        $pipes = [];\n        $this->stream = proc_open($this->command, $descriptorSpec, $pipes);\n        stream_set_blocking($pipes[2], false);\n        if ($err = stream_get_contents($pipes[2])) {\n            throw new TransportException('Process could not be started: '.$err);\n        }\n        $this->in = &$pipes[0];\n        $this->out = &$pipes[1];\n    }\n\n    public function terminate(): void\n    {\n        if (null !== $this->stream) {\n            fclose($this->in);\n            fclose($this->out);\n            proc_close($this->stream);\n        }\n\n        parent::terminate();\n    }\n\n    protected function getReadConnectionDescription(): string\n    {\n        return 'process '.$this->command;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n    private $err;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException('Failed to start process.');\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        $this->err = $pipes[2];\n\n        stream_set_blocking($this->out, false);\n        stream_set_blocking($this->err, false);\n    }\n\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->err)) {\n            fclose($this->err);\n        }\n\n        if (is_resource($this->stream)) {\n            $returnCode = proc_close($this->stream);\n            if ($returnCode !== 0) {\n                throw new \\RuntimeException(\"Process exited with error code: $returnCode\");\n            }\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        return stream_get_meta_data($this->out)['uri'] ?? 'No connection established';\n    }\n\n    public function writeToStdin(string $input): void\n    {\n        if (!is_resource($this->in)) {\n            throw new \\RuntimeException(\"Input stream is not a valid resource.\");\n        }\n        fwrite($this->in, $input);\n    }\n\n    public function readFromStdout(): string\n    {\n        if (!is_resource($this->out)) {\n            throw new \\RuntimeException(\"Output stream is not a valid resource.\");\n        }\n        return stream_get_contents($this->out);\n    }\n\n    public function readFromStderr(): string\n    {\n        if (!is_resource($this->err)) {\n            throw new \\RuntimeException(\"Error stream is not a valid resource.\");\n        }\n        return stream_get_contents($this->err);\n    }\n}\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n    private $err;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException('Failed to start process.');\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        $this->err = $pipes[2];\n\n        stream_set_blocking($this->out, false);\n        stream_set_blocking($this->err, false);\n    }\n\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->err)) {\n            fclose($this->err);\n        }\n\n        if (is_resource($this->stream)) {\n            $returnCode = proc_close($this->stream);\n            if ($returnCode !== 0) {\n                throw new \\RuntimeException(\"Process exited with error code: \" . $returnCode);\n            }\n        }\n\n        $this->stream = null;\n        $this->in = null;\n        $this->out = null;\n        $this->err = null;\n\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        return stream_get_meta_data($this->out)['uri'] ?? 'Stream not initialized';\n    }\n\n\n}\n?>\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n    private $err;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException('Failed to start process.');\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        $this->err = $pipes[2];\n\n        stream_set_blocking($this->out, false);\n        stream_set_blocking($this->err, false);\n    }\n\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->err)) {\n            fclose($this->err);\n        }\n\n        if (is_resource($this->stream)) {\n            $returnCode = proc_close($this->stream);\n            if ($returnCode !== 0) {\n                throw new \\RuntimeException(\"Process exited with error code: $returnCode\");\n            }\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return 'Process not initialized.';\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta['uri'] ?? 'Unknown stream URI';\n    }\n\n    public function writeToStdin(string $input): void\n    {\n        if (!is_resource($this->in)) {\n            throw new \\RuntimeException('Input stream is not available.');\n        }\n        fwrite($this->in, $input);\n    }\n\n    public function readFromStdout(): string\n    {\n        if (!is_resource($this->out)) {\n            throw new \\RuntimeException('Output stream is not available.');\n        }\n        return stream_get_contents($this->out);\n    }\n\n    public function readFromStderr(): string\n    {\n        if (!is_resource($this->err)) {\n            throw new \\RuntimeException('Error stream is not available.');\n        }\n        return stream_get_contents($this->err);\n    }\n}\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n    private $err;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException('Failed to start process.');\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        $this->err = $pipes[2];\n\n        stream_set_blocking($this->out, false);\n        stream_set_blocking($this->err, false);\n    }\n\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->err)) {\n            fclose($this->err);\n        }\n\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return 'Process not initialized.';\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta['uri'] ?? 'Unknown stream URI';\n    }\n\n    public function writeToStdin(string $input): void\n    {\n        if (!is_resource($this->in)) {\n            throw new \\RuntimeException('Input stream is not available.');\n        }\n        fwrite($this->in, $input);\n    }\n\n    public function readFromStdout(): string\n    {\n        if (!is_resource($this->out)) {\n            return '';\n        }\n\n        $output = stream_get_contents($this->out);\n        return $output === false ? '' : $output;\n    }\n\n    public function readFromStderr(): string\n    {\n        if (!is_resource($this->err)) {\n            return '';\n        }\n        $error = stream_get_contents($this->err);\n        return $error === false ? '' : $error;\n\n    }\n}\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n    private $err;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException('Failed to start process.');\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        $this->err = $pipes[2];\n\n        stream_set_blocking($this->out, false);\n        stream_set_blocking($this->err, false);\n    }\n\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->err)) {\n            fclose($this->err);\n        }\n\n        if (is_resource($this->stream)) {\n            $returnCode = proc_close($this->stream);\n            if ($returnCode !== 0) {\n                throw new \\RuntimeException(\"Process exited with error code: $returnCode\");\n            }\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return 'Process not initialized.';\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta['uri'] ?? 'Unknown stream URI';\n    }\n\n    public function writeToStdin(string $input): void\n    {\n        if (!is_resource($this->in)) {\n            throw new \\RuntimeException('Input stream is not available.');\n        }\n        fwrite($this->in, $input);\n    }\n\n    public function readFromStdout(): string\n    {\n        if (!is_resource($this->out)) {\n            return '';\n        }\n\n        $output = stream_get_contents($this->out);\n        return $output === false ? '' : $output;\n    }\n\n    public function readFromStderr(): string\n    {\n        if (!is_resource($this->err)) {\n            return '';\n        }\n        $error = stream_get_contents($this->err);\n        return $error === false ? '' : $error;\n\n    }\n}\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n    private $err;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException('Failed to start process.');\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        $this->err = $pipes[2];\n\n        stream_set_blocking($this->out, false);\n        stream_set_blocking($this->err, false);\n    }\n\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->err)) {\n            fclose($this->err);\n        }\n\n        if (is_resource($this->stream)) {\n            $returnCode = proc_close($this->stream);\n            if ($returnCode !== 0) {\n                throw new \\RuntimeException(\"Process exited with error code: $returnCode\");\n            }\n        }\n\n\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return 'Process not initialized.';\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta['uri'] ?? 'Unknown stream URI';\n    }\n\n\n    public function writeToStdin(string $input): void\n    {\n      if (!is_resource($this->in)) {\n          throw new \\RuntimeException(\"Input stream is not a valid resource.\");\n      }\n      fwrite($this->in, $input);\n    }\n\n    public function readFromStdout(): string\n    {\n        if (!is_resource($this->out)) {\n            throw new \\RuntimeException(\"Output stream is not a valid resource.\");\n        }\n        return stream_get_contents($this->out);\n    }\n\n    public function readFromStderr(): string {\n        if (!is_resource($this->err)) {\n            throw new \\RuntimeException(\"Error stream is not a valid resource.\");\n        }\n        return stream_get_contents($this->err);\n    }\n}\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n    private $err;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException('Failed to start process.');\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        $this->err = $pipes[2];\n\n        stream_set_blocking($this->out, false);\n        stream_set_blocking($this->err, false);\n    }\n\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->err)) {\n            fclose($this->err);\n        }\n\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n\n        $this->stream = null;\n        $this->in = null;\n        $this->out = null;\n        $this->err = null;\n\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return 'Process not initialized.';\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta['uri'] ?? 'Unknown stream URI';\n\n    }\n\n\n    public function writeToStdin(string $input) : void {\n        if (!is_resource($this->in)) {\n            throw new \\RuntimeException('Input stream is not available.');\n        }\n        fwrite($this->in, $input);\n    }\n\n    public function readFromStdout() : string {\n        if (!is_resource($this->out)) {\n            throw new \\RuntimeException('Output stream is not available.');\n        }\n\n        return stream_get_contents($this->out);\n    }\n\n    public function readFromStderr() : string {\n        if (!is_resource($this->err)) {\n            throw new \\RuntimeException('Error stream is not available.');\n        }\n        return stream_get_contents($this->err);\n\n    }\n\n\n}\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n    private $err;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException('Failed to start process.');\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        $this->err = $pipes[2];\n\n        stream_set_blocking($this->out, false);\n        stream_set_blocking($this->err, false);\n    }\n\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->err)) {\n            fclose($this->err);\n        }\n\n        if (is_resource($this->stream)) {\n            $returnCode = proc_close($this->stream);\n            if ($returnCode !== 0) {\n                throw new \\RuntimeException(\"Process exited with error code: $returnCode\");\n            }\n        }\n\n        $this->stream = null;\n        $this->in = null;\n        $this->out = null;\n        $this->err = null;\n\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return 'Process not initialized.';\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta['uri'] ?? 'Unknown stream URI';\n    }\n\n    public function writeToStdin(string $input): void\n    {\n        if (!is_resource($this->in)) {\n            throw new \\RuntimeException('Input stream is not available.');\n        }\n        fwrite($this->in, $input);\n    }\n\n    public function readFromStdout(): string\n    {\n        if (!is_resource($this->out)) {\n            return ''; // Or throw an exception, depending on desired behavior\n        }\n        return stream_get_contents($this->out);\n    }\n\n    public function readFromStderr(): string\n    {\n        if (!is_resource($this->err)) {\n            return ''; // Or throw an exception, depending on desired behavior\n        }\n        return stream_get_contents($this->err);\n    }\n\n\n}\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n    private $err;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException('Failed to start process.');\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        $this->err = $pipes[2];\n\n        stream_set_blocking($this->out, false);\n        stream_set_blocking($this->err, false);\n    }\n\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->err)) {\n            fclose($this->err);\n        }\n\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n\n        $this->stream = null;\n        $this->in = null;\n        $this->out = null;\n        $this->err = null;\n\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return 'Process not initialized.';\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta['uri'] ?? 'Unknown stream URI';\n\n    }\n\n\n    public function writeToStdin(string $input) : void {\n        if (!is_resource($this->in)) {\n            throw new \\RuntimeException('Input stream is not available.');\n        }\n        fwrite($this->in, $input);\n    }\n\n    public function readFromStdout() : string {\n        if (!is_resource($this->out)) {\n            throw new \\RuntimeException('Output stream is not available.');\n        }\n        return stream_get_contents($this->out);\n    }\n\n    public function readFromStderr() : string {\n        if (!is_resource($this->err)) {\n            throw new \\RuntimeException('Error stream is not available.');\n        }\n        return stream_get_contents($this->err);\n    }\n\n\n}\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n    private $err;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException('Failed to start process.');\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        $this->err = $pipes[2];\n\n        stream_set_blocking($this->out, false);\n        stream_set_blocking($this->err, false);\n    }\n\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->err)) {\n            fclose($this->err);\n        }\n\n        if (is_resource($this->stream)) {\n            $return_value = proc_close($this->stream);\n            if ($return_value !== 0) {\n                throw new \\RuntimeException(\"Process exited with error code: $return_value\");\n            }\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return 'Process not initialized.';\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta['uri'] ?? 'Unknown stream URI';\n    }\n\n    public function writeToStdin(string $input): void\n    {\n        if (!is_resource($this->in)) {\n            throw new \\RuntimeException('Input stream not available.');\n        }\n        fwrite($this->in, $input);\n    }\n\n    public function readFromStdout(): string\n    {\n        if (!is_resource($this->out)) {\n            throw new \\RuntimeException('Output stream not available.');\n        }\n        return stream_get_contents($this->out);\n    }\n\n    public function readFromStderr(): string\n    {\n        if (!is_resource($this->err)) {\n            throw new \\RuntimeException('Error stream not available.');\n        }\n        return stream_get_contents($this->err);\n    }\n}\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 138,
    "Instruction": "Task Description: Create a function that retrieves Git tag information from a specified directory using subprocess communication via pipes.\n\nFunction Description: The function checks if a given directory is a Git repository (by checking for .git folder) and then executes the 'git describe --tags' command to get the latest tag information. It handles subprocess communication using pipes for stdout and stderr, properly manages resources, and returns the tag information or false if unsuccessful.\n\nInput: \n- $path (string): The filesystem path to check for Git repository information\n\nOutput:\n- Returns either:\n  - (string) The trimmed output from 'git describe --tags' command if successful\n  - (bool) false if:\n    - The path is not a Git repository\n    - The subprocess cannot be created\n    - The command returns a non-zero exit code",
    "Canonical_solution": "function getGitInformation(string $path)\n{\n    if (!\\is_dir($path . DIRECTORY_SEPARATOR . '.git')) {\n        return false;\n    }\n\n    $process = \\proc_open(\n        'git describe --tags',\n        [\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ],\n        $pipes,\n        $path\n    );\n\n    if (!\\is_resource($process)) {\n        return false;\n    }\n\n    $result = \\trim(\\stream_get_contents($pipes[1]));\n\n    \\fclose($pipes[1]);\n    \\fclose($pipes[2]);\n\n    $returnCode = \\proc_close($process);\n\n    if ($returnCode !== 0) {\n        return false;\n    }\n\n    return $result;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "<?php\n\nfunction get_git_tag_from_directory(string $path): string|false {\n    if (!is_dir($path . '/.git')) {\n        return false;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptorspec, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_value = proc_close($process);\n\n    if ($return_value !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n",
      "<?php\n\nfunction get_git_tag_from_directory(string $path): string|false {\n    if (!is_dir($path . '/.git')) {\n        return false;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptorspec, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_value = proc_close($process);\n\n    if ($return_value !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n",
      "```php\n<?php\n\nfunction get_git_tag_from_directory(string $path): string|false {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction get_git_tag_from_directory(string $path): string|false {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|false {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "<?php\n\nfunction get_git_tag_from_directory(string $path): string|false {\n    if (!is_dir($path . '/.git')) {\n        return false;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptorspec, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n",
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|false {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "<?php\n\nfunction get_git_tag_from_directory(string $path): string|false {\n    if (!is_dir($path . '/.git')) {\n        return false;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptorspec, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_value = proc_close($process);\n\n    if ($return_value !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n",
      "```php\n<?php\n\nfunction get_git_tag_from_directory(string $path): string|false {\n    if (!is_dir($path . '/.git')) {\n        return false;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptorspec, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_value = proc_close($process);\n\n    if ($return_value !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "<?php\n\nfunction get_git_tag_info(string $path): string|false {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 139,
    "Instruction": "Task Description: Create a PHP class that manages subprocess execution using proc_open, handling input/output through pipes, with support for timeouts and temporary files.\n\nClass Description: The DefaultPhpProcess class provides functionality to execute subprocesses in PHP using proc_open, managing standard input/output/error streams through pipes. It supports timeout handling, environment variable configuration, and temporary file usage for large inputs.\n\nAttributes:\n- tempFile: [string|null] - Path to temporary file used for storing input when needed\n- stdin: [string|null] - Standard input content for the subprocess\n- env: [array|null] - Environment variables to pass to the subprocess\n- timeout: [int|null] - Maximum execution time in seconds before terminating the subprocess\n\nMethods:\n- runJob(string $job, array $settings = []): array - Executes a job with optional settings, returns output\n  Input: \n    - $job: [string] - The input content for the subprocess\n    - $settings: [array] - Additional execution settings\n  Output: [array] - Associative array containing 'stdout' and 'stderr' output\n\n- getHandles(): array - Returns additional stream handles for the subprocess\n  Output: [array] - Array of stream handles\n\n- runProcess(string $job, array $settings): array - Internal method to execute the subprocess\n  Input:\n    - $job: [string] - The input content\n    - $settings: [array] - Execution settings\n  Output: [array] - Associative array containing 'stdout' and 'stderr'\n\n- process(resource $pipe, string $job): void - Writes job content to the input pipe\n  Input:\n    - $pipe: [resource] - The input pipe resource\n    - $job: [string] - Content to write\n\n- cleanup(): void - Cleans up temporary resources (files)\n  \n- useTemporaryFile(): bool - Determines whether to use temporary files for input\n  Output: [bool] - True if temporary files should be used",
    "Canonical_solution": "use function array_merge;\nuse function fclose;\nuse function file_put_contents;\nuse function fread;\nuse function fwrite;\nuse function is_array;\nuse function is_resource;\nuse function proc_close;\nuse function proc_open;\nuse function proc_terminate;\nuse function rewind;\nuse function sprintf;\nuse function stream_get_contents;\nuse function stream_select;\nuse function sys_get_temp_dir;\nuse function tempnam;\nuse function unlink;\nuse PHPUnit\\Framework\\Exception;\n\nclass DefaultPhpProcess\n{\n    protected $tempFile;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        if ($this->stdin || $this->useTemporaryFile()) {\n            if (!($this->tempFile = tempnam(sys_get_temp_dir(), 'PHPUnit')) ||\n                file_put_contents($this->tempFile, $job) === false) {\n                throw new Exception(\n                    'Unable to write temporary file',\n                );\n            }\n\n            $job = $this->stdin;\n        }\n\n        return $this->runProcess($job, $settings);\n    }\n\n    protected function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $handles = $this->getHandles();\n\n        $env = null;\n\n        if ($this->env) {\n            $env = $_SERVER ?? [];\n            unset($env['argv'], $env['argc']);\n            $env = array_merge($env, $this->env);\n\n            foreach ($env as $envKey => $envVar) {\n                if (is_array($envVar)) {\n                    unset($env[$envKey]);\n                }\n            }\n        }\n\n        $pipeSpec = [\n            0 => $handles[0] ?? ['pipe', 'r'],\n            1 => $handles[1] ?? ['pipe', 'w'],\n            2 => $handles[2] ?? ['pipe', 'w'],\n        ];\n\n        $process = proc_open(\n            $this->getCommand($settings, $this->tempFile),\n            $pipeSpec,\n            $pipes,\n            null,\n            $env,\n        );\n\n        if (!is_resource($process)) {\n            throw new Exception(\n                'Unable to spawn worker process',\n            );\n        }\n\n        if ($job) {\n            $this->process($pipes[0], $job);\n        }\n\n        fclose($pipes[0]);\n\n        $stderr = $stdout = '';\n\n        if ($this->timeout) {\n            unset($pipes[0]);\n\n            while (true) {\n                $r = $pipes;\n                $w = null;\n                $e = null;\n\n                $n = @stream_select($r, $w, $e, $this->timeout);\n\n                if ($n === false) {\n                    break;\n                }\n\n                if ($n === 0) {\n                    proc_terminate($process, 9);\n\n                    throw new Exception(\n                        sprintf(\n                            'Job execution aborted after %d seconds',\n                            $this->timeout,\n                        ),\n                    );\n                }\n\n                if ($n > 0) {\n                    foreach ($r as $pipe) {\n                        $pipeOffset = 0;\n\n                        foreach ($pipes as $i => $origPipe) {\n                            if ($pipe === $origPipe) {\n                                $pipeOffset = $i;\n\n                                break;\n                            }\n                        }\n\n                        if (!$pipeOffset) {\n                            break;\n                        }\n\n                        $line = fread($pipe, 8192);\n\n                        if ($line === '' || $line === false) {\n                            fclose($pipes[$pipeOffset]);\n\n                            unset($pipes[$pipeOffset]);\n                        } elseif ($pipeOffset === 1) {\n                            $stdout .= $line;\n                        } else {\n                            $stderr .= $line;\n                        }\n                    }\n\n                    if (empty($pipes)) {\n                        break;\n                    }\n                }\n            }\n        } else {\n            if (isset($pipes[1])) {\n                $stdout = stream_get_contents($pipes[1]);\n\n                fclose($pipes[1]);\n            }\n\n            if (isset($pipes[2])) {\n                $stderr = stream_get_contents($pipes[2]);\n\n                fclose($pipes[2]);\n            }\n        }\n\n        if (isset($handles[1])) {\n            rewind($handles[1]);\n\n            $stdout = stream_get_contents($handles[1]);\n\n            fclose($handles[1]);\n        }\n\n        if (isset($handles[2])) {\n            rewind($handles[2]);\n\n            $stderr = stream_get_contents($handles[2]);\n\n            fclose($handles[2]);\n        }\n\n        proc_close($process);\n\n        $this->cleanup();\n\n        return ['stdout' => $stdout, 'stderr' => $stderr];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    protected function cleanup(): void\n    {\n        if ($this->tempFile) {\n            unlink($this->tempFile);\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "<?php\n\nclass DefaultPhpProcess\n{\n    private $tempFile = null;\n    private $stdin = null;\n    private $env = null;\n    private $timeout = null;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $job;\n        $this->env = $settings['env'] ?? null;\n        $this->timeout = $settings['timeout'] ?? null;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    private function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = [\n            0 => $this->useTemporaryFile() ? ['file', $this->tempFile, 'r'] : ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $process = proc_open($settings['cmd'], $descriptorspec, $pipes, $settings['cwd'] ?? null, $this->env);\n\n        if (is_resource($process)) {\n            if ($this->useTemporaryFile()) {\n                fclose($pipes[0]);\n            } else {\n                $this->process($pipes[0], $job);\n                fclose($pipes[0]);\n            }\n\n\n            $stdout = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n\n            $stderr = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n\n            $exitCode = proc_close($process);\n\n            $this->cleanup();\n\n            return ['stdout' => $stdout, 'stderr' => $stderr, 'exit_code' => $exitCode];\n        }\n\n        $this->cleanup();\n        return ['stdout' => '', 'stderr' => 'Failed to start process', 'exit_code' => -1];\n    }\n\n    private function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    private function cleanup(): void\n    {\n        if ($this->tempFile && file_exists($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    private function useTemporaryFile(): bool\n    {\n        if (isset($this->stdin) && strlen($this->stdin) > 1024) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $this->stdin);\n            return true;\n        }\n        return false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass DefaultPhpProcess\n{\n    private $tempFile = null;\n    private $stdin = null;\n    private $env = null;\n    private $timeout = null;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $job;\n        $this->env = $settings['env'] ?? null;\n        $this->timeout = $settings['timeout'] ?? null;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n\n    private function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = [\n            0 => $this->useTemporaryFile() ? ['file', $this->tempFile, 'r'] : ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $process = proc_open($settings['cmd'], $descriptorspec, $pipes, $settings['cwd'] ?? null, $this->env);\n\n\n        if (is_resource($process)) {\n            if ($this->useTemporaryFile()) {\n                fclose($pipes[0]);\n            } else {\n                $this->process($pipes[0], $job);\n                fclose($pipes[0]);\n            }\n\n            $stdout = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n\n            $stderr = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n\n            $exitCode = proc_close($process);\n\n            $this->cleanup();\n\n            return ['stdout' => $stdout, 'stderr' => $stderr, 'exit_code' => $exitCode];\n        }\n\n        $this->cleanup();\n        return ['stdout' => '', 'stderr' => 'Failed to start process', 'exit_code' => -1];\n    }\n\n    private function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    private function cleanup(): void\n    {\n        if ($this->tempFile && file_exists($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    private function useTemporaryFile(): bool\n    {\n        if (isset($this->stdin) && strlen($this->stdin) > 1024) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $this->stdin);\n            return true;\n        }\n        return false;\n    }\n}\n",
      "<?php\n\nclass DefaultPhpProcess\n{\n    private $tempFile = null;\n    private $stdin = null;\n    private $env = null;\n    private $timeout = null;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $job;\n        $this->env = $settings['env'] ?? null;\n        $this->timeout = $settings['timeout'] ?? null;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    private function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = [\n            0 => $this->useTemporaryFile() ? ['file', $this->tempFile, 'r'] : ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $process = proc_open($settings['cmd'], $descriptorspec, $pipes, $settings['cwd'] ?? null, $this->env);\n\n        if (is_resource($process)) {\n            if ($this->useTemporaryFile()) {\n                fclose($pipes[0]);\n            } else {\n                $this->process($pipes[0], $job);\n                fclose($pipes[0]);\n            }\n\n\n            $stdout = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n\n            $stderr = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n\n            $exitCode = proc_close($process);\n\n            $this->cleanup();\n\n            return ['stdout' => $stdout, 'stderr' => $stderr, 'exit_code' => $exitCode];\n        }\n\n        $this->cleanup();\n        return ['stdout' => '', 'stderr' => 'Failed to start process', 'exit_code' => -1];\n    }\n\n    private function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    private function cleanup(): void\n    {\n        if ($this->tempFile && file_exists($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    private function useTemporaryFile(): bool\n    {\n        if (isset($this->stdin) && strlen($this->stdin) > 1024) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $this->stdin);\n            return true;\n        }\n        return false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass DefaultPhpProcess\n{\n    private $tempFile = null;\n    private $stdin = null;\n    private $env = null;\n    private $timeout = null;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $job;\n        $this->env = $settings['env'] ?? null;\n        $this->timeout = $settings['timeout'] ?? null;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    private function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = [\n            0 => $this->useTemporaryFile() ? ['file', $this->tempFile, 'r'] : ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $process = proc_open($settings['cmd'], $descriptorspec, $pipes, $settings['cwd'] ?? null, $this->env);\n\n        if (is_resource($process)) {\n            if ($this->useTemporaryFile()) {\n                fclose($pipes[0]);\n            } else {\n                $this->process($pipes[0], $job);\n                fclose($pipes[0]);\n            }\n\n\n            $stdout = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n\n            $stderr = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n\n            $exitCode = proc_close($process);\n\n            $this->cleanup();\n\n            return ['stdout' => $stdout, 'stderr' => $stderr, 'exit_code' => $exitCode];\n        }\n\n        $this->cleanup();\n        return ['stdout' => '', 'stderr' => 'Failed to start process', 'exit_code' => -1];\n    }\n\n    private function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    private function cleanup(): void\n    {\n        if ($this->tempFile && file_exists($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    private function useTemporaryFile(): bool\n    {\n        if (isset($this->stdin) && strlen($this->stdin) > 1024) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $this->stdin);\n            return true;\n        }\n        return false;\n    }\n}\n",
      "<?php\n\nclass DefaultPhpProcess\n{\n    private $tempFile;\n    private $stdin;\n    private $env;\n    private $timeout;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $job;\n        $this->env = $settings['env'] ?? null;\n        $this->timeout = $settings['timeout'] ?? null;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    private function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = [\n            0 => $this->useTemporaryFile() ? ['file', $this->tempFile, 'r'] : ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $process = proc_open($settings['cmd'], $descriptorspec, $pipes, $settings['cwd'] ?? null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to open process.');\n        }\n\n        if ($this->useTemporaryFile()) {\n            fclose($pipes[0]);\n        } else {\n            $this->process($pipes[0], $job);\n            fclose($pipes[0]);\n        }\n\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['stdout' => $stdout, 'stderr' => $stderr, 'exit_code' => $exitCode];\n    }\n\n    private function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    private function cleanup(): void\n    {\n        if ($this->tempFile && file_exists($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    private function useTemporaryFile(): bool\n    {\n        if (isset($this->stdin) && strlen($this->stdin) > 1024) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $this->stdin);\n            return true;\n        }\n        return false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass DefaultPhpProcess\n{\n    private $tempFile;\n    private $stdin;\n    private $env;\n    private $timeout;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $job;\n        $this->env = $settings['env'] ?? null;\n        $this->timeout = $settings['timeout'] ?? null;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    private function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = [\n            0 => $this->useTemporaryFile() ? ['file', $this->tempFile, 'r'] : ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $process = proc_open($settings['cmd'], $descriptorspec, $pipes, $settings['cwd'] ?? null, $this->env);\n\n        if (!is_resource($process)) {\n            return ['stdout' => '', 'stderr' => 'Failed to open process.'];\n        }\n\n        if ($this->useTemporaryFile()) {\n            file_put_contents($this->tempFile, $job);\n        } else {\n            $this->process($pipes[0], $job);\n        }\n        fclose($pipes[0]);\n\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['stdout' => $stdout, 'stderr' => $stderr];\n    }\n\n    private function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    private function cleanup(): void\n    {\n        if ($this->tempFile && file_exists($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    private function useTemporaryFile(): bool\n    {\n        if (isset($this->stdin) && strlen($this->stdin) > 1024) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            return true;\n        }\n        return false;\n    }\n}\n",
      "<?php\n\nclass DefaultPhpProcess\n{\n    private $tempFile = null;\n    private $stdin = null;\n    private $env = null;\n    private $timeout = null;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $job;\n        $this->env = $settings['env'] ?? null;\n        $this->timeout = $settings['timeout'] ?? null;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    private function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = [\n            0 => $this->useTemporaryFile() ? ['file', $this->tempFile, 'r'] : ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $process = proc_open($settings['cmd'], $descriptorspec, $pipes, $settings['cwd'] ?? null, $this->env);\n\n        if (is_resource($process)) {\n            if ($this->useTemporaryFile()) {\n                fclose($pipes[0]);\n            } else {\n                $this->process($pipes[0], $job);\n                fclose($pipes[0]);\n            }\n\n\n            $stdout = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n\n            $stderr = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n\n            $exitCode = proc_close($process);\n\n            $this->cleanup();\n\n            return ['stdout' => $stdout, 'stderr' => $stderr, 'exit_code' => $exitCode];\n        }\n\n        $this->cleanup();\n        return ['stdout' => '', 'stderr' => 'Failed to start process', 'exit_code' => -1];\n    }\n\n    private function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    private function cleanup(): void\n    {\n        if ($this->tempFile && file_exists($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    private function useTemporaryFile(): bool\n    {\n        if (isset($this->stdin) && strlen($this->stdin) > 1024) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $this->stdin);\n            return true;\n        }\n        return false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass DefaultPhpProcess\n{\n    private $tempFile = null;\n    private $stdin = null;\n    private $env = null;\n    private $timeout = null;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $job;\n        $this->env = $settings['env'] ?? null;\n        $this->timeout = $settings['timeout'] ?? null;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    private function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = [\n            0 => $this->useTemporaryFile() ? ['file', $this->tempFile, 'r'] : ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $process = proc_open($settings['cmd'], $descriptorspec, $pipes, $settings['cwd'] ?? null, $this->env);\n\n        if (is_resource($process)) {\n            if ($this->useTemporaryFile()) {\n                fclose($pipes[0]);\n            } else {\n                $this->process($pipes[0], $job);\n                fclose($pipes[0]);\n            }\n\n\n            $stdout = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n\n            $stderr = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n\n            $exitCode = proc_close($process);\n\n            $this->cleanup();\n\n            return ['stdout' => $stdout, 'stderr' => $stderr, 'exit_code' => $exitCode];\n        }\n\n        $this->cleanup();\n        return ['stdout' => '', 'stderr' => 'Failed to start process', 'exit_code' => -1];\n    }\n\n    private function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    private function cleanup(): void\n    {\n        if ($this->tempFile && file_exists($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    private function useTemporaryFile(): bool\n    {\n        if (isset($this->stdin) && strlen($this->stdin) > 1024) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $this->stdin);\n            return true;\n        }\n        return false;\n    }\n}\n",
      "<?php\n\nclass DefaultPhpProcess\n{\n    private $tempFile;\n    private $stdin;\n    private $env;\n    private $timeout;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $job;\n        $this->env = $settings['env'] ?? null;\n        $this->timeout = $settings['timeout'] ?? null;\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    private function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = [\n            0 => $this->useTemporaryFile() ? ['file', $this->tempFile, 'r'] : ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $process = proc_open($settings['cmd'], $descriptorspec, $pipes, $settings['cwd'] ?? null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to open process.');\n        }\n\n\n        if ($this->useTemporaryFile()) {\n            fwrite(fopen($this->tempFile, 'w'), $job);\n        } else {\n            $this->process($pipes[0], $job);\n        }\n        fclose($pipes[0]);\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['stdout' => $stdout, 'stderr' => $stderr, 'exit_code' => $exitCode];\n    }\n\n    private function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    private function cleanup(): void\n    {\n        if ($this->tempFile && file_exists($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    private function useTemporaryFile(): bool\n    {\n        if (isset($this->stdin) && strlen($this->stdin) > 1024) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            return true;\n        }\n        return false;\n    }\n}\n",
      "<?php\n\nclass DefaultPhpProcess\n{\n    private $tempFile = null;\n    private $stdin = null;\n    private $env = null;\n    private $timeout = null;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $job;\n        $this->env = $settings['env'] ?? null;\n        $this->timeout = $settings['timeout'] ?? null;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    private function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = [\n            0 => $this->useTemporaryFile() ? ['file', $this->tempFile, 'r'] : ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $process = proc_open($settings['cmd'], $descriptorspec, $pipes, $settings['cwd'] ?? null, $this->env);\n\n        if (is_resource($process)) {\n            if ($this->useTemporaryFile()) {\n                fclose($pipes[0]);\n            } else {\n                $this->process($pipes[0], $job);\n                fclose($pipes[0]);\n            }\n\n            $stdout = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n\n            $stderr = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n\n            $exitCode = proc_close($process);\n\n            $this->cleanup();\n\n            return ['stdout' => $stdout, 'stderr' => $stderr, 'exit_code' => $exitCode];\n        }\n\n        $this->cleanup();\n        return ['stdout' => '', 'stderr' => 'Failed to start process', 'exit_code' => -1];\n    }\n\n    private function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    private function cleanup(): void\n    {\n        if ($this->tempFile && file_exists($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    private function useTemporaryFile(): bool\n    {\n        if (isset($this->stdin) && strlen($this->stdin) > 1024) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $this->stdin);\n            return true;\n        }\n        return false;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using Symfony's HTTP client components to handle HTTP requests and responses.\n\nClass Description: The `HttpClientKernel` class is a Symfony HTTP client implementation that handles HTTP requests by sending them to a server and processing the responses. It supports various request methods, headers, cookies, and body content (including form data and file uploads).\n\nAttributes:\n- client: [HttpClientInterface] - The Symfony HTTP client instance used to send requests\n\nMethods:\n- __construct([HttpClientInterface $client = null]) -> [void] - Initializes the HTTP client. If no client is provided, creates a new instance. Requires Symfony HTTP client component.\n- handle([Request $request], [int $type = HttpKernelInterface::MAIN_REQUEST], [bool $catch = true]) -> [Response] - Processes an HTTP request, sends it using the client, and returns the response. Handles headers, cookies, and request body.\n- getBody([Request $request]) -> [AbstractPart|null] - Prepares the request body content. Returns null for GET/HEAD requests, TextPart for raw content, or FormDataPart for form data including files.\n- getHeaders([Request $request]) -> [array] - Prepares request headers including cookies from the request object. Returns an array of headers.",
    "Canonical_solution": "use Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        if (null === $client && !class_exists(HttpClient::class)) {\n            throw new \\LogicException(sprintf('You cannot use \"%s\" as the HttpClient component is not installed. Try running \"composer require symfony/http-client\".', __CLASS__));\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = HttpKernelInterface::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $headers = $this->getHeaders($request);\n        $body = '';\n        if (null !== $part = $this->getBody($request)) {\n            $headers = array_merge($headers, $part->getPreparedHeaders()->toArray());\n            $body = $part->bodyToIterable();\n        }\n        $response = $this->client->request($request->getMethod(), $request->getUri(), [\n            'headers' => $headers,\n            'body' => $body,\n        ] + $request->attributes->get('http_client_options', []));\n\n        $response = new Response($response->getContent(!$catch), $response->getStatusCode(), $response->getHeaders(!$catch));\n\n        $response->headers->remove('X-Body-File');\n        $response->headers->remove('X-Body-Eval');\n        $response->headers->remove('X-Content-Digest');\n\n        $response->headers = new class($response->headers->all()) extends ResponseHeaderBag {\n            protected function computeCacheControlValue(): string\n            {\n                return $this->getCacheControlHeader();\n            }\n        };\n\n        return $response;\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (\\in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        if (!class_exists(AbstractPart::class)) {\n            throw new \\LogicException('You cannot pass non-empty bodies as the Mime component is not installed. Try running \"composer require symfony/mime\".');\n        }\n\n        if ($content = $request->getContent()) {\n            return new TextPart($content, 'utf-8', 'plain', '8bit');\n        }\n\n        $fields = $request->request->all();\n        foreach ($request->files->all() as $name => $file) {\n            $fields[$name] = DataPart::fromPath($file->getPathname(), $file->getClientOriginalName(), $file->getClientMimeType());\n        }\n\n        return new FormDataPart($fields);\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers as $key => $value) {\n            $headers[$key] = $value;\n        }\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name.'='.$value;\n        }\n        if ($cookies) {\n            $headers['cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 134,
    "matched_results": [
      "<?php\n\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $options = [\n            'headers' => $this->getHeaders($request),\n            'body' => $this->getBody($request),\n        ];\n\n        $method = $request->getMethod();\n        $url = $request->getUri();\n\n        try {\n            $response = $this->client->request($method, $url, $options);\n            return $this->createResponse($response);\n        } catch (\\Throwable $e) {\n            if ($catch) {\n                return new Response($e->getMessage(), 500);\n            }\n            throw $e;\n        }\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false && !empty($content)) {\n            return new TextPart($content, 'utf-8');\n        }\n\n\n        if ($request->files->count() > 0) {\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[$key] = $value;\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[$key] = DataPart::fromPath($file->getPathname());\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n    }\n\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            $headers[$name] = $values;\n        }\n\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name . '=' . $value;\n        }\n        if (!empty($cookies)) {\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n\n    private function createResponse(ResponseInterface $clientResponse): Response\n    {\n        $response = new Response(\n            $clientResponse->getContent(false),\n            $clientResponse->getStatusCode(),\n            $clientResponse->getHeaders()\n        );\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $options = [\n            'headers' => $this->getHeaders($request),\n            'body' => $this->getBody($request),\n        ];\n\n        try {\n            $response = $this->client->request($request->getMethod(), $request->getUri(), $options);\n            return $this->createResponse($response);\n        } catch (\\Throwable $e) {\n            if ($catch) {\n                return new Response($e->getMessage(), 500);\n            }\n            throw $e;\n        }\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false && !empty($content)) {\n            return new TextPart($content, 'utf-8', 'plain', '8bit');\n        }\n\n        if ($request->files->count() > 0) {\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[$key] = $value;\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[$key] = DataPart::fromPath($file->getPathname());\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n    }\n\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            $headers[$name] = $values;\n        }\n\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name . '=' . $value;\n        }\n        if (!empty($cookies)) {\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n\n    private function createResponse(ResponseInterface $clientResponse): Response\n    {\n        $response = new Response(\n            $clientResponse->getContent(false),\n            $clientResponse->getStatusCode(),\n            $clientResponse->getHeaders()\n        );\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $options = [\n            'headers' => $this->getHeaders($request),\n            'body' => $this->getBody($request),\n        ];\n\n        try {\n            $response = $this->client->request($request->getMethod(), $request->getUri(), $options);\n            return $this->createResponse($response);\n        } catch (\\Throwable $e) {\n            if ($catch) {\n                return new Response($e->getMessage(), 500);\n            }\n            throw $e;\n        }\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false && !empty($content)) {\n            return new TextPart($content, 'utf-8', 'plain', '8bit');\n        }\n\n        if ($request->files->count() > 0) {\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[$key] = $value;\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[$key] = DataPart::fromPath($file->getPathname());\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n    }\n\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            $headers[$name] = $values;\n        }\n\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name . '=' . $value;\n        }\n        if (!empty($cookies)) {\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n\n    private function createResponse(ResponseInterface $clientResponse): Response\n    {\n        $response = new Response(\n            $clientResponse->getContent(false),\n            $clientResponse->getStatusCode(),\n            $clientResponse->getHeaders(false)\n        );\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $options = [\n            'headers' => $this->getHeaders($request),\n            'body' => $this->getBody($request),\n        ];\n\n        try {\n            $response = $this->client->request($request->getMethod(), $request->getUri(), $options);\n            return $this->createResponse($response);\n        } catch (\\Throwable $e) {\n            if ($catch) {\n                return new Response($e->getMessage(), 500);\n            }\n            throw $e;\n        }\n    }\n\n    private function getBody(Request $request): AbstractPart|null\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false && !empty($content)) {\n            return new TextPart($content, 'utf-8', 'plain', '8bit');\n        }\n\n        if ($request->files->count() > 0) {\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[$key] = $value;\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[$key] = DataPart::fromPath($file->getPathname());\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n    }\n\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            $headers[$name] = $values;\n        }\n\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name . '=' . $value;\n        }\n        if (!empty($cookies)) {\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n\n    private function createResponse(ResponseInterface $clientResponse): Response\n    {\n        $response = new Response(\n            $clientResponse->getContent(false),\n            $clientResponse->getStatusCode(),\n            $clientResponse->getHeaders(false)\n        );\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $options = [\n            'headers' => $this->getHeaders($request),\n            'body' => $this->getBody($request),\n        ];\n\n        try {\n            $response = $this->client->request($request->getMethod(), $request->getUri(), $options);\n            return $this->createResponse($response);\n        } catch (\\Throwable $e) {\n            if ($catch) {\n                return new Response($e->getMessage(), 500);\n            }\n            throw $e;\n        }\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false && !empty($content)) {\n            return new TextPart($content, 'utf-8');\n        }\n\n\n        if ($request->files->count() > 0) {\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[$key] = $value;\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[$key] = DataPart::fromPath($file->getPathname());\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        if ($request->request->count() > 0) {\n            return new FormDataPart($request->request->all());\n        }\n\n        return null;\n    }\n\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            $headers[$name] = $values;\n        }\n\n        return $headers;\n    }\n\n    private function createResponse(ResponseInterface $clientResponse): Response\n    {\n        $response = new Response(\n            $clientResponse->getContent(false),\n            $clientResponse->getStatusCode(),\n            $clientResponse->getHeaders()\n        );\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $options = [\n            'headers' => $this->getHeaders($request),\n            'body' => $this->getBody($request),\n        ];\n\n        try {\n            $response = $this->client->request($request->getMethod(), $request->getUri(), $options);\n            return $this->createResponse($response);\n        } catch (\\Throwable $e) {\n            if ($catch) {\n                return new Response($e->getMessage(), 500);\n            }\n            throw $e;\n        }\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false && !empty($content)) {\n            return new TextPart($content, 'utf-8');\n        }\n\n        if ($request->files->count() > 0) {\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[$key] = $value;\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[$key] = DataPart::fromPath($file->getPathname());\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n    }\n\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $key => $values) {\n            $headers[$key] = $values[0];\n        }\n\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name . '=' . $value;\n        }\n        if (!empty($cookies)) {\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n\n    private function createResponse(ResponseInterface $clientResponse): Response\n    {\n        $response = new Response(\n            $clientResponse->getContent(false),\n            $clientResponse->getStatusCode(),\n            $clientResponse->getHeaders(false)\n        );\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $options = [\n            'headers' => $this->getHeaders($request),\n            'body' => $this->getBody($request),\n        ];\n\n        try {\n            $response = $this->client->request($request->getMethod(), $request->getUri(), $options);\n            return $this->createResponse($response);\n        } catch (\\Throwable $e) {\n            if ($catch) {\n                return new Response($e->getMessage(), 500);\n            }\n            throw $e;\n        }\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false && !empty($content)) {\n            return new TextPart($content, 'utf-8', 'plain', '8bit');\n        }\n\n        if ($request->files->count() > 0) {\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[$key] = $value;\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[$key] = DataPart::fromPath($file->getPathname());\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $key => $value) {\n            $headers[$key] = $value[0];\n        }\n\n        $cookies = [];\n        foreach ($request->cookies->all() as $key => $value) {\n            $cookies[] = $key . '=' . $value;\n        }\n        if (!empty($cookies)) {\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n\n\n    private function createResponse(ResponseInterface $clientResponse): Response\n    {\n        $response = new Response(\n            $clientResponse->getContent(false),\n            $clientResponse->getStatusCode(),\n            $clientResponse->getHeaders()\n        );\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $options = [\n            'headers' => $this->getHeaders($request),\n            'body' => $this->getBody($request),\n        ];\n\n        try {\n            $response = $this->client->request($request->getMethod(), $request->getUri(), $options);\n            return $this->createResponse($response);\n        } catch (\\Throwable $e) {\n            if ($catch) {\n                return new Response($e->getMessage(), 500);\n            }\n            throw $e;\n        }\n    }\n\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== false && !empty($content)) {\n            return new TextPart($content, 'utf-8', 'plain', '8bit');\n        }\n\n        if ($request->files->count() > 0) {\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[$key] = $value;\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[$key] = DataPart::fromPath($file->getPathname());\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return null;\n\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $key => $values) {\n            $headers[$key] = $values[0];\n        }\n\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name . '=' . $value;\n        }\n        if (!empty($cookies)) {\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n\n    private function createResponse(ResponseInterface $clientResponse): Response\n    {\n        $response = new Response(\n            $clientResponse->getContent(false),\n            $clientResponse->getStatusCode(),\n            $clientResponse->getHeaders(false)\n        );\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $options = [\n            'headers' => $this->getHeaders($request),\n            'body' => $this->getBody($request),\n        ];\n\n        try {\n            $response = $this->client->request($request->getMethod(), $request->getUri(), $options);\n            return $this->createResponse($response);\n        } catch (\\Throwable $e) {\n            if ($catch) {\n                return new Response($e->getMessage(), 500);\n            }\n            throw $e;\n        }\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== null) {\n            return new TextPart($content, 'utf-8');\n        }\n\n        if ($request->files->count() > 0) {\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[$key] = $value;\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[$key] = DataPart::fromPath($file->getPathname());\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        return new FormDataPart($request->request->all());\n\n\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            $headers[$name] = $values;\n        }\n\n        return $headers;\n    }\n\n    private function createResponse(ResponseInterface $clientResponse): Response\n    {\n        $response = new Response(\n            $clientResponse->getContent(false),\n            $clientResponse->getStatusCode(),\n            $clientResponse->getHeaders(false)\n        );\n\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\nuse Symfony\\Contracts\\HttpClient\\ResponseInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $options = [\n            'headers' => $this->getHeaders($request),\n            'body' => $this->getBody($request),\n        ];\n\n        $method = $request->getMethod();\n        $url = $request->getUri();\n\n        try {\n            $response = $this->client->request($method, $url, $options);\n            return $this->createResponse($response);\n        } catch (\\Throwable $e) {\n            if ($catch) {\n                return new Response($e->getMessage(), 500);\n            }\n            throw $e;\n        }\n    }\n\n    private function getBody(Request $request): AbstractPart|null\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n\n        if ($content !== null) {\n            return new TextPart($content, 'utf-8');\n        }\n\n\n        if ($request->files->count() > 0) {\n            $formData = [];\n            foreach ($request->request->all() as $key => $value) {\n                $formData[$key] = $value;\n            }\n            foreach ($request->files->all() as $key => $file) {\n                $formData[$key] = DataPart::fromPath($file->getPathname());\n            }\n            return new FormDataPart($formData);\n        }\n\n\n        if ($request->request->count() > 0) {\n            return new FormDataPart($request->request->all());\n        }\n\n        return null;\n    }\n\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            $headers[$name] = $values;\n        }\n\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name . '=' . $value;\n        }\n        if (!empty($cookies)) {\n            $headers['Cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n\n    private function createResponse(ResponseInterface $clientResponse): Response\n    {\n        $response = new Response(\n            $clientResponse->getContent(false),\n            $clientResponse->getStatusCode(),\n            $clientResponse->getHeaders(false)\n        );\n\n        return $response;\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a PHP class that facilitates the execution of shell commands as subprocesses, handling input/output streams, and providing process execution details.\n\nClass Description: The Process class provides a way to execute shell commands as subprocesses, capturing their output streams (stdout and stderr), return codes, and execution time. It includes methods for basic execution and error-checked execution variants.\n\nAttributes:\n\ncommand: [string] - The shell command to be executed\ncwd: [string|null] - The working directory for the command execution\nenv: [array] - Environment variables for the command\ndescriptors: [array] - Static array defining I/O streams configuration\nlog_run_times: [bool] - Static flag to enable execution time logging\nrun_times: [array] - Static array storing command execution time statistics\n\nMethods:\n\ncreate: [static](string $command, string|null $cwd = null, array $env = []) -> [Process] - Factory method to create a new Process instance\nrun: [](void) -> [ProcessRun] - Executes the command and returns execution details including stdout, stderr, and return code\nrun_check: [](void) -> [ProcessRun] - Executes the command and throws RuntimeException if return code is non-zero\nrun_check_stderr: [](void) -> [ProcessRun] - Executes the command and throws RuntimeException if return code is non-zero or if stderr contains unexpected output (with specific exception for known PSR-0 deprecation warning)",
    "Canonical_solution": "namespace WP_CLI;\n\nuse RuntimeException;\n\nclass Process {\n\tprivate $command;\n\tprivate $cwd;\n\tprivate $env;\n\tprivate static $descriptors = [\n\t\t0 => STDIN,\n\t\t1 => [ 'pipe', 'w' ],\n\t\t2 => [ 'pipe', 'w' ],\n\t];\n\tpublic static $log_run_times = false;\n\tpublic static $run_times = [];\n\n\tpublic static function create( $command, $cwd = null, $env = [] ) {\n\t\t$proc = new self();\n\t\t$proc->command = $command;\n\t\t$proc->cwd = $cwd;\n\t\t$proc->env = $env;\n\t\treturn $proc;\n\t}\n\n\tprivate function __construct() {}\n\n\tpublic function run() {\n\t\tUtils\\check_proc_available( 'Process::run' );\n\n\t\t$start_time = microtime( true );\n\t\t$pipes = [];\n\t\t$proc = Utils\\proc_open_compat( $this->command, self::$descriptors, $pipes, $this->cwd, $this->env );\n\n\t\t$stdout = stream_get_contents( $pipes[1] );\n\t\tfclose( $pipes[1] );\n\n\t\t$stderr = stream_get_contents( $pipes[2] );\n\t\tfclose( $pipes[2] );\n\n\t\t$return_code = proc_close( $proc );\n\n\t\t$run_time = microtime( true ) - $start_time;\n\n\t\tif ( self::$log_run_times ) {\n\t\t\tif ( ! isset( self::$run_times[ $this->command ] ) ) {\n\t\t\t\tself::$run_times[ $this->command ] = [ 0, 0 ];\n\t\t\t}\n\t\t\tself::$run_times[ $this->command ][0] += $run_time;\n\t\t\t++self::$run_times[ $this->command ][1];\n\t\t}\n\n\t\treturn new ProcessRun( [\n\t\t\t'stdout' => $stdout,\n\t\t\t'stderr' => $stderr,\n\t\t\t'return_code' => $return_code,\n\t\t\t'command' => $this->command,\n\t\t\t'cwd' => $this->cwd,\n\t\t\t'env' => $this->env,\n\t\t\t'run_time' => $run_time,\n\t\t] );\n\t}\n\n\tpublic function run_check() {\n\t\t$r = $this->run();\n\t\tif ( $r->return_code ) {\n\t\t\tthrow new RuntimeException( $r );\n\t\t}\n\t\treturn $r;\n\t}\n\n\tpublic function run_check_stderr() {\n\t\t$r = $this->run();\n\t\tif ( $r->return_code ) {\n\t\t\tthrow new RuntimeException( $r );\n\t\t}\n\t\tif ( ! empty( $r->stderr ) ) {\n\t\t\t$stderr_lines = array_filter( explode( \"\\n\", $r->stderr ) );\n\t\t\tif ( 1 === count( $stderr_lines ) ) {\n\t\t\t\t$stderr_line = $stderr_lines[0];\n\t\t\t\tif ( false !== strpos( $stderr_line, 'The PSR-0 `Requests_...` class names in the Request library are deprecated.' ) ) {\n\t\t\t\t\treturn $r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new RuntimeException( $r );\n\t\t}\n\t\treturn $r;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, string|null $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start = microtime(true);\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to execute command: ' . $this->command);\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $returnCode = proc_close($process);\n\n        if (self::$log_run_times) {\n            $end = microtime(true);\n            self::$run_times[$this->command] = $end - $start;\n        }\n\n        return new ProcessRun($stdout, $stderr, $returnCode);\n    }\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr) {\n            if (str_contains($result->stderr, 'Deprecation Notice: Class') && str_contains($result->stderr, 'located in')) {\n                return $result;\n            }\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code\n    ) {}\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start = microtime(true);\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to execute command: ' . $this->command);\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $returnCode = proc_close($process);\n\n        if (self::$log_run_times) {\n            $end = microtime(true);\n            self::$run_times[$this->command] = $end - $start;\n        }\n\n        return new ProcessRun($stdout, $stderr, $returnCode);\n    }\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr) {\n            if (str_contains($result->stderr, 'Class Composer\\Autoload\\ClassLoader located in ./vendor/composer/ClassLoader.php does not comply with psr-0')) {\n                return $result;\n            }\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start = microtime(true);\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to execute command: ' . $this->command);\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $returnCode = proc_close($process);\n\n        if (self::$log_run_times) {\n            $end = microtime(true);\n            self::$run_times[$this->command] = $end - $start;\n        }\n\n        return new ProcessRun($stdout, $stderr, $returnCode);\n    }\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException('Command failed with code ' . $result->return_code . ': ' . $this->command . \"\\n\" . $result->stderr);\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr) {\n            if (strpos($result->stderr, 'PHP Deprecated:  The PSR-0') === 0) {\n                return $result;\n            }\n            throw new \\RuntimeException('Command failed with code ' . $result->return_code . ': ' . $this->command . \"\\n\" . $result->stderr);\n        }\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code\n    ) {}\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start = microtime(true);\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to execute command: ' . $this->command);\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $returnCode = proc_close($process);\n\n        if (self::$log_run_times) {\n            $end = microtime(true);\n            self::$run_times[$this->command] = $end - $start;\n        }\n\n        return new ProcessRun($stdout, $stderr, $returnCode);\n    }\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n\n        if ($result->return_code !== 0 || $result->stderr) {\n            if (str_contains($result->stderr, 'Deprecation Notice: Class') && str_contains($result->stderr, 'located in')) {\n                return $result;\n            }\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to execute command: ' . $this->command);\n        }\n\n        fclose($pipes[0]);\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        if (self::$log_run_times) {\n            $end_time = microtime(true);\n            self::$run_times[$this->command] = $end_time - $start_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code);\n    }\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n\n        if ($result->return_code !== 0 || $result->stderr) {\n            if (str_contains($result->stderr, 'Since symfony/console 5.4')) {\n                return $result;\n            }\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start = microtime(true);\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to execute command: ' . $this->command);\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $returnCode = proc_close($process);\n\n        if (self::$log_run_times) {\n            $end = microtime(true);\n            self::$run_times[$this->command] = $end - $start;\n        }\n\n        return new ProcessRun($stdout, $stderr, $returnCode);\n    }\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr) {\n            if (str_contains($result->stderr, 'Class Composer\\Autoload\\ClassLoader located in ./vendor/composer/ClassLoader.php does not comply with psr-0')) {\n                throw new \\RuntimeException('PSR-0 deprecation warning detected.');\n            }\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code\n    ) {}\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, string|null $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start = microtime(true);\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to execute command: ' . $this->command);\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $returnCode = proc_close($process);\n\n        if (self::$log_run_times) {\n            $end = microtime(true);\n            self::$run_times[$this->command] = $end - $start;\n        }\n\n        return new ProcessRun($stdout, $stderr, $returnCode);\n    }\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr !== '' && strpos($result->stderr, 'PHP Deprecated:  ') !== 0) {\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code\n    ) {}\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to execute command: ' . $this->command);\n        }\n\n        fclose($pipes[0]);\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        if (self::$log_run_times) {\n            $end_time = microtime(true);\n            self::$run_times[$this->command] = $end_time - $start_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code);\n    }\n\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n\n        if ($result->return_code !== 0 || $result->stderr) {\n            if (str_contains($result->stderr, 'Since symfony/console 5.4')) {\n                return $result;\n            }\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, string|null $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start = microtime(true);\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to execute command: ' . $this->command);\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $returnCode = proc_close($process);\n\n        if (self::$log_run_times) {\n            $end = microtime(true);\n            self::$run_times[$this->command] = $end - $start;\n        }\n\n        return new ProcessRun($stdout, $stderr, $returnCode);\n    }\n\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n\n        if ($result->return_code !== 0 || $result->stderr) {\n            if (str_contains($result->stderr, 'Deprecation Notice: Class') && str_contains($result->stderr, 'located in')) {\n                return $result;\n            }\n            throw new \\RuntimeException(sprintf('Command \"%s\" failed with code %d: %s', $this->command, $result->return_code, $result->stderr));\n        }\n\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start = microtime(true);\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to execute command: ' . $this->command);\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $returnCode = proc_close($process);\n\n        if (self::$log_run_times) {\n            $end = microtime(true);\n            self::$run_times[$this->command] = $end - $start;\n        }\n\n        return new ProcessRun($stdout, $stderr, $returnCode);\n    }\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException('Command failed with code ' . $result->return_code . ': ' . $this->command . \"\\n\\n\" . $result->stderr);\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr) {\n            if (strpos($result->stderr, 'PHP Deprecated:  The PSR-0') !== false) {\n                throw new \\ErrorException($result->stderr);\n            }\n            throw new \\RuntimeException('Command failed with code ' . $result->return_code . ': ' . $this->command . \"\\n\\n\" . $result->stderr);\n        }\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code\n    ) {\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 141,
    "Instruction": "Task Description: Create a PHP class that manages subprocess execution with proper pipe handling for inter-process communication, including input/output streams and error handling.\n\nClass Description: The Process class provides a way to execute shell commands as subprocesses, capturing their output streams (stdout and stderr) and exit codes. It supports custom working directories and environment variables, and includes optional execution time tracking.\n\nAttributes:\n- command: string - The shell command to be executed\n- cwd: string|null - The working directory for the command execution\n- env: array - Environment variables for the command\n- descriptors: array - Static array defining I/O descriptors for proc_open\n- log_run_times: bool - Static flag to enable execution time logging\n- run_times: array - Static array storing aggregated execution times\n\nMethods:\n- create(string $command, string|null $cwd = null, array $env = array()) -> Process - Static factory method to create a new Process instance\n- run() -> ProcessRun - Executes the command and returns a ProcessRun object containing execution results\n- run_check() -> ProcessRun - Executes the command and throws RuntimeException if return code or stderr is non-empty\n- run_check_stderr() -> ProcessRun - Executes the command and throws RuntimeException if return code is non-zero or stderr exists\n\nNote: The ProcessRun return type refers to an object containing these properties:\n- stdout: string - Output from stdout\n- stderr: string - Output from stderr\n- return_code: int - Process exit code\n- command: string - The executed command\n- cwd: string|null - Working directory used\n- env: array - Environment variables used\n- run_time: float - Execution time in seconds",
    "Canonical_solution": "namespace EE;\n\nuse EE\\Utils;\n\nclass Process {\n\tprivate $command;\n\tprivate $cwd;\n\tprivate $env;\n\tprivate static $descriptors = array(\n\t\t0 => STDIN,\n\t\t1 => array( 'pipe', 'w' ),\n\t\t2 => array( 'pipe', 'w' ),\n\t);\n\tpublic static $log_run_times = false;\n\tpublic static $run_times = array();\n\n\tpublic static function create( $command, $cwd = null, $env = array() ) {\n\t\t$proc = new self;\n\t\t$proc->command = $command;\n\t\t$proc->cwd = $cwd;\n\t\t$proc->env = $env;\n\t\treturn $proc;\n\t}\n\n\tprivate function __construct() {}\n\n\tpublic function run() {\n\t\t$start_time = microtime( true );\n\t\t$proc = Utils\\proc_open_compat( $this->command, self::$descriptors, $pipes, $this->cwd, $this->env );\n\n\t\t$stdout = stream_get_contents( $pipes[1] );\n\t\tfclose( $pipes[1] );\n\n\t\t$stderr = stream_get_contents( $pipes[2] );\n\t\tfclose( $pipes[2] );\n\n\t\t$return_code = proc_close( $proc );\n\t\t$run_time = microtime( true ) - $start_time;\n\n\t\tif ( self::$log_run_times ) {\n\t\t\tif ( ! isset( self::$run_times[ $this->command ] ) ) {\n\t\t\t\tself::$run_times[ $this->command ] = array( 0, 0 );\n\t\t\t}\n\t\t\tself::$run_times[ $this->command ][0] += $run_time;\n\t\t\tself::$run_times[ $this->command ][1]++;\n\t\t}\n\n\t\treturn new ProcessRun( array(\n\t\t\t'stdout' => $stdout,\n\t\t\t'stderr' => $stderr,\n\t\t\t'return_code' => $return_code,\n\t\t\t'command' => $this->command,\n\t\t\t'cwd' => $this->cwd,\n\t\t\t'env' => $this->env,\n\t\t\t'run_time' => $run_time,\n\t\t) );\n\t}\n\n\tpublic function run_check() {\n\t\t$r = $this->run();\n\t\tif ( $r->return_code || ! empty( $r->STDERR ) ) {\n\t\t\tthrow new \\RuntimeException( $r );\n\t\t}\n\t\treturn $r;\n\t}\n\n\tpublic function run_check_stderr() {\n\t\t$r = $this->run();\n\t\tif ( $r->return_code || ! empty( $r->stderr ) ) {\n\t\t\tthrow new \\RuntimeException( $r );\n\t\t}\n\t\treturn $r;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException(\"Failed to execute command: {$this->command}\");\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        $run_time = microtime(true) - $start_time;\n\n        if (self::$log_run_times) {\n            self::$run_times[] = $run_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code, $this->command, $this->cwd, $this->env, $run_time);\n    }\n\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command failed: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(\"Command failed with code {$result->return_code}: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        if ($result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command generated stderr: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code,\n        public string $command,\n        public ?string $cwd,\n        public array $env,\n        public float $run_time\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException(\"Failed to execute command: {$this->command}\");\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        $run_time = microtime(true) - $start_time;\n\n        if (self::$log_run_times) {\n            self::$run_times[] = $run_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code, $this->command, $this->cwd, $this->env, $run_time);\n    }\n\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command failed: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(\"Command failed with code {$result->return_code}: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        if ($result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command generated stderr: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code,\n        public string $command,\n        public ?string $cwd,\n        public array $env,\n        public float $run_time\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException(\"Failed to execute command: {$this->command}\");\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        $run_time = microtime(true) - $start_time;\n\n        if (self::$log_run_times) {\n            self::$run_times[] = $run_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code, $this->command, $this->cwd, $this->env, $run_time);\n    }\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command failed: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        return $result;\n    }\n\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(\"Command failed with code {$result->return_code}: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n\n        if ($result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command generated stderr: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code,\n        public string $command,\n        public ?string $cwd,\n        public array $env,\n        public float $run_time\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public $command;\n    public $cwd;\n    public $env;\n    private static $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static $log_run_times = false;\n    public static $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to open process.');\n        }\n\n        fclose($pipes[0]);\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        $run_time = microtime(true) - $start_time;\n\n        if (self::$log_run_times) {\n            self::$run_times[] = $run_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code, $this->command, $this->cwd, $this->env, $run_time);\n    }\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr !== '') {\n            throw new \\RuntimeException(\"Command failed: {$this->command}\\n{$result->stderr}\");\n        }\n        return $result;\n    }\n\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(\"Command failed with code {$result->return_code}: {$this->command}\\n{$result->stderr}\");\n        }\n        if ($result->stderr !== '') {\n            throw new \\RuntimeException(\"Command wrote to stderr: {$this->command}\\n{$result->stderr}\");\n        }\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code,\n        public string $command,\n        public ?string $cwd,\n        public array $env,\n        public float $run_time\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to open process.');\n        }\n\n        fclose($pipes[0]);\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        $run_time = microtime(true) - $start_time;\n\n        if (self::$log_run_times) {\n            self::$run_times[] = $run_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code, $this->command, $this->cwd, $this->env, $run_time);\n    }\n\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr !== '') {\n            throw new \\RuntimeException(\"Command failed: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(\"Command failed with code {$result->return_code}: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        if ($result->stderr !== '') {\n            throw new \\RuntimeException(\"Command generated stderr: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code,\n        public string $command,\n        public ?string $cwd,\n        public array $env,\n        public float $run_time\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException(\"Failed to execute command: {$this->command}\");\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        $run_time = microtime(true) - $start_time;\n\n        if (self::$log_run_times) {\n            self::$run_times[] = $run_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code, $this->command, $this->cwd, $this->env, $run_time);\n    }\n\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command failed: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(\"Command failed with code {$result->return_code}: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n\n        if ($result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command generated stderr: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code,\n        public string $command,\n        public ?string $cwd,\n        public array $env,\n        public float $run_time\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to open process.');\n        }\n\n        fclose($pipes[0]);\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        $run_time = microtime(true) - $start_time;\n\n        if (self::$log_run_times) {\n            self::$run_times[] = $run_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code, $this->command, $this->cwd, $this->env, $run_time);\n    }\n\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr !== '') {\n            throw new \\RuntimeException(\"Command failed: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(\"Command failed with code {$result->return_code}: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        if ($result->stderr !== '') {\n            throw new \\RuntimeException(\"Command generated stderr: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code,\n        public string $command,\n        public ?string $cwd,\n        public array $env,\n        public float $run_time\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException(\"Failed to execute command: {$this->command}\");\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        $run_time = microtime(true) - $start_time;\n\n        if (self::$log_run_times) {\n            self::$run_times[] = $run_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code, $this->command, $this->cwd, $this->env, $run_time);\n    }\n\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command failed: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(\"Command failed with code {$result->return_code}: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n\n        if ($result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command generated stderr: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code,\n        public string $command,\n        public ?string $cwd,\n        public array $env,\n        public float $run_time\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Failed to open process.');\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        $run_time = microtime(true) - $start_time;\n\n        if (self::$log_run_times) {\n            self::$run_times[] = $run_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code, $this->command, $this->cwd, $this->env, $run_time);\n    }\n\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr !== '') {\n            throw new \\RuntimeException(\"Command failed: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(\"Command exited with non-zero status ({$result->return_code}): {$this->command}\");\n        }\n\n        if ($result->stderr !== '') {\n            throw new \\RuntimeException(\"Command wrote to stderr: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code,\n        public string $command,\n        public ?string $cwd,\n        public array $env,\n        public float $run_time\n    ) {\n    }\n}\n",
      "<?php\n\nclass Process\n{\n    public string $command;\n    public ?string $cwd;\n    public array $env;\n    private static array $descriptors = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n    public static bool $log_run_times = false;\n    public static array $run_times = [];\n\n    public static function create(string $command, ?string $cwd = null, array $env = []): Process\n    {\n        $process = new self();\n        $process->command = $command;\n        $process->cwd = $cwd;\n        $process->env = $env;\n        return $process;\n    }\n\n    public function run(): ProcessRun\n    {\n        $start_time = microtime(true);\n\n        $process = proc_open($this->command, self::$descriptors, $pipes, $this->cwd, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException(\"Failed to execute command: {$this->command}\");\n        }\n\n        fclose($pipes[0]);\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $return_code = proc_close($process);\n\n        $run_time = microtime(true) - $start_time;\n\n        if (self::$log_run_times) {\n            self::$run_times[] = $run_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code, $this->command, $this->cwd, $this->env, $run_time);\n    }\n\n\n    public function run_check(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0 || $result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command failed: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n        return $result;\n    }\n\n    public function run_check_stderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->return_code !== 0) {\n            throw new \\RuntimeException(\"Command failed with code {$result->return_code}: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n\n        if ($result->stderr !== \"\") {\n            throw new \\RuntimeException(\"Command generated stderr: {$this->command}\\nStderr: {$result->stderr}\");\n        }\n\n        return $result;\n    }\n}\n\nclass ProcessRun\n{\n    public function __construct(\n        public string $stdout,\n        public string $stderr,\n        public int $return_code,\n        public string $command,\n        public ?string $cwd,\n        public array $env,\n        public float $run_time\n    ) {\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Create a PHP class that provides a convenient way to execute shell commands with options for argument escaping, error capturing, and different execution methods (proc_open vs exec).\n\nClass Description: The Command class encapsulates shell command execution functionality, allowing for flexible command building, execution, and result handling. It supports both proc_open and exec methods, with options for capturing stderr, escaping arguments, and configuring process execution environment.\n\nAttributes:\n\nescapeArgs: [bool] - Whether to escape arguments automatically (default true)\nescapeCommand: [bool] - Whether to escape the command (default false)\nuseExec: [bool] - Whether to use exec() instead of proc_open() (default false)\ncaptureStdErr: [bool] - Whether to capture stderr output (default true)\nprocCwd: [string|null] - Working directory for the process\nprocEnv: [array|null] - Environment variables for the process\nprocOptions: [array|null] - Additional options for proc_open\n_command: [string] - The base command to execute\n_args: [array] - Array of command arguments\n_execCommand: [string|null] - The final constructed command string\n_stdOut: [string] - Captured stdout output\n_stdErr: [string] - Captured stderr output\n_exitCode: [int|null] - Process exit code\n_error: [string] - Last error message\n_executed: [bool] - Whether command has been executed\n\nMethods:\n\n__construct: [mixed $options = null] -> [void] - Constructor that accepts either configuration array or command string\nsetCommand: [string $command] -> [self] - Sets the base command to execute\ngetCommand: [void] -> [string] - Gets the current base command\ngetExecCommand: [void] -> [string|false] - Gets the fully constructed command string\naddArg: [string $key, mixed $value = null, bool $escape = null] -> [self] - Adds an argument to the command\nexecute: [void] -> [bool] - Executes the command and returns success status\ngetOutput: [void] -> [string] - Gets the stdout output\ngetError: [void] -> [string] - Gets the last error message\ngetStdErr: [void] -> [string] - Gets the stderr output\ngetExitCode: [void] -> [int|null] - Gets the process exit code",
    "Canonical_solution": "class Command\n{\n    public $escapeArgs = true;\n    public $escapeCommand = false;\n    public $useExec = false;\n    public $captureStdErr = true;\n    public $procCwd;\n    public $procEnv;\n    public $procOptions;\n\n    protected $_command;\n    protected $_args = array();\n    protected $_execCommand;\n    protected $_stdOut = '';\n    protected $_stdErr = '';\n    protected $_exitCode;\n    protected $_error = '';\n    protected $_executed = false;\n\n    public function __construct($options = null)\n    {\n        if (is_array($options)) {\n            $this->setOptions($options);\n        } elseif (is_string($options)) {\n            $this->setCommand($options);\n        }\n    }\n\n    public function setCommand($command)\n    {\n        $this->_command = $this->escapeCommand ? escapeshellcmd($command) : $command;\n        return $this;\n    }\n\n    public function getCommand()\n    {\n        return $this->_command;\n    }\n\n    public function getExecCommand()\n    {\n        if ($this->_execCommand===null) {\n            $command = $this->getCommand();\n            if (!$command) {\n                $this->_error = 'Could not locate any executable command';\n                return false;\n            }\n            $args = $this->getArgs();\n            $this->_execCommand = $args ? $command.' '.$args : $command;\n        }\n        return $this->_execCommand;\n    }\n\n    public function addArg($key, $value = null, $escape = null)\n    {\n        $doEscape = $escape!==null ? $escape : $this->escapeArgs;\n        if ($value===null) {\n            $this->_args[] = $escape ? escapeshellarg($key) : $key;\n        } else {\n            $separator = substr($key, -1)==='=' ? '' : ' ';\n            if (is_array($value)) {\n                $params = array();\n                foreach ($value as $v) {\n                    $params[] = $doEscape ? escapeshellarg($v) : $v;\n                }\n                $this->_args[] = $key.$separator.implode(' ',$params);\n            } else {\n                $this->_args[] = $key.$separator.($doEscape ? escapeshellarg($value) : $value);\n            }\n        }\n        return $this;\n    }\n\n    public function execute()\n    {\n        $command = $this->getExecCommand();\n\n        if (!$command) {\n            return false;\n        }\n\n        if ($this->useExec) {\n            $execCommand = $this->captureStdErr ? \"$command 2>&1\" : $command;\n            exec($execCommand, $output, $this->_exitCode);\n            $this->_stdOut = trim(implode(\"\\n\", $output));\n            if ($this->_exitCode!==0) {\n                $this->_stdErr = $this->_stdOut;\n                $this->_error = empty($this->_stdErr) ? 'Command failed' : $this->_stdErr;\n                return false;\n            }\n        } else {\n            $descriptors = array(\n                1 => array('pipe','w'),\n                2 => array('pipe','a'),\n            );\n            $process = proc_open($command, $descriptors, $pipes, $this->procCwd, $this->procEnv, $this->procOptions);\n\n            if (is_resource($process)) {\n                $this->_stdOut = trim(stream_get_contents($pipes[1]));\n                $this->_stdErr = trim(stream_get_contents($pipes[2]));\n                fclose($pipes[1]);\n                fclose($pipes[2]);\n\n                $this->_exitCode = proc_close($process);\n\n                if ($this->_exitCode!==0) {\n                    $this->_error = $this->_stdErr ? $this->_stdErr : \"Failed without error message: $command\";\n                    return false;\n                }\n            } else {\n                $this->_error = \"Could not run command $command\";\n                return false;\n            }\n        }\n\n        $this->_executed = true;\n        return true;\n    }\n\n    public function getOutput()\n    {\n        return $this->_stdOut;\n    }\n\n    public function getError()\n    {\n        return $this->_error;\n    }\n\n    public function getStdErr()\n    {\n        return $this->_stdErr;\n    }\n\n    public function getExitCode()\n    {\n        return $this->_exitCode;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "```php\n<?php\n\nclass Command\n{\n    public bool $escapeArgs = true;\n    public bool $escapeCommand = false;\n    public bool $useExec = false;\n    public bool $captureStdErr = true;\n    public ?string $procCwd = null;\n    public ?array $procEnv = null;\n    public ?array $procOptions = null;\n    protected string $_command = '';\n    protected array $_args = [];\n    protected ?string $_execCommand = null;\n    protected string $_stdOut = '';\n    protected string $_stdErr = '';\n    protected ?int $_exitCode = null;\n    protected string $_error = '';\n    protected bool $_executed = false;\n\n\n    public function __construct(mixed $options = null)\n    {\n        if (is_string($options)) {\n            $this->setCommand($options);\n        } elseif (is_array($options)) {\n            foreach ($options as $key => $value) {\n                if (property_exists($this, $key)) {\n                    $this->$key = $value;\n                }\n            }\n        }\n    }\n\n    public function setCommand(string $command): self\n    {\n        $this->_command = $command;\n        return $this;\n    }\n\n    public function getCommand(): string\n    {\n        return $this->_command;\n    }\n\n    public function getExecCommand(): string|false\n    {\n        if (!$this->_executed && !$this->buildCommand()) {\n            return false;\n        }\n        return $this->_execCommand;\n    }\n\n    public function addArg(string $key, mixed $value = null, bool $escape = null): self\n    {\n        $arg = $key;\n        if ($value !== null) {\n            $arg .= '=' . ($escape ?? $this->escapeArgs ? escapeshellarg($value) : $value);\n        }\n        $this->_args[] = $arg;\n        return $this;\n    }\n\n\n    public function execute(): bool\n    {\n        if (!$this->buildCommand()) {\n            return false;\n        }\n\n        if ($this->useExec) {\n            exec($this->_execCommand, $output, $this->_exitCode);\n            $this->_stdOut = implode(\"\\n\", $output);\n        } else {\n            $descriptors = [\n                1 => ['pipe', 'w'],\n                2 => $this->captureStdErr ? ['pipe', 'w'] : ['dev', 'null']\n            ];\n            $process = proc_open($this->_execCommand, $descriptors, $pipes, $this->procCwd, $this->procEnv, $this->procOptions);\n\n            if (is_resource($process)) {\n                $this->_stdOut = stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n                if ($this->captureStdErr) {\n                    $this->_stdErr = stream_get_contents($pipes[2]);\n                    fclose($pipes[2]);\n                }\n                $this->_exitCode = proc_close($process);\n            } else {\n                $this->_error = 'Failed to open process.';\n                return false;\n            }\n        }\n        $this->_executed = true;\n        return true;\n    }\n\n    public function getOutput(): string\n    {\n        return $this->_stdOut;\n    }\n\n    public function getError(): string\n    {\n        return $this->_error;\n    }\n\n    public function getStdErr(): string\n    {\n        return $this->_stdErr;\n    }\n\n    public function getExitCode(): ?int\n    {\n        return $this->_exitCode;\n    }\n\n\n    protected function buildCommand(): bool\n    {\n        if (empty($this->_command)) {\n            $this->_error = 'No command set.';\n            return false;\n        }\n\n        $command = $this->escapeCommand ? escapeshellcmd($this->_command) : $this->_command;\n        $this->_execCommand = $command . ' ' . implode(' ', $this->_args);\n        return true;\n    }\n}\n\n```",
      "```php\n<?php\n\nclass Command\n{\n    public bool $escapeArgs = true;\n    public bool $escapeCommand = false;\n    public bool $useExec = false;\n    public bool $captureStdErr = true;\n    public ?string $procCwd = null;\n    public ?array $procEnv = null;\n    public ?array $procOptions = null;\n    protected string $_command;\n    protected array $_args = [];\n    protected ?string $_execCommand = null;\n    protected string $_stdOut = '';\n    protected string $_stdErr = '';\n    protected ?int $_exitCode = null;\n    protected string $_error = '';\n    protected bool $_executed = false;\n\n    public function __construct(mixed $options = null)\n    {\n        if (is_string($options)) {\n            $this->setCommand($options);\n        } elseif (is_array($options)) {\n            foreach ($options as $key => $value) {\n                if (property_exists($this, $key)) {\n                    $this->$key = $value;\n                }\n            }\n        }\n    }\n\n    public function setCommand(string $command): self\n    {\n        $this->_command = $command;\n        return $this;\n    }\n\n    public function getCommand(): string\n    {\n        return $this->_command;\n    }\n\n    public function getExecCommand(): string|false\n    {\n        if (!$this->_executed && !$this->buildCommand()) {\n            return false;\n        }\n        return $this->_execCommand;\n    }\n\n    public function addArg(string $key, mixed $value = null, bool $escape = null): self\n    {\n        $arg = $key;\n        if ($value !== null) {\n            $arg .= ' ' . ($escape ?? $this->escapeArgs ? escapeshellarg($value) : $value);\n        }\n        $this->_args[] = $arg;\n        return $this;\n    }\n\n\n    protected function buildCommand(): bool\n    {\n        $command = $this->escapeCommand ? escapeshellcmd($this->_command) : $this->_command;\n        $this->_execCommand = $command . ' ' . implode(' ', $this->_args);\n        return true;\n    }\n\n    public function execute(): bool\n    {\n        if (!$this->buildCommand()) {\n            return false;\n        }\n\n        if ($this->useExec) {\n            exec($this->_execCommand, $output, $this->_exitCode);\n            $this->_stdOut = implode(\"\\n\", $output);\n        } else {\n            $descriptors = [\n                1 => ['pipe', 'w'],\n                2 => $this->captureStdErr ? ['pipe', 'w'] : ['dev', 'null']\n            ];\n            $process = proc_open($this->_execCommand, $descriptors, $pipes, $this->procCwd, $this->procEnv, $this->procOptions);\n\n            if (is_resource($process)) {\n                $this->_stdOut = stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n                if ($this->captureStdErr) {\n                    $this->_stdErr = stream_get_contents($pipes[2]);\n                    fclose($pipes[2]);\n                }\n                $this->_exitCode = proc_close($process);\n            } else {\n                $this->_error = 'Failed to open process.';\n                return false;\n            }\n        }\n        $this->_executed = true;\n        return $this->_exitCode === 0;\n    }\n\n    public function getOutput(): string\n    {\n        return $this->_stdOut;\n    }\n\n    public function getError(): string\n    {\n        return $this->_error;\n    }\n\n    public function getStdErr(): string\n    {\n        return $this->_stdErr;\n    }\n\n    public function getExitCode(): ?int\n    {\n        return $this->_exitCode;\n    }\n}\n```",
      "```php\n<?php\n\nclass Command\n{\n    public bool $escapeArgs = true;\n    public bool $escapeCommand = false;\n    public bool $useExec = false;\n    public bool $captureStdErr = true;\n    public ?string $procCwd = null;\n    public ?array $procEnv = null;\n    public ?array $procOptions = null;\n    protected string $_command = '';\n    protected array $_args = [];\n    protected ?string $_execCommand = null;\n    protected string $_stdOut = '';\n    protected string $_stdErr = '';\n    protected ?int $_exitCode = null;\n    protected string $_error = '';\n    protected bool $_executed = false;\n\n    public function __construct(mixed $options = null)\n    {\n        if (is_string($options)) {\n            $this->setCommand($options);\n        } elseif (is_array($options)) {\n            foreach ($options as $key => $value) {\n                if (property_exists($this, $key)) {\n                    $this->$key = $value;\n                }\n            }\n        }\n    }\n\n    public function setCommand(string $command): self\n    {\n        $this->_command = $command;\n        return $this;\n    }\n\n    public function getCommand(): string\n    {\n        return $this->_command;\n    }\n\n    public function getExecCommand(): string|false\n    {\n        if (!$this->_executed && !$this->buildCommand()) {\n            return false;\n        }\n        return $this->_execCommand;\n    }\n\n    public function addArg(string $key, mixed $value = null, bool $escape = null): self\n    {\n        $arg = $key;\n        if ($value !== null) {\n            $arg .= ' ' . ($escape ?? $this->escapeArgs ? escapeshellarg($value) : $value);\n        }\n        $this->_args[] = $arg;\n        return $this;\n    }\n\n\n    public function execute(): bool\n    {\n        if (!$this->buildCommand()) {\n            return false;\n        }\n\n        if ($this->useExec) {\n            exec($this->_execCommand, $output, $this->_exitCode);\n            $this->_stdOut = implode(\"\\n\", $output);\n        } else {\n            $descriptors = [\n                1 => ['pipe', 'w'],\n                2 => $this->captureStdErr ? ['pipe', 'w'] : ['dev', 'null']\n            ];\n            $process = proc_open($this->_execCommand, $descriptors, $pipes, $this->procCwd, $this->procEnv, $this->procOptions);\n\n            if (is_resource($process)) {\n                $this->_stdOut = stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n                if ($this->captureStdErr) {\n                    $this->_stdErr = stream_get_contents($pipes[2]);\n                    fclose($pipes[2]);\n                }\n                $this->_exitCode = proc_close($process);\n            } else {\n                $this->_error = 'Failed to open process.';\n                return false;\n            }\n        }\n        $this->_executed = true;\n        return true;\n    }\n\n    public function getOutput(): string\n    {\n        return $this->_stdOut;\n    }\n\n    public function getError(): string\n    {\n        return $this->_error;\n    }\n\n    public function getStdErr(): string\n    {\n        return $this->_stdErr;\n    }\n\n    public function getExitCode(): ?int\n    {\n        return $this->_exitCode;\n    }\n\n    protected function buildCommand(): bool\n    {\n        if (empty($this->_command)) {\n            $this->_error = 'No command set.';\n            return false;\n        }\n\n        $command = $this->escapeCommand ? escapeshellcmd($this->_command) : $this->_command;\n        $this->_execCommand = $command . ' ' . implode(' ', $this->_args);\n        return true;\n    }\n}\n\n```",
      "```php\n<?php\n\nclass Command\n{\n    public bool $escapeArgs = true;\n    public bool $escapeCommand = false;\n    public bool $useExec = false;\n    public bool $captureStdErr = true;\n    public ?string $procCwd = null;\n    public ?array $procEnv = null;\n    public ?array $procOptions = null;\n    protected string $_command = '';\n    protected array $_args = [];\n    protected ?string $_execCommand = null;\n    protected string $_stdOut = '';\n    protected string $_stdErr = '';\n    protected ?int $_exitCode = null;\n    protected string $_error = '';\n    protected bool $_executed = false;\n\n\n    public function __construct(mixed $options = null)\n    {\n        if (is_string($options)) {\n            $this->setCommand($options);\n        } elseif (is_array($options)) {\n            foreach ($options as $key => $value) {\n                if (property_exists($this, $key)) {\n                    $this->$key = $value;\n                }\n            }\n        }\n    }\n\n    public function setCommand(string $command): self\n    {\n        $this->_command = $command;\n        return $this;\n    }\n\n    public function getCommand(): string\n    {\n        return $this->_command;\n    }\n\n\n    public function getExecCommand(): string|false\n    {\n        if (!$this->_executed && !$this->buildCommand()) {\n            return false;\n        }\n        return $this->_execCommand;\n    }\n\n    public function addArg(string $key, mixed $value = null, bool $escape = null): self\n    {\n        $arg = $key;\n        if ($value !== null) {\n            $arg .= '=' . ($escape ?? $this->escapeArgs ? escapeshellarg($value) : $value);\n        }\n\n        $this->_args[] = $arg;\n        return $this;\n    }\n\n\n    public function execute(): bool\n    {\n        if (!$this->buildCommand()) {\n            return false;\n        }\n\n        if ($this->useExec) {\n            exec($this->_execCommand, $output, $this->_exitCode);\n            $this->_stdOut = implode(\"\\n\", $output);\n        } else {\n            $descriptors = [\n                1 => ['pipe', 'w'],\n                2 => $this->captureStdErr ? ['pipe', 'w'] : ['dev', 'null']\n            ];\n\n            $process = proc_open($this->_execCommand, $descriptors, $pipes, $this->procCwd, $this->procEnv, $this->procOptions);\n\n            if (is_resource($process)) {\n                $this->_stdOut = stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n\n                if ($this->captureStdErr) {\n                    $this->_stdErr = stream_get_contents($pipes[2]);\n                    fclose($pipes[2]);\n                }\n\n                $this->_exitCode = proc_close($process);\n            } else {\n                $this->_error = 'Failed to open process.';\n                return false;\n            }\n        }\n        $this->_executed = true;\n        return true;\n    }\n\n    public function getOutput(): string\n    {\n        return $this->_stdOut;\n    }\n\n    public function getError(): string\n    {\n        return $this->_error;\n    }\n\n    public function getStdErr(): string\n    {\n        return $this->_stdErr;\n    }\n\n    public function getExitCode(): ?int\n    {\n        return $this->_exitCode;\n    }\n\n\n    protected function buildCommand(): bool\n    {\n        if (empty($this->_command)) {\n            $this->_error = 'No command set.';\n            return false;\n        }\n\n        $command = $this->escapeCommand ? escapeshellcmd($this->_command) : $this->_command;\n        $this->_execCommand = $command . ' ' . implode(' ', $this->_args);\n        return true;\n    }\n}\n\n```",
      "```php\n<?php\n\nclass Command\n{\n    public bool $escapeArgs = true;\n    public bool $escapeCommand = false;\n    public bool $useExec = false;\n    public bool $captureStdErr = true;\n    public ?string $procCwd = null;\n    public ?array $procEnv = null;\n    public ?array $procOptions = null;\n    protected string $_command;\n    protected array $_args = [];\n    protected ?string $_execCommand = null;\n    protected string $_stdOut = '';\n    protected string $_stdErr = '';\n    protected ?int $_exitCode = null;\n    protected string $_error = '';\n    protected bool $_executed = false;\n\n    public function __construct(mixed $options = null)\n    {\n        if (is_string($options)) {\n            $this->setCommand($options);\n        } elseif (is_array($options)) {\n            foreach ($options as $key => $value) {\n                if (property_exists($this, $key)) {\n                    $this->$key = $value;\n                }\n            }\n        }\n    }\n\n    public function setCommand(string $command): self\n    {\n        $this->_command = $command;\n        return $this;\n    }\n\n    public function getCommand(): string\n    {\n        return $this->_command;\n    }\n\n    public function getExecCommand(): string|false\n    {\n        if (!$this->_executed && !$this->buildCommand()) {\n            return false;\n        }\n        return $this->_execCommand;\n    }\n\n    public function addArg(string $key, mixed $value = null, bool $escape = null): self\n    {\n        $escape = $escape ?? $this->escapeArgs;\n        $arg = $key;\n        if ($value !== null) {\n            $arg .= ' ';\n            $arg .= $escape ? escapeshellarg($value) : $value;\n        }\n        $this->_args[] = $arg;\n        return $this;\n    }\n\n\n    public function execute(): bool\n    {\n        if (!$this->buildCommand()) {\n            return false;\n        }\n\n        if ($this->useExec) {\n            exec($this->_execCommand, $output, $this->_exitCode);\n            $this->_stdOut = implode(\"\\n\", $output);\n        } else {\n            $descriptors = [\n                1 => ['pipe', 'w'],\n                2 => $this->captureStdErr ? ['pipe', 'w'] : ['dev', 'null']\n            ];\n            $process = proc_open($this->_execCommand, $descriptors, $pipes, $this->procCwd, $this->procEnv, $this->procOptions);\n\n            if (is_resource($process)) {\n                $this->_stdOut = stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n                if ($this->captureStdErr) {\n                    $this->_stdErr = stream_get_contents($pipes[2]);\n                    fclose($pipes[2]);\n                }\n                $this->_exitCode = proc_close($process);\n            } else {\n                $this->_error = 'Failed to open process.';\n                return false;\n            }\n        }\n        $this->_executed = true;\n        return $this->_exitCode === 0;\n    }\n\n    public function getOutput(): string\n    {\n        return $this->_stdOut;\n    }\n\n    public function getError(): string\n    {\n        return $this->_error;\n    }\n\n    public function getStdErr(): string\n    {\n        return $this->_stdErr;\n    }\n\n    public function getExitCode(): ?int\n    {\n        return $this->_exitCode;\n    }\n\n    protected function buildCommand(): bool\n    {\n        if (empty($this->_command)) {\n            $this->_error = 'No command set.';\n            return false;\n        }\n\n        $command = $this->escapeCommand ? escapeshellcmd($this->_command) : $this->_command;\n        $this->_execCommand = $command . ' ' . implode(' ', $this->_args);\n        return true;\n    }\n}\n\n```",
      "<?php\n\nclass Command\n{\n    public bool $escapeArgs = true;\n    public bool $escapeCommand = false;\n    public bool $useExec = false;\n    public bool $captureStdErr = true;\n    public ?string $procCwd = null;\n    public ?array $procEnv = null;\n    public ?array $procOptions = null;\n\n    protected string $_command = '';\n    protected array $_args = [];\n    protected ?string $_execCommand = null;\n\n    protected string $_stdOut = '';\n    protected string $_stdErr = '';\n    protected ?int $_exitCode = null;\n    protected string $_error = '';\n    protected bool $_executed = false;\n\n\n    public function __construct(mixed $options = null)\n    {\n        if (is_string($options)) {\n            $this->setCommand($options);\n        } elseif (is_array($options)) {\n            foreach ($options as $key => $value) {\n                if (property_exists($this, $key)) {\n                    $this->$key = $value;\n                }\n            }\n        }\n    }\n\n    public function setCommand(string $command): self\n    {\n        $this->_command = $command;\n        return $this;\n    }\n\n    public function getCommand(): string\n    {\n        return $this->_command;\n    }\n\n\n    public function getExecCommand(): string|false\n    {\n        if (!$this->_execCommand) {\n            $this->buildExecCommand();\n        }\n        return $this->_execCommand;\n\n    }\n\n    public function addArg(string $key, mixed $value = null, bool $escape = null): self\n    {\n        $arg = $key;\n        if ($value !== null) {\n            $arg .= ' ';\n            if ($escape ?? $this->escapeArgs) {\n                $value = escapeshellarg($value);\n            }\n            $arg .= $value;\n        }\n\n        $this->_args[] = $arg;\n        return $this;\n    }\n\n\n    public function execute(): bool\n    {\n        $this->buildExecCommand();\n\n        if ($this->useExec) {\n            exec($this->_execCommand, $output, $return_var);\n            $this->_stdOut = implode(\"\\n\", $output);\n            $this->_exitCode = $return_var;\n        } else {\n            $descriptors = [\n                1 => ['pipe', 'w'],\n                2 => $this->captureStdErr ? ['pipe', 'w'] : ['dev', 'null']\n            ];\n\n            $process = proc_open($this->_execCommand, $descriptors, $pipes, $this->procCwd, $this->procEnv, $this->procOptions);\n\n\n            if (is_resource($process)) {\n                $this->_stdOut = stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n\n                if ($this->captureStdErr) {\n                    $this->_stdErr = stream_get_contents($pipes[2]);\n                    fclose($pipes[2]);\n                }\n\n                $this->_exitCode = proc_close($process);\n            } else {\n                $this->_error = 'Failed to open process.';\n                return false;\n            }\n        }\n        $this->_executed = true;\n        return $this->_exitCode === 0;\n    }\n\n    public function getOutput(): string\n    {\n        return $this->_stdOut;\n    }\n\n    public function getError(): string\n    {\n        return $this->_error;\n    }\n\n    public function getStdErr(): string\n    {\n        return $this->_stdErr;\n    }\n\n    public function getExitCode(): ?int\n    {\n        return $this->_exitCode;\n    }\n\n\n    protected function buildExecCommand(): void\n    {\n        $command = $this->_command;\n        if ($this->escapeCommand) {\n            $command = escapeshellcmd($command);\n        }\n\n        $this->_execCommand = $command . ' ' . implode(' ', $this->_args);\n    }\n}\n",
      "<?php\n\nclass Command\n{\n    public bool $escapeArgs = true;\n    public bool $escapeCommand = false;\n    public bool $useExec = false;\n    public bool $captureStdErr = true;\n    public ?string $procCwd = null;\n    public ?array $procEnv = null;\n    public ?array $procOptions = null;\n\n    protected string $_command = '';\n    protected array $_args = [];\n    protected ?string $_execCommand = null;\n\n    protected string $_stdOut = '';\n    protected string $_stdErr = '';\n    protected ?int $_exitCode = null;\n    protected string $_error = '';\n    protected bool $_executed = false;\n\n\n    public function __construct(mixed $options = null)\n    {\n        if (is_string($options)) {\n            $this->setCommand($options);\n        } elseif (is_array($options)) {\n            foreach ($options as $key => $value) {\n                if (property_exists($this, $key)) {\n                    $this->$key = $value;\n                }\n            }\n        }\n    }\n\n    public function setCommand(string $command): self\n    {\n        $this->_command = $command;\n        return $this;\n    }\n\n    public function getCommand(): string\n    {\n        return $this->_command;\n    }\n\n\n    public function getExecCommand(): string|false\n    {\n        if (!$this->_execCommand) {\n            $this->buildExecCommand();\n        }\n        return $this->_execCommand;\n    }\n\n    public function addArg(string $key, mixed $value = null, bool $escape = null): self\n    {\n        $arg = $key;\n        if ($value !== null) {\n            $arg .= ' ';\n            if ($escape ?? $this->escapeArgs) {\n                $value = escapeshellarg($value);\n            }\n            $arg .= $value;\n        }\n\n        $this->_args[] = $arg;\n        return $this;\n    }\n\n    public function execute(): bool\n    {\n        $this->buildExecCommand();\n\n        if ($this->useExec) {\n            exec($this->_execCommand, $output, $return_var);\n            $this->_stdOut = implode(\"\\n\", $output);\n            $this->_exitCode = $return_var;\n        } else {\n            $descriptors = [\n                1 => ['pipe', 'w'],\n                2 => $this->captureStdErr ? ['pipe', 'w'] : ['dev', 'null']\n            ];\n\n            $process = proc_open($this->_execCommand, $descriptors, $pipes, $this->procCwd, $this->procEnv, $this->procOptions);\n\n            if (is_resource($process)) {\n                $this->_stdOut = stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n\n                if ($this->captureStdErr) {\n                    $this->_stdErr = stream_get_contents($pipes[2]);\n                    fclose($pipes[2]);\n                }\n\n                $this->_exitCode = proc_close($process);\n            } else {\n                $this->_error = 'Failed to open process.';\n                return false;\n            }\n        }\n\n        $this->_executed = true;\n        return $this->_exitCode === 0;\n    }\n\n    public function getOutput(): string\n    {\n        return $this->_stdOut;\n    }\n\n    public function getError(): string\n    {\n        return $this->_error;\n    }\n\n    public function getStdErr(): string\n    {\n        return $this->_stdErr;\n    }\n\n    public function getExitCode(): ?int\n    {\n        return $this->_exitCode;\n    }\n\n    protected function buildExecCommand(): void\n    {\n        $command = $this->_command;\n        if ($this->escapeCommand) {\n            $command = escapeshellcmd($command);\n        }\n        $this->_execCommand = $command . ' ' . implode(' ', $this->_args);\n    }\n}\n",
      "```php\n<?php\n\nclass Command\n{\n    public bool $escapeArgs = true;\n    public bool $escapeCommand = false;\n    public bool $useExec = false;\n    public bool $captureStdErr = true;\n    public ?string $procCwd = null;\n    public ?array $procEnv = null;\n    public ?array $procOptions = null;\n    protected string $_command;\n    protected array $_args = [];\n    protected ?string $_execCommand = null;\n    protected string $_stdOut = '';\n    protected string $_stdErr = '';\n    protected ?int $_exitCode = null;\n    protected string $_error = '';\n    protected bool $_executed = false;\n\n    public function __construct(mixed $options = null)\n    {\n        if (is_string($options)) {\n            $this->setCommand($options);\n        } elseif (is_array($options)) {\n            foreach ($options as $key => $value) {\n                if (property_exists($this, $key)) {\n                    $this->$key = $value;\n                }\n            }\n        }\n    }\n\n    public function setCommand(string $command): self\n    {\n        $this->_command = $command;\n        return $this;\n    }\n\n    public function getCommand(): string\n    {\n        return $this->_command;\n    }\n\n    public function getExecCommand(): string|false\n    {\n        if (!$this->_executed && !$this->buildCommand()) {\n            return false;\n        }\n        return $this->_execCommand;\n    }\n\n    public function addArg(string $key, mixed $value = null, bool $escape = null): self\n    {\n        $arg = $key;\n        if ($value !== null) {\n            $arg .= ' ';\n            $arg .= ($escape ?? $this->escapeArgs) ? escapeshellarg($value) : $value;\n        }\n        $this->_args[] = $arg;\n        return $this;\n    }\n\n\n    public function execute(): bool\n    {\n        if (!$this->buildCommand()) {\n            return false;\n        }\n\n        if ($this->useExec) {\n            exec($this->_execCommand, $output, $this->_exitCode);\n            $this->_stdOut = implode(\"\\n\", $output);\n        } else {\n            $descriptors = [\n                1 => ['pipe', 'w'],\n                2 => $this->captureStdErr ? ['pipe', 'w'] : ['dev', 'null']\n            ];\n            $process = proc_open($this->_execCommand, $descriptors, $pipes, $this->procCwd, $this->procEnv, $this->procOptions);\n\n            if (is_resource($process)) {\n                $this->_stdOut = stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n                if ($this->captureStdErr) {\n                    $this->_stdErr = stream_get_contents($pipes[2]);\n                    fclose($pipes[2]);\n                }\n                $this->_exitCode = proc_close($process);\n            } else {\n                $this->_error = 'Failed to open process.';\n                return false;\n            }\n        }\n        $this->_executed = true;\n        return true;\n    }\n\n    public function getOutput(): string\n    {\n        return $this->_stdOut;\n    }\n\n    public function getError(): string\n    {\n        return $this->_error;\n    }\n\n    public function getStdErr(): string\n    {\n        return $this->_stdErr;\n    }\n\n    public function getExitCode(): ?int\n    {\n        return $this->_exitCode;\n    }\n\n    protected function buildCommand(): bool\n    {\n        if (empty($this->_command)) {\n            $this->_error = 'No command set.';\n            return false;\n        }\n\n        $command = $this->escapeCommand ? escapeshellcmd($this->_command) : $this->_command;\n        $this->_execCommand = $command . ' ' . implode(' ', $this->_args);\n        return true;\n    }\n}\n\n```",
      "```php\n<?php\n\nclass Command\n{\n    public bool $escapeArgs = true;\n    public bool $escapeCommand = false;\n    public bool $useExec = false;\n    public bool $captureStdErr = true;\n    public ?string $procCwd = null;\n    public ?array $procEnv = null;\n    public ?array $procOptions = null;\n    protected string $_command = '';\n    protected array $_args = [];\n    protected ?string $_execCommand = null;\n    protected string $_stdOut = '';\n    protected string $_stdErr = '';\n    protected ?int $_exitCode = null;\n    protected string $_error = '';\n    protected bool $_executed = false;\n\n\n    public function __construct(mixed $options = null)\n    {\n        if (is_string($options)) {\n            $this->setCommand($options);\n        } elseif (is_array($options)) {\n            foreach ($options as $key => $value) {\n                if (property_exists($this, $key)) {\n                    $this->$key = $value;\n                }\n            }\n        }\n    }\n\n    public function setCommand(string $command): self\n    {\n        $this->_command = $command;\n        return $this;\n    }\n\n    public function getCommand(): string\n    {\n        return $this->_command;\n    }\n\n\n    public function getExecCommand(): string|false\n    {\n        if (!$this->_executed && !$this->buildCommand()) {\n            return false;\n        }\n        return $this->_execCommand;\n    }\n\n    public function addArg(string $key, mixed $value = null, bool $escape = null): self\n    {\n        $arg = $key;\n        if ($value !== null) {\n            $arg .= ' ';\n            if ($escape ?? $this->escapeArgs) {\n                $value = escapeshellarg($value);\n            }\n            $arg .= $value;\n        }\n\n        $this->_args[] = $arg;\n        return $this;\n    }\n\n\n    public function execute(): bool\n    {\n        if (!$this->buildCommand()) {\n            return false;\n        }\n\n        if ($this->useExec) {\n            exec($this->_execCommand, $output, $this->_exitCode);\n            $this->_stdOut = implode(\"\\n\", $output);\n        } else {\n            $descriptors = [\n                1 => ['pipe', 'w'],\n                2 => $this->captureStdErr ? ['pipe', 'w'] : ['dev', 'null']\n            ];\n\n            $process = proc_open($this->_execCommand, $descriptors, $pipes, $this->procCwd, $this->procEnv, $this->procOptions);\n\n            if (is_resource($process)) {\n                $this->_stdOut = stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n\n                if ($this->captureStdErr) {\n                    $this->_stdErr = stream_get_contents($pipes[2]);\n                    fclose($pipes[2]);\n                }\n\n                $this->_exitCode = proc_close($process);\n            } else {\n                $this->_error = 'Failed to open process.';\n                return false;\n            }\n        }\n        $this->_executed = true;\n        return true;\n    }\n\n\n    public function getOutput(): string\n    {\n        return $this->_stdOut;\n    }\n\n    public function getError(): string\n    {\n        return $this->_error;\n    }\n\n    public function getStdErr(): string\n    {\n        return $this->_stdErr;\n    }\n\n    public function getExitCode(): ?int\n    {\n        return $this->_exitCode;\n    }\n\n\n    protected function buildCommand(): bool\n    {\n        if (empty($this->_command)) {\n            $this->_error = 'No command set.';\n            return false;\n        }\n\n        $command = $this->escapeCommand ? escapeshellcmd($this->_command) : $this->_command;\n        $this->_execCommand = $command . ' ' . implode(' ', $this->_args);\n        return true;\n    }\n}\n\n```",
      "<?php\n\nclass Command\n{\n    public bool $escapeArgs = true;\n    public bool $escapeCommand = false;\n    public bool $useExec = false;\n    public bool $captureStdErr = true;\n    public ?string $procCwd = null;\n    public ?array $procEnv = null;\n    public ?array $procOptions = null;\n\n    protected string $_command = '';\n    protected array $_args = [];\n    protected ?string $_execCommand = null;\n\n    protected string $_stdOut = '';\n    protected string $_stdErr = '';\n    protected ?int $_exitCode = null;\n    protected string $_error = '';\n    protected bool $_executed = false;\n\n\n    public function __construct(mixed $options = null)\n    {\n        if (is_string($options)) {\n            $this->setCommand($options);\n        } elseif (is_array($options)) {\n            foreach ($options as $key => $value) {\n                if (property_exists($this, $key)) {\n                    $this->$key = $value;\n                }\n            }\n        }\n    }\n\n    public function setCommand(string $command): self\n    {\n        $this->_command = $command;\n        return $this;\n    }\n\n    public function getCommand(): string\n    {\n        return $this->_command;\n    }\n\n\n    public function getExecCommand(): string|false\n    {\n        if (!$this->_execCommand) {\n            $this->buildExecCommand();\n        }\n        return $this->_execCommand;\n    }\n\n    public function addArg(string $key, mixed $value = null, bool $escape = null): self\n    {\n        $arg = $key;\n        if ($value !== null) {\n            $arg .= '=' . ($escape ?? $this->escapeArgs ? escapeshellarg($value) : $value);\n        }\n\n        $this->_args[] = $arg;\n        return $this;\n    }\n\n\n    public function execute(): bool\n    {\n        $this->buildExecCommand();\n\n        if ($this->useExec) {\n            exec($this->_execCommand, $output, $this->_exitCode);\n            $this->_stdOut = implode(\"\\n\", $output);\n        } else {\n            $descriptors = [\n                1 => ['pipe', 'w'],\n                2 => $this->captureStdErr ? ['pipe', 'w'] : ['dev', 'null']\n            ];\n\n            $process = proc_open($this->_execCommand, $descriptors, $pipes, $this->procCwd, $this->procEnv, $this->procOptions);\n\n\n            if (is_resource($process)) {\n                $this->_stdOut = stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n\n                if ($this->captureStdErr) {\n                    $this->_stdErr = stream_get_contents($pipes[2]);\n                    fclose($pipes[2]);\n                }\n\n                $this->_exitCode = proc_close($process);\n            } else {\n                $this->_error = 'Failed to open process.';\n                return false;\n            }\n        }\n        $this->_executed = true;\n        return $this->_exitCode === 0;\n    }\n\n    public function getOutput(): string\n    {\n        return $this->_stdOut;\n    }\n\n    public function getError(): string\n    {\n        return $this->_error;\n    }\n\n    public function getStdErr(): string\n    {\n        return $this->_stdErr;\n    }\n\n    public function getExitCode(): ?int\n    {\n        return $this->_exitCode;\n    }\n\n\n    protected function buildExecCommand(): void\n    {\n        $command = $this->escapeCommand ? escapeshellcmd($this->_command) : $this->_command;\n        $this->_execCommand = $command . ' ' . implode(' ', $this->_args);\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a PHP class that handles process execution and communication using pipes, specifically designed for logging purposes. The class should manage subprocess creation, input/output streams, and error handling.\n\nClass Description: ProcessHandler is a logging handler that executes a subprocess and communicates with it through pipes (stdin, stdout, stderr). It ensures proper process management, handles startup errors, and provides methods for writing input and reading errors.\n\nAttributes:\n- process: [resource|null] - The subprocess resource handle\n- command: [string] - The command to execute as a subprocess\n- cwd: [string|null] - The working directory for the subprocess\n- pipes: [array] - Array of file pointers for process pipes (stdin, stdout, stderr)\n\nMethods:\n- __construct(string $command, int|string|Level $level = Level::Debug, bool $bubble = true, ?string $cwd = null) -> [void] - Initializes the handler with command, log level, and working directory\n- write(LogRecord $record) -> [void] - Writes formatted log record to the process stdin\n- close() -> [void] - Closes all pipes and terminates the process\n- ensureProcessIsStarted() -> [void] - Ensures the subprocess is running (starts if not)\n- startProcess() -> [void] - Starts the subprocess using proc_open\n- handleStartupErrors() -> [void] - Checks for and handles any startup errors\n- selectErrorStream() -> [int|false] - Monitors the stderr pipe for activity\n- readProcessErrors() -> [string] - Reads and returns error output from stderr\n- writeProcessInput(string $string) -> [void] - Writes data to the process stdin",
    "Canonical_solution": "use Monolog\\Level;\nuse Monolog\\LogRecord;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private string $command;\n    private ?string $cwd;\n    private array $pipes = [];\n    protected const DESCRIPTOR_SPEC = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    public function __construct(string $command, int|string|Level $level = Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        if ($command === '') {\n            throw new \\InvalidArgumentException('The command argument must be a non-empty string.');\n        }\n        if ($cwd === '') {\n            throw new \\InvalidArgumentException('The optional CWD argument must be a non-empty string or null.');\n        }\n\n        parent::__construct($level, $bubble);\n\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    protected function write(LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n\n        $errors = $this->readProcessErrors();\n        if ($errors !== '') {\n            throw new \\UnexpectedValueException(sprintf('Errors while writing to process: %s', $errors));\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (is_resource($this->process) === false) {\n            $this->startProcess();\n            $this->handleStartupErrors();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $this->process = proc_open($this->command, static::DESCRIPTOR_SPEC, $this->pipes, $this->cwd);\n        foreach ($this->pipes as $pipe) {\n            stream_set_blocking($pipe, false);\n        }\n    }\n\n    private function handleStartupErrors(): void\n    {\n        $selected = $this->selectErrorStream();\n        if (false === $selected) {\n            throw new \\UnexpectedValueException('Something went wrong while selecting a stream.');\n        }\n\n        $errors = $this->readProcessErrors();\n        if (is_resource($this->process) === false || $errors !== '') {\n            throw new \\UnexpectedValueException(\n                sprintf('The process \"%s\" could not be opened: ' . $errors, $this->command)\n            );\n        }\n    }\n\n    protected function selectErrorStream()\n    {\n        $empty = [];\n        $errorPipes = [$this->pipes[2]];\n        return stream_select($errorPipes, $empty, $empty, 1);\n    }\n\n    protected function readProcessErrors(): string\n    {\n        return (string) stream_get_contents($this->pipes[2]);\n    }\n\n    protected function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n\n    public function close(): void\n    {\n        if (is_resource($this->process)) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nclass ProcessHandler extends \\Monolog\\Handler\\AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, int|string|\\Monolog\\Level $level = \\Monolog\\Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(\\Monolog\\LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false); \n        stream_set_blocking($this->pipes[2], false); \n    }\n\n    private function handleStartupErrors(): void\n    {\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nclass ProcessHandler extends \\Monolog\\Handler\\AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, int|string|\\Monolog\\Level $level = \\Monolog\\Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(\\Monolog\\LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false); \n        stream_set_blocking($this->pipes[2], false); \n    }\n\n    private function handleStartupErrors(): void\n    {\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nclass ProcessHandler extends \\Monolog\\Handler\\AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, int|string|\\Monolog\\Level $level = \\Monolog\\Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(\\Monolog\\LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false); \n        stream_set_blocking($this->pipes[2], false); \n    }\n\n    private function handleStartupErrors(): void\n    {\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nclass ProcessHandler extends \\Monolog\\Handler\\AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, int|string|\\Monolog\\Level $level = \\Monolog\\Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(\\Monolog\\LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false);\n        stream_set_blocking($this->pipes[2], false);\n    }\n\n    private function handleStartupErrors(): void\n    {\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nclass ProcessHandler extends \\Monolog\\Handler\\AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, int|string|\\Monolog\\Level $level = \\Monolog\\Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(\\Monolog\\LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false); \n        stream_set_blocking($this->pipes[2], false); \n    }\n\n    private function handleStartupErrors(): void\n    {\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nclass ProcessHandler extends \\Monolog\\Handler\\AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, int|string|\\Monolog\\Level $level = \\Monolog\\Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(\\Monolog\\LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record['formatted']);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false); \n        stream_set_blocking($this->pipes[2], false); \n    }\n\n    private function handleStartupErrors(): void\n    {\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = [];\n        $except = [];\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nclass ProcessHandler extends \\Monolog\\Handler\\AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, int|string|\\Monolog\\Level $level = \\Monolog\\Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(\\Monolog\\LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false);\n        stream_set_blocking($this->pipes[2], false);\n    }\n\n    private function handleStartupErrors(): void\n    {\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nclass ProcessHandler extends \\Monolog\\Handler\\AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, int|string|\\Monolog\\Level $level = \\Monolog\\Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(\\Monolog\\LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false); \n        stream_set_blocking($this->pipes[2], false); \n    }\n\n    private function handleStartupErrors(): void\n    {\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nclass ProcessHandler extends \\Monolog\\Handler\\AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, int|string|\\Monolog\\Level $level = \\Monolog\\Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(\\Monolog\\LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false);\n        stream_set_blocking($this->pipes[2], false);\n    }\n\n    private function handleStartupErrors(): void\n    {\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nclass ProcessHandler extends \\Monolog\\Handler\\AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, int|string|\\Monolog\\Level $level = \\Monolog\\Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(\\Monolog\\LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false); \n        stream_set_blocking($this->pipes[2], false); \n    }\n\n    private function handleStartupErrors(): void\n    {\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 144,
    "Instruction": "Task Description: Create a function that retrieves Git tag information from a specified directory using subprocess communication via pipes.\n\nFunction Description: The function checks if a given directory is a Git repository (by checking for .git folder) and then executes the 'git describe --tags' command to get the latest tag information. It handles subprocess communication using pipes for stdout and stderr, properly manages resources, and returns the tag information or false if unsuccessful.\n\nInput: \n- $path (string): The filesystem path to check for Git repository and execute Git command\n\nOutput:\n- Returns (string|bool): The trimmed output from 'git describe --tags' command as string if successful, false if:\n  - The path is not a Git repository\n  - The subprocess cannot be created\n  - The Git command returns a non-zero exit code",
    "Canonical_solution": "function getGitInformation(string $path)\n{\n    if (!\\is_dir($path . DIRECTORY_SEPARATOR . '.git')) {\n        return false;\n    }\n\n    $process = \\proc_open(\n        'git describe --tags',\n        [\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ],\n        $pipes,\n        $path\n    );\n\n    if (!\\is_resource($process)) {\n        return false;\n    }\n\n    $result = \\trim(\\stream_get_contents($pipes[1]));\n\n    \\fclose($pipes[1]);\n    \\fclose($pipes[2]);\n\n    $returnCode = \\proc_close($process);\n\n    if ($returnCode !== 0) {\n        return false;\n    }\n\n    return $result;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|bool {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'], // stdin\n        1 => ['pipe', 'w'], // stdout\n        2 => ['pipe', 'w'], // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|bool {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|bool {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|bool {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|bool {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|bool {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|bool {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|bool {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|bool {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```",
      "```php\n<?php\n\nfunction get_git_tag_info(string $path): string|bool {\n    $git_dir = $path . '/.git';\n    if (!is_dir($git_dir)) {\n        return false;\n    }\n\n    $descriptors = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open('git describe --tags', $descriptors, $pipes, $path);\n\n    if (!is_resource($process)) {\n        return false;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $return_code = proc_close($process);\n\n    if ($return_code !== 0) {\n        return false;\n    }\n\n    return trim($output);\n}\n\n?>\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 145,
    "Instruction": "Task Description: Create a function that executes a shell command in a subprocess and captures its standard output while properly handling resources and errors.\n\nFunction Description: The function `readFromProcess` executes a given shell command as a subprocess using PHP's `proc_open`, captures the output from the subprocess's stdout stream, and ensures all resources are properly closed. It handles cases where the `proc_open` function is unavailable or fails to create the subprocess.\n\nInput: \n- `$command` (string): The shell command to be executed in the subprocess.\n\nOutput: \n- (string|null): Returns the captured output from the subprocess's stdout if successful, or null if the subprocess could not be created or if `proc_open` is unavailable.",
    "Canonical_solution": "function readFromProcess($command)\n{\n    if (!\\function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes, null, null, ['suppress_errors' => true]);\n    if (!\\is_resource($process)) {\n        return null;\n    }\n\n    $info = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n    proc_close($process);\n\n    return $info;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "<?php\n\nfunction readFromProcess(string $command): ?string\n{\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction readFromProcess(string $command): ?string\n{\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction readFromProcess(string $command): ?string\n{\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction readFromProcess(string $command): ?string\n{\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction readFromProcess(string $command): ?string\n{\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction readFromProcess(string $command): ?string\n{\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction readFromProcess(string $command): ?string\n{\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction readFromProcess(string $command): ?string\n{\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction readFromProcess(string $command): ?string\n{\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n\n    return $output;\n}\n\n?>\n",
      "<?php\n\nfunction readFromProcess(string $command): ?string\n{\n    if (!function_exists('proc_open')) {\n        return null;\n    }\n\n    $descriptorspec = [\n        0 => ['pipe', 'r'],  // stdin\n        1 => ['pipe', 'w'],  // stdout\n        2 => ['pipe', 'w'],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return null;\n    }\n\n    fclose($pipes[0]);\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n\n    return $output;\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a PHP class that manages a subprocess using proc_open, handling input/output streams and proper cleanup.\n\nClass Description: ProcessStream is a class that manages the lifecycle of a subprocess, including initialization, stream handling, and termination. It provides access to the subprocess's standard input and output streams while properly handling errors and resource cleanup.\n\nAttributes:\n- command: string - The command to be executed in the subprocess\n- stream: resource - The process resource created by proc_open\n- in: resource - The input stream (stdin) of the subprocess\n- out: resource - The output stream (stdout) of the subprocess\n\nMethods:\n- setCommand(string $command): void - Sets the command to be executed by the subprocess\n- initialize(): void - Starts the subprocess, sets up streams, and checks for startup errors\n- terminate(): void - Closes all streams and terminates the subprocess\n- getReadConnectionDescription(): string - Returns a description of the process connection",
    "Canonical_solution": "namespace Symfony\\Component\\Mailer\\Transport\\Smtp\\Stream;\n\nuse Symfony\\Component\\Mailer\\Exception\\TransportException;\n\nfinal class ProcessStream extends AbstractStream\n{\n    private string $command;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorSpec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', '\\\\' === \\DIRECTORY_SEPARATOR ? 'a' : 'w'],\n        ];\n        $pipes = [];\n        $this->stream = proc_open($this->command, $descriptorSpec, $pipes);\n        stream_set_blocking($pipes[2], false);\n        if ($err = stream_get_contents($pipes[2])) {\n            throw new TransportException('Process could not be started: '.$err);\n        }\n        $this->in = &$pipes[0];\n        $this->out = &$pipes[1];\n    }\n\n    public function terminate(): void\n    {\n        if (null !== $this->stream) {\n            fclose($this->in);\n            fclose($this->out);\n            proc_close($this->stream);\n        }\n\n        parent::terminate();\n    }\n\n    protected function getReadConnectionDescription(): string\n    {\n        return 'process '.$this->command;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException(\"Failed to start subprocess.\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n\n        fclose($pipes[2]);\n    }\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return \"Process not initialized.\";\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta[\"uri\"] ?? \"Unknown connection description.\";\n\n    }\n\n    public function __destruct()\n    {\n        $this->terminate();\n    }\n}\n\n?>\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException(\"Failed to start subprocess.\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n\n        fclose($pipes[2]);\n    }\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return \"Process not initialized.\";\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta['uri'] ?? \"No URI available.\";\n    }\n\n    public function __destruct()\n    {\n        $this->terminate();\n    }\n}\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException(\"Failed to start process.\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n\n        fclose($pipes[2]);\n    }\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return \"Process not initialized.\";\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta[\"uri\"] ?? \"No URI available.\";\n\n    }\n\n    public function __destruct()\n    {\n        $this->terminate();\n    }\n}\n\n?>\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException(\"Failed to start subprocess.\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n\n        fclose($pipes[2]);\n    }\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return \"Process not initialized.\";\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta['uri'] ?? \"No URI available.\";\n    }\n\n\n    public function __destruct()\n    {\n        $this->terminate();\n    }\n}\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException(\"Failed to start process.\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n\n        fclose($pipes[2]);\n    }\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return \"Process not initialized.\";\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta[\"uri\"] ?? \"No URI available.\";\n    }\n\n    public function __destruct()\n    {\n        $this->terminate();\n    }\n}\n\n?>\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException(\"Failed to start subprocess.\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n\n        fclose($pipes[2]);\n    }\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return \"Process not initialized.\";\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta[\"uri\"] ?? \"Unknown connection description.\";\n    }\n\n    public function __destruct()\n    {\n        $this->terminate();\n    }\n}\n\n?>\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException(\"Failed to start process.\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n\n        fclose($pipes[2]);\n    }\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return \"Process not initialized.\";\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta[\"uri\"] ?? \"No URI available.\";\n\n    }\n\n    public function __destruct()\n    {\n        $this->terminate();\n    }\n}\n?>\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException(\"Failed to start subprocess.\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n\n        fclose($pipes[2]);\n    }\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return \"Process not initialized.\";\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta[\"uri\"] ?? \"No stream URI available.\";\n\n    }\n\n    public function __destruct()\n    {\n        $this->terminate();\n    }\n}\n\n?>\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException(\"Failed to start subprocess.\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n\n        fclose($pipes[2]);\n    }\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return \"Process not initialized.\";\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta[\"uri\"] ?? \"Unknown stream URI\";\n    }\n\n\n    public function __destruct()\n    {\n        $this->terminate();\n    }\n}\n\n?>\n",
      "<?php\n\nclass ProcessStream\n{\n    private string $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"],\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (!is_resource($this->stream)) {\n            throw new \\RuntimeException(\"Failed to start process.\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n\n        fclose($pipes[2]);\n    }\n\n    public function terminate(): void\n    {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string\n    {\n        if (!is_resource($this->stream)) {\n            return \"Process not initialized.\";\n        }\n        $meta = stream_get_meta_data($this->out);\n        return $meta[\"uri\"] ?? \"No URI available.\";\n    }\n\n\n    public function __destruct()\n    {\n        $this->terminate();\n    }\n}\n?>\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 147,
    "Instruction": "Task Description: Create a function that executes a shell command and captures its standard output and error streams using PHP's proc_open.\n\nFunction Description: The function should execute a given shell command, capture both stdout and stderr streams, properly close all resources, and return the exit code of the process. It should handle cases where process creation fails.\n\nInput:\n- $command: string - The shell command to execute\n- &$stdout: ?string (optional reference) - Variable to store the standard output\n- &$stderr: ?string (optional reference) - Variable to store the standard error\n\nOutput:\n- int - The exit code of the executed process. Returns -1 if process creation fails.",
    "Canonical_solution": "function execute(string $command, ?string &$stdout = null, ?string &$stderr = null) : int\n{\n    $process = proc_open($command, [\n        [\"pipe\", \"r\"],\n        [\"pipe\", \"w\"],\n        [\"pipe\", \"w\"]\n    ], $pipes);\n\n    if($process === false){\n        $stderr = \"Failed to open process\";\n        $stdout = \"\";\n        return -1;\n    }\n\n    $stdout = stream_get_contents($pipes[1]);\n    $stderr = stream_get_contents($pipes[2]);\n\n    foreach($pipes as $p){\n        fclose($p);\n    }\n\n    return proc_close($process);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "<?php\n\nfunction executeCommand(string $command, ?string &$stdout = null, ?string &$stderr = null): int {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return -1;\n    }\n\n    fclose($pipes[0]);\n\n    $stdout = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $stderr = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    return proc_close($process);\n}\n\n?>\n",
      "<?php\n\nfunction executeCommand(string $command, ?string &$stdout = null, ?string &$stderr = null): int {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return -1;\n    }\n\n    fclose($pipes[0]);\n\n    $stdout = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $stderr = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $exitCode = proc_close($process);\n\n    return $exitCode;\n}\n\n?>\n",
      "<?php\n\nfunction executeCommand(string $command, ?string &$stdout = null, ?string &$stderr = null): int {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return -1;\n    }\n\n    fclose($pipes[0]);\n\n    $stdout = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $stderr = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $exitCode = proc_close($process);\n\n    return $exitCode;\n}\n\n?>\n",
      "<?php\n\nfunction executeCommand(string $command, ?string &$stdout = null, ?string &$stderr = null): int {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return -1;\n    }\n\n    fclose($pipes[0]);\n\n    $stdout = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $stderr = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $exitCode = proc_close($process);\n\n    return $exitCode;\n}\n\n?>\n",
      "<?php\n\nfunction executeCommand(string $command, ?string &$stdout = null, ?string &$stderr = null): int {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return -1;\n    }\n\n    fclose($pipes[0]);\n\n    $stdout = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $stderr = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $exitCode = proc_close($process);\n\n    return $exitCode;\n}\n\n?>\n",
      "<?php\nfunction executeCommand(string $command, ?string &$stdout = null, ?string &$stderr = null): int {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return -1;\n    }\n\n    fclose($pipes[0]);\n\n    $stdout = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $stderr = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    return proc_close($process);\n}\n?>\n",
      "<?php\n\nfunction executeCommand(string $command, ?string &$stdout = null, ?string &$stderr = null): int {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return -1;\n    }\n\n    fclose($pipes[0]);\n\n    $stdout = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $stderr = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $exitCode = proc_close($process);\n\n    return $exitCode;\n}\n\n?>\n",
      "<?php\n\nfunction executeCommand(string $command, ?string &$stdout = null, ?string &$stderr = null): int {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return -1;\n    }\n\n    fclose($pipes[0]);\n\n    $stdout = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $stderr = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    return proc_close($process);\n}\n\n?>\n",
      "<?php\n\nfunction executeCommand(string $command, ?string &$stdout = null, ?string &$stderr = null): int {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return -1;\n    }\n\n    fclose($pipes[0]);\n\n    $stdout = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $stderr = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    $exitCode = proc_close($process);\n\n    return $exitCode;\n}\n\n?>\n",
      "<?php\n\nfunction executeCommand(string $command, ?string &$stdout = null, ?string &$stderr = null): int {\n    $descriptorspec = [\n        0 => [\"pipe\", \"r\"],  // stdin\n        1 => [\"pipe\", \"w\"],  // stdout\n        2 => [\"pipe\", \"w\"],  // stderr\n    ];\n\n    $process = proc_open($command, $descriptorspec, $pipes);\n\n    if (!is_resource($process)) {\n        return -1;\n    }\n\n    fclose($pipes[0]);\n\n    $stdout = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $stderr = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    return proc_close($process);\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 148,
    "Instruction": "Task Description: Create a function that executes system commands using various PHP execution methods, with fallback options from most to least preferred, and returns the command output along with execution method information.\n\nFunction Description: The function attempts to execute a system command using multiple PHP execution methods in a prioritized order (COM, exec, shell_exec, system, passthru, popen, proc_open). It handles both Windows and Unix-like systems, sets the working directory, and properly manages process pipes and resources. The function returns the command output and indicates which execution method was successful.\n\nInput:\n- $cmd: [string] - The system command to be executed\n- $cwd: [string] - The working directory where the command should be executed\n- $com: [bool] (optional) - Flag to force using COM method on Windows (default: false)\n\nOutput:\n- Returns [array] with two elements:\n  - 'res': [string] - The output from the executed command\n  - 'msg': [string] - Status message indicating the execution method used or NULL if no output",
    "Canonical_solution": "function command($cmd, $cwd, $com = false) {\n    $iswin = substr(PHP_OS,0,3) == 'WIN' ? true : false;\n    $res = $msg = '';\n    \n    if($cwd == 'com' || $com) {\n        if($iswin && class_exists('COM')) {\n            $wscript = new COM('Wscript.Shell');\n            $exec = $wscript->exec('c:\\\\windows\\\\system32\\\\cmd.exe /c '.$cmd);\n            $stdout = $exec->StdOut();\n            $res = $stdout->ReadAll();\n            $msg = 'Wscript.Shell';\n        }\n    } else {\n        chdir($cwd);\n        $cwd = getcwd();\n        \n        if(function_exists('exec')) {\n            @exec($cmd, $res);\n            $res = join(\"\\n\", $res);\n            $msg = 'exec';\n        }\n        elseif(function_exists('shell_exec')) {\n            $res = @shell_exec($cmd);\n            $msg = 'shell_exec';\n        }\n        elseif(function_exists('system')) {\n            ob_start();\n            @system($cmd);\n            $res = ob_get_contents();\n            ob_end_clean();\n            $msg = 'system';\n        }\n        elseif(function_exists('passthru')) {\n            ob_start();\n            @passthru($cmd);\n            $res = ob_get_contents();\n            ob_end_clean();\n            $msg = 'passthru';\n        }\n        elseif(function_exists('popen')) {\n            $fp = @popen($cmd, 'r');\n            if($fp) {\n                while(!feof($fp)) {\n                    $res .= fread($fp, 1024);\n                }\n            }\n            @pclose($fp);\n            $msg = 'popen';\n        }\n        elseif(function_exists('proc_open')) {\n            $env = $iswin ? array('path' => 'c:\\\\windows\\\\system32') : array('path' => '/bin:/usr/bin:/usr/local/bin:/usr/local/sbin:/usr/sbin');\n            $des = array(\n                0 => array(\"pipe\", \"r\"),\n                1 => array(\"pipe\", \"w\"),\n                2 => array(\"pipe\", \"w\")\n            );\n            $process = @proc_open($cmd, $des, $pipes, $cwd, $env);\n            \n            if(is_resource($process)) {\n                fwrite($pipes[0], $cmd);\n                fclose($pipes[0]);\n                $res .= stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n                $res .= stream_get_contents($pipes[2]);\n                fclose($pipes[2]);\n            }\n            @proc_close($process);\n            $msg = 'proc_open';\n        }\n    }\n    \n    $msg = $res == '' ? '<h1>NULL</h1>' : '<h2>利用'.$msg.'执行成功</h2>';\n    return array('res' => $res, 'msg' => $msg);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "<?php\n\nfunction execute_command($cmd, $cwd, $com = false) {\n    $res = null;\n    $msg = null;\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' && $com) {\n        $wsh = new COM('WScript.Shell');\n        $exec = $wsh->exec($cmd);\n        $stdout = $exec->StdOut();\n        $res = $stdout->ReadAll();\n        $msg = 'Executed using COM';\n    } elseif (function_exists('exec')) {\n        $res = [];\n        exec($cmd, $res);\n        $res = implode(\"\\n\", $res);\n        $msg = 'Executed using exec';\n    } elseif (function_exists('shell_exec')) {\n        $res = shell_exec($cmd);\n        $msg = 'Executed using shell_exec';\n    } elseif (function_exists('system')) {\n        ob_start();\n        system($cmd);\n        $res = ob_get_contents();\n        ob_end_clean();\n        $msg = 'Executed using system';\n    } elseif (function_exists('passthru')) {\n        ob_start();\n        passthru($cmd);\n        $res = ob_get_contents();\n        ob_end_clean();\n        $msg = 'Executed using passthru';\n    } elseif (function_exists('popen')) {\n        $handle = popen($cmd, 'r');\n        if ($handle) {\n            $res = stream_get_contents($handle);\n            pclose($handle);\n            $msg = 'Executed using popen';\n        }\n    } elseif (function_exists('proc_open')) {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n        $process = proc_open($cmd, $descriptorspec, $pipes, $cwd);\n\n        if (is_resource($process)) {\n            $res = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n\n            $error = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n\n            $return_value = proc_close($process);\n            if ($return_value == 0) {\n                $msg = 'Executed using proc_open';\n            } else {\n                $res = $error;\n                $msg = 'Error using proc_open: ' . $return_value;\n            }\n        }\n    }\n\n    return ['res' => $res, 'msg' => $msg];\n}\n\n?>\n",
      "<?php\n\nfunction execute_command($cmd, $cwd, $com = false) {\n    $descriptors = array(\n        0 => array(\"pipe\", \"r\"),\n        1 => array(\"pipe\", \"w\"),\n        2 => array(\"pipe\", \"w\")\n    );\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' && class_exists('COM') && $com) {\n        $wsh = new COM('WScript.Shell');\n        $exec = $wsh->exec($cmd);\n        $stdout = $exec->StdOut->ReadAll();\n        $stderr = $exec->StdErr->ReadAll();\n        if ($stdout) {\n            return array('res' => $stdout, 'msg' => 'Executed using COM');\n        } elseif ($stderr) {\n            return array('res' => $stderr, 'msg' => 'Error using COM');\n        }\n    } elseif (function_exists('exec')) {\n        $output = array();\n        exec($cmd, $output, $return_var);\n        if ($output) {\n            return array('res' => implode(\"\\n\", $output), 'msg' => 'Executed using exec');\n        } elseif ($return_var !== 0) {\n            return array('res' => null, 'msg' => 'Error using exec (Code: ' . $return_var . ')');\n        }\n    } elseif (function_exists('shell_exec')) {\n        $output = shell_exec($cmd);\n        if ($output) {\n            return array('res' => $output, 'msg' => 'Executed using shell_exec');\n        }\n    } elseif (function_exists('system')) {\n        ob_start();\n        system($cmd, $return_var);\n        $output = ob_get_contents();\n        ob_end_clean();\n        if ($output) {\n            return array('res' => $output, 'msg' => 'Executed using system');\n        } elseif ($return_var !== 0) {\n            return array('res' => null, 'msg' => 'Error using system (Code: ' . $return_var . ')');\n        }\n    } elseif (function_exists('passthru')) {\n        ob_start();\n        passthru($cmd, $return_var);\n        $output = ob_get_contents();\n        ob_end_clean();\n        if ($output) {\n            return array('res' => $output, 'msg' => 'Executed using passthru');\n        } elseif ($return_var !== 0) {\n            return array('res' => null, 'msg' => 'Error using passthru (Code: ' . $return_var . ')');\n        }\n    } elseif (function_exists('popen')) {\n        $process = popen($cmd, 'r');\n        $output = stream_get_contents($process);\n        pclose($process);\n        if ($output) {\n            return array('res' => $output, 'msg' => 'Executed using popen');\n        }\n    } elseif (function_exists('proc_open')) {\n        $process = proc_open($cmd, $descriptors, $pipes, $cwd);\n        if (is_resource($process)) {\n            fclose($pipes[0]);\n            $output = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n            $error = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n            $return_value = proc_close($process);\n\n            if ($output) {\n                return array('res' => $output, 'msg' => 'Executed using proc_open');\n            } elseif ($error) {\n                return array('res' => $error, 'msg' => 'Error using proc_open');\n            }\n        }\n    }\n\n    return array('res' => null, 'msg' => null);\n}\n\n?>\n",
      "<?php\n\nfunction execute_command($cmd, $cwd, $com = false) {\n    $res = null;\n    $msg = null;\n\n    if ($com && strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n        try {\n            $wsh = new COM('WScript.Shell');\n            $exec = $wsh->exec($cmd);\n            $stdout = $exec->StdOut;\n            $res = $stdout->ReadAll();\n            $msg = \"Executed using COM\";\n        } catch (Exception $e) {\n            // Fallback to other methods\n        }\n    }\n\n    if ($res === null && function_exists('exec')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        exec($cmd, $output, $return_var);\n        chdir($old_cwd);\n        if ($return_var === 0) {\n            $res = implode(\"\\n\", $output);\n            $msg = \"Executed using exec\";\n        }\n    }\n\n    if ($res === null && function_exists('shell_exec')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        $res = shell_exec($cmd);\n        chdir($old_cwd);\n        if ($res !== null) {\n            $msg = \"Executed using shell_exec\";\n        }\n    }\n\n    if ($res === null && function_exists('system')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        ob_start();\n        system($cmd, $return_var);\n        $res = ob_get_clean();\n        chdir($old_cwd);\n        if ($return_var === 0) {\n            $msg = \"Executed using system\";\n        }\n    }\n\n    if ($res === null && function_exists('passthru')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        ob_start();\n        passthru($cmd, $return_var);\n        $res = ob_get_clean();\n        chdir($old_cwd);\n        if ($return_var === 0) {\n            $msg = \"Executed using passthru\";\n        }\n    }\n\n    if ($res === null && function_exists('popen')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        $handle = popen($cmd, 'r');\n        if ($handle) {\n            $res = stream_get_contents($handle);\n            pclose($handle);\n            $msg = \"Executed using popen\";\n        }\n        chdir($old_cwd);\n    }\n\n    if ($res === null && function_exists('proc_open')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        $descriptorspec = array(\n            0 => array(\"pipe\", \"r\"),\n            1 => array(\"pipe\", \"w\"),\n            2 => array(\"pipe\", \"w\")\n        );\n        $process = proc_open($cmd, $descriptorspec, $pipes);\n        if (is_resource($process)) {\n            $res = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n            fclose($pipes[0]);\n            fclose($pipes[2]);\n            $return_value = proc_close($process);\n            if ($return_value === 0) {\n                $msg = \"Executed using proc_open\";\n            }\n        }\n        chdir($old_cwd);\n    }\n\n    return array('res' => $res, 'msg' => $msg);\n}\n\n?>\n",
      "<?php\n\nfunction execute_command($cmd, $cwd, $com = false) {\n    $res = null;\n    $msg = null;\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' && $com) {\n        $wsh = new COM('WScript.Shell');\n        $exec = $wsh->exec($cmd);\n        $stdout = $exec->StdOut();\n        $res = $stdout->ReadAll();\n        $msg = 'Executed using COM';\n    } elseif (function_exists('exec')) {\n        $res = [];\n        exec($cmd, $res);\n        $res = implode(\"\\n\", $res);\n        $msg = 'Executed using exec';\n    } elseif (function_exists('shell_exec')) {\n        $res = shell_exec($cmd);\n        $msg = 'Executed using shell_exec';\n    } elseif (function_exists('system')) {\n        ob_start();\n        system($cmd);\n        $res = ob_get_contents();\n        ob_end_clean();\n        $msg = 'Executed using system';\n    } elseif (function_exists('passthru')) {\n        ob_start();\n        passthru($cmd);\n        $res = ob_get_contents();\n        ob_end_clean();\n        $msg = 'Executed using passthru';\n    } elseif (function_exists('popen')) {\n        $handle = popen($cmd, 'r');\n        if ($handle) {\n            $res = stream_get_contents($handle);\n            pclose($handle);\n            $msg = 'Executed using popen';\n        }\n    } elseif (function_exists('proc_open')) {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n        $process = proc_open($cmd, $descriptorspec, $pipes, $cwd);\n\n        if (is_resource($process)) {\n            $res = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n\n            $error = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n\n            $return_value = proc_close($process);\n            if ($return_value == 0) {\n                $msg = 'Executed using proc_open';\n            } else {\n                $res = $error;\n                $msg = 'Error using proc_open: ' . $return_value;\n            }\n        }\n\n    }\n\n    return ['res' => $res, 'msg' => $msg];\n}\n?>\n",
      "<?php\n\nfunction execute_command($cmd, $cwd, $com = false) {\n    $res = null;\n    $msg = null;\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' && $com) {\n        $wsh = new COM('WScript.Shell');\n        $exec = $wsh->exec($cmd);\n        $stdout = $exec->StdOut();\n        $res = $stdout->ReadAll();\n        $msg = 'Executed using COM';\n    } elseif (function_exists('exec')) {\n        $res = [];\n        exec($cmd, $res);\n        $res = implode(\"\\n\", $res);\n        $msg = 'Executed using exec';\n    } elseif (function_exists('shell_exec')) {\n        $res = shell_exec($cmd);\n        $msg = 'Executed using shell_exec';\n    } elseif (function_exists('system')) {\n        ob_start();\n        system($cmd);\n        $res = ob_get_contents();\n        ob_end_clean();\n        $msg = 'Executed using system';\n    } elseif (function_exists('passthru')) {\n        ob_start();\n        passthru($cmd);\n        $res = ob_get_contents();\n        ob_end_clean();\n        $msg = 'Executed using passthru';\n    } elseif (function_exists('popen')) {\n        $handle = popen($cmd, 'r');\n        if ($handle) {\n            $res = stream_get_contents($handle);\n            pclose($handle);\n            $msg = 'Executed using popen';\n        }\n    } elseif (function_exists('proc_open')) {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w']\n        ];\n        $process = proc_open($cmd, $descriptorspec, $pipes, $cwd);\n\n        if (is_resource($process)) {\n            $res = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n            fclose($pipes[0]);\n            fclose($pipes[2]);\n\n            $return_value = proc_close($process);\n            $msg = 'Executed using proc_open';\n        }\n    }\n\n    return ['res' => $res, 'msg' => $msg];\n}\n\n?>\n",
      "<?php\n\nfunction execute_command($cmd, $cwd, $com = false) {\n    $res = null;\n    $msg = null;\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' && $com) {\n        try {\n            $wsh = new COM('WScript.Shell');\n            $exec = $wsh->exec($cmd);\n            $stdout = $exec->StdOut();\n            $res = $stdout->ReadAll();\n            $msg = 'Executed using COM';\n        } catch (Exception $e) {\n            // Fallback to other methods\n        }\n    }\n\n    if ($res === null && function_exists('exec')) {\n        $cwd_set = chdir($cwd);\n        exec($cmd, $output, $return_var);\n        if ($cwd_set) chdir(__DIR__);\n        $res = implode(\"\\n\", $output);\n        if ($return_var === 0) {\n            $msg = 'Executed using exec';\n        }\n    }\n\n    if ($res === null && function_exists('shell_exec')) {\n        $cwd_set = chdir($cwd);\n        $res = shell_exec($cmd);\n        if ($cwd_set) chdir(__DIR__);\n        if ($res !== null) {\n            $msg = 'Executed using shell_exec';\n        }\n    }\n\n    if ($res === null && function_exists('system')) {\n        $cwd_set = chdir($cwd);\n        ob_start();\n        system($cmd, $return_var);\n        $res = ob_get_clean();\n        if ($cwd_set) chdir(__DIR__);\n        if ($return_var === 0) {\n            $msg = 'Executed using system';\n        }\n    }\n\n    if ($res === null && function_exists('passthru')) {\n        $cwd_set = chdir($cwd);\n        ob_start();\n        passthru($cmd, $return_var);\n        $res = ob_get_clean();\n        if ($cwd_set) chdir(__DIR__);\n        if ($return_var === 0) {\n            $msg = 'Executed using passthru';\n        }\n    }\n\n    if ($res === null && function_exists('popen')) {\n        $cwd_set = chdir($cwd);\n        $handle = popen($cmd, 'r');\n        if ($handle) {\n            $res = stream_get_contents($handle);\n            pclose($handle);\n            if ($cwd_set) chdir(__DIR__);\n            $msg = 'Executed using popen';\n        }\n    }\n\n    if ($res === null && function_exists('proc_open')) {\n        $cwd_set = chdir($cwd);\n        $descriptorspec = array(\n            0 => array(\"pipe\", \"r\"),\n            1 => array(\"pipe\", \"w\"),\n            2 => array(\"pipe\", \"w\")\n        );\n        $process = proc_open($cmd, $descriptorspec, $pipes);\n\n        if (is_resource($process)) {\n            $res = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n\n            $error = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n\n            $return_value = proc_close($process);\n            if ($cwd_set) chdir(__DIR__);\n            if ($return_value === 0) {\n                $msg = 'Executed using proc_open';\n            }\n        }\n    }\n\n\n    return array('res' => $res, 'msg' => $msg);\n}\n\n?>\n",
      "<?php\n\nfunction execute_command($cmd, $cwd, $com = false) {\n    $descriptors = array(\n        0 => array(\"pipe\", \"r\"),\n        1 => array(\"pipe\", \"w\"),\n        2 => array(\"pipe\", \"w\")\n    );\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' && class_exists('COM') && $com) {\n        $wsh = new COM('WScript.Shell');\n        $exec = $wsh->exec($cmd);\n        $stdout = $exec->StdOut->ReadAll();\n        $stderr = $exec->StdErr->ReadAll();\n        return ['res' => $stdout, 'msg' => 'Executed using COM'];\n    } else if (function_exists('exec')) {\n        $output = [];\n        exec($cmd, $output, $return_var);\n        if ($return_var === 0) {\n            return ['res' => implode(\"\\n\", $output), 'msg' => 'Executed using exec'];\n        }\n    } else if (function_exists('shell_exec')) {\n        $output = shell_exec($cmd);\n        if ($output !== null) {\n            return ['res' => $output, 'msg' => 'Executed using shell_exec'];\n        }\n    } else if (function_exists('system')) {\n        ob_start();\n        system($cmd, $return_var);\n        $output = ob_get_contents();\n        ob_end_clean();\n        if ($return_var === 0) {\n            return ['res' => $output, 'msg' => 'Executed using system'];\n        }\n    } else if (function_exists('passthru')) {\n        ob_start();\n        passthru($cmd, $return_var);\n        $output = ob_get_contents();\n        ob_end_clean();\n        if ($return_var === 0) {\n            return ['res' => $output, 'msg' => 'Executed using passthru'];\n        }\n    } else if (function_exists('popen')) {\n        $process = popen($cmd, 'r');\n        $output = stream_get_contents($process);\n        pclose($process);\n        if ($output !== false) {\n            return ['res' => $output, 'msg' => 'Executed using popen'];\n        }\n    } else if (function_exists('proc_open')) {\n        $process = proc_open($cmd, $descriptors, $pipes, $cwd);\n        if (is_resource($process)) {\n            fclose($pipes[0]);\n            $output = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n            $error = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n            $return_value = proc_close($process);\n\n            if ($return_value === 0) {\n                return ['res' => $output, 'msg' => 'Executed using proc_open'];\n            }\n        }\n    }\n\n    return ['res' => null, 'msg' => null];\n}\n\n?>\n",
      "<?php\n\nfunction execute_command($cmd, $cwd, $com = false) {\n    $res = null;\n    $msg = null;\n\n    if ($com && strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n        try {\n            $wsh = new COM('WScript.Shell');\n            $exec = $wsh->exec($cmd);\n            $stdout = $exec->StdOut;\n            $res = $stdout->ReadAll();\n            $msg = 'Executed using COM';\n        } catch (Exception $e) {\n            // Fallback to other methods\n        }\n    }\n\n    if ($res === null && function_exists('exec')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        exec($cmd, $output);\n        chdir($old_cwd);\n        $res = implode(\"\\n\", $output);\n        $msg = 'Executed using exec';\n    }\n\n    if ($res === null && function_exists('shell_exec')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        $res = shell_exec($cmd);\n        chdir($old_cwd);\n        $msg = 'Executed using shell_exec';\n    }\n\n\n    if ($res === null && function_exists('system')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        ob_start();\n        system($cmd);\n        $res = ob_get_clean();\n        chdir($old_cwd);\n        $msg = 'Executed using system';\n    }\n\n    if ($res === null && function_exists('passthru')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        ob_start();\n        passthru($cmd);\n        $res = ob_get_clean();\n        chdir($old_cwd);\n        $msg = 'Executed using passthru';\n    }\n\n    if ($res === null && function_exists('popen')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        $handle = popen($cmd, 'r');\n        $res = stream_get_contents($handle);\n        pclose($handle);\n        chdir($old_cwd);\n        $msg = 'Executed using popen';\n    }\n\n    if ($res === null && function_exists('proc_open')) {\n        $old_cwd = getcwd();\n        chdir($cwd);\n        $descriptorspec = array(\n            0 => array(\"pipe\", \"r\"),\n            1 => array(\"pipe\", \"w\"),\n            2 => array(\"pipe\", \"w\")\n        );\n        $process = proc_open($cmd, $descriptorspec, $pipes);\n\n        if (is_resource($process)) {\n            $res = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n            fclose($pipes[0]);\n            fclose($pipes[2]);\n\n            $return_value = proc_close($process);\n        }\n        chdir($old_cwd);\n        $msg = 'Executed using proc_open';\n    }\n\n    return array('res' => $res, 'msg' => $msg);\n}\n\n?>\n",
      "<?php\n\nfunction execute_command($cmd, $cwd, $com = false) {\n    $descriptors = array(\n        0 => array(\"pipe\", \"r\"),\n        1 => array(\"pipe\", \"w\"),\n        2 => array(\"pipe\", \"w\")\n    );\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' && class_exists('COM') && $com) {\n        try {\n            $wsh = new COM('WScript.Shell');\n            $exec = $wsh->exec($cmd);\n            $stdout = $exec->StdOut->ReadAll();\n            return ['res' => $stdout, 'msg' => 'Executed using COM'];\n        } catch (Exception $e) {\n            // Fallback to other methods\n        }\n    }\n\n    if (function_exists('exec')) {\n        $output = [];\n        exec($cmd, $output);\n        $res = implode(\"\\n\", $output);\n        if (!empty($res)) return ['res' => $res, 'msg' => 'Executed using exec'];\n    }\n\n    if (function_exists('shell_exec')) {\n        $res = shell_exec($cmd);\n        if (!empty($res)) return ['res' => $res, 'msg' => 'Executed using shell_exec'];\n    }\n\n    if (function_exists('system')) {\n        ob_start();\n        system($cmd, $return_var);\n        $res = ob_get_contents();\n        ob_end_clean();\n        if (!empty($res)) return ['res' => $res, 'msg' => 'Executed using system'];\n    }\n\n    if (function_exists('passthru')) {\n        ob_start();\n        passthru($cmd, $return_var);\n        $res = ob_get_contents();\n        ob_end_clean();\n        if (!empty($res)) return ['res' => $res, 'msg' => 'Executed using passthru'];\n    }\n\n    if (function_exists('popen')) {\n        $process = popen($cmd, 'r');\n        $res = stream_get_contents($process);\n        pclose($process);\n        if (!empty($res)) return ['res' => $res, 'msg' => 'Executed using popen'];\n    }\n\n\n    if (function_exists('proc_open')) {\n        $process = proc_open($cmd, $descriptors, $pipes, $cwd);\n\n        if (is_resource($process)) {\n            fclose($pipes[0]);\n            $res = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n            $stderr = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n            $return_value = proc_close($process);\n\n            if (!empty($res)) return ['res' => $res, 'msg' => 'Executed using proc_open'];\n        }\n    }\n\n    return ['res' => NULL, 'msg' => NULL];\n}\n\n?>\n",
      "<?php\n\nfunction execute_command($cmd, $cwd, $com = false) {\n    $descriptors = array(\n        0 => array(\"pipe\", \"r\"),\n        1 => array(\"pipe\", \"w\"),\n        2 => array(\"pipe\", \"w\")\n    );\n\n    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' && class_exists('COM') && $com) {\n        $wsh = new COM('WScript.Shell');\n        $exec = $wsh->exec($cmd);\n        $stdout = $exec->StdOut->ReadAll();\n        return ['res' => $stdout, 'msg' => 'Executed using COM'];\n    } else if (function_exists('exec')) {\n        $output = [];\n        exec($cmd, $output, $return_var);\n        if ($return_var === 0) {\n            return ['res' => implode(\"\\n\", $output), 'msg' => 'Executed using exec'];\n        }\n    } else if (function_exists('shell_exec')) {\n        $output = shell_exec($cmd);\n        if ($output !== null) {\n            return ['res' => $output, 'msg' => 'Executed using shell_exec'];\n        }\n    } else if (function_exists('system')) {\n        ob_start();\n        system($cmd, $return_var);\n        $output = ob_get_contents();\n        ob_end_clean();\n        if ($return_var === 0) {\n            return ['res' => $output, 'msg' => 'Executed using system'];\n        }\n    } else if (function_exists('passthru')) {\n        ob_start();\n        passthru($cmd, $return_var);\n        $output = ob_get_contents();\n        ob_end_clean();\n        if ($return_var === 0) {\n            return ['res' => $output, 'msg' => 'Executed using passthru'];\n        }\n    } else if (function_exists('popen')) {\n        $process = popen($cmd, 'r');\n        $output = stream_get_contents($process);\n        pclose($process);\n        if ($output !== false) {\n            return ['res' => $output, 'msg' => 'Executed using popen'];\n        }\n    } else if (function_exists('proc_open')) {\n        $process = proc_open($cmd, $descriptors, $pipes, $cwd);\n        if (is_resource($process)) {\n            fclose($pipes[0]);\n            $output = stream_get_contents($pipes[1]);\n            fclose($pipes[1]);\n            $error = stream_get_contents($pipes[2]);\n            fclose($pipes[2]);\n            $return_value = proc_close($process);\n\n            if ($return_value === 0) {\n                return ['res' => $output, 'msg' => 'Executed using proc_open'];\n            }\n        }\n    }\n\n    return ['res' => null, 'msg' => null];\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a PHP helper class for executing system commands and handling inter-process communication using pipes.\n\nClass Description: ProcessHelper is a utility class designed to execute system commands in a cross-platform manner (supporting both Windows and Unix-like systems). It provides a clean interface for running commands, capturing their output and errors, and properly managing process resources.\n\nMethods:\n\nMethod1: run(string $command, string $cwd = null) -> array - Executes a system command and returns the exit code, output, and error messages. The method uses proc_open to create pipes for inter-process communication, properly handles resource cleanup, and returns trimmed output strings.\n\nInput:\n- $command: [string] - The system command to be executed\n- $cwd: [string|null] - The working directory for the command (optional)\n\nOutput:\n- Returns [array] containing three elements:\n  1. [int] Exit code of the process (0 typically indicates success)\n  2. [string] Standard output from the command (trimmed)\n  3. [string] Error output from the command (trimmed)\n\nThrows:\n- RuntimeException if the process cannot be started",
    "Canonical_solution": "namespace SMProxy\\Helper;\n\nclass ProcessHelper\n{\n    /**\n     * run a command. it is support windows\n     * @param string $command\n     * @param string|null $cwd\n     * @return array\n     * @throws \\RuntimeException\n     */\n    public static function run(string $command, string $cwd = null): array\n    {\n        $descriptors = [\n            0 => ['pipe', 'r'], // stdin - read channel\n            1 => ['pipe', 'w'], // stdout - write channel\n            2 => ['pipe', 'w'], // stdout - error channel\n            3 => ['pipe', 'r'], // stdin - This is the pipe we can feed the password into\n        ];\n\n        $process = proc_open($command, $descriptors, $pipes, $cwd);\n\n        if (!\\is_resource($process)) {\n            throw new \\RuntimeException('Can\\'t open resource with proc_open.');\n        }\n\n        // Nothing to push to input.\n        fclose($pipes[0]);\n\n        $output = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        fclose($pipes[3]);\n\n        // Close all pipes before proc_close! $code === 0 is success.\n        $code = proc_close($process);\n\n        return [trim($code), trim($output), trim($error)];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "<?php\n\nclass ProcessHelper\n{\n    public function run(string $command, string $cwd = null): array\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'], // stdin\n            1 => ['pipe', 'w'], // stdout\n            2 => ['pipe', 'w'], // stderr\n        ];\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd);\n\n        if (!is_resource($process)) {\n            throw new RuntimeException('Could not start process.');\n        }\n\n        fclose($pipes[0]);\n\n        $output = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        return [\n            'exit_code' => $exitCode,\n            'output' => trim($output),\n            'error' => trim($error),\n        ];\n    }\n}\n",
      "<?php\n\nclass ProcessHelper\n{\n    public function run(string $command, string $cwd = null): array\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd);\n\n        if (!is_resource($process)) {\n            throw new RuntimeException('Could not start process.');\n        }\n\n        fclose($pipes[0]);\n\n        $output = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        return [\n            'exit_code' => $exitCode,\n            'output' => trim($output),\n            'error' => trim($error),\n        ];\n    }\n}\n",
      "<?php\n\nclass ProcessHelper\n{\n    public function run(string $command, string $cwd = null): array\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd);\n\n        if (!is_resource($process)) {\n            throw new RuntimeException('Could not start process.');\n        }\n\n        fclose($pipes[0]);\n\n        $output = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        return [\n            'exit_code' => $exitCode,\n            'output' => trim($output),\n            'error' => trim($error),\n        ];\n    }\n}\n",
      "<?php\n\nclass ProcessHelper\n{\n    public function run(string $command, string $cwd = null): array\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd);\n\n        if (!is_resource($process)) {\n            throw new RuntimeException('Could not start process.');\n        }\n\n        fclose($pipes[0]);\n\n        $output = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        return [\n            'exit_code' => $exitCode,\n            'output' => trim($output),\n            'error' => trim($error),\n        ];\n    }\n}\n",
      "<?php\n\nclass ProcessHelper\n{\n    public function run(string $command, string $cwd = null): array\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd);\n\n        if (!is_resource($process)) {\n            throw new RuntimeException(\"Could not start process.\");\n        }\n\n        fclose($pipes[0]);\n\n        $output = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        return [\n            'exit_code' => $exitCode,\n            'output' => trim($output),\n            'error' => trim($error),\n        ];\n    }\n}\n",
      "<?php\n\nclass ProcessHelper\n{\n    public function run(string $command, string $cwd = null): array\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'], // stdin\n            1 => ['pipe', 'w'], // stdout\n            2 => ['pipe', 'w'], // stderr\n        ];\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd);\n\n        if (!is_resource($process)) {\n            throw new RuntimeException('Could not start process.');\n        }\n\n        fclose($pipes[0]);\n\n        $output = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        return [\n            'exit_code' => $exitCode,\n            'output' => trim($output),\n            'error' => trim($error),\n        ];\n    }\n}\n\n?>\n",
      "<?php\n\nclass ProcessHelper\n{\n    public function run(string $command, string $cwd = null): array\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'], // stdin\n            1 => ['pipe', 'w'], // stdout\n            2 => ['pipe', 'w'], // stderr\n        ];\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd);\n\n        if (!is_resource($process)) {\n            throw new RuntimeException('Could not start process.');\n        }\n\n        fclose($pipes[0]);\n\n        $output = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        return [\n            $exitCode,\n            trim($output),\n            trim($error),\n        ];\n    }\n}\n",
      "<?php\n\nclass ProcessHelper\n{\n    public function run(string $command, string $cwd = null): array\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd);\n\n        if (!is_resource($process)) {\n            throw new RuntimeException('Could not start process.');\n        }\n\n        fclose($pipes[0]);\n\n        $output = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        return [\n            'exit_code' => $exitCode,\n            'output' => trim($output),\n            'error' => trim($error),\n        ];\n    }\n}\n",
      "<?php\n\nclass ProcessHelper\n{\n    public function run(string $command, string $cwd = null): array\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd);\n\n        if (!is_resource($process)) {\n            throw new RuntimeException('Could not start process.');\n        }\n\n        fclose($pipes[0]);\n\n        $output = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        return [\n            $exitCode,\n            trim($output),\n            trim($error),\n        ];\n    }\n}\n",
      "<?php\n\nclass ProcessHelper\n{\n    public function run(string $command, string $cwd = null): array\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd);\n\n        if (!is_resource($process)) {\n            throw new RuntimeException('Could not start process.');\n        }\n\n        fclose($pipes[0]);\n\n        $output = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $error = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        return [\n            'exit_code' => $exitCode,\n            'output' => trim($output),\n            'error' => trim($error),\n        ];\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Create a PHP function that performs HTTP requests using cURL with support for various HTTP methods, custom headers, and JSON response handling.\n\nFunction Description: The function should initialize a cURL session, configure it based on input parameters, execute the request, handle errors, process the response, and return a structured result including status, headers, and response body. It should support GET, POST, PUT, DELETE, PATCH, and OPTIONS methods, with options for custom headers, additional cURL options, JSON response parsing, and timeout configuration.\n\nInput:\n- $url (string): The target URL for the HTTP request\n- $method (string, optional, default='GET'): HTTP method (GET|POST|PUT|DELETE|PATCH|OPTIONS)\n- $data (mixed, optional, default=false): Request payload data\n- $headers (mixed, optional, default=false): Request headers (string or array)\n- $options (mixed, optional, default=false): Additional cURL options as array\n- $json (bool, optional, default=false): Whether to parse response as JSON\n- $timeout (int, optional, default=3600): Request timeout in seconds\n\nOutput:\nReturns an associative array containing:\n- 'data': Response body (parsed as array if $json=true and valid JSON)\n- 'status': Boolean indicating success (HTTP status 200-299)\n- 'code': HTTP status code\n- 'header': Parsed response headers as associative array\n\nIn case of cURL errors:\n- 'data': Error message\n- 'code': 0\n- 'header': cURL info array",
    "Canonical_solution": "function url_request($url, $method = 'GET', $data = false, $headers = false, $options = false, $json = false, $timeout = 3600) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_HEADER, 1);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\n    curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);\n    curl_setopt($ch, CURLINFO_HEADER_OUT, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n    curl_setopt($ch, CURLOPT_REFERER, get_url_link($url));\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36');\n\n    if ($headers) {\n        if (is_string($headers)) {\n            $headers = array($headers);\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    }\n\n    switch ($method) {\n        case 'GET':\n            curl_setopt($ch, CURLOPT_HTTPGET, 1);\n            break;\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PUT':\n        case 'DELETE':\n        case 'PATCH':\n        case 'OPTIONS':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n    }\n\n    if (!empty($options)) {\n        curl_setopt_array($ch, $options);\n    }\n\n    $response = curl_exec($ch);\n    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    $response_info = curl_getinfo($ch);\n    $http_body = substr($response, $header_size);\n    $http_header = substr($response, 0, $header_size);\n    $http_header = parse_headers($http_header);\n\n    if ($response_info['http_code'] == 0) {\n        $error_message = curl_error($ch);\n        if (!empty($error_message)) {\n            $error_message = \"API call to $url failed; $error_message\";\n        } else {\n            $error_message = \"API call to $url failed; maybe network error!\";\n        }\n        return array(\n            'data' => $error_message,\n            'code' => 0,\n            'header' => $response_info,\n        );\n    }\n\n    curl_close($ch);\n\n    if ($json && ($response_info['http_code'] >= 200 && $response_info['http_code'] <= 299)) {\n        $data = @json_decode($http_body, true);\n        if (json_last_error() == 0) {\n            $http_body = $data;\n        }\n    }\n\n    return array(\n        'data' => $http_body,\n        'status' => ($response_info['http_code'] >= 200 && $response_info['http_code'] <= 299),\n        'code' => $response_info['http_code'],\n        'header' => $http_header,\n    );\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction http_request($url, $method = 'GET', $data = false, $headers = false, $options = false, $json = false, $timeout = 3600) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HEADER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PUT':\n        case 'DELETE':\n        case 'PATCH':\n        case 'OPTIONS':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, strtoupper($method));\n            if ($data) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            }\n            break;\n    }\n\n    if ($headers) {\n        if (is_string($headers)) {\n            $headers = explode(\"\\r\\n\", $headers);\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    }\n\n    if ($options && is_array($options)) {\n        curl_setopt_array($ch, $options);\n    }\n\n    $response = curl_exec($ch);\n    $info = curl_getinfo($ch);\n\n    if ($response === false) {\n        return [\n            'data' => curl_error($ch),\n            'code' => 0,\n            'header' => $info\n        ];\n    }\n\n    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    $header = substr($response, 0, $header_size);\n    $body = substr($response, $header_size);\n    $header_array = [];\n    foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n        if ($i === 0) {\n            continue;\n        }\n        if (strpos($line, ':') !== false) {\n            list($key, $value) = explode(':', $line, 2);\n            $header_array[trim($key)] = trim($value);\n        }\n    }\n\n    $status = ($info['http_code'] >= 200 && $info['http_code'] < 300);\n\n    if ($json && $body) {\n        $decoded_body = json_decode($body, true);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            $body = $decoded_body;\n        }\n    }\n\n    curl_close($ch);\n\n    return [\n        'data' => $body,\n        'status' => $status,\n        'code' => $info['http_code'],\n        'header' => $header_array\n    ];\n}\n?>\n",
      "<?php\nfunction http_request($url, $method = 'GET', $data = false, $headers = false, $options = false, $json = false, $timeout = 3600) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HEADER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PUT':\n        case 'DELETE':\n        case 'PATCH':\n        case 'OPTIONS':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, strtoupper($method));\n            if ($data) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            }\n            break;\n    }\n\n    if ($headers) {\n        if (is_string($headers)) {\n            $headers = explode(\"\\r\\n\", $headers);\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    }\n\n    if ($options && is_array($options)) {\n        curl_setopt_array($ch, $options);\n    }\n\n    $response = curl_exec($ch);\n    $info = curl_getinfo($ch);\n\n    if ($response === false) {\n        return [\n            'data' => curl_error($ch),\n            'code' => 0,\n            'header' => $info\n        ];\n    }\n\n    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    $header = substr($response, 0, $header_size);\n    $body = substr($response, $header_size);\n    $header_array = [];\n    foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n        if ($i === 0) {\n            continue;\n        }\n        if (strpos($line, ':') !== false) {\n            list($key, $value) = explode(':', $line, 2);\n            $header_array[trim($key)] = trim($value);\n        }\n    }\n\n    $status = ($info['http_code'] >= 200 && $info['http_code'] < 300);\n    $data = $body;\n    if ($json && $status) {\n        $decoded = json_decode($body, true);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            $data = $decoded;\n        }\n    }\n\n    curl_close($ch);\n\n    return [\n        'data' => $data,\n        'status' => $status,\n        'code' => $info['http_code'],\n        'header' => $header_array\n    ];\n}\n?>\n",
      "<?php\nfunction http_request($url, $method = 'GET', $data = false, $headers = false, $options = false, $json = false, $timeout = 3600) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HEADER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PUT':\n        case 'DELETE':\n        case 'PATCH':\n        case 'OPTIONS':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, strtoupper($method));\n            if ($data) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            }\n            break;\n    }\n\n    if ($headers) {\n        if (is_string($headers)) {\n            $headers = explode(\"\\r\\n\", $headers);\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    }\n\n    if ($options && is_array($options)) {\n        curl_setopt_array($ch, $options);\n    }\n\n    $response = curl_exec($ch);\n    $info = curl_getinfo($ch);\n\n    if ($response === false) {\n        return [\n            'data' => curl_error($ch),\n            'code' => 0,\n            'header' => $info\n        ];\n    }\n\n    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    $header = substr($response, 0, $header_size);\n    $body = substr($response, $header_size);\n    $header_array = [];\n    foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n        if ($i === 0) {\n            continue;\n        }\n        if (strpos($line, ':') !== false) {\n            list($key, $value) = explode(':', $line, 2);\n            $header_array[trim($key)] = trim($value);\n        }\n    }\n\n    $data = $body;\n    if ($json && $body) {\n        $decoded = json_decode($body, true);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            $data = $decoded;\n        }\n    }\n\n    curl_close($ch);\n\n    return [\n        'data' => $data,\n        'status' => $info['http_code'] >= 200 && $info['http_code'] < 300,\n        'code' => $info['http_code'],\n        'header' => $header_array\n    ];\n}\n?>\n",
      "<?php\nfunction http_request($url, $method = 'GET', $data = false, $headers = false, $options = false, $json = false, $timeout = 3600) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HEADER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PUT':\n        case 'DELETE':\n        case 'PATCH':\n        case 'OPTIONS':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, strtoupper($method));\n            if ($data) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            }\n            break;\n    }\n\n    if ($headers) {\n        if (is_string($headers)) {\n            $headers = explode(\"\\r\\n\", $headers);\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    }\n\n    if ($options && is_array($options)) {\n        curl_setopt_array($ch, $options);\n    }\n\n    $response = curl_exec($ch);\n    $info = curl_getinfo($ch);\n\n    if ($response === false) {\n        return [\n            'data' => curl_error($ch),\n            'code' => 0,\n            'header' => $info\n        ];\n    }\n\n    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    $header = substr($response, 0, $header_size);\n    $body = substr($response, $header_size);\n    $header_array = [];\n    foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n        if ($i === 0) {\n            continue;\n        }\n        if (strpos($line, ':') !== false) {\n            list($key, $value) = explode(':', $line, 2);\n            $header_array[trim($key)] = trim($value);\n        }\n    }\n\n\n    if ($json && $body) {\n        $body = json_decode($body, true);\n    }\n\n    curl_close($ch);\n\n    return [\n        'data' => $body,\n        'status' => $info['http_code'] >= 200 && $info['http_code'] < 300,\n        'code' => $info['http_code'],\n        'header' => $header_array\n    ];\n}\n?>\n",
      "<?php\nfunction http_request($url, $method = 'GET', $data = false, $headers = false, $options = false, $json = false, $timeout = 3600) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HEADER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PUT':\n        case 'DELETE':\n        case 'PATCH':\n        case 'OPTIONS':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, strtoupper($method));\n            if ($data) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            }\n            break;\n    }\n\n    if ($headers) {\n        if (is_string($headers)) {\n            $headers = explode(\"\\r\\n\", $headers);\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    }\n\n    if ($options && is_array($options)) {\n        curl_setopt_array($ch, $options);\n    }\n\n    $response = curl_exec($ch);\n    $info = curl_getinfo($ch);\n\n    if ($response === false) {\n        return [\n            'data' => curl_error($ch),\n            'code' => 0,\n            'header' => $info\n        ];\n    }\n\n    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    $header = substr($response, 0, $header_size);\n    $body = substr($response, $header_size);\n    $header_array = [];\n    foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n        if ($i === 0) {\n            continue;\n        }\n        if (strpos($line, ':') !== false) {\n            list($key, $value) = explode(':', $line, 2);\n            $header_array[trim($key)] = trim($value);\n        }\n    }\n\n\n    $status = ($info['http_code'] >= 200 && $info['http_code'] < 300);\n\n    if ($json && $status && $body) {\n        $decoded = json_decode($body, true);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            $body = $decoded;\n        }\n    }\n\n    curl_close($ch);\n\n    return [\n        'data' => $body,\n        'status' => $status,\n        'code' => $info['http_code'],\n        'header' => $header_array\n    ];\n}\n?>\n",
      "<?php\nfunction http_request($url, $method = 'GET', $data = false, $headers = false, $options = false, $json = false, $timeout = 3600) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HEADER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PUT':\n        case 'DELETE':\n        case 'PATCH':\n        case 'OPTIONS':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, strtoupper($method));\n            if ($data) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            }\n            break;\n    }\n\n    if ($headers) {\n        if (is_string($headers)) {\n            $headers = explode(\"\\r\\n\", $headers);\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    }\n\n    if ($options && is_array($options)) {\n        curl_setopt_array($ch, $options);\n    }\n\n\n    $response = curl_exec($ch);\n    $info = curl_getinfo($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        curl_close($ch);\n        return ['data' => $error, 'code' => 0, 'header' => $info];\n    }\n\n    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    $header = substr($response, 0, $header_size);\n    $body = substr($response, $header_size);\n    $header_array = [];\n    foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n        if ($i === 0) {\n            continue;\n        }\n        if (strpos($line, ':') !== false) {\n            list($key, $value) = explode(':', $line, 2);\n            $header_array[trim($key)] = trim($value);\n        }\n    }\n\n    $status = ($info['http_code'] >= 200 && $info['http_code'] < 300);\n    $data = $body;\n    if ($json && $status) {\n        $decoded = json_decode($body, true);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            $data = $decoded;\n        }\n    }\n\n    curl_close($ch);\n    return ['data' => $data, 'status' => $status, 'code' => $info['http_code'], 'header' => $header_array];\n}\n?>\n",
      "<?php\nfunction http_request($url, $method = 'GET', $data = false, $headers = false, $options = false, $json = false, $timeout = 3600) {\n    $ch = curl_init();\n    $method = strtoupper($method);\n\n    switch ($method) {\n        case 'GET':\n            if ($data) {\n                $url .= (strpos($url, '?') === false ? '?' : '&') . http_build_query($data);\n            }\n            break;\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PUT':\n        case 'DELETE':\n        case 'PATCH':\n        case 'OPTIONS':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        default:\n            return [\n                'data' => 'Invalid HTTP method',\n                'code' => 0,\n                'header' => [],\n                'status' => false\n            ];\n    }\n\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HEADER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n\n    if ($headers) {\n        if (is_array($headers)) {\n            $headers = array_map(function($key, $value) {\n                return $key . ': ' . $value;\n            }, array_keys($headers), array_values($headers));\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    }\n\n    if ($options && is_array($options)) {\n        curl_setopt_array($ch, $options);\n    }\n\n    $response = curl_exec($ch);\n    $info = curl_getinfo($ch);\n\n    if ($response === false) {\n        return [\n            'data' => curl_error($ch),\n            'code' => 0,\n            'header' => $info,\n            'status' => false\n        ];\n    }\n\n    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    $header = substr($response, 0, $header_size);\n    $body = substr($response, $header_size);\n    $header_array = [];\n    foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n        if ($i === 0) {\n            continue;\n        }\n        if (strpos($line, ':') !== false) {\n            list($key, $value) = explode(':', $line, 2);\n            $header_array[trim($key)] = trim($value);\n        }\n    }\n\n    if ($json && $body) {\n        $data = json_decode($body, true);\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            $data = $body;\n        }\n    } else {\n        $data = $body;\n    }\n\n    $status = ($info['http_code'] >= 200 && $info['http_code'] < 300);\n\n    curl_close($ch);\n\n    return [\n        'data' => $data,\n        'status' => $status,\n        'code' => $info['http_code'],\n        'header' => $header_array\n    ];\n}\n?>\n",
      "<?php\nfunction http_request($url, $method = 'GET', $data = false, $headers = false, $options = false, $json = false, $timeout = 3600) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HEADER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PUT':\n        case 'DELETE':\n        case 'PATCH':\n        case 'OPTIONS':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, strtoupper($method));\n            if ($data) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            }\n            break;\n    }\n\n    if ($headers) {\n        if (is_string($headers)) {\n            $headers = explode(\"\\r\\n\", $headers);\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    }\n\n    if ($options && is_array($options)) {\n        curl_setopt_array($ch, $options);\n    }\n\n    $response = curl_exec($ch);\n    $info = curl_getinfo($ch);\n\n    if ($response === false) {\n        return [\n            'data' => curl_error($ch),\n            'code' => 0,\n            'header' => $info\n        ];\n    }\n\n    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    $header = substr($response, 0, $header_size);\n    $body = substr($response, $header_size);\n    $header_array = [];\n    foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n        if ($i === 0) {\n            continue;\n        }\n        if (strpos($line, ':') !== false) {\n            list($key, $value) = explode(':', $line, 2);\n            $header_array[trim($key)] = trim($value);\n        }\n    }\n\n    $status = ($info['http_code'] >= 200 && $info['http_code'] < 300);\n\n    if ($json && $body) {\n        $decoded_body = json_decode($body, true);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            $body = $decoded_body;\n        }\n    }\n\n    curl_close($ch);\n\n    return [\n        'data' => $body,\n        'status' => $status,\n        'code' => $info['http_code'],\n        'header' => $header_array\n    ];\n}\n?>\n"
    ],
    "unmatched_results": [
      "<?php\nfunction http_request($url, $method = 'GET', $data = false, $headers = false, $options = false, $json = false, $timeout = 3600) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HEADER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PUT':\n        case 'DELETE':\n        case 'PATCH':\n        case 'OPTIONS':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, strtoupper($method));\n            if ($data) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            }\n            break;\n    }\n\n    if ($headers) {\n        if (is_string($headers)) {\n            $headers = explode(\"\\r\\n\", $headers);\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    }\n\n    if ($options && is_array($options)) {\n        curl_setopt_array($ch, $options);\n    }\n\n    $response = curl_exec($ch);\n    $info = curl_getinfo($ch);\n\n    if ($response === false) {\n        return [\n            'data' => curl_error($ch),\n            'code' => 0,\n            'header' => $info\n        ];\n    }\n\n    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    $header = substr($response, 0, $header_size);\n    $body = substr($response, $header_size);\n    $header_array = [];\n    foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n        if ($i === 0) {\n            continue;\n        }\n        if (strpos($line, ':') !== false) {\n            list($key, $value) = explode(':', $line, 2);\n            $header_array[trim($key)] = trim($value);\n        }\n    }\n\n    $data = $body;\n    if ($json && $body) {\n        $json_data = json_decode($body, true);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            $data = $json_data;\n        }\n    }\n\n    return [\n        'data' => $data,\n        'status' => $info['http_code'] >= 200 && $info['http_code'] < 300,\n        'code' => $info['http_code'],\n        'header' => $header_array\n    ];\n}\n?>\n",
      "<?php\nfunction http_request($url, $method = 'GET', $data = false, $headers = false, $options = false, $json = false, $timeout = 3600) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HEADER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PUT':\n        case 'DELETE':\n        case 'PATCH':\n        case 'OPTIONS':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, strtoupper($method));\n            if ($data) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            }\n            break;\n    }\n\n    if ($headers) {\n        if (is_string($headers)) {\n            $headers = explode(\"\\r\\n\", $headers);\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    }\n\n    if ($options && is_array($options)) {\n        curl_setopt_array($ch, $options);\n    }\n\n    $response = curl_exec($ch);\n    $info = curl_getinfo($ch);\n\n    if ($response === false) {\n        return [\n            'data' => curl_error($ch),\n            'code' => 0,\n            'header' => $info\n        ];\n    }\n\n    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    $header = substr($response, 0, $header_size);\n    $body = substr($response, $header_size);\n    $header_array = [];\n    foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n        if ($i === 0) {\n            continue;\n        }\n        if (strpos($line, ':') !== false) {\n            list($key, $value) = explode(':', $line, 2);\n            $header_array[trim($key)] = trim($value);\n        }\n    }\n\n\n    if ($json && $body) {\n        $data = json_decode($body, true);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            $body = $data;\n        }\n    }\n\n    return [\n        'data' => $body,\n        'status' => $info['http_code'] >= 200 && $info['http_code'] < 300,\n        'code' => $info['http_code'],\n        'header' => $header_array\n    ];\n}\n?>\n"
    ],
    "match_count": 8,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a PHP class that manages the execution of a subprocess using proc_open, handles input/output through pipes, and provides timeout functionality for process execution.\n\nClass Description: DefaultPhpProcess is a class that extends AbstractPhpProcess and provides concrete implementation for running PHP jobs in a subprocess. It handles process creation, I/O management through pipes, timeout enforcement, and resource cleanup.\n\nAttributes:\ntempFile: string - Temporary file path used for storing job input when stdin is not used\nstdin: mixed - Input source for the subprocess\nenv: array - Environment variables for the subprocess\ntimeout: int - Maximum execution time in seconds before process termination\n\nMethods:\nrunJob(string $job, array $settings = []) -> array - Executes a PHP job with optional settings, returns output and error\ngetHandles() -> array - Returns empty array by default, can be overridden to provide custom handles\nrunProcess(string $job, array $settings) -> array - Core method that manages process execution and I/O handling\nprocess(resource $pipe, string $job) -> void - Writes job input to the process pipe\ncleanup() -> void - Cleans up temporary resources (files)\nuseTemporaryFile() -> bool - Determines whether to use temporary files for input (default false)",
    "Canonical_solution": "use function array_merge;\nuse function fclose;\nuse function file_put_contents;\nuse function fread;\nuse function fwrite;\nuse function is_array;\nuse function is_resource;\nuse function proc_close;\nuse function proc_open;\nuse function proc_terminate;\nuse function rewind;\nuse function sprintf;\nuse function stream_get_contents;\nuse function stream_select;\nuse function sys_get_temp_dir;\nuse function tempnam;\nuse function unlink;\nuse PHPUnit\\Framework\\Exception;\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    protected $tempFile;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        if ($this->stdin || $this->useTemporaryFile()) {\n            if (!($this->tempFile = tempnam(sys_get_temp_dir(), 'PHPUnit')) ||\n                file_put_contents($this->tempFile, $job) === false) {\n                throw new Exception(\n                    'Unable to write temporary file'\n                );\n            }\n\n            $job = $this->stdin;\n        }\n\n        return $this->runProcess($job, $settings);\n    }\n\n    protected function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $handles = $this->getHandles();\n\n        $env = null;\n\n        if ($this->env) {\n            $env = $_SERVER ?? [];\n            unset($env['argv'], $env['argc']);\n            $env = array_merge($env, $this->env);\n\n            foreach ($env as $envKey => $envVar) {\n                if (is_array($envVar)) {\n                    unset($env[$envKey]);\n                }\n            }\n        }\n\n        $pipeSpec = [\n            0 => $handles[0] ?? ['pipe', 'r'],\n            1 => $handles[1] ?? ['pipe', 'w'],\n            2 => $handles[2] ?? ['pipe', 'w'],\n        ];\n\n        $process = proc_open(\n            $this->getCommand($settings, $this->tempFile),\n            $pipeSpec,\n            $pipes,\n            null,\n            $env\n        );\n\n        if (!is_resource($process)) {\n            throw new Exception(\n                'Unable to spawn worker process'\n            );\n        }\n\n        if ($job) {\n            $this->process($pipes[0], $job);\n        }\n\n        fclose($pipes[0]);\n\n        $stderr = $stdout = '';\n\n        if ($this->timeout) {\n            unset($pipes[0]);\n\n            while (true) {\n                $r = $pipes;\n                $w = null;\n                $e = null;\n\n                $n = @stream_select($r, $w, $e, $this->timeout);\n\n                if ($n === false) {\n                    break;\n                }\n\n                if ($n === 0) {\n                    proc_terminate($process, 9);\n\n                    throw new Exception(\n                        sprintf(\n                            'Job execution aborted after %d seconds',\n                            $this->timeout\n                        )\n                    );\n                }\n\n                if ($n > 0) {\n                    foreach ($r as $pipe) {\n                        $pipeOffset = 0;\n\n                        foreach ($pipes as $i => $origPipe) {\n                            if ($pipe === $origPipe) {\n                                $pipeOffset = $i;\n\n                                break;\n                            }\n                        }\n\n                        if (!$pipeOffset) {\n                            break;\n                        }\n\n                        $line = fread($pipe, 8192);\n\n                        if ($line === '' || $line === false) {\n                            fclose($pipes[$pipeOffset]);\n\n                            unset($pipes[$pipeOffset]);\n                        } elseif ($pipeOffset === 1) {\n                            $stdout .= $line;\n                        } else {\n                            $stderr .= $line;\n                        }\n                    }\n\n                    if (empty($pipes)) {\n                        break;\n                    }\n                }\n            }\n        } else {\n            if (isset($pipes[1])) {\n                $stdout = stream_get_contents($pipes[1]);\n\n                fclose($pipes[1]);\n            }\n\n            if (isset($pipes[2])) {\n                $stderr = stream_get_contents($pipes[2]);\n\n                fclose($pipes[2]);\n            }\n        }\n\n        if (isset($handles[1])) {\n            rewind($handles[1]);\n\n            $stdout = stream_get_contents($handles[1]);\n\n            fclose($handles[1]);\n        }\n\n        if (isset($handles[2])) {\n            rewind($handles[2]);\n\n            $stderr = stream_get_contents($handles[2]);\n\n            fclose($handles[2]);\n        }\n\n        proc_close($process);\n\n        $this->cleanup();\n\n        return ['stdout' => $stdout, 'stderr' => $stderr];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    protected function cleanup(): void\n    {\n        if ($this->tempFile) {\n            unlink($this->tempFile);\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "matched_results": [
      "<?php\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    private ?string $tempFile = null;\n    private mixed $stdin;\n    private array $env = [];\n    private int $timeout = 60;\n\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $settings['stdin'] ?? null;\n        $this->env = $settings['env'] ?? [];\n        $this->timeout = $settings['timeout'] ?? 60;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = $this->getDescriptorSpec();\n        $pipes = [];\n\n        $process = proc_open($this->getCommandLine(), $descriptorspec, $pipes, null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Could not create process.');\n        }\n\n        if ($this->useTemporaryFile()) {\n            $this->tempFile = $this->createTemporaryFile($job);\n            $this->process($pipes[0], $this->tempFile);\n        } else {\n            $this->process($pipes[0], $job);\n        }\n        fclose($pipes[0]);\n\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['output' => $stdout, 'error' => $stderr, 'exit_code' => $exitCode];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n\n    protected function cleanup(): void\n    {\n        if ($this->tempFile) {\n            unlink($this->tempFile);\n            $this->tempFile = null;\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n}\n?>\n",
      "<?php\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    protected string $tempFile;\n    protected mixed $stdin;\n    protected array $env;\n    protected int $timeout;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $this->stdin = $settings['stdin'] ?? null;\n        $this->env = $settings['env'] ?? [];\n        $this->timeout = $settings['timeout'] ?? 60;\n\n        $descriptors = $this->getDescriptors();\n        $pipes = [];\n\n        $process = proc_open($this->getCommandLine(), $descriptors, $pipes, null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Could not create process.');\n        }\n\n        if ($this->useTemporaryFile()) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $job);\n            $job = '';\n        }\n\n        $this->process($pipes[0], $job);\n        fclose($pipes[0]);\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['output' => $stdout, 'error' => $stderr, 'exit_code' => $exitCode];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    protected function cleanup(): void\n    {\n        if (isset($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n\n    protected function getDescriptors(): array\n    {\n        return [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n    }\n\n\n    protected function getCommandLine(): string\n    {\n        $phpExecutable = PHP_BINARY;\n        if ($this->useTemporaryFile()) {\n            return $phpExecutable . ' ' . $this->tempFile;\n        }\n        return $phpExecutable;\n    }\n}\n\nabstract class AbstractPhpProcess\n{\n\n}\n",
      "<?php\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    private ?string $tempFile = null;\n    private mixed $stdin;\n    private array $env = [];\n    private int $timeout = 60;\n\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $settings['stdin'] ?? null;\n        $this->env = $settings['env'] ?? [];\n        $this->timeout = $settings['timeout'] ?? 60;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    public function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = $this->getDescriptorSpec();\n        $pipes = [];\n\n        $process = proc_open($this->getCommand(), $descriptorspec, $pipes, null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Could not create process.');\n        }\n\n        if ($this->useTemporaryFile()) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $job);\n            $job = $this->tempFile;\n        }\n\n        $this->process($pipes[0], $job);\n        fclose($pipes[0]);\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['output' => $stdout, 'error' => $stderr, 'exit_code' => $exitCode];\n    }\n\n\n    protected function process($pipe, string $job): void\n    {\n        if (is_resource($this->stdin)) {\n            stream_copy_to_stream($this->stdin, $pipe);\n        } elseif (is_string($job)) {\n            fwrite($pipe, $job);\n        }\n    }\n\n    protected function cleanup(): void\n    {\n        if ($this->tempFile) {\n            unlink($this->tempFile);\n            $this->tempFile = null;\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n\n    private function getDescriptorSpec(): array\n    {\n        if ($this->useTemporaryFile()) {\n            return [\n                0 => ['pipe', 'r'],\n                1 => ['pipe', 'w'],\n                2 => ['pipe', 'w'],\n            ];\n        }\n\n        if (is_resource($this->stdin)) {\n            return [\n                0 => $this->stdin,\n                1 => ['pipe', 'w'],\n                2 => ['pipe', 'w'],\n            ];\n        }\n\n\n        return [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n    }\n\n    private function getCommand(): string\n    {\n        return PHP_BINARY;\n    }\n}\n\nabstract class AbstractPhpProcess\n{\n\n}\n",
      "<?php\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    private ?string $tempFile = null;\n    private mixed $stdin;\n    private array $env = [];\n    private int $timeout = 60;\n\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $settings['stdin'] ?? null;\n        $this->env = $settings['env'] ?? [];\n        $this->timeout = $settings['timeout'] ?? 60;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = $this->getDescriptorSpec();\n        $pipes = [];\n        $process = proc_open($this->getCommandLine(), $descriptorspec, $pipes, null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Could not create process.');\n        }\n\n        if ($this->useTemporaryFile()) {\n            $this->tempFile = $this->createTemporaryFile($job);\n        } else {\n            $this->process($pipes[0], $job);\n        }\n        fclose($pipes[0]);\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['stdout' => $stdout, 'stderr' => $stderr, 'exit_code' => $exitCode];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    protected function cleanup(): void\n    {\n        if ($this->tempFile) {\n            unlink($this->tempFile);\n        }\n    }\n\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n}\n",
      "<?php\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    private ?string $tempFile = null;\n    private mixed $stdin;\n    private array $env = [];\n    private int $timeout = 60;\n\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $settings['stdin'] ?? null;\n        $this->env = $settings['env'] ?? [];\n        $this->timeout = $settings['timeout'] ?? 60;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    public function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = $this->getDescriptorSpec();\n        $pipes = [];\n\n        $process = proc_open($this->getCommandLine(), $descriptorspec, $pipes, null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Could not create process.');\n        }\n\n        if ($this->useTemporaryFile()) {\n            $this->tempFile = $this->createTemporaryFile($job);\n            $this->process($pipes[0], $this->tempFile);\n        } else {\n            $this->process($pipes[0], $job);\n        }\n        fclose($pipes[0]);\n\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['output' => $stdout, 'error' => $stderr, 'exit_code' => $exitCode];\n    }\n\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    protected function cleanup(): void\n    {\n        if ($this->tempFile) {\n            unlink($this->tempFile);\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n\n\n    private function createTemporaryFile(string $content): string\n    {\n        $tempFile = tempnam(sys_get_temp_dir(), 'php_process');\n        if (!file_put_contents($tempFile, $content)) {\n            throw new \\RuntimeException(\"Could not write to temporary file: {$tempFile}\");\n        }\n        return $tempFile;\n    }\n\n    private function getCommandLine(): string\n    {\n        return PHP_BINARY;\n    }\n\n    private function getDescriptorSpec(): array\n    {\n        if ($this->useTemporaryFile()) {\n            return [\n                0 => ['pipe', 'r'],\n                1 => ['pipe', 'w'],\n                2 => ['pipe', 'w'],\n            ];\n        }\n\n        $spec = [\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        if ($this->stdin !== null) {\n            $spec[0] = ['pipe', 'r'];\n        } else {\n            $spec[0] = ['pipe', 'r'];\n        }\n\n        return $spec;\n    }\n}\n\nabstract class AbstractPhpProcess\n{\n\n}\n?>\n",
      "<?php\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    protected string $tempFile;\n    protected mixed $stdin;\n    protected array $env = [];\n    protected int $timeout = 60;\n\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $this->stdin = $settings['stdin'] ?? null;\n        $this->env = $settings['env'] ?? [];\n        $this->timeout = $settings['timeout'] ?? 60;\n\n        $descriptorspec = $this->getDescriptorSpec();\n        $pipes = [];\n        $process = proc_open($this->getCommandLine(), $descriptorspec, $pipes, null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Could not create process.');\n        }\n\n        if ($this->useTemporaryFile()) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $job);\n            $job = '';\n        }\n\n        $this->process($pipes[0], $job);\n        fclose($pipes[0]);\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['output' => $stdout, 'error' => $stderr, 'exit_code' => $exitCode];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    protected function cleanup(): void\n    {\n        if (isset($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n\n    private function getDescriptorSpec(): array\n    {\n        if ($this->useTemporaryFile()) {\n            return [\n                0 => ['pipe', 'r'],\n                1 => ['pipe', 'w'],\n                2 => ['pipe', 'w'],\n            ];\n        }\n\n        return [\n            0 => $this->stdin !== null ? ['pipe', 'r'] : ['file', '/dev/null', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n    }\n\n\n    private function getCommandLine(): string\n    {\n        $phpExecutable = PHP_BINARY;\n        if ($this->useTemporaryFile()) {\n            return $phpExecutable . ' ' . $this->tempFile;\n        }\n        return $phpExecutable;\n    }\n}\n\nabstract class AbstractPhpProcess\n{\n\n}\n",
      "<?php\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    private ?string $tempFile = null;\n    private mixed $stdin;\n    private array $env = [];\n    private int $timeout = 60;\n\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $this->stdin = $settings['stdin'] ?? null;\n        $this->env = $settings['env'] ?? [];\n        $this->timeout = $settings['timeout'] ?? 60;\n\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $descriptorspec = $this->getDescriptorSpec();\n        $pipes = [];\n        $process = proc_open($this->getCommandLine(), $descriptorspec, $pipes, null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Could not create process.');\n        }\n\n        if ($this->useTemporaryFile()) {\n            $this->tempFile = $this->createTemporaryFile($job);\n        } else {\n            $this->process($pipes[0], $job);\n        }\n        fclose($pipes[0]);\n\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['output' => $stdout, 'error' => $stderr, 'exit_code' => $exitCode];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n\n    protected function cleanup(): void\n    {\n        if ($this->tempFile) {\n            unlink($this->tempFile);\n            $this->tempFile = null;\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n}\n\nabstract class AbstractPhpProcess\n{\n    protected function getCommandLine(): string\n    {\n        return PHP_BINARY;\n    }\n\n    protected function getDescriptorSpec(): array\n    {\n        if ($this->useTemporaryFile()) {\n            return [\n                0 => ['file', $this->tempFile, 'r'],\n                1 => ['pipe', 'w'],\n                2 => ['pipe', 'w'],\n            ];\n        } else {\n            return [\n                0 => ['pipe', 'r'],\n                1 => ['pipe', 'w'],\n                2 => ['pipe', 'w'],\n            ];\n        }\n    }\n\n    protected function createTemporaryFile(string $content): string\n    {\n        $tempFile = tempnam(sys_get_temp_dir(), 'php_process');\n        if (!file_put_contents($tempFile, $content)) {\n            throw new \\RuntimeException(\"Could not write to temporary file: $tempFile\");\n        }\n        return $tempFile;\n    }\n}\n",
      "<?php\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    protected string $tempFile;\n    protected mixed $stdin;\n    protected array $env;\n    protected int $timeout;\n\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $this->stdin = $settings['stdin'] ?? null;\n        $this->env = $settings['env'] ?? [];\n        $this->timeout = $settings['timeout'] ?? 60;\n\n        $descriptorspec = $this->getDescriptorspec();\n        $pipes = [];\n\n        $process = proc_open($this->getCommand(), $descriptorspec, $pipes, null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Could not create process.');\n        }\n\n        if ($this->useTemporaryFile()) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $job);\n            $job = '';\n        }\n\n        $this->process($pipes[0], $job);\n        fclose($pipes[0]);\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['output' => $stdout, 'error' => $stderr, 'exit_code' => $exitCode];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    protected function cleanup(): void\n    {\n        if (isset($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    protected string $tempFile;\n    protected mixed $stdin;\n    protected array $env;\n    protected int $timeout;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $this->stdin = $settings['stdin'] ?? null;\n        $this->env = $settings['env'] ?? [];\n        $this->timeout = $settings['timeout'] ?? 60;\n\n        $descriptorspec = $this->getDescriptorSpec();\n        $pipes = [];\n\n        $process = proc_open($this->getCommandLine(), $descriptorspec, $pipes, null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Could not create process.');\n        }\n\n        if ($this->useTemporaryFile()) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $job);\n            $this->process($pipes[0], $this->tempFile);\n        } else {\n            $this->process($pipes[0], $job);\n        }\n        fclose($pipes[0]);\n\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['output' => $stdout, 'error' => $stderr, 'exit_code' => $exitCode];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    protected function cleanup(): void\n    {\n        if (isset($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n\n    protected function getCommandLine(): string\n    {\n        return PHP_BINARY;\n    }\n\n    protected function getDescriptorSpec(): array\n    {\n        if ($this->useTemporaryFile()) {\n            return [\n                0 => ['pipe', 'r'],\n                1 => ['pipe', 'w'],\n                2 => ['pipe', 'w'],\n            ];\n        } else {\n            return [\n                0 => ['pipe', 'r'],\n                1 => ['pipe', 'w'],\n                2 => ['pipe', 'w'],\n            ];\n        }\n    }\n}\n\nabstract class AbstractPhpProcess\n{\n}\n",
      "<?php\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    protected string $tempFile;\n    protected mixed $stdin;\n    protected array $env;\n    protected int $timeout;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        return $this->runProcess($job, $settings);\n    }\n\n    public function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $this->stdin = $settings['stdin'] ?? null;\n        $this->env = $settings['env'] ?? [];\n        $this->timeout = $settings['timeout'] ?? 60;\n\n        $descriptorspec = $this->getDescriptorSpec();\n        $pipes = [];\n\n        $process = proc_open($this->getCommand(), $descriptorspec, $pipes, null, $this->env);\n\n        if (!is_resource($process)) {\n            throw new \\RuntimeException('Could not create process.');\n        }\n\n        if ($this->useTemporaryFile()) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php_process_');\n            file_put_contents($this->tempFile, $job);\n            $this->process($pipes[0], $this->tempFile);\n        } else {\n            $this->process($pipes[0], $job);\n        }\n        fclose($pipes[0]);\n\n\n        $stdout = stream_get_contents($pipes[1]);\n        fclose($pipes[1]);\n\n        $stderr = stream_get_contents($pipes[2]);\n        fclose($pipes[2]);\n\n        $exitCode = proc_close($process);\n\n        $this->cleanup();\n\n        return ['output' => $stdout, 'error' => $stderr, 'exit_code' => $exitCode];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    protected function cleanup(): void\n    {\n        if (isset($this->tempFile)) {\n            unlink($this->tempFile);\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n\n\n    private function getDescriptorSpec(): array\n    {\n        if ($this->useTemporaryFile()) {\n            return [\n                0 => ['pipe', 'r'],\n                1 => ['pipe', 'w'],\n                2 => ['pipe', 'w'],\n            ];\n        }\n\n        return [\n            0 => $this->stdin !== null ? ['pipe', 'r'] : ['pipe', 'w'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n    }\n\n    private function getCommand(): string\n    {\n        $phpExecutable = PHP_BINARY;\n        if ($this->useTemporaryFile()) {\n            return $phpExecutable . ' ' . $this->tempFile;\n        }\n        return $phpExecutable;\n    }\n}\n\nabstract class AbstractPhpProcess\n{\n\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 151,
    "Instruction": "Task Description: Create a PHP class that handles inter-process communication (IPC) using proc_open to execute external commands, manage input/output streams, and handle errors.\n\nClass Description: The ProcessHandler class manages subprocess execution via proc_open, providing methods to write input to the process, read output/errors, and properly clean up resources. It extends Monolog's AbstractProcessingHandler for logging integration.\n\nAttributes:\n- process: [resource|null] - The subprocess resource handle or null if not running\n- command: [string] - The command to execute in the subprocess\n- cwd: [string|null] - The working directory for the subprocess or null for default\n- pipes: [array] - Array of file pointers for process pipes (stdin, stdout, stderr)\n\nMethods:\n- __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null) -> [void] - Initializes the handler with command and optional working directory\n- write(array $record) -> [void] - Writes formatted log record to process stdin (inherited from AbstractProcessingHandler)\n- close() -> [void] - Closes all pipes and terminates the process\n- ensureProcessIsStarted() -> [void] - Starts the process if not already running\n- startProcess() -> [void] - Executes proc_open to start the subprocess\n- handleStartupErrors() -> [void] - Checks for and handles any startup errors\n- selectErrorStream() -> [int|false] - Monitors stderr for error output\n- readProcessErrors() -> [string] - Reads and returns content from stderr\n- writeProcessInput(string $string) -> [void] - Writes data to process stdin",
    "Canonical_solution": "use Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n    protected const DESCRIPTOR_SPEC = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        if ($command === '') {\n            throw new \\InvalidArgumentException('The command argument must be a non-empty string.');\n        }\n        if ($cwd === '') {\n            throw new \\InvalidArgumentException('The optional CWD argument must be a non-empty string or null.');\n        }\n\n        parent::__construct($level, $bubble);\n\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    protected function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record['formatted']);\n        $errors = $this->readProcessErrors();\n        if (empty($errors) === false) {\n            throw new \\UnexpectedValueException(sprintf('Errors while writing to process: %s', $errors));\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (is_resource($this->process) === false) {\n            $this->startProcess();\n            $this->handleStartupErrors();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $this->process = proc_open($this->command, static::DESCRIPTOR_SPEC, $this->pipes, $this->cwd);\n        foreach ($this->pipes as $pipe) {\n            stream_set_blocking($pipe, false);\n        }\n    }\n\n    private function handleStartupErrors(): void\n    {\n        $selected = $this->selectErrorStream();\n        if (false === $selected) {\n            throw new \\UnexpectedValueException('Something went wrong while selecting a stream.');\n        }\n\n        $errors = $this->readProcessErrors();\n        if (is_resource($this->process) === false || empty($errors) === false) {\n            throw new \\UnexpectedValueException(\n                sprintf('The process \"%s\" could not be opened: ' . $errors, $this->command)\n            );\n        }\n    }\n\n    protected function selectErrorStream()\n    {\n        $empty = [];\n        $errorPipes = [$this->pipes[2]];\n        return stream_select($errorPipes, $empty, $empty, 1);\n    }\n\n    protected function readProcessErrors(): string\n    {\n        return (string) stream_get_contents($this->pipes[2]);\n    }\n\n    protected function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n\n    public function close(): void\n    {\n        if (is_resource($this->process)) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nuse Monolog\\Handler\\AbstractProcessingHandler;\nuse Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        fwrite($this->pipes[0], (string) $record['formatted']);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            fclose($this->pipes[0]);\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        $this->handleStartupErrors();\n    }\n\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $status = proc_get_status($this->process);\n        if (!$status['running']) {\n            $errors = $this->readProcessErrors();\n            throw new \\RuntimeException('Process exited prematurely: ' . $errors);\n        }\n\n        stream_set_blocking($this->pipes[2], false); // Set stderr to non-blocking\n        stream_set_blocking($this->pipes[1], false); // Set stdout to non-blocking\n\n    }\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        return stream_get_contents($this->pipes[2]);\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nuse Monolog\\Handler\\AbstractProcessingHandler;\nuse Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        fwrite($this->pipes[0], (string) $record['formatted']);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            fclose($this->pipes[0]);\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        $this->handleStartupErrors();\n    }\n\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        if ($errorStream = $this->selectErrorStream()) {\n            $errorOutput = $this->readProcessErrors();\n            throw new \\RuntimeException(\"Error starting process: {$errorOutput}\");\n        }\n\n        stream_set_blocking($this->pipes[1], false);\n        stream_set_blocking($this->pipes[2], false);\n    }\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        $result = stream_select($read, $write, $except, 0);\n        return $result === false ? false : ($read ? 2 : false);\n    }\n\n    private function readProcessErrors(): string\n    {\n        return stream_get_contents($this->pipes[2]);\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nuse Monolog\\Handler\\AbstractProcessingHandler;\nuse Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $string = (string) $record['formatted'];\n        $this->writeProcessInput($string);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        $this->handleStartupErrors();\n    }\n\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $status = proc_get_status($this->process);\n        if (!$status['running']) {\n            $this->close();\n            throw new \\RuntimeException('Process exited prematurely with exit code ' . $status['exitcode']);\n        }\n\n        stream_set_blocking($this->pipes[2], false);\n    }\n\n    private function selectErrorStream()\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        $errors = '';\n        if ($this->selectErrorStream()) {\n            $errors = stream_get_contents($this->pipes[2]);\n        }\n        return $errors;\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        if (!fwrite($this->pipes[0], $string)) {\n            throw new \\RuntimeException('Could not write to process stdin.');\n        }\n    }\n}\n",
      "<?php\n\nuse Monolog\\Handler\\AbstractProcessingHandler;\nuse Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $string = (string) $record['formatted'];\n        $this->writeProcessInput($string);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'], // stdin\n            1 => ['pipe', 'w'], // stdout\n            2 => ['pipe', 'w'], // stderr\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false); // Set stdout to non-blocking\n        stream_set_blocking($this->pipes[2], false); // Set stderr to non-blocking\n    }\n\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream()\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        if (!fwrite($this->pipes[0], $string)) {\n            throw new \\RuntimeException('Could not write to process stdin.');\n        }\n    }\n}\n",
      "<?php\n\nuse Monolog\\Handler\\AbstractProcessingHandler;\nuse Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $string = (string) $record['formatted'];\n        $this->writeProcessInput($string);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'], // stdin\n            1 => ['pipe', 'w'], // stdout\n            2 => ['pipe', 'w'], // stderr\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        $this->handleStartupErrors();\n    }\n\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $status = proc_get_status($this->process);\n        if (!$status['running']) {\n            $errors = $this->readProcessErrors();\n            throw new \\RuntimeException('Process exited prematurely: ' . $errors);\n        }\n\n        stream_set_blocking($this->pipes[1], false); // Set stdout to non-blocking\n        stream_set_blocking($this->pipes[2], false); // Set stderr to non-blocking\n    }\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = [];\n        $except = [];\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        return stream_get_contents($this->pipes[2]);\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nuse Monolog\\Handler\\AbstractProcessingHandler;\nuse Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $string = (string) $record['formatted'];\n        $this->writeProcessInput($string);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'], // stdin\n            1 => ['pipe', 'w'], // stdout\n            2 => ['pipe', 'w'], // stderr\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false); // Set stdout to non-blocking\n        stream_set_blocking($this->pipes[2], false); // Set stderr to non-blocking\n    }\n\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n    }\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = [];\n        $except = [];\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        $errors = '';\n        if ($this->selectErrorStream()) {\n            $errors = stream_get_contents($this->pipes[2]);\n        }\n        return $errors;\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        if (!fwrite($this->pipes[0], $string)) {\n            throw new \\RuntimeException('Failed to write to process stdin.');\n        }\n    }\n}\n",
      "<?php\n\nuse Monolog\\Handler\\AbstractProcessingHandler;\nuse Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $string = (string) $record['formatted'];\n        $this->writeProcessInput($string);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'], // stdin\n            1 => ['pipe', 'w'], // stdout\n            2 => ['pipe', 'w'], // stderr\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        $this->handleStartupErrors();\n    }\n\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $status = proc_get_status($this->process);\n        if (!$status['running']) {\n            $this->close();\n            throw new \\RuntimeException('Process exited prematurely with code: ' . $status['exitcode']);\n        }\n    }\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = [];\n        $except = [];\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        $errors = '';\n        if ($this->selectErrorStream()) {\n            $errors = stream_get_contents($this->pipes[2]);\n        }\n        return $errors;\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nuse Monolog\\Handler\\AbstractProcessingHandler;\nuse Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $string = (string) $record['formatted'];\n        $this->writeProcessInput($string);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'], // stdin\n            1 => ['pipe', 'w'], // stdout\n            2 => ['pipe', 'w'], // stderr\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        $this->handleStartupErrors();\n\n        stream_set_blocking($this->pipes[1], false); // Set stdout to non-blocking\n        stream_set_blocking($this->pipes[2], false); // Set stderr to non-blocking\n    }\n\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        if ($error = $this->readProcessErrors()) {\n            throw new \\RuntimeException('Process started with errors: ' . $error);\n        }\n    }\n\n\n    private function selectErrorStream()\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        if ($this->selectErrorStream()) {\n            return stream_get_contents($this->pipes[2]);\n        }\n        return '';\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nuse Monolog\\Handler\\AbstractProcessingHandler;\nuse Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        fwrite($this->pipes[0], (string) $record['formatted']);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            fclose($this->pipes[0]);\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        $this->handleStartupErrors();\n    }\n\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        if ($errorStream = $this->selectErrorStream()) {\n            $errorOutput = $this->readProcessErrors();\n            throw new \\RuntimeException('Error starting process: ' . $errorOutput);\n        }\n\n        stream_set_blocking($this->pipes[1], false);\n        stream_set_blocking($this->pipes[2], false);\n    }\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        $result = stream_select($read, $write, $except, 0);\n        return $result === false ? false : ($read ? 2 : false);\n    }\n\n    private function readProcessErrors(): string\n    {\n        return stream_get_contents($this->pipes[2]);\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n",
      "<?php\n\nuse Monolog\\Handler\\AbstractProcessingHandler;\nuse Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        fwrite($this->pipes[0], (string) $record['formatted']);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            fclose($this->pipes[0]);\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        $this->handleStartupErrors();\n    }\n\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Could not start process: ' . $this->command);\n        }\n\n        $status = proc_get_status($this->process);\n        if (!$status['running']) {\n            $errors = $this->readProcessErrors();\n            throw new \\RuntimeException('Process exited prematurely: ' . $errors);\n        }\n\n        stream_set_blocking($this->pipes[1], false);\n        stream_set_blocking($this->pipes[2], false);\n    }\n\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        return stream_get_contents($this->pipes[2]);\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n}\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a PHP class that handles interactions with the Alipay payment gateway, specifically for transferring funds to Alipay accounts. The class should handle request signing, HTTP communication, and response processing.\n\nClass Description: The AlipayService class provides functionality to interact with Alipay's fund transfer API. It handles request signing using RSA, constructs proper API requests, and processes responses. The class manages authentication credentials and provides methods for executing fund transfers.\n\nAttributes:\n- appId: string - Alipay application ID\n- rsaPrivateKey: string - RSA private key for request signing\n- alipayRootCertSn: string - Alipay root certificate serial number\n- appCertSn: string - Application certificate serial number\n- charset: string - Character encoding (default: 'utf-8')\n\nMethods:\n- __construct(string $appid, string $saPrivateKey) -> void - Initializes the service with app ID and private key\n- setAlipayRootCertSn(string $alipayRootCertSn) -> void - Sets the Alipay root certificate serial number\n- setAppCertSn(string $appCertSn) -> void - Sets the application certificate serial number\n- doTransfer(float $totalFee, string $outTradeNo, string $account, string $realName, string $remark='') -> array - Executes a fund transfer with given parameters\n- curlPost(string $url='', mixed $postData='', array $options=array()) -> string - Sends a POST request using cURL\n- generateSign(array $params, string $signType=\"RSA\") -> string - Generates a signature for request parameters\n- sign(string $data, string $signType=\"RSA\") -> string - Signs data using RSA\n- checkEmpty(mixed $value) -> bool - Checks if a value is empty\n- getSignContent(array $params) -> string - Prepares parameters for signing\n- characet(string $data, string $targetCharset) -> string - Converts character encoding",
    "Canonical_solution": "class AlipayService\n{\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $alipayRootCertSn = '';\n    protected $appCertSn = '';\n    protected $charset = 'utf-8';\n\n    public function __construct($appid, $saPrivateKey)\n    {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $saPrivateKey;\n    }\n\n    public function setAlipayRootCertSn($alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn($appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n    public function doTransfer($totalFee, $outTradeNo, $account, $realName, $remark='')\n    {\n        $requestConfigs = array(\n            'out_biz_no'=>$outTradeNo,\n            'payee_type'=>'ALIPAY_LOGONID',\n            'trans_amount'=>$totalFee,\n            'product_code'=>'TRANS_ACCOUNT_NO_PWD',\n            'biz_scene'=>'DIRECT_TRANSFER',\n            'order_title'=>'织梦猫提现',\n            'payee_info'=>array(\n                'identity'=>$account,\n                'identity_type'=>'ALIPAY_LOGON_ID',\n                'name'=>$realName,\n            ),\n            'remark'=>$remark,\n        );\n        $commonConfigs = array(\n            'alipay_root_cert_sn' => $this->alipayRootCertSn,\n            'app_cert_sn' => $this->appCertSn,\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset'=>$this->charset,\n            'sign_type'=>'RSA2',\n            'timestamp'=>date('Y-m-d H:i:s'),\n            'version'=>'1.0',\n            'biz_content'=>json_encode($requestConfigs),\n        );\n        $commonConfigs[\"sign\"] = $this->generateSign($commonConfigs, $commonConfigs['sign_type']);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do?charset='.$this->charset,$commonConfigs);\n        return json_decode($result,true);\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array())\n    {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey=$this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, version_compare(PHP_VERSION,'5.4.0', '<') ? SHA256 : OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    protected function checkEmpty($value) {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n        return false;\n    }\n\n    public function getSignContent($params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                $v = $this->characet($v, $this->charset);\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey)\n    {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn): void\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn): void\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function doTransfer(float $totalFee, string $outTradeNo, string $account, string $realName, string $remark = ''): array\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.toaccount.transfer',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outTradeNo,\n                'payee_type' => 'ALIPAY_LOGONID',\n                'payee_account' => $account,\n                'amount' => number_format($totalFee, 2, '.', ''),\n                'payer_show_name' => $realName,\n                'payee_real_name' => $realName,\n                'remark' => $remark,\n            ]),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, $params);\n        return json_decode($result, true);\n    }\n\n\n    public function curlPost(string $url = '', mixed $postData = '', array $options = array()): string\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, is_array($postData) ? http_build_query($postData) : $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n    public function generateSign(array $params, string $signType = \"RSA2\"): string\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType = \"RSA2\"): string\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty(mixed $value): bool\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    public function getSignContent(array $params): string\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . \"=\" . $v . \"&\";\n            }\n        }\n        $stringToBeSigned = substr($stringToBeSigned, 0, strlen($stringToBeSigned) - 1);\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n\n    public function characet(string $data, string $targetCharset): string\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8,GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset);\n            }\n        }\n        return $data;\n    }\n}\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey)\n    {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn): void\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn): void\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function doTransfer(float $totalFee, string $outTradeNo, string $account, string $realName, string $remark = ''): array\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.toaccount.transfer',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outTradeNo,\n                'payee_type' => 'ALIPAY_LOGONID',\n                'payee_account' => $account,\n                'amount' => number_format($totalFee, 2, '.', ''),\n                'payer_show_name' => $realName,\n                'payee_real_name' => $realName,\n                'remark' => $remark,\n            ]),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n        $response = $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n        return json_decode($response, true);\n    }\n\n\n    public function curlPost(string $url = '', mixed $postData = '', array $options = array()): string\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, is_array($postData) ? http_build_query($postData) : $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n    public function generateSign(array $params, string $signType = \"RSA2\"): string\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType = \"RSA2\"): string\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty(mixed $value): bool\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    public function getSignContent(array $params): string\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    public function characet(string $data, string $targetCharset): string\n    {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset);\n            }\n        }\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey)\n    {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn): void\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn): void\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function doTransfer(float $totalFee, string $outTradeNo, string $account, string $realName, string $remark = ''): array\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.toaccount.transfer',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outTradeNo,\n                'payee_type' => 'ALIPAY_LOGONID',\n                'payee_account' => $account,\n                'amount' => number_format($totalFee, 2, '.', ''),\n                'payer_show_name' => $realName,\n                'payee_real_name' => $realName,\n                'remark' => $remark,\n            ]),\n        ];\n\n        if (!empty($this->appCertSn) && !empty($this->alipayRootCertSn)) {\n            $params['app_cert_sn'] = $this->appCertSn;\n            $params['alipay_root_cert_sn'] = $this->alipayRootCertSn;\n        }\n\n        $params['sign'] = $this->generateSign($params);\n        $response = $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n        return json_decode($response, true);\n    }\n\n    public function curlPost(string $url = '', mixed $postData = '', array $options = array()): string\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, is_array($postData) ? http_build_query($postData) : $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n    public function generateSign(array $params, string $signType = \"RSA2\"): string\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType = \"RSA2\"): string\n    {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        ($signType === 'RSA') ? openssl_sign($data, $sign, $res) : openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n\n    protected function checkEmpty(mixed $value): bool\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    public function getSignContent(array $params): string\n    {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    public function characet(string $data, string $targetCharset): string\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey)\n    {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn): void\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn): void\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function doTransfer(float $totalFee, string $outTradeNo, string $account, string $realName, string $remark = ''): array\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.toaccount.transfer',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outTradeNo,\n                'payee_type' => 'ALIPAY_LOGONID',\n                'payee_account' => $account,\n                'amount' => number_format($totalFee, 2, '.', ''),\n                'payer_show_name' => $realName,\n                'payee_real_name' => $realName,\n                'remark' => $remark,\n            ]),\n        ];\n\n        if (!empty($this->appCertSn) && !empty($this->alipayRootCertSn)) {\n            $params['app_cert_sn'] = $this->appCertSn;\n            $params['alipay_root_cert_sn'] = $this->alipayRootCertSn;\n        }\n\n        $params['sign'] = $this->generateSign($params);\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n        return json_decode($response, true);\n    }\n\n\n    public function curlPost(string $url = '', mixed $postData = '', array $options = array()): string\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, is_array($postData) ? http_build_query($postData) : $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n    public function generateSign(array $params, string $signType = \"RSA2\"): string\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign(string $data, string $signType = \"RSA2\"): string\n    {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        ($signType === 'RSA') ? openssl_sign($data, $sign, $res) : openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n\n    protected function checkEmpty(mixed $value): bool\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    public function getSignContent(array $params): string\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset): string\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n}\n\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $charset = 'utf-8';\n\n\n    public function __construct(string $appid, string $rsaPrivateKey)\n    {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn): void\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn): void\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function doTransfer(float $totalFee, string $outTradeNo, string $account, string $realName, string $remark = ''): array\n    {\n        $bizContent = [\n            'out_biz_no' => $outTradeNo,\n            'trans_amount' => $totalFee,\n            'product_code' => 'TRANS_ACCOUNT_NO_PWD',\n            'payee_info' => [\n                'identity' => $account,\n                'identity_type' => 'ALIPAY_LOGON_ID',\n                'name' => $realName,\n            ],\n            'remark' => $remark,\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.toaccount.transfer',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = json_decode($this->curlPost($url, $params), true);\n\n        return $result;\n    }\n\n\n    public function curlPost(string $url = '', mixed $postData = '', array $options = array()): string\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, is_array($postData) ? http_build_query($postData) : $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n\n        $result = curl_exec($ch);\n        curl_close($ch);\n        return $result;\n    }\n\n    public function generateSign(array $params, string $signType = \"RSA2\"): string\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType = \"RSA2\"): string\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty(mixed $value): bool\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    public function getSignContent(array $params): string\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n\n    public function characet(string $data, string $targetCharset): string\n    {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset);\n                $this->charset = $targetCharset;\n            }\n        }\n        return $data;\n    }\n}\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey)\n    {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn): void\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn): void\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function doTransfer(float $totalFee, string $outTradeNo, string $account, string $realName, string $remark = ''): array\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.toaccount.transfer',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outTradeNo,\n                'payee_type' => 'ALIPAY_LOGONID',\n                'payee_account' => $account,\n                'amount' => number_format($totalFee, 2, '.', ''),\n                'payer_show_name' => $realName,\n                'payee_real_name' => $realName,\n                'remark' => $remark,\n            ]),\n        ];\n\n        if (!empty($this->appCertSn) && !empty($this->alipayRootCertSn)) {\n            $params['app_cert_sn'] = $this->appCertSn;\n            $params['alipay_root_cert_sn'] = $this->alipayRootCertSn;\n        }\n\n        $params['sign'] = $this->generateSign($params);\n        $response = $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n        return json_decode($response, true);\n    }\n\n    public function curlPost(string $url = '', mixed $postData = '', array $options = array()): string\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, is_array($postData) ? http_build_query($postData) : $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n    public function generateSign(array $params, string $signType = \"RSA2\"): string\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType = \"RSA2\"): string\n    {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        ($signType === 'RSA') ? openssl_sign($data, $sign, $res) : openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        openssl_free_key($res);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty(mixed $value): bool\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    public function getSignContent(array $params): string\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    public function characet(string $data, string $targetCharset): string\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n}\n",
      "<?php\n\nclass AlipayService {\n\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $charset = 'utf-8';\n\n\n    public function __construct(string $appid, string $rsaPrivateKey) {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn) {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn) {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function doTransfer(float $totalFee, string $outTradeNo, string $account, string $realName, string $remark=''): array\n    {\n        $bizContent = [\n            'out_biz_no' => $outTradeNo,\n            'trans_amount' => $totalFee,\n            'product_code' => 'TRANS_ACCOUNT_NO_PWD',\n            'payee_info' => [\n                'identity' => $account,\n                'identity_type' => 'ALIPAY_LOGON_ID',\n                'name' => $realName,\n            ],\n            'remark' => $remark,\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        if (!empty($this->appCertSn) && !empty($this->alipayRootCertSn)) {\n            $params['app_cert_sn'] = $this->appCertSn;\n            $params['alipay_root_cert_sn'] = $this->alipayRootCertSn;\n        }\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, $params);\n        return json_decode($result, true);\n    }\n\n\n\n    public function curlPost(string $url='', mixed $postData='', array $options=array()): string\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, is_array($postData)?http_build_query($postData):$postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https请求 不验证证书和host\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n    public function generateSign(array $params, string $signType=\"RSA\"): string\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign(string $data, string $signType=\"RSA\"): string\n    {\n        $priKey=$this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    public function checkEmpty(mixed $value): bool\n    {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent(array $params): string\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                // 转换成目标字符集\n                $v = $this->characet($v, $this->charset);\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    /**\n     * 转换字符集编码\n     * @param $data\n     * @param $targetCharset\n     * @return string\n     */\n    function characet(string $data, string $targetCharset): string\n    {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n                //$data = iconv($fileType, $targetCharset.'//IGNORE', $data);\n            }\n        }\n        return $data;\n    }\n}\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey)\n    {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn): void\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn): void\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function doTransfer(float $totalFee, string $outTradeNo, string $account, string $realName, string $remark = ''): array\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.toaccount.transfer',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outTradeNo,\n                'payee_type' => 'ALIPAY_LOGONID',\n                'payee_account' => $account,\n                'amount' => number_format($totalFee, 2, '.', ''),\n                'payer_show_name' => $realName,\n                'payee_real_name' => $realName,\n                'remark' => $remark,\n            ]),\n        ];\n\n        if (!empty($this->appCertSn) && !empty($this->alipayRootCertSn)) {\n            $params['app_cert_sn'] = $this->appCertSn;\n            $params['alipay_root_cert_sn'] = $this->alipayRootCertSn;\n        }\n\n        $params['sign'] = $this->generateSign($params);\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n\n        return json_decode($response, true);\n    }\n\n    public function curlPost(string $url = '', mixed $postData = '', array $options = array()): string\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, is_array($postData) ? http_build_query($postData) : $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n    public function generateSign(array $params, string $signType = \"RSA2\"): string\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType = \"RSA2\"): string\n    {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        ($signType === 'RSA') ? openssl_sign($data, $sign, $res) : openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        openssl_free_key($res);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty(mixed $value): bool\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    public function getSignContent(array $params): string\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset): string\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $charset = 'utf-8';\n\n\n    public function __construct(string $appid, string $rsaPrivateKey)\n    {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn): void\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn): void\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function doTransfer(float $totalFee, string $outTradeNo, string $account, string $realName, string $remark = ''): array\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.toaccount.transfer',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outTradeNo,\n                'payee_type' => 'ALIPAY_LOGONID',\n                'payee_account' => $account,\n                'amount' => number_format($totalFee, 2, '.', ''),\n                'payer_show_name' => $realName,\n                'payee_real_name' => $realName,\n                'remark' => $remark,\n            ]),\n        ];\n\n        if (!empty($this->appCertSn) && !empty($this->alipayRootCertSn)) {\n            $params['app_cert_sn'] = $this->appCertSn;\n            $params['alipay_root_cert_sn'] = $this->alipayRootCertSn;\n        }\n\n        $params['sign'] = $this->generateSign($params);\n\n        $result = json_decode($this->curlPost('https://openapi.alipay.com/gateway.do', $params), true);\n        return $result;\n    }\n\n\n    public function curlPost(string $url = '', mixed $postData = '', array $options = array()): string\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, is_array($postData) ? http_build_query($postData) : $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n\n    public function generateSign(array $params, string $signType = \"RSA2\"): string\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType = \"RSA2\"): string\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty(mixed $value): bool\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    public function getSignContent(array $params): string\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    public function characet(string $data, string $targetCharset): string\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n}\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey)\n    {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn): void\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn): void\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function doTransfer(float $totalFee, string $outTradeNo, string $account, string $realName, string $remark = ''): array\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.toaccount.transfer',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outTradeNo,\n                'payee_type' => 'ALIPAY_LOGONID',\n                'payee_account' => $account,\n                'amount' => number_format($totalFee, 2, '.', ''),\n                'payer_show_name' => $realName,\n                'payee_real_name' => $realName,\n                'remark' => $remark,\n            ]),\n        ];\n\n        if (!empty($this->appCertSn) && !empty($this->alipayRootCertSn)) {\n            $params['app_cert_sn'] = $this->appCertSn;\n            $params['alipay_root_cert_sn'] = $this->alipayRootCertSn;\n        }\n\n        $params['sign'] = $this->generateSign($params);\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n        return json_decode($response, true);\n    }\n\n\n    public function curlPost(string $url = '', mixed $postData = '', array $options = array()): string\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, is_array($postData) ? http_build_query($postData) : $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n\n    public function generateSign(array $params, string $signType = \"RSA2\"): string\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType = \"RSA2\"): string\n    {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        ($signType === 'RSA') ? openssl_sign($data, $sign, $res) : openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        openssl_free_key($res);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty(mixed $value): bool\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    public function getSignContent(array $params): string\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    public function characet(string $data, string $targetCharset): string\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a PHP class that handles HTTP requests using cURL for sending upgrade notifications, with error handling and response processing capabilities.\n\nClass Description: UpgradeNoticeBehavior is a class designed to manage HTTP communications for upgrade notifications. It encapsulates cURL functionality to send requests to specified URLs, handle parameters and headers, process responses, and manage errors.\n\nAttributes:\nheader_: [string] - Stores HTTP headers for requests\nhttpCode_: [int] - Stores HTTP status code from responses\nhttpDesc_: [string] - Stores HTTP status description from responses\naccesskey_: [string] - Stores access key for authentication\nsecretkey_: [string] - Stores secret key for authentication\n\nMethods:\nsend: [send]([string $url, array $params = array(), array $headers = array()]) -> [mixed] - Sends an HTTP request to the specified URL with optional parameters and headers. Returns the decoded JSON response on success or false on failure. Handles cURL errors and invalid response formats.",
    "Canonical_solution": "namespace Behavior;\n\nclass UpgradeNoticeBehavior {\n    protected $header_ = '';\n    protected $httpCode_;\n    protected $httpDesc_;\n    protected $accesskey_;\n    protected $secretkey_;\n\n    private function send($url, $params = array(), $headers = array()) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        if (!empty($params)) {\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        }\n        if (!empty($headers)) curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $txt = curl_exec($ch);\n        if (curl_errno($ch)) {\n            trace(curl_error($ch), '升级通知出错', 'NOTIC', true);\n            return false;\n        }\n        curl_close($ch);\n        $ret = json_decode($txt, true);\n        if (!$ret) {\n            trace('接口[' . $url . ']返回格式不正确', '升级通知出错', 'NOTIC', true);\n            return false;\n        }\n        return $ret;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass UpgradeNoticeBehavior\n{\n    private $header_ = [];\n    private $httpCode_;\n    private $httpDesc_;\n    private $accesskey_;\n    private $secretkey_;\n\n    public function send(string $url, array $params = [], array $headers = []): mixed\n    {\n        $ch = curl_init($url);\n\n        if (!empty($params)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n        }\n\n        $headers = array_merge($this->header_, $headers);\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($this->accesskey_ && $this->secretkey_) {\n            curl_setopt($ch, CURLOPT_USERPWD, $this->accesskey_ . \":\" . $this->secretkey_);\n        }\n\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $this->httpDesc_ = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $this->httpCode_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        $this->httpDesc_ = '';\n        $headerLines = explode(\"\\r\\n\", $header);\n        foreach ($headerLines as $line) {\n            if (strpos($line, 'HTTP/') === 0) {\n                $this->httpDesc_ = $line;\n                break;\n            }\n        }\n\n        curl_close($ch);\n\n\n        $json = json_decode($body, true);\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            $this->httpDesc_ = 'Invalid JSON response';\n            return false;\n        }\n\n        return $json;\n    }\n\n\n    public function setAuth(string $accesskey, string $secretkey): void\n    {\n        $this->accesskey_ = $accesskey;\n        $this->secretkey_ = $secretkey;\n    }\n\n\n    public function getHttpCode(): ?int\n    {\n        return $this->httpCode_;\n    }\n\n    public function getHttpDesc(): ?string\n    {\n        return $this->httpDesc_;\n    }\n\n\n    public function setHeader(array $header): void\n    {\n        $this->header_ = $header;\n    }\n\n}\n?>\n",
      "<?php\n\nclass UpgradeNoticeBehavior\n{\n    private $header_ = [];\n    private $httpCode_;\n    private $httpDesc_;\n    private $accesskey_;\n    private $secretkey_;\n\n    public function send(string $url, array $params = [], array $headers = []): mixed\n    {\n        $ch = curl_init($url);\n\n        if (!empty($params)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n        }\n\n        $headers = array_merge($this->header_, $headers);\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n\n        if(isset($this->accesskey_) && isset($this->secretkey_)){\n            curl_setopt($ch, CURLOPT_USERPWD, $this->accesskey_ . \":\" . $this->secretkey_);\n        }\n\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n\n\n        $response = curl_exec($ch);\n\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $this->httpCode_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n\n        $header_lines = explode(\"\\r\\n\", $header);\n        foreach ($header_lines as $line) {\n          if (strpos($line, 'HTTP/') === 0) {\n            $parts = explode(' ', $line);\n            if (isset($parts[1])) {\n              $this->httpCode_ = (int)$parts[1];\n            }\n            if (isset($parts[2])) {\n              $this->httpDesc_ = $parts[2];\n            }\n          }\n        }\n\n        curl_close($ch);\n\n\n        $jsonData = json_decode($body, true);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            return $jsonData;\n        }\n\n        return false;\n\n    }\n\n    public function setAuth(string $accesskey, string $secretkey): void{\n        $this->accesskey_ = $accesskey;\n        $this->secretkey_ = $secretkey;\n    }\n\n    public function getHttpCode(): ?int\n    {\n        return $this->httpCode_;\n    }\n\n    public function getHttpDesc(): ?string\n    {\n        return $this->httpDesc_;\n    }\n\n    public function setHeader(array $header): void\n    {\n        $this->header_ = $header;\n    }\n}\n?>\n",
      "<?php\n\nclass UpgradeNoticeBehavior\n{\n    private $header_ = [];\n    private $httpCode_;\n    private $httpDesc_;\n    private $accesskey_;\n    private $secretkey_;\n\n    public function __construct($accesskey = null, $secretkey = null)\n    {\n        $this->accesskey_ = $accesskey;\n        $this->secretkey_ = $secretkey;\n    }\n\n    public function send(string $url, array $params = [], array $headers = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n\n        if (!empty($params)) {\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n        }\n\n        $headers = array_merge($this->header_, $headers);\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n\n        if ($this->accesskey_ && $this->secretkey_) {\n            curl_setopt($ch, CURLOPT_USERPWD, $this->accesskey_ . \":\" . $this->secretkey_);\n        }\n\n\n        $response = curl_exec($ch);\n        $this->httpCode_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->httpDesc_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n\n\n        $decodedResponse = json_decode($response, true);\n        if (json_last_error() !== JSON_ERROR_NONE) {\n\n            return false;\n        }\n\n        return $decodedResponse;\n    }\n}\n?>\n",
      "<?php\n\nclass UpgradeNoticeBehavior\n{\n    private $header_ = [];\n    private $httpCode_;\n    private $httpDesc_;\n    private $accesskey_;\n    private $secretkey_;\n\n\n    public function __construct($accesskey = null, $secretkey = null)\n    {\n        $this->accesskey_ = $accesskey;\n        $this->secretkey_ = $secretkey;\n    }\n\n    public function send(string $url, array $params = [], array $headers = [])\n    {\n        $ch = curl_init();\n\n        if (!empty($params)) {\n            $url .= '?' . http_build_query($params);\n        }\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n\n\n        if (!empty($headers)) {\n            $this->header_ = array_merge($this->header_, $headers);\n        }\n\n        if (!empty($this->header_)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->header_);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $this->httpCode_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n\n        $header_lines = explode(\"\\r\\n\", $header);\n        foreach ($header_lines as $line) {\n            if (strpos($line, 'HTTP/') === 0) {\n                $parts = explode(' ', $line, 3);\n                if (count($parts) >= 2) {\n                    $this->httpDesc_ = $parts[2] ?? '';\n                }\n            }\n        }\n\n        curl_close($ch);\n\n\n        $json = json_decode($body, true);\n\n        if (json_last_error() === JSON_ERROR_NONE) {\n            return $json;\n        }\n\n        return false;\n\n    }\n}\n",
      "<?php\n\nclass UpgradeNoticeBehavior\n{\n    private $header_ = [];\n    private $httpCode_;\n    private $httpDesc_;\n    private $accesskey_;\n    private $secretkey_;\n\n    public function send(string $url, array $params = [], array $headers = [])\n    {\n        $ch = curl_init($url);\n\n        if (!empty($params)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n        }\n\n        $headers = array_merge($this->header_, $headers);\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($this->accesskey_ && $this->secretkey_) {\n            curl_setopt($ch, CURLOPT_USERPWD, $this->accesskey_ . \":\" . $this->secretkey_);\n        }\n\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n\n\n        $response = curl_exec($ch);\n\n\n        if ($response === false) {\n            $this->httpDesc_ = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $this->httpCode_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        $headerLines = explode(\"\\r\\n\", $header);\n        foreach ($headerLines as $line) {\n            $parts = explode(': ', $line, 2);\n            if (count($parts) == 2) {\n                $this->httpDesc_ = isset($parts[1]) ? $parts[1] : '';\n            }\n        }\n\n        curl_close($ch);\n\n        $json = json_decode($body, true);\n\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            return false;\n        }\n\n        return $json;\n    }\n\n    public function setAuth(string $accesskey, string $secretkey): void\n    {\n        $this->accesskey_ = $accesskey;\n        $this->secretkey_ = $secretkey;\n    }\n\n\n    public function getHttpCode(): ?int\n    {\n        return $this->httpCode_;\n    }\n\n    public function getHttpDesc(): ?string\n    {\n        return $this->httpDesc_;\n    }\n}\n?>\n",
      "<?php\n\nclass UpgradeNoticeBehavior\n{\n    private $header_ = [];\n    private $httpCode_;\n    private $httpDesc_;\n    private $accesskey_;\n    private $secretkey_;\n\n    public function send(string $url, array $params = [], array $headers = []): mixed\n    {\n        $ch = curl_init($url);\n\n        if (!empty($params)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n        }\n\n        $headers = array_merge($this->header_, $headers);\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($this->accesskey_ && $this->secretkey_) {\n            curl_setopt($ch, CURLOPT_USERPWD, $this->accesskey_ . \":\" . $this->secretkey_);\n        }\n\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $this->httpCode_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n\n        $header_lines = explode(\"\\r\\n\", $header);\n        foreach ($header_lines as $line) {\n          if (strpos($line, 'HTTP/') === 0) {\n            $parts = explode(' ', $line);\n            if (isset($parts[1])) {\n              $this->httpCode_ = (int)$parts[1];\n            }\n            if (isset($parts[2])) {\n              $this->httpDesc_ = $parts[2];\n            }\n          }\n        }\n\n        curl_close($ch);\n\n        $json = json_decode($body, true);\n\n        if (json_last_error() === JSON_ERROR_NONE) {\n            return $json;\n        }\n\n        return false;\n\n    }\n\n    public function setAuth(string $accesskey, string $secretkey): void {\n        $this->accesskey_ = $accesskey;\n        $this->secretkey_ = $secretkey;\n    }\n\n    public function getHttpCode(): ?int {\n        return $this->httpCode_;\n    }\n\n    public function getHttpDesc(): ?string {\n        return $this->httpDesc_;\n    }\n}\n?>\n",
      "<?php\n\nclass UpgradeNoticeBehavior\n{\n    private $header_ = [];\n    private $httpCode_;\n    private $httpDesc_;\n    private $accesskey_;\n    private $secretkey_;\n\n\n    public function __construct($accesskey = null, $secretkey = null)\n    {\n        $this->accesskey_ = $accesskey;\n        $this->secretkey_ = $secretkey;\n    }\n\n    public function send(string $url, array $params = [], array $headers = [])\n    {\n        $ch = curl_init();\n\n        if (!empty($params)) {\n            $url .= '?' . http_build_query($params);\n        }\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        if (!empty($headers)) {\n            $this->header_ = array_merge($this->header_, $headers);\n        }\n        if (!empty($this->header_)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->header_);\n        }\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $this->httpCode_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        $header_lines = explode(\"\\r\\n\", $header);\n        foreach ($header_lines as $line) {\n            if (strpos($line, 'HTTP/') === 0) {\n                $parts = explode(' ', $line, 3);\n                if (isset($parts[1])) {\n                    $this->httpCode_ = (int)$parts[1];\n                }\n                if (isset($parts[2])) {\n                    $this->httpDesc_ = $parts[2];\n                }\n            }\n        }\n\n        curl_close($ch);\n\n        $json = json_decode($body, true);\n\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            return false;\n        }\n\n        return $json;\n    }\n}\n",
      "<?php\n\nclass UpgradeNoticeBehavior\n{\n    private $header_ = [];\n    private $httpCode_;\n    private $httpDesc_;\n    private $accesskey_;\n    private $secretkey_;\n\n    public function __construct($accesskey = null, $secretkey = null)\n    {\n        $this->accesskey_ = $accesskey;\n        $this->secretkey_ = $secretkey;\n    }\n\n    public function send(string $url, array $params = [], array $headers = [])\n    {\n        $ch = curl_init();\n\n        if (!empty($params)) {\n            $url .= '?' . http_build_query($params);\n        }\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n        if (!is_null($this->accesskey_) && !is_null($this->secretkey_)) {\n            curl_setopt($ch, CURLOPT_USERPWD, $this->accesskey_ . \":\" . $this->secretkey_);\n        }\n\n\n        $response = curl_exec($ch);\n        $this->httpCode_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->httpDesc_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $decodedResponse = json_decode($response, true);\n\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $decodedResponse;\n    }\n\n\n    public function getHttpCode()\n    {\n        return $this->httpCode_;\n    }\n\n    public function getHttpDesc()\n    {\n        return $this->httpDesc_;\n    }\n}\n",
      "<?php\n\nclass UpgradeNoticeBehavior\n{\n    private $header_ = [];\n    private $httpCode_;\n    private $httpDesc_;\n    private $accesskey_;\n    private $secretkey_;\n\n    public function send(string $url, array $params = [], array $headers = []): mixed\n    {\n        $ch = curl_init($url);\n\n        if (!empty($params)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n        }\n\n        $headers = array_merge($this->header_, $headers);\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($this->accesskey_ && $this->secretkey_) {\n            curl_setopt($ch, CURLOPT_USERPWD, $this->accesskey_ . \":\" . $this->secretkey_);\n        }\n\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $this->httpCode_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        $headerLines = explode(\"\\r\\n\", $header);\n        foreach ($headerLines as $line) {\n            if (strpos($line, 'HTTP/') === 0) {\n                $parts = explode(' ', $line, 3);\n                if (isset($parts[1])) {\n                    $this->httpCode_ = (int)$parts[1];\n                }\n                if (isset($parts[2])) {\n                    $this->httpDesc_ = $parts[2];\n                }\n            }\n        }\n\n        curl_close($ch);\n\n        $jsonData = json_decode($body, true);\n\n        if (json_last_error() === JSON_ERROR_NONE) {\n            return $jsonData;\n        }\n\n        return false;\n\n    }\n\n    public function setAuth(string $accesskey, string $secretkey): void\n    {\n        $this->accesskey_ = $accesskey;\n        $this->secretkey_ = $secretkey;\n    }\n\n\n    public function getHttpCode(): ?int\n    {\n        return $this->httpCode_;\n    }\n\n    public function getHttpDesc(): ?string\n    {\n        return $this->httpDesc_;\n    }\n}\n?>\n",
      "<?php\n\nclass UpgradeNoticeBehavior\n{\n    private $header_ = [];\n    private $httpCode_;\n    private $httpDesc_;\n    private $accesskey_;\n    private $secretkey_;\n\n    public function send(string $url, array $params = [], array $headers = []): mixed\n    {\n        $ch = curl_init($url);\n\n        if (!empty($params)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n        }\n\n        $headers = array_merge($this->header_, $headers);\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($this->accesskey_ && $this->secretkey_) {\n            curl_setopt($ch, CURLOPT_USERPWD, $this->accesskey_ . \":\" . $this->secretkey_);\n        }\n\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $this->httpCode_ = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        $header_lines = explode(\"\\r\\n\", $header);\n        foreach ($header_lines as $line) {\n            if (strpos($line, 'HTTP/') === 0) {\n                $parts = explode(' ', $line, 3);\n                if (isset($parts[1])) {\n                    $this->httpCode_ = (int)$parts[1];\n                }\n                if (isset($parts[2])) {\n                    $this->httpDesc_ = $parts[2];\n                }\n\n            }\n        }\n\n\n        curl_close($ch);\n\n        $json = json_decode($body, true);\n\n        if (json_last_error() === JSON_ERROR_NONE) {\n            return $json;\n        }\n\n        return false;\n\n    }\n\n    public function setAuth(string $accesskey, string $secretkey): void\n    {\n        $this->accesskey_ = $accesskey;\n        $this->secretkey_ = $secretkey;\n    }\n\n\n    public function getHttpCode(): ?int\n    {\n        return $this->httpCode_;\n    }\n\n    public function getHttpDesc(): ?string\n    {\n        return $this->httpDesc_;\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Create a PHP class that handles HTTP requests using cURL with support for custom headers, payloads, and proxy configuration.\n\nClass Description: The Meting class provides functionality to make HTTP requests using PHP's cURL library. It supports GET/POST requests, custom headers, timeout settings, retry mechanism, and proxy configuration.\n\nAttributes:\n- header: array - Stores HTTP headers to be sent with the request\n- proxy: string - Stores proxy server address if configured\n- raw: mixed - Stores the raw response from the cURL request\n- info: array - Stores cURL request information\n- error: int - Stores cURL error code if any\n- status: string - Stores cURL error message if any\n\nMethods:\n- curl(string $url, mixed $payload = null, int $headerOnly = 0) -> self - Makes an HTTP request to the specified URL with optional payload and header-only response flag. Returns the class instance for method chaining.\n  Parameters:\n    - $url: string - The target URL for the request\n    - $payload: mixed - Optional request payload (array or string)\n    - $headerOnly: int - Flag to return only headers (1) or full response (0)",
    "Canonical_solution": "namespace Sakura\\API;\n\nclass Meting\n{\n    private function curl($url, $payload = null, $headerOnly = 0)\n    {\n        $header = array_map(function ($k, $v) {\n            return $k.': '.$v;\n        }, array_keys($this->header), $this->header);\n        $curl = curl_init();\n        if (!is_null($payload)) {\n            curl_setopt($curl, CURLOPT_POST, 1);\n            curl_setopt($curl, CURLOPT_POSTFIELDS, is_array($payload) ? http_build_query($payload) : $payload);\n        }\n        curl_setopt($curl, CURLOPT_HEADER, $headerOnly);\n        curl_setopt($curl, CURLOPT_TIMEOUT, 20);\n        curl_setopt($curl, CURLOPT_ENCODING, 'gzip');\n        curl_setopt($curl, CURLOPT_IPRESOLVE, 1);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 0);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 10);\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_HTTPHEADER, $header);\n        if ($this->proxy) {\n            curl_setopt($curl, CURLOPT_PROXY, $this->proxy);\n        }\n        for ($i = 0; $i < 3; $i++) {\n            $this->raw = curl_exec($curl);\n            $this->info = curl_getinfo($curl);\n            $this->error = curl_errno($curl);\n            $this->status = $this->error ? curl_error($curl) : '';\n            if (!$this->error) {\n                break;\n            }\n        }\n        curl_close($curl);\n\n        return $this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass Meting\n{\n    public $header = [];\n    public $proxy = null;\n    public $raw;\n    public $info;\n    public $error;\n    public $status;\n\n    public function curl($url, $payload = null, $headerOnly = 0)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n        if ($headerOnly) {\n            curl_setopt($ch, CURLOPT_NOBODY, 1);\n        }\n        if ($payload) {\n            if (is_array($payload)) {\n                $payload = http_build_query($payload);\n            }\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);\n        }\n        if ($this->header) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->header);\n        }\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n        $this->raw = curl_exec($ch);\n        $this->info = curl_getinfo($ch);\n        $this->error = curl_errno($ch);\n        $this->status = curl_error($ch);\n        curl_close($ch);\n        return $this;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Meting\n{\n    public $header = [];\n    public $proxy = null;\n    public $raw;\n    public $info;\n    public $error;\n    public $status;\n\n    public function curl($url, $payload = null, $headerOnly = 0)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n        if ($headerOnly) {\n            curl_setopt($ch, CURLOPT_NOBODY, 1);\n        }\n        if ($payload) {\n            if (is_array($payload)) {\n                $payload = http_build_query($payload);\n            }\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);\n        }\n        if ($this->header) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->header);\n        }\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n        $this->raw = curl_exec($ch);\n        $this->info = curl_getinfo($ch);\n        $this->error = curl_errno($ch);\n        $this->status = curl_error($ch);\n        curl_close($ch);\n        return $this;\n    }\n}\n\n?>\n",
      "<?php\nclass Meting\n{\n    public $header = [];\n    public $proxy = null;\n    public $raw;\n    public $info;\n    public $error;\n    public $status;\n\n    public function curl($url, $payload = null, $headerOnly = 0)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n        if ($headerOnly) {\n            curl_setopt($ch, CURLOPT_NOBODY, 1);\n        }\n        if ($payload) {\n            if (is_array($payload)) {\n                curl_setopt($ch, CURLOPT_POST, 1);\n                curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($payload));\n            } else {\n                curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);\n            }\n        }\n        if (!empty($this->header)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->header);\n        }\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n        $this->raw = curl_exec($ch);\n        $this->info = curl_getinfo($ch);\n        $this->error = curl_errno($ch);\n        $this->status = curl_error($ch);\n        curl_close($ch);\n        return $this;\n    }\n}\n\n?>\n",
      "<?php\nclass Meting\n{\n    public $header = [];\n    public $proxy = null;\n    public $raw;\n    public $info;\n    public $error;\n    public $status;\n\n    public function curl($url, $payload = null, $headerOnly = 0)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n        if ($headerOnly) {\n            curl_setopt($ch, CURLOPT_NOBODY, 1);\n        }\n        if ($payload) {\n            if (is_array($payload)) {\n                $payload = http_build_query($payload);\n            }\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);\n        }\n        if (!empty($this->header)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->header);\n        }\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n        $this->raw = curl_exec($ch);\n        $this->info = curl_getinfo($ch);\n        $this->error = curl_errno($ch);\n        $this->status = curl_error($ch);\n        curl_close($ch);\n        return $this;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Meting\n{\n    public $header = [];\n    public $proxy = null;\n    public $raw;\n    public $info;\n    public $error;\n    public $status;\n\n    public function curl($url, $payload = null, $headerOnly = 0)\n    {\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_HEADER, 1);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($curl, CURLOPT_TIMEOUT, 10);\n        if ($payload) {\n            if (is_array($payload)) {\n                $payload = http_build_query($payload);\n            }\n            curl_setopt($curl, CURLOPT_POST, 1);\n            curl_setopt($curl, CURLOPT_POSTFIELDS, $payload);\n        }\n        if ($headerOnly) {\n            curl_setopt($curl, CURLOPT_NOBODY, 1);\n        }\n        if ($this->header) {\n            curl_setopt($curl, CURLOPT_HTTPHEADER, $this->header);\n        }\n        if ($this->proxy) {\n            curl_setopt($curl, CURLOPT_PROXY, $this->proxy);\n        }\n        $this->raw = curl_exec($curl);\n        $this->info = curl_getinfo($curl);\n        $this->error = curl_errno($curl);\n        $this->status = curl_error($curl);\n        curl_close($curl);\n        return $this;\n    }\n}\n\n?>\n",
      "<?php\nclass Meting\n{\n    public $header = [];\n    public $proxy = null;\n    public $raw;\n    public $info;\n    public $error;\n    public $status;\n\n    public function curl($url, $payload = null, $headerOnly = 0)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n        if ($headerOnly) {\n            curl_setopt($ch, CURLOPT_NOBODY, 1);\n        }\n        if ($payload) {\n            if (is_array($payload)) {\n                $payload = http_build_query($payload);\n            }\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);\n        }\n        if (!empty($this->header)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->header);\n        }\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n        $this->raw = curl_exec($ch);\n        $this->info = curl_getinfo($ch);\n        $this->error = curl_errno($ch);\n        $this->status = curl_error($ch);\n        curl_close($ch);\n        return $this;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Meting\n{\n    public $header = [];\n    public $proxy = null;\n    public $raw;\n    public $info;\n    public $error;\n    public $status;\n\n    public function curl($url, $payload = null, $headerOnly = 0)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n        if ($headerOnly) {\n            curl_setopt($ch, CURLOPT_NOBODY, 1);\n        }\n        if ($payload) {\n            if (is_array($payload)) {\n                $payload = http_build_query($payload);\n            }\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);\n        }\n        if (!empty($this->header)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->header);\n        }\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n        $this->raw = curl_exec($ch);\n        $this->info = curl_getinfo($ch);\n        $this->error = curl_errno($ch);\n        $this->status = curl_error($ch);\n        curl_close($ch);\n        return $this;\n    }\n}\n\n?>\n",
      "<?php\nclass Meting\n{\n    public $header = [];\n    public $proxy = null;\n    public $raw;\n    public $info;\n    public $error;\n    public $status;\n\n    public function curl($url, $payload = null, $headerOnly = 0)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n        if ($payload) {\n            if (is_array($payload)) {\n                $payload = http_build_query($payload);\n            }\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);\n        }\n        if ($headerOnly) {\n            curl_setopt($ch, CURLOPT_NOBODY, 1);\n        }\n        if ($this->header) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->header);\n        }\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n        $this->raw = curl_exec($ch);\n        $this->info = curl_getinfo($ch);\n        $this->error = curl_errno($ch);\n        $this->status = curl_error($ch);\n\n        curl_close($ch);\n        return $this;\n    }\n}\n\n?>\n",
      "<?php\nclass Meting\n{\n    public $header = [];\n    public $proxy = null;\n    public $raw;\n    public $info;\n    public $error;\n    public $status;\n\n    public function curl($url, $payload = null, $headerOnly = 0)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n        if ($headerOnly) {\n            curl_setopt($ch, CURLOPT_NOBODY, 1);\n        }\n        if ($payload) {\n            if (is_array($payload)) {\n                $payload = http_build_query($payload);\n            }\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);\n        }\n        if (!empty($this->header)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->header);\n        }\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n        $this->raw = curl_exec($ch);\n        $this->info = curl_getinfo($ch);\n        $this->error = curl_errno($ch);\n        $this->status = curl_error($ch);\n        curl_close($ch);\n        return $this;\n    }\n}\n\n?>\n",
      "<?php\nclass Meting\n{\n    public $header = [];\n    public $proxy = null;\n    public $raw;\n    public $info;\n    public $error;\n    public $status;\n\n    public function curl($url, $payload = null, $headerOnly = 0)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n        if ($headerOnly) {\n            curl_setopt($ch, CURLOPT_NOBODY, 1);\n        }\n        if ($payload) {\n            if (is_array($payload)) {\n                $payload = http_build_query($payload);\n            }\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);\n        }\n        if (!empty($this->header)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->header);\n        }\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n        $this->raw = curl_exec($ch);\n        $this->info = curl_getinfo($ch);\n        $this->error = curl_errno($ch);\n        $this->status = curl_error($ch);\n        curl_close($ch);\n        return $this;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a PHP class for handling HTTP requests to interact with WeChat Pay API, supporting both GET and POST methods with proper SSL configuration.\n\nClass Description: The Wechatpay class provides methods for making HTTP requests to WeChat Pay API endpoints. It handles both GET and POST requests, with special consideration for HTTPS connections and SSL configuration. The class includes error handling through HTTP status codes.\n\nMethods:\n\nMethod1: http_get(string $url) -> string|false - Performs a GET request to the specified URL. Returns the response content if successful (HTTP 200), or false otherwise.\nMethod2: http_post(string $url, array $param, bool $post_file=false) -> string|false - Performs a POST request to the specified URL with given parameters. Handles both regular form data and file uploads. Returns the response content if successful (HTTP 200), or false otherwise.",
    "Canonical_solution": "class Wechatpay\n{\n    /**\n     * GET 请求\n     * @param string $url\n     */\n    private function http_get($url){\n        $oCurl = curl_init();\n        if(stripos($url,\"https://\")!==FALSE){\n            curl_setopt($oCurl, CURLOPT_SSL_VERIFYPEER, FALSE);\n            curl_setopt($oCurl, CURLOPT_SSL_VERIFYHOST, FALSE);\n            curl_setopt($oCurl, CURLOPT_SSLVERSION, 1); //CURL_SSLVERSION_TLSv1\n        }\n        curl_setopt($oCurl, CURLOPT_URL, $url);\n        curl_setopt($oCurl, CURLOPT_RETURNTRANSFER, 1 );\n        $sContent = curl_exec($oCurl);\n        $aStatus = curl_getinfo($oCurl);\n        curl_close($oCurl);\n        if(intval($aStatus[\"http_code\"])==200){\n            return $sContent;\n        }else{\n            return false;\n        }\n    }\n\n    /**\n     * POST 请求\n     * @param string $url\n     * @param array $param\n     * @param boolean $post_file 是否文件上传\n     * @return string content\n     */\n    private function http_post($url,$param,$post_file=false){\n        $oCurl = curl_init();\n        if(stripos($url,\"https://\")!==FALSE){\n            curl_setopt($oCurl, CURLOPT_SSL_VERIFYPEER, FALSE);\n            curl_setopt($oCurl, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($oCurl, CURLOPT_SSLVERSION, 1); //CURL_SSLVERSION_TLSv1\n        }\n        if (is_string($param) || $post_file) {\n            $strPOST = $param;\n        } else {\n            $aPOST = array();\n            foreach($param as $key=>$val){\n                $aPOST[] = $key.\"=\".urlencode($val);\n            }\n            $strPOST =  join(\"&\", $aPOST);\n        }\n        curl_setopt($oCurl, CURLOPT_URL, $url);\n        curl_setopt($oCurl, CURLOPT_RETURNTRANSFER, 1 );\n        curl_setopt($oCurl, CURLOPT_POST,true);\n        curl_setopt($oCurl, CURLOPT_POSTFIELDS,$strPOST);\n        $sContent = curl_exec($oCurl);\n        $aStatus = curl_getinfo($oCurl);\n        curl_close($oCurl);\n        if(intval($aStatus[\"http_code\"])==200){\n            return $sContent;\n        }else{\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Wechatpay\n{\n    public function http_get($url)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return $httpCode === 200 ? $response : false;\n    }\n\n    public function http_post($url, $param, $post_file = false)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"POST\",\n            CURLOPT_POSTFIELDS => $post_file ? $param : http_build_query($param),\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n        if ($post_file) {\n            curl_setopt($curl, CURLOPT_HTTPHEADER, array(\"Content-Type: multipart/form-data\"));\n        }\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n\n        curl_close($curl);\n\n        return $httpCode === 200 ? $response : false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Wechatpay\n{\n    public function http_get($url)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n\n    public function http_post($url, $param, $post_file = false)\n    {\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n\n        if ($post_file) {\n            curl_setopt($curl, CURLOPT_POST, true);\n            curl_setopt($curl, CURLOPT_POSTFIELDS, $param);\n        } else {\n            curl_setopt($curl, CURLOPT_POST, true);\n            curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($param));\n        }\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n}\n\n?>\n",
      "<?php\nclass Wechatpay {\n\n    public function http_get($url) {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n\n\n    public function http_post($url, $param, $post_file = false) {\n        $curl = curl_init();\n        if ($post_file) {\n            curl_setopt($curl, CURLOPT_SAFE_UPLOAD, true);\n            $fields = $param;\n        } else {\n            $fields = http_build_query($param);\n        }\n\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"POST\",\n            CURLOPT_POSTFIELDS => $fields,\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n}\n?>\n",
      "<?php\n\nclass Wechatpay\n{\n    public function http_get($url)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n\n    public function http_post($url, $param, $post_file = false)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"POST\",\n            CURLOPT_POSTFIELDS => $post_file ? $param : http_build_query($param),\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n            CURLOPT_HTTPHEADER => $post_file ? array(\"Content-Type: multipart/form-data\") : array(),\n        ));\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Wechatpay\n{\n    public function http_get($url)\n    {\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        if ($httpCode == 200) {\n            return $response;\n        } else {\n            return false;\n        }\n    }\n\n    public function http_post($url, $param, $post_file = false)\n    {\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        if ($post_file) {\n            curl_setopt($curl, CURLOPT_POSTFIELDS, $param);\n        } else {\n            curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($param));\n        }\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        if ($httpCode == 200) {\n            return $response;\n        } else {\n            return false;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass Wechatpay\n{\n    public function http_get($url)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n\n    public function http_post($url, $param, $post_file = false)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"POST\",\n            CURLOPT_POSTFIELDS => $post_file ? $param : http_build_query($param),\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n        if ($post_file) {\n            curl_setopt($curl, CURLOPT_SAFE_UPLOAD, false);\n        }\n\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Wechatpay\n{\n    public function http_get($url)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return $httpCode === 200 ? $response : false;\n    }\n\n    public function http_post($url, $param, $post_file = false)\n    {\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n\n        if ($post_file) {\n            curl_setopt($curl, CURLOPT_POST, true);\n            curl_setopt($curl, CURLOPT_POSTFIELDS, $param);\n        } else {\n            curl_setopt($curl, CURLOPT_POST, true);\n            curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($param));\n        }\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return $httpCode === 200 ? $response : false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Wechatpay\n{\n    public function http_get($url)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n\n    public function http_post($url, $param, $post_file = false)\n    {\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n\n        if ($post_file) {\n            curl_setopt($curl, CURLOPT_POST, true);\n            curl_setopt($curl, CURLOPT_POSTFIELDS, $param);\n        } else {\n            curl_setopt($curl, CURLOPT_POST, true);\n            curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($param));\n        }\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Wechatpay\n{\n    public function http_get($url)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n\n    public function http_post($url, $param, $post_file = false)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"POST\",\n            CURLOPT_POSTFIELDS => $post_file ? $param : http_build_query($param),\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n        if ($post_file) {\n            curl_setopt($curl, CURLOPT_HTTPHEADER, array(\"Content-Type: multipart/form-data\"));\n        }\n\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n\n        curl_close($curl);\n\n        return ($httpCode === 200) ? $response : false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Wechatpay\n{\n    public function http_get($url)\n    {\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_SSL_VERIFYPEER => true,\n            CURLOPT_SSL_VERIFYHOST => 2,\n        ));\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return $httpCode === 200 ? $response : false;\n    }\n\n    public function http_post($url, $param, $post_file = false)\n    {\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n\n        if ($post_file) {\n            curl_setopt($curl, CURLOPT_POST, true);\n            curl_setopt($curl, CURLOPT_POSTFIELDS, $param);\n        } else {\n            curl_setopt($curl, CURLOPT_POST, true);\n            curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($param));\n        }\n\n        $response = curl_exec($curl);\n        $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n\n        return $httpCode === 200 ? $response : false;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using Guzzle library to download files and fetch GitHub release information.\n\nClass Description: The HttpClient class provides methods for downloading remote files via HTTP and retrieving GitHub release information (both stable and pre-release) using the Guzzle HTTP client library.\n\nAttributes:\n- client: [Client] - Guzzle HTTP client instance used for making requests\n\nMethods:\n- __construct() -> [void] - Initializes the Guzzle HTTP client instance\n- getSourceFile(string $fileName, string $savePath, string $url) -> [bool] - Downloads a file from the specified URL and saves it to the given path\n- getLatestReleaseTagName(string $repo) -> [string] - Gets the latest stable release tag name from a GitHub repository\n- getLatestPreReleaseTagName(string $repo) -> [string] - Gets the latest pre-release tag name from a GitHub repository",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    /**\n     * Download remote file via HTTP\n     *\n     * @param string $fileName\n     * @param string $savePath\n     * @param string $url\n     * @return bool\n     */\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            if (! file_exists($savePath)) {\n                echo '目标文件夹 ' . $savePath . ' 不存在，下載失败。' . PHP_EOL;\n                return false;\n            }\n\n            echo '- 开始下载 ' . $fileName . '...' . PHP_EOL;\n            $request = $this->client->get($url);\n            echo '- 下载 ' . $fileName . ' 成功，正在保存...' . PHP_EOL;\n            $result = file_put_contents($savePath . $fileName, $request->getBody()->getContents());\n\n            if (! $result) {\n                echo '- 保存 ' . $fileName . ' 至 ' . $savePath . ' 失败。' . PHP_EOL;\n            } else {\n                echo '- 保存 ' . $fileName . ' 至 ' . $savePath . ' 成功。' . PHP_EOL;\n            }\n\n            return true;\n        } catch (GuzzleException $e) {\n            echo '- 下载 ' . $fileName . ' 失败...' . PHP_EOL;\n            echo $e->getMessage() . PHP_EOL;\n\n            return false;\n        }\n    }\n\n    /**\n     * Get latest GitHub release tag\n     *\n     * @param string $repo\n     * @return string\n     * @throws GuzzleException\n     */\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        $url = 'https://api.github.com/repos/' . $repo . '/releases/latest' .\n            ($_ENV['github_access_token'] !== '' ? '?access_token=' . $_ENV['github_access_token'] : '');\n        $request = $this->client->get($url);\n\n        return json_decode(\n            $request->getBody()->getContents(),\n            true\n        )['tag_name'];\n    }\n\n    /**\n     * Get latest GitHub pre-release tag\n     *\n     * @param string $repo\n     * @return string\n     * @throws GuzzleException\n     */\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        $url = 'https://api.github.com/repos/' . $repo . '/releases' .\n            ($_ENV['github_access_token'] !== '' ? '?access_token=' . $_ENV['github_access_token'] : '');\n        $request = $this->client->get($url);\n        $latest = json_decode(\n            $request->getBody()->getContents(),\n            true\n        )[0];\n\n        return $latest['tag_name'];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url, ['sink' => $savePath . $fileName]);\n            return $response->getStatusCode() === 200;\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, false);\n    }\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, true);\n    }\n\n\n    private function getReleaseTagName(string $repo, bool $preRelease): string\n    {\n        $url = \"https://api.github.com/repos/{$repo}/releases\";\n\n        try {\n            $response = $this->client->get($url);\n            $releases = json_decode($response->getBody(), true);\n\n            if ($preRelease) {\n                foreach ($releases as $release) {\n                    if ($release['prerelease']) {\n                        return $release['tag_name'];\n                    }\n                }\n            } else {\n                foreach ($releases as $release) {\n                    if (!$release['prerelease']) {\n                        return $release['tag_name'];\n                    }\n                }\n            }\n\n        } catch (GuzzleException $e) {\n            return '';\n        }\n\n        return '';\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url, ['sink' => $savePath . $fileName]);\n            return $response->getStatusCode() === 200;\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, false);\n    }\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, true);\n    }\n\n\n    private function getReleaseTagName(string $repo, bool $preRelease): string\n    {\n        try {\n            $url = \"https://api.github.com/repos/{$repo}/releases\";\n            $response = $this->client->get($url);\n\n            if ($response->getStatusCode() !== 200) {\n                return '';\n            }\n\n            $releases = json_decode($response->getBody(), true);\n\n            if (empty($releases)) {\n                return '';\n            }\n\n\n            foreach ($releases as $release) {\n                if ($release['prerelease'] === $preRelease) {\n                    return $release['tag_name'];\n                }\n            }\n\n            return '';\n\n\n        } catch (GuzzleException $e) {\n            return '';\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url);\n            $fileContent = $response->getBody()->getContents();\n            file_put_contents($savePath . '/' . $fileName, $fileContent);\n            return true;\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        $url = \"https://api.github.com/repos/{$repo}/releases/latest\";\n        try {\n            $response = $this->client->get($url);\n            $releaseData = json_decode($response->getBody(), true);\n            return $releaseData['tag_name'] ?? '';\n        } catch (GuzzleException $e) {\n            return '';\n        }\n    }\n\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        $url = \"https://api.github.com/repos/{$repo}/releases\";\n        try {\n            $response = $this->client->get($url);\n            $releases = json_decode($response->getBody(), true);\n\n            foreach ($releases as $release) {\n                if ($release['prerelease']) {\n                    return $release['tag_name'];\n                }\n            }\n            return '';\n\n        } catch (GuzzleException $e) {\n            return '';\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url, ['sink' => $savePath . $fileName]);\n            return $response->getStatusCode() === 200;\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, false);\n    }\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, true);\n    }\n\n\n    private function getReleaseTagName(string $repo, bool $preRelease): string\n    {\n        try {\n            $url = \"https://api.github.com/repos/{$repo}/releases\";\n            $response = $this->client->get($url);\n\n            if ($response->getStatusCode() !== 200) {\n                return '';\n            }\n\n            $releases = json_decode($response->getBody(), true);\n\n            if (empty($releases)) {\n                return '';\n            }\n\n\n            foreach ($releases as $release) {\n                if ($release['prerelease'] === $preRelease) {\n                    return $release['tag_name'];\n                }\n            }\n\n            return '';\n\n        } catch (GuzzleException $e) {\n            return '';\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url, ['sink' => $savePath . $fileName]);\n            return $response->getStatusCode() === 200;\n        } catch (\\Exception $e) {\n            return false;\n        }\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        $url = \"https://api.github.com/repos/{$repo}/releases/latest\";\n        try {\n            $response = $this->client->get($url);\n            $data = json_decode($response->getBody(), true);\n            return $data['tag_name'] ?? '';\n        } catch (\\Exception $e) {\n            return '';\n        }\n    }\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        $url = \"https://api.github.com/repos/{$repo}/releases\";\n        try {\n            $response = $this->client->get($url);\n            $releases = json_decode($response->getBody(), true);\n\n            foreach ($releases as $release) {\n                if ($release['prerelease']) {\n                    return $release['tag_name'];\n                }\n            }\n            return '';\n\n        } catch (\\Exception $e) {\n            return '';\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url, ['sink' => $savePath . $fileName]);\n            return $response->getStatusCode() === 200;\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, false);\n    }\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, true);\n    }\n\n\n    private function getReleaseTagName(string $repo, bool $preRelease): string\n    {\n        try {\n            $url = \"https://api.github.com/repos/{$repo}/releases\";\n            $response = $this->client->get($url);\n\n            if ($response->getStatusCode() !== 200) {\n                return '';\n            }\n\n            $releases = json_decode($response->getBody(), true);\n\n            if (empty($releases)) {\n                return '';\n            }\n\n            foreach ($releases as $release) {\n                if ($release['prerelease'] === $preRelease) {\n                    return $release['tag_name'];\n                }\n            }\n\n            return '';\n\n        } catch (GuzzleException $e) {\n            return '';\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url);\n            $fileContent = $response->getBody()->getContents();\n            file_put_contents($savePath . '/' . $fileName, $fileContent);\n            return true;\n        } catch (\\Exception $e) {\n            return false;\n        }\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        $url = \"https://api.github.com/repos/{$repo}/releases/latest\";\n        try {\n            $response = $this->client->get($url);\n            $data = json_decode($response->getBody()->getContents(), true);\n            return $data['tag_name'] ?? '';\n        } catch (\\Exception $e) {\n            return '';\n        }\n    }\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        $url = \"https://api.github.com/repos/{$repo}/releases\";\n        try {\n            $response = $this->client->get($url);\n            $releases = json_decode($response->getBody()->getContents(), true);\n\n            foreach ($releases as $release) {\n                if ($release['prerelease']) {\n                    return $release['tag_name'];\n                }\n            }\n            return '';\n\n        } catch (\\Exception $e) {\n            return '';\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url);\n            $fileContent = $response->getBody()->getContents();\n            file_put_contents($savePath . '/' . $fileName, $fileContent);\n            return true;\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        $url = \"https://api.github.com/repos/{$repo}/releases/latest\";\n        try {\n            $response = $this->client->get($url);\n            $releaseData = json_decode($response->getBody(), true);\n            return $releaseData['tag_name'] ?? '';\n        } catch (GuzzleException $e) {\n            return '';\n        }\n    }\n\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        $url = \"https://api.github.com/repos/{$repo}/releases\";\n        try {\n            $response = $this->client->get($url);\n            $releases = json_decode($response->getBody(), true);\n\n            foreach ($releases as $release) {\n                if ($release['prerelease']) {\n                    return $release['tag_name'];\n                }\n            }\n            return '';\n\n        } catch (GuzzleException $e) {\n            return '';\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url, ['sink' => $savePath . $fileName]);\n            return $response->getStatusCode() === 200;\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, false);\n    }\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, true);\n    }\n\n\n    private function getReleaseTagName(string $repo, bool $preRelease): string\n    {\n        try {\n            $url = \"https://api.github.com/repos/{$repo}/releases\";\n            $response = $this->client->get($url);\n\n            if ($response->getStatusCode() !== 200) {\n                return '';\n            }\n\n            $releases = json_decode($response->getBody(), true);\n\n            if (empty($releases)) {\n                return '';\n            }\n\n            foreach ($releases as $release) {\n                if ($release['prerelease'] === $preRelease) {\n                    return $release['tag_name'];\n                }\n            }\n\n            return '';\n\n        } catch (GuzzleException $e) {\n            return '';\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url, ['sink' => $savePath . $fileName]);\n            return $response->getStatusCode() === 200;\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, false);\n    }\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        return $this->getReleaseTagName($repo, true);\n    }\n\n\n    private function getReleaseTagName(string $repo, bool $preRelease): string\n    {\n        $url = \"https://api.github.com/repos/{$repo}/releases\";\n\n        try {\n            $response = $this->client->get($url);\n            $releases = json_decode($response->getBody(), true);\n\n            if ($preRelease) {\n                foreach ($releases as $release) {\n                    if ($release['prerelease']) {\n                        return $release['tag_name'];\n                    }\n                }\n            } else {\n                foreach ($releases as $release) {\n                    if (!$release['prerelease']) {\n                        return $release['tag_name'];\n                    }\n                }\n            }\n\n        } catch (GuzzleException $e) {\n            return '';\n        }\n\n        return '';\n    }\n}\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a PHP function that sends a POST request to a specified URL with given data using cURL and returns the response.\n\nFunction Description: The function initializes a cURL session, configures it for a POST request with the provided URL and data, sets various options including timeouts and SSL verification settings, executes the request, and returns the response. It handles the entire lifecycle of the cURL session from initialization to cleanup.\n\nInput:\n- $url (string): The target URL to which the POST request will be sent\n- $data (mixed): The data to be sent with the POST request (can be an array or string)\n\nOutput:\n- Returns the response from the server as a string if the request is successful\n- Returns false if the request fails (though error handling could be enhanced in a production environment)",
    "Canonical_solution": "function post2url($url, $data) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction sendPostRequest($url, $data) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    if (is_array($data)) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data));\n    } else {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // For testing purposes only. Disable in production.\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // For testing purposes only. Disable in production.\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction sendPostRequest($url, $data) {\n    $ch = curl_init($url);\n    if ($ch === false) {\n        return false;\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    if (is_array($data)) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data));\n    } else {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // Disable for testing, enable in production\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // Disable for testing, enable in production\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction sendPostRequest($url, $data) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    if (is_array($data)) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data));\n    } else {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // For testing purposes only. Disable in production.\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // For testing purposes only. Disable in production.\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction sendPostRequest($url, $data) {\n    $ch = curl_init($url);\n    if ($ch === false) {\n        return false;\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    if (is_array($data)) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data));\n    } else {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // For testing purposes only. Disable in production.\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // For testing purposes only. Disable in production.\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction sendPostRequest($url, $data) {\n    $ch = curl_init($url);\n    if ($ch === false) {\n        return false;\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    if (is_array($data)) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data));\n    } else {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // Disable for testing, enable in production\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // Disable for testing, enable in production\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction sendPostRequest($url, $data) {\n    $ch = curl_init($url);\n    if ($ch === false) {\n        return false;\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    if (is_array($data)) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data));\n    } else {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // For testing purposes only. Disable in production.\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // For testing purposes only. Disable in production.\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction sendPostRequest($url, $data) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    if (is_array($data)) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data));\n    } else {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // Disable for testing, enable in production\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // Disable for testing, enable in production\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction sendPostRequest($url, $data) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    if (is_array($data)) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data));\n    } else {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // For testing purposes only. Disable in production.\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // For testing purposes only. Disable in production.\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction sendPostRequest($url, $data) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    if (is_array($data)) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data));\n    } else {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // For testing purposes only. Disable in production.\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // For testing purposes only. Disable in production.\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction sendPostRequest($url, $data) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    if (is_array($data)) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data));\n    } else {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // For testing purposes only. Disable in production.\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // For testing purposes only. Disable in production.\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a class that handles file downloads using cURL in PHP, with support for temporary file management and cleanup.\n\nClass Description: The CurlDownloader class provides functionality to download files from a given URL using cURL, storing them in a temporary directory, and managing the downloaded files' lifecycle.\n\nAttributes:\n- tempDir: string - The directory path where temporary files will be stored. Defaults to system temp directory if not specified.\n- outputFile: string - The path to the downloaded file.\n\nMethods:\n- setTempDir(string $tempDir) -> void - Sets the temporary directory for storing downloaded files.\n- download(string $url) -> bool - Downloads a file from the specified URL using cURL. Returns true on success, throws ErrorException on failure.\n- getFilename() -> string - Returns the path to the downloaded file.\n- cleanup() -> void - Removes the downloaded file if it exists.\n\nInput:\n- For setTempDir(): A string representing the directory path.\n- For download(): A string representing the URL to download from.\n\nOutput:\n- For download(): A boolean indicating success (true) or failure (false).\n- For getFilename(): A string representing the path to the downloaded file.\n- Other methods do not return values.",
    "Canonical_solution": "use Psy\\Exception\\ErrorException;\nuse Psy\\Shell;\n\nclass CurlDownloader implements Downloader\n{\n    private $tempDir = null;\n    private $outputFile = null;\n\n    public function setTempDir(string $tempDir)\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?: \\sys_get_temp_dir();\n        $this->outputFile = \\tempnam($tempDir, 'psysh-archive-');\n        $targetName = $this->outputFile.'.tar.gz';\n\n        if (!\\rename($this->outputFile, $targetName)) {\n            return false;\n        }\n\n        $this->outputFile = $targetName;\n\n        $outputHandle = \\fopen($this->outputFile, 'w');\n        if (!$outputHandle) {\n            return false;\n        }\n        $curl = \\curl_init();\n        \\curl_setopt_array($curl, [\n            \\CURLOPT_FAILONERROR    => true,\n            \\CURLOPT_HEADER         => 0,\n            \\CURLOPT_FOLLOWLOCATION => true,\n            \\CURLOPT_TIMEOUT        => 10,\n            \\CURLOPT_FILE           => $outputHandle,\n            \\CURLOPT_HTTPHEADER     => [\n                'User-Agent' => 'PsySH/'.Shell::VERSION,\n            ],\n        ]);\n        \\curl_setopt($curl, \\CURLOPT_URL, $url);\n        $result = \\curl_exec($curl);\n        $error = \\curl_error($curl);\n        \\curl_close($curl);\n\n        \\fclose($outputHandle);\n\n        if (!$result) {\n            throw new ErrorException('cURL Error: '.$error);\n        }\n\n        return (bool) $result;\n    }\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup()\n    {\n        if (\\file_exists($this->outputFile)) {\n            \\unlink($this->outputFile);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct(?string $tempDir = null)\n    {\n        $this->tempDir = $tempDir ?? sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n        fclose($fp);\n\n\n        if (!$success) {\n            $this->cleanup();\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct(?string $tempDir = null)\n    {\n        $this->tempDir = $tempDir ?? sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_');\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n        fclose($fp);\n\n\n        if (!$success) {\n            $this->cleanup();\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct(?string $tempDir = null)\n    {\n        $this->tempDir = $tempDir ?? sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . DIRECTORY_SEPARATOR . uniqid('download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        if (!$ch) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(\"Failed to initialize cURL.\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            fclose($fp);\n            unlink($this->outputFile);\n            curl_close($ch);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct(?string $tempDir = null)\n    {\n        $this->tempDir = $tempDir ?? sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        if (!$ch) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(\"Failed to initialize cURL.\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n        $error = curl_error($ch);\n\n        curl_close($ch);\n        fclose($fp);\n\n        if ($result === false) {\n            unlink($this->outputFile);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        return true;\n    }\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct(?string $tempDir = null)\n    {\n        $this->tempDir = $tempDir ?? sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . DIRECTORY_SEPARATOR . uniqid('download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n        fclose($fp);\n\n\n        if (!$success) {\n            $this->cleanup();\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct(?string $tempDir = null)\n    {\n        $this->tempDir = $tempDir ?? sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Failed to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n        fclose($fp);\n\n\n        if (!$success) {\n            $this->cleanup();\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct(?string $tempDir = null)\n    {\n        $this->tempDir = $tempDir ?? sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_');\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n        fclose($fp);\n\n        if (!$success) {\n            $this->cleanup();\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct(?string $tempDir = null)\n    {\n        $this->tempDir = $tempDir ?? sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Failed to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n        fclose($fp);\n\n\n        if (!$success) {\n            $this->cleanup();\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct(?string $tempDir = null)\n    {\n        $this->tempDir = $tempDir ?? sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_');\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n\n        if ($success === false) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(curl_error($ch));\n        }\n\n        fclose($fp);\n        curl_close($ch);\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader {\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct(?string $tempDir = null) {\n        $this->tempDir = $tempDir ?? sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool {\n        $this->outputFile = $this->tempDir . DIRECTORY_SEPARATOR . uniqid('download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Failed to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n        fclose($fp);\n\n        if (!$success) {\n            $this->cleanup();\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        return true;\n    }\n\n\n    public function getFilename(): string {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a Qiniu storage client class in PHP that handles HTTP requests to Qiniu's cloud storage service, including file uploads, downloads, and management operations.\n\nClass Description: QiniuStorage is a client class for interacting with Qiniu's cloud storage service. It provides methods for making HTTP requests to Qiniu's API endpoints with proper headers and request handling.\n\nAttributes:\n- QINIU_RSF_HOST: string - Qiniu's RSF (Resource List) API host\n- QINIU_RS_HOST: string - Qiniu's RS (Resource Management) API host  \n- QINIU_UP_HOST: string - Qiniu's file upload API host\n- timeout: string - Request timeout duration\n- error: string - Last error message\n- errorStr: string - Detailed error information\n\nMethods:\n- request(string $path, string $method, array|null $headers = null, mixed $body = null) -> mixed - Makes an HTTP request to Qiniu's API. Handles request setup, execution, and response processing.\n- response(string $text) -> array - Processes the response text and extracts JSON data from headers.\n- error(string $header, string $body) -> void - Handles error responses by parsing status codes and error messages.\n\nInput Parameters for request():\n- $path: string - The API endpoint path\n- $method: string - HTTP method (GET, POST, PUT, HEAD)\n- $headers: array|null - Optional request headers\n- $body: mixed - Request payload (can be string or resource)\n\nOutput for request():\n- Returns response body for successful GET requests\n- Returns parsed response array for other successful requests  \n- Returns false on failure and sets error information\n\nInput Parameters for response():\n- $text: string - Raw response text with headers\n\nOutput for response():\n- array - Parsed JSON data from response\n\nInput Parameters for error():\n- $header: string - Response header\n- $body: string - Response body\n\nOutput for error():\n- void - Sets error and errorStr properties",
    "Canonical_solution": "namespace Think\\Upload\\Driver\\Qiniu;\n\nclass QiniuStorage\n{\n    public $QINIU_RSF_HOST = 'http://rsf.qbox.me';\n    public $QINIU_RS_HOST = 'http://rs.qbox.me';\n    public $QINIU_UP_HOST = 'http://up.qiniu.com';\n    public $timeout = '';\n\n    private function request($path, $method, $headers = null, $body = null)\n    {\n        $ch = curl_init($path);\n\n        $_headers = array('Expect:');\n        if (!is_null($headers) && is_array($headers)) {\n            foreach ($headers as $k => $v) {\n                array_push($_headers, \"{$k}: {$v}\");\n            }\n        }\n\n        $length = 0;\n        $date = gmdate('D, d M Y H:i:s \\G\\M\\T');\n\n        if (!is_null($body)) {\n            if (is_resource($body)) {\n                fseek($body, 0, SEEK_END);\n                $length = ftell($body);\n                fseek($body, 0);\n\n                array_push($_headers, \"Content-Length: {$length}\");\n                curl_setopt($ch, CURLOPT_INFILE, $body);\n                curl_setopt($ch, CURLOPT_INFILESIZE, $length);\n            } else {\n                $length = @strlen($body);\n                array_push($_headers, \"Content-Length: {$length}\");\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $body);\n            }\n        } else {\n            array_push($_headers, \"Content-Length: {$length}\");\n        }\n\n        array_push($_headers, \"Date: {$date}\");\n\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $_headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 0);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n\n        if ('PUT' == $method || 'POST' == $method) {\n            curl_setopt($ch, CURLOPT_POST, 1);\n        } else {\n            curl_setopt($ch, CURLOPT_POST, 0);\n        }\n\n        if ('HEAD' == $method) {\n            curl_setopt($ch, CURLOPT_NOBODY, true);\n        }\n\n        $response = curl_exec($ch);\n        $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (200 == $status) {\n            if ('GET' == $method) {\n                return $body;\n            } else {\n                return $this->response($response);\n            }\n        } else {\n            $this->error($header, $body);\n            return false;\n        }\n    }\n\n    private function response($text)\n    {\n        $headers = explode(PHP_EOL, $text);\n        $items = array();\n        foreach ($headers as $header) {\n            $header = trim($header);\n            if (strpos($header, '{') !== false) {\n                $items = json_decode($header, 1);\n                break;\n            }\n        }\n        return $items;\n    }\n\n    private function error($header, $body)\n    {\n        list($status, $stash) = explode(\"\\r\\n\", $header, 2);\n        list($v, $code, $message) = explode(\" \", $status, 3);\n        $message = is_null($message) ? 'File Not Found' : \"[{$status}]:{$message}]\";\n        $this->error = $message;\n        $this->errorStr = json_decode($body, 1);\n        $this->errorStr = $this->errorStr['error'];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass QiniuStorage\n{\n    const QINIU_RSF_HOST = 'rsf.qbox.me';\n    const QINIU_RS_HOST = 'rs.qbox.me';\n    const QINIU_UP_HOST = 'up.qiniup.com';\n\n    public $timeout = '60s';\n    public $error;\n    public $errorStr;\n\n    public function request($path, $method, $headers = null, $body = null)\n    {\n        $url = $path;\n        $headers = $headers ?: [];\n        $headers['User-Agent'] = 'QiniuPHP/7.2.27';\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->formatHeaders($headers));\n        if ($body) {\n            if (is_resource($body)) {\n                curl_setopt($ch, CURLOPT_INFILE, $body);\n                curl_setopt($ch, CURLOPT_INFILESIZE, fstat($body)['size']);\n            } else {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $body);\n            }\n        }\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        $ret = curl_exec($ch);\n        $err = curl_error($ch);\n        $code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $responseHeader = substr($ret, 0, $headerSize);\n        $responseBody = substr($ret, $headerSize);\n        curl_close($ch);\n\n        if ($err) {\n            $this->error = $err;\n            $this->errorStr = $err;\n            return false;\n        }\n\n        if ($code >= 200 && $code < 300) {\n            if ($method === 'GET') {\n                return $responseBody;\n            }\n            return $this->response($responseHeader . \"\\r\\n\\r\\n\" . $responseBody);\n        }\n\n        $this->error($responseHeader, $responseBody);\n        return false;\n    }\n\n    private function formatHeaders($headers)\n    {\n        $formattedHeaders = [];\n        foreach ($headers as $key => $value) {\n            $formattedHeaders[] = $key . ': ' . $value;\n        }\n        return $formattedHeaders;\n    }\n\n\n    public function response($text)\n    {\n        $headers = [];\n        $headerLines = explode(\"\\r\\n\", $text);\n\n        $body = array_pop($headerLines);\n        foreach ($headerLines as $headerLine) {\n            if (strpos($headerLine, ': ') !== false) {\n                list($key, $value) = explode(': ', $headerLine);\n                $headers[$key] = $value;\n            }\n        }\n        $data = json_decode($body, true);\n        return $data ?: [];\n    }\n\n    public function error($header, $body)\n    {\n        list($status, $statusText) = explode(\"\\r\\n\", $header, 2);\n        preg_match('/HTTP\\/1\\.1 (\\d+) (\\w+)/', $status, $matches);\n        $this->error = $matches[1];\n        $this->errorStr = $body;\n    }\n}\n\n?>\n",
      "<?php\nclass QiniuStorage\n{\n    const QINIU_RSF_HOST = 'rsf.qbox.me';\n    const QINIU_RS_HOST = 'rs.qbox.me';\n    const QINIU_UP_HOST = 'up.qiniup.com';\n\n    public $timeout = '60s';\n    public $error;\n    public $errorStr;\n\n    public function request($path, $method, $headers = null, $body = null)\n    {\n        $url = $path;\n        $options = array(\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_CUSTOMREQUEST => $method,\n            CURLOPT_CONNECTTIMEOUT => 10,\n            CURLOPT_TIMEOUT => $this->timeout,\n            CURLOPT_HEADER => true,\n            CURLOPT_NOSIGNAL => 1,\n        );\n\n        if ($headers) {\n            $options[CURLOPT_HTTPHEADER] = $headers;\n        }\n        if ($body) {\n            $options[CURLOPT_POSTFIELDS] = $body;\n        }\n        $ch = curl_init($url);\n        curl_setopt_array($ch, $options);\n        $result = curl_exec($ch);\n        $ret = curl_errno($ch);\n        if ($ret !== 0) {\n            $this->error = $ret;\n            $this->errorStr = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n        $code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($result, 0, $header_size);\n        $body = substr($result, $header_size);\n        curl_close($ch);\n\n        if ($code >= 200 && $code < 300) {\n            if ($method == 'GET') {\n                return $body;\n            }\n            return $this->response($headers, $body);\n        } else {\n            $this->error($headers, $body);\n            return false;\n        }\n    }\n\n    private function response($header, $body)\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n            if ($i === 0) {\n                continue;\n            }\n            list($key, $value) = explode(':', $line);\n            $headers[trim($key)] = trim($value);\n        }\n\n        $response = json_decode($body, true);\n        if (!$response) {\n            $response = $body;\n        }\n        return $response;\n    }\n\n    private function error($header, $body)\n    {\n        list($status, $reason) = explode(' ', substr($header, 0, strpos($header, \"\\r\\n\")));\n        $this->error = $status;\n        $this->errorStr = $body;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [
      "<?php\nclass QiniuStorage\n{\n    const QINIU_RSF_HOST = 'rsf.qbox.me';\n    const QINIU_RS_HOST = 'rs.qbox.me';\n    const QINIU_UP_HOST = 'up.qiniup.com';\n\n    public $timeout = '60s';\n    public $error;\n    public $errorStr;\n\n    public function request($path, $method, $headers = null, $body = null)\n    {\n        $url = $path;\n        $options = [\n            'http' => [\n                'method' => $method,\n                'timeout' => $this->timeout,\n                'ignore_errors' => true\n            ]\n        ];\n        if ($headers) {\n            $options['http']['header'] = $headers;\n        }\n        if ($body) {\n            $options['http']['content'] = $body;\n        }\n        $context = stream_context_create($options);\n        $response = file_get_contents($url, false, $context);\n        if ($response === false) {\n            $this->error = 'Network error';\n            $this->errorStr = $this->error;\n            return false;\n        }\n\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (strpos($header, ' 200 ') === false) {\n            $this->error($header, $body);\n            return false;\n        }\n\n        if ($method === 'GET') {\n            return $body;\n        } else {\n            return $this->response($response);\n        }\n    }\n\n\n    private function response($text)\n    {\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $text, 2);\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $header) as $headerLine) {\n            $headerLine = trim($headerLine);\n            if (strpos($headerLine, ': ') !== false) {\n                list($key, $value) = explode(': ', $headerLine, 2);\n                $headers[strtolower($key)] = $value;\n            }\n        }\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $data = $body;\n        }\n        return [\n            'code' => intval(explode(' ', $header)[1]),\n            'data' => $data,\n            'headers' => $headers\n        ];\n    }\n\n    private function error($header, $body)\n    {\n        list($protocol, $code, $status) = explode(' ', $header, 3);\n        $this->error = $code;\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $this->errorStr = $body;\n        } else {\n            $this->errorStr = $data['error'];\n        }\n    }\n}\n\n?>\n",
      "<?php\nclass QiniuStorage\n{\n    const QINIU_RSF_HOST = 'rsf.qbox.me';\n    const QINIU_RS_HOST = 'rs.qbox.me';\n    const QINIU_UP_HOST = 'up.qiniup.com';\n\n    public $timeout = '60s';\n    public $error;\n    public $errorStr;\n\n    public function request($path, $method, $headers = null, $body = null)\n    {\n        $url = $path;\n        $options = [\n            'http' => [\n                'method' => $method,\n                'timeout' => $this->timeout,\n                'ignore_errors' => true\n            ]\n        ];\n        if ($headers) {\n            $options['http']['header'] = $headers;\n        }\n        if ($body) {\n            $options['http']['content'] = $body;\n        }\n        $context = stream_context_create($options);\n        $response = file_get_contents($url, false, $context);\n        if ($response === false) {\n            $this->error = 'Network error';\n            $this->errorStr = $this->error;\n            return false;\n        }\n\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (strpos($header, ' 200 ') === false) {\n            $this->error($header, $body);\n            return false;\n        }\n\n        if ($method === 'GET') {\n            return $body;\n        }\n        return $this->response($response);\n    }\n\n    private function response($text)\n    {\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $text, 2);\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $header) as $headerLine) {\n            $headerLine = trim($headerLine);\n            if (strpos($headerLine, ': ') !== false) {\n                list($key, $value) = explode(': ', $headerLine, 2);\n                $headers[strtolower($key)] = $value;\n            }\n        }\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $data = $body;\n        }\n        return [\n            'code' => intval(explode(' ', $header)[1]),\n            'data' => $data,\n            'headers' => $headers\n        ];\n    }\n\n    private function error($header, $body)\n    {\n        list($protocol, $code, $message) = explode(' ', $header, 3);\n        $this->error = $code;\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $this->errorStr = $body;\n        } else {\n            $this->errorStr = $data['error'];\n        }\n    }\n}\n\n?>\n",
      "<?php\nclass QiniuStorage\n{\n    const QINIU_RSF_HOST = 'rsf.qbox.me';\n    const QINIU_RS_HOST = 'rs.qbox.me';\n    const QINIU_UP_HOST = 'up.qiniup.com';\n\n    public $timeout = '60s';\n    public $error;\n    public $errorStr;\n\n    public function request($path, $method, $headers = null, $body = null)\n    {\n        $url = $path;\n        $options = [\n            'http' => [\n                'method' => $method,\n                'timeout' => $this->timeout,\n                'ignore_errors' => true\n            ]\n        ];\n        if ($headers) {\n            $options['http']['header'] = $headers;\n        }\n        if ($body) {\n            $options['http']['content'] = $body;\n        }\n        $context = stream_context_create($options);\n        $response = file_get_contents($url, false, $context);\n        if ($response === false) {\n            $this->error = 'Network error';\n            $this->errorStr = $this->error;\n            return false;\n        }\n\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (strpos($header, ' 200 ') === false) {\n            $this->error($header, $body);\n            return false;\n        }\n        if ($method === 'GET') {\n            return $body;\n        }\n        return $this->response($response);\n    }\n\n    private function response($text)\n    {\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $text, 2);\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $header) as $headerLine) {\n            $headerLine = trim($headerLine);\n            if (strpos($headerLine, ': ') !== false) {\n                list($key, $value) = explode(': ', $headerLine, 2);\n                $headers[strtolower($key)] = $value;\n            }\n        }\n\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $data = $body;\n        }\n\n        return [\n            'code' => intval(explode(' ', $header)[1]),\n            'data' => $data,\n            'headers' => $headers\n        ];\n    }\n\n    private function error($header, $body)\n    {\n        list($protocol, $code, $status) = explode(' ', $header, 3);\n        $this->error = $code;\n        $this->errorStr = $body;\n    }\n}\n\n?>\n",
      "<?php\nclass QiniuStorage\n{\n    const QINIU_RSF_HOST = 'rsf.qbox.me';\n    const QINIU_RS_HOST = 'rs.qbox.me';\n    const QINIU_UP_HOST = 'up.qiniup.com';\n\n    public $timeout = '60s';\n    public $error;\n    public $errorStr;\n\n    public function request($path, $method, $headers = null, $body = null)\n    {\n        $url = $path;\n        $options = [\n            'http' => [\n                'method' => $method,\n                'timeout' => $this->timeout,\n                'ignore_errors' => true\n            ]\n        ];\n        if ($headers) {\n            $options['http']['header'] = $headers;\n        }\n        if ($body) {\n            $options['http']['content'] = $body;\n        }\n        $context = stream_context_create($options);\n        $response = file_get_contents($url, false, $context);\n        if ($response === false) {\n            $this->error = 'Network error';\n            $this->errorStr = $this->error;\n            return false;\n        }\n\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (strpos($header, ' 200 ') === false) {\n            $this->error($header, $body);\n            return false;\n        }\n\n        if ($method === 'GET') {\n            return $body;\n        }\n        return $this->response($response);\n    }\n\n    private function response($text)\n    {\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $text, 2);\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $header) as $headerLine) {\n            $headerLine = trim($headerLine);\n            if (strpos($headerLine, ': ') !== false) {\n                list($key, $value) = explode(': ', $headerLine, 2);\n                $headers[strtolower($key)] = $value;\n            }\n        }\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $data = $body;\n        }\n        return [\n            'code' => intval(explode(' ', $header)[1]),\n            'data' => $data,\n            'headers' => $headers\n        ];\n    }\n\n    private function error($header, $body)\n    {\n        list($protocol, $code, $message) = explode(' ', $header, 3);\n        $this->error = $code;\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $this->errorStr = $body;\n        } else {\n            $this->errorStr = $data['error'];\n        }\n    }\n}\n\n?>\n",
      "<?php\nclass QiniuStorage\n{\n    const QINIU_RSF_HOST = 'rsf.qbox.me';\n    const QINIU_RS_HOST = 'rs.qbox.me';\n    const QINIU_UP_HOST = 'up.qiniup.com';\n\n    public $timeout = '60s';\n    public $error;\n    public $errorStr;\n\n    public function request($path, $method, $headers = null, $body = null)\n    {\n        $url = $path;\n        $options = [\n            'http' => [\n                'method' => $method,\n                'timeout' => $this->timeout,\n                'ignore_errors' => true\n            ]\n        ];\n        if ($headers) {\n            $options['http']['header'] = $headers;\n        }\n        if ($body) {\n            $options['http']['content'] = $body;\n        }\n        $context = stream_context_create($options);\n        $response = file_get_contents($url, false, $context);\n        if ($response === false) {\n            $this->error = 'Network error';\n            $this->errorStr = $this->error;\n            return false;\n        }\n\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (strpos($header, ' 200 ') === false) {\n            $this->error($header, $body);\n            return false;\n        }\n\n        if ($method === 'GET') {\n            return $body;\n        }\n        return $this->response($response);\n    }\n\n\n    private function response($text)\n    {\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $text, 2);\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $header) as $headerLine) {\n            $headerLine = trim($headerLine);\n            if (strpos($headerLine, ': ') !== false) {\n                list($key, $value) = explode(': ', $headerLine, 2);\n                $headers[strtolower($key)] = $value;\n            }\n        }\n\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $data = $body;\n        }\n\n        return [\n            'code' => intval(explode(' ', $header)[1]),\n            'data' => $data,\n            'headers' => $headers\n        ];\n    }\n\n\n    private function error($header, $body)\n    {\n        list($protocol, $code, $status) = explode(' ', $header, 3);\n        $this->error = $code;\n        $this->errorStr = $body;\n    }\n}\n\n?>\n",
      "<?php\nclass QiniuStorage\n{\n    const QINIU_RSF_HOST = 'rsf.qbox.me';\n    const QINIU_RS_HOST = 'rs.qbox.me';\n    const QINIU_UP_HOST = 'up.qiniup.com';\n\n    public $timeout = '60s';\n    public $error;\n    public $errorStr;\n\n    public function request($path, $method, $headers = null, $body = null)\n    {\n        $url = $path;\n        $options = [\n            'http' => [\n                'method' => $method,\n                'timeout' => $this->timeout,\n                'ignore_errors' => true\n            ]\n        ];\n        if ($headers) {\n            $options['http']['header'] = $headers;\n        }\n        if ($body) {\n            $options['http']['content'] = $body;\n        }\n        $context = stream_context_create($options);\n        $response = file_get_contents($url, false, $context);\n        if ($response === false) {\n            $this->error = 'Network error';\n            $this->errorStr = $this->error;\n            return false;\n        }\n\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (strpos($header, ' 200 ') === false) {\n            $this->error($header, $body);\n            return false;\n        }\n\n        if ($method === 'GET') {\n            return $body;\n        }\n        return $this->response($response);\n    }\n\n    private function response($text)\n    {\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $text, 2);\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $header) as $headerLine) {\n            $headerLine = trim($headerLine);\n            if (strpos($headerLine, ': ') !== false) {\n                list($key, $value) = explode(': ', $headerLine, 2);\n                $headers[strtolower($key)] = $value;\n            }\n        }\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $data = $body;\n        }\n        return [\n            'code' => intval(explode(' ', $header)[1]),\n            'data' => $data,\n            'headers' => $headers\n        ];\n    }\n\n\n    private function error($header, $body)\n    {\n        list($protocol, $code, $message) = explode(' ', $header, 3);\n        $this->error = $code;\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $this->errorStr = $body;\n        } else {\n            $this->errorStr = $data['error'];\n        }\n    }\n}\n\n?>\n",
      "<?php\nclass QiniuStorage\n{\n    const QINIU_RSF_HOST = 'rsf.qbox.me';\n    const QINIU_RS_HOST = 'rs.qbox.me';\n    const QINIU_UP_HOST = 'up.qiniup.com';\n\n    public $timeout = '60s';\n    public $error;\n    public $errorStr;\n\n    public function request($path, $method, $headers = null, $body = null)\n    {\n        $url = $path;\n        $options = [\n            'http' => [\n                'method' => $method,\n                'timeout' => $this->timeout,\n                'ignore_errors' => true\n            ]\n        ];\n        if ($headers) {\n            $options['http']['header'] = $headers;\n        }\n        if ($body) {\n            $options['http']['content'] = $body;\n        }\n        $context = stream_context_create($options);\n        $response = file_get_contents($url, false, $context);\n        if ($response === false) {\n            $this->error = 'Network error';\n            $this->errorStr = $this->error;\n            return false;\n        }\n\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (strpos($header, ' 200 ') === false) {\n            $this->error($header, $body);\n            return false;\n        }\n\n        if ($method === 'GET') {\n            return $body;\n        }\n        return $this->response($response);\n    }\n\n    private function response($text)\n    {\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $text, 2);\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $header) as $headerLine) {\n            $headerLine = trim($headerLine);\n            if (strpos($headerLine, ': ') !== false) {\n                list($key, $value) = explode(': ', $headerLine, 2);\n                $headers[strtolower($key)] = $value;\n            }\n        }\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $data = $body;\n        }\n        return ['body' => $data, 'headers' => $headers];\n    }\n\n    private function error($header, $body)\n    {\n        list($protocol, $status, $message) = explode(' ', $header, 3);\n        $this->error = $status;\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $this->errorStr = $body;\n        } else {\n            $this->errorStr = $data['error'];\n        }\n    }\n}\n\n?>\n",
      "<?php\nclass QiniuStorage\n{\n    const QINIU_RSF_HOST = 'rsf.qbox.me';\n    const QINIU_RS_HOST = 'rs.qbox.me';\n    const QINIU_UP_HOST = 'up.qiniup.com';\n\n    public $timeout = '60s';\n    public $error;\n    public $errorStr;\n\n    public function request($path, $method, $headers = null, $body = null)\n    {\n        $url = $path;\n        $options = [\n            'http' => [\n                'method' => $method,\n                'timeout' => $this->timeout,\n                'ignore_errors' => true\n            ]\n        ];\n        if ($headers) {\n            $options['http']['header'] = $headers;\n        }\n        if ($body) {\n            $options['http']['content'] = $body;\n        }\n        $context = stream_context_create($options);\n        $response = file_get_contents($url, false, $context);\n        if ($response === false) {\n            $this->error = 'Network error';\n            $this->errorStr = $this->error;\n            return false;\n        }\n\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (strpos($header, ' 200 ') === false) {\n            $this->error($header, $body);\n            return false;\n        }\n\n        if ($method === 'GET') {\n            return $body;\n        }\n        return $this->response($response);\n    }\n\n\n    private function response($text)\n    {\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $text, 2);\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $header) as $headerLine) {\n            $headerLine = trim($headerLine);\n            if (strpos($headerLine, ': ') !== false) {\n                list($key, $value) = explode(': ', $headerLine, 2);\n                $headers[strtolower($key)] = $value;\n            }\n        }\n        $data = json_decode($body, true);\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            $data = $body;\n        }\n        return [\n            'code' => intval(explode(' ', $header)[1]),\n            'data' => $data,\n            'headers' => $headers\n        ];\n    }\n\n    private function error($header, $body)\n    {\n        list($protocol, $code, $status) = explode(' ', $header, 3);\n        $this->error = $code;\n        $this->errorStr = $body;\n    }\n}\n\n?>\n"
    ],
    "match_count": 2,
    "pass@3": 0.5333333333333333,
    "pass@5": 0.7777777777777778
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a PHP class that handles HTTP requests to the OpenAI API using cURL, with support for different content types, streaming, and proxy configuration.\n\nClass Description: The OpenAi class is designed to interact with OpenAI's API by sending HTTP requests. It manages API keys, content types, headers, and request configurations. The class supports both JSON and multipart/form-data content types, allows for request streaming, and can be configured to use a proxy.\n\nAttributes:\n\nengine: string - The default OpenAI engine to use (default: \"davinci\")\nmodel: string - The default model for completions (default: \"text-davinci-002\")\nchatModel: string - The default model for chat completions (default: \"gpt-3.5-turbo\")\nassistantsBetaVersion: string - The version for assistants API (default: \"v1\")\nheaders: array - Array of HTTP headers to be sent with requests\ncontentTypes: array - Mapping of content types to their header strings\ntimeout: int - cURL timeout in seconds (default: 0)\nstream_method: object - Callback method for streaming responses\ncustomUrl: string - Custom base URL to override the default OpenAI API URL\nproxy: string - Proxy server address if needed\ncurlInfo: array - Information about the last cURL request\n\nMethods:\n\n__construct: __construct(string $OPENAI_API_KEY) -> void - Initializes the class with the OpenAI API key and sets default headers\nsendRequest: sendRequest(string $url, string $method, array $opts = []) -> bool|string - Sends an HTTP request to the specified URL with given method and options\nbaseUrl: baseUrl(string &$url) -> void - Modifies the base URL if a custom URL is set",
    "Canonical_solution": "namespace Orhanerday\\OpenAi;\n\nuse Exception;\n\nclass OpenAi\n{\n    private string $engine = \"davinci\";\n    private string $model = \"text-davinci-002\";\n    private string $chatModel = \"gpt-3.5-turbo\";\n    private string $assistantsBetaVersion = \"v1\";\n    private array $headers;\n    private array $contentTypes;\n    private int $timeout = 0;\n    private object $stream_method;\n    private string $customUrl = \"\";\n    private string $proxy = \"\";\n    private array $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY)\n    {\n        $this->contentTypes = [\n            \"application/json\" => \"Content-Type: application/json\",\n            \"multipart/form-data\" => \"Content-Type: multipart/form-data\",\n        ];\n\n        $this->headers = [\n            $this->contentTypes[\"application/json\"],\n            \"Authorization: Bearer $OPENAI_API_KEY\",\n        ];\n    }\n\n    /**\n     * @param  string  $url\n     * @param  string  $method\n     * @param  array   $opts\n     * @return bool|string\n     */\n    private function sendRequest(string $url, string $method, array $opts = [])\n    {\n        $post_fields = json_encode($opts);\n\n        if (array_key_exists('file', $opts) || array_key_exists('image', $opts)) {\n            $this->headers[0] = $this->contentTypes[\"multipart/form-data\"];\n            $post_fields = $opts;\n        } else {\n            $this->headers[0] = $this->contentTypes[\"application/json\"];\n        }\n        $curl_info = [\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => '',\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => $this->timeout,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => $method,\n            CURLOPT_POSTFIELDS => $post_fields,\n            CURLOPT_HTTPHEADER => $this->headers,\n        ];\n\n        if ($opts == []) {\n            unset($curl_info[CURLOPT_POSTFIELDS]);\n        }\n\n        if (! empty($this->proxy)) {\n            $curl_info[CURLOPT_PROXY] = $this->proxy;\n        }\n\n        if (array_key_exists('stream', $opts) && $opts['stream']) {\n            $curl_info[CURLOPT_WRITEFUNCTION] = $this->stream_method;\n        }\n\n        $curl = curl_init();\n\n        curl_setopt_array($curl, $curl_info);\n        $response = curl_exec($curl);\n\n        $info = curl_getinfo($curl);\n        $this->curlInfo = $info;\n\n        curl_close($curl);\n\n        if (! $response) {\n            throw new Exception(curl_error($curl));\n        }\n\n        return $response;\n    }\n\n    /**\n     * @param  string  $url\n     */\n    private function baseUrl(string &$url)\n    {\n        if ($this->customUrl != \"\") {\n            $url = str_replace(Url::ORIGIN, $this->customUrl, $url);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $assistantsBetaVersion = \"v1\";\n    public $headers = [];\n    public $contentTypes = [\n        'application/json' => 'application/json',\n        'multipart/form-data' => 'multipart/form-data'\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            'Content-Type: application/json',\n            'Authorization: Bearer ' . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest($url, $method, $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['headers'])) {\n            $this->headers = array_merge($this->headers, $opts['headers']);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n\n        if (isset($opts['contentType']) && isset($this->contentTypes[$opts['contentType']])) {\n            $this->headers = array_filter($this->headers, function ($header) {\n                return strpos($header, 'Content-Type') === false;\n            });\n            $this->headers[] = 'Content-Type: ' . $this->contentTypes[$opts['contentType']];\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n\n\n        if ($method != 'GET') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n            if (isset($opts['body'])) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n            }\n        }\n\n        if (isset($opts['stream']) && $opts['stream'] === true && is_callable($this->stream_method)) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(&$url) {\n        if ($this->customUrl) {\n            $url = str_replace(\"https://api.openai.com/\", $this->customUrl, $url);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $assistantsBetaVersion = \"v1\";\n    public $headers = [];\n    public $contentTypes = [\n        'application/json' => 'application/json',\n        'multipart/form-data' => 'multipart/form-data'\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct(string $OPENAI_API_KEY) {\n        $this->headers = [\n            'Content-Type: application/json',\n            'Authorization: Bearer ' . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['headers'])) {\n            $this->headers = array_merge($this->headers, $opts['headers']);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n\n        if (isset($opts['contentType']) && isset($this->contentTypes[$opts['contentType']])) {\n            $this->headers = array_filter($this->headers, function ($header) {\n                return strpos($header, 'Content-Type') === false;\n            });\n            $this->headers[] = 'Content-Type: ' . $this->contentTypes[$opts['contentType']];\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n\n\n        if (isset($opts['data'])) {\n            if ($method == 'POST') {\n                curl_setopt($ch, CURLOPT_POST, 1);\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['data']);\n            } else {\n                curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['data']);\n            }\n        }\n\n        if ($this->stream_method) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if ($this->customUrl) {\n            $url = str_replace(\"https://api.openai.com/\", $this->customUrl, $url);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $assistantsBetaVersion = \"v1\";\n    public $headers = [];\n    public $contentTypes = [\n        'application/json' => 'application/json',\n        'multipart/form-data' => 'multipart/form-data'\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct(string $OPENAI_API_KEY) {\n        $this->headers = [\n            'Content-Type: application/json',\n            'Authorization: Bearer ' . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['headers'])) {\n            $this->headers = array_merge($this->headers, $opts['headers']);\n        }\n\n        if (isset($opts['contentType']) && isset($this->contentTypes[$opts['contentType']])) {\n            $this->headers = array_filter($this->headers, function ($header) {\n                return strpos($header, 'Content-Type') === false;\n            });\n            $this->headers[] = 'Content-Type: ' . $this->contentTypes[$opts['contentType']];\n        }\n\n        if (isset($opts['data'])) {\n            if ($method == 'POST') {\n                curl_setopt($ch, CURLOPT_POST, 1);\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['data']);\n            } else {\n                curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['data']);\n            }\n        }\n\n\n        if (isset($opts['stream']) && $opts['stream'] === true && $this->stream_method) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if ($this->customUrl) {\n            $url = str_replace('https://api.openai.com/', $this->customUrl, $url);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $assistantsBetaVersion = \"v1\";\n    public $headers = [];\n    public $contentTypes = [\n        'application/json' => 'application/json',\n        'multipart/form-data' => 'multipart/form-data'\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            'Content-Type: application/json',\n            'Authorization: Bearer ' . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest($url, $method, $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['stream']) && $opts['stream'] === true && $this->stream_method) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n\n        if ($method == 'POST') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n\n            if (isset($opts['contentType']) && $opts['contentType'] == 'multipart/form-data') {\n                $this->headers = array_filter($this->headers, function ($header) {\n                    return strpos($header, 'Content-Type') === false;\n                });\n                curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n            }\n        }\n\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(&$url) {\n        if ($this->customUrl) {\n            $url = str_replace('https://api.openai.com/', $this->customUrl, $url);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $assistantsBetaVersion = \"v1\";\n    public $headers = [];\n    public $contentTypes = [\n        'application/json' => 'application/json',\n        'multipart/form-data' => 'multipart/form-data'\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            'Content-Type: application/json',\n            'Authorization: Bearer ' . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest($url, $method, $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['headers'])) {\n            $this->headers = array_merge($this->headers, $opts['headers']);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n\n        if (isset($opts['contentType']) && isset($this->contentTypes[$opts['contentType']])) {\n            $this->headers = array_filter($this->headers, function ($header) {\n                return strpos($header, 'Content-Type') === false;\n            });\n            $this->headers[] = 'Content-Type: ' . $this->contentTypes[$opts['contentType']];\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n\n\n        if ($method != 'GET') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n            if (isset($opts['body'])) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n            }\n        }\n\n        if (isset($this->stream_method)) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(&$url) {\n        if ($this->customUrl) {\n            $url = str_replace(\"https://api.openai.com/\", $this->customUrl, $url);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $assistantsBetaVersion = \"v1\";\n    public $headers = [];\n    public $contentTypes = [\n        'application/json' => 'application/json',\n        'multipart/form-data' => 'multipart/form-data'\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct(string $OPENAI_API_KEY) {\n        $this->headers = [\n            'Content-Type: application/json',\n            'Authorization: Bearer ' . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['stream']) && $opts['stream'] === true && $this->stream_method) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        if ($method === 'POST') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n\n            if (isset($opts['contentType']) && $opts['contentType'] === 'multipart/form-data') {\n                $this->headers = array_filter($this->headers, function ($header) {\n                    return strpos($header, 'Content-Type') === false;\n                });\n                curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n            }\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n        curl_close($ch);\n\n        return $response;\n    }\n\n\n    public function baseUrl(string &$url) {\n        if ($this->customUrl) {\n            $url = str_replace('https://api.openai.com/', $this->customUrl, $url);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $assistantsBetaVersion = \"v1\";\n    public $headers = [];\n    public $contentTypes = [\n        'application/json' => 'application/json',\n        'multipart/form-data' => 'multipart/form-data'\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n\n    public function __construct(string $OPENAI_API_KEY) {\n        $this->headers = [\n            'Content-Type: application/json',\n            'Authorization: Bearer ' . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['headers'])) {\n            $this->headers = array_merge($this->headers, $opts['headers']);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n\n        if (isset($opts['contentType']) && isset($this->contentTypes[$opts['contentType']])) {\n            $this->headers = array_filter($this->headers, function ($header) {\n                return strpos($header, 'Content-Type') !== 0;\n            });\n            $this->headers[] = 'Content-Type: ' . $this->contentTypes[$opts['contentType']];\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n\n\n        if ($method != 'GET') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n            if (isset($opts['body'])) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n            }\n        }\n\n        if (isset($this->stream_method)) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if ($this->customUrl) {\n            $url = str_replace('https://api.openai.com/', $this->customUrl, $url);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $assistantsBetaVersion = \"v1\";\n    public $headers = [];\n    public $contentTypes = [\n        'application/json' => 'application/json',\n        'multipart/form-data' => 'multipart/form-data'\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n\n    public function __construct(string $OPENAI_API_KEY) {\n        $this->headers = [\n            'Content-Type: application/json',\n            'Authorization: Bearer ' . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['headers'])) {\n            $this->headers = array_merge($this->headers, $opts['headers']);\n        }\n\n        if (isset($opts['contentType']) && isset($this->contentTypes[$opts['contentType']])) {\n            $this->headers = array_filter($this->headers, function ($header) {\n                return strpos($header, 'Content-Type') === false;\n            });\n            $this->headers[] = 'Content-Type: ' . $this->contentTypes[$opts['contentType']];\n        }\n\n        if (isset($opts['data'])) {\n            if ($method == 'POST') {\n                curl_setopt($ch, CURLOPT_POST, 1);\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['data']);\n            } else {\n                curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['data']);\n            }\n        }\n\n        if (isset($this->stream_method)) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if ($this->customUrl) {\n            $url = str_replace(\"https://api.openai.com/\", $this->customUrl, $url);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $assistantsBetaVersion = \"v1\";\n    public $headers = [];\n    public $contentTypes = [\n        'application/json' => 'application/json',\n        'multipart/form-data' => 'multipart/form-data'\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n\n    public function __construct(string $OPENAI_API_KEY) {\n        $this->headers = [\n            'Content-Type' => 'application/json',\n            'Authorization' => 'Bearer ' . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['stream']) && $opts['stream'] === true && $this->stream_method) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        switch (strtoupper($method)) {\n            case 'POST':\n                curl_setopt($ch, CURLOPT_POST, true);\n                if (isset($opts['data'])) {\n                    if ($this->headers['Content-Type'] === $this->contentTypes['application/json']) {\n                        $data = json_encode($opts['data']);\n                    } else {\n                        $data = $opts['data'];\n                    }\n                    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n                }\n                break;\n            case 'GET':\n                break;\n            default:\n                curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n                if (isset($opts['data'])) {\n                    $data = http_build_query($opts['data']);\n                    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n                }\n        }\n\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if ($this->customUrl) {\n            $url = $this->customUrl . $url;\n        } else {\n            $url = 'https://api.openai.com' . $url;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $assistantsBetaVersion = \"v1\";\n    public $headers = [];\n    public $contentTypes = [\n        'application/json' => 'application/json',\n        'multipart/form-data' => 'multipart/form-data'\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n\n    public function __construct(string $OPENAI_API_KEY) {\n        $this->headers = [\n            'Content-Type: application/json',\n            'Authorization: Bearer ' . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if (isset($opts['headers'])) {\n            $this->headers = array_merge($this->headers, $opts['headers']);\n        }\n\n        if (isset($opts['contentType']) && isset($this->contentTypes[$opts['contentType']])) {\n            $this->headers = array_filter($this->headers, function ($header) {\n                return strpos($header, 'Content-Type') === false;\n            });\n            $this->headers[] = 'Content-Type: ' . $this->contentTypes[$opts['contentType']];\n        }\n\n        if (isset($opts['body'])) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n        }\n\n        if ($method == 'POST') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n        } elseif ($method != 'GET') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($this->stream_method)) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n\n        if (curl_errno($ch)) {\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n\n    public function baseUrl(string &$url) {\n        if ($this->customUrl) {\n            $url = str_replace('https://api.openai.com/', $this->customUrl, $url);\n        }\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a PHP class for making HTTP requests using cURL with support for various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: The RequestCore class provides a comprehensive wrapper around PHP's cURL functions to simplify HTTP requests. It supports GET, POST, PUT, DELETE, and HEAD methods, handles authentication, manages request/response headers and bodies, supports streaming for large files, and includes proxy configuration.\n\nAttributes:\n- request_url: string - The URL to send the request to\n- request_headers: array - Associative array of request headers\n- request_body: string - The request body content\n- response: string - The complete response from the server\n- response_headers: array - Parsed response headers\n- response_body: string - The response body content\n- response_code: int - HTTP response status code\n- response_info: array - Additional cURL response information\n- curl_handle: resource - The cURL handle resource\n- method: string - HTTP method (GET, POST, PUT, DELETE, HEAD)\n- proxy: array|null - Proxy configuration details\n- username: string|null - Authentication username\n- password: string|null - Authentication password\n- curlopts: array|null - Additional cURL options\n- debug_mode: bool - Whether to enable debug mode\n- request_class: string - Class name for request objects\n- response_class: string - Class name for response objects\n- useragent: string - User agent string\n- read_file: string|null - File path for reading data\n- read_stream: resource|null - Stream resource for reading data\n- read_stream_size: int|null - Size of read stream\n- read_stream_read: int - Bytes read from stream\n- write_file: string|null - File path for writing data\n- write_stream: resource|null - Stream resource for writing data\n- seek_position: int|null - Position to seek in read stream\n- cacert_location: mixed - CA certificate location\n- ssl_verification: bool - Whether to verify SSL\n- registered_streaming_read_callback: callable|null - Callback for streaming read\n- registered_streaming_write_callback: callable|null - Callback for streaming write\n\nMethods:\n- __construct(string|null $url, array|null $proxy, array|null $helpers) -> self - Initialize the request object\n- __destruct() -> self - Clean up resources\n- set_credentials(string $user, string $pass) -> self - Set authentication credentials\n- add_header(string $key, string $value) -> self - Add a request header\n- remove_header(string $key) -> self - Remove a request header\n- set_method(string $method) -> self - Set the HTTP method\n- set_useragent(string $ua) -> self - Set the user agent\n- set_body(string $body) -> self - Set the request body\n- set_request_url(string $url) -> self - Set the request URL\n- set_curlopts(array $curlopts) -> self - Set additional cURL options\n- set_read_stream_size(int $size) -> self - Set read stream size\n- set_read_stream(resource $resource, int|null $size) -> self - Set read stream resource\n- set_read_file(string $location) -> self - Set read file location\n- set_write_stream(resource $resource) -> self - Set write stream resource\n- set_write_file(string $location) -> self - Set write file location\n- set_proxy(string $proxy) -> self - Configure proxy settings\n- set_seek_position(int|null $position) -> self - Set seek position for read stream\n- register_streaming_read_callback(callable $callback) -> self - Register read callback\n- register_streaming_write_callback(callable $callback) -> self - Register write callback\n- streaming_read_callback(resource $curl_handle, resource $file_handle, int $length) -> string - Handle streaming read\n- streaming_write_callback(resource $curl_handle, string $data) -> int - Handle streaming write\n- prep_request() -> resource - Prepare and return cURL handle\n- process_response(resource|null $curl_handle, string|null $response) -> mixed - Process the response\n- send_request(bool $parse = false) -> mixed - Send the request and get response\n- get_response_header(string|null $header) -> mixed - Get response header(s)\n- get_response_body() -> string - Get response body\n- get_response_code() -> int - Get response status code",
    "Canonical_solution": "class RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request']))\n        {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response']))\n        {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy)\n        {\n            $this->set_proxy($proxy);\n        }\n\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream))\n        {\n            fclose($this->read_stream);\n        }\n\n        if (isset($this->write_file) && isset($this->write_stream))\n        {\n            fclose($this->write_stream);\n        }\n\n        return $this;\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key]))\n        {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0)\n        {\n            $stats = fstat($resource);\n\n            if ($stats && $stats['size'] >= 0)\n            {\n                $position = ftell($resource);\n\n                if ($position !== false && $position >= 0)\n                {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->set_read_stream($read_file_handle);\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->set_write_stream($write_file_handle);\n    }\n\n    public function set_proxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = isset($position) ? (integer) $position : null;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size)\n        {\n            return '';\n        }\n\n        if ($this->read_stream_read == 0 && isset($this->seek_position) && $this->seek_position !== ftell($this->read_stream))\n        {\n            if (fseek($this->read_stream, $this->seek_position) !== 0)\n            {\n                throw new RequestCore_Exception('The stream does not support seeking and is either not at the requested position or the position is unknown.');\n            }\n        }\n\n        $read = fread($this->read_stream, min($this->read_stream_size - $this->read_stream_read, $length));\n        $this->read_stream_read += strlen($read);\n\n        $out = $read === false ? '' : $read;\n\n        if ($this->registered_streaming_read_callback)\n        {\n            call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $out);\n        }\n\n        return $out;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n\n        while ($written_total < $length)\n        {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n\n            if ($written_last === false)\n            {\n                return $written_total;\n            }\n\n            $written_total += $written_last;\n        }\n\n        if ($this->registered_streaming_write_callback)\n        {\n            call_user_func($this->registered_streaming_write_callback, $curl_handle, $written_total);\n        }\n\n        return $written_total;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->ssl_verification)\n        {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);\n        }\n        else\n        {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        if ($this->cacert_location === true)\n        {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, dirname(__FILE__) . '/cacert.pem');\n        }\n        elseif (is_string($this->cacert_location))\n        {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->debug_mode)\n        {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if (!ini_get('safe_mode') && !ini_get('open_basedir'))\n        {\n            curl_setopt($curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        if ($this->proxy)\n        {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n\n            if (isset($this->proxy['user']) && isset($this->proxy['pass']))\n            {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password)\n        {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (extension_loaded('zlib'))\n        {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n\n        if (isset($this->request_headers) && count($this->request_headers))\n        {\n            $temp_headers = array();\n\n            foreach ($this->request_headers as $k => $v)\n            {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        switch ($this->method)\n        {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream))\n                {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0)\n                    {\n                        throw new RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                }\n                else\n                {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream))\n                {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                }\n                else\n                {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0)\n        {\n            foreach ($this->curlopts as $k => $v)\n            {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response)\n        {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle))\n        {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n\n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n\n            $header_assoc = array();\n            foreach ($this->response_headers as $header)\n            {\n                $kv = explode(': ', $header);\n                $header_assoc[strtolower($kv[0])] = isset($kv[1])?$kv[1]:'';\n            }\n\n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n\n            if ($curl_handle && $response)\n            {\n                return new $this->response_class($this->response_headers, $this->response_body, $this->response_code, $this->curl_handle);\n            }\n        }\n\n        return false;\n    }\n\n    public function send_request($parse = false)\n    {\n        set_time_limit(0);\n\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false)\n        {\n            throw new RequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        curl_close($curl_handle);\n\n        if ($parse)\n        {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n    public function get_response_header($header = null)\n    {\n        if ($header)\n        {\n            return $this->response_headers[strtolower($header)];\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n\n\n        $this->ssl_verification = true;\n\n\n        $this->cacert_location = __DIR__ . '/cacert.pem';\n\n    }\n\n    public function __destruct() {\n        $this->close();\n    }\n\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size']) {\n                $this->read_stream_size = $stats['size'];\n            }\n        } else {\n            $this->read_stream_size = $size;\n        }\n\n        return $this;\n    }\n\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n\n    public function streaming_write_callback($curl_handle, $data) {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n\n    public function prep_request() {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->cacert_location) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if ($this->read_stream || $this->read_file) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n\n                        if ($this->read_file) {\n                            $this->read_stream_size = filesize($this->read_file);\n                        }\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n\n                    if ($this->read_stream) {\n\n                        $this->registered_streaming_read_callback =\n                            array($this, 'streaming_read_callback');\n                        curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n                    } else {\n                        curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_file);\n                    }\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if ($this->read_stream || $this->read_file) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        if ($this->read_file) {\n                            $this->read_stream_size = filesize($this->read_file);\n                        }\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    if ($this->read_stream) {\n                        $this->registered_streaming_read_callback =\n                            array($this, 'streaming_read_callback');\n                        curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n                    } else {\n                        curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_file);\n                    }\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        $request_headers = array();\n        foreach ($this->request_headers as $key => $value) {\n            $request_headers[] = $key . ': ' . $value;\n        }\n        curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $request_headers);\n\n        if ($this->write_stream) {\n            $this->registered_streaming_write_callback =\n                array($this, 'streaming_write_callback');\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        } else if ($this->write_file) {\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_file);\n        }\n\n        if ($this->seek_position) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n        return $curl_handle;\n    }\n\n\n    public function process_response($curl_handle = null, $response = null) {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n        if (!$response) {\n            $response = curl_exec($curl_handle);\n        }\n\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n\n        if (curl_errno($curl_handle)) {\n            throw new RequestCore_Exception('cURL resource: ' . (string)$curl_handle .\n                '; cURL error: ' . curl_error($curl_handle) .\n                ' (' . curl_errno($curl_handle) . ')');\n        }\n\n\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        $this->response = $response;\n\n        curl_close($curl_handle);\n        return $this;\n    }\n\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $this->curl_handle = $curl_handle;\n        $this->response = curl_exec($curl_handle);\n\n        return $this->process_response($curl_handle, $this->response);\n    }\n\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            if (isset($this->response_headers[$header])) {\n                return $this->response_headers[$header];\n            }\n            return null;\n        }\n        return $this->response_headers;\n    }\n\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n\n    public function close() {\n        if (isset($this->read_stream)) {\n            fclose($this->read_stream);\n            unset($this->read_stream);\n            $this->read_stream_read = 0;\n        }\n\n        if (isset($this->write_stream)) {\n            fclose($this->write_stream);\n            unset($this->write_stream);\n        }\n    }\n}\n\n\nclass RequestCore_Exception extends Exception {}\n?>\n"
    ],
    "unmatched_results": [
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n\n\n        $this->ssl_verification = true;\n\n\n        $this->cacert_location = __DIR__ . '/cacert.pem';\n\n    }\n\n    public function __destruct() {\n        curl_close($this->curl_handle);\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size']) {\n                $this->read_stream_size = $stats['size'];\n            }\n        } else {\n            $this->read_stream_size = $size;\n        }\n\n        return $this;\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data) {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request() {\n        $curl_handle = curl_init();\n\n\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n        if ($this->cacert_location) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n        if (!ini_get('safe_mode') && !ini_get('open_basedir')) {\n            curl_setopt($curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        if ($this->method === 'GET') {\n            curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n        } else if ($this->method === 'POST') {\n            curl_setopt($curl_handle, CURLOPT_POST, true);\n            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        } else if ($this->method === 'PUT' || $this->method === 'DELETE') {\n            $this->request_headers['Content-Length'] = strlen($this->request_body);\n            curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        } else if ($this->method === 'HEAD') {\n            curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n            curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n        }\n\n        $request_headers = array();\n        foreach ($this->request_headers as $key => $value) {\n            $request_headers[] = $key . ': ' . $value;\n        }\n        curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $request_headers);\n\n\n        if ($this->read_stream) {\n\n            if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                $stats = fstat($this->read_stream);\n                if ($stats && $stats['size']) {\n                    $this->read_stream_size = $stats['size'];\n                }\n            }\n\n            $this->read_stream_read = 0;\n\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n\n\n            $this->register_streaming_read_callback(array($this, 'streaming_read_callback'));\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n        }\n\n\n        if ($this->write_stream) {\n            $this->register_streaming_write_callback(array($this, 'streaming_write_callback'));\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        }\n\n\n        if ($this->seek_position) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null) {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n        if (!$response) {\n            $response = curl_exec($curl_handle);\n        }\n\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n\n        if (curl_errno($curl_handle) && $this->response_code == 0) {\n            throw new RequestCore_Exception('cURL error ' . curl_errno($curl_handle) . ': ' . curl_error($curl_handle));\n        }\n\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        $this->response = $response;\n\n        return $this;\n    }\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $this->curl_handle = $curl_handle;\n\n        $this->response = curl_exec($curl_handle);\n\n        $this->process_response($this->curl_handle, $this->response);\n\n        return $this->response_body;\n    }\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            if (isset($this->response_headers[$header])) {\n                return $this->response_headers[$header];\n            } else {\n                return false;\n            }\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n}\n?>\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        // Initialize variables\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        // Set proxy\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n\n\n        $this->ssl_verification = true;\n        $this->cacert_location = __DIR__ . '/cacert.pem';\n    }\n\n    public function __destruct() {\n        curl_close($this->curl_handle);\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data) {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request() {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        // Handle user authentication.\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        // Handle the proxy.\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        // Handle the user agent.\n        if ($this->useragent) {\n            curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        }\n\n        // Handle the method.\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                $this->add_header('Content-Length', strlen($this->request_body));\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n        // Handle the headers.\n        if ($this->request_headers) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        // Handle streaming uploads.\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $this->read_stream_size = filesize($this->read_file);\n                }\n            }\n\n            $this->register_streaming_read_callback(array($this, 'streaming_read_callback'));\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n        }\n\n        // Handle streaming downloads.\n        if ($this->write_stream) {\n            $this->register_streaming_write_callback(array($this, 'streaming_write_callback'));\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        }\n\n        // Handle additional CURL opts.\n        if ($this->curlopts !== null) {\n            foreach ((array)$this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        $this->curl_handle = $curl_handle;\n        return $this->curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null) {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (self::is_curl_error($this->curl_handle)) {\n            throw new RequestCore_Exception('cURL resource: ' . (string)$this->curl_handle . '; cURL error: ' . curl_error($this->curl_handle) . ' (' . curl_errno($this->curl_handle) . ')');\n        }\n\n        $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n        $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n        $this->response_info = curl_getinfo($this->curl_handle);\n\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            if (isset($this->response_headers[$header])) {\n                return $this->response_headers[$header];\n            }\n            return null;\n        }\n        return $this->response_headers;\n    }\n\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n\n    public static function is_curl_error($curl_handle) {\n        return curl_errno($curl_handle);\n    }\n}\n\nclass RequestCore_Exception extends Exception {}\n?>\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($helpers && isset($helpers['foo'])) {\n            throw new \\Exception('Foo helper is not supported');\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct() {\n        curl_close($this->curl_handle);\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data) {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request() {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->cacert_location) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if (!$this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n\n\n        // Handle user authentication.\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        // Handle the proxy.\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        // Handle the user agent.\n        if ($this->useragent) {\n            curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        }\n\n        // Handle the HTTP method.\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                $this->add_header('Content-Length', strlen($this->request_body));\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n        // Handle the request headers.\n        if (count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        // Handle streaming file reading.\n        if ($this->read_file) {\n            if (!is_file($this->read_file)) {\n                throw new \\Exception('Could not open file for reading: ' . $this->read_file);\n            }\n\n            $fh = fopen($this->read_file, 'r');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $fh);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, filesize($this->read_file));\n            $this->read_stream = $fh;\n        }\n\n        // Handle streaming file writing.\n        if ($this->write_file) {\n            if (!($this->write_stream = fopen($this->write_file, 'w'))) {\n                throw new \\Exception('Could not open file for writing: ' . $this->write_file);\n            }\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        }\n\n\n        // Handle streaming using a read callback.\n        if ($this->read_stream && $this->registered_streaming_read_callback) {\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n            if ($this->read_stream_size) {\n                curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            }\n        }\n\n\n        // Handle streaming using a write callback.\n        if ($this->write_stream && $this->registered_streaming_write_callback) {\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        }\n\n\n        // Set the curl options.\n        if (is_array($this->curlopts) && count($this->curlopts) > 0) {\n            curl_setopt_array($curl_handle, $this->curlopts);\n        }\n\n        $this->curl_handle = $curl_handle;\n        return $this->curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null) {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle)) {\n            $this->response_info = curl_getinfo($this->curl_handle);\n        }\n\n        if ($this->response_info['http_code'] == 0) {\n            throw new \\Exception('Problem with cURL resource: ' . curl_error($this->curl_handle));\n        }\n\n        if ($this->response_info['http_code'] >= 300) {\n            throw new \\Exception('HTTP Error: ' . $this->response_info['http_code'] . ' : ' . $this->response);\n        }\n\n        // Split the HTTP response into header and body.\n        $header_size = $this->response_info['header_size'];\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n        $this->response_code = $this->response_info['http_code'];\n\n        // Parse the response headers.\n        $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n        $this->response_headers = array_pop($this->response_headers);\n        $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n        array_shift($this->response_headers);\n\n        $header_assoc = array();\n        foreach ($this->response_headers as $header) {\n            $kv = explode(': ', $header);\n            $header_assoc[strtolower($kv[0])] = isset($kv[1]) ? $kv[1] : '';\n        }\n        $this->response_headers = $header_assoc;\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n        return $this->process_response($curl_handle, $this->response);\n    }\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            return $this->response_headers[strtolower($header)];\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n}\n\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($helpers && isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if ($helpers && isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct() {\n        curl_close($this->curl_handle);\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n    \n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            $this->read_stream_size = $stats[7];\n        } else {\n            $this->read_stream_size = $size;\n        }\n\n        return $this;\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data) {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request() {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->cacert_location) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n\n        // Handle user authentication.\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        // Handle the proxy settings.\n        if (isset($this->proxy) && isset($this->proxy['port'])) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        // Handle the user configurable options.\n        if ($this->curlopts && is_array($this->curlopts)) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                $this->add_header('Content-Length', strlen($this->request_body));\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n\n        // Handle the request headers.\n        if (!empty($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        $this->curl_handle = $curl_handle;\n        return $this->curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null) {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n\n        if (!$response) {\n            $response = curl_exec($curl_handle);\n        }\n\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n\n        if ($response === false) {\n            throw new Exception('cURL resource: ' . (string)$curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        $this->response = $response;\n\n        return $this;\n    }\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception('cURL resource: ' . (string)$curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            $matches = array();\n            if (preg_match('/' . $header . ': (.+?)\\\\r\\\\n/m', $this->response_headers, $matches)) {\n                return $matches[1];\n            }\n            return null;\n        }\n\n        $headers = array();\n        $lines = explode(\"\\r\\n\", $this->response_headers);\n        foreach ($lines as $line) {\n            if (strpos($line, ': ') !== false) {\n                list($key, $value) = explode(': ', $line, 2);\n                $headers[$key] = $value;\n            }\n        }\n        return $headers;\n    }\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n}\n\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (!$helpers || !is_array($helpers)) {\n            $helpers = array();\n        }\n\n        $this->proxy = $proxy;\n\n\n        $this->ssl_verification = true;\n        $this->cacert_location = __DIR__ . '/cacert.pem';\n\n    }\n\n    public function __destruct() {\n        curl_close($this->curl_handle);\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data) {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request() {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->cacert_location) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if ($this->curlopts && is_array($this->curlopts)) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n\n        $headers = array();\n        foreach ($this->request_headers as $key => $value) {\n            $headers[] = $key . ': ' . $value;\n        }\n        curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n\n\n        if ($this->read_stream) {\n\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $this->read_stream_size = filesize($this->read_file);\n                }\n            }\n\n            $this->registered_streaming_read_callback = array($this, 'streaming_read_callback');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n        }\n\n\n        if ($this->write_stream) {\n            $this->registered_streaming_write_callback = array($this, 'streaming_write_callback');\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        }\n\n\n        if ($this->seek_position) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n        $this->curl_handle = $curl_handle;\n        return $this->curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null) {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (strpos(PHP_VERSION, '5.5') !== false) {\n            $this->response_info = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n        } else {\n            $this->response_info = curl_getinfo($this->curl_handle);\n        }\n\n        $this->response_code = $this->response_info['http_code'];\n\n        if (curl_errno($this->curl_handle) > 0) {\n            throw new Exception('cURL error: ' . curl_error($this->curl_handle));\n        }\n\n\n        $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n\n        $this->response_headers = $this->get_response_header_array($this->response_headers);\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n\n    public function get_response_header_array($headers)\n    {\n        $header_array = array();\n        foreach (explode(\"\\r\\n\", $headers) as $i => $line) {\n            if ($i === 0) {\n                $header_array['http_code'] = $line;\n            } else {\n                if (strpos($line, ': ') !== false) {\n                    list($key, $value) = explode(': ', $line);\n                    $header_array[$key] = $value;\n                }\n            }\n        }\n        return $header_array;\n    }\n\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n}\n\n?>\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($helpers && isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if ($helpers && isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct() {\n        curl_close($this->curl_handle);\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data) {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request() {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->cacert_location) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n\n        // Handle user authentication.\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        // Handle the proxy.\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        // Handle the user agent.\n        if ($this->useragent) {\n            curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        }\n\n        // Handle the HTTP method.\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n        // Handle the custom headers.\n        if (isset($this->request_headers) && is_array($this->request_headers)) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        // Handle streaming file reading.\n        if ($this->read_file) {\n            if (!is_file($this->read_file)) {\n                throw new RequestCore_Exception('read_file is not a file');\n            }\n\n            $read_file_handle = fopen($this->read_file, 'r');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $read_file_handle);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, filesize($this->read_file));\n\n        }\n\n        // Handle streaming or file reading.\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size)) {\n                throw new RequestCore_Exception('read_stream requires read_stream_size');\n            }\n            $read_stream_handle =  $this->read_stream;\n            if (isset($this->seek_position) && fseek($this->read_stream, $this->seek_position) !== 0) {\n                throw new RequestCore_Exception('The stream does not support seeking and is either not at the beginning or not writeable');\n            }\n            curl_setopt($curl_handle, CURLOPT_INFILE, $read_stream_handle);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n        }\n\n        // Handle streaming file writing.\n        if ($this->write_file) {\n            $write_file_handle = fopen($this->write_file, 'w');\n            curl_setopt($curl_handle, CURLOPT_FILE, $write_file_handle);\n        }\n\n        // Handle streaming or file writing.\n        if ($this->write_stream) {\n            $write_stream_handle = $this->write_stream;\n            curl_setopt($curl_handle, CURLOPT_FILE, $write_stream_handle);\n        }\n\n        // Handle streaming callbacks.\n        if ($this->registered_streaming_read_callback) {\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n        }\n\n        if ($this->registered_streaming_write_callback) {\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        }\n\n        if ($this->curlopts && is_array($this->curlopts)) {\n            curl_setopt_array($curl_handle, $this->curlopts);\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null) {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (strpos($this->response, \"\\r\\n\\r\\n\") === false) {\n            throw new RequestCore_Exception(\"missing header/body separator\");\n        }\n\n        list($response_header, $response_body) = explode(\"\\r\\n\\r\\n\", $this->response, 2);\n\n        if (strpos($response_header, \"\\r\\n\\r\\n\") !== false) {\n            list($response_header_new, $response_body_new) = explode(\"\\r\\n\\r\\n\", $response_header, 2);\n            $response_header = $response_header_new;\n            $response_body = $response_body_new . \"\\r\\n\\r\\n\" . $response_body;\n        }\n\n        $this->response_headers = array();\n        $lines = explode(\"\\r\\n\", $response_header);\n        foreach ($lines as $line) {\n            if (strpos($line, ': ') === false) {\n                continue;\n            }\n            list($key, $value) = explode(': ', $line, 2);\n            $this->response_headers[$key] = $value;\n        }\n\n        $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n        $this->response_body = $response_body;\n        $this->response_info = curl_getinfo($this->curl_handle);\n\n        return $this;\n    }\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new RequestCore_Exception('cURL resource: ' . (string)$curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed = $this->process_response($curl_handle, $this->response);\n\n        if ($parse) {\n            return $parsed;\n        }\n\n        return $this->response;\n    }\n\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n}\n\nclass RequestCore_Exception extends Exception {}\n?>\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($helpers && isset($helpers['foo'])) {\n            throw new Exception('Foo helper is not supported');\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct() {\n        curl_close($this->curl_handle);\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data) {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request() {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->cacert_location) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if (!$this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n\n\n        // Handle user authentication.\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        // Handle the proxy.\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        // Handle the user agent.\n        if ($this->useragent) {\n            curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        }\n\n        // Handle the HTTP method.\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                $this->add_header('Content-Length', strlen($this->request_body));\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n        // Handle the request headers.\n        if (count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        // Handle streaming file reading.\n        if ($this->read_file) {\n            if (!is_file($this->read_file)) {\n                throw new Exception('Could not open file for reading: ' . $this->read_file);\n            }\n            $fh = fopen($this->read_file, 'r');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $fh);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, filesize($this->read_file));\n            $this->read_stream = $fh;\n        }\n\n        // Handle streaming file writing.\n        if ($this->write_file) {\n            if (!($this->write_stream = fopen($this->write_file, 'w'))) {\n                throw new Exception('Could not open file for writing: ' . $this->write_file);\n            }\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        }\n\n\n        // Handle streaming using a read callback.\n        if ($this->read_stream && $this->registered_streaming_read_callback) {\n            call_user_func_array(\n                array($this, 'register_streaming_read_callback'),\n                array($this->registered_streaming_read_callback)\n            );\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n            if ($this->read_stream_size) {\n                curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            }\n        }\n\n        // Handle streaming using a write callback.\n        if ($this->write_stream && $this->registered_streaming_write_callback) {\n            call_user_func_array(\n                array($this, 'register_streaming_write_callback'),\n                array($this->registered_streaming_write_callback)\n            );\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n        }\n\n        // Set additional cURL options.\n        if ($this->curlopts && is_array($this->curlopts)) {\n            foreach ($this->curlopts as $opt => $value) {\n                curl_setopt($curl_handle, $opt, $value);\n            }\n        }\n\n        $this->curl_handle = $curl_handle;\n        return $this->curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null) {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n\n        if (!$response) {\n            $response = curl_exec($curl_handle);\n        }\n\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n\n        if (curl_errno($curl_handle) > 0) {\n            throw new Exception('cURL error: ' . curl_error($curl_handle));\n        }\n\n\n        // Parse out the headers and body.\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        $this->response = $response;\n\n        // Handle response headers\n        $response_header_lines = explode(\"\\r\\n\", $this->response_headers);\n        $response_headers = array();\n        foreach ($response_header_lines as $header_line) {\n            if (strpos($header_line, ':') !== false) {\n                list($header, $value) = explode(':', $header_line, 2);\n                $header = trim($header);\n                $value = trim($value);\n                if (isset($response_headers[$header])) {\n                    if (!is_array($response_headers[$header])) {\n                        $response_headers[$header] = array($response_headers[$header]);\n                    }\n                    $response_headers[$header][] = $value;\n                } else {\n                    $response_headers[$header] = $value;\n                }\n            }\n        }\n        $this->response_headers = $response_headers;\n\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $response = curl_exec($curl_handle);\n        $parsed_response = $this->process_response($curl_handle, $response);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n}\n\nclass ResponseCore {}\n?>\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n\n\n        $this->ssl_verification = true;\n\n\n        $this->cacert_location = __DIR__ . '/cacert.pem';\n\n    }\n\n    public function __destruct() {\n        curl_close($this->curl_handle);\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n\n        if (!isset($size)) {\n            if (isset($this->read_stream_size)) {\n                $this->read_stream_size = $size;\n            } else {\n\n                $stats = fstat($this->read_stream);\n                $this->read_stream_size = $stats[7];\n            }\n        }\n        return $this;\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data) {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request() {\n        $curl_handle = curl_init();\n\n\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n\n        if (isset($this->read_stream)) {\n\n            $this->read_stream_read = 0;\n\n\n            if (isset($this->seek_position) && fseek($this->read_stream, $this->seek_position) !== 0) {\n                throw new RequestCore_Exception('The stream does not support seeking and is either not at the beginning or not writeable.');\n            }\n\n            if (isset($this->read_stream_size)) {\n                curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            }\n\n\n            curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n        } elseif (isset($this->read_file)) {\n\n            if (!file_exists($this->read_file)) {\n                throw new RequestCore_Exception('The file specified cannot be read.');\n            }\n\n\n            $this->read_stream = fopen($this->read_file, 'r');\n\n            $this->read_stream_size = filesize($this->read_file);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n\n\n            curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n        } elseif (isset($this->request_body)) {\n            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        }\n\n        if (isset($this->write_stream)) {\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n            curl_setopt($curl_handle, CURLOPT_HEADER, false);\n        } elseif (isset($this->write_file)) {\n\n            $fp = fopen($this->write_file, 'w');\n            curl_setopt($curl_handle, CURLOPT_FILE, $fp);\n            curl_setopt($curl_handle, CURLOPT_HEADER, false);\n        }\n\n        if (isset($this->proxy)) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n        }\n\n        if (isset($this->username) && isset($this->password)) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        if ($this->method !== 'GET') {\n            curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n        }\n\n        if (!empty($this->request_headers)) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null) {\n        if ($curl_handle && $response) {\n\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n\n        $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n        $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n        $this->response_info = curl_getinfo($this->curl_handle);\n\n        if ($this->response_code >= 400) {\n\n            $header_array = $this->get_response_header_as_array();\n            $body = $this->response_body;\n            throw new RequestCore_Exception($body, $this->response_code, $header_array);\n        }\n\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n\n        if ($this->response === false) {\n            throw new RequestCore_Exception('cURL resource: ' . (string)$curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        if ($parse) {\n            return $parsed_response;\n        } else {\n            return $this->response;\n        }\n    }\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            preg_match('/' . $header . ': (.+?)\\r\\n/m', $this->response_headers, $match);\n            if (isset($match[1])) {\n                return $match[1];\n            } else {\n                return null;\n            }\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_header_as_array() {\n        $headers = array();\n\n        $lines = explode(\"\\r\\n\", $this->response_headers);\n        foreach ($lines as $line) {\n            if (preg_match('/(.+?): (.+)/', $line, $matches)) {\n                $headers[$matches[1]] = $matches[2];\n            }\n        }\n        return $headers;\n    }\n\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n}\n\n\nclass RequestCore_Exception extends Exception {\n\n    public $header_array = array();\n\n    public function __construct($message, $code = 0, $headers = null) {\n        parent::__construct($message, $code);\n        $this->header_array = $headers;\n    }\n}\n?>\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($helpers && isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if ($helpers && isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct() {\n        curl_close($this->curl_handle);\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size']) {\n                $this->read_stream_size = $stats['size'];\n            }\n        } else {\n            $this->read_stream_size = $size;\n        }\n\n        return $this;\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data) {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request() {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->cacert_location) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n\n\n        // Handle user authentication.\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        // Handle the proxy settings.\n        if (isset($this->proxy) && isset($this->proxy['host'])) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n\n        // Handle the user configurable options.\n        if ($this->curlopts && is_array($this->curlopts)) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n\n            default: // GET is default method.\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n        }\n\n\n        // Handle the request headers.\n        if (is_array($this->request_headers)) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n\n        // Handle streaming file uploads.\n        if (isset($this->read_file)) {\n            if (function_exists('curl_file_create')) {\n                $file_data = curl_file_create($this->read_file);\n            } else {\n                $file_data = '@' . realpath($this->read_file);\n            }\n\n            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, array('file' => $file_data));\n        }\n\n\n        // Handle streaming uploads.\n        if (isset($this->read_stream)) {\n            $read_callback = array($this, 'streaming_read_callback');\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $read_callback);\n            curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n        }\n\n\n        // Handle streaming downloads.\n        if (isset($this->write_stream)) {\n            $write_callback = array($this, 'streaming_write_callback');\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $write_callback);\n        }\n\n\n        // Handle file downloads.\n        if (isset($this->write_file)) {\n            $fp = fopen($this->write_file, 'w');\n            curl_setopt($curl_handle, CURLOPT_FILE, $fp);\n        }\n\n\n        // Set the curl handle.\n        $this->curl_handle = $curl_handle;\n        return $this->curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null) {\n        // Extract the response headers.\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $header_text = substr($response, 0, $header_size);\n        $this->response_headers = $this->get_parsed_headers($header_text);\n\n\n        // Extract the response body.\n        $this->response_body = substr($response, $header_size);\n\n\n        // Extract additional response info.\n        $this->response_code = curl_getinfo($curl_handle, CURLINFO_HTTP_CODE);\n        $this->response_info = curl_getinfo($curl_handle);\n\n\n        // Clear the curl handle.\n        curl_close($curl_handle);\n\n\n        // If an error occurred, throw an Exception.\n        if (curl_errno($curl_handle)) {\n            throw new RequestCore_Exception(curl_error($curl_handle), curl_errno($curl_handle));\n        }\n\n\n        return $this->response_code;\n    }\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new RequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n\n\n    private function get_parsed_headers($headers) {\n        $response_headers = array();\n        $header_lines = explode(\"\\r\\n\", $headers);\n        foreach ($header_lines as $header_line) {\n            if (strpos($header_line, ':') !== false) {\n                list($header, $value) = explode(':', $header_line, 2);\n                $header = strtolower($header);\n                $value = trim($value);\n                if (isset($response_headers[$header])) {\n                    $response_headers[$header] .= ',' . $value;\n                } else {\n                    $response_headers[$header] = $value;\n                }\n            }\n        }\n        return $response_headers;\n    }\n}\n\n\nclass RequestCore_Exception extends Exception {}\n\n?>\n"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Create a PHP class that provides HTTP client functionality using cURL for making GET and POST requests, with error handling and resource management.\n\nClass Description: The HttpClient class encapsulates cURL functionality to perform HTTP requests. It includes methods for GET requests, POST requests, and POST requests with download capability. The class handles cURL initialization, option setting, execution, error checking, and resource cleanup.\n\nMethods:\n\nMethod1: getCurl(string $url) -> mixed - Performs a GET request to the specified URL and returns the response data. Throws an exception if cURL is not enabled.\n\nMethod2: postDownloadCurl(string $url, mixed $data) -> array - Performs a POST request with the given data to the specified URL, returns the response as a decoded JSON array. Throws an exception if cURL is not enabled.\n\nMethod3: postCurl(string $url, mixed $data) -> array - Performs a POST request with the given data to the specified URL, decrypts the response using Faveo private key, and returns it as a decoded JSON array. Throws an exception if cURL is not enabled.\n\nNote: All methods include error handling that returns error messages to the caller when exceptions occur. Each method follows proper cURL resource management by initializing, executing, and closing the cURL session.",
    "Canonical_solution": "use App\\Http\\Controllers\\Utility\\LibraryController as Utility;\nuse Exception;\n\nclass HttpClient\n{\n    public function getCurl($url)\n    {\n        try {\n            $curl = Utility::_isCurl();\n            if (!$curl) {\n                throw new Exception('Please enable your curl function to check latest update');\n            }\n            $ch = curl_init();\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_URL, $url);\n            if (curl_exec($ch) === false) {\n                echo 'Curl error: '.curl_error($ch);\n            }\n            $data = curl_exec($ch);\n            curl_close($ch);\n\n            return $data;\n        } catch (Exception $ex) {\n            return redirect()->back()->with('fails', $ex->getMessage());\n        }\n    }\n\n    public function postDownloadCurl($url, $data)\n    {\n        try {\n            $curl = Utility::_isCurl();\n            if (!$curl) {\n                throw new Exception('Please enable your curl function to check latest update');\n            }\n            $ch = curl_init();\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_URL, $url);\n            if (curl_exec($ch) === false) {\n                echo 'Curl error: '.curl_error($ch);\n            }\n            $data = curl_exec($ch);\n            curl_close($ch);\n\n            return json_decode($data, true);\n        } catch (Exception $ex) {\n            return redirect()->back()->with('fails', $ex->getMessage());\n        }\n    }\n\n    public function postCurl($url, $data)\n    {\n        try {\n            $curl = Utility::_isCurl();\n            if (!$curl) {\n                throw new Exception('Please enable your curl function to check latest update');\n            }\n            $ch = curl_init();\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_URL, $url);\n            if (curl_exec($ch) === false) {\n                echo 'Curl error: '.curl_error($ch);\n            }\n            $data = curl_exec($ch);\n            curl_close($ch);\n            $data = Utility::decryptByFaveoPrivateKey($data);\n\n            return json_decode($data, true);\n        } catch (Exception $ex) {\n            return redirect()->back()->with('fails', $ex->getMessage());\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass HttpClient\n{\n    public function getCurl(string $url): mixed\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function postDownloadCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n\n        return json_decode($response, true);\n    }\n\n\n    public function postCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\nclass HttpClient\n{\n    public function getCurl(string $url): mixed\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function postDownloadCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n        curl_close($ch);\n\n        return json_decode($response, true);\n\n\n    }\n\n\n    public function postCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\nclass HttpClient\n{\n    public function getCurl(string $url): mixed\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function postDownloadCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n\n        return json_decode($response, true);\n    }\n\n\n    public function postCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\nclass HttpClient\n{\n    public function getCurl(string $url): mixed\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function postDownloadCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n\n        return json_decode($response, true);\n    }\n\n\n    public function postCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n\n?>\n",
      "<?php\n\nclass HttpClient\n{\n    public function getCurl(string $url): mixed\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function postDownloadCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n\n        return json_decode($response, true);\n    }\n\n\n    public function postCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\nclass HttpClient\n{\n    public function getCurl(string $url): mixed\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function postDownloadCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n        curl_close($ch);\n\n        return json_decode($response, true);\n    }\n\n\n    public function postCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n        curl_close($ch);\n        return json_decode($response, true);\n\n    }\n}\n?>\n",
      "<?php\n\nclass HttpClient\n{\n    public function getCurl(string $url): mixed\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n\n    public function postDownloadCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n        curl_close($ch);\n\n        return json_decode($response, true);\n\n\n    }\n\n    public function postCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\nclass HttpClient\n{\n    public function getCurl(string $url): mixed\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function postDownloadCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n        curl_close($ch);\n\n        return json_decode($response, true);\n    }\n\n\n    public function postCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\nclass HttpClient\n{\n    public function getCurl(string $url): mixed\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function postDownloadCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n        curl_close($ch);\n\n        return json_decode($response, true);\n    }\n\n\n    public function postCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\nclass HttpClient\n{\n    public function getCurl(string $url): mixed\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function postDownloadCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n\n        return json_decode($response, true);\n    }\n\n\n    public function postCurl(string $url, mixed $data): array\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\Exception(\"cURL is not enabled.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new \\Exception(\"cURL Error: \" . $error);\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using cURL for making API requests to Facebook's various domains, with support for handling authentication, error management, and request configuration.\n\nClass Description: The BaseFacebook class provides core functionality for interacting with Facebook's APIs using cURL. It handles request construction, authentication, error handling, and includes utility methods for common operations. The class supports different Facebook domains and manages API credentials.\n\nAttributes:\n\nAttribute1: [array] - $CURL_OPTS - Default cURL options including timeout settings and user agent\nAttribute2: [array] - $DROP_QUERY_PARAMS - Query parameters to be removed from requests\nAttribute3: [array] - $DOMAIN_MAP - Mapping of Facebook API domains and their base URLs\nAttribute4: [string] - $appId - Facebook application ID\nAttribute5: [string] - $appSecret - Facebook application secret\nAttribute6: [mixed] - $user - Current authenticated user\nAttribute7: [mixed] - $signedRequest - Signed request data\nAttribute8: [mixed] - $state - Application state\nAttribute9: [string|null] - $accessToken - Current access token\nAttribute10: [bool] - $fileUploadSupport - Flag for file upload support\nAttribute11: [bool] - $trustForwarded - Flag for trusting forwarded headers\n\nMethods:\n\nMethod1: [makeRequest]($url, $params, $ch=null) -> [mixed] - Makes an HTTP request using cURL with the specified URL and parameters. Handles errors and SSL certificate verification.\nMethod2: [_oauthRequest]($url, $params) -> [mixed] - Makes an OAuth-authenticated request by adding access token and app secret proof to parameters before making the request.\nMethod3: [getAppSecretProof]($access_token) -> [string] - Generates an app secret proof using HMAC-SHA256 for the given access token.\nMethod4: [errorLog]($msg) -> [void] - Logs error messages, with special handling for CLI environments.",
    "Canonical_solution": "class BaseFacebook\n{\n    const VERSION = '3.2.2';\n    const SIGNED_REQUEST_ALGORITHM = 'HMAC-SHA256';\n\n    public static $CURL_OPTS = array(\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT        => 60,\n        CURLOPT_USERAGENT      => 'facebook-php-3.2',\n    );\n\n    protected static $DROP_QUERY_PARAMS = array(\n        'code',\n        'state',\n        'signed_request',\n    );\n\n    public static $DOMAIN_MAP = array(\n        'api'         => 'https://api.facebook.com/',\n        'api_video'   => 'https://api-video.facebook.com/',\n        'api_read'    => 'https://api-read.facebook.com/',\n        'graph'       => 'https://graph.facebook.com/',\n        'graph_video' => 'https://graph-video.facebook.com/',\n        'www'         => 'https://www.facebook.com/',\n    );\n\n    protected $appId;\n    protected $appSecret;\n    protected $user;\n    protected $signedRequest;\n    protected $state;\n    protected $accessToken = null;\n    protected $fileUploadSupport = false;\n    protected $trustForwarded = false;\n\n    protected function makeRequest($url, $params, $ch=null)\n    {\n        if (!$ch) {\n            $ch = curl_init();\n        }\n\n        $opts = self::$CURL_OPTS;\n        if ($this->getFileUploadSupport()) {\n            $opts[CURLOPT_POSTFIELDS] = $params;\n        } else {\n            $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n        }\n        $opts[CURLOPT_URL] = $url;\n\n        if (isset($opts[CURLOPT_HTTPHEADER])) {\n            $existing_headers = $opts[CURLOPT_HTTPHEADER];\n            $existing_headers[] = 'Expect:';\n            $opts[CURLOPT_HTTPHEADER] = $existing_headers;\n        } else {\n            $opts[CURLOPT_HTTPHEADER] = array('Expect:');\n        }\n\n        curl_setopt_array($ch, $opts);\n        $result = curl_exec($ch);\n\n        if (curl_errno($ch) == 60) {\n            self::errorLog('Invalid or no certificate authority found, using bundled information');\n            curl_setopt($ch, CURLOPT_CAINFO, dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n            $result = curl_exec($ch);\n        }\n\n        if ($result === false && empty($opts[CURLOPT_IPRESOLVE])) {\n            $matches = array();\n            $regex = '/Failed to connect to ([^:].*): Network is unreachable/';\n            if (preg_match($regex, curl_error($ch), $matches)) {\n                if (strlen(inet_pton($matches[1]) ?? '') === 16) {\n                    self::errorLog('Invalid IPv6 configuration on server, Please disable or get native IPv6 on your server.');\n                    self::$CURL_OPTS[CURLOPT_IPRESOLVE] = CURL_IPRESOLVE_V4;\n                    curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n                    $result = curl_exec($ch);\n                }\n            }\n        }\n\n        if ($result === false) {\n            $e = new FacebookApiException(array(\n                'error_code' => curl_errno($ch),\n                'error' => array(\n                    'message' => curl_error($ch),\n                    'type' => 'CurlException',\n                ),\n            ));\n            curl_close($ch);\n            throw $e;\n        }\n        curl_close($ch);\n        return $result;\n    }\n\n    protected function _oauthRequest($url, $params)\n    {\n        if (!isset($params['access_token'])) {\n            $params['access_token'] = $this->getAccessToken();\n        }\n\n        if (isset($params['access_token'])) {\n            $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n        }\n\n        foreach ($params as $key => $value) {\n            if (!is_string($value)) {\n                $params[$key] = json_encode($value);\n            }\n        }\n\n        return $this->makeRequest($url, $params);\n    }\n\n    protected function getAppSecretProof($access_token)\n    {\n        return hash_hmac('sha256', $access_token, $this->getAppSecret());\n    }\n\n    protected static function errorLog($msg)\n    {\n        if (php_sapi_name() != 'cli') {\n            error_log($msg);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass BaseFacebook {\n    protected $CURL_OPTS = array(\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT        => 60,\n        CURLOPT_USERAGENT      => 'facebook-php-5.0.0',\n    );\n    protected $DROP_QUERY_PARAMS = array('code', 'state', 'signed_request');\n    protected $DOMAIN_MAP = array(\n        'api'         => 'https://api.facebook.com/',\n        'api_read'    => 'https://api-read.facebook.com/',\n        'api_video'   => 'https://api-video.facebook.com/',\n        'graph'       => 'https://graph.facebook.com/',\n        'graph_video' => 'https://graph-video.facebook.com/',\n        'www'         => 'https://www.facebook.com/',\n    );\n    protected $appId;\n    protected $appSecret;\n    protected $user;\n    protected $signedRequest;\n    protected $state;\n    protected $accessToken = null;\n    protected $fileUploadSupport = false;\n    protected $trustForwarded = false;\n\n    public function makeRequest($url, $params, $ch=null) {\n        if (!$ch) {\n            $ch = curl_init();\n        }\n        $opts = $this->CURL_OPTS;\n        $opts[CURLOPT_POST] = count($params) > 0;\n        $opts[CURLOPT_URL] = $url;\n        if ($opts[CURLOPT_POST]) {\n            $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n        }\n        curl_setopt_array($ch, $opts);\n        $result = curl_exec($ch);\n        if (curl_errno($ch) == 60) {\n            self::errorLog('Invalid or no certificate authority found, using bundled information');\n            curl_setopt($ch, CURLOPT_CAINFO, dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n            $result = curl_exec($ch);\n        }\n        if ($result === false) {\n            $e = new FacebookApiException(array(\n                'error_code' => curl_errno($ch),\n                'error'      => array(\n                    'message' => curl_error($ch),\n                    'type'    => 'CurlException',\n                ),\n            ));\n            curl_close($ch);\n            throw $e;\n        }\n        curl_close($ch);\n        return $result;\n    }\n\n    protected function _oauthRequest($url, $params) {\n        if (!isset($params['access_token'])) {\n            $params['access_token'] = $this->getAccessToken();\n        }\n        if (isset($params['access_token'])) {\n            $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n        }\n        return $this->makeRequest($url, $params);\n    }\n\n    protected function getAppSecretProof($access_token) {\n        return hash_hmac('sha256', $access_token, $this->appSecret);\n    }\n\n    protected static function errorLog($msg) {\n        if (php_sapi_name() != 'cli') {\n            error_log($msg);\n        }\n    }\n}\n?>\n",
      "<?php\nclass BaseFacebook {\n    protected $CURL_OPTS = array(\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT        => 60,\n        CURLOPT_USERAGENT      => 'facebook-php-5.0.0',\n    );\n    protected $DROP_QUERY_PARAMS = array(\n        'code',\n        'state',\n        'signed_request',\n    );\n    protected $DOMAIN_MAP = array(\n        'api'         => 'https://api.facebook.com/',\n        'api_video'   => 'https://api-video.facebook.com/',\n        'api_read'    => 'https://api-read.facebook.com/',\n        'graph'       => 'https://graph.facebook.com/',\n        'graph_video' => 'https://graph-video.facebook.com/',\n        'www'         => 'https://www.facebook.com/',\n    );\n    protected $appId;\n    protected $appSecret;\n    protected $user;\n    protected $signedRequest;\n    protected $state;\n    protected $accessToken = null;\n    protected $fileUploadSupport = false;\n    protected $trustForwarded = false;\n\n    public function makeRequest($url, $params, $ch=null) {\n        if (!$ch) {\n            $ch = curl_init();\n        }\n        $opts = $this->CURL_OPTS;\n        $opts[CURLOPT_POST] = count($params) > 0;\n        $opts[CURLOPT_URL] = $url;\n        if ($opts[CURLOPT_POST]) {\n            $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n        }\n        curl_setopt_array($ch, $opts);\n        $result = curl_exec($ch);\n        if (curl_errno($ch) == 60) {\n            self::errorLog('Invalid or no certificate authority found, using bundled information');\n            curl_setopt($ch, CURLOPT_CAINFO, dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n            $result = curl_exec($ch);\n        }\n        if ($result === false) {\n            $e = new Exception(array(\n                'error_code' => curl_errno($ch),\n                'error'      => array(\n                    'message' => curl_error($ch),\n                    'type'    => 'CurlException',\n                ),\n            ));\n            curl_close($ch);\n            throw $e;\n        }\n        curl_close($ch);\n        return $result;\n    }\n\n    protected function _oauthRequest($url, $params) {\n        if (!isset($params['access_token'])) {\n            $params['access_token'] = $this->getAccessToken();\n        }\n        if (isset($params['access_token'])) {\n            $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n        }\n        return $this->makeRequest($url, $params);\n    }\n\n    protected function getAppSecretProof($access_token) {\n        return hash_hmac('sha256', $access_token, $this->appSecret);\n    }\n\n    protected static function errorLog($msg) {\n        if (php_sapi_name() != 'cli') {\n            error_log($msg);\n        }\n    }\n\n\n    public function getAccessToken(){\n        return $this->accessToken;\n    }\n}\n?>\n",
      "<?php\nclass BaseFacebook {\n  protected $CURL_OPTS = array(\n    CURLOPT_CONNECTTIMEOUT => 10,\n    CURLOPT_RETURNTRANSFER => true,\n    CURLOPT_TIMEOUT        => 60,\n    CURLOPT_USERAGENT      => 'facebook-php-5.0.0',\n  );\n\n  protected $DROP_QUERY_PARAMS = array(\n    'code',\n    'state',\n    'signed_request',\n  );\n\n  protected $DOMAIN_MAP = array(\n    'api'         => 'https://api.facebook.com/',\n    'api_video'   => 'https://api-video.facebook.com/',\n    'api_read'    => 'https://api-read.facebook.com/',\n    'graph'       => 'https://graph.facebook.com/',\n    'graph_video' => 'https://graph-video.facebook.com/',\n    'www'         => 'https://www.facebook.com/',\n  );\n\n  protected $appId;\n  protected $appSecret;\n  protected $user;\n  protected $signedRequest;\n  protected $state;\n  protected $accessToken = null;\n  protected $fileUploadSupport = false;\n  protected $trustForwarded = false;\n\n\n  public function makeRequest($url, $params, $ch=null) {\n    if (!$ch) {\n      $ch = curl_init();\n    }\n\n    $opts = $this->CURL_OPTS;\n    if ($this->fileUploadSupport) {\n      $opts[CURLOPT_POSTFIELDS] = $params;\n    } else {\n      $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n    }\n    $opts[CURLOPT_URL] = $url;\n\n    // disable the 'Expect: 100-continue' behaviour. This causes CURL to wait\n    // for 2 seconds if the server does not support this header.\n    if (isset($opts[CURLOPT_HTTPHEADER])) {\n      $existing_headers = $opts[CURLOPT_HTTPHEADER];\n      $existing_headers[] = 'Expect:';\n      $opts[CURLOPT_HTTPHEADER] = $existing_headers;\n    } else {\n      $opts[CURLOPT_HTTPHEADER] = array('Expect:');\n    }\n\n    curl_setopt_array($ch, $opts);\n    $result = curl_exec($ch);\n\n    if (curl_errno($ch) == 60) {\n      self::errorLog('Invalid or no certificate authority found, using bundled information');\n      curl_setopt($ch, CURLOPT_CAINFO,\n                  dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n      $result = curl_exec($ch);\n    }\n\n    if ($result === false) {\n      $e = new FacebookApiException(array(\n        'error_code' => curl_errno($ch),\n        'error'      => array(\n          'message' => curl_error($ch),\n          'type'    => 'CurlException',\n        ),\n      ));\n      curl_close($ch);\n      throw $e;\n    }\n    curl_close($ch);\n    return $result;\n  }\n\n  protected function _oauthRequest($url, $params) {\n    if (!isset($params['access_token'])) {\n      $params['access_token'] = $this->getAccessToken();\n    }\n\n    if (isset($params['access_token'])) {\n      $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n    }\n\n    return $this->makeRequest($url, $params);\n  }\n\n\n  protected function getAppSecretProof($access_token) {\n    return hash_hmac('sha256', $access_token, $this->appSecret);\n  }\n\n  protected static function errorLog($msg) {\n    // error_log is not safe to call from a CLI script due to a bug in PHP\n    // which makes error_log() die.\n    if (php_sapi_name() != 'cli') {\n      error_log($msg);\n    }\n  }\n}\n?>\n",
      "<?php\nclass BaseFacebook {\n    protected $CURL_OPTS = array(\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT        => 60,\n        CURLOPT_USERAGENT      => 'facebook-php-5.0.0',\n    );\n    protected $DROP_QUERY_PARAMS = array('code', 'state', 'signed_request');\n    protected $DOMAIN_MAP = array(\n        'api'         => 'https://api.facebook.com/',\n        'api_read'    => 'https://api-read.facebook.com/',\n        'graph'       => 'https://graph.facebook.com/',\n        'graph_video' => 'https://graph-video.facebook.com/',\n        'www'         => 'https://www.facebook.com/',\n    );\n    protected $appId;\n    protected $appSecret;\n    protected $user;\n    protected $signedRequest;\n    protected $state;\n    protected $accessToken = null;\n    protected $fileUploadSupport = false;\n    protected $trustForwarded = false;\n\n    public function makeRequest($url, $params, $ch=null) {\n        if (!$ch) {\n            $ch = curl_init();\n        }\n        $opts = $this->CURL_OPTS;\n        $opts[CURLOPT_POST] = count($params) > 0;\n        $opts[CURLOPT_URL] = $url;\n        if ($opts[CURLOPT_POST]) {\n            $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n        }\n        curl_setopt_array($ch, $opts);\n        $result = curl_exec($ch);\n        if (curl_errno($ch) == 60) {\n            self::errorLog('Invalid or no certificate authority found, using bundled information');\n            curl_setopt($ch, CURLOPT_CAINFO, dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n            $result = curl_exec($ch);\n        }\n        if ($result === false) {\n            $e = new FacebookApiException(array(\n                'error_code' => curl_errno($ch),\n                'error'      => array(\n                    'message' => curl_error($ch),\n                    'type'    => 'CurlException',\n                ),\n            ));\n            curl_close($ch);\n            throw $e;\n        }\n        curl_close($ch);\n        return $result;\n    }\n\n    protected function _oauthRequest($url, $params) {\n        if (!isset($params['access_token'])) {\n            $params['access_token'] = $this->getAccessToken();\n        }\n        if (isset($params['access_token'])) {\n            $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n        }\n        return $this->makeRequest($url, $params);\n    }\n\n    protected function getAppSecretProof($access_token) {\n        return hash_hmac('sha256', $access_token, $this->appSecret);\n    }\n\n    protected static function errorLog($msg) {\n        if (php_sapi_name() != 'cli') {\n            error_log($msg);\n        }\n    }\n}\n?>\n",
      "<?php\nclass BaseFacebook {\n    protected $CURL_OPTS = array(\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT        => 60,\n        CURLOPT_USERAGENT      => 'facebook-php-5.0.0',\n    );\n    protected $DROP_QUERY_PARAMS = array('code', 'state', 'signed_request');\n    protected $DOMAIN_MAP = array(\n        'api'         => 'https://api.facebook.com/',\n        'api_read'    => 'https://api-read.facebook.com/',\n        'api_video'   => 'https://api-video.facebook.com/',\n        'graph'       => 'https://graph.facebook.com/',\n        'graph_video' => 'https://graph-video.facebook.com/',\n        'www'         => 'https://www.facebook.com/',\n    );\n    protected $appId;\n    protected $appSecret;\n    protected $user;\n    protected $signedRequest;\n    protected $state;\n    protected $accessToken = null;\n    protected $fileUploadSupport = false;\n    protected $trustForwarded = false;\n\n    public function makeRequest($url, $params, $ch=null) {\n        if (!$ch) {\n            $ch = curl_init();\n        }\n        $opts = $this->CURL_OPTS;\n        $opts[CURLOPT_POST] = count($params);\n        $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n        $opts[CURLOPT_URL] = $url;\n\n        // disable the 'Expect: 100-continue' behaviour. This causes CURL to wait\n        // for 2 seconds if the server does not support this header.\n        if (isset($opts[CURLOPT_HTTPHEADER])) {\n            $existing_headers = $opts[CURLOPT_HTTPHEADER];\n            $existing_headers[] = 'Expect:';\n            $opts[CURLOPT_HTTPHEADER] = $existing_headers;\n        } else {\n            $opts[CURLOPT_HTTPHEADER] = array('Expect:');\n        }\n        curl_setopt_array($ch, $opts);\n        $result = curl_exec($ch);\n\n        if (curl_errno($ch) == 60) {  // CURLE_SSL_CACERT\n            self::errorLog('Invalid or no certificate authority found, using bundled information');\n            curl_setopt($ch, CURLOPT_CAINFO, dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n            $result = curl_exec($ch);\n        }\n\n        if ($result === false) {\n            $e = new FacebookApiException(array(\n                'error_code' => curl_errno($ch),\n                'error'      => array(\n                    'message' => curl_error($ch),\n                    'type'    => 'CurlException',\n                ),\n            ));\n            curl_close($ch);\n            throw $e;\n        }\n        curl_close($ch);\n        return $result;\n    }\n\n    protected function _oauthRequest($url, $params) {\n        if (!isset($params['access_token'])) {\n            $params['access_token'] = $this->getAccessToken();\n        }\n        if (isset($params['access_token'])) {\n            $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n        }\n        return $this->makeRequest($url, $params);\n    }\n\n    protected function getAppSecretProof($access_token) {\n        return hash_hmac('sha256', $access_token, $this->appSecret);\n    }\n\n    protected static function errorLog($msg) {\n        // This is also a good place to put an error log\n        if (php_sapi_name() == 'cli') {\n            error_log($msg);\n        } else {\n            error_log($msg);\n        }\n    }\n\n    public function getAccessToken(){\n        return $this->accessToken;\n    }\n}\n?>\n",
      "<?php\nclass BaseFacebook {\n    protected $CURL_OPTS = array(\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT        => 60,\n        CURLOPT_USERAGENT      => 'facebook-php-5.0.0',\n    );\n    protected $DROP_QUERY_PARAMS = array(\n        'code',\n        'state',\n        'signed_request',\n    );\n    protected $DOMAIN_MAP = array(\n        'api'         => 'https://api.facebook.com/',\n        'api_video'   => 'https://api-video.facebook.com/',\n        'api_read'    => 'https://api-read.facebook.com/',\n        'graph'       => 'https://graph.facebook.com/',\n        'graph_video' => 'https://graph-video.facebook.com/',\n        'www'         => 'https://www.facebook.com/',\n    );\n    protected $appId;\n    protected $appSecret;\n    protected $user;\n    protected $signedRequest;\n    protected $state;\n    protected $accessToken = null;\n    protected $fileUploadSupport = false;\n    protected $trustForwarded = false;\n\n\n    public function makeRequest($url, $params, $ch=null) {\n        if (!$ch) {\n            $ch = curl_init();\n        }\n        $opts = $this->CURL_OPTS;\n        $opts[CURLOPT_POST] = count($params) > 0;\n        $opts[CURLOPT_URL] = $url;\n        if ($opts[CURLOPT_POST]) {\n            $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n        }\n        curl_setopt_array($ch, $opts);\n        $result = curl_exec($ch);\n        if (curl_errno($ch) == 60) {\n            self::errorLog('Invalid or no certificate authority found, using bundled information');\n            curl_setopt($ch, CURLOPT_CAINFO, dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n            $result = curl_exec($ch);\n        }\n        if ($result === false) {\n            $e = new FacebookApiException(array(\n                'error_code' => curl_errno($ch),\n                'error'      => array(\n                    'message' => curl_error($ch),\n                    'type'    => 'CurlException',\n                ),\n            ));\n            curl_close($ch);\n            throw $e;\n        }\n        curl_close($ch);\n        return $result;\n    }\n\n    protected function _oauthRequest($url, $params) {\n        if (!isset($params['access_token'])) {\n            $params['access_token'] = $this->getAccessToken();\n        }\n        if (isset($params['access_token'])) {\n            $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n        }\n        return $this->makeRequest($url, $params);\n    }\n\n    protected function getAppSecretProof($access_token) {\n        return hash_hmac('sha256', $access_token, $this->appSecret);\n    }\n\n    protected static function errorLog($msg) {\n        if (php_sapi_name() != 'cli') {\n            error_log($msg);\n        }\n    }\n\n}\n?>\n",
      "<?php\nclass BaseFacebook {\n    protected $CURL_OPTS = array(\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT        => 60,\n        CURLOPT_USERAGENT      => 'facebook-php-5.0.0',\n    );\n    protected $DROP_QUERY_PARAMS = array(\n        'code',\n        'state',\n        'signed_request',\n    );\n    protected $DOMAIN_MAP = array(\n        'api'         => 'https://api.facebook.com/',\n        'api_video'   => 'https://api-video.facebook.com/',\n        'api_read'    => 'https://api-read.facebook.com/',\n        'graph'       => 'https://graph.facebook.com/',\n        'graph_video' => 'https://graph-video.facebook.com/',\n        'www'         => 'https://www.facebook.com/',\n    );\n    protected $appId;\n    protected $appSecret;\n    protected $user;\n    protected $signedRequest;\n    protected $state;\n    protected $accessToken = null;\n    protected $fileUploadSupport = false;\n    protected $trustForwarded = false;\n\n\n    public function makeRequest($url, $params, $ch=null) {\n        if (!$ch) {\n            $ch = curl_init();\n        }\n        $opts = $this->CURL_OPTS;\n        $opts[CURLOPT_POST] = count($params) > 0;\n        $opts[CURLOPT_URL] = $url;\n        if ($opts[CURLOPT_POST]) {\n            $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n        }\n        curl_setopt_array($ch, $opts);\n        $result = curl_exec($ch);\n        if (curl_errno($ch) == 60) {\n            self::errorLog('Invalid or no certificate authority found, using bundled information');\n            curl_setopt($ch, CURLOPT_CAINFO, dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n            $result = curl_exec($ch);\n        }\n        if ($result === false) {\n            $e = new FacebookApiException(array(\n                'error_code' => curl_errno($ch),\n                'error'      => array(\n                    'message' => curl_error($ch),\n                    'type'    => 'CurlException',\n                ),\n            ));\n            curl_close($ch);\n            throw $e;\n        }\n        curl_close($ch);\n        return $result;\n    }\n\n    protected function _oauthRequest($url, $params) {\n        if (!isset($params['access_token'])) {\n            $params['access_token'] = $this->getAccessToken();\n        }\n        if (isset($params['access_token'])) {\n            $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n        }\n        return $this->makeRequest($url, $params);\n    }\n\n    protected function getAppSecretProof($access_token) {\n        return hash_hmac('sha256', $access_token, $this->appSecret);\n    }\n\n    protected static function errorLog($msg) {\n        if (php_sapi_name() != 'cli') {\n            error_log($msg);\n        }\n    }\n\n}\n?>\n",
      "<?php\nclass BaseFacebook {\n  protected $CURL_OPTS = array(\n    CURLOPT_CONNECTTIMEOUT => 10,\n    CURLOPT_RETURNTRANSFER => true,\n    CURLOPT_TIMEOUT        => 60,\n    CURLOPT_USERAGENT      => 'facebook-php-5.0.0',\n  );\n  protected $DROP_QUERY_PARAMS = array(\n    'code',\n    'state',\n    'signed_request',\n  );\n  protected $DOMAIN_MAP = array(\n    'api'         => 'https://api.facebook.com/',\n    'api_read'    => 'https://api-read.facebook.com/',\n    'api_video'   => 'https://api-video.facebook.com/',\n    'graph'       => 'https://graph.facebook.com/',\n    'graph_video' => 'https://graph-video.facebook.com/',\n    'www'         => 'https://www.facebook.com/',\n  );\n  protected $appId;\n  protected $appSecret;\n  protected $user;\n  protected $signedRequest;\n  protected $state;\n  protected $accessToken = null;\n  protected $fileUploadSupport = false;\n  protected $trustForwarded = false;\n\n\n  public function makeRequest($url, $params, $ch=null) {\n    if (!$ch) {\n      $ch = curl_init();\n    }\n\n    $opts = $this->CURL_OPTS;\n    if ($this->fileUploadSupport) {\n      $opts[CURLOPT_POSTFIELDS] = $params;\n    } else {\n      $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n    }\n    $opts[CURLOPT_URL] = $url;\n\n    // disable the 'Expect: 100-continue' behaviour. This causes CURL to wait\n    // for 2 seconds if the server does not support this header.\n    if (isset($opts[CURLOPT_HTTPHEADER])) {\n      $existing_headers = $opts[CURLOPT_HTTPHEADER];\n      $existing_headers[] = 'Expect:';\n      $opts[CURLOPT_HTTPHEADER] = $existing_headers;\n    } else {\n      $opts[CURLOPT_HTTPHEADER] = array('Expect:');\n    }\n\n    curl_setopt_array($ch, $opts);\n    $result = curl_exec($ch);\n\n    if (curl_errno($ch) == 60) { // CURLE_SSL_CACERT\n      self::errorLog('Invalid or no certificate authority found, using bundled information');\n      curl_setopt($ch, CURLOPT_CAINFO,\n                  dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n      $result = curl_exec($ch);\n    }\n\n    if ($result === false) {\n      $e = new FacebookApiException(array(\n        'error_code' => curl_errno($ch),\n        'error'      => array(\n          'message' => curl_error($ch),\n          'type'    => 'CurlException',\n        ),\n      ));\n      curl_close($ch);\n      throw $e;\n    }\n    curl_close($ch);\n    return $result;\n  }\n\n  protected function _oauthRequest($url, $params) {\n    if (!isset($params['access_token'])) {\n      $params['access_token'] = $this->getAccessToken();\n    }\n\n    // add the app secret proof for internal apps\n    if ($this->getAppId() && $this->getAppSecret() && isset($params['access_token'])) {\n      $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n    }\n\n    return $this->makeRequest($url, $params);\n  }\n\n  protected function getAppSecretProof($access_token) {\n    return hash_hmac('sha256', $access_token, $this->getAppSecret());\n  }\n\n\n  protected static function errorLog($msg) {\n    // error_log is not safe to call from a CLI script due to a bug in PHP\n    // which makes it interact with the output buffer that normally gets\n    // implicitly cleaned up by PHP. This is a problem in our case because\n    // calls to errorLog() cause us to write output while gettting the\n    // results from a stream which is incompatible with the output\n    // buffering, leading to a broken output buffer and some crashes\n    if (php_sapi_name() != 'cli') {\n      error_log($msg);\n    }\n  }\n}\n?>\n",
      "<?php\nclass BaseFacebook {\n    protected $CURL_OPTS = array(\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT        => 60,\n        CURLOPT_USERAGENT      => 'facebook-php-5.0.0',\n    );\n    protected $DROP_QUERY_PARAMS = array(\n        'code',\n        'state',\n        'signed_request',\n    );\n    protected $DOMAIN_MAP = array(\n        'api'         => 'https://api.facebook.com/',\n        'api_video'   => 'https://api-video.facebook.com/',\n        'api_read'    => 'https://api-read.facebook.com/',\n        'graph'       => 'https://graph.facebook.com/',\n        'graph_video' => 'https://graph-video.facebook.com/',\n        'www'         => 'https://www.facebook.com/',\n    );\n    protected $appId;\n    protected $appSecret;\n    protected $user;\n    protected $signedRequest;\n    protected $state;\n    protected $accessToken = null;\n    protected $fileUploadSupport = false;\n    protected $trustForwarded = false;\n\n    public function makeRequest($url, $params, $ch=null) {\n        if (!$ch) {\n            $ch = curl_init();\n        }\n        $opts = $this->CURL_OPTS;\n        $opts[CURLOPT_POST] = count($params) > 0;\n        $opts[CURLOPT_URL] = $url;\n        if ($opts[CURLOPT_POST]) {\n            $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n        }\n        curl_setopt_array($ch, $opts);\n        $result = curl_exec($ch);\n        if (curl_errno($ch) == 60) {\n            self::errorLog('Invalid or no certificate authority found, using bundled information');\n            curl_setopt($ch, CURLOPT_CAINFO, dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n            $result = curl_exec($ch);\n        }\n        if ($result === false) {\n            $e = new Exception(array(\n                'error_code' => curl_errno($ch),\n                'error'      => array(\n                    'message' => curl_error($ch),\n                    'type'    => 'CurlException',\n                ),\n            ));\n            curl_close($ch);\n            throw $e;\n        }\n        curl_close($ch);\n        return $result;\n    }\n\n    protected function _oauthRequest($url, $params) {\n        if (!isset($params['access_token'])) {\n            $params['access_token'] = $this->getAccessToken();\n        }\n        if (isset($params['access_token'])) {\n            $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n        }\n        return $this->makeRequest($url, $params);\n    }\n\n    protected function getAppSecretProof($access_token) {\n        return hash_hmac('sha256', $access_token, $this->appSecret);\n    }\n\n    protected static function errorLog($msg) {\n        if (php_sapi_name() != 'cli') {\n            error_log($msg);\n        }\n    }\n\n    public function getAccessToken(){\n        return $this->accessToken;\n    }\n}\n?>\n",
      "<?php\nclass BaseFacebook {\n    protected $CURL_OPTS = array(\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT        => 60,\n        CURLOPT_USERAGENT      => 'facebook-php-5.0.0',\n    );\n    protected $DROP_QUERY_PARAMS = array(\n        'code',\n        'state',\n        'signed_request',\n    );\n    protected $DOMAIN_MAP = array(\n        'api'         => 'https://api.facebook.com/',\n        'api_read'    => 'https://api-read.facebook.com/',\n        'api_video'   => 'https://api-video.facebook.com/',\n        'graph'       => 'https://graph.facebook.com/',\n        'graph_video' => 'https://graph-video.facebook.com/',\n        'www'         => 'https://www.facebook.com/',\n    );\n    protected $appId;\n    protected $appSecret;\n    protected $user;\n    protected $signedRequest;\n    protected $state;\n    protected $accessToken = null;\n    protected $fileUploadSupport = false;\n    protected $trustForwarded = false;\n\n    public function makeRequest($url, $params, $ch=null) {\n        if (!$ch) {\n            $ch = curl_init();\n        }\n        $opts = $this->CURL_OPTS;\n        $opts[CURLOPT_POST] = count($params) > 0;\n        $opts[CURLOPT_URL] = $url;\n        if ($opts[CURLOPT_POST]) {\n            $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n        }\n        curl_setopt_array($ch, $opts);\n        $result = curl_exec($ch);\n        if (curl_errno($ch) == 60) {\n            self::errorLog('Invalid or no certificate authority found, using bundled information');\n            curl_setopt($ch, CURLOPT_CAINFO, dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n            $result = curl_exec($ch);\n        }\n        if ($result === false) {\n            $e = new FacebookApiException(array(\n                'error_code' => curl_errno($ch),\n                'error'      => array(\n                    'message' => curl_error($ch),\n                    'type'    => 'CurlException',\n                ),\n            ));\n            curl_close($ch);\n            throw $e;\n        }\n        curl_close($ch);\n        return $result;\n    }\n\n    protected function _oauthRequest($url, $params) {\n        if (!isset($params['access_token'])) {\n            $params['access_token'] = $this->getAccessToken();\n        }\n        if (isset($params['access_token'])) {\n            $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n        }\n        return $this->makeRequest($url, $params);\n    }\n\n    protected function getAppSecretProof($access_token) {\n        return hash_hmac('sha256', $access_token, $this->appSecret);\n    }\n\n    protected static function errorLog($msg) {\n        if (php_sapi_name() != 'cli') {\n            error_log($msg);\n        }\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Create a PHP class that handles HTTP POST requests to the Coinbase API using cURL, including setting necessary headers and handling the response.\n\nClass Description: The Coinbase class encapsulates functionality for making authenticated POST requests to the Coinbase API. It manages API configuration and provides a method for executing cURL requests with proper headers and timeout settings.\n\nAttributes:\n- config: [array] - Stores configuration parameters including the Coinbase API key\n\nMethods:\n- __construct([array $config]) -> [void] - Initializes the class with configuration parameters\n- _curlPost([string $url], [mixed $params = false]) -> [mixed] - Executes a cURL POST request to the specified URL with given parameters and returns the response\n\nNote: The _curlPost method is private as it's an internal implementation detail of the class. The method handles the full cURL lifecycle including initialization, option setting, execution, error handling (implied by timeout), and resource cleanup.",
    "Canonical_solution": "namespace App\\Payments;\n\nclass Coinbase {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    private function _curlPost($url, $params = false) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 0);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 300);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        curl_setopt(\n            $ch, CURLOPT_HTTPHEADER, \n            array(\n                'X-CC-Api-Key:' . $this->config['coinbase_api_key'], \n                'X-CC-Version: 2018-03-22'\n            )\n        );\n        $result = curl_exec($ch);\n        curl_close($ch);\n        return $result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Coinbase {\n\n    private $config;\n\n    public function __construct(array $config) {\n        $this->config = $config;\n    }\n\n    private function _curlPost(string $url, $params = false) {\n        $ch = curl_init();\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n\n        $options = [\n            CURLOPT_URL => $url,\n            CURLOPT_POST => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => 30,\n        ];\n\n        if ($params) {\n            $options[CURLOPT_POSTFIELDS] = json_encode($params);\n        }\n\n        curl_setopt_array($ch, $options);\n\n        $response = curl_exec($ch);\n\n        if(curl_errno($ch)) {\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n\n?>\n",
      "<?php\n\nclass Coinbase {\n\n    private $config;\n\n    public function __construct(array $config) {\n        $this->config = $config;\n    }\n\n\n    private function _curlPost(string $url, $params = false) {\n        $ch = curl_init();\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CB-ACCESS-KEY: ' . $this->config['apiKey'],\n        ];\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($params));\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n\n        $response = curl_exec($ch);\n\n        if(curl_errno($ch)) {\n            return false; \n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Coinbase {\n\n    private $config;\n\n    public function __construct(array $config) {\n        $this->config = $config;\n    }\n\n\n    private function _curlPost(string $url, $params = false) {\n        $ch = curl_init();\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CB-ACCESS-KEY: ' . $this->config['apiKey'],\n        ];\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($params));\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n\n        $response = curl_exec($ch);\n\n        if(curl_errno($ch)) {\n            return false; \n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Coinbase {\n\n    private $config;\n\n    public function __construct(array $config) {\n        $this->config = $config;\n    }\n\n\n    private function _curlPost(string $url, $params = false) {\n        $ch = curl_init();\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n\n        $options = [\n            CURLOPT_URL => $url,\n            CURLOPT_POST => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => 30,\n        ];\n\n        if ($params) {\n            $options[CURLOPT_POSTFIELDS] = json_encode($params);\n        }\n\n        curl_setopt_array($ch, $options);\n\n        $response = curl_exec($ch);\n\n        if(curl_errno($ch)) {\n            curl_close($ch);\n            return false; \n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n\n?>\n",
      "<?php\n\nclass Coinbase {\n\n    private $config;\n\n    public function __construct(array $config) {\n        $this->config = $config;\n    }\n\n\n    private function _curlPost(string $url, $params = false) {\n        $ch = curl_init();\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CB-ACCESS-KEY: ' . $this->config['apiKey'],\n        ];\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($params));\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n\n        $response = curl_exec($ch);\n\n        if(curl_errno($ch)) {\n            return false; \n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Coinbase {\n\n    private $config;\n\n    public function __construct(array $config) {\n        $this->config = $config;\n    }\n\n\n    private function _curlPost(string $url, $params = false) {\n        $ch = curl_init();\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CB-ACCESS-KEY: ' . $this->config['apiKey'],\n        ];\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($params));\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n\n        $response = curl_exec($ch);\n\n        if(curl_errno($ch)) {\n            return false; \n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Coinbase {\n\n    private $config;\n\n    public function __construct(array $config) {\n        $this->config = $config;\n    }\n\n\n    private function _curlPost(string $url, $params = false) {\n        $ch = curl_init();\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($params));\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n\n        $response = curl_exec($ch);\n\n        if(curl_errno($ch)) {\n            return false; \n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Coinbase {\n\n    private $config;\n\n    public function __construct(array $config) {\n        $this->config = $config;\n    }\n\n\n    private function _curlPost(string $url, $params = false) {\n        $ch = curl_init();\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CB-ACCESS-KEY: ' . $this->config['apiKey'],\n        ];\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($params));\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n\n        $response = curl_exec($ch);\n\n        if(curl_errno($ch)) {\n            return false; \n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Coinbase {\n\n    private $config;\n\n    public function __construct(array $config) {\n        $this->config = $config;\n    }\n\n\n    private function _curlPost(string $url, $params = false) {\n        $ch = curl_init();\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CB-ACCESS-KEY: ' . $this->config['apiKey'],\n        ];\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($params));\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n\n        $response = curl_exec($ch);\n\n        if(curl_errno($ch)) {\n            return false; \n        }\n\n        curl_close($ch);\n\n        return json_decode($response, true);\n    }\n}\n\n?>\n",
      "<?php\n\nclass Coinbase {\n\n    private $config;\n\n    public function __construct(array $config) {\n        $this->config = $config;\n    }\n\n\n    private function _curlPost(string $url, $params = false) {\n        $ch = curl_init();\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CB-ACCESS-KEY: ' . $this->config['apiKey'],\n        ];\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($params));\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n\n        $response = curl_exec($ch);\n\n        if(curl_errno($ch)) {\n            return false; \n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create a PHP function that makes an HTTP request using cURL with specific configurations for timeout, headers, and SSL verification.\n\nFunction Description: The function performs an HTTP GET request to a specified URL using PHP's cURL library. It includes custom configurations such as a user agent header, disabled SSL verification, and a connection timeout. The function returns the response content from the requested URL.\n\nInput: \n- $url (string): The URL to which the HTTP GET request will be made.\n\nOutput: \n- string: The content returned from the HTTP request. Returns false if the request fails.",
    "Canonical_solution": "function curl($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5000);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, array(\n        'User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4'\n    ));\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REDIR_PROTOCOLS, -1);\n    $contents = curl_exec($ch);\n    curl_close($ch);\n    return $contents;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a PHP class that interacts with the Coinbase API to handle payment processing using cURL for HTTP requests.\n\nClass Description: The Coinbase class implements the PaymentInterface and provides functionality to make POST requests to the Coinbase API. It handles API key authentication and request configuration.\n\nAttributes:\n- config: [array] - Stores the configuration settings including the Coinbase API key.\n\nMethods:\n- __construct($config): [void] - Initializes the class with the provided configuration.\n  - Input: $config [array] - Configuration array containing API credentials\n  - Output: None\n\n- _curlPost($url, $params = false): [mixed] - Makes a POST request to the specified URL with optional parameters.\n  - Input: \n    - $url [string] - The API endpoint URL\n    - $params [mixed|false] - Optional request payload parameters\n  - Output: [mixed] - The API response or false on failure",
    "Canonical_solution": "namespace App\\Payments;\n\nuse App\\Contracts\\PaymentInterface;\nuse App\\Exceptions\\ApiException;\n\nclass Coinbase implements PaymentInterface\n{\n    protected $config;\n    public function __construct($config)\n    {\n        $this->config = $config;\n    }\n\n    private function _curlPost($url, $params = false)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 0);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 300);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        curl_setopt(\n            $ch,\n            CURLOPT_HTTPHEADER,\n            array('X-CC-Api-Key:' . $this->config['coinbase_api_key'], 'X-CC-Version: 2018-03-22')\n        );\n        $result = curl_exec($ch);\n        curl_close($ch);\n        return $result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\ninterface PaymentInterface {}\n\nclass Coinbase implements PaymentInterface\n{\n    private $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n    }\n\n    private function _curlPost(string $url, $params = false)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        if ($params) {\n            $data_string = json_encode($params);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('Curl error: ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\ninterface PaymentInterface {}\n\nclass Coinbase implements PaymentInterface\n{\n    private $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n    }\n\n    private function _curlPost(string $url, $params = false)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        if ($params) {\n            $data_string = json_encode($params);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('Curl error: ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\ninterface PaymentInterface {}\n\nclass Coinbase implements PaymentInterface\n{\n    private $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n    }\n\n    private function _curlPost(string $url, $params = false)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        if ($params) {\n            $data_string = json_encode($params);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('Curl error: ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\ninterface PaymentInterface {}\n\nclass Coinbase implements PaymentInterface\n{\n    private $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n    }\n\n    private function _curlPost(string $url, $params = false)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n            'X-CC-Version: 2018-03-22' // Example version, update as needed\n        ];\n\n        if ($params) {\n            $data_string = json_encode($params);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string);\n            $headers[] = 'Content-Length: ' . strlen($data_string);\n        }\n\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        $result = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            error_log('Coinbase API Error: ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n\n        if ($httpCode >= 400) {\n            error_log('Coinbase API Error: HTTP Code ' . $httpCode . ' - ' . $result);\n            return false;\n        }\n\n        return json_decode($result, true);\n    }\n}\n?>\n",
      "<?php\n\ninterface PaymentInterface {}\n\nclass Coinbase implements PaymentInterface\n{\n    private $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n    }\n\n    private function _curlPost(string $url, $params = false)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        if ($params) {\n            $data_string = json_encode($params);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string);\n        }\n\n        $result = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('Curl error: ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return json_decode($result, true);\n    }\n}\n?>\n",
      "<?php\n\ninterface PaymentInterface {}\n\nclass Coinbase implements PaymentInterface\n{\n    private $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n    }\n\n    private function _curlPost(string $url, $params = false)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        if ($params) {\n            $data_string = json_encode($params);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('Coinbase API Error: ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\ninterface PaymentInterface {}\n\nclass Coinbase implements PaymentInterface\n{\n    private $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n    }\n\n    private function _curlPost(string $url, $params = false)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        if ($params) {\n            $data_string = json_encode($params);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string);\n        }\n\n        $result = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('Curl error: ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return json_decode($result, true);\n    }\n}\n?>\n",
      "<?php\n\ninterface PaymentInterface {}\n\nclass Coinbase implements PaymentInterface\n{\n    private $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n    }\n\n    private function _curlPost(string $url, $params = false)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        if ($params) {\n            $data_string = json_encode($params);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('Curl error: ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\ninterface PaymentInterface {}\n\nclass Coinbase implements PaymentInterface\n{\n    private $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n    }\n\n    private function _curlPost(string $url, $params = false)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        if ($params) {\n            $data_string = json_encode($params);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('Coinbase API Error: ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return json_decode($response, true);\n    }\n}\n?>\n",
      "<?php\n\ninterface PaymentInterface {}\n\nclass Coinbase implements PaymentInterface\n{\n    private $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n    }\n\n    private function _curlPost(string $url, $params = false)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n\n        $headers = [\n            'Content-Type: application/json',\n            'X-CC-Api-Key: ' . $this->config['apiKey'],\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        if ($params) {\n            $data_string = json_encode($params);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string);\n        }\n\n        $result = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('Curl error: ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return json_decode($result, true);\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Implement a class for interacting with a pretreatment API service that handles task processing and querying, using HTTP requests with Guzzle client in PHP.\n\nClass Description: The Pretreat class provides functionality to submit tasks for processing and query their status through an API service. It handles request signing, parameter preparation, and response processing.\n\nAttributes:\n\nAttribute1: Config $config - Configuration object containing service settings like timeout, service name, and endpoint URLs\n\nMethods:\n\nMethod1: __construct(Config $config) -> void - Initializes the Pretreat instance with configuration. Throws an exception if processNotifyUrl is not configured.\n\nMethod2: process(array $tasks, array $optionalParams = []) -> array - Submits tasks for processing. Takes an array of tasks and optional parameters, returns the API response as an associative array.\n\nMethod3: query(array $taskIds, string $path) -> array|bool - Queries the status of tasks by their IDs. Returns an array of tasks if successful, or false on failure.",
    "Canonical_solution": "namespace Upyun\\Api;\n\nuse GuzzleHttp\\Client;\nuse Upyun\\Config;\nuse Upyun\\Signature;\nuse Upyun\\Util;\n\nclass Pretreat\n{\n    protected $config;\n\n    public function __construct(Config $config)\n    {\n        if (!$config->processNotifyUrl) {\n            throw new \\Exception(\"should config prosessNotifyUrl first.\");\n        }\n        $this->config = $config;\n    }\n\n    public function process($tasks, $optionalParams = array())\n    {\n        $encodedTasks = Util::base64Json($tasks);\n\n        $client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n\n        $params = array(\n            'service' => $this->config->serviceName,\n            'notify_url' => $this->config->processNotifyUrl,\n            'tasks' => $encodedTasks,\n        );\n\n        $params = array_merge($params, $optionalParams);\n\n        $path = '/pretreatment/';\n        $method = 'POST';\n        $signedHeaders = Signature::getHeaderSign($this->config, $method, $path);\n\n        $url = $this->config->getPretreatEndPoint() . $path;\n        $response = $client->request($method, $url, [\n            'headers' => $signedHeaders,\n            'form_params' => $params\n        ]);\n\n        $body = $response->getBody()->getContents();\n        return json_decode($body, true);\n    }\n\n    public function query($taskIds, $path)\n    {\n        $client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n\n        $params = array(\n            'service' => $this->config->serviceName,\n            'task_ids' => implode(',', $taskIds)\n        );\n        $path = $path . '?' . http_build_query($params);\n\n        $method = 'GET';\n        $url = $this->config->getPretreatEndPoint() . $path;\n        $signedHeaders = Signature::getHeaderSign($this->config, $method, $path);\n        $response = $client->request($method, $url, [\n            'headers' => $signedHeaders\n        ]);\n\n        if ($response->getStatusCode() === 200) {\n            $body = $response->getBody()->getContents();\n            $result = json_decode($body, true);\n            if (is_array($result)) {\n                return $result['tasks'];\n            }\n        }\n        return false;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [
      "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass Pretreat\n{\n    private Client $client;\n    private array $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n\n        if (!isset($this->config['processNotifyUrl'])) {\n            throw new \\InvalidArgumentException(\"processNotifyUrl must be configured.\");\n        }\n\n        $this->client = new Client([\n            'timeout' => $this->config['timeout'] ?? 30,\n        ]);\n    }\n\n    public function process(array $tasks, array $optionalParams = []): array\n    {\n        $params = array_merge($optionalParams, [\n            'serviceName' => $this->config['serviceName'],\n            'tasks' => $tasks,\n            'processNotifyUrl' => $this->config['processNotifyUrl'],\n        ]);\n\n        try {\n            $response = $this->client->post($this->config['processUrl'], ['json' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            // Handle exception, log, or rethrow\n            throw new \\RuntimeException(\"API request failed: \" . $e->getMessage(), 0, $e);\n        }\n    }\n\n\n    public function query(array $taskIds, string $path): array|bool\n    {\n        $params = [\n            'serviceName' => $this->config['serviceName'],\n            'taskIds' => $taskIds,\n        ];\n\n        try {\n            $response = $this->client->get($this->config['queryUrl'] . $path, ['query' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            // Handle exception, log, or return false\n            return false;\n        }\n    }\n}\n\n```\n"
    ],
    "unmatched_results": [
      "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass Pretreat\n{\n    private Client $client;\n    private array $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'base_uri' => $this->config['service_endpoint'],\n            'timeout' => $this->config['timeout'],\n        ]);\n\n        if (!isset($this->config['process_notify_url'])) {\n            throw new \\InvalidArgumentException(\"processNotifyUrl must be configured.\");\n        }\n    }\n\n    public function process(array $tasks, array $optionalParams = []): array\n    {\n        $params = array_merge($optionalParams, [\n            'tasks' => $tasks,\n            'processNotifyUrl' => $this->config['process_notify_url'],\n        ]);\n\n        try {\n            $response = $this->client->post('process', ['json' => $params]);\n            return json_decode($response->getBody(), true);\n        } catch (GuzzleException $e) {\n            // Handle exception, log, and potentially rethrow or return an error response\n            error_log(\"Pretreat::process failed: \" . $e->getMessage());\n            return [];\n        }\n    }\n\n\n    public function query(array $taskIds, string $path): array|bool\n    {\n        try {\n            $response = $this->client->get($path, ['query' => ['taskIds' => $taskIds]]);\n            return json_decode($response->getBody(), true);\n        } catch (GuzzleException $e) {\n            // Handle exception, log, and return false\n            error_log(\"Pretreat::query failed: \" . $e->getMessage());\n            return false;\n        }\n    }\n}\n\n```\n",
      "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass Pretreat\n{\n    private Client $client;\n    private array $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n\n        if (!isset($this->config['processNotifyUrl'])) {\n            throw new \\InvalidArgumentException(\"processNotifyUrl must be configured.\");\n        }\n\n        $this->client = new Client([\n            'timeout' => $this->config['timeout'] ?? 30,\n        ]);\n    }\n\n    public function process(array $tasks, array $optionalParams = []): array\n    {\n        $params = array_merge($optionalParams, [\n            'serviceName' => $this->config['serviceName'],\n            'tasks' => $tasks,\n            'processNotifyUrl' => $this->config['processNotifyUrl'],\n        ]);\n\n        try {\n            $response = $this->client->post($this->config['processEndpoint'], ['json' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\RuntimeException(\"Failed to process tasks: \" . $e->getMessage(), 0, $e);\n        }\n    }\n\n\n    public function query(array $taskIds, string $path): array|bool\n    {\n        $params = [\n            'serviceName' => $this->config['serviceName'],\n            'taskIds' => $taskIds,\n        ];\n\n        try {\n            $response = $this->client->get($this->config['queryEndpoint'] . $path, ['query' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n}\n\n```\n",
      "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass Pretreat\n{\n    private Client $client;\n    private array $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n\n        if (!isset($this->config['processNotifyUrl'])) {\n            throw new \\InvalidArgumentException(\"processNotifyUrl must be configured.\");\n        }\n\n        $this->client = new Client([\n            'timeout' => $this->config['timeout'] ?? 30,\n        ]);\n    }\n\n    public function process(array $tasks, array $optionalParams = []): array\n    {\n        $params = array_merge($optionalParams, [\n            'serviceName' => $this->config['serviceName'],\n            'tasks' => $tasks,\n            'processNotifyUrl' => $this->config['processNotifyUrl'],\n        ]);\n\n        try {\n            $response = $this->client->post($this->config['processEndpoint'], ['json' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\RuntimeException(\"Failed to process tasks: \" . $e->getMessage(), 0, $e);\n        }\n    }\n\n\n    public function query(array $taskIds, string $path): array|bool\n    {\n        $params = [\n            'serviceName' => $this->config['serviceName'],\n            'taskIds' => $taskIds\n        ];\n\n        try {\n            $response = $this->client->get($this->config['queryEndpoint'] . $path, ['query' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n}\n\n```\n",
      "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass Pretreat\n{\n    private Client $client;\n    private array $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n\n        if (!isset($this->config['processNotifyUrl'])) {\n            throw new \\InvalidArgumentException(\"processNotifyUrl must be configured.\");\n        }\n\n        $this->client = new Client([\n            'timeout' => $this->config['timeout'] ?? 30,\n        ]);\n    }\n\n    public function process(array $tasks, array $optionalParams = []): array\n    {\n        $params = array_merge($optionalParams, [\n            'serviceName' => $this->config['serviceName'],\n            'tasks' => $tasks,\n            'processNotifyUrl' => $this->config['processNotifyUrl'],\n        ]);\n\n        try {\n            $response = $this->client->post($this->config['processUrl'], ['json' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\RuntimeException(\"Failed to process tasks: \" . $e->getMessage(), 0, $e);\n        }\n    }\n\n\n    public function query(array $taskIds, string $path): array|bool\n    {\n        $params = [\n            'serviceName' => $this->config['serviceName'],\n            'taskIds' => $taskIds\n        ];\n\n        try {\n            $response = $this->client->get($this->config['queryUrl'] . $path, ['query' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n}\n\n```\n",
      "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass Pretreat\n{\n    private Client $client;\n    private array $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'timeout' => $this->config['timeout'] ?? 30,\n            'base_uri' => $this->config['base_uri'],\n        ]);\n\n        if (!isset($this->config['processNotifyUrl'])) {\n            throw new \\InvalidArgumentException(\"processNotifyUrl must be configured.\");\n        }\n    }\n\n    public function process(array $tasks, array $optionalParams = []): array\n    {\n        $params = array_merge($optionalParams, [\n            'serviceName' => $this->config['serviceName'],\n            'tasks' => $tasks,\n            'processNotifyUrl' => $this->config['processNotifyUrl'],\n        ]);\n\n        try {\n            $response = $this->client->post('process', ['json' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\RuntimeException(\"Failed to process tasks: \" . $e->getMessage(), 0, $e);\n        }\n    }\n\n\n    public function query(array $taskIds, string $path): array|bool\n    {\n        try {\n            $response = $this->client->get($path, ['query' => ['taskIds' => $taskIds]]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n}\n\n```\n",
      "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass Pretreat\n{\n    private Client $client;\n    private array $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'base_uri' => $this->config['service_endpoint'],\n            'timeout' => $this->config['timeout'],\n        ]);\n\n        if (!isset($this->config['process_notify_url'])) {\n            throw new \\InvalidArgumentException(\"processNotifyUrl must be configured.\");\n        }\n    }\n\n    public function process(array $tasks, array $optionalParams = []): array\n    {\n        $params = array_merge($optionalParams, [\n            'tasks' => $tasks,\n            'processNotifyUrl' => $this->config['process_notify_url'],\n        ]);\n\n        try {\n            $response = $this->client->post('process', ['json' => $params]);\n            return json_decode($response->getBody(), true);\n        } catch (GuzzleException $e) {\n            // Handle exception, log, and potentially rethrow or return an error response\n            error_log(\"Pretreat::process failed: \" . $e->getMessage());\n            return ['error' => $e->getMessage()];\n        }\n    }\n\n\n    public function query(array $taskIds, string $path): array|bool\n    {\n        try {\n            $response = $this->client->get($path, ['query' => ['taskIds' => $taskIds]]);\n            return json_decode($response->getBody(), true);\n        } catch (GuzzleException $e) {\n            // Handle exception, log, and return false\n            error_log(\"Pretreat::query failed: \" . $e->getMessage());\n            return false;\n        }\n    }\n}\n\n```\n",
      "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass Pretreat\n{\n    private Client $client;\n    private array $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n\n        if (!isset($this->config['processNotifyUrl'])) {\n            throw new \\InvalidArgumentException(\"processNotifyUrl must be configured.\");\n        }\n\n        $this->client = new Client([\n            'timeout' => $this->config['timeout'] ?? 30,\n        ]);\n    }\n\n    public function process(array $tasks, array $optionalParams = []): array\n    {\n        $params = array_merge($optionalParams, [\n            'serviceName' => $this->config['serviceName'],\n            'tasks' => $tasks,\n            'processNotifyUrl' => $this->config['processNotifyUrl'],\n        ]);\n\n        try {\n            $response = $this->client->post($this->config['processUrl'], ['json' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\RuntimeException(\"Failed to process tasks: \" . $e->getMessage(), 0, $e);\n        }\n    }\n\n\n    public function query(array $taskIds, string $path): array|bool\n    {\n        $params = [\n            'serviceName' => $this->config['serviceName'],\n            'taskIds' => $taskIds\n        ];\n\n        try {\n            $response = $this->client->get($this->config['queryUrl'] . $path, ['query' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n}\n\n```\n",
      "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass Pretreat\n{\n    private Client $client;\n    private array $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n\n        if (!isset($this->config['processNotifyUrl'])) {\n            throw new \\InvalidArgumentException(\"processNotifyUrl must be configured.\");\n        }\n\n        $this->client = new Client([\n            'timeout' => $this->config['timeout'] ?? 30,\n        ]);\n    }\n\n    public function process(array $tasks, array $optionalParams = []): array\n    {\n        $params = array_merge($optionalParams, [\n            'serviceName' => $this->config['serviceName'],\n            'tasks' => $tasks,\n            'processNotifyUrl' => $this->config['processNotifyUrl'],\n        ]);\n\n        try {\n            $response = $this->client->post($this->config['processEndpoint'], ['json' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\RuntimeException(\"Failed to process tasks: \" . $e->getMessage(), 0, $e);\n        }\n    }\n\n\n    public function query(array $taskIds, string $path): array|bool\n    {\n        $params = [\n            'serviceName' => $this->config['serviceName'],\n            'taskIds' => $taskIds,\n        ];\n\n        try {\n            $response = $this->client->get($this->config['queryEndpoint'] . $path, ['query' => $params]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n}\n\n```\n",
      "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass Pretreat\n{\n    private Client $client;\n    private array $config;\n\n    public function __construct(array $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'base_uri' => $this->config['service_endpoint'],\n            'timeout' => $this->config['timeout'],\n        ]);\n\n        if (!isset($this->config['process_notify_url'])) {\n            throw new \\InvalidArgumentException(\"processNotifyUrl must be configured.\");\n        }\n    }\n\n    public function process(array $tasks, array $optionalParams = []): array\n    {\n        $params = array_merge($optionalParams, [\n            'tasks' => $tasks,\n            'processNotifyUrl' => $this->config['process_notify_url'],\n        ]);\n\n        try {\n            $response = $this->client->post('process', ['json' => $params]);\n            return json_decode($response->getBody(), true);\n        } catch (GuzzleException $e) {\n            // Handle exception, log, and potentially rethrow or return an error response\n            error_log(\"Pretreat::process failed: \" . $e->getMessage());\n            return ['error' => $e->getMessage()];\n        }\n    }\n\n\n    public function query(array $taskIds, string $path): array|bool\n    {\n        try {\n            $response = $this->client->get($path, ['query' => ['taskIds' => $taskIds]]);\n            return json_decode($response->getBody(), true);\n        } catch (GuzzleException $e) {\n            // Handle exception, log, and return false\n            error_log(\"Pretreat::query failed: \" . $e->getMessage());\n            return false;\n        }\n    }\n}\n\n```\n"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Create a PHP function that downloads a file from a specified URL and saves it to a local file using cURL.\n\nFunction Description: The function `http_fetch` uses PHP's cURL library to make an HTTP request to a specified URL and writes the response directly to a local file. It includes custom headers (User-Agent and Referer) to mimic a browser request and handles the cURL session lifecycle properly.\n\nInput:\n- `$url` (string): The URL of the resource to download\n- `$filename` (string): The local file path where the downloaded content should be saved\n\nOutput:\n- The function does not explicitly return a value, but it writes the downloaded content to the specified file\n- The cURL session information is captured in `$ret` but not returned (could be modified to return this if needed)",
    "Canonical_solution": "function http_fetch($url, $filename)\n{\n    $fh = fopen($filename, 'w');\n\n    $options = array(\n        CURLOPT_FILE    => $fh,\n        CURLOPT_TIMEOUT => 60,\n        CURLOPT_URL     => $url,\n    );\n\n    $options[CURLOPT_HTTPHEADER] = array(\n        'Referer: https://www.facebook.com/',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36',\n    );\n\n    $ch = curl_init();\n    curl_setopt_array($ch, $options);\n    curl_exec($ch);\n    $ret = curl_getinfo($ch);\n    curl_close($ch);\n\n    fclose($fh);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction http_fetch($url, $filename) {\n    $ch = curl_init($url);\n    $fp = fopen($filename, 'w');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    $ret = curl_exec($ch);\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction http_fetch($url, $filename) {\n    $ch = curl_init($url);\n    $fp = fopen($filename, 'w');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com');\n    $ret = curl_exec($ch);\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction http_fetch($url, $filename) {\n    $ch = curl_init($url);\n    $fp = fopen($filename, 'w');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    $ret = curl_exec($ch);\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction http_fetch($url, $filename) {\n    $ch = curl_init($url);\n    $fp = fopen($filename, 'w');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    $ret = curl_exec($ch);\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction http_fetch($url, $filename) {\n    $ch = curl_init($url);\n    $fp = fopen($filename, 'w');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com');\n    $ret = curl_exec($ch);\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction http_fetch($url, $filename) {\n    $ch = curl_init($url);\n    $fp = fopen($filename, 'w');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    $ret = curl_exec($ch);\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction http_fetch($url, $filename) {\n    $ch = curl_init($url);\n    $fp = fopen($filename, 'w');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com');\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    $ret = curl_exec($ch);\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction http_fetch($url, $filename) {\n    $ch = curl_init($url);\n    $fp = fopen($filename, 'w');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    $ret = curl_exec($ch);\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction http_fetch($url, $filename) {\n    $ch = curl_init($url);\n    $fp = fopen($filename, 'w');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    $ret = curl_exec($ch);\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction http_fetch($url, $filename) {\n    $ch = curl_init($url);\n    $fp = fopen($filename, 'w');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    $ret = curl_exec($ch);\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Implement a PHP class for sending notifications through the Pushover.net API using cURL for HTTP requests.\n\nClass Description: The Notifications_Pushover class implements push notification functionality through the Pushover.net service. It handles authentication, message formatting, and API communication to send notifications with different severity levels.\n\nAttributes:\n- token: string - The API token/key for Pushover.net authentication\n- user: string - The user key for Pushover.net authentication\n- priorities: static array - Mapping of priority levels to their string representations\n\nMethods:\n- __construct(string $token, string $user) -> void - Initializes the class with API credentials\n- static getName() -> string - Returns the service name \"pushover.net\"\n- static getParameters() -> array - Returns required configuration parameters for the service\n- notify(string $message, string $severity = 'info', ?string $event = null) -> void - Sends a notification with the given message, severity level, and optional event title",
    "Canonical_solution": "class Notifications_Pushover implements IPushNotification {\n    private $token;\n    private $user;\n    public function __construct($token, $user){\n        $this->token = $token;\n        $this->user = $user;\n    }\n    \n    static $priorities = array(\n        0 => 'info',\n        1 => 'warning',\n        2 => 'error',\n    );\n    \n    public static function getName(){\n        return \"pushover.net\";\n    }\n    \n    public static function getParameters(){\n        return array(\n            'token' => 'API Token/Key',\n            'user' => 'Your User Key',\n        );\n    }\n    \n    public function notify($message, $severity = 'info', $event = null){\n        curl_setopt_array($ch = curl_init(), array(\n            CURLOPT_URL => \"https://api.pushover.net/1/messages.json\",\n            CURLOPT_POST => true,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_POSTFIELDS => http_build_query($data = array(\n                \"token\" => $this->token,\n                \"user\" => $this->user,\n                \"message\" => $code = strip_tags(preg_replace('/<([\\/]?)span[^>]*>/i', '<\\1b>', $message), \"<b><i><u><a><font><p><br>\"),\n                \"title\" => strip_tags($event),\n                \"priority\" => (int)array_search($severity, self::$priorities),\n                \"timestamp\" => time(),\n                \"html\" => preg_match('/<[^>]+>/', $code),\n            )),\n        ));\n        curl_exec($ch);\n        curl_close($ch);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Notifications_Pushover\n{\n    private string $token;\n    private string $user;\n    private static array $priorities = [\n        'lowest' => -2,\n        'low' => -1,\n        'normal' => 0,\n        'high' => 1,\n        'emergency' => 2,\n    ];\n\n    public function __construct(string $token, string $user)\n    {\n        $this->token = $token;\n        $this->user = $user;\n    }\n\n    public static function getName(): string\n    {\n        return 'pushover.net';\n    }\n\n    public static function getParameters(): array\n    {\n        return [\n            'token' => 'Application API Token',\n            'user' => 'User Key',\n        ];\n    }\n\n    public function notify(string $message, string $severity = 'info', ?string $event = null): void\n    {\n        $priority = self::$priorities[$severity] ?? 0;\n\n        $data = [\n            'token' => $this->token,\n            'user' => $this->user,\n            'message' => $message,\n            'priority' => $priority,\n        ];\n\n        if ($event !== null) {\n            $data['title'] = $event;\n        }\n\n\n        $ch = curl_init('https://api.pushover.net/1/messages.json');\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_exec($ch);\n        curl_close($ch);\n    }\n}\n\n?>\n",
      "<?php\n\nclass Notifications_Pushover\n{\n    private string $token;\n    private string $user;\n\n    private static array $priorities = [\n        'lowest' => -2,\n        'low' => -1,\n        'normal' => 0,\n        'high' => 1,\n        'emergency' => 2,\n    ];\n\n    public function __construct(string $token, string $user)\n    {\n        $this->token = $token;\n        $this->user = $user;\n    }\n\n    public static function getName(): string\n    {\n        return 'pushover.net';\n    }\n\n    public static function getParameters(): array\n    {\n        return [\n            'token' => 'Application Token',\n            'user' => 'User Key',\n        ];\n    }\n\n    public function notify(string $message, string $severity = 'info', ?string $event = null): void\n    {\n        $priority = self::$priorities[$severity] ?? 0;\n\n        $data = [\n            'token' => $this->token,\n            'user' => $this->user,\n            'message' => $message,\n            'priority' => $priority,\n        ];\n\n        if ($event !== null) {\n            $data['title'] = $event;\n        }\n\n        $ch = curl_init('https://api.pushover.net/1/messages.json');\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_exec($ch);\n        curl_close($ch);\n    }\n}\n\n?>\n",
      "<?php\n\nclass Notifications_Pushover\n{\n    private string $token;\n    private string $user;\n\n    private static array $priorities = [\n        'lowest' => -2,\n        'low' => -1,\n        'normal' => 0,\n        'high' => 1,\n        'emergency' => 2,\n    ];\n\n    public function __construct(string $token, string $user)\n    {\n        $this->token = $token;\n        $this->user = $user;\n    }\n\n    public static function getName(): string\n    {\n        return 'pushover.net';\n    }\n\n    public static function getParameters(): array\n    {\n        return [\n            'token' => 'Application API Token',\n            'user' => 'User Key',\n        ];\n    }\n\n    public function notify(string $message, string $severity = 'info', ?string $event = null): void\n    {\n        $priority = self::$priorities[$severity] ?? 0;\n\n        $data = [\n            'token' => $this->token,\n            'user' => $this->user,\n            'message' => $message,\n            'priority' => $priority,\n        ];\n\n        if ($event !== null) {\n            $data['title'] = $event;\n        }\n\n\n        $ch = curl_init('https://api.pushover.net/1/messages.json');\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n        curl_exec($ch);\n        curl_close($ch);\n    }\n}\n?>\n",
      "<?php\n\nclass Notifications_Pushover\n{\n    private $token;\n    private $user;\n    private static $priorities = [\n        'lowest' => -2,\n        'low' => -1,\n        'normal' => 0,\n        'high' => 1,\n        'emergency' => 2,\n    ];\n\n    public function __construct(string $token, string $user)\n    {\n        $this->token = $token;\n        $this->user = $user;\n    }\n\n    public static function getName(): string\n    {\n        return 'pushover.net';\n    }\n\n    public static function getParameters(): array\n    {\n        return [\n            'token' => 'Application API Token',\n            'user' => 'User Key',\n        ];\n    }\n\n    public function notify(string $message, string $severity = 'info', ?string $event = null): void\n    {\n        $priority = self::$priorities[$severity] ?? 0;\n\n        $data = [\n            'token' => $this->token,\n            'user' => $this->user,\n            'message' => $message,\n            'priority' => $priority,\n        ];\n\n        if ($event !== null) {\n            $data['title'] = $event;\n        }\n\n\n        $ch = curl_init('https://api.pushover.net/1/messages.json');\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_exec($ch);\n        curl_close($ch);\n    }\n}\n\n?>\n",
      "<?php\n\nclass Notifications_Pushover\n{\n    private string $token;\n    private string $user;\n\n    private static array $priorities = [\n        'lowest' => -2,\n        'low' => -1,\n        'normal' => 0,\n        'high' => 1,\n        'emergency' => 2,\n    ];\n\n\n    public function __construct(string $token, string $user)\n    {\n        $this->token = $token;\n        $this->user = $user;\n    }\n\n    public static function getName(): string\n    {\n        return 'pushover.net';\n    }\n\n    public static function getParameters(): array\n    {\n        return [\n            'token' => 'Application API Token',\n            'user' => 'User Key',\n        ];\n    }\n\n    public function notify(string $message, string $severity = 'info', ?string $event = null): void\n    {\n        $priority = self::$priorities[$severity] ?? 0;\n\n        $data = [\n            'token' => $this->token,\n            'user' => $this->user,\n            'message' => $message,\n            'priority' => $priority,\n        ];\n\n        if ($event !== null) {\n            $data['title'] = $event;\n        }\n\n\n        $ch = curl_init('https://api.pushover.net/1/messages.json');\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n        curl_exec($ch);\n        curl_close($ch);\n    }\n}\n?>\n",
      "<?php\n\nclass Notifications_Pushover\n{\n    private string $token;\n    private string $user;\n    private static array $priorities = [\n        'lowest' => -2,\n        'low' => -1,\n        'normal' => 0,\n        'high' => 1,\n        'emergency' => 2,\n    ];\n\n    public function __construct(string $token, string $user)\n    {\n        $this->token = $token;\n        $this->user = $user;\n    }\n\n    public static function getName(): string\n    {\n        return 'pushover.net';\n    }\n\n    public static function getParameters(): array\n    {\n        return [\n            'token' => 'Application API Token',\n            'user' => 'User Key',\n        ];\n    }\n\n    public function notify(string $message, string $severity = 'info', ?string $event = null): void\n    {\n        $priority = self::$priorities[$severity] ?? 0;\n\n        $data = [\n            'token' => $this->token,\n            'user' => $this->user,\n            'message' => $message,\n            'priority' => $priority,\n        ];\n\n        if ($event !== null) {\n            $data['title'] = $event;\n        }\n\n\n        $ch = curl_init('https://api.pushover.net/1/messages.json');\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_exec($ch);\n        curl_close($ch);\n    }\n}\n\n?>\n",
      "<?php\n\nclass Notifications_Pushover\n{\n    private string $token;\n    private string $user;\n\n    private static array $priorities = [\n        'lowest' => -2,\n        'low' => -1,\n        'normal' => 0,\n        'high' => 1,\n        'emergency' => 2,\n    ];\n\n    public function __construct(string $token, string $user)\n    {\n        $this->token = $token;\n        $this->user = $user;\n    }\n\n    public static function getName(): string\n    {\n        return 'pushover.net';\n    }\n\n    public static function getParameters(): array\n    {\n        return [\n            'token' => 'Application API Token',\n            'user' => 'User Key',\n        ];\n    }\n\n    public function notify(string $message, string $severity = 'info', ?string $event = null): void\n    {\n        $priority = self::$priorities[$severity] ?? 0;\n\n        $data = [\n            'token' => $this->token,\n            'user' => $this->user,\n            'message' => $message,\n            'priority' => $priority,\n        ];\n\n        if ($event !== null) {\n            $data['title'] = $event;\n        }\n\n        $ch = curl_init('https://api.pushover.net/1/messages.json');\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_exec($ch);\n        curl_close($ch);\n    }\n}\n\n?>\n",
      "<?php\n\nclass Notifications_Pushover\n{\n    private string $token;\n    private string $user;\n    private static array $priorities = [\n        'lowest' => -2,\n        'low' => -1,\n        'normal' => 0,\n        'high' => 1,\n        'emergency' => 2,\n    ];\n\n    public function __construct(string $token, string $user)\n    {\n        $this->token = $token;\n        $this->user = $user;\n    }\n\n    public static function getName(): string\n    {\n        return 'pushover.net';\n    }\n\n    public static function getParameters(): array\n    {\n        return [\n            'token' => 'Application API Token',\n            'user' => 'User Key',\n        ];\n    }\n\n    public function notify(string $message, string $severity = 'info', ?string $event = null): void\n    {\n        $priority = self::$priorities[$severity] ?? 0;\n\n        $data = [\n            'token' => $this->token,\n            'user' => $this->user,\n            'message' => $message,\n            'priority' => $priority,\n        ];\n\n        if ($event !== null) {\n            $data['title'] = $event;\n        }\n\n\n        $ch = curl_init('https://api.pushover.net/1/messages.json');\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n        curl_exec($ch);\n        curl_close($ch);\n    }\n}\n?>\n",
      "<?php\n\nclass Notifications_Pushover\n{\n    private string $token;\n    private string $user;\n    private static array $priorities = [\n        'lowest' => -2,\n        'low' => -1,\n        'normal' => 0,\n        'high' => 1,\n        'emergency' => 2,\n    ];\n\n    public function __construct(string $token, string $user)\n    {\n        $this->token = $token;\n        $this->user = $user;\n    }\n\n    public static function getName(): string\n    {\n        return 'pushover.net';\n    }\n\n    public static function getParameters(): array\n    {\n        return [\n            'token' => 'Application API Token',\n            'user' => 'User Key',\n        ];\n    }\n\n    public function notify(string $message, string $severity = 'info', ?string $event = null): void\n    {\n        $priority = self::$priorities[$severity] ?? 0;\n\n        $data = [\n            'token' => $this->token,\n            'user' => $this->user,\n            'message' => $message,\n            'priority' => $priority,\n        ];\n\n        if ($event !== null) {\n            $data['title'] = $event;\n        }\n\n\n        $ch = curl_init('https://api.pushover.net/1/messages.json');\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_exec($ch);\n        curl_close($ch);\n    }\n}\n\n?>\n",
      "<?php\n\nclass Notifications_Pushover\n{\n    private $token;\n    private $user;\n    private static $priorities = [\n        'lowest' => -2,\n        'low' => -1,\n        'normal' => 0,\n        'high' => 1,\n        'emergency' => 2,\n    ];\n\n    public function __construct(string $token, string $user)\n    {\n        $this->token = $token;\n        $this->user = $user;\n    }\n\n    public static function getName(): string\n    {\n        return 'pushover.net';\n    }\n\n    public static function getParameters(): array\n    {\n        return [\n            'token' => 'Application API Token',\n            'user' => 'User Key',\n        ];\n    }\n\n    public function notify(string $message, string $severity = 'info', ?string $event = null): void\n    {\n        $priority = self::$priorities[$severity] ?? 0;\n\n        $data = [\n            'token' => $this->token,\n            'user' => $this->user,\n            'message' => $message,\n            'priority' => $priority,\n        ];\n\n        if ($event !== null) {\n            $data['title'] = $event;\n        }\n\n\n        $ch = curl_init('https://api.pushover.net/1/messages.json');\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_exec($ch);\n        curl_close($ch);\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: The task involves creating PHP functions to interact with a logistics tracking API (kuaidi100.com) to retrieve shipping company information and tracking data for a given tracking number.\n\nFunction Description: The code consists of three functions that work together to:\n1. Identify the logistics company from a tracking number\n2. Retrieve tracking details for the shipment\n3. Generate random IP addresses for request headers\n\nInput: \n- For get_company(): A string representing the tracking number ($text)\n- For get_data(): Two strings - tracking number ($text) and company code ($com)\n- For Rand_IP(): No input parameters\n\nOutput:\n- get_company(): Returns a string representing the logistics company code\n- get_data(): Returns a JSON string containing the tracking information\n- Rand_IP(): Returns a string representing a randomly generated IP address\n\nMethods:\n1. get_company($text) -> string - Identifies the logistics company from a tracking number by making an HTTP request to kuaidi100.com's autocomplete API and extracting the company code from the response.\n2. get_data($text, $com) -> string - Retrieves tracking details for a given tracking number and company code by making an HTTP request to kuaidi100.com's query API.\n3. Rand_IP() -> string - Generates a random IP address to be used in request headers for bypassing potential IP-based restrictions.\n\nNote: The functions use cURL for HTTP requests with specific headers and options, including SSL verification disabled, custom user agent, and random IP addresses in headers to mimic browser requests.",
    "Canonical_solution": "function get_compary($text) {\n    $headerArray = array(\"Accept-Language: zh-CN,zh;q=0.8\",\"Cache-Control: no-cache\",\"Host:www.kuaidi100.com\",\"Referer:https://www.kuaidi100.com/\");\n    $curl = curl_init();\n    $url = \"https://www.kuaidi100.com/autonumber/autoComNum?resultv2=1&text=\".$text;\n    curl_setopt($curl, CURLOPT_URL, $url);\n    curl_setopt($curl, CURLOPT_HTTPHEADER, array('X-FORWARDED-FOR:'.Rand_IP(), 'CLIENT-IP:'.Rand_IP()));\n    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST,FALSE);\n    curl_setopt($curl, CURLOPT_USERAGENT,\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\");\n    curl_setopt($curl, CURLOPT_POST, 0);\n    curl_setopt($curl,CURLOPT_HTTPHEADER,$headerArray);\n    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n    $output = curl_exec($curl);\n    curl_close($curl);\n    preg_match_all('#\"comCode\":\"(.*?)\"#',$output,$match);\n    $company = $match[1][1];\n    return $company;\n}\n\nfunction get_data($text,$com) {\n    $rand = mt_rand(1111111111111111, 8888888888888888);\n    $temp =  '0.' . $rand;\n    $headerArray = array(\"Accept: application/json, text/javascript, */*; q=0.01\",\"Cache-Control: no-cache\",\"Host:www.kuaidi100.com\",\"Referer:https://www.kuaidi100.com/?from=openv\",\"Cookie: csrftoken=C8eAjWh2fyDqqOSMlSmKaJdMqtjW8iLLOIBsUmMsgHE; WWWID=WWW8A873C08880109D493D45E7B86FC5583; Hm_lvt_22ea01af58ba2be0fec7c11b25e88e6c=1574823124,1574827551; MOBID=B53E32216F579899AC3BF9579DF8E2C5; Hm_lpvt_22ea01af58ba2be0fec7c11b25e88e6c=1574827564\");\n    $curl = curl_init();\n    $url = \"https://www.kuaidi100.com/query?type=\".$com.\"&postid=\".$text.\"&temp=\".$temp.\"&phone=\";\n    curl_setopt($curl, CURLOPT_URL, $url);\n    curl_setopt($curl, CURLOPT_HTTPHEADER, array('X-FORWARDED-FOR:'.Rand_IP(), 'CLIENT-IP:'.Rand_IP()));\n    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST,FALSE);\n    curl_setopt($curl, CURLOPT_USERAGENT,\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\");\n    curl_setopt($curl, CURLOPT_POST, 0);\n    curl_setopt($curl,CURLOPT_HTTPHEADER,$headerArray);\n    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n    $output = curl_exec($curl);\n    curl_close($curl);\n    return $output;\n}\n\nfunction Rand_IP() {\n    $ip2id= round(rand(600000, 2550000) / 10000);\n    $ip3id= round(rand(600000, 2550000) / 10000);\n    $ip4id= round(rand(600000, 2550000) / 10000);\n    $arr_1 = array(\"218\",\"218\",\"66\",\"66\",\"218\",\"218\",\"60\",\"60\",\"202\",\"204\",\"66\",\"66\",\"66\",\"59\",\"61\",\"60\",\"222\",\"221\",\"66\",\"59\",\"60\",\"60\",\"66\",\"218\",\"218\",\"62\",\"63\",\"64\",\"66\",\"66\",\"122\",\"211\");\n    $randarr= mt_rand(0,count($arr_1)-1);\n    $ip1id = $arr_1[$randarr];\n    return $ip1id.\".\".$ip2id.\".\".$ip3id.\".\".$ip4id;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction get_company($text) {\n    $post_data = array(\n        'text' => $text\n    );\n    $url = 'https://www.kuaidi100.com/autonumber/autoComNum?resultv2=1&'.http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP()\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    $data = json_decode($output, true);\n    if (isset($data[0]['comCode'])) {\n        return $data[0]['comCode'];\n    } else {\n        return '';\n    }\n}\n\nfunction get_data($text, $com) {\n    $post_data = array(\n        'customer' => '',\n        'param' => '{\"com\":\"'.$com.'\",\"num\":\"'.$text.'\"}',\n        'sign' => '',\n    );\n    $url = 'https://www.kuaidi100.com/query?' . http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP()\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    return $output;\n}\n\nfunction Rand_IP(){\n    $ip2id= round(rand(600000, 2550000) / 10000); //第一种方法\n    $ip3id= round(rand(600000, 2550000) / 10000);\n    $ip4id= round(rand(600000, 2550000) / 10000);\n    //下面是第二种方法\n    $num1 = rand(0,255);\n    $num2 = rand(0,255);\n    $num3 = rand(0,255);\n    $num4 = rand(0,255);\n    Return $num1.\".\".$num2.\".\".$num3.\".\".$num4;\n}\n?>\n",
      "<?php\nfunction get_company($text) {\n    $post_data = array(\n        'text' => $text\n    );\n    $url = 'https://www.kuaidi100.com/autonumber/autoComNum?resultv2=1&'.http_build_query($post_data);\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36');\n    $output = curl_exec($ch);\n    curl_close($ch);\n    $result = json_decode($output, true);\n    if (isset($result['auto']) && is_array($result['auto']) && !empty($result['auto'])) {\n        return $result['auto'][0]['comCode'];\n    } else {\n        return '';\n    }\n}\n\nfunction get_data($text, $com) {\n    $post_data = array(\n        'customer' => '', \n        'param' => json_encode(array('com' => $com, 'num' => $text)),\n        'sign' => '',\n    );\n    $url = 'https://www.kuaidi100.com/query?' . http_build_query($post_data);\n    $header = array(\n        'CLIENT-IP:' . Rand_IP(),\n        'X-FORWARDED-FOR:' . Rand_IP(),\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36');\n    $output = curl_exec($ch);\n    curl_close($ch);\n    return $output;\n}\n\nfunction Rand_IP(){\n    srand(microtime(true));\n    return rand(1,255).\".\".rand(0,255).\".\".rand(0,255).\".\".rand(0,255);\n}\n?>\n",
      "<?php\nfunction get_company($text) {\n    $post_data = array(\n        'text' => $text\n    );\n    $url = 'https://www.kuaidi100.com/autonumber/autoComNum?resultv2=1&'.http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP()\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    $data = json_decode($output, true);\n    if (isset($data['auto']) && isset($data['auto'][0]) && isset($data['auto'][0]['comCode'])) {\n        return $data['auto'][0]['comCode'];\n    } else {\n        return '';\n    }\n}\n\nfunction get_data($text, $com) {\n    $post_data = array(\n        'customer' => '',\n        'param' => json_encode(array('com' => $com, 'num' => $text)),\n        'sign' => '',\n    );\n    $url = 'https://www.kuaidi100.com/query?' . http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP()\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    return $output;\n}\n\nfunction Rand_IP(){\n    $ip2id= round(rand(600000, 2550000) / 10000); //第一种方法，直接生成\n    $ip3id= round(rand(600000, 2550000) / 10000);\n    $ip4id= round(rand(600000, 2550000) / 10000);\n    return $ip2id.'.'.$ip3id.'.'.$ip4id;\n}\n?>\n",
      "<?php\nfunction get_company($text) {\n    $post_data = array(\n        'text' => $text\n    );\n    $url = 'https://www.kuaidi100.com/autonumber/autoComNum?resultv2=1&'.http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP()\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    $result = json_decode($output, true);\n    if (isset($result['auto']) && is_array($result['auto']) && !empty($result['auto'])) {\n        return $result['auto'][0]['comCode'];\n    } else {\n        return '';\n    }\n}\n\nfunction get_data($text, $com) {\n    $post_data = array(\n        'customer' => '',\n        'param' => json_encode(array('com' => $com, 'num' => $text)),\n        'sign' => '',\n    );\n    $url = 'https://www.kuaidi100.com/query?' . http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP()\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    return $output;\n}\n\nfunction Rand_IP(){\n    $ip2id= round(rand(600000, 2550000) / 10000); //第一种方法\n    $ip3id= round(rand(600000, 2550000) / 10000);\n    $ip4id= round(rand(600000, 2550000) / 10000);\n    return $ip2id.'.'.$ip3id.'.'.$ip4id;\n}\n?>\n",
      "<?php\nfunction get_company($text) {\n    $post_data = array(\n        'text' => $text\n    );\n    $url = 'https://www.kuaidi100.com/autonumber/autoComNum?resultv2=1&'.http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP()\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    $result = json_decode($output, true);\n    if (isset($result['auto']) && is_array($result['auto']) && !empty($result['auto'])) {\n        return $result['auto'][0]['comCode'];\n    } else {\n        return '';\n    }\n}\n\nfunction get_data($text, $com) {\n    $post_data = array(\n        'customer' => '', \n        'param' => json_encode(array('com' => $com, 'num' => $text)),\n        'sign' => '',\n        'key' => '' \n    );\n    $url = 'https://poll.kuaidi100.com/poll/query.do';\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP()\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($post_data));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    return $output;\n}\n\nfunction Rand_IP(){\n    $ip2id= round(rand(600000, 2550000) / 10000); \n    $ip3id= round(rand(600000, 2550000) / 10000); \n    $ip4id= round(rand(600000, 2550000) / 10000); \n    $arr_1 = array(\"218\",\"218\",\"66\",\"66\",\"218\",\"218\",\"60\",\"60\",\"202\",\"204\",\"66\",\"66\",\"66\",\"59\",\"61\",\"60\",\"222\",\"221\",\"66\",\"59\",\"60\",\"60\",\"66\",\"218\",\"218\",\"62\",\"63\",\"64\",\"66\",\"66\",\"122\",\"211\");\n    $randarr= mt_rand(0, count($arr_1)-1);\n    $ip1id = $arr_1[$randarr]; \n    return $ip1id.\".\".$ip2id.\".\".$ip3id.\".\".$ip4id;\n}\n?>\n",
      "<?php\nfunction get_company($text) {\n    $post_data = array(\n        'text' => $text\n    );\n    $url = 'https://www.kuaidi100.com/autonumber/autoComNum?resultv2=1&'.http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP(),\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    $data = json_decode($output, true);\n    if (isset($data[0]['comCode'])) {\n        return $data[0]['comCode'];\n    } else {\n        return '';\n    }\n}\n\nfunction get_data($text, $com) {\n    $post_data = array(\n        'customer' => '',\n        'param' => '{\"com\":\"'.$com.'\",\"num\":\"'.$text.'\"}',\n        'sign' => '',\n    );\n    $url = 'https://www.kuaidi100.com/query?' . http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP(),\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    return $output;\n}\n\nfunction Rand_IP(){\n    $ip2id= round(rand(600000, 2550000) / 10000); //第一种方法\n    $ip3id= round(rand(600000, 2550000) / 10000);\n    $ip4id= round(rand(600000, 2550000) / 10000);\n    //下面是第二种方法\n    $ip2id = round(rand(1,254));\n    $ip3id = round(rand(1,254));\n    $ip4id = round(rand(1,254));\n    return $ip2id.\".\".$ip3id.\".\".$ip4id;\n}\n?>\n",
      "<?php\nfunction get_company($text) {\n    $post_data = array(\n        'text' => $text\n    );\n    $url = 'https://www.kuaidi100.com/autonumber/autoComNum?resultv2=1&'.http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP(),\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    $result = json_decode($output, true);\n    if (isset($result['auto']) && is_array($result['auto']) && !empty($result['auto'])) {\n        return $result['auto'][0]['comCode'];\n    } else {\n        return '';\n    }\n}\n\nfunction get_data($text, $com) {\n    $post_data = array(\n        'customer' => '', \n        'param' => json_encode(array('com' => $com, 'num' => $text)),\n        'sign' => '',\n        'key' => '' \n    );\n    $url = 'https://poll.kuaidi100.com/poll/query.do';\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP(),\n        'Content-Type: application/x-www-form-urlencoded;charset=UTF-8'\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($post_data));\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    return $output;\n}\n\nfunction Rand_IP(){\n    $ip2id= round(rand(600000, 2550000) / 10000); \n    $ip3id= round(rand(600000, 2550000) / 10000); \n    $ip4id= round(rand(600000, 2550000) / 10000); \n    $arr_1 = array(\"218\",\"218\",\"66\",\"66\",\"218\",\"218\",\"60\",\"60\",\"202\",\"204\",\"66\",\"66\",\"66\",\"59\",\"61\",\"60\",\"222\",\"221\",\"66\",\"59\",\"60\",\"60\",\"66\",\"218\",\"218\",\"62\",\"63\",\"64\",\"66\",\"66\",\"122\",\"211\");\n    $randarr= mt_rand(0, count($arr_1)-1);\n    $ip1id = $arr_1[$randarr]; \n    return $ip1id.\".\".$ip2id.\".\".$ip3id.\".\".$ip4id;\n}\n?>\n",
      "<?php\nfunction get_company($text) {\n    $post_data = array(\n        'text' => $text\n    );\n    $url = 'https://www.kuaidi100.com/autonumber/autoComNum?resultv2=1&'.http_build_query($post_data);\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36');\n    $output = curl_exec($ch);\n    curl_close($ch);\n    $result = json_decode($output, true);\n    if (isset($result['auto']) && is_array($result['auto']) && !empty($result['auto'])) {\n        return $result['auto'][0]['comCode'];\n    } else {\n        return '';\n    }\n}\n\nfunction get_data($text, $com) {\n    $post_data = array(\n        'customer' => '',\n        'param' => json_encode(array('com' => $com, 'num' => $text)),\n        'sign' => '',\n    );\n    $url = 'https://www.kuaidi100.com/query?' . http_build_query($post_data);\n    $header = array(\n        'CLIENT-IP:' . Rand_IP(),\n        'X-FORWARDED-FOR:' . Rand_IP(),\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36');\n    $output = curl_exec($ch);\n    curl_close($ch);\n    return $output;\n}\n\nfunction Rand_IP(){\n    srand(microtime(true));\n    return rand(1,254).\".\".rand(0,255).\".\".rand(0,255).\".\".rand(1,254);\n}\n?>\n",
      "<?php\nfunction get_company($text) {\n    $post_data = array(\n        'text' => $text\n    );\n    $url = 'https://www.kuaidi100.com/autonumber/autoComNum?resultv2=1&'.http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP(),\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    $data = json_decode($output, true);\n    return $data['auto'][0]['comCode'];\n}\n\nfunction get_data($text, $com) {\n    $post_data = array(\n        'customer' => '',\n        'param' => '{\"com\":\"'.$com.'\",\"num\":\"'.$text.'\"}',\n        'sign' => '',\n    );\n    $url = 'https://www.kuaidi100.com/query?' . http_build_query($post_data);\n    $header = array(\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'CLIENT-IP: '.Rand_IP(),\n        'X-FORWARDED-FOR: '.Rand_IP(),\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    $output = curl_exec($ch);\n    curl_close($ch);\n    return $output;\n}\n\nfunction Rand_IP(){\n    $ip2id= round(rand(600000, 2550000) / 10000); //第一种方法\n    $ip3id= round(rand(600000, 2550000) / 10000);\n    $ip4id= round(rand(600000, 2550000) / 10000);\n    //下面是第二种方法\n    $ip2id = mt_rand(1,254);\n    $ip3id = mt_rand(1,254);\n    $ip4id = mt_rand(1,254);\n    return $ip2id.\".\".$ip3id.\".\".$ip4id;\n}\n?>\n",
      "<?php\nfunction get_company($text) {\n    $post_data = array(\n        'text' => $text\n    );\n    $url = 'https://www.kuaidi100.com/autonumber/autoComNum?resultv2=1&'.http_build_query($post_data);\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36');\n    $output = curl_exec($ch);\n    curl_close($ch);\n    $result = json_decode($output, true);\n    if (isset($result['auto']) && is_array($result['auto']) && !empty($result['auto'])) {\n        return $result['auto'][0]['comCode'];\n    } else {\n        return '';\n    }\n}\n\nfunction get_data($text, $com) {\n    $post_data = array(\n        'customer' => '',\n        'param' => json_encode(array('com' => $com, 'num' => $text)),\n        'sign' => '',\n    );\n    $url = 'https://www.kuaidi100.com/query?' . http_build_query($post_data);\n    $header = array(\n        'CLIENT-IP:' . Rand_IP(),\n        'X-FORWARDED-FOR:' . Rand_IP(),\n    );\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36');\n    $output = curl_exec($ch);\n    curl_close($ch);\n    return $output;\n}\n\nfunction Rand_IP(){\n    $ip2id= round(rand(600000, 2550000) / 10000); //第一种方法\n    $ip3id= round(rand(600000, 2550000) / 10000);\n    $ip4id= round(rand(600000, 2550000) / 10000);\n    return $ip2id.\".\".$ip3id.\".\".$ip4id;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a PHP class that monitors the availability of a URL by periodically checking its HTTP response code until it meets the desired state (available or unavailable) within a specified timeout period.\n\nClass Description: The URLChecker class provides functionality to wait for a URL to become available (returns HTTP 200) or unavailable (returns non-200) within a given timeout period, using cURL for HTTP requests with configurable polling intervals and connection timeouts.\n\nAttributes:\n- POLL_INTERVAL_MS: int - The interval in milliseconds between consecutive URL checks\n- CONNECT_TIMEOUT_MS: int - The connection timeout in milliseconds for each HTTP request\n\nMethods:\n- waitUntilAvailable(int $timeout_in_ms, string $url) -> self - Waits until the specified URL returns HTTP 200 status code or throws TimeoutException if not achieved within timeout\n- waitUntilUnavailable(int $timeout_in_ms, string $url) -> self - Waits until the specified URL returns non-200 status code or throws TimeoutException if not achieved within timeout\n- getHTTPResponseCode(string $url) -> ?int - Private method that makes the actual HTTP request and returns the response code (null if request fails)",
    "Canonical_solution": "use Exception;\nuse Facebook\\WebDriver\\Exception\\TimeoutException;\n\nclass URLChecker\n{\n    const POLL_INTERVAL_MS = 500;\n    const CONNECT_TIMEOUT_MS = 500;\n\n    public function waitUntilAvailable($timeout_in_ms, $url)\n    {\n        $end = microtime(true) + $timeout_in_ms / 1000;\n\n        while ($end > microtime(true)) {\n            if ($this->getHTTPResponseCode($url) === 200) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS);\n        }\n\n        throw new TimeoutException(sprintf(\n            'Timed out waiting for %s to become available after %d ms.',\n            $url,\n            $timeout_in_ms\n        ));\n    }\n\n    public function waitUntilUnavailable($timeout_in_ms, $url)\n    {\n        $end = microtime(true) + $timeout_in_ms / 1000;\n\n        while ($end > microtime(true)) {\n            if ($this->getHTTPResponseCode($url) !== 200) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS);\n        }\n\n        throw new TimeoutException(sprintf(\n            'Timed out waiting for %s to become unavailable after %d ms.',\n            $url,\n            $timeout_in_ms\n        ));\n    }\n\n    private function getHTTPResponseCode($url)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        if (!defined('CURLOPT_CONNECTTIMEOUT_MS')) {\n            define('CURLOPT_CONNECTTIMEOUT_MS', 156);\n        }\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n\n        $code = null;\n\n        try {\n            curl_exec($ch);\n            $info = curl_getinfo($ch);\n            $code = $info['http_code'];\n        } catch (Exception $e) {\n        }\n        curl_close($ch);\n\n        return $code;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass TimeoutException extends Exception {}\n\nclass URLChecker {\n\n    const POLL_INTERVAL_MS = 1000;\n    const CONNECT_TIMEOUT_MS = 1000;\n\n    public function waitUntilAvailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code === 200) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become available within the timeout period.\");\n            }\n        }\n    }\n\n    public function waitUntilUnavailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code !== 200 && $http_code !== null) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become unavailable within the timeout period.\");\n            }\n        }\n    }\n\n\n    private function getHTTPResponseCode(string $url): ?int\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_NOBODY, true);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            return null;\n        }\n\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        return $http_code;\n    }\n}\n\n?>\n",
      "<?php\n\nclass TimeoutException extends Exception {}\n\nclass URLChecker\n{\n    const POLL_INTERVAL_MS = 1000;\n    const CONNECT_TIMEOUT_MS = 1000;\n\n    public function waitUntilAvailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code === 200) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become available within the timeout period.\");\n            }\n        }\n    }\n\n    public function waitUntilUnavailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code !== 200 && $http_code !== null) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become unavailable within the timeout period.\");\n            }\n        }\n    }\n\n\n    private function getHTTPResponseCode(string $url): ?int\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_NOBODY, true);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n        curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        return ($http_code !== 0) ? $http_code : null;\n    }\n}\n",
      "<?php\n\nclass TimeoutException extends Exception {}\n\nclass URLChecker\n{\n    const POLL_INTERVAL_MS = 1000;\n    const CONNECT_TIMEOUT_MS = 1000;\n\n    public function waitUntilAvailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code === 200) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become available within the timeout period.\");\n            }\n        }\n    }\n\n    public function waitUntilUnavailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code !== 200 && $http_code !== null) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become unavailable within the timeout period.\");\n            }\n        }\n    }\n\n\n    private function getHTTPResponseCode(string $url): ?int\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_NOBODY, true);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n        curl_setopt($ch, CURLOPT_TIMEOUT_MS, self::CONNECT_TIMEOUT_MS); \n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            return null;\n        }\n\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        return $http_code;\n    }\n}\n\n?>\n",
      "<?php\n\nclass TimeoutException extends Exception {}\n\nclass URLChecker {\n\n    const POLL_INTERVAL_MS = 1000;\n    const CONNECT_TIMEOUT_MS = 1000;\n\n    public function waitUntilAvailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code === 200) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become available within the timeout period.\");\n            }\n        }\n    }\n\n    public function waitUntilUnavailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code !== 200 && $http_code !== null) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become unavailable within the timeout period.\");\n            }\n        }\n    }\n\n\n    private function getHTTPResponseCode(string $url): ?int\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_NOBODY, true);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            return null;\n        }\n\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        return $http_code;\n    }\n}\n?>\n",
      "<?php\n\nclass TimeoutException extends Exception {}\n\nclass URLChecker\n{\n    const POLL_INTERVAL_MS = 1000;\n    const CONNECT_TIMEOUT_MS = 1000;\n\n    public function waitUntilAvailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code === 200) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become available within the timeout period.\");\n            }\n        }\n    }\n\n    public function waitUntilUnavailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code !== 200 && $http_code !== null) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become unavailable within the timeout period.\");\n            }\n        }\n    }\n\n\n    private function getHTTPResponseCode(string $url): ?int\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_NOBODY, true);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n        curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        return $http_code ?: null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass TimeoutException extends Exception {}\n\nclass URLChecker {\n\n    const POLL_INTERVAL_MS = 1000;\n    const CONNECT_TIMEOUT_MS = 1000;\n\n    public function waitUntilAvailable(int $timeout_in_ms, string $url): self {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code === 200) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become available within the timeout period.\");\n            }\n        }\n    }\n\n    public function waitUntilUnavailable(int $timeout_in_ms, string $url): self {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code !== 200 && $http_code !== null) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become unavailable within the timeout period.\");\n            }\n        }\n    }\n\n\n    private function getHTTPResponseCode(string $url): ?int {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_NOBODY, true);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n        curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        return $http_code ?: null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass TimeoutException extends Exception {}\n\nclass URLChecker\n{\n    const POLL_INTERVAL_MS = 1000;\n    const CONNECT_TIMEOUT_MS = 1000;\n\n    public function waitUntilAvailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code === 200) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become available within the timeout period.\");\n            }\n        }\n    }\n\n    public function waitUntilUnavailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code !== 200 && $http_code !== null) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become unavailable within the timeout period.\");\n            }\n        }\n    }\n\n\n    private function getHTTPResponseCode(string $url): ?int\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_NOBODY, true);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n        curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        return $http_code ?: null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass TimeoutException extends Exception {}\n\nclass URLChecker\n{\n    const POLL_INTERVAL_MS = 1000;\n    const CONNECT_TIMEOUT_MS = 1000;\n\n    public function waitUntilAvailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n\n            if ($http_code === 200) {\n                return $this;\n            }\n\n            usleep(self::POLL_INTERVAL_MS * 1000);\n\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become available within the timeout period.\");\n            }\n        }\n    }\n\n    public function waitUntilUnavailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n\n            if ($http_code !== 200 && $http_code !== null) {\n                return $this;\n            }\n\n            usleep(self::POLL_INTERVAL_MS * 1000);\n\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become unavailable within the timeout period.\");\n            }\n        }\n    }\n\n\n    private function getHTTPResponseCode(string $url): ?int\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_NOBODY, true);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n        curl_setopt($ch, CURLOPT_TIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            return null;\n        }\n\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        return $http_code;\n    }\n}\n",
      "<?php\n\nclass TimeoutException extends Exception {}\n\nclass URLChecker\n{\n    const POLL_INTERVAL_MS = 1000;\n    const CONNECT_TIMEOUT_MS = 1000;\n\n    public function waitUntilAvailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code === 200) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become available within the timeout period.\");\n            }\n        }\n    }\n\n\n    public function waitUntilUnavailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code !== 200 && $http_code !== null) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if ((microtime(true) - $start_time) * 1000 > $timeout_in_ms) {\n                throw new TimeoutException(\"URL '$url' did not become unavailable within the timeout period.\");\n            }\n        }\n    }\n\n\n    private function getHTTPResponseCode(string $url): ?int\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_NOBODY, true);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n        curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        return ($http_code !== 0) ? $http_code : null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass TimeoutException extends Exception {}\n\nclass URLChecker\n{\n    const POLL_INTERVAL_MS = 1000;\n    const CONNECT_TIMEOUT_MS = 1000;\n\n    public function waitUntilAvailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code === 200) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if (microtime(true) - $start_time > $timeout_in_ms / 1000) {\n                throw new TimeoutException(\"URL '$url' did not become available within the timeout period.\");\n            }\n        }\n    }\n\n    public function waitUntilUnavailable(int $timeout_in_ms, string $url): self\n    {\n        $start_time = microtime(true);\n        while (true) {\n            $http_code = $this->getHTTPResponseCode($url);\n            if ($http_code !== 200 && $http_code !== null) {\n                return $this;\n            }\n            usleep(self::POLL_INTERVAL_MS * 1000);\n            if (microtime(true) - $start_time > $timeout_in_ms / 1000) {\n                throw new TimeoutException(\"URL '$url' did not become unavailable within the timeout period.\");\n            }\n        }\n    }\n\n\n    private function getHTTPResponseCode(string $url): ?int\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_NOBODY, true);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, self::CONNECT_TIMEOUT_MS);\n        curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        return $http_code ?: null;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Create a PHP function that makes an HTTP request using cURL to fetch data from a specified URL.\n\nFunction Description: The function initializes a cURL session, configures it with basic options (disabling SSL verification for simplicity), executes the request, and returns the response. It handles the entire cURL lifecycle from initialization to cleanup.\n\nInput: \n- $url (string): The URL to which the HTTP request will be made.\n\nOutput: \n- Returns the response from the HTTP request as a string if successful, or false on failure.",
    "Canonical_solution": "function make_curl_request($url)\n{\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_HEADER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    $res = curl_exec($ch);\n    curl_close($ch);\n    return $res;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction fetch_url($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); \n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetchDataFromUrl($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); \n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a PHP class for interacting with Alipay's API to query fund transfer orders, including request signing and HTTP communication functionality.\n\nClass Description: The AlipayService class provides methods to interact with Alipay's payment API, specifically for querying fund transfer orders. It handles request signing, parameter encoding, and HTTP communication using cURL.\n\nAttributes:\n- appId: string - The application ID provided by Alipay\n- rsaPrivateKey: string - The RSA private key for request signing\n- charset: string - The character encoding to use (default: 'utf-8')\n\nMethods:\n- __construct(string $appid, string $saPrivateKey) -> void - Initializes the service with Alipay app ID and private key\n- doQuery(string $outBizBo='', string $orderId='') -> array - Queries a fund transfer order using either out business number or order ID\n- generateSign(array $params, string $signType='RSA') -> string - Generates a signature for the request parameters\n- sign(string $data, string $signType='RSA') -> string - Signs the given data using the configured private key\n- checkEmpty(mixed $value) -> bool - Checks if a value is empty or null\n- getSignContent(array $params) -> string - Prepares the parameter string for signing\n- characet(string $data, string $targetCharset) -> string - Converts character encoding if needed\n- curlPost(string $url='', mixed $postData='', array $options=[]) -> string - Executes a POST request using cURL",
    "Canonical_solution": "class AlipayService\n{\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $charset;\n\n    public function __construct($appid, $saPrivateKey)\n    {\n        $this->appId = $appid;\n        $this->charset = 'utf-8';\n        $this->rsaPrivateKey = $saPrivateKey;\n    }\n\n    public function doQuery($outBizBo='', $orderId='')\n    {\n        $requestConfigs = array(\n            'out_biz_no'=>$outBizBo,\n            'order_id'=>$orderId,\n        );\n        $commonConfigs = array(\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.order.query',\n            'format' => 'JSON',\n            'charset'=>$this->charset,\n            'sign_type'=>'RSA2',\n            'timestamp'=>date('Y-m-d H:i:s'),\n            'version'=>'1.0',\n            'biz_content'=>json_encode($requestConfigs),\n        );\n        $commonConfigs[\"sign\"] = $this->generateSign($commonConfigs, $commonConfigs['sign_type']);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do?charset='.$this->charset,$commonConfigs);\n        return json_decode($result,true);\n    }\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey=$this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, version_compare(PHP_VERSION,'5.4.0', '<') ? SHA256 : OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    protected function checkEmpty($value) {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                $v = $this->characet($v, $this->charset);\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array())\n    {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $charset = 'utf-8';\n    protected $gatewayUrl = 'https://openapi.alipay.com/gateway.do';\n\n    public function __construct(string $appid, string $rsaPrivateKey) {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function doQuery(string $outBizNo='', string $orderId='') {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.order.query',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outBizNo,\n                'order_id' => $orderId,\n            ]),\n        ];\n        $params['sign'] = $this->generateSign($params);\n        return json_decode($this->curlPost($this->gatewayUrl, $params), true);\n    }\n\n\n    public function generateSign(array $params, string $signType='RSA2') {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType='RSA2') {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        if ($signType === 'RSA') {\n            openssl_sign($data, $sign, $res);\n        } else {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        }\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n\n    protected function checkEmpty($value) {\n        return $value === null || $value === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && $k != 'sign' && \"@\" != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . \"=\" . $v . \"&\";\n            }\n        }\n        return substr($stringToBeSigned, 0, strlen($stringToBeSigned) - 1);\n    }\n\n    protected function characet(string $data, string $targetCharset) {\n        if (strcasecmp($this->charset, $targetCharset) != 0) {\n            $data = mb_convert_encoding($data, $targetCharset, $this->charset);\n            $this->charset = $targetCharset;\n        }\n        return $data;\n    }\n\n    protected function curlPost(string $url='', mixed $postData='', array $options=[]) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        if (is_array($postData)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($postData));\n        } else {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        }\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch), 0);\n        }\n        curl_close($ch);\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey) {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function doQuery(string $outBizNo='', string $orderId='') {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.order.query',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outBizNo,\n                'order_id' => $orderId,\n            ]),\n        ];\n        $params['sign'] = $this->generateSign($params);\n        return json_decode($this->curlPost('https://openapi.alipay.com/gateway.do', $params), true);\n    }\n\n\n    public function generateSign(array $params, string $signType='RSA2') {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType='RSA2') {\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($this->rsaPrivateKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, $signType === 'RSA' ? OPENSSL_ALGO_SHA1 : OPENSSL_ALGO_SHA256);\n        return base64_encode($sign);\n    }\n\n    protected function checkEmpty($value) {\n        return $value === null || $value === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset) {\n        if (strcasecmp($this->charset, $targetCharset) != 0) {\n            $data = mb_convert_encoding($data, $targetCharset, $this->charset);\n            $this->charset = $targetCharset;\n        }\n        return $data;\n    }\n\n    protected function curlPost(string $url='', mixed $postData='', array $options=[]) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        curl_setopt($ch, CURLOPT_POSTFIELDS, is_array($postData) ? http_build_query($postData) : $postData);\n\n        $response = curl_exec($ch);\n\n        if(curl_errno($ch)){\n            throw new Exception(curl_error($ch),0);\n        }\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $charset = 'utf-8';\n    protected $gatewayUrl = 'https://openapi.alipay.com/gateway.do';\n\n    public function __construct(string $appid, string $rsaPrivateKey) {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function doQuery(string $outBizNo='', string $orderId='') {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.order.query',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outBizNo,\n                'order_id' => $orderId,\n            ]),\n        ];\n        $params['sign'] = $this->generateSign($params);\n        return json_decode($this->curlPost($this->gatewayUrl, $params), true);\n    }\n\n\n    public function generateSign(array $params, string $signType='RSA2') {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType='RSA2') {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        if ($signType === 'RSA') {\n            openssl_sign($data, $sign, $res);\n        } else {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        }\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n\n    protected function checkEmpty($value) {\n        return $value === null || $value === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset) {\n        if (strcasecmp($this->charset, $targetCharset) != 0) {\n            $data = mb_convert_encoding($data, $targetCharset, $this->charset);\n            $this->charset = $targetCharset;\n        }\n        return $data;\n    }\n\n    protected function curlPost(string $url='', mixed $postData='', array $options=[]) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        if (is_array($postData) && 0 < count($postData)) {\n            $postData = http_build_query($postData);\n        }\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        $response = curl_exec($ch);\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch),0);\n        }\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey) {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function doQuery(string $outBizNo='', string $orderId='') {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.order.query',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outBizNo,\n                'order_id' => $orderId,\n            ]),\n        ];\n        $params['sign'] = $this->generateSign($params);\n        return json_decode($this->curlPost('https://openapi.alipay.com/gateway.do', $params), true);\n    }\n\n\n    public function generateSign(array $params, string $signType='RSA2') {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType='RSA2') {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        if ($signType === 'RSA') {\n            openssl_sign($data, $sign, $res);\n        } else {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        }\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n    protected function checkEmpty($value) {\n        return $value === null || $value === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset) {\n        if (strcasecmp($this->charset, $targetCharset) != 0) {\n            $data = mb_convert_encoding($data, $targetCharset, $this->charset);\n            $this->charset = $targetCharset;\n        }\n        return $data;\n    }\n\n    protected function curlPost(string $url='', mixed $postData='', array $options=[]) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        if (is_array($postData) && 0 < count($postData)) {\n            $postData = http_build_query($postData);\n        }\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt_array($ch, $options);\n        $response = curl_exec($ch);\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch),0);\n        }\n        curl_close($ch);\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey) {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function doQuery(string $outBizNo='', string $orderId='') {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.order.query',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outBizNo,\n                'order_id' => $orderId,\n            ]),\n        ];\n        $params['sign'] = $this->generateSign($params);\n        return json_decode($this->curlPost('https://openapi.alipay.com/gateway.do', $params), true);\n    }\n\n\n    public function generateSign(array $params, string $signType='RSA2') {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType='RSA2') {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        if ($signType === 'RSA') {\n            openssl_sign($data, $sign, $res);\n        } else {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        }\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n    protected function checkEmpty($value) {\n        return $value === null || $value === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset) {\n        if (strcasecmp($this->charset, $targetCharset) != 0) {\n            $data = mb_convert_encoding($data, $targetCharset, $this->charset);\n            $this->charset = $targetCharset;\n        }\n        return $data;\n    }\n\n    protected function curlPost(string $url='', mixed $postData='', array $options=[]) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        if (is_array($postData)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($postData));\n        } else {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        }\n\n        curl_setopt_array($ch, $options);\n        $response = curl_exec($ch);\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch), 0);\n        }\n        curl_close($ch);\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $charset = 'utf-8';\n    protected $gatewayUrl = 'https://openapi.alipay.com/gateway.do';\n\n    public function __construct(string $appId, string $rsaPrivateKey) {\n        $this->appId = $appId;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function doQuery(string $outBizNo='', string $orderId='') {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.order.query',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outBizNo,\n                'order_id' => $orderId,\n            ]),\n        ];\n        $params['sign'] = $this->generateSign($params);\n        return json_decode($this->curlPost($this->gatewayUrl, $params), true);\n    }\n\n    public function generateSign(array $params, string $signType='RSA2') {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType='RSA2') {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        if ($signType === 'RSA') {\n            openssl_sign($data, $sign, $res);\n        } else {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        }\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n\n    protected function checkEmpty($value) {\n        return $value === null || $value === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset) {\n        if (strcasecmp($this->charset, $targetCharset) != 0) {\n            $data = mb_convert_encoding($data, $targetCharset, $this->charset);\n            $this->charset = $targetCharset;\n        }\n        return $data;\n    }\n\n    protected function curlPost(string $url='', mixed $postData='', array $options=[]) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        if (is_array($postData) && 0 < count($postData)) {\n            $postData = http_build_query($postData);\n        }\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        $response = curl_exec($ch);\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch), 0);\n        }\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey) {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function doQuery(string $outBizNo='', string $orderId='') {\n        $bizContent = [];\n        if (!empty($outBizNo)) {\n            $bizContent['out_biz_no'] = $outBizNo;\n        }\n        if (!empty($orderId)) {\n            $bizContent['order_id'] = $orderId;\n        }\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.order.query',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n        $url = 'https://openapi.alipay.com/gateway.do';\n        return json_decode($this->curlPost($url, $params), true);\n    }\n\n\n    public function generateSign(array $params, string $signType='RSA2') {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType='RSA2') {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        if ($signType === 'RSA') {\n            openssl_sign($data, $sign, $res);\n        } else {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        }\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n    protected function checkEmpty($value) {\n        return $value === null || $value === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset) {\n        if (strcasecmp($this->charset, $targetCharset) != 0) {\n            $data = mb_convert_encoding($data, $targetCharset, $this->charset);\n            $this->charset = $targetCharset;\n        }\n        return $data;\n    }\n\n    protected function curlPost(string $url='', mixed $postData='', array $options=[]) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        if (is_array($postData) && 0 < count($postData)) {\n            $postData = http_build_query($postData);\n        }\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch),0);\n        } else {\n            $httpStatusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if (200 !== $httpStatusCode) {\n                throw new Exception($response,$httpStatusCode);\n            }\n        }\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey) {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function doQuery(string $outBizNo='', string $orderId='') {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.order.query',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outBizNo,\n                'order_id' => $orderId,\n            ]),\n        ];\n        $params['sign'] = $this->generateSign($params);\n        return json_decode($this->curlPost('https://openapi.alipay.com/gateway.do', $params), true);\n    }\n\n\n    public function generateSign(array $params, string $signType='RSA2') {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType='RSA2') {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        if ($signType === 'RSA') {\n            openssl_sign($data, $sign, $res);\n        } else {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        }\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n    protected function checkEmpty($value) {\n        return $value === null || $value === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset) {\n        if (strcasecmp($this->charset, $targetCharset) != 0) {\n            $data = mb_convert_encoding($data, $targetCharset, $this->charset);\n            $this->charset = $targetCharset;\n        }\n        return $data;\n    }\n\n    protected function curlPost(string $url='', mixed $postData='', array $options=[]) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        if (is_array($postData) && 0 < count($postData)) {\n            $postData = http_build_query($postData);\n        }\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt_array($ch, $options);\n        $response = curl_exec($ch);\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch),0);\n        }\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $charset = 'utf-8';\n    protected $gatewayUrl = 'https://openapi.alipay.com/gateway.do';\n\n    public function __construct(string $appid, string $rsaPrivateKey) {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function doQuery(string $outBizNo='', string $orderId='') {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.order.query',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode([\n                'out_biz_no' => $outBizNo,\n                'order_id' => $orderId,\n            ]),\n        ];\n        $params['sign'] = $this->generateSign($params);\n        return json_decode($this->curlPost($this->gatewayUrl, $params), true);\n    }\n\n\n    public function generateSign(array $params, string $signType='RSA2') {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType='RSA2') {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        if ($signType === 'RSA') {\n            openssl_sign($data, $sign, $res);\n        } else {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        }\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n\n    protected function checkEmpty($value) {\n        return $value === null || $value === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && $k != 'sign' && \"@\" != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . \"=\" . $v . \"&\";\n            }\n        }\n        return substr($stringToBeSigned, 0, strlen($stringToBeSigned) - 1);\n    }\n\n    protected function characet(string $data, string $targetCharset) {\n        if (strcasecmp($this->charset, $targetCharset) != 0) {\n            $data = mb_convert_encoding($data, $targetCharset, $this->charset);\n            $this->charset = $targetCharset;\n        }\n        return $data;\n    }\n\n    protected function curlPost(string $url='', mixed $postData='', array $options=[]) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        if (is_array($postData)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($postData));\n        } else {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        }\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch), 0);\n        }\n        curl_close($ch);\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $rsaPrivateKey;\n    protected $charset = 'utf-8';\n\n    public function __construct(string $appid, string $rsaPrivateKey) {\n        $this->appId = $appid;\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function doQuery(string $outBizNo='', string $orderId='') {\n        $bizContent = [];\n        if (!empty($outBizNo)) {\n            $bizContent['out_biz_no'] = $outBizNo;\n        }\n        if (!empty($orderId)) {\n            $bizContent['order_id'] = $orderId;\n        }\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.order.query',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n        $url = 'https://openapi.alipay.com/gateway.do';\n        return json_decode($this->curlPost($url, $params), true);\n    }\n\n\n    public function generateSign(array $params, string $signType='RSA2') {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    public function sign(string $data, string $signType='RSA2') {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        if ($signType === 'RSA') {\n            openssl_sign($data, $sign, $res);\n        } else {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        }\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n    protected function checkEmpty($value) {\n        return $value === null || $value === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset) {\n        if (strcasecmp($this->charset, $targetCharset) != 0) {\n            $data = mb_convert_encoding($data, $targetCharset, $this->charset);\n            $this->charset = $targetCharset;\n        }\n        return $data;\n    }\n\n    protected function curlPost(string $url='', mixed $postData='', array $options=[]) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        if (is_array($postData) && 0 < count($postData)) {\n            $postData = http_build_query($postData);\n        }\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        $response = curl_exec($ch);\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch),0);\n        }\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create a PHP function that performs HTTP requests using cURL with support for GET/POST methods, custom headers, cookies, and SSL configuration.\n\nFunction Description: The function should make HTTP requests to a specified URL with optional cookies and user agent. It should handle both HTTP and HTTPS protocols, with configurable SSL verification. The function should follow redirects (302 status) and return the response data or false on failure. Timeouts should be configurable for connection and request execution.\n\nInput:\n- $url: string - The target URL for the HTTP request\n- $cookies: string (optional) - Cookie string to be sent with the request\n- $useragent: string (optional) - User-Agent header value\n- $method: string (optional) - HTTP method ('GET' or 'POST'), defaults to 'GET'\n\nOutput:\n- Returns: mixed - The response data as string on success (HTTP 200), follows redirects automatically (HTTP 302), or returns false on failure",
    "Canonical_solution": "function download($url, $cookies='', $useragent='', $method = 'GET')\n{\n    $header = array(\n        \"Content-Type:application/x-www-form-urlencoded\",\n        'User-Agent: '.$useragent);\n    $ch = curl_init();\n    if ($method === 'POST') {\n        curl_setopt($ch, CURLOPT_POST, true);\n    }\n    if (stripos($url, 'https://') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_SSLVERSION, 1);\n    }\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_COOKIE, $cookies);\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 60);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 600);\n    $data = curl_exec($ch);\n    $status = curl_getinfo($ch);\n    curl_close($ch);\n    if (isset($status['http_code']) && $status['http_code'] == 200) {\n        return $data;\n    }\n    if (isset($status['http_code']) && $status['http_code'] == 302) {\n        return download($status['redirect_url'], $cookies, $useragent);\n    }\n    return $data;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction http_request($url, $cookies = null, $useragent = null, $method = 'GET', $post_data = null, $ssl_verify = true, $timeout = 30) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    if ($cookies) {\n        curl_setopt($ch, CURLOPT_COOKIE, $cookies);\n    }\n\n    if ($useragent) {\n        curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n    }\n\n    if ($method == 'POST') {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($post_data) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n        }\n    }\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, $ssl_verify);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, $ssl_verify ? 2 : 0);\n    }\n\n\n    $response = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($response === false || $http_code != 200) {\n      curl_close($ch);\n      return false;\n    }\n\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url, $cookies = null, $useragent = null, $method = 'GET', $post_data = null, $ssl_verify = true, $timeout = 30) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);\n\n    if ($cookies) {\n        curl_setopt($ch, CURLOPT_COOKIE, $cookies);\n    }\n\n    if ($useragent) {\n        curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n    }\n\n    if ($method == 'POST') {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($post_data) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n        }\n    }\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, $ssl_verify);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, $ssl_verify ? 2 : 0);\n    }\n\n\n    $response = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($response === false || $http_code != 200) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url, $cookies = null, $useragent = null, $method = 'GET', $post_data = null, $ssl_verify = true, $timeout = 30) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    if ($cookies) {\n        curl_setopt($ch, CURLOPT_COOKIE, $cookies);\n    }\n\n    if ($useragent) {\n        curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n    }\n\n    if ($method == 'POST') {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($post_data) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n        }\n    }\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, $ssl_verify);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, $ssl_verify ? 2 : 0);\n    }\n\n\n    $response = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($response === false || $http_code != 200) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url, $cookies = null, $useragent = null, $method = 'GET', $post_data = null, $ssl_verify = true, $timeout = 30) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    if ($cookies) {\n        curl_setopt($ch, CURLOPT_COOKIE, $cookies);\n    }\n\n    if ($useragent) {\n        curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n    }\n\n    if ($method == 'POST') {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($post_data) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n        }\n    }\n\n    if (strpos($url, 'https://') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, $ssl_verify);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, $ssl_verify ? 2 : 0);\n    }\n\n\n    $response = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($response === false || $http_code != 200) {\n      curl_close($ch);\n      return false;\n    }\n\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url, $cookies = null, $useragent = null, $method = 'GET', $post_data = null, $ssl_verify = true, $timeout = 30) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);\n\n    if ($cookies) {\n        curl_setopt($ch, CURLOPT_COOKIE, $cookies);\n    }\n\n    if ($useragent) {\n        curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n    }\n\n    if ($method == 'POST') {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($post_data) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n        }\n    }\n\n    if (strpos($url, 'https://') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, $ssl_verify);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, $ssl_verify ? 2 : 0);\n    }\n\n\n    $response = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($response === false || $http_code != 200) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url, $cookies = null, $useragent = null, $method = 'GET', $post_data = null, $ssl_verify = true, $timeout = 30) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    if ($cookies) {\n        curl_setopt($ch, CURLOPT_COOKIE, $cookies);\n    }\n\n    if ($useragent) {\n        curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n    }\n\n    if ($method == 'POST') {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($post_data) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n        }\n    }\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, $ssl_verify);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, $ssl_verify ? 2 : 0);\n    }\n\n\n    $response = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($response === false || $http_code != 200) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url, $cookies = null, $useragent = null, $method = 'GET', $post_data = null, $ssl_verify = true, $timeout = 30) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);\n\n    if ($cookies) {\n        curl_setopt($ch, CURLOPT_COOKIE, $cookies);\n    }\n\n    if ($useragent) {\n        curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n    }\n\n    if ($method == 'POST') {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($post_data) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n        }\n    }\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, $ssl_verify);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, $ssl_verify ? 2 : 0);\n    }\n\n\n    $response = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($response === false || $http_code != 200) {\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url, $cookies = null, $useragent = null, $method = 'GET', $post_data = null, $ssl_verify = true, $timeout = 30) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    if ($cookies) {\n        curl_setopt($ch, CURLOPT_COOKIE, $cookies);\n    }\n\n    if ($useragent) {\n        curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n    }\n\n    if ($method == 'POST') {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($post_data) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n        }\n    }\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, $ssl_verify);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, $ssl_verify ? 2 : 0);\n    }\n\n\n    $response = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($response === false || $http_code != 200) {\n      curl_close($ch);\n      return false;\n    }\n\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url, $cookies = null, $useragent = null, $method = 'GET', $post_data = null, $ssl_verify = true, $timeout = 30) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    if ($cookies) {\n        curl_setopt($ch, CURLOPT_COOKIE, $cookies);\n    }\n\n    if ($useragent) {\n        curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n    }\n\n    if ($method == 'POST') {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($post_data) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n        }\n    }\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, $ssl_verify);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, $ssl_verify ? 2 : 0);\n    }\n\n\n    $response = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($response === false || $http_code != 200) {\n      curl_close($ch);\n      return false;\n    }\n\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url, $cookies = null, $useragent = null, $method = 'GET', $post_data = null, $ssl_verify = true, $timeout = 30) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n    if ($cookies) {\n        curl_setopt($ch, CURLOPT_COOKIE, $cookies);\n    }\n\n    if ($useragent) {\n        curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n    }\n\n    if ($method == 'POST') {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($post_data) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n        }\n    }\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, $ssl_verify);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, $ssl_verify ? 2 : 0);\n    }\n\n\n    $response = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($response === false || $http_code != 200) {\n        curl_close($ch);\n        return false;\n    }\n\n\n    curl_close($ch);\n    return $response;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Create a PHP class that provides HTTP client functionality using cURL for making GET and POST requests to external APIs, with basic error handling and resource management.\n\nClass Description: The ApiExceptAuthController class is designed to handle HTTP requests to external APIs using PHP's cURL library. It provides methods for making GET and POST requests with basic configuration options and error handling. The class is initialized with a Request object and maintains it as an instance variable.\n\nAttributes:\n- api_controller: [mixed] - Reserved for potential future use to reference an API controller instance\n- request: [Illuminate\\Http\\Request] - The HTTP request object injected during instantiation\n\nMethods:\n- __construct(Request $request) -> [void] - Initializes the class with the given HTTP request object\n- callGetApi(string $url) -> [string|bool] - Makes a GET request to the specified URL and returns the response or false on failure\n- callPostApi(string $url, mixed $data) -> [string|bool] - Makes a POST request to the specified URL with the given data and returns the response or false on failure",
    "Canonical_solution": "use Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Str;\n\nclass ApiExceptAuthController\n{\n    public $api_controller;\n    public $request;\n\n    public function __construct(Request $request)\n    {\n        $this->request = $request;\n    }\n\n    public function callGetApi($url)\n    {\n        $curl = curl_init($url);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_HEADER, 0);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($curl);\n\n        if (curl_errno($curl)) {\n            //echo 'error:' . curl_error($curl);\n        }\n\n        return $response;\n        curl_close($curl);\n    }\n\n    public function callPostApi($url, $data)\n    {\n        $curl = curl_init($url);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_HEADER, 0);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($curl);\n\n        if (curl_errno($curl)) {\n            echo 'error:'.curl_error($curl);\n        }\n\n        return $response;\n        curl_close($curl);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nuse Illuminate\\Http\\Request;\n\nclass ApiExceptAuthController\n{\n    private $api_controller;\n    private Request $request;\n\n    public function __construct(Request $request)\n    {\n        $this->request = $request;\n    }\n\n    public function callGetApi(string $url): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (GET): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function callPostApi(string $url, mixed $data): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (POST): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\n\nuse Illuminate\\Http\\Request;\n\nclass ApiExceptAuthController\n{\n    private $api_controller;\n    private Request $request;\n\n    public function __construct(Request $request)\n    {\n        $this->request = $request;\n    }\n\n    public function callGetApi(string $url): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (GET): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function callPostApi(string $url, mixed $data): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (POST): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Illuminate\\Http\\Request;\n\nclass ApiExceptAuthController\n{\n    private $api_controller;\n    private Request $request;\n\n    public function __construct(Request $request)\n    {\n        $this->request = $request;\n    }\n\n    public function callGetApi(string $url): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function callPostApi(string $url, mixed $data): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Illuminate\\Http\\Request;\n\nclass ApiExceptAuthController\n{\n    private $api_controller;\n    private Request $request;\n\n    public function __construct(Request $request)\n    {\n        $this->request = $request;\n    }\n\n    public function callGetApi(string $url): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (GET): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function callPostApi(string $url, mixed $data): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (POST): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Illuminate\\Http\\Request;\n\nclass ApiExceptAuthController\n{\n    private $api_controller;\n    private Request $request;\n\n    public function __construct(Request $request)\n    {\n        $this->request = $request;\n    }\n\n    public function callGetApi(string $url): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function callPostApi(string $url, mixed $data): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Illuminate\\Http\\Request;\n\nclass ApiExceptAuthController\n{\n    private $api_controller;\n    private Request $request;\n\n    public function __construct(Request $request)\n    {\n        $this->request = $request;\n    }\n\n    public function callGetApi(string $url): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (GET): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function callPostApi(string $url, mixed $data): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (POST): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Illuminate\\Http\\Request;\n\nclass ApiExceptAuthController\n{\n    private $api_controller;\n    private Request $request;\n\n    public function __construct(Request $request)\n    {\n        $this->request = $request;\n    }\n\n    public function callGetApi(string $url): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (GET): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function callPostApi(string $url, mixed $data): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (POST): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Illuminate\\Http\\Request;\n\nclass ApiExceptAuthController\n{\n    private $api_controller;\n    private Request $request;\n\n    public function __construct(Request $request)\n    {\n        $this->request = $request;\n    }\n\n    public function callGetApi(string $url): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function callPostApi(string $url, mixed $data): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Illuminate\\Http\\Request;\n\nclass ApiExceptAuthController\n{\n    private $api_controller;\n    private Request $request;\n\n    public function __construct(Request $request)\n    {\n        $this->request = $request;\n    }\n\n    public function callGetApi(string $url): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (GET): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function callPostApi(string $url, mixed $data): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (POST): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n",
      "<?php\n\nuse Illuminate\\Http\\Request;\n\nclass ApiExceptAuthController\n{\n    private $api_controller;\n    private Request $request;\n\n    public function __construct(Request $request)\n    {\n        $this->request = $request;\n    }\n\n    public function callGetApi(string $url): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (GET): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function callPostApi(string $url, mixed $data): string|bool\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error (POST): ' . curl_error($ch));\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Create a PHP function that makes an HTTP POST request to a specified API endpoint to fetch content using cURL, with appropriate headers and request parameters.\n\nFunction Description: The function `curl_pipigaoxiao` initiates a cURL session to send a POST request to the 'http://h5.ippzone.com/ppapi/share/fetch_content' endpoint. It sets necessary headers including Content-Type, Origin, and User-Agent, along with a Referer header. The function sends JSON-formatted POST data containing a post ID and type, then returns the response from the server.\n\nInput: \n- `$id` (string|integer): The post ID to be included in the request payload\n\nOutput:\n- `$data` (string): The raw HTTP response including headers and body from the API endpoint",
    "Canonical_solution": "function curl_pipigaoxiao($id)\n{\n    $cl = curl_init();\n    curl_setopt($cl, CURLOPT_URL, 'http://h5.ippzone.com/ppapi/share/fetch_content');\n    curl_setopt($cl, CURLOPT_HEADER, 1);\n    curl_setopt($cl, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($cl, CURLOPT_HTTPHEADER, array(\n        'Content-Type: application/json;charset=utf-8',\n        'Origin: http://h5.ippzone.com',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36'\n    ));\n    curl_setopt($cl, CURLOPT_REFERER, 'http://h5.ippzone.com/pp/post/78266943052');\n    curl_setopt($cl, CURLOPT_POST, 1);\n    $post_data = \"{\\\"pid\\\":\".$id.\",\\\"type\\\":\\\"post\\\",\\\"mid\\\":null}\";\n    curl_setopt($cl, CURLOPT_POSTFIELDS, $post_data);\n    $data = curl_exec($cl);\n    curl_close($cl);\n    return $data;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction curl_pipigaoxiao($id) {\n    $ch = curl_init();\n    $url = 'http://h5.ippzone.com/ppapi/share/fetch_content';\n    $headers = array(\n        'Content-Type: application/json',\n        'Origin: http://h5.ippzone.com',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n        'Referer: http://h5.ippzone.com/'\n    );\n    $post_data = json_encode(array('id' => $id, 'type' => 'post'));\n\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $data = curl_exec($ch);\n\n    curl_close($ch);\n\n    return $data;\n}\n?>\n",
      "<?php\nfunction curl_pipigaoxiao($id) {\n    $ch = curl_init();\n    $url = 'http://h5.ippzone.com/ppapi/share/fetch_content';\n    $headers = array(\n        'Content-Type: application/json',\n        'Origin: http://h5.ippzone.com',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n        'Referer: http://h5.ippzone.com/'\n    );\n    $postData = json_encode(array('id' => $id, 'type' => 'post'));\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $data = curl_exec($ch);\n    curl_close($ch);\n    return $data;\n}\n?>\n",
      "<?php\nfunction curl_pipigaoxiao($id) {\n    $ch = curl_init();\n    $url = 'http://h5.ippzone.com/ppapi/share/fetch_content';\n    $headers = array(\n        'Content-Type: application/json',\n        'Origin: http://h5.ippzone.com',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n        'Referer: http://h5.ippzone.com/'\n    );\n    $postData = json_encode(array('id' => $id, 'type' => 'post'));\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $data = curl_exec($ch);\n    curl_close($ch);\n    return $data;\n}\n?>\n",
      "<?php\nfunction curl_pipigaoxiao($id) {\n    $ch = curl_init();\n    $url = 'http://h5.ippzone.com/ppapi/share/fetch_content';\n    $headers = array(\n        'Content-Type: application/json',\n        'Origin: http://h5.ippzone.com',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n        'Referer: http://h5.ippzone.com/'\n    );\n    $postData = json_encode(array('id' => $id, 'type' => 'post'));\n\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $data = curl_exec($ch);\n\n    curl_close($ch);\n\n    return $data;\n}\n?>\n",
      "<?php\nfunction curl_pipigaoxiao($id) {\n    $ch = curl_init();\n    $url = 'http://h5.ippzone.com/ppapi/share/fetch_content';\n    $headers = array(\n        'Content-Type: application/json',\n        'Origin: http://h5.ippzone.com',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n        'Referer: http://h5.ippzone.com/'\n    );\n    $post_data = json_encode(array('id' => $id, 'type' => 'post'));\n\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $data = curl_exec($ch);\n\n    curl_close($ch);\n\n    return $data;\n}\n?>\n",
      "<?php\nfunction curl_pipigaoxiao($id) {\n    $ch = curl_init();\n    $url = 'http://h5.ippzone.com/ppapi/share/fetch_content';\n    $headers = array(\n        'Content-Type: application/json',\n        'Origin: http://h5.ippzone.com',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n        'Referer: http://h5.ippzone.com/'\n    );\n    $post_data = json_encode(array('id' => $id, 'type' => 'post'));\n\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $data = curl_exec($ch);\n\n    curl_close($ch);\n\n    return $data;\n}\n?>\n",
      "<?php\nfunction curl_pipigaoxiao($id) {\n    $ch = curl_init();\n    $url = 'http://h5.ippzone.com/ppapi/share/fetch_content';\n    $headers = array(\n        'Content-Type: application/json',\n        'Origin: http://h5.ippzone.com',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n        'Referer: http://h5.ippzone.com/'\n    );\n    $postData = json_encode(array('id' => $id, 'type' => 'post'));\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $data = curl_exec($ch);\n    curl_close($ch);\n    return $data;\n}\n?>\n",
      "<?php\nfunction curl_pipigaoxiao($id) {\n    $ch = curl_init();\n    $url = 'http://h5.ippzone.com/ppapi/share/fetch_content';\n    $headers = array(\n        'Content-Type: application/json',\n        'Origin: http://h5.ippzone.com',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n        'Referer: http://h5.ippzone.com/'\n    );\n    $postData = json_encode(array('id' => $id, 'type' => 'post'));\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $data = curl_exec($ch);\n    curl_close($ch);\n    return $data;\n}\n?>\n",
      "<?php\nfunction curl_pipigaoxiao($id) {\n    $ch = curl_init();\n    $url = 'http://h5.ippzone.com/ppapi/share/fetch_content';\n    $headers = array(\n        'Content-Type: application/json',\n        'Origin: http://h5.ippzone.com',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n        'Referer: http://h5.ippzone.com/'\n    );\n    $postData = json_encode(array('id' => $id, 'type' => 'post'));\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $data = curl_exec($ch);\n    curl_close($ch);\n    return $data;\n}\n?>\n",
      "<?php\nfunction curl_pipigaoxiao($id) {\n    $ch = curl_init();\n    $url = 'http://h5.ippzone.com/ppapi/share/fetch_content';\n    $headers = array(\n        'Content-Type: application/json',\n        'Origin: http://h5.ippzone.com',\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n        'Referer: http://h5.ippzone.com/'\n    );\n    $postData = json_encode(array('id' => $id, 'type' => 'post'));\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $data = curl_exec($ch);\n    curl_close($ch);\n    return $data;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a PHP class that generates placeholder images by downloading them from a remote HTTP server using either cURL or file operations, with various customization options.\n\nClass Description: The Image class provides functionality to generate placeholder images with customizable dimensions, categories, formats, and other visual properties. It handles the download process using either cURL or file operations depending on server capabilities.\n\nAttributes:\n- BASE_URL: string - Base URL for the placeholder image service\n- FORMAT_JPG: string - Constant for JPG format\n- FORMAT_JPEG: string - Constant for JPEG format  \n- FORMAT_PNG: string - Constant for PNG format\n- categories: array - Available image categories\n\nMethods:\n- image(\n    string|null $dir = null,\n    int $width = 640,\n    int $height = 480,\n    string|null $category = null,\n    bool $fullPath = true,\n    bool $randomize = true,\n    string|null $word = null,\n    bool $gray = false,\n    string $format = 'png'\n  ) -> string|false - Downloads and saves an image with specified parameters, returning the file path or false on failure\n- imageUrl(\n    int $width,\n    int $height,\n    string|null $category,\n    bool $randomize,\n    string|null $word,\n    bool $gray,\n    string $format\n  ) -> string - Generates the URL for the placeholder image (assumed to exist based on reference code)",
    "Canonical_solution": "namespace Faker\\Provider;\n\nclass Image extends Base\n{\n    public const BASE_URL = 'https://via.placeholder.com';\n    public const FORMAT_JPG = 'jpg';\n    public const FORMAT_JPEG = 'jpeg';\n    public const FORMAT_PNG = 'png';\n\n    protected static $categories = [\n        'abstract', 'animals', 'business', 'cats', 'city', 'food', 'nightlife',\n        'fashion', 'people', 'nature', 'sports', 'technics', 'transport',\n    ];\n\n    public static function image(\n        $dir = null,\n        $width = 640,\n        $height = 480,\n        $category = null,\n        $fullPath = true,\n        $randomize = true,\n        $word = null,\n        $gray = false,\n        $format = 'png'\n    ) {\n        $dir = null === $dir ? sys_get_temp_dir() : $dir;\n        if (!is_dir($dir) || !is_writable($dir)) {\n            throw new \\InvalidArgumentException(sprintf('Cannot write to directory \"%s\"', $dir));\n        }\n\n        $name = md5(uniqid(empty($_SERVER['SERVER_ADDR']) ? '' : $_SERVER['SERVER_ADDR'], true));\n        $filename = sprintf('%s.%s', $name, $format);\n        $filepath = $dir . DIRECTORY_SEPARATOR . $filename;\n\n        $url = static::imageUrl($width, $height, $category, $randomize, $word, $gray, $format);\n\n        if (function_exists('curl_exec')) {\n            $fp = fopen($filepath, 'w');\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            $success = curl_exec($ch) && curl_getinfo($ch, CURLINFO_HTTP_CODE) === 200;\n            fclose($fp);\n            curl_close($ch);\n\n            if (!$success) {\n                unlink($filepath);\n                return false;\n            }\n        } elseif (ini_get('allow_url_fopen')) {\n            $success = copy($url, $filepath);\n            if (!$success) {\n                return false;\n            }\n        } else {\n            return new \\RuntimeException('The image formatter downloads an image from a remote HTTP server. Therefore, it requires that PHP can request remote hosts, either via cURL or fopen()');\n        }\n\n        return $fullPath ? $filepath : $filename;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Image\n{\n    const BASE_URL = 'https://via.placeholder.com/';\n    const FORMAT_JPG = 'jpg';\n    const FORMAT_JPEG = 'jpeg';\n    const FORMAT_PNG = 'png';\n\n    private array $categories = [\n        'animals', 'arch', 'nature', 'people', 'tech',\n    ];\n\n\n    public function image(\n        ?string $dir = null,\n        int $width = 640,\n        int $height = 480,\n        ?string $category = null,\n        bool $fullPath = true,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string|false {\n        $url = $this->imageUrl($width, $height, $category, $randomize, $word, $gray, $format);\n\n        $filename = basename(parse_url($url, PHP_URL_PATH));\n        $filepath = ($dir ? rtrim($dir, '/') . '/' : '') . $filename;\n\n        if (function_exists('curl_version')) {\n            $ch = curl_init($url);\n            $fp = fopen($filepath, 'wb');\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_exec($ch);\n            curl_close($ch);\n            fclose($fp);\n        } else {\n            $image = file_get_contents($url);\n            if ($image === false) {\n                return false;\n            }\n            file_put_contents($filepath, $image);\n        }\n\n\n        return $fullPath ? $filepath : $filename;\n    }\n\n    public function imageUrl(\n        int $width,\n        int $height,\n        ?string $category = null,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string {\n        $url = self::BASE_URL . $width . 'x' . $height;\n\n        if ($category && in_array($category, $this->categories)) {\n            $url .= '/' . $category;\n        }\n\n        if ($randomize) {\n            $url .= '?' . mt_rand();\n        }\n\n        if ($word) {\n            $url .= ($randomize ? '&' : '?') . 'text=' . urlencode($word);\n        }\n\n        if ($gray) {\n            $url .= ($randomize || $word) ? '&' : '?';\n            $url .= in_array($format, [self::FORMAT_JPG, self::FORMAT_JPEG]) ? 'grayscale' : 'greyscale';\n        }\n\n        switch ($format) {\n            case self::FORMAT_JPG:\n            case self::FORMAT_JPEG:\n                $url .= '.jpg';\n                break;\n            case self::FORMAT_PNG:\n            default:\n                $url .= '.png';\n                break;\n        }\n\n        return $url;\n    }\n}\n",
      "<?php\n\nclass Image\n{\n    const BASE_URL = 'https://via.placeholder.com/';\n    const FORMAT_JPG = 'jpg';\n    const FORMAT_JPEG = 'jpeg';\n    const FORMAT_PNG = 'png';\n\n    private array $categories = [\n        'animals', 'arch', 'nature', 'people', 'tech',\n    ];\n\n\n    public function image(\n        ?string $dir = null,\n        int $width = 640,\n        int $height = 480,\n        ?string $category = null,\n        bool $fullPath = true,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string|false {\n        $url = $this->imageUrl($width, $height, $category, $randomize, $word, $gray, $format);\n\n        $filename = basename(parse_url($url, PHP_URL_PATH));\n        $filepath = ($dir ?? sys_get_temp_dir()) . '/' . $filename;\n\n        if (function_exists('curl_version')) {\n            $ch = curl_init($url);\n            $fp = fopen($filepath, 'wb');\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_exec($ch);\n            curl_close($ch);\n            fclose($fp);\n        } else {\n            $image = file_get_contents($url);\n            if ($image === false) {\n                return false;\n            }\n            file_put_contents($filepath, $image);\n        }\n\n\n        return $fullPath ? $filepath : $filename;\n    }\n\n    public function imageUrl(\n        int $width,\n        int $height,\n        ?string $category = null,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string {\n        $url = self::BASE_URL . \"{$width}x{$height}\";\n\n        if ($category && in_array($category, $this->categories)) {\n            $url .= \"/$category\";\n        }\n\n        if ($randomize) {\n            $url .= '/' . rand(0, 1000);\n        }\n\n        if ($word) {\n            $url .= \"?text=$word\";\n        }\n\n        if ($gray) {\n            $url .= ($word ? '&' : '?') . 'bg=646464/fff';\n        }\n\n        switch ($format) {\n            case self::FORMAT_JPG:\n            case self::FORMAT_JPEG:\n                $url .= '.jpg';\n                break;\n            case self::FORMAT_PNG:\n            default:\n                $url .= '.png';\n                break;\n        }\n\n        return $url;\n    }\n}\n",
      "<?php\n\nclass Image\n{\n    const BASE_URL = 'https://via.placeholder.com/';\n    const FORMAT_JPG = 'jpg';\n    const FORMAT_JPEG = 'jpeg';\n    const FORMAT_PNG = 'png';\n\n    private array $categories = [\n        'animals', 'arch', 'nature', 'people', 'tech',\n    ];\n\n\n    public function image(\n        ?string $dir = null,\n        int $width = 640,\n        int $height = 480,\n        ?string $category = null,\n        bool $fullPath = true,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string|false {\n        $url = $this->imageUrl($width, $height, $category, $randomize, $word, $gray, $format);\n\n        $filename = basename(parse_url($url, PHP_URL_PATH));\n        $filepath = ($dir ?? sys_get_temp_dir()) . '/' . $filename;\n\n        if (function_exists('curl_version')) {\n            $ch = curl_init($url);\n            $fp = fopen($filepath, 'wb');\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_exec($ch);\n            curl_close($ch);\n            fclose($fp);\n        } else {\n            $image = file_get_contents($url);\n            if ($image === false) {\n                return false;\n            }\n            file_put_contents($filepath, $image);\n        }\n\n        return $fullPath ? $filepath : $filename;\n    }\n\n\n    public function imageUrl(\n        int $width,\n        int $height,\n        ?string $category = null,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string {\n        $url = self::BASE_URL . \"{$width}x{$height}\";\n\n        if ($category && in_array($category, $this->categories)) {\n            $url .= \"/$category\";\n        }\n\n        if ($randomize) {\n            $url .= '/' . rand(0, 1000);\n        }\n\n        if ($word) {\n            $url .= \"?text=$word\";\n        }\n\n        if ($gray) {\n            $url .= ($word ? '&' : '?') . 'bg=646464/fff';\n        }\n\n        switch ($format) {\n            case self::FORMAT_JPG:\n            case self::FORMAT_JPEG:\n                $url .= '.jpg';\n                break;\n            case self::FORMAT_PNG:\n            default:\n                $url .= '.png';\n                break;\n        }\n\n        return $url;\n    }\n}\n",
      "<?php\n\nclass Image\n{\n    const BASE_URL = 'https://via.placeholder.com/';\n    const FORMAT_JPG = 'jpg';\n    const FORMAT_JPEG = 'jpeg';\n    const FORMAT_PNG = 'png';\n\n    private array $categories = [\n        'animals', 'arch', 'nature', 'people', 'tech',\n    ];\n\n\n    public function image(\n        ?string $dir = null,\n        int $width = 640,\n        int $height = 480,\n        ?string $category = null,\n        bool $fullPath = true,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string|false {\n        $url = $this->imageUrl($width, $height, $category, $randomize, $word, $gray, $format);\n\n        $filename = basename(parse_url($url, PHP_URL_PATH));\n        $filepath = ($dir ?? sys_get_temp_dir()) . '/' . $filename;\n\n        if (function_exists('curl_version')) {\n            $ch = curl_init($url);\n            $fp = fopen($filepath, 'wb');\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_exec($ch);\n            curl_close($ch);\n            fclose($fp);\n        } else {\n            $image = file_get_contents($url);\n            if ($image === false) {\n                return false;\n            }\n            file_put_contents($filepath, $image);\n        }\n\n        return $fullPath ? $filepath : $filename;\n    }\n\n    public function imageUrl(\n        int $width,\n        int $height,\n        ?string $category = null,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string {\n        $url = self::BASE_URL . \"{$width}x{$height}\";\n\n        if ($category && in_array($category, $this->categories)) {\n            $url .= \"/$category\";\n        }\n\n        if ($randomize) {\n            $url .= '/' . rand(0, 1000);\n        }\n\n        if ($word) {\n            $url .= \"?text=$word\";\n        }\n\n        if ($gray) {\n            $url .= ($word ? '&' : '?') . 'bg=646464/fff';\n        }\n\n        switch ($format) {\n            case self::FORMAT_JPG:\n            case self::FORMAT_JPEG:\n                $url .= '.jpg';\n                break;\n            case self::FORMAT_PNG:\n            default:\n                $url .= '.png';\n                break;\n        }\n\n        return $url;\n    }\n}\n",
      "<?php\n\nclass Image\n{\n    const BASE_URL = 'https://via.placeholder.com/';\n    const FORMAT_JPG = 'jpg';\n    const FORMAT_JPEG = 'jpeg';\n    const FORMAT_PNG = 'png';\n\n    private array $categories = [\n        'animals', 'arch', 'nature', 'people', 'tech',\n    ];\n\n\n    public function image(\n        ?string $dir = null,\n        int $width = 640,\n        int $height = 480,\n        ?string $category = null,\n        bool $fullPath = true,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string|false {\n        $url = $this->imageUrl($width, $height, $category, $randomize, $word, $gray, $format);\n\n        $filename = basename(parse_url($url, PHP_URL_PATH));\n        $filepath = ($dir ?? sys_get_temp_dir()) . '/' . $filename;\n\n\n        if (function_exists('curl_version')) {\n            $ch = curl_init($url);\n            $fp = fopen($filepath, 'wb');\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_exec($ch);\n            curl_close($ch);\n            fclose($fp);\n        } else {\n            $image = file_get_contents($url);\n            if ($image === false) {\n                return false;\n            }\n            file_put_contents($filepath, $image);\n        }\n\n        return $fullPath ? $filepath : $filename;\n    }\n\n    public function imageUrl(\n        int $width,\n        int $height,\n        ?string $category = null,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string {\n\n        $url = self::BASE_URL . \"{$width}x{$height}\";\n\n        if ($category && in_array($category, $this->categories)) {\n            $url .= \"/$category\";\n        }\n\n        if ($randomize) {\n            $url .= '/' . rand(0, 1000);\n        }\n\n        if ($word) {\n            $url .= \"?text=$word\";\n        }\n\n\n        if ($gray) {\n            $url .= ($word ? '&' : '?') . 'grayscale';\n        }\n\n        switch ($format) {\n            case self::FORMAT_JPG:\n            case self::FORMAT_JPEG:\n                $url .= '.jpg';\n                break;\n            case self::FORMAT_PNG:\n            default:\n                $url .= '.png';\n        }\n\n        return $url;\n    }\n}\n",
      "<?php\n\nclass Image\n{\n    const BASE_URL = 'https://via.placeholder.com/';\n    const FORMAT_JPG = 'jpg';\n    const FORMAT_JPEG = 'jpeg';\n    const FORMAT_PNG = 'png';\n\n    private array $categories = [\n        'animals', 'arch', 'nature', 'people', 'tech',\n    ];\n\n\n    public function image(\n        ?string $dir = null,\n        int $width = 640,\n        int $height = 480,\n        ?string $category = null,\n        bool $fullPath = true,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string|false {\n        $url = $this->imageUrl($width, $height, $category, $randomize, $word, $gray, $format);\n\n        $filename = basename(parse_url($url, PHP_URL_PATH));\n        $filepath = ($dir ?? sys_get_temp_dir()) . '/' . $filename;\n\n\n        if (function_exists('curl_version')) {\n            $ch = curl_init($url);\n            $fp = fopen($filepath, 'wb');\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_exec($ch);\n            curl_close($ch);\n            fclose($fp);\n        } else {\n            $image = file_get_contents($url);\n            if ($image === false) {\n                return false;\n            }\n            file_put_contents($filepath, $image);\n        }\n\n        return $fullPath ? $filepath : $filename;\n    }\n\n    public function imageUrl(\n        int $width,\n        int $height,\n        ?string $category = null,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string {\n\n        $url = self::BASE_URL . \"{$width}x{$height}\";\n\n        if ($category && in_array($category, $this->categories)) {\n            $url .= \"/$category\";\n        }\n\n        if ($randomize) {\n            $url .= '/' . rand(0, 1000);\n        }\n\n\n        $params = [];\n        if ($word) {\n            $params['text'] = $word;\n        }\n        if ($gray) {\n            $params['bg'] = '000000/FFFFFF';\n        }\n\n        if ($format !== self::FORMAT_PNG) {\n            $params['format'] = $format;\n        }\n\n\n        if (!empty($params)) {\n            $url .= '?' . http_build_query($params);\n        }\n\n        return $url;\n    }\n}\n",
      "<?php\n\nclass Image\n{\n    const BASE_URL = 'https://via.placeholder.com/';\n    const FORMAT_JPG = 'jpg';\n    const FORMAT_JPEG = 'jpeg';\n    const FORMAT_PNG = 'png';\n\n    private array $categories = [\n        'animals', 'arch', 'nature', 'people', 'tech',\n    ];\n\n\n    public function image(\n        ?string $dir = null,\n        int $width = 640,\n        int $height = 480,\n        ?string $category = null,\n        bool $fullPath = true,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string|false {\n        $url = $this->imageUrl($width, $height, $category, $randomize, $word, $gray, $format);\n\n        $filename = basename(parse_url($url, PHP_URL_PATH));\n        $filepath = ($dir ? rtrim($dir, '/') . '/' : '') . $filename;\n\n        if (function_exists('curl_version')) {\n            $ch = curl_init($url);\n            $fp = fopen($filepath, 'wb');\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_exec($ch);\n            curl_close($ch);\n            fclose($fp);\n        } else {\n            $image = file_get_contents($url);\n            if ($image === false) {\n                return false;\n            }\n            file_put_contents($filepath, $image);\n        }\n\n        return $fullPath ? $filepath : $filename;\n    }\n\n    public function imageUrl(\n        int $width,\n        int $height,\n        ?string $category = null,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string {\n        $url = self::BASE_URL . $width . 'x' . $height;\n\n        if ($category && in_array($category, $this->categories)) {\n            $url .= '/' . $category;\n        }\n\n        if ($randomize) {\n            $url .= '?' . mt_rand();\n        }\n\n        if ($word) {\n            $url .= ($randomize ? '&' : '?') . 'text=' . urlencode($word);\n        }\n\n        if ($gray) {\n            $url .= ($randomize || $word ? '&' : '?') . 'bg=000000/FFFFFF';\n        }\n\n        switch ($format) {\n            case self::FORMAT_JPG:\n            case self::FORMAT_JPEG:\n                $url .= '.jpg';\n                break;\n            case self::FORMAT_PNG:\n            default:\n                $url .= '.png';\n                break;\n        }\n\n        return $url;\n    }\n}\n",
      "<?php\n\nclass Image\n{\n    const BASE_URL = 'https://via.placeholder.com/';\n    const FORMAT_JPG = 'jpg';\n    const FORMAT_JPEG = 'jpeg';\n    const FORMAT_PNG = 'png';\n\n    private array $categories = [\n        'animals', 'arch', 'nature', 'people', 'tech',\n    ];\n\n\n    public function image(\n        ?string $dir = null,\n        int $width = 640,\n        int $height = 480,\n        ?string $category = null,\n        bool $fullPath = true,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string|false {\n        $url = $this->imageUrl($width, $height, $category, $randomize, $word, $gray, $format);\n\n        $filename = basename(parse_url($url, PHP_URL_PATH));\n        $filepath = ($dir ?? sys_get_temp_dir()) . '/' . $filename;\n\n        if (function_exists('curl_version')) {\n            $ch = curl_init($url);\n            $fp = fopen($filepath, 'wb');\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_exec($ch);\n            curl_close($ch);\n            fclose($fp);\n        } else {\n            $content = file_get_contents($url);\n            if ($content === false) {\n                return false;\n            }\n            file_put_contents($filepath, $content);\n        }\n\n\n        return $fullPath ? $filepath : $filename;\n    }\n\n    public function imageUrl(\n        int $width,\n        int $height,\n        ?string $category = null,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string {\n        $url = self::BASE_URL . \"{$width}x{$height}\";\n\n        if ($category && in_array($category, $this->categories, true)) {\n            $url .= \"/$category\";\n        }\n\n        if ($randomize) {\n            $url .= '/' . rand(0, 1000);\n        }\n\n        if ($word) {\n            $url .= \"?text=$word\";\n        }\n\n        if ($gray) {\n            $url .= ($word ? '&' : '?') . 'bg=646464/fff';\n        }\n\n        switch ($format) {\n            case self::FORMAT_JPG:\n            case self::FORMAT_JPEG:\n                $url .= '.jpg';\n                break;\n            case self::FORMAT_PNG:\n            default:\n                $url .= '.png';\n                break;\n        }\n\n        return $url;\n    }\n}\n",
      "<?php\n\nclass Image\n{\n    const BASE_URL = 'https://via.placeholder.com/';\n    const FORMAT_JPG = 'jpg';\n    const FORMAT_JPEG = 'jpeg';\n    const FORMAT_PNG = 'png';\n\n    private array $categories = [\n        'animals', 'arch', 'nature', 'people', 'tech',\n    ];\n\n\n    public function image(\n        ?string $dir = null,\n        int $width = 640,\n        int $height = 480,\n        ?string $category = null,\n        bool $fullPath = true,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string|false {\n        $url = $this->imageUrl($width, $height, $category, $randomize, $word, $gray, $format);\n\n        $filename = basename(parse_url($url, PHP_URL_PATH));\n        $filepath = ($dir ?? sys_get_temp_dir()) . '/' . $filename;\n\n\n        if (function_exists('curl_version')) {\n            $ch = curl_init($url);\n            $fp = fopen($filepath, 'wb');\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_exec($ch);\n            curl_close($ch);\n            fclose($fp);\n        } else {\n            $image = file_get_contents($url);\n            if ($image === false) {\n                return false;\n            }\n            file_put_contents($filepath, $image);\n        }\n\n        return $fullPath ? $filepath : $filename;\n    }\n\n    public function imageUrl(\n        int $width,\n        int $height,\n        ?string $category = null,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string {\n\n        $url = self::BASE_URL . \"{$width}x{$height}\";\n\n        if ($category && in_array($category, $this->categories)) {\n            $url .= \"/$category\";\n        }\n\n\n        if ($randomize) {\n            $url .= '/' . rand(0, 1000);\n        }\n\n        if ($word) {\n            $url .= \"?text=$word\";\n        }\n\n\n        if ($gray) {\n            $url .= ($word ? '&' : '?') . 'bg=000000/FFFFFF';\n        }\n\n        switch ($format) {\n            case self::FORMAT_JPG:\n            case self::FORMAT_JPEG:\n                $url .= '.jpg';\n                break;\n            case self::FORMAT_PNG:\n            default:\n                $url .= '.png';\n                break;\n        }\n\n        return $url;\n    }\n}\n?>\n",
      "<?php\n\nclass Image\n{\n    const BASE_URL = 'https://via.placeholder.com/';\n    const FORMAT_JPG = 'jpg';\n    const FORMAT_JPEG = 'jpeg';\n    const FORMAT_PNG = 'png';\n\n    private array $categories = [\n        'animals', 'arch', 'nature', 'people', 'tech',\n    ];\n\n\n    public function image(\n        ?string $dir = null,\n        int $width = 640,\n        int $height = 480,\n        ?string $category = null,\n        bool $fullPath = true,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string|false {\n        $url = $this->imageUrl($width, $height, $category, $randomize, $word, $gray, $format);\n\n        $filename = basename(parse_url($url, PHP_URL_PATH));\n        $filepath = ($dir ?? sys_get_temp_dir()) . '/' . $filename;\n\n\n        if (function_exists('curl_version')) {\n            $ch = curl_init($url);\n            $fp = fopen($filepath, 'wb');\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_exec($ch);\n            curl_close($ch);\n            fclose($fp);\n        } else {\n            $image = file_get_contents($url);\n            if ($image === false) {\n                return false;\n            }\n            file_put_contents($filepath, $image);\n        }\n\n        return $fullPath ? $filepath : $filename;\n    }\n\n\n    public function imageUrl(\n        int $width,\n        int $height,\n        ?string $category = null,\n        bool $randomize = true,\n        ?string $word = null,\n        bool $gray = false,\n        string $format = 'png'\n    ): string {\n        $url = self::BASE_URL . \"{$width}x{$height}\";\n\n        if ($category && in_array($category, $this->categories)) {\n            $url .= \"/$category\";\n        }\n\n        if ($randomize) {\n            $url .= '/' . rand(0, 1000);\n        }\n\n        if ($word) {\n            $url .= \"?text=$word\";\n        }\n\n        if ($gray) {\n            $url .= ($word ? '&' : '?') . 'bg=646464/fff';\n        }\n\n        switch ($format) {\n            case self::FORMAT_JPG:\n            case self::FORMAT_JPEG:\n                $url .= '.jpg';\n                break;\n            case self::FORMAT_PNG:\n            default:\n                $url .= '.png';\n                break;\n        }\n\n        return $url;\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a PHP class that fetches currency conversion rates from an external API and stores them in a repository.\n\nClass Description: The FetchConversionRate class is responsible for retrieving currency conversion rates between a base currency and all other available currencies. It uses Guzzle HTTP client to make requests to an external currency API and stores the results in a conversion rate repository.\n\nAttributes:\n- baseCurrencyId: int - The ID of the base currency for which conversion rates will be fetched\n- currencyRepository: CurrencyRepository - Repository for accessing currency data\n- conversionRateRepository: ConversionRateRepository - Repository for storing conversion rates\n\nMethods:\n- __construct(int $baseCurrencyId) -> void - Constructor that initializes the base currency ID\n- handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository) -> void - Main method that executes the conversion rate fetching process:\n  - Retrieves all currencies from the repository\n  - For each target currency, makes an API request to get the conversion rate\n  - Stores or updates the conversion rate in the repository\n  - Skips invalid currencies and handles API request failures gracefully",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse Exception;\n\nclass FetchConversionRate\n{\n    protected $baseCurrencyId;\n    private $currencyRepository;\n    private $conversionRateRepository;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(\n        CurrencyRepository $currencyRepository,\n        ConversionRateRepository $conversionRateRepository\n    ): void {\n        $this->currencyRepository = $currencyRepository;\n        $this->conversionRateRepository = $conversionRateRepository;\n\n        $baseCurrency = $this->currencyRepository->getById($this->baseCurrencyId);\n\n        if (!$baseCurrency || !$baseCurrency->iso) {\n            return;\n        }\n\n        $client = new Client();\n\n        foreach ($this->currencyRepository->getAll() as $targetCurrency) {\n            if (!$targetCurrency->iso || $baseCurrency->iso === $targetCurrency->iso) {\n                continue;\n            }\n\n            $url = sprintf(\n                'https://cdn.jsdelivr.net/npm/@fawazahmed0/currency-api@latest/v1/currencies/%s.json',\n                $baseCurrency->iso_lowercased,\n            );\n\n            try {\n                $response = $client->request('GET', $url);\n                $decoded_response = json_decode($response->getBody(), true);\n                $rate = $decoded_response[$baseCurrency->iso_lowercased][$targetCurrency->iso_lowercased];\n            } catch (Exception) {\n                continue;\n            }\n\n            $this->conversionRateRepository->createOrUpdate(\n                $baseCurrency->id,\n                $targetCurrency->id,\n                $rate\n            );\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nclass FetchConversionRate\n{\n    private int $baseCurrencyId;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $currencies = $currencyRepository->findAll();\n\n        foreach ($currencies as $currency) {\n            if ($currency->getId() === $this->baseCurrencyId) {\n                continue;\n            }\n\n            try {\n                $client = new GuzzleHttp\\Client();\n                $response = $client->request('GET', \"https://api.example.com/convert?from={$this->baseCurrencyId}&to={$currency->getId()}\");\n\n                if ($response->getStatusCode() === 200) {\n                    $data = json_decode($response->getBody(), true);\n                    $rate = $data['rate'];\n\n                    $conversionRate = $conversionRateRepository->findByBaseAndTargetCurrency($this->baseCurrencyId, $currency->getId());\n\n                    if ($conversionRate) {\n                        $conversionRate->setRate($rate);\n                        $conversionRateRepository->update($conversionRate);\n                    } else {\n                        $conversionRate = new ConversionRate($this->baseCurrencyId, $currency->getId(), $rate);\n                        $conversionRateRepository->save($conversionRate);\n                    }\n                } else {\n                    // Handle API error\n                    error_log(\"API request failed for currency {$currency->getId()}: {$response->getStatusCode()}\");\n                }\n            } catch (GuzzleHttp\\Exception\\GuzzleException $e) {\n                // Handle Guzzle exception\n                error_log(\"Guzzle exception: {$e->getMessage()}\");\n            } catch (Exception $e) {\n                // Handle other exceptions\n                error_log(\"Exception: {$e->getMessage()}\");\n            }\n        }\n    }\n}\n",
      "<?php\n\nclass FetchConversionRate\n{\n    private int $baseCurrencyId;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $currencies = $currencyRepository->findAll();\n\n        foreach ($currencies as $currency) {\n            if ($currency->getId() === $this->baseCurrencyId) {\n                continue;\n            }\n\n            try {\n                $client = new GuzzleHttp\\Client();\n                $response = $client->request('GET', \"https://api.example.com/convert?from={$this->baseCurrencyId}&to={$currency->getId()}\");\n\n                if ($response->getStatusCode() === 200) {\n                    $data = json_decode($response->getBody(), true);\n                    $rate = $data['rate'];\n\n                    $conversionRate = $conversionRateRepository->findByBaseAndTargetCurrency($this->baseCurrencyId, $currency->getId());\n\n                    if ($conversionRate) {\n                        $conversionRate->setRate($rate);\n                        $conversionRateRepository->update($conversionRate);\n                    } else {\n                        $conversionRate = new ConversionRate($this->baseCurrencyId, $currency->getId(), $rate);\n                        $conversionRateRepository->save($conversionRate);\n                    }\n                } else {\n                    // Handle API error\n                    error_log(\"API request failed for currency {$currency->getId()}: {$response->getStatusCode()}\");\n                }\n            } catch (GuzzleHttp\\Exception\\RequestException $e) {\n                // Handle request exception\n                error_log(\"Request exception for currency {$currency->getId()}: {$e->getMessage()}\");\n            } catch (Exception $e) {\n                error_log(\"Error processing currency {$currency->getId()}: {$e->getMessage()}\");\n            }\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass FetchConversionRate\n{\n    private int $baseCurrencyId;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $currencies = $currencyRepository->findAll();\n\n        foreach ($currencies as $currency) {\n            if ($currency->getId() === $this->baseCurrencyId) {\n                continue;\n            }\n\n            try {\n                $client = new GuzzleHttp\\Client();\n                $response = $client->request('GET', \"https://api.example.com/convert?from={$this->baseCurrencyId}&to={$currency->getId()}\");\n\n                if ($response->getStatusCode() === 200) {\n                    $data = json_decode($response->getBody(), true);\n                    $rate = $data['rate'];\n\n                    $conversionRate = $conversionRateRepository->findByBaseAndTargetCurrency($this->baseCurrencyId, $currency->getId());\n\n                    if ($conversionRate) {\n                        $conversionRate->setRate($rate);\n                        $conversionRateRepository->update($conversionRate);\n                    } else {\n                        $conversionRate = new ConversionRate($this->baseCurrencyId, $currency->getId(), $rate);\n                        $conversionRateRepository->save($conversionRate);\n                    }\n                } else {\n                    // Handle API error\n                    error_log(\"API request failed for currency {$currency->getId()}: {$response->getStatusCode()}\");\n                }\n            } catch (GuzzleHttp\\Exception\\GuzzleException $e) {\n                // Handle Guzzle exception\n                error_log(\"Guzzle exception: {$e->getMessage()}\");\n            } catch (Exception $e) {\n                // Handle other exceptions\n                error_log(\"Exception: {$e->getMessage()}\");\n            }\n        }\n    }\n}\n",
      "<?php\n\nclass FetchConversionRate\n{\n    private int $baseCurrencyId;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $currencies = $currencyRepository->findAll();\n\n        foreach ($currencies as $currency) {\n            if ($currency->getId() === $this->baseCurrencyId) {\n                continue;\n            }\n\n            try {\n                $client = new GuzzleHttp\\Client();\n                $response = $client->request('GET', \"https://api.example.com/convert?from={$this->baseCurrencyId}&to={$currency->getId()}\");\n\n                $data = json_decode($response->getBody(), true);\n                $rate = $data['rate'];\n\n                $conversionRate = $conversionRateRepository->findByBaseAndTargetCurrency($this->baseCurrencyId, $currency->getId());\n\n                if ($conversionRate) {\n                    $conversionRate->setRate($rate);\n                    $conversionRateRepository->update($conversionRate);\n                } else {\n                    $conversionRate = new ConversionRate($this->baseCurrencyId, $currency->getId(), $rate);\n                    $conversionRateRepository->save($conversionRate);\n                }\n            } catch (GuzzleHttp\\Exception\\GuzzleException $e) {\n                // Log the error or handle it appropriately\n                error_log(\"Error fetching conversion rate: \" . $e->getMessage());\n                continue;\n            } catch (Exception $e) {\n                // Handle other potential exceptions like invalid JSON data\n                error_log(\"Error processing conversion rate: \" . $e->getMessage());\n                continue;\n            }\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass FetchConversionRate\n{\n    private int $baseCurrencyId;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $currencies = $currencyRepository->findAll();\n\n        foreach ($currencies as $currency) {\n            if ($currency->getId() === $this->baseCurrencyId) {\n                continue;\n            }\n\n            try {\n                $client = new GuzzleHttp\\Client();\n                $response = $client->request('GET', \"https://api.example.com/convert?from={$this->baseCurrencyId}&to={$currency->getId()}\");\n\n                if ($response->getStatusCode() === 200) {\n                    $data = json_decode($response->getBody(), true);\n                    $rate = $data['rate'];\n\n                    $conversionRate = $conversionRateRepository->findByBaseAndTargetCurrency($this->baseCurrencyId, $currency->getId());\n\n                    if ($conversionRate) {\n                        $conversionRate->setRate($rate);\n                        $conversionRateRepository->update($conversionRate);\n                    } else {\n                        $conversionRate = new ConversionRate($this->baseCurrencyId, $currency->getId(), $rate);\n                        $conversionRateRepository->save($conversionRate);\n                    }\n                } else {\n                    // Handle API error\n                    error_log(\"API request failed for currency {$currency->getId()}: {$response->getStatusCode()}\");\n                }\n            } catch (GuzzleHttp\\Exception\\GuzzleException $e) {\n                // Handle Guzzle exception\n                error_log(\"Guzzle exception: {$e->getMessage()}\");\n            } catch (Exception $e) {\n                // Handle other exceptions\n                error_log(\"Exception: {$e->getMessage()}\");\n            }\n        }\n    }\n}\n",
      "<?php\n\nclass FetchConversionRate\n{\n    private int $baseCurrencyId;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $currencies = $currencyRepository->findAll();\n\n        foreach ($currencies as $currency) {\n            if ($currency->getId() === $this->baseCurrencyId) {\n                continue;\n            }\n\n            try {\n                $client = new GuzzleHttp\\Client();\n                $response = $client->request('GET', \"https://api.example.com/convert?from={$this->baseCurrencyId}&to={$currency->getId()}\");\n\n                if ($response->getStatusCode() === 200) {\n                    $data = json_decode($response->getBody(), true);\n                    $rate = $data['rate'];\n\n                    $conversionRate = $conversionRateRepository->findByBaseAndTargetCurrency($this->baseCurrencyId, $currency->getId());\n\n                    if ($conversionRate) {\n                        $conversionRate->setRate($rate);\n                        $conversionRateRepository->update($conversionRate);\n                    } else {\n                        $conversionRate = new ConversionRate($this->baseCurrencyId, $currency->getId(), $rate);\n                        $conversionRateRepository->save($conversionRate);\n                    }\n                } else {\n                    // Handle API error\n                    error_log(\"API request failed for currency {$currency->getId()}: {$response->getStatusCode()}\");\n                }\n            } catch (GuzzleHttp\\Exception\\GuzzleException $e) {\n                // Handle Guzzle exception\n                error_log(\"Guzzle exception: {$e->getMessage()}\");\n            } catch (Exception $e) {\n                // Handle other exceptions\n                error_log(\"Exception: {$e->getMessage()}\");\n            }\n        }\n    }\n}\n",
      "<?php\n\nclass FetchConversionRate\n{\n    private int $baseCurrencyId;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $currencies = $currencyRepository->findAll();\n\n        foreach ($currencies as $currency) {\n            if ($currency->getId() === $this->baseCurrencyId) {\n                continue;\n            }\n\n            try {\n                $client = new GuzzleHttp\\Client();\n                $response = $client->request('GET', \"https://api.example.com/convert?from={$this->baseCurrencyId}&to={$currency->getId()}\");\n\n                if ($response->getStatusCode() === 200) {\n                    $data = json_decode($response->getBody(), true);\n                    $rate = $data['rate'];\n\n                    $conversionRate = $conversionRateRepository->findByBaseAndTargetCurrency($this->baseCurrencyId, $currency->getId());\n\n                    if ($conversionRate) {\n                        $conversionRate->setRate($rate);\n                        $conversionRateRepository->update($conversionRate);\n                    } else {\n                        $conversionRate = new ConversionRate($this->baseCurrencyId, $currency->getId(), $rate);\n                        $conversionRateRepository->save($conversionRate);\n                    }\n                } else {\n                    // Handle API error\n                    error_log(\"API request failed for currency {$currency->getId()} with status code: \" . $response->getStatusCode());\n                }\n            } catch (GuzzleHttp\\Exception\\GuzzleException $e) {\n                // Handle Guzzle exception\n                error_log(\"Guzzle exception: \" . $e->getMessage());\n            } catch (Exception $e) {\n                // Handle other exceptions\n                error_log(\"Exception: \" . $e->getMessage());\n            }\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass FetchConversionRate\n{\n    private int $baseCurrencyId;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $currencies = $currencyRepository->findAll();\n\n        foreach ($currencies as $currency) {\n            if ($currency->getId() === $this->baseCurrencyId) {\n                continue;\n            }\n\n            try {\n                $client = new GuzzleHttp\\Client();\n                $response = $client->request('GET', \"https://api.example.com/convert?from={$this->baseCurrencyId}&to={$currency->getId()}\");\n\n                $data = json_decode($response->getBody(), true);\n                $rate = $data['rate'];\n\n                $conversionRate = $conversionRateRepository->findByBaseAndTargetCurrency($this->baseCurrencyId, $currency->getId());\n\n                if ($conversionRate) {\n                    $conversionRate->setRate($rate);\n                    $conversionRateRepository->update($conversionRate);\n                } else {\n                    $conversionRate = new ConversionRate($this->baseCurrencyId, $currency->getId(), $rate);\n                    $conversionRateRepository->save($conversionRate);\n                }\n            } catch (GuzzleHttp\\Exception\\GuzzleException $e) {\n                // Log the error or handle it appropriately\n                error_log(\"Error fetching conversion rate: \" . $e->getMessage());\n                continue;\n            } catch (Exception $e) {\n                // Handle other potential exceptions like invalid JSON data\n                error_log(\"Error processing conversion rate: \" . $e->getMessage());\n                continue;\n            }\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass FetchConversionRate\n{\n    private int $baseCurrencyId;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $currencies = $currencyRepository->findAll();\n\n        foreach ($currencies as $currency) {\n            if ($currency->getId() === $this->baseCurrencyId) {\n                continue;\n            }\n\n            try {\n                $client = new GuzzleHttp\\Client();\n                $response = $client->request('GET', \"https://api.example.com/convert?from={$this->baseCurrencyId}&to={$currency->getId()}\");\n\n                if ($response->getStatusCode() === 200) {\n                    $data = json_decode($response->getBody(), true);\n                    $rate = $data['rate'];\n\n                    $conversionRate = $conversionRateRepository->findByBaseAndTargetCurrency($this->baseCurrencyId, $currency->getId());\n\n                    if ($conversionRate) {\n                        $conversionRate->setRate($rate);\n                        $conversionRateRepository->update($conversionRate);\n                    } else {\n                        $conversionRate = new ConversionRate($this->baseCurrencyId, $currency->getId(), $rate);\n                        $conversionRateRepository->save($conversionRate);\n                    }\n                } else {\n                    // Handle API error\n                    error_log(\"API request failed for currency {$currency->getId()}: {$response->getStatusCode()}\");\n                }\n            } catch (GuzzleHttp\\Exception\\RequestException $e) {\n                // Handle request exception\n                error_log(\"Request exception for currency {$currency->getId()}: {$e->getMessage()}\");\n            } catch (Exception $e) {\n                error_log(\"An unexpected error occurred: {$e->getMessage()}\");\n            }\n        }\n    }\n}\n",
      "<?php\n\nclass FetchConversionRate\n{\n    private int $baseCurrencyId;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $currencies = $currencyRepository->findAll();\n\n        foreach ($currencies as $currency) {\n            if ($currency->getId() === $this->baseCurrencyId) {\n                continue;\n            }\n\n            try {\n                $client = new GuzzleHttp\\Client();\n                $response = $client->request('GET', \"https://api.example.com/convert?from={$this->baseCurrencyId}&to={$currency->getId()}\");\n\n                $data = json_decode($response->getBody(), true);\n                $rate = $data['rate'];\n\n                $conversionRate = $conversionRateRepository->findByBaseAndTargetCurrency($this->baseCurrencyId, $currency->getId());\n\n                if ($conversionRate) {\n                    $conversionRate->setRate($rate);\n                    $conversionRateRepository->update($conversionRate);\n                } else {\n                    $conversionRate = new ConversionRate($this->baseCurrencyId, $currency->getId(), $rate);\n                    $conversionRateRepository->save($conversionRate);\n                }\n            } catch (GuzzleHttp\\Exception\\GuzzleException $e) {\n                // Log the error or handle it appropriately\n                error_log(\"Error fetching conversion rate: \" . $e->getMessage());\n                continue;\n            } catch (Exception $e) {\n                // Handle other potential exceptions like invalid JSON data\n                error_log(\"Error processing conversion rate: \" . $e->getMessage());\n                continue;\n            }\n        }\n    }\n}\n?>\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Create a function that retrieves the content of a specified URL using PHP's cURL library, with appropriate settings for handling redirects and mimicking a mobile user agent.\n\nFunction Description: The function uses PHP's cURL functions to make an HTTP request to the specified URL. It configures the cURL session to return the response as a string rather than outputting it directly, follows any redirects, and sets a mobile user agent string to mimic a mobile browser. The function then executes the request, closes the cURL session, and returns the response content.\n\nInput: \n- $url (string): The URL from which to retrieve content\n\nOutput: \n- (string): The content retrieved from the specified URL, or false if the request fails",
    "Canonical_solution": "function GetUrlContent($url)\n{\n    $curl = curl_init($url);\n    curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1);\n    curl_setopt($curl, CURLOPT_USERAGENT, 'Mozilla/5.0 (iPhone; U; CPU iPhone OS 3_0 like Mac OS X; en-us) AppleWebKit/528.18 (KHTML, like Gecko) Version/4.0 Mobile/7A341 Safari/528.16');\n    $res = curl_exec($curl);\n    curl_close($curl);\n    return $res;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction fetch_url_mobile($url) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 11; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.210 Mobile Safari/537.36');\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url_mobile($url) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Mobile Safari/537.36');\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url_mobile($url) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url_mobile($url) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 11; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.210 Mobile Safari/537.36');\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url_mobile($url) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 11; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.210 Mobile Safari/537.36');\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url_mobile($url) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url_mobile($url) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 13) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.130 Mobile Safari/537.36');\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url_mobile($url) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url_mobile($url) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction fetch_url_mobile($url) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 11; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.210 Mobile Safari/537.36');\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Create a PHP class that implements Alipay payment integration using cURL for HTTP communication with Alipay's API.\n\nClass Description: The AlipayService class provides functionality to interact with Alipay's payment gateway. It handles payment request creation, signing, and communication with Alipay's API endpoints.\n\nAttributes:\n- appId: [string] - The application ID provided by Alipay\n- notifyUrl: [string] - The URL where Alipay will send payment notifications\n- charset: [string] - Character encoding (default: 'utf-8')\n- rsaPrivateKey: [string] - The RSA private key for signing requests\n- totalFee: [float] - The total payment amount\n- outTradeNo: [string] - The merchant's unique order number\n- orderName: [string] - Description of the order\n\nMethods:\n- __construct() -> [void] - Initializes the class with default charset\n- setAppid(string $appid) -> [void] - Sets the Alipay application ID\n- setNotifyUrl(string $notifyUrl) -> [void] - Sets the notification URL\n- setRsaPrivateKey(string $saPrivateKey) -> [void] - Sets the RSA private key\n- setTotalFee(float $payAmount) -> [void] - Sets the payment amount\n- setOutTradeNo(string $outTradeNo) -> [void] - Sets the merchant order number\n- setOrderName(string $orderName) -> [void] - Sets the order description\n- doPay() -> [array] - Prepares and sends payment request to Alipay, returns response\n- curlPost(string $url, mixed $postData, array $options) -> [string] - Executes cURL POST request to specified URL\n- generateSign(array $params, string $signType) -> [string] - Generates signature for request parameters (implementation not shown in reference code)",
    "Canonical_solution": "class AlipayService\n{\n    protected $appId;\n    protected $notifyUrl;\n    protected $charset;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($saPrivateKey)\n    {\n        $this->rsaPrivateKey = $saPrivateKey;\n    }\n\n    public function setTotalFee($payAmount)\n    {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function doPay()\n    {\n        $requestConfigs = array(\n            'out_trade_no'=>$this->outTradeNo,\n            'total_amount'=>$this->totalFee,\n            'subject'=>$this->orderName,\n            'timeout_express'=>'2h'\n        );\n        $commonConfigs = array(\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.precreate',\n            'format' => 'JSON',\n            'charset'=>$this->charset,\n            'sign_type'=>'RSA2',\n            'timestamp'=>date('Y-m-d H:i:s'),\n            'version'=>'1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content'=>json_encode($requestConfigs),\n        );\n        $commonConfigs[\"sign\"] = $this->generateSign($commonConfigs, $commonConfigs['sign_type']);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do?charset='.$this->charset,$commonConfigs);\n        return json_decode($result,true);\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array())\n    {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n\n    public function doPay() {\n        $bizContent = [\n            'subject' => $this->orderName,\n            'out_trade_no' => $this->outTradeNo,\n            'total_amount' => $this->totalFee,\n            'product_code' => 'FAST_INSTANT_TRADE_PAY',\n        ];\n        $data = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.page.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n        $data['sign'] = $this->generateSign($data, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do?' . http_build_query($data);\n        return ['url' => $url];\n    }\n\n    public function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    public function generateSign($params, $signType) {\n        // Implementation for generating signature is not provided in the reference code.\n        // This method should be implemented based on Alipay's documentation.\n        return ''; // Placeholder\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function doPay() {\n        $bizContent = [\n            'subject' => $this->orderName,\n            'out_trade_no' => $this->outTradeNo,\n            'total_amount' => $this->totalFee,\n            'product_code' => 'FAST_INSTANT_TRADE_PAY',\n        ];\n        $data = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.page.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n        $data['sign'] = $this->generateSign($data, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do?' . http_build_query($data);\n        return ['url' => $url];\n    }\n\n    public function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        $result = curl_exec($ch);\n        curl_close($ch);\n        return $result;\n    }\n\n    public function generateSign($params, $signType) {\n        // Implementation for generating signature is not provided in the reference code.\n        // This method should be implemented based on Alipay's documentation.\n        return ''; // Placeholder\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function doPay() {\n        $bizContent = [\n            'subject' => $this->orderName,\n            'out_trade_no' => $this->outTradeNo,\n            'total_amount' => $this->totalFee,\n            'product_code' => 'FAST_INSTANT_TRADE_PAY',\n        ];\n        $data = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.page.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n        $data['sign'] = $this->generateSign($data, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do?' . http_build_query($data);\n        return ['url' => $url];\n    }\n\n\n    public function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    public function generateSign($params, $signType) {\n        // Implementation for generating signature is not provided in the reference code.\n        // This method should be implemented based on Alipay's documentation.\n        return ''; // Placeholder\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n\n    public function doPay() {\n        $bizContent = [\n            'subject' => $this->orderName,\n            'out_trade_no' => $this->outTradeNo,\n            'total_amount' => $this->totalFee,\n            'product_code' => 'FAST_INSTANT_TRADE_PAY',\n        ];\n        $data = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.page.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n        $data['sign'] = $this->generateSign($data, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do?' . http_build_query($data);\n        return ['url' => $url];\n\n    }\n\n    public function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        $result = curl_exec($ch);\n        curl_close($ch);\n        return $result;\n    }\n\n    public function generateSign($params, $signType) {\n        // Implementation for generating signature is not provided in the reference code.\n        // This method should be implemented based on Alipay's documentation.\n        return ''; // Placeholder\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function doPay() {\n        $bizContent = [\n            'subject' => $this->orderName,\n            'out_trade_no' => $this->outTradeNo,\n            'total_amount' => $this->totalFee,\n            'product_code' => 'FAST_INSTANT_TRADE_PAY',\n        ];\n        $data = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.page.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n        $data['sign'] = $this->generateSign($data, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do?' . http_build_query($data);\n        return ['url' => $url];\n    }\n\n\n    public function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    public function generateSign($params, $signType) {\n        // Implementation for generating signature is not provided in the reference code.\n        // This method should be implemented based on Alipay's documentation.\n        return ''; // Placeholder\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n\n    public function doPay() {\n        $bizContent = [\n            'subject' => $this->orderName,\n            'out_trade_no' => $this->outTradeNo,\n            'total_amount' => $this->totalFee,\n            'product_code' => 'FAST_INSTANT_TRADE_PAY',\n        ];\n        $data = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.page.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n        $data['sign'] = $this->generateSign($data, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do?' . http_build_query($data);\n        return ['url' => $url];\n    }\n\n    public function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    public function generateSign($params, $signType) {\n        // Implementation for generating signature is not provided in the reference code.\n        // This method should be implemented based on Alipay's documentation for signature generation.\n        return ''; // Placeholder\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService\n{\n    protected $appId;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n\n    public function doPay()\n    {\n        $bizContent = [\n            'subject' => $this->orderName,\n            'out_trade_no' => $this->outTradeNo,\n            'total_amount' => $this->totalFee,\n            'product_code' => 'FAST_INSTANT_TRADE_PAY',\n        ];\n        $data = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.page.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n        $data['sign'] = $this->generateSign($data, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do?' . http_build_query($data);\n        return ['url' => $url];\n\n    }\n\n    public function curlPost($url, $postData, $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        $result = curl_exec($ch);\n        curl_close($ch);\n        return $result;\n    }\n\n\n    public function generateSign(array $params, string $signType = 'RSA2'): string\n    {\n        return ''; // Implementation for generating signature is not provided in the reference code.\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n\n    public function doPay() {\n        $bizContent = [\n            'subject' => $this->orderName,\n            'out_trade_no' => $this->outTradeNo,\n            'total_amount' => $this->totalFee,\n            'product_code' => 'FAST_INSTANT_TRADE_PAY',\n        ];\n        $data = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.page.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n        $data['sign'] = $this->generateSign($data, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do?' . http_build_query($data);\n        return ['url' => $url];\n    }\n\n    public function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        $result = curl_exec($ch);\n        curl_close($ch);\n        return $result;\n    }\n\n    public function generateSign($params, $signType) {\n        // Implementation for generating signature is not provided in the reference code.\n        // This method should be implemented based on Alipay's documentation.\n        return ''; // Placeholder\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService\n{\n    protected $appId;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n\n    public function doPay()\n    {\n        $bizContent = [\n            'subject' => $this->orderName,\n            'out_trade_no' => $this->outTradeNo,\n            'total_amount' => $this->totalFee,\n            'product_code' => 'FAST_INSTANT_TRADE_PAY',\n        ];\n        $data = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.page.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n        $data['sign'] = $this->generateSign($data, 'RSA2');\n        return $data;\n    }\n\n    public function curlPost($url, $postData, $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    public function generateSign($params, $signType)\n    {\n        // Implementation for generating signature is not provided in the reference code.\n        // This method should be implemented based on Alipay's documentation.\n        return '';\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n\n    public function doPay() {\n        $bizContent = [\n            'subject' => $this->orderName,\n            'out_trade_no' => $this->outTradeNo,\n            'total_amount' => $this->totalFee,\n            'product_code' => 'FAST_INSTANT_TRADE_PAY',\n        ];\n        $data = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.page.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n        $data['sign'] = $this->generateSign($data, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do?' . http_build_query($data);\n        return ['url' => $url];\n    }\n\n    public function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        $result = curl_exec($ch);\n        curl_close($ch);\n        return $result;\n    }\n\n    public function generateSign($params, $signType) {\n        // Implementation for generating signature is not provided in the reference code.\n        // This method should be implemented based on Alipay's documentation.\n        return ''; // Placeholder\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Create a PHP class that handles HTTP requests using cURL with file writing capabilities, including error handling and response status checking.\n\nClass Description: The timthumb class provides functionality to fetch remote URLs using cURL with controlled file writing, including size limitations and error handling. It falls back to file_get_contents if cURL is not available.\n\nAttributes:\n- $curlFH: [resource|false] - File handle for writing cURL response data\n- $curlDataWritten: [int] - Tracks the amount of data written during cURL transfer\n- $lastURLError: [string|false] - Stores the last URL fetch error message\n\nMethods:\n- curlWrite($h, $d) -> [int] - Static callback function for cURL write operation that writes data to file and enforces size limits\n  - $h: [resource] - cURL handle\n  - $d: [string] - Data to write\n  - Returns: [int] - Number of bytes written (0 if size limit exceeded)\n\n- getURL($url, $tempfile) -> [bool] - Fetches content from a URL and saves it to a temporary file\n  - $url: [string] - URL to fetch\n  - $tempfile: [string] - Path to temporary file for storing the response\n  - Returns: [bool] - True on success, False on failure\n  - Side effects: Sets $lastURLError on failure, may call set404() or error() methods",
    "Canonical_solution": "class timthumb\n{\n    protected static $curlFH = false;\n    protected static $curlDataWritten = 0;\n    protected $lastURLError = false;\n\n    public static function curlWrite($h, $d)\n    {\n        fwrite(self::$curlFH, $d);\n        self::$curlDataWritten += strlen($d);\n        if (self::$curlDataWritten > MAX_FILE_SIZE) {\n            return 0;\n        } else {\n            return strlen($d);\n        }\n    }\n\n    protected function getURL($url, $tempfile)\n    {\n        $this->lastURLError = false;\n        $url = preg_replace('/ /', '%20', $url);\n        if (function_exists('curl_init')) {\n            $this->debug(3, \"Curl is installed so using it to fetch URL.\");\n            self::$curlFH = fopen($tempfile, 'w');\n            if (!self::$curlFH) {\n                $this->error(\"Could not open $tempfile for writing.\");\n                return false;\n            }\n            self::$curlDataWritten = 0;\n            $this->debug(3, \"Fetching url with curl: $url\");\n            $curl = curl_init($url);\n            curl_setopt($curl, CURLOPT_TIMEOUT, CURL_TIMEOUT);\n            curl_setopt($curl, CURLOPT_USERAGENT, \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.122 Safari/534.30\");\n            curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\n            curl_setopt($curl, CURLOPT_HEADER, 0);\n            curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n            curl_setopt($curl, CURLOPT_WRITEFUNCTION, 'timthumb::curlWrite');\n            @curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n            @curl_setopt($curl, CURLOPT_MAXREDIRS, 10);\n\n            $curlResult = curl_exec($curl);\n            fclose(self::$curlFH);\n            $httpStatus = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n            if ($httpStatus == 404) {\n                $this->set404();\n            }\n            if ($httpStatus == 302) {\n                $this->error(\"External Image is Redirecting. Try alternate image url\");\n                return false;\n            }\n            if ($curlResult) {\n                curl_close($curl);\n                return true;\n            } else {\n                $this->lastURLError = curl_error($curl);\n                curl_close($curl);\n                return false;\n            }\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === false) {\n                $err = error_get_last();\n                if (is_array($err) && $err['message']) {\n                    $this->lastURLError = $err['message'];\n                } else {\n                    $this->lastURLError = $err;\n                }\n                if (preg_match('/404/', $this->lastURLError)) {\n                    $this->set404();\n                }\n\n                return false;\n            }\n            if (!file_put_contents($tempfile, $img)) {\n                $this->error(\"Could not write to $tempfile.\");\n                return false;\n            }\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($this->curlFH, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $this->curlDataWritten += $return;\n        if ($this->curlDataWritten > 1048576) {\n            return 0;\n        }\n        return $return;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file for writing.';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                $this->lastURLError = 'Could not initialize cURL.';\n                fclose($this->curlFH);\n                return false;\n            }\n\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.122 Safari/534.30');\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n            curl_setopt($ch, CURLOPT_HEADER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FAILONERROR, true);\n\n            $curl_result = curl_exec($ch);\n\n            if ($curl_result === false) {\n                $this->lastURLError = curl_error($ch);\n                curl_close($ch);\n                fclose($this->curlFH);\n                return false;\n            } else {\n                $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n                if ($statusCode == 404) {\n                    // Handle 404\n                    fclose($this->curlFH);\n                    return false;\n                }\n                curl_close($ch);\n                fclose($this->curlFH);\n                return true;\n            }\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL. ' . $url;\n                fclose($this->curlFH);\n                return false;\n            }\n            fwrite($this->curlFH, $img);\n            fclose($this->curlFH);\n            return true;\n        }\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $o = $h->object;\n        $bytes = fwrite($o->curlFH, $d);\n        if ($bytes) {\n            $o->curlDataWritten += $bytes;\n        }\n        if ($o->curlDataWritten > 1048576) {\n            return 0;\n        }\n        return $bytes;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->lastURLError = false;\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            $this->curlFH = fopen($tempfile, 'w');\n            if (!$this->curlFH) {\n                $this->lastURLError = 'Could not open temporary file for writing.';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n            $this->curlDataWritten = 0;\n            $ch->object = $this;\n            $exec = curl_exec($ch);\n            fclose($this->curlFH);\n            $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($http_code == 404) {\n                if (method_exists($this, 'set404')) {\n                    $this->set404();\n                }\n                return false;\n            }\n            if (!$exec) {\n                $this->lastURLError = curl_error($ch);\n                if (method_exists($this, 'error')) {\n                    $this->error($this->lastURLError);\n                }\n                return false;\n            }\n            curl_close($ch);\n            return true;\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === FALSE) {\n                $this->lastURLError = 'file_get_contents could not fetch URL';\n                return false;\n            }\n            $fh = fopen($tempfile, 'w');\n            if (!$fh) {\n                $this->lastURLError = 'Could not open temporary file for writing.';\n                return false;\n            }\n            fwrite($fh, $img);\n            fclose($fh);\n            return true;\n        }\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $fp = $h;\n        $data = $d;\n        fwrite($fp, $data);\n        $written = strlen($data);\n        $thisObj = &self::getInstance();\n        $thisObj->curlDataWritten += $written;\n        if ($thisObj->curlDataWritten > 1048576) {\n            return 0;\n        }\n        return $written;\n    }\n\n\n    public function getURL($url, $tempfile)\n    {\n        $this->lastURLError = false;\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            $this->curlFH = fopen($tempfile, 'w');\n            if (! $this->curlFH) {\n                $this->lastURLError = 'Could not open temporary file for writing.';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.122 Safari/534.30');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            $data = curl_exec($ch);\n\n            if (curl_errno($ch)) {\n                $this->lastURLError = curl_error($ch);\n                return false;\n            }\n\n            fclose($this->curlFH);\n            $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($http_code == 404) {\n                return false;\n            }\n\n            curl_close($ch);\n            return true;\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === FALSE) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL.  Check if allow_url_fopen is enabled.';\n                return false;\n            }\n            if (file_put_contents($tempfile, $img) === FALSE) {\n                $this->lastURLError = 'Could not write to temporary file.';\n                return false;\n            }\n            return true;\n        }\n    }\n\n    private static function &getInstance() {\n        static $instance = null;\n        if (null === $instance) {\n            $instance = new self();\n        }\n        return $instance;\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($this->curlFH, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $this->curlDataWritten += $return;\n        if ($this->curlDataWritten > 1048576) {\n            return 0;\n        }\n        return $return;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file for writing.';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                $this->lastURLError = 'Could not initialize cURL.';\n                fclose($this->curlFH);\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            $curl_result = curl_exec($ch);\n            $http_response_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n            if ($curl_result === false) {\n                $this->lastURLError = curl_error($ch);\n            }\n            curl_close($ch);\n\n            fclose($this->curlFH);\n\n            if ($curl_result === false || $http_response_code != 200) {\n                if ($http_response_code == 404) {\n                    // Implement set404() if needed\n                    //set404();\n                } else {\n                    // Implement error() if needed\n                    //error('An error occurred fetching the image: ' . $this->lastURLError . ' URL:' . $url);\n                }\n                return false;\n            }\n            return true;\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents could not fetch the image.';\n                return false;\n            }\n            $fh = $this->curlFH;\n            fwrite($fh, $img);\n            fclose($fh);\n            return true;\n        }\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($this->curlFH, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $this->curlDataWritten += $return;\n        if ($this->curlDataWritten > 1048576) {\n            return 0;\n        }\n        return $return;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->lastURLError = false;\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file for writing.';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                $this->lastURLError = 'Could not initialize cURL.';\n                fclose($this->curlFH);\n                return false;\n            }\n\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FAILONERROR, true);\n            $data = curl_exec($ch);\n\n            if ($data === false) {\n                $this->lastURLError = curl_error($ch);\n                curl_close($ch);\n                fclose($this->curlFH);\n                return false;\n            }\n\n            curl_close($ch);\n            fclose($this->curlFH);\n            return true;\n        } else {\n            $data = @file_get_contents($url);\n            if ($data === false) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL. Check if allow_url_fopen is enabled.';\n                fclose($this->curlFH);\n                return false;\n            }\n\n            $written = fwrite($this->curlFH, $data);\n            fclose($this->curlFH);\n            return ($written !== false);\n        }\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $o = $h->object;\n        $bytes = fwrite($o->curlFH, $d);\n        if ($bytes) {\n            $o->curlDataWritten += $bytes;\n        }\n        if ($o->curlDataWritten > 1048576) {\n            return 0;\n        }\n        return $bytes;\n    }\n\n\n    public function getURL($url, $tempfile)\n    {\n        $this->lastURLError = false;\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            $this->curlFH = fopen($tempfile, 'w');\n            if (!$this->curlFH) {\n                $this->lastURLError = 'Could not open temporary file for writing.';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.122 Safari/534.30');\n            curl_setopt($ch, CURLOPT_BINARYTRANSFER, true);\n            $ch->object = $this;\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            $exec = curl_exec($ch);\n            fclose($this->curlFH);\n            $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($http_code == 404) {\n                return false;\n            }\n            if (!$exec) {\n                $this->lastURLError = curl_error($ch);\n                return false;\n            }\n            curl_close($ch);\n            return true;\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents could not fetch URL';\n                return false;\n            }\n            $fh = fopen($tempfile, 'w');\n            if (!$fh) {\n                $this->lastURLError = 'Could not open temporary file for writing.';\n                return false;\n            }\n            fwrite($fh, $img);\n            fclose($fh);\n            return true;\n        }\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $fh = $h->f;\n        $max = $h->max;\n        if ($fh->curlDataWritten + strlen($d) > $max) {\n            return 0;\n        }\n        $fh->curlDataWritten += fwrite($fh->curlFH, $d);\n        return strlen($d);\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->lastURLError = false;\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            $this->curlFH = fopen($tempfile, 'w');\n            if (!$this->curlFH) {\n                $this->lastURLError = 'Could not open temporary file';\n                return false;\n            }\n            $ch->f = $this;\n            $ch->max = 10485760;\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 20);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.122 Safari/534.30');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array(__CLASS__, 'curlWrite'));\n            $data = curl_exec($ch);\n            fclose($this->curlFH);\n            if (curl_errno($ch)) {\n                $this->lastURLError = curl_error($ch);\n                return false;\n            }\n            $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($http_code == 404) {\n                if (method_exists($this, 'set404')) {\n                    $this->set404();\n                }\n                return false;\n            }\n            if ($http_code >= 400) {\n                $this->lastURLError = 'HTTP error: ' . $http_code;\n                if (method_exists($this, 'error')) {\n                    $this->error($http_code);\n                }\n                return false;\n            }\n            curl_close($ch);\n            return true;\n        } else {\n            $maxFileSize = 10485760;\n            $img = @file_get_contents($url);\n            if ($img === FALSE) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL';\n                return false;\n            }\n            if (strlen($img) > $maxFileSize) {\n                $this->lastURLError = 'file_get_contents retrieved too large a file';\n                return false;\n            }\n            if (file_put_contents($tempfile, $img) === FALSE) {\n                $this->lastURLError = 'file_put_contents could not write to file';\n                return false;\n            }\n            return true;\n        }\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $fp = $h;\n        $data = $d;\n        fwrite($fp, $data);\n        $written = strlen($data);\n        return $written;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->lastURLError = false;\n        if(function_exists('curl_init')) {\n            $ch = curl_init($url);\n            $this->curlFH = fopen($tempfile, 'w');\n            if (! $this->curlFH) {\n                $this->lastURLError = 'Could not open temporary file for writing.';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this,'curlWrite'));\n            $data = curl_exec($ch);\n\n            fclose($this->curlFH);\n            if ($data === false) {\n                $this->lastURLError = curl_error($ch);\n                curl_close($ch);\n                return false;\n            }\n            curl_close($ch);\n            return true;\n        } else {\n            $data = @file_get_contents($url);\n            if ($data === false) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL. Check if allow_url_fopen is enabled.';\n                return false;\n            }\n            file_put_contents($tempfile, $data);\n            return true;\n        }\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $o = $h->object;\n        $o->curlDataWritten += strlen($d);\n        if ($o->curlDataWritten > 1048576) {\n            return 0;\n        }\n        return fwrite($o->curlFH, $d);\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->lastURLError = false;\n        if (function_exists('curl_init')) {\n            $this->curlFH = fopen($tempfile, 'w');\n            if (!$this->curlFH) {\n                $this->lastURLError = 'Could not open temporary file for writing.';\n                return false;\n            }\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.122 Safari/534.30');\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n            curl_setopt($ch, CURLOPT_HEADER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            $ch->object = $this;\n            $success = curl_exec($ch);\n            fclose($this->curlFH);\n            if (!$success) {\n                $this->lastURLError = curl_error($ch);\n                return false;\n            }\n            $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            curl_close($ch);\n            if ($statusCode == 404) {\n                return false;\n            }\n            if ($statusCode != 200) {\n                $this->lastURLError = 'Error reading the URL: ' . $statusCode;\n                return false;\n            }\n            return true;\n        } else if (ini_get('allow_url_fopen')) {\n            $img = @file_get_contents($url);\n            if (!$img) {\n                $this->lastURLError = 'Could not retrieve the URL because allow_url_fopen is disabled.';\n                return false;\n            }\n            $fh = fopen($tempfile, 'w');\n            fwrite($fh, $img);\n            fclose($fh);\n            return true;\n        } else {\n            $this->lastURLError = 'Could not retrieve the URL because both cURL and allow_url_fopen are disabled.';\n            return false;\n        }\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $fp = $h;\n        $data = $d;\n        fwrite($fp, $data);\n        $written = strlen($data);\n        $thisObj = &self::getInstance();\n        $thisObj->curlDataWritten += $written;\n        if ($thisObj->curlDataWritten > 1048576) {\n            return 0;\n        }\n        return $written;\n    }\n\n\n    public function getURL($url, $tempfile)\n    {\n        $this->lastURLError = false;\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            $this->curlFH = fopen($tempfile, 'w');\n            if (!$this->curlFH) {\n                $this->lastURLError = 'Could not open temporary file for writing.';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            $data = curl_exec($ch);\n\n            if (curl_errno($ch)) {\n                $this->lastURLError = curl_error($ch);\n                fclose($this->curlFH);\n                return false;\n            }\n\n            fclose($this->curlFH);\n            $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($http_code == 404) {\n                return false;\n            }\n\n            curl_close($ch);\n            return true;\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === FALSE) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL.  Check if allow_url_fopen is enabled.';\n                return false;\n            }\n            if (file_put_contents($tempfile, $img) === FALSE) {\n                $this->lastURLError = 'Could not write to temporary file.';\n                return false;\n            }\n            return true;\n        }\n    }\n\n    private static function &getInstance()\n    {\n        static $instance = null;\n        if (null === $instance) {\n            $instance = new self();\n        }\n        return $instance;\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client using cURL for making HTTP requests with support for various methods (GET, POST, PUT, DELETE, PATCH), custom headers, and request/response logging.\n\nClass Description: The Curl class is an HTTP client implementation that uses PHP's cURL extension to send HTTP requests and handle responses. It supports common HTTP methods, allows configuration of cURL options, handles request headers and parameters, and provides detailed response information including headers, status code, and body.\n\nAttributes:\n\ncurlOptions: [array] - Default cURL options including timeout, SSL verification, redirects, etc.\nrequestArguments: [array] - Stores the current request parameters including URI, method, parameters, and headers.\nrequestHeader: [array] - Default request headers that can be extended or overridden.\nresponseBody: [string] - Stores the response body from the last request.\nresponseHeader: [array] - Stores the response headers from the last request.\nresponseHttpCode: [int] - Stores the HTTP status code from the last request.\nresponseClientError: [string|null] - Stores any cURL error from the last request.\nresponseClientInfo: [array] - Stores cURL info from the last request.\nlogger: [object|null] - Optional logger instance for request/response logging.\n\nMethods:\n\nrequest: [request](string $uri, string $method = 'GET', array $parameters = [], array $headers = [], bool $multipart = false) -> string - Makes an HTTP request to the specified URI with given method, parameters and headers. Returns the response body.\ngetResponse: [getResponse]() -> array - Returns complete request/response information including headers, status code, body, and client info.\nsetCurlOptions: [setCurlOptions](array $curlOptions) -> void - Sets additional cURL options.\nsetLogger: [setLogger](object $logger) -> void - Sets a logger instance for request/response logging.\ngetResponseBody: [getResponseBody]() -> string - Returns the response body from the last request.\ngetResponseHeader: [getResponseHeader]() -> array - Returns the response headers from the last request.\ngetResponseHttpCode: [getResponseHttpCode]() -> int - Returns the HTTP status code from the last request.\ngetResponseClientError: [getResponseClientError]() -> string|null - Returns any cURL error from the last request.\nfetchResponseHeader: [fetchResponseHeader](resource $curl, string $header) -> int - Callback function for processing response headers.\nprepareRequestHeaders: [prepareRequestHeaders]() -> array - Prepares request headers in cURL format.\ngetResponseClientInfo: [getResponseClientInfo]() -> array - Returns cURL info from the last request.\ngetRequestArguments: [getRequestArguments]() -> array - Returns the arguments used for the last request.",
    "Canonical_solution": "namespace Hybridauth\\HttpClient;\n\nclass Curl implements HttpClientInterface\n{\n    protected $curlOptions = [\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_CONNECTTIMEOUT => 30,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 5,\n        CURLINFO_HEADER_OUT => true,\n        CURLOPT_ENCODING => 'identity',\n        CURLOPT_USERAGENT => 'Hybridauth, PHP Social Authentication Library (https://github.com/hybridauth/hybridauth)',\n    ];\n\n    protected $requestArguments = [];\n    protected $requestHeader = [\n        'Accept' => '*/*',\n        'Cache-Control' => 'max-age=0',\n        'Connection' => 'keep-alive',\n        'Expect' => '',\n        'Pragma' => '',\n    ];\n\n    protected $responseBody = '';\n    protected $responseHeader = [];\n    protected $responseHttpCode = 0;\n    protected $responseClientError = null;\n    protected $responseClientInfo = [];\n    protected $logger = null;\n\n    public function request($uri, $method = 'GET', $parameters = [], $headers = [], $multipart = false)\n    {\n        $this->requestHeader = array_replace($this->requestHeader, (array)$headers);\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $this->requestHeader,\n        ];\n\n        $curl = curl_init();\n\n        switch ($method) {\n            case 'GET':\n            case 'DELETE':\n                unset($this->curlOptions[CURLOPT_POST]);\n                unset($this->curlOptions[CURLOPT_POSTFIELDS]);\n                $uri = $uri . (strpos($uri, '?') ? '&' : '?') . http_build_query($parameters);\n                if ($method === 'DELETE') {\n                    $this->curlOptions[CURLOPT_CUSTOMREQUEST] = 'DELETE';\n                }\n                break;\n            case 'PUT':\n            case 'POST':\n            case 'PATCH':\n                $body_content = $multipart ? $parameters : http_build_query($parameters);\n                if (isset($this->requestHeader['Content-Type'])\n                    && $this->requestHeader['Content-Type'] == 'application/json'\n                ) {\n                    $body_content = json_encode($parameters);\n                }\n\n                if ($method === 'POST') {\n                    $this->curlOptions[CURLOPT_POST] = true;\n                } else {\n                    $this->curlOptions[CURLOPT_CUSTOMREQUEST] = $method;\n                }\n                $this->curlOptions[CURLOPT_POSTFIELDS] = $body_content;\n                break;\n        }\n\n        $this->curlOptions[CURLOPT_URL] = $uri;\n        $this->curlOptions[CURLOPT_HTTPHEADER] = $this->prepareRequestHeaders();\n        $this->curlOptions[CURLOPT_HEADERFUNCTION] = [$this, 'fetchResponseHeader'];\n\n        foreach ($this->curlOptions as $opt => $value) {\n            curl_setopt($curl, $opt, $value);\n        }\n\n        $response = curl_exec($curl);\n\n        $this->responseBody = $response;\n        $this->responseHttpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        $this->responseClientError = curl_error($curl);\n        $this->responseClientInfo = curl_getinfo($curl);\n\n        if ($this->logger) {\n            $this->logger->debug(sprintf('%s::request( %s, %s ), response:', get_class($this), $uri, $method), $this->getResponse());\n            if (false === $response) {\n                $this->logger->error(sprintf('%s::request( %s, %s ), error:', get_class($this), $uri, $method), [$this->responseClientError]);\n            }\n        }\n\n        curl_close($curl);\n        return $this->responseBody;\n    }\n\n    public function getResponse()\n    {\n        $curlOptions = $this->curlOptions;\n        $curlOptions[CURLOPT_HEADERFUNCTION] = '*omitted';\n        return [\n            'request' => $this->getRequestArguments(),\n            'response' => [\n                'code' => $this->getResponseHttpCode(),\n                'headers' => $this->getResponseHeader(),\n                'body' => $this->getResponseBody(),\n            ],\n            'client' => [\n                'error' => $this->getResponseClientError(),\n                'info' => $this->getResponseClientInfo(),\n                'opts' => $curlOptions,\n            ],\n        ];\n    }\n\n    public function setCurlOptions($curlOptions)\n    {\n        foreach ($curlOptions as $opt => $value) {\n            $this->curlOptions[$opt] = $value;\n        }\n    }\n\n    public function setLogger($logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody()\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader()\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode()\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError()\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo()\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments()\n    {\n        return $this->requestArguments;\n    }\n\n    protected function fetchResponseHeader($curl, $header)\n    {\n        $pos = strpos($header, ':');\n        if (!empty($pos)) {\n            $key = str_replace('-', '_', strtolower(substr($header, 0, $pos)));\n            $value = trim(substr($header, $pos + 2));\n            $this->responseHeader[$key] = $value;\n        }\n        return strlen($header);\n    }\n\n    protected function prepareRequestHeaders()\n    {\n        $headers = [];\n        foreach ($this->requestHeader as $header => $value) {\n            $headers[] = trim($header) . ': ' . trim($value);\n        }\n        return $headers;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Curl\n{\n    public array $curlOptions = [\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADERFUNCTION => [$this, 'fetchResponseHeader'],\n    ];\n\n    public array $requestArguments = [];\n    public array $requestHeader = [];\n    public string $responseBody = '';\n    public array $responseHeader = [];\n    public int $responseHttpCode = 0;\n    public ?string $responseClientError = null;\n    public array $responseClientInfo = [];\n    public ?object $logger = null;\n\n\n    public function request(string $uri, string $method = 'GET', array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = compact('uri', 'method', 'parameters', 'headers');\n        $ch = curl_init($uri);\n\n        $options = $this->curlOptions;\n        $options[CURLOPT_CUSTOMREQUEST] = strtoupper($method);\n        $headers = array_merge($this->requestHeader, $headers);\n\n        if ($parameters) {\n            if ($method === 'GET') {\n                $uri .= (strpos($uri, '?') === false ? '?' : '&') . http_build_query($parameters);\n                $options[CURLOPT_URL] = $uri;\n            } else {\n                if ($multipart) {\n                    $options[CURLOPT_POSTFIELDS] = $parameters;\n                } else {\n                    $options[CURLOPT_POSTFIELDS] = http_build_query($parameters);\n                }\n            }\n        }\n\n        if ($headers) {\n            $options[CURLOPT_HTTPHEADER] = $this->prepareRequestHeaders($headers);\n        }\n        curl_setopt_array($ch, $options);\n\n        $this->responseBody = curl_exec($ch);\n        $this->responseHttpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->responseClientError = curl_error($ch);\n        $this->responseClientInfo = curl_getinfo($ch);\n\n        if ($this->logger) {\n            $logMessage = [\n                'request' => $this->requestArguments,\n                'response' => $this->getResponse(),\n            ];\n            $this->logger->log(json_encode($logMessage));\n        }\n\n        curl_close($ch);\n        return $this->responseBody;\n    }\n\n\n    public function getResponse(): array\n    {\n        return [\n            'header' => $this->responseHeader,\n            'http_code' => $this->responseHttpCode,\n            'body' => $this->responseBody,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n\n    public function setCurlOptions(array $curlOptions): void\n    {\n        $this->curlOptions = array_merge($this->curlOptions, $curlOptions);\n    }\n\n\n    public function setLogger(object $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n\n    public function fetchResponseHeader($curl, string $header): int\n    {\n        $len = strlen($header);\n        $header = explode(':', $header, 2);\n        if (count($header) < 2) {\n            return $len;\n        }\n\n        $name = strtolower(trim($header[0]));\n        if (!isset($this->responseHeader[$name])) {\n            $this->responseHeader[$name] = [trim($header[1])];\n        } else {\n            $this->responseHeader[$name][] = trim($header[1]);\n        }\n        return $len;\n    }\n\n    private function prepareRequestHeaders(array $headers): array\n    {\n        $curlHeaders = [];\n        foreach ($headers as $key => $value) {\n            $curlHeaders[] = $key . ': ' . $value;\n        }\n        return $curlHeaders;\n    }\n\n\n    public function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n\n    public function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nclass Curl\n{\n    public array $curlOptions = [\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADERFUNCTION => [$this, 'fetchResponseHeader'],\n    ];\n\n    public array $requestArguments = [];\n    public array $requestHeader = [];\n    public string $responseBody = '';\n    public array $responseHeader = [];\n    public int $responseHttpCode = 0;\n    public ?string $responseClientError = null;\n    public array $responseClientInfo = [];\n    public ?object $logger = null;\n\n\n    public function request(string $uri, string $method = 'GET', array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = compact('uri', 'method', 'parameters', 'headers');\n        $ch = curl_init($uri);\n\n        $options = $this->curlOptions;\n        $options[CURLOPT_CUSTOMREQUEST] = strtoupper($method);\n        $options[CURLOPT_HTTPHEADER] = $this->prepareRequestHeaders($headers);\n\n\n        if ($method === 'POST' || $method === 'PUT' || $method === 'PATCH') {\n            if ($multipart) {\n                $options[CURLOPT_POSTFIELDS] = $parameters;\n            } else {\n                $options[CURLOPT_POSTFIELDS] = http_build_query($parameters);\n            }\n        } elseif (!empty($parameters)) {\n            $uri .= (strpos($uri, '?') === false ? '?' : '&') . http_build_query($parameters);\n            curl_setopt($ch, CURLOPT_URL, $uri);\n        }\n\n\n        curl_setopt_array($ch, $options);\n\n        $this->responseBody = curl_exec($ch);\n        $this->responseHttpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->responseClientError = curl_error($ch);\n        $this->responseClientInfo = curl_getinfo($ch);\n\n        if ($this->logger) {\n            $logMessage = [\n                'request' => $this->requestArguments,\n                'response' => $this->getResponse(),\n            ];\n            $this->logger->log(json_encode($logMessage));\n        }\n\n        curl_close($ch);\n        return $this->responseBody;\n    }\n\n\n    public function getResponse(): array\n    {\n        return [\n            'header' => $this->responseHeader,\n            'httpCode' => $this->responseHttpCode,\n            'body' => $this->responseBody,\n            'clientError' => $this->responseClientError,\n            'clientInfo' => $this->responseClientInfo,\n        ];\n    }\n\n\n    public function setCurlOptions(array $curlOptions): void\n    {\n        $this->curlOptions = array_replace($this->curlOptions, $curlOptions);\n    }\n\n\n    public function setLogger(object $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n\n    public function fetchResponseHeader($curl, string $header): int\n    {\n        $len = strlen($header);\n        $header = explode(':', $header, 2);\n        if (count($header) < 2) {\n            return $len;\n        }\n\n        $name = strtolower(trim($header[0]));\n        if (!isset($this->responseHeader[$name])) {\n            $this->responseHeader[$name] = [trim($header[1])];\n        } else {\n            $this->responseHeader[$name][] = trim($header[1]);\n        }\n        return $len;\n    }\n\n\n    private function prepareRequestHeaders(array $headers = []): array\n    {\n        $requestHeaders = $this->requestHeader;\n        foreach ($headers as $key => $value) {\n            $requestHeaders[] = $key . ': ' . $value;\n        }\n        return $requestHeaders;\n    }\n\n    public function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    public function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nclass Curl\n{\n    public array $curlOptions = [\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADERFUNCTION => [$this, 'fetchResponseHeader'],\n    ];\n    public array $requestArguments = [];\n    public array $requestHeader = [];\n    public string $responseBody = '';\n    public array $responseHeader = [];\n    public int $responseHttpCode = 0;\n    public ?string $responseClientError = null;\n    public array $responseClientInfo = [];\n    public ?object $logger = null;\n\n    public function request(string $uri, string $method = 'GET', array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = compact('uri', 'method', 'parameters', 'headers');\n        $ch = curl_init($uri);\n        $options = $this->curlOptions;\n        $options[CURLOPT_CUSTOMREQUEST] = strtoupper($method);\n        $headers = array_merge($this->requestHeader, $headers);\n        if ($parameters) {\n            if ($method === 'GET') {\n                $uri .= (strpos($uri, '?') === false ? '?' : '&') . http_build_query($parameters);\n                curl_setopt($ch, CURLOPT_URL, $uri);\n            } else {\n                if ($multipart) {\n                    $options[CURLOPT_POSTFIELDS] = $parameters;\n                } else {\n                    $options[CURLOPT_POSTFIELDS] = http_build_query($parameters);\n                }\n            }\n        }\n\n        $options[CURLOPT_HTTPHEADER] = $this->prepareRequestHeaders($headers);\n        curl_setopt_array($ch, $options);\n\n        $this->responseBody = curl_exec($ch);\n        $this->responseHttpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->responseClientError = curl_error($ch);\n        $this->responseClientInfo = curl_getinfo($ch);\n\n        if ($this->logger) {\n            $logMessage = [\n                'request' => $this->requestArguments,\n                'response' => $this->getResponse(),\n            ];\n            $this->logger->log(json_encode($logMessage));\n        }\n        curl_close($ch);\n        return $this->responseBody;\n    }\n\n\n    public function getResponse(): array\n    {\n        return [\n            'header' => $this->responseHeader,\n            'http_code' => $this->responseHttpCode,\n            'body' => $this->responseBody,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setCurlOptions(array $curlOptions): void\n    {\n        $this->curlOptions = array_merge($this->curlOptions, $curlOptions);\n    }\n\n    public function setLogger(object $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    public function fetchResponseHeader($curl, string $header): int\n    {\n        $len = strlen($header);\n        $header = explode(':', $header, 2);\n        if (count($header) < 2) {\n            return $len;\n        }\n\n        $name = strtolower(trim($header[0]));\n        if (!isset($this->responseHeader[$name])) {\n            $this->responseHeader[$name] = [trim($header[1])];\n        } else {\n            $this->responseHeader[$name][] = trim($header[1]);\n        }\n        return $len;\n    }\n\n    private function prepareRequestHeaders(array $headers): array\n    {\n        $curlHeaders = [];\n        foreach ($headers as $key => $value) {\n            $curlHeaders[] = $key . ': ' . $value;\n        }\n        return $curlHeaders;\n    }\n\n\n    public function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    public function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nclass Curl\n{\n    public array $curlOptions = [\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADERFUNCTION => [$this, 'fetchResponseHeader'],\n    ];\n\n    public array $requestArguments = [];\n    public array $requestHeader = [];\n    public string $responseBody = '';\n    public array $responseHeader = [];\n    public int $responseHttpCode = 0;\n    public ?string $responseClientError = null;\n    public array $responseClientInfo = [];\n    public ?object $logger = null;\n\n\n    public function request(string $uri, string $method = 'GET', array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = compact('uri', 'method', 'parameters', 'headers');\n        $ch = curl_init($uri);\n\n        $options = $this->curlOptions;\n        $options[CURLOPT_CUSTOMREQUEST] = strtoupper($method);\n        $options[CURLOPT_HTTPHEADER] = $this->prepareRequestHeaders($headers);\n\n\n        if ($method === 'POST' || $method === 'PUT' || $method === 'PATCH') {\n            if ($multipart) {\n                $options[CURLOPT_POSTFIELDS] = $parameters;\n            } else {\n                $options[CURLOPT_POSTFIELDS] = http_build_query($parameters);\n            }\n        } elseif (!empty($parameters)) {\n            $uri .= (strpos($uri, '?') === false ? '?' : '&') . http_build_query($parameters);\n            curl_setopt($ch, CURLOPT_URL, $uri);\n        }\n\n        curl_setopt_array($ch, $options);\n\n        $this->responseBody = curl_exec($ch);\n        $this->responseHttpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->responseClientError = curl_error($ch);\n        $this->responseClientInfo = curl_getinfo($ch);\n\n        if ($this->logger) {\n            $logMessage = [\n                'request' => $this->requestArguments,\n                'response' => $this->getResponse(),\n            ];\n            $this->logger->log(json_encode($logMessage));\n        }\n\n        curl_close($ch);\n        return $this->responseBody;\n    }\n\n\n    public function getResponse(): array\n    {\n        return [\n            'header' => $this->responseHeader,\n            'httpCode' => $this->responseHttpCode,\n            'body' => $this->responseBody,\n            'clientError' => $this->responseClientError,\n            'clientInfo' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setCurlOptions(array $curlOptions): void\n    {\n        $this->curlOptions = array_replace($this->curlOptions, $curlOptions);\n    }\n\n    public function setLogger(object $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    public function fetchResponseHeader($curl, string $header): int\n    {\n        $len = strlen($header);\n        $header = explode(':', $header, 2);\n        if (count($header) < 2) {\n            return $len;\n        }\n\n        $name = strtolower(trim($header[0]));\n        if (!isset($this->responseHeader[$name])) {\n            $this->responseHeader[$name] = [trim($header[1])];\n        } else {\n            $this->responseHeader[$name][] = trim($header[1]);\n        }\n        return $len;\n    }\n\n    private function prepareRequestHeaders(array $headers = []): array\n    {\n        $requestHeaders = $this->requestHeader;\n        foreach ($headers as $key => $value) {\n            $requestHeaders[] = $key . ': ' . $value;\n        }\n        return $requestHeaders;\n    }\n\n\n    public function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    public function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nclass Curl\n{\n    public array $curlOptions = [\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADERFUNCTION => [$this, 'fetchResponseHeader'],\n    ];\n    public array $requestArguments = [];\n    public array $requestHeader = [];\n    public string $responseBody = '';\n    public array $responseHeader = [];\n    public int $responseHttpCode = 0;\n    public ?string $responseClientError = null;\n    public array $responseClientInfo = [];\n    public ?object $logger = null;\n\n    public function request(string $uri, string $method = 'GET', array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = compact('uri', 'method', 'parameters', 'headers');\n        $ch = curl_init($uri);\n        $options = $this->curlOptions;\n        $options[CURLOPT_CUSTOMREQUEST] = strtoupper($method);\n        $headers = array_merge($this->requestHeader, $headers);\n        if ($parameters) {\n            if ($method === 'GET') {\n                $uri .= (strpos($uri, '?') === false ? '?' : '&') . http_build_query($parameters);\n                curl_setopt($ch, CURLOPT_URL, $uri);\n            } else {\n                if ($multipart) {\n                    $options[CURLOPT_POSTFIELDS] = $parameters;\n                } else {\n                    $options[CURLOPT_POSTFIELDS] = http_build_query($parameters);\n                }\n            }\n        }\n\n        $options[CURLOPT_HTTPHEADER] = $this->prepareRequestHeaders($headers);\n        curl_setopt_array($ch, $options);\n\n        $this->responseBody = curl_exec($ch);\n        $this->responseHttpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->responseClientError = curl_error($ch);\n        $this->responseClientInfo = curl_getinfo($ch);\n\n        if ($this->logger) {\n            $logMessage = [\n                'request' => $this->requestArguments,\n                'response' => $this->getResponse(),\n            ];\n            $this->logger->log(json_encode($logMessage));\n        }\n\n        curl_close($ch);\n        return $this->responseBody;\n    }\n\n\n    public function getResponse(): array\n    {\n        return [\n            'header' => $this->responseHeader,\n            'http_code' => $this->responseHttpCode,\n            'body' => $this->responseBody,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setCurlOptions(array $curlOptions): void\n    {\n        $this->curlOptions = array_merge($this->curlOptions, $curlOptions);\n    }\n\n    public function setLogger(object $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    public function fetchResponseHeader($curl, string $header): int\n    {\n        $len = strlen($header);\n        $header = explode(':', $header, 2);\n        if (count($header) < 2) {\n            return $len;\n        }\n\n        $name = strtolower(trim($header[0]));\n        if (!isset($this->responseHeader[$name])) {\n            $this->responseHeader[$name] = [trim($header[1])];\n        } else {\n            $this->responseHeader[$name][] = trim($header[1]);\n        }\n        return $len;\n    }\n\n    private function prepareRequestHeaders(array $headers): array\n    {\n        $curlHeaders = [];\n        foreach ($headers as $key => $value) {\n            $curlHeaders[] = $key . ': ' . $value;\n        }\n        return $curlHeaders;\n    }\n\n\n    public function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    public function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nclass Curl\n{\n    public array $curlOptions = [\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_MAXREDIRS => 5,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADERFUNCTION => [$this, 'fetchResponseHeader'],\n    ];\n\n    public array $requestArguments = [];\n    public array $requestHeader = [];\n    public string $responseBody = '';\n    public array $responseHeader = [];\n    public int $responseHttpCode = 0;\n    public ?string $responseClientError = null;\n    public array $responseClientInfo = [];\n    public ?object $logger = null;\n\n\n    public function request(string $uri, string $method = 'GET', array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = compact('uri', 'method', 'parameters', 'headers');\n        $ch = curl_init($uri);\n\n        $options = $this->curlOptions;\n        $options[CURLOPT_CUSTOMREQUEST] = strtoupper($method);\n        $options[CURLOPT_HTTPHEADER] = $this->prepareRequestHeaders($headers);\n\n        if ($method === 'POST' || $method === 'PUT' || $method === 'PATCH') {\n            if ($multipart) {\n                $options[CURLOPT_POSTFIELDS] = $parameters;\n            } else {\n                $options[CURLOPT_POSTFIELDS] = http_build_query($parameters);\n            }\n        } elseif (!empty($parameters)) {\n            $uri .= (strpos($uri, '?') === false ? '?' : '&') . http_build_query($parameters);\n            curl_setopt($ch, CURLOPT_URL, $uri);\n        }\n\n\n        curl_setopt_array($ch, $options);\n\n        $this->responseBody = curl_exec($ch);\n        $this->responseHttpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->responseClientError = curl_error($ch);\n        $this->responseClientInfo = curl_getinfo($ch);\n\n        if ($this->logger) {\n            $logMessage = [\n                'request' => $this->requestArguments,\n                'response' => $this->getResponse(),\n            ];\n            $this->logger->log(json_encode($logMessage));\n        }\n\n        curl_close($ch);\n        return $this->responseBody;\n    }\n\n    public function getResponse(): array\n    {\n        return [\n            'header' => $this->responseHeader,\n            'http_code' => $this->responseHttpCode,\n            'body' => $this->responseBody,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setCurlOptions(array $curlOptions): void\n    {\n        $this->curlOptions = array_replace($this->curlOptions, $curlOptions);\n    }\n\n    public function setLogger(object $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    public function fetchResponseHeader($curl, string $header): int\n    {\n        $len = strlen($header);\n        $header = explode(':', $header, 2);\n        if (count($header) < 2) {\n            return $len;\n        }\n\n        $name = strtolower(trim($header[0]));\n        if (!isset($this->responseHeader[$name])) {\n            $this->responseHeader[$name] = [trim($header[1])];\n        } else {\n            $this->responseHeader[$name][] = trim($header[1]);\n        }\n        return $len;\n    }\n\n    private function prepareRequestHeaders(array $headers = []): array\n    {\n        $requestHeaders = $this->requestHeader;\n        foreach ($headers as $key => $value) {\n            $requestHeaders[] = $key . ': ' . $value;\n        }\n        return $requestHeaders;\n    }\n\n\n    public function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    public function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nclass Curl\n{\n    public array $curlOptions = [\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADERFUNCTION => [$this, 'fetchResponseHeader'],\n    ];\n\n    public array $requestArguments = [];\n    public array $requestHeader = [];\n    public string $responseBody = '';\n    public array $responseHeader = [];\n    public int $responseHttpCode = 0;\n    public ?string $responseClientError = null;\n    public array $responseClientInfo = [];\n    public ?object $logger = null;\n\n\n    public function request(string $uri, string $method = 'GET', array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = compact('uri', 'method', 'parameters', 'headers');\n        $ch = curl_init($uri);\n\n        $options = $this->curlOptions;\n        $options[CURLOPT_CUSTOMREQUEST] = strtoupper($method);\n        $headers = array_merge($this->requestHeader, $headers);\n\n\n        if ($method === 'POST' || $method === 'PUT' || $method === 'PATCH') {\n            if ($multipart) {\n                $options[CURLOPT_POSTFIELDS] = $parameters;\n            } else {\n                $options[CURLOPT_POSTFIELDS] = http_build_query($parameters);\n                $headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            }\n        } elseif (!empty($parameters)) {\n            $uri .= (strpos($uri, '?') === false ? '?' : '&') . http_build_query($parameters);\n        }\n\n        $options[CURLOPT_HTTPHEADER] = $this->prepareRequestHeaders($headers);\n        curl_setopt_array($ch, $options);\n\n        $this->responseBody = curl_exec($ch);\n        $this->responseHttpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->responseClientError = curl_error($ch);\n        $this->responseClientInfo = curl_getinfo($ch);\n\n        if ($this->logger) {\n            $logMessage = [\n                'request' => $this->requestArguments,\n                'response' => $this->getResponse(),\n            ];\n            $this->logger->log(json_encode($logMessage));\n        }\n\n        curl_close($ch);\n        return $this->responseBody;\n    }\n\n\n    public function getResponse(): array\n    {\n        return [\n            'body' => $this->responseBody,\n            'header' => $this->responseHeader,\n            'http_code' => $this->responseHttpCode,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setCurlOptions(array $curlOptions): void\n    {\n        $this->curlOptions = array_merge($this->curlOptions, $curlOptions);\n    }\n\n    public function setLogger(object $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    public function fetchResponseHeader($curl, string $header): int\n    {\n        $len = strlen($header);\n        $header = explode(':', $header, 2);\n        if (count($header) < 2) {\n            return $len;\n        }\n\n        $name = strtolower(trim($header[0]));\n        if (!isset($this->responseHeader[$name])) {\n            $this->responseHeader[$name] = [trim($header[1])];\n        } else {\n            $this->responseHeader[$name][] = trim($header[1]);\n        }\n        return $len;\n    }\n\n    private function prepareRequestHeaders(array $headers): array\n    {\n        $curlHeaders = [];\n        foreach ($headers as $key => $value) {\n            $curlHeaders[] = $key . ': ' . $value;\n        }\n        return $curlHeaders;\n    }\n\n\n    public function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    public function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nclass Curl\n{\n    public array $curlOptions = [\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADERFUNCTION => [$this, 'fetchResponseHeader'],\n    ];\n\n    public array $requestArguments = [];\n    public array $requestHeader = [];\n    public string $responseBody = '';\n    public array $responseHeader = [];\n    public int $responseHttpCode = 0;\n    public ?string $responseClientError = null;\n    public array $responseClientInfo = [];\n    public ?object $logger = null;\n\n\n    public function request(string $uri, string $method = 'GET', array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = compact('uri', 'method', 'parameters', 'headers');\n        $ch = curl_init($uri);\n\n        $options = $this->curlOptions;\n        $options[CURLOPT_CUSTOMREQUEST] = strtoupper($method);\n        $headers = array_merge($this->requestHeader, $headers);\n\n        if ($method === 'POST' || $method === 'PUT' || $method === 'PATCH') {\n            if ($multipart) {\n                $options[CURLOPT_POSTFIELDS] = $parameters;\n            } else {\n                $options[CURLOPT_POSTFIELDS] = http_build_query($parameters);\n                $headers[] = 'Content-Type: application/x-www-form-urlencoded';\n            }\n        } elseif (!empty($parameters)) {\n            $uri .= (strpos($uri, '?') === false ? '?' : '&') . http_build_query($parameters);\n        }\n\n        $options[CURLOPT_HTTPHEADER] = $this->prepareRequestHeaders($headers);\n        curl_setopt_array($ch, $options);\n\n        $this->responseBody = curl_exec($ch);\n        $this->responseHttpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->responseClientError = curl_error($ch);\n        $this->responseClientInfo = curl_getinfo($ch);\n\n        if ($this->logger) {\n            $logMessage = [\n                'request' => $this->requestArguments,\n                'response' => $this->getResponse(),\n            ];\n            $this->logger->log(json_encode($logMessage));\n        }\n\n        curl_close($ch);\n        return $this->responseBody;\n    }\n\n\n    public function getResponse(): array\n    {\n        return [\n            'header' => $this->responseHeader,\n            'http_code' => $this->responseHttpCode,\n            'body' => $this->responseBody,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setCurlOptions(array $curlOptions): void\n    {\n        $this->curlOptions = array_merge($this->curlOptions, $curlOptions);\n    }\n\n    public function setLogger(object $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    public function fetchResponseHeader($curl, string $header): int\n    {\n        $len = strlen($header);\n        $header = explode(':', $header, 2);\n        if (count($header) < 2) {\n            return $len;\n        }\n\n        $name = strtolower(trim($header[0]));\n        if (!isset($this->responseHeader[$name])) {\n            $this->responseHeader[$name] = [trim($header[1])];\n        } else {\n            $this->responseHeader[$name][] = trim($header[1]);\n        }\n        return $len;\n    }\n\n    private function prepareRequestHeaders(array $headers): array\n    {\n        $curlHeaders = [];\n        foreach ($headers as $key => $value) {\n            if (is_string($key)) {\n                $curlHeaders[] = $key . ': ' . $value;\n            } else {\n                $curlHeaders[] = $value;\n            }\n        }\n        return $curlHeaders;\n    }\n\n\n    public function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    public function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nclass Curl\n{\n    public array $curlOptions = [\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADERFUNCTION => [$this, 'fetchResponseHeader'],\n    ];\n    public array $requestArguments = [];\n    public array $requestHeader = [];\n    public string $responseBody = '';\n    public array $responseHeader = [];\n    public int $responseHttpCode = 0;\n    public ?string $responseClientError = null;\n    public array $responseClientInfo = [];\n    public ?object $logger = null;\n\n    public function request(string $uri, string $method = 'GET', array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = compact('uri', 'method', 'parameters', 'headers');\n        $ch = curl_init($uri);\n        $options = $this->curlOptions;\n        $options[CURLOPT_CUSTOMREQUEST] = strtoupper($method);\n        $headers = array_merge($this->requestHeader, $headers);\n        if ($parameters) {\n            if ($method === 'GET') {\n                $uri .= (strpos($uri, '?') === false ? '?' : '&') . http_build_query($parameters);\n                curl_setopt($ch, CURLOPT_URL, $uri);\n            } else {\n                if ($multipart) {\n                    $options[CURLOPT_POSTFIELDS] = $parameters;\n                } else {\n                    $options[CURLOPT_POSTFIELDS] = http_build_query($parameters);\n                }\n            }\n        }\n\n        $options[CURLOPT_HTTPHEADER] = $this->prepareRequestHeaders($headers);\n\n        curl_setopt_array($ch, $options);\n        $this->responseBody = curl_exec($ch);\n        $this->responseHttpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->responseClientError = curl_error($ch);\n        $this->responseClientInfo = curl_getinfo($ch);\n        if ($this->logger) {\n            $logMessage = [\n                'request' => $this->requestArguments,\n                'response' => $this->getResponse(),\n            ];\n            $this->logger->log(json_encode($logMessage));\n        }\n        curl_close($ch);\n\n        return $this->responseBody;\n    }\n\n\n    public function getResponse(): array\n    {\n        return [\n            'body' => $this->responseBody,\n            'header' => $this->responseHeader,\n            'http_code' => $this->responseHttpCode,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setCurlOptions(array $curlOptions): void\n    {\n        $this->curlOptions = array_merge($this->curlOptions, $curlOptions);\n    }\n\n    public function setLogger(object $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    public function fetchResponseHeader($curl, string $header): int\n    {\n        $len = strlen($header);\n        $header = explode(':', $header, 2);\n        if (count($header) < 2) {\n            return $len;\n        }\n\n        $name = strtolower(trim($header[0]));\n        if (!isset($this->responseHeader[$name])) {\n            $this->responseHeader[$name] = [trim($header[1])];\n        } else {\n            $this->responseHeader[$name][] = trim($header[1]);\n        }\n        return $len;\n    }\n\n    private function prepareRequestHeaders(array $headers): array\n    {\n        $curlHeaders = [];\n        foreach ($headers as $key => $value) {\n            $curlHeaders[] = $key . ': ' . $value;\n        }\n        return $curlHeaders;\n    }\n\n\n    public function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    public function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nclass Curl\n{\n    public array $curlOptions = [\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADERFUNCTION => [$this, 'fetchResponseHeader'],\n    ];\n    public array $requestArguments = [];\n    public array $requestHeader = [];\n    public string $responseBody = '';\n    public array $responseHeader = [];\n    public int $responseHttpCode = 0;\n    public ?string $responseClientError = null;\n    public array $responseClientInfo = [];\n    public ?object $logger = null;\n\n\n    public function request(string $uri, string $method = 'GET', array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = compact('uri', 'method', 'parameters', 'headers');\n        $ch = curl_init($uri);\n        $options = $this->curlOptions;\n        $options[CURLOPT_CUSTOMREQUEST] = strtoupper($method);\n        $headers = array_merge($this->requestHeader, $headers);\n\n        if ($method === 'POST' || $method === 'PUT' || $method === 'PATCH') {\n            if ($multipart) {\n                $options[CURLOPT_POSTFIELDS] = $parameters;\n            } else {\n                $options[CURLOPT_POSTFIELDS] = http_build_query($parameters);\n                $headers[] = 'Content-Type: application/x-www-form-urlencoded';\n            }\n        } elseif (!empty($parameters)) {\n            $uri .= (strpos($uri, '?') === false ? '?' : '&') . http_build_query($parameters);\n        }\n\n        $options[CURLOPT_HTTPHEADER] = $this->prepareRequestHeaders($headers);\n        curl_setopt_array($ch, $options);\n\n        $this->responseBody = curl_exec($ch);\n        $this->responseHttpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $this->responseClientError = curl_error($ch);\n        $this->responseClientInfo = curl_getinfo($ch);\n\n        if ($this->logger) {\n            $logMessage = [\n                'request' => $this->requestArguments,\n                'response' => $this->getResponse(),\n            ];\n            $this->logger->log(json_encode($logMessage));\n        }\n\n        curl_close($ch);\n        return $this->responseBody;\n    }\n\n\n    public function getResponse(): array\n    {\n        return [\n            'header' => $this->responseHeader,\n            'http_code' => $this->responseHttpCode,\n            'body' => $this->responseBody,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setCurlOptions(array $curlOptions): void\n    {\n        $this->curlOptions = array_merge($this->curlOptions, $curlOptions);\n    }\n\n    public function setLogger(object $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n\n    public function fetchResponseHeader($curl, string $header): int\n    {\n        $len = strlen($header);\n        $header = explode(':', $header, 2);\n        if (count($header) < 2) {\n            return $len;\n        }\n\n        $name = strtolower(trim($header[0]));\n        if (!isset($this->responseHeader[$name])) {\n            $this->responseHeader[$name] = [trim($header[1])];\n        } else {\n            $this->responseHeader[$name][] = trim($header[1]);\n        }\n        return $len;\n    }\n\n    private function prepareRequestHeaders(array $headers): array\n    {\n        $curlHeaders = [];\n        foreach ($headers as $key => $value) {\n            if (is_string($key)) {\n                $curlHeaders[] = $key . ': ' . $value;\n            } else {\n                $curlHeaders[] = $value;\n            }\n        }\n        return $curlHeaders;\n    }\n\n\n    public function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    public function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Create a function that performs an HTTP request using cURL in PHP, with support for proxy configuration and error handling.\n\nFunction Description: The function makes an HTTP GET request to a specified URL using PHP's cURL library. It includes configuration options for handling redirects, timeouts, SSL verification, and proxy settings. The function returns the content of the response or null if an error occurs.\n\nInput: \n- $encUrl: string - The URL to which the HTTP request will be made\n- $proxy: string|null - (Optional) Proxy server address if proxy is required\n- $proxyAuth: array|null - (Optional) Associative array containing 'user' and 'pwd' keys for proxy authentication\n\nOutput: \n- string|null - Returns the response content as a string if successful, or null if an error occurs",
    "Canonical_solution": "function parse($encUrl)\n{\n    global $proxy;\n    global $proxyAuth;\n    $options = array(\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADER         => false,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_ENCODING       => \"\",\n        CURLOPT_USERAGENT      => 'sharrre',\n        CURLOPT_AUTOREFERER    => true,\n        CURLOPT_CONNECTTIMEOUT => 5,\n        CURLOPT_TIMEOUT        => 10,\n        CURLOPT_MAXREDIRS      => 3,\n        CURLOPT_SSL_VERIFYHOST => 0,\n        CURLOPT_SSL_VERIFYPEER => false,\n    );\n    $ch = curl_init();\n    \n    if ($proxy != null) {\n        $options[CURLOPT_PROXY] = $proxy;\n        if (isset($proxyAuth['user']) && isset($proxyAuth['pwd'])) {\n            $options[CURLOPT_PROXYUSERPWD] = $proxyAuth['user'] . ':' . $proxyAuth['pwd'];\n        }\n    }\n    \n    $options[CURLOPT_URL] = $encUrl;\n    curl_setopt_array($ch, $options);\n\n    $content = curl_exec($ch);\n    $err = curl_errno($ch);\n    $errmsg = curl_error($ch);\n\n    curl_close($ch);\n\n    return $content;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction http_request_with_proxy($encUrl, $proxy = null, $proxyAuth = null) {\n    $ch = curl_init($encUrl);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n    if ($proxy) {\n        curl_setopt($ch, CURLOPT_PROXY, $proxy);\n        if ($proxyAuth && isset($proxyAuth['user']) && isset($proxyAuth['pwd'])) {\n            curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyAuth['user'] . ':' . $proxyAuth['pwd']);\n        }\n    }\n\n    $response = curl_exec($ch);\n    $error = curl_error($ch);\n\n    if ($error) {\n        return null;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction httpRequest($encUrl, $proxy = null, $proxyAuth = null) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $encUrl);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n    if ($proxy) {\n        curl_setopt($ch, CURLOPT_PROXY, $proxy);\n        if ($proxyAuth && isset($proxyAuth['user']) && isset($proxyAuth['pwd'])) {\n            curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyAuth['user'] . ':' . $proxyAuth['pwd']);\n        }\n    }\n\n    $response = curl_exec($ch);\n    $error = curl_error($ch);\n\n    if ($error) {\n        curl_close($ch);\n        return null;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request_with_proxy($encUrl, $proxy = null, $proxyAuth = null) {\n    $ch = curl_init($encUrl);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n    if ($proxy) {\n        curl_setopt($ch, CURLOPT_PROXY, $proxy);\n        if ($proxyAuth && isset($proxyAuth['user']) && isset($proxyAuth['pwd'])) {\n            curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyAuth['user'] . ':' . $proxyAuth['pwd']);\n        }\n    }\n\n    $response = curl_exec($ch);\n    $error = curl_error($ch);\n\n    if ($error) {\n        return null;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction httpRequestWithProxy($encUrl, $proxy = null, $proxyAuth = null) {\n    $ch = curl_init($encUrl);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n    if ($proxy) {\n        curl_setopt($ch, CURLOPT_PROXY, $proxy);\n        if ($proxyAuth && isset($proxyAuth['user']) && isset($proxyAuth['pwd'])) {\n            curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyAuth['user'] . ':' . $proxyAuth['pwd']);\n        }\n    }\n\n    $response = curl_exec($ch);\n    $error = curl_error($ch);\n\n    if ($error) {\n        return null;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction httpRequest($encUrl, $proxy = null, $proxyAuth = null) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $encUrl);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n    if ($proxy) {\n        curl_setopt($ch, CURLOPT_PROXY, $proxy);\n        if ($proxyAuth && isset($proxyAuth['user']) && isset($proxyAuth['pwd'])) {\n            curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyAuth['user'] . ':' . $proxyAuth['pwd']);\n        }\n    }\n\n    $response = curl_exec($ch);\n    $error = curl_error($ch);\n\n    if ($error) {\n        curl_close($ch);\n        return null;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction httpRequestWithProxy($encUrl, $proxy = null, $proxyAuth = null) {\n    $ch = curl_init($encUrl);\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n    if ($proxy) {\n        curl_setopt($ch, CURLOPT_PROXY, $proxy);\n        if ($proxyAuth && isset($proxyAuth['user']) && isset($proxyAuth['pwd'])) {\n            curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyAuth['user'] . ':' . $proxyAuth['pwd']);\n        }\n    }\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        curl_close($ch);\n        return null;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction httpRequest($encUrl, $proxy = null, $proxyAuth = null) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $encUrl);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n    if ($proxy) {\n        curl_setopt($ch, CURLOPT_PROXY, $proxy);\n        if ($proxyAuth && isset($proxyAuth['user']) && isset($proxyAuth['pwd'])) {\n            curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyAuth['user'] . ':' . $proxyAuth['pwd']);\n        }\n    }\n\n    $response = curl_exec($ch);\n    $error = curl_error($ch);\n\n    if ($error) {\n        curl_close($ch);\n        return null;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction httpRequestWithProxy($encUrl, $proxy = null, $proxyAuth = null) {\n    $ch = curl_init($encUrl);\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n    if ($proxy) {\n        curl_setopt($ch, CURLOPT_PROXY, $proxy);\n        if ($proxyAuth && isset($proxyAuth['user']) && isset($proxyAuth['pwd'])) {\n            curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyAuth['user'] . ':' . $proxyAuth['pwd']);\n        }\n    }\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        curl_close($ch);\n        return null;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request_with_proxy($encUrl, $proxy = null, $proxyAuth = null) {\n    $ch = curl_init($encUrl);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n    if ($proxy) {\n        curl_setopt($ch, CURLOPT_PROXY, $proxy);\n        if ($proxyAuth && isset($proxyAuth['user']) && isset($proxyAuth['pwd'])) {\n            curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyAuth['user'] . ':' . $proxyAuth['pwd']);\n        }\n    }\n\n    $response = curl_exec($ch);\n    $error = curl_error($ch);\n\n    if ($error) {\n        return null;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction httpRequest(string $encUrl, ?string $proxy = null, ?array $proxyAuth = null): ?string {\n    $ch = curl_init($encUrl);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n    if ($proxy) {\n        curl_setopt($ch, CURLOPT_PROXY, $proxy);\n        if ($proxyAuth && isset($proxyAuth['user']) && isset($proxyAuth['pwd'])) {\n            curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyAuth['user'] . ':' . $proxyAuth['pwd']);\n        }\n    }\n\n    $response = curl_exec($ch);\n    $error = curl_error($ch);\n\n    if ($error) {\n        return null;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a function that makes an HTTP POST request to a specified API endpoint using cURL in PHP, with configurable parameters and SSL verification settings.\n\nFunction Description: The function sends a POST request to a Taobao API endpoint to convert a Taobao share link (tkl) using provided authentication and configuration parameters. It handles SSL verification and returns the API response.\n\nInput:\n- $appkey (string): The application key for API authentication\n- $sid (string): The session ID or user identifier\n- $pid (string): The product ID or parameter\n- $tkl (string): The Taobao share link (tkl) to be converted\n\nOutput:\n- Returns the raw response from the API as a string, or false if the request fails",
    "Canonical_solution": "function reqApi($appkey, $sid, $pid, $tkl)\n{\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, \"https://api.zhetaoke.com:10001/api/open_gaoyongzhuanlian_tkl.ashx?appkey=\".$appkey.\"&sid=\".$sid.\"&pid=\".$pid.\"&tkl=\".$tkl.\"&signurl=5\");\n    curl_setopt($ch, CURLOPT_POST, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $curl_result = curl_exec($ch);\n    curl_close($ch);\n    return $curl_result;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction taobaoTklConvert($appkey, $sid, $pid, $tkl) {\n    $url = 'https://api.taobao.com/router/rest'; // Replace with the actual Taobao API endpoint\n    $params = array(\n        'method' => 'taobao.tbk.tpwd.create', // Replace with the correct API method name\n        'app_key' => $appkey,\n        'session' => $sid,\n        'timestamp' => date('Y-m-d H:i:s'),\n        'format' => 'json',\n        'v' => '2.0',\n        'sign_method' => 'md5',\n        'adzone_id' => $pid, // Assuming pid is adzone_id\n        'text' => $tkl,\n        // Add other necessary parameters as required by the API\n    );\n\n    $sign = generateSign($params, $appkey, 'your_app_secret'); // Replace 'your_app_secret' with the actual app secret\n    $params['sign'] = $sign;\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Enable SSL verification\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); // Verify certificate common name\n\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n\nfunction generateSign($params, $appkey, $appsecret) {\n    ksort($params);\n    $stringToBeSigned = $appsecret;\n    foreach ($params as $k => $v) {\n        if (is_string($v)) {\n            $stringToBeSigned .= \"$k$v\";\n        }\n    }\n    $stringToBeSigned .= $appsecret;\n    return strtoupper(md5($stringToBeSigned));\n}\n?>\n",
      "<?php\nfunction taobaoTklConvert($appkey, $sid, $pid, $tkl) {\n    $url = 'https://api.taobao.com/router/rest'; // Replace with the actual Taobao API endpoint\n    $params = array(\n        'method' => 'taobao.tkl.create', // Replace with the correct API method name\n        'app_key' => $appkey,\n        'session' => $sid,\n        'timestamp' => date('Y-m-d H:i:s'),\n        'format' => 'json',\n        'v' => '2.0',\n        'sign_method' => 'md5',\n        'pid' => $pid,\n        'text' => $tkl,\n        // Add other necessary parameters as required by the API\n    );\n\n    $sign = generateSign($params, $appkey, 'your_app_secret'); // Replace 'your_app_secret' with the actual app secret\n    $params['sign'] = $sign;\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Enable SSL verification\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); // Verify certificate common name\n\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n\nfunction generateSign($params, $appkey, $appsecret) {\n    ksort($params);\n    $stringToBeSigned = $appsecret;\n    foreach ($params as $k => $v) {\n        if (is_string($v)) {\n            $stringToBeSigned .= \"$k$v\";\n        }\n    }\n    $stringToBeSigned .= $appsecret;\n    return strtoupper(md5($stringToBeSigned));\n}\n?>\n",
      "<?php\nfunction taobaoTklConvert($appkey, $sid, $pid, $tkl) {\n    $url = 'https://api.taobao.com/router/rest'; // Replace with the actual Taobao API endpoint\n    $params = array(\n        'method' => 'taobao.tkl.create', // Replace with the correct API method name\n        'app_key' => $appkey,\n        'session' => $sid,\n        'timestamp' => date('Y-m-d H:i:s'),\n        'format' => 'json',\n        'v' => '2.0',\n        'sign_method' => 'md5',\n        'pid' => $pid,\n        'text' => $tkl,\n        // Add other necessary parameters as required by the API\n    );\n\n    $sign = generateSign($params, $appkey, 'your_app_secret'); // Replace 'your_app_secret' with the actual app secret\n    $params['sign'] = $sign;\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Enable SSL verification\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); // Verify certificate common name\n\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n\n    return $response;\n}\n\nfunction generateSign($params, $appkey, $appsecret) {\n    ksort($params);\n    $stringToBeSigned = $appsecret;\n    foreach ($params as $k => $v) {\n        if (is_string($v) && \"@\" != substr($v, 0, 1)) {\n            $stringToBeSigned .= \"$k$v\";\n        }\n    }\n    $stringToBeSigned .= $appsecret;\n    return strtoupper(md5($stringToBeSigned));\n}\n?>\n",
      "<?php\nfunction taobaoTklConvert($appkey, $sid, $pid, $tkl) {\n    $url = 'https://api.taobao.com/router/rest'; // Replace with the actual Taobao API endpoint\n    $params = array(\n        'method' => 'taobao.tkl.create', // Replace with the correct API method name\n        'app_key' => $appkey,\n        'session' => $sid,\n        'timestamp' => date('Y-m-d H:i:s'),\n        'format' => 'json',\n        'v' => '2.0',\n        'sign_method' => 'md5',\n        'pid' => $pid,\n        'text' => $tkl,\n        // Add other necessary parameters as required by the API\n    );\n\n    $sign = generateSign($params, $appkey, 'your_app_secret'); // Replace 'your_app_secret' with the actual app secret\n    $params['sign'] = $sign;\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Enable SSL verification\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); // Verify certificate common name\n\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n\nfunction generateSign($params, $appkey, $appsecret) {\n    ksort($params);\n    $stringToBeSigned = $appsecret;\n    foreach ($params as $k => $v) {\n        if (is_string($v)) {\n            $stringToBeSigned .= \"$k$v\";\n        }\n    }\n    $stringToBeSigned .= $appsecret;\n    return strtoupper(md5($stringToBeSigned));\n}\n?>\n",
      "<?php\nfunction taobaoTklConvert($appkey, $sid, $pid, $tkl) {\n    $url = 'https://api.taobao.com/router/rest';\n    $params = array(\n        'method' => 'taobao.tbk.tpwd.create',\n        'app_key' => $appkey,\n        'session' => $sid,\n        'timestamp' => date('Y-m-d H:i:s'),\n        'format' => 'json',\n        'v' => '2.0',\n        'sign_method' => 'md5',\n        'text' => $tkl,\n        'url' => $tkl,\n        'ext' => \"{\\\"pid\\\":\\\"$pid\\\"}\"\n    );\n\n    ksort($params);\n    $signStr = $appkey;\n    foreach ($params as $k => $v) {\n        $signStr .= $k . $v;\n    }\n    $signStr .= $appkey;\n    $params['sign'] = strtoupper(md5($signStr));\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // Set to true for production\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // Set to 2 for production\n\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction taobaoTklConvert($appkey, $sid, $pid, $tkl) {\n    $url = 'https://api.taobao.com/router/rest'; // Replace with the actual Taobao API endpoint\n    $params = array(\n        'method' => 'taobao.tbk.tpwd.create', // Replace with the correct API method name\n        'app_key' => $appkey,\n        'session' => $sid,\n        'timestamp' => date('Y-m-d H:i:s'),\n        'format' => 'json',\n        'v' => '2.0',\n        'sign_method' => 'md5',\n        'text' => $tkl,\n        'url' => $tkl,\n        'ext' => \"{\\\"pid\\\":\\\"$pid\\\"}\" // Example of including the pid in the request\n    );\n\n    $sign = generateSign($params, $appkey, 'your_app_secret'); // Replace 'your_app_secret' with the actual app secret\n    $params['sign'] = $sign;\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Enable SSL verification\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); // Verify hostname against certificate\n\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n\n    return $response;\n}\n\nfunction generateSign($params, $appkey, $appsecret) {\n    ksort($params);\n    $stringToBeSigned = $appsecret;\n    foreach ($params as $k => $v) {\n        if (is_string($v)) {\n            $stringToBeSigned .= \"$k$v\";\n        }\n    }\n    $stringToBeSigned .= $appsecret;\n    return strtoupper(md5($stringToBeSigned));\n}\n?>\n",
      "<?php\nfunction taobaoTklConvert($appkey, $sid, $pid, $tkl) {\n    $url = 'https://api.taobao.com/router/rest'; // Replace with the actual Taobao API endpoint\n    $params = array(\n        'method' => 'taobao.tkl.create', // Replace with the correct API method name\n        'app_key' => $appkey,\n        'session' => $sid,\n        'timestamp' => date('Y-m-d H:i:s'),\n        'format' => 'json',\n        'v' => '2.0',\n        'sign_method' => 'md5',\n        'pid' => $pid,\n        'text' => $tkl,\n        // Add other necessary parameters as required by the API\n    );\n\n    $sign = generateSign($params, $appkey, 'your_app_secret'); // Replace 'your_app_secret' with the actual app secret\n    $params['sign'] = $sign;\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Enable SSL verification\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); // Verify certificate common name\n\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n\nfunction generateSign($params, $appkey, $appsecret) {\n    ksort($params);\n    $stringToBeSigned = $appsecret;\n    foreach ($params as $k => $v) {\n        if (is_string($v)) {\n            $stringToBeSigned .= \"$k$v\";\n        }\n    }\n    $stringToBeSigned .= $appsecret;\n    return strtoupper(md5($stringToBeSigned));\n}\n?>\n",
      "<?php\nfunction taobaoTklConvert($appkey, $sid, $pid, $tkl) {\n    $url = 'https://api.taobao.com/router/rest'; // Replace with the actual Taobao API endpoint\n    $params = array(\n        'method' => 'taobao.tkl.create', // Replace with the correct API method name\n        'app_key' => $appkey,\n        'session' => $sid,\n        'timestamp' => date('Y-m-d H:i:s'),\n        'format' => 'json',\n        'v' => '2.0',\n        'sign_method' => 'md5',\n        'pid' => $pid,\n        'text' => $tkl,\n        // Add other necessary parameters as required by the API\n    );\n\n    $sign = generateSign($params, $appkey, 'your_app_secret'); // Replace 'your_app_secret' with the actual app secret\n    $params['sign'] = $sign;\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Enable SSL verification\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);   // Verify hostname against certificate\n\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n\nfunction generateSign($params, $appkey, $appsecret) {\n    ksort($params);\n    $stringToBeSigned = $appsecret;\n    foreach ($params as $k => $v) {\n        if (is_string($v)) {\n            $stringToBeSigned .= \"$k$v\";\n        }\n    }\n    $stringToBeSigned .= $appsecret;\n    return strtoupper(md5($stringToBeSigned));\n}\n?>\n",
      "<?php\nfunction taobaoTklConvert($appkey, $sid, $pid, $tkl) {\n    $url = 'https://api.taobao.com/router/rest'; // Replace with the actual Taobao API endpoint\n    $params = array(\n        'method' => 'taobao.tkl.create', // Replace with the correct API method name\n        'app_key' => $appkey,\n        'session' => $sid,\n        'timestamp' => date('Y-m-d H:i:s'),\n        'format' => 'json',\n        'v' => '2.0',\n        'sign_method' => 'md5',\n        'pid' => $pid,\n        'text' => $tkl,\n        // Add other necessary parameters as required by the API\n    );\n\n    $sign = generateSign($params, $appkey, 'your_app_secret'); // Replace 'your_app_secret' with the actual app secret\n    $params['sign'] = $sign;\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Enable SSL verification\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); // Verify certificate common name\n\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n\nfunction generateSign($params, $appkey, $appsecret) {\n    ksort($params);\n    $stringToBeSigned = $appsecret;\n    foreach ($params as $k => $v) {\n        if (is_string($v) && \"@\" != substr($v, 0, 1)) {\n            $stringToBeSigned .= \"$k$v\";\n        }\n    }\n    $stringToBeSigned .= $appsecret;\n    return strtoupper(md5($stringToBeSigned));\n}\n?>\n",
      "<?php\nfunction taobaoTklConvert($appkey, $sid, $pid, $tkl) {\n    $url = 'https://api.taobao.com/router/rest';\n    $params = array(\n        'app_key' => $appkey,\n        'method' => 'taobao.tbk.tpwd.create',\n        'session' => $sid,\n        'timestamp' => date('Y-m-d H:i:s'),\n        'format' => 'json',\n        'v' => '2.0',\n        'sign_method' => 'md5',\n        'text' => $tkl,\n        'url' => $tkl,\n        'ext' => \"{\\\"pid\\\":\\\"$pid\\\"}\"\n    );\n\n    ksort($params);\n    $signStr = $appkey;\n    foreach ($params as $key => $val) {\n        $signStr .= $key . $val;\n    }\n    $signStr .= $appkey;\n    $params['sign'] = strtoupper(md5($signStr));\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // Set to true for production\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // Set to 2 for production\n\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a PHP class that interacts with the Xiami music API to fetch details about songs, albums, or collections using cURL for HTTP requests.\n\nClass Description: The HermitJson class provides functionality to make HTTP requests to the Xiami API and retrieve JSON responses containing music details. It handles different types of requests (song, album, or collection) through a single method.\n\nAttributes: \n[This class has no explicitly defined attributes in the reference code]\n\nMethods:\n1: xiami_http(int $type, string $id) -> array|bool - Makes an HTTP request to the Xiami API based on the specified type and ID. Returns the decoded JSON response as an array or false on failure.\n   - $type: Integer specifying request type (0 for song, 1 for album, 2 for collection)\n   - $id: String containing the ID of the requested item\n   - Returns: Array containing the API response data or false if the request fails",
    "Canonical_solution": "class HermitJson\n{\n    public function __construct()\n    {\n    }\n\n    private function xiami_http($type, $id)\n    {\n        switch($type){\n            case 0:\n                $url = \"http://api.xiami.com/web?v=2.0&app_key=1&id={$id}&r=song/detail\";\n                break;\n\n            case 1:\n                $url = \"http://api.xiami.com/web?v=2.0&app_key=1&id={$id}&r=album/detail\";\n                break;\n\n            case 2:\n                $url = \"http://api.xiami.com/web?v=2.0&app_key=1&id={$id}&type=collectId&r=collect/detail\";\n                break;\n        }\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_REFERER, \"http://m.xiami.com/\");\n        curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53');\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n        curl_setopt($ch, CURLOPT_HEADER, 0);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        $cexecute = curl_exec($ch);\n        @curl_close($ch);\n\n        if ($cexecute) {\n            $result = json_decode($cexecute, TRUE);\n            return $result;\n        } else {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass HermitJson\n{\n    public function xiami_http(int $type, string $id): array|bool\n    {\n        $url = match ($type) {\n            0 => \"http://api.xiami.com/web?v=2.0&app_key=1&key=\" . $id . \"&r=song/detail\",\n            1 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=album/detail\",\n            2 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=collect/detail\",\n            default => false,\n        };\n\n        if ($url === false) {\n            return false;\n        }\n\n        $curl = curl_init();\n        curl_setopt_array($curl, [\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_HTTPHEADER => [\n                \"cache-control: no-cache\"\n            ],\n        ]);\n\n        $response = curl_exec($curl);\n        $err = curl_error($curl);\n        curl_close($curl);\n\n        if ($err) {\n            return false;\n        } else {\n            return json_decode($response, true);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass HermitJson\n{\n    public function xiami_http(int $type, string $id): array|bool\n    {\n        $url = match ($type) {\n            0 => \"http://api.xiami.com/web?v=2.0&app_key=1&key=\" . $id . \"&r=song/detail\",\n            1 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=album/detail\",\n            2 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=collect/detail\",\n            default => false,\n        };\n\n        if ($url === false) {\n            return false;\n        }\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n        $data = curl_exec($ch);\n        if (curl_errno($ch)) {\n            curl_close($ch);\n            return false;\n        }\n        curl_close($ch);\n\n        $json = json_decode($data, true);\n        return $json ?? false;\n    }\n}\n\n?>\n",
      "<?php\n\nclass HermitJson\n{\n    public function xiami_http(int $type, string $id): array|bool\n    {\n        $url = match ($type) {\n            0 => \"http://api.xiami.com/web?v=2.0&app_key=1&key=\" . $id . \"&r=song/detail\",\n            1 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=album/detail\",\n            2 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=collect/detail\",\n            default => false,\n        };\n\n        if ($url === false) {\n            return false;\n        }\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 10);\n        $data = curl_exec($curl);\n        curl_close($curl);\n\n        if ($data === false) {\n            return false;\n        }\n\n        $json = json_decode($data, true);\n\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            return false;\n        }\n        \n        return $json;\n    }\n}\n\n?>\n",
      "<?php\n\nclass HermitJson\n{\n    public function xiami_http(int $type, string $id): array|bool\n    {\n        $url = match ($type) {\n            0 => \"http://api.xiami.com/web?v=2.0&app_key=1&key=\" . $id . \"&r=song/detail\",\n            1 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=album/detail\",\n            2 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=collect/detail\",\n            default => false,\n        };\n\n        if ($url === false) {\n            return false;\n        }\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 10);\n        $data = curl_exec($curl);\n        curl_close($curl);\n\n        if ($data === false) {\n            return false;\n        }\n\n        $json = json_decode($data, true);\n\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            return false;\n        }\n\n        return $json;\n    }\n}\n\n?>\n",
      "<?php\n\nclass HermitJson\n{\n    public function xiami_http(int $type, string $id): array|bool\n    {\n        $url = match ($type) {\n            0 => \"http://www.xiami.com/song/playlist/id/\" . $id . \"/object_name/default/object_id/0\",\n            1 => \"http://www.xiami.com/album/playlist/id/\" . $id . \"/object_name/default/object_id/0\",\n            2 => \"http://www.xiami.com/collect/playlist/id/\" . $id . \"/object_name/default/object_id/0\",\n            default => return false,\n        };\n\n        $curl = curl_init();\n        curl_setopt_array($curl, [\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_HTTPHEADER => [\n                \"cache-control: no-cache\"\n            ],\n        ]);\n\n        $response = curl_exec($curl);\n        $err = curl_error($curl);\n        curl_close($curl);\n\n        if ($err) {\n            return false;\n        } else {\n            return json_decode($response, true);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass HermitJson\n{\n    public function xiami_http(int $type, string $id): array|bool\n    {\n        $url = match ($type) {\n            0 => \"http://api.xiami.com/web?v=2.0&app_key=1&key=\" . $id . \"&r=song/detail\",\n            1 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=album/detail\",\n            2 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=collect/detail\",\n            default => return false,\n        };\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 10);\n        $data = curl_exec($curl);\n        curl_close($curl);\n\n        if ($data) {\n            return json_decode($data, true);\n        } else {\n            return false;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass HermitJson\n{\n    public function xiami_http(int $type, string $id): array|bool\n    {\n        $url = match ($type) {\n            0 => \"http://api.xiami.com/web?v=2.0&app_key=1&key=\" . $id . \"&r=song/detail\",\n            1 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=album/detail\",\n            2 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=collect/detail\",\n            default => false,\n        };\n\n        if ($url === false) {\n            return false;\n        }\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 10);\n        $data = curl_exec($curl);\n        curl_close($curl);\n\n        if ($data === false) {\n            return false;\n        }\n\n        $json = json_decode($data, true);\n\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            return false;\n        }\n\n        return $json;\n    }\n}\n\n?>\n",
      "<?php\n\nclass HermitJson\n{\n    public function xiami_http(int $type, string $id): array|bool\n    {\n        $url = match ($type) {\n            0 => \"http://api.xiami.com/web?v=2.0&app_key=1&key=\" . $id . \"&r=song/detail\",\n            1 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=album/detail\",\n            2 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=collect/detail\",\n            default => false,\n        };\n\n        if ($url === false) {\n            return false;\n        }\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 10);\n        $json = curl_exec($curl);\n        curl_close($curl);\n\n        if ($json === false) {\n            return false;\n        }\n\n        $data = json_decode($json, true);\n\n        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {\n            return false;\n        }\n\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\n\nclass HermitJson\n{\n    public function xiami_http(int $type, string $id): array|bool\n    {\n        $url = match ($type) {\n            0 => \"http://www.xiami.com/song/playlist/id/\" . $id . \"/object_name/default/object_id/0\",\n            1 => \"http://www.xiami.com/song/playlist/id/\" . $id . \"/type/1/cat/json\",\n            2 => \"http://www.xiami.com/song/playlist/id/\" . $id . \"/type/3/cat/json\",\n            default => \"\",\n        };\n\n        if (empty($url)) {\n            return false;\n        }\n\n        $curl = curl_init();\n        curl_setopt_array($curl, [\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_HTTPHEADER => [\n                \"cache-control: no-cache\"\n            ],\n        ]);\n\n        $response = curl_exec($curl);\n        $err = curl_error($curl);\n        curl_close($curl);\n\n        if ($err) {\n            return false;\n        }\n\n        return json_decode($response, true);\n    }\n}\n\n?>\n",
      "<?php\n\nclass HermitJson\n{\n    public function xiami_http(int $type, string $id): array|bool\n    {\n        $url = match ($type) {\n            0 => \"http://api.xiami.com/web?v=2.0&app_key=1&key=\" . $id . \"&r=song/detail\",\n            1 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=album/detail\",\n            2 => \"http://api.xiami.com/web?v=2.0&app_key=1&id=\" . $id . \"&r=collect/detail\",\n            default => false,\n        };\n\n        if ($url === false) {\n            return false;\n        }\n\n        $curl = curl_init();\n        curl_setopt_array($curl, [\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING => \"\",\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"GET\",\n            CURLOPT_HTTPHEADER => [\n                \"cache-control: no-cache\"\n            ],\n        ]);\n\n        $response = curl_exec($curl);\n        $err = curl_error($curl);\n        curl_close($curl);\n\n        if ($err) {\n            return false;\n        } else {\n            return json_decode($response, true);\n        }\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a PHP HTTP client class that handles various types of HTTP requests (GET, POST, DELETE, multipart POST) using cURL, with proper error handling and response processing.\n\nClass Description: The Client class provides static methods to send HTTP requests and process responses. It handles request construction, cURL session management, response parsing, and error handling. The class supports standard HTTP methods and multipart form data for file uploads.\n\nAttributes: (This class has no instance attributes as all methods are static)\n\nMethods:\n\nMethod1: get(string $url, array $headers = array()) -> Response - Sends a GET request to the specified URL with optional headers.\n\nMethod2: delete(string $url, array $headers = array()) -> Response - Sends a DELETE request to the specified URL with optional headers.\n\nMethod3: post(string $url, mixed $body, array $headers = array()) -> Response - Sends a POST request with the given body to the specified URL with optional headers.\n\nMethod4: multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()) -> Response - Sends a multipart/form-data POST request for file upload with additional form fields.\n\nMethod5: sendRequest(Request $request) -> Response - Internal method that executes the cURL request and returns a Response object. Handles request setup, execution, and response processing.\n\nMethod6: userAgent() -> string - Generates a User-Agent string with SDK, system, and PHP version information.\n\nMethod7: parseHeaders(string $raw) -> array - Parses raw HTTP response headers into an associative array.\n\nMethod8: escapeQuotes(string $str) -> string - Escapes quotes in a string for use in HTTP headers.\n\nMethod9: ucwordsHyphen(string $str) -> string - Properly capitalizes hyphenated header names.",
    "Canonical_solution": "namespace Qiniu\\Http;\n\nuse Qiniu\\Config;\nuse Qiniu\\Http\\Request;\nuse Qiniu\\Http\\Response;\n\nfinal class Client\n{\n    public static function get($url, array $headers = array())\n    {\n        $request = new Request('GET', $url, $headers);\n        return self::sendRequest($request);\n    }\n\n    public static function delete($url, array $headers = array())\n    {\n        $request = new Request('DELETE', $url, $headers);\n        return self::sendRequest($request);\n    }\n\n    public static function post($url, $body, array $headers = array())\n    {\n        $request = new Request('POST', $url, $headers, $body);\n        return self::sendRequest($request);\n    }\n\n    public static function multipartPost(\n        $url,\n        $fields,\n        $name,\n        $fileName,\n        $fileBody,\n        $mimeType = null,\n        array $headers = array()\n    ) {\n        $data = array();\n        $mimeBoundary = md5(microtime());\n\n        foreach ($fields as $key => $val) {\n            array_push($data, '--' . $mimeBoundary);\n            array_push($data, \"Content-Disposition: form-data; name=\\\"$key\\\"\");\n            array_push($data, '');\n            array_push($data, $val);\n        }\n\n        array_push($data, '--' . $mimeBoundary);\n        $finalMimeType = empty($mimeType) ? 'application/octet-stream' : $mimeType;\n        $finalFileName = self::escapeQuotes($fileName);\n        array_push($data, \"Content-Disposition: form-data; name=\\\"$name\\\"; filename=\\\"$finalFileName\\\"\");\n        array_push($data, \"Content-Type: $finalMimeType\");\n        array_push($data, '');\n        array_push($data, $fileBody);\n\n        array_push($data, '--' . $mimeBoundary . '--');\n        array_push($data, '');\n\n        $body = implode(\"\\r\\n\", $data);\n        $contentType = 'multipart/form-data; boundary=' . $mimeBoundary;\n        $headers['Content-Type'] = $contentType;\n        $request = new Request('POST', $url, $headers, $body);\n        return self::sendRequest($request);\n    }\n\n    private static function userAgent()\n    {\n        $sdkInfo = \"QiniuPHP/\" . Config::SDK_VER;\n        $systemInfo = php_uname(\"s\");\n        $machineInfo = php_uname(\"m\");\n        $envInfo = \"($systemInfo/$machineInfo)\";\n        $phpVer = phpversion();\n        $ua = \"$sdkInfo $envInfo PHP/$phpVer\";\n        return $ua;\n    }\n\n    public static function sendRequest($request)\n    {\n        $t1 = microtime(true);\n        $ch = curl_init();\n        $options = array(\n            CURLOPT_USERAGENT => self::userAgent(),\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HEADER => true,\n            CURLOPT_NOBODY => false,\n            CURLOPT_CUSTOMREQUEST => $request->method,\n            CURLOPT_URL => $request->url,\n        );\n\n        if (!ini_get('safe_mode') && !ini_get('open_basedir')) {\n            $options[CURLOPT_FOLLOWLOCATION] = true;\n        }\n\n        if (!empty($request->headers)) {\n            $headers = array();\n            foreach ($request->headers as $key => $val) {\n                array_push($headers, \"$key: $val\");\n            }\n            $options[CURLOPT_HTTPHEADER] = $headers;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, array('Expect:'));\n\n        if (!empty($request->body)) {\n            $options[CURLOPT_POSTFIELDS] = $request->body;\n        }\n        curl_setopt_array($ch, $options);\n        $result = curl_exec($ch);\n        $t2 = microtime(true);\n        $duration = round($t2 - $t1, 3);\n        $ret = curl_errno($ch);\n        if ($ret !== 0) {\n            $r = new Response(-1, $duration, array(), null, curl_error($ch));\n            curl_close($ch);\n            return $r;\n        }\n        $code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = self::parseHeaders(substr($result, 0, $header_size));\n        $body = substr($result, $header_size);\n        curl_close($ch);\n        return new Response($code, $duration, $headers, $body, null);\n    }\n\n    private static function parseHeaders($raw)\n    {\n        $headers = array();\n        $headerLines = explode(\"\\r\\n\", $raw);\n        foreach ($headerLines as $line) {\n            $headerLine = trim($line);\n            $kv = explode(':', $headerLine);\n            if (count($kv) > 1) {\n                $kv[0] =self::ucwordsHyphen($kv[0]);\n                $headers[$kv[0]] = trim($kv[1]);\n            }\n        }\n        return $headers;\n    }\n\n    private static function escapeQuotes($str)\n    {\n        $find = array(\"\\\\\", \"\\\"\");\n        $replace = array(\"\\\\\\\\\", \"\\\\\\\"\");\n        return str_replace($find, $replace, $str);\n    }\n    \n    private static function ucwordsHyphen($str)\n    {\n        return str_replace('- ', '-', ucwords(str_replace('-', '- ', $str)));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($key) . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($name) . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->getUrl());\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->getMethod());\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->getBody()) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->getBody());\n        }\n\n        $processedHeaders = [];\n        foreach ($request->getHeaders() as $key => $value) {\n            $processedHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $processedHeaders);\n\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($errno) {\n            throw new Exception($error, $errno);\n        }\n\n        $headers = self::parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n\n        return new Response($httpCode, $body, $headers);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' ' . php_uname('s') . '/' . php_uname('r');\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = array();\n        $lines = explode(\"\\r\\n\", $raw);\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', '-', ucwords(strtolower(str_replace('-', ' ', $str))));\n    }\n}\n\nclass Request\n{\n    private string $method;\n    private string $url;\n    private mixed $body;\n    private array $headers;\n\n    public function __construct(string $method, string $url, mixed $body = null, array $headers = array())\n    {\n        $this->method = $method;\n        $this->url = $url;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getUrl(): string\n    {\n        return $this->url;\n    }\n\n    public function getBody(): mixed\n    {\n        return $this->body;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n}\n\nclass Response\n{\n    private int $httpCode;\n    private string $body;\n    private array $headers;\n\n    public function __construct(int $httpCode, string $body, array $headers)\n    {\n        $this->httpCode = $httpCode;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n\n    public function getHttpCode(): int\n    {\n        return $this->httpCode;\n    }\n\n    public function getBody(): string\n    {\n        return $this->body;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($key) . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($name) . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->getUrl());\n        curl_setopt_array($ch, [\n            CURLOPT_CUSTOMREQUEST => $request->getMethod(),\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HEADER => true,\n            CURLOPT_USERAGENT => self::userAgent(),\n        ]);\n\n        if ($request->getBody()) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->getBody());\n        }\n\n        $headers = $request->getHeaders();\n        if (!empty($headers)) {\n            $formattedHeaders = [];\n            foreach ($headers as $key => $value) {\n                $formattedHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n            }\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $formattedHeaders);\n        }\n\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n        $info = curl_getinfo($ch);\n        curl_close($ch);\n\n        if ($errno) {\n            throw new Exception($error, $errno);\n        }\n\n        list($headerStr, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $headers = self::parseHeaders($headerStr);\n\n        return new Response($info['http_code'], $headers, $body);\n    }\n\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (' . php_uname('s') . ')';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $raw) as $header) {\n            if (strpos($header, ':') !== false) {\n                list($key, $value) = explode(':', $header, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', '-', ucwords(strtolower(str_replace('-', ' ', $str))));\n    }\n}\n\nclass Request\n{\n    private string $method;\n    private string $url;\n    private mixed $body;\n    private array $headers;\n\n    public function __construct(string $method, string $url, mixed $body = null, array $headers = [])\n    {\n        $this->method = $method;\n        $this->url = $url;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getUrl(): string\n    {\n        return $this->url;\n    }\n\n    public function getBody(): mixed\n    {\n        return $this->body;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n}\n\nclass Response\n{\n    private int $statusCode;\n    private array $headers;\n    private string $body;\n\n    public function __construct(int $statusCode, array $headers, string $body)\n    {\n        $this->statusCode = $statusCode;\n        $this->headers = $headers;\n        $this->body = $body;\n    }\n\n    public function getStatusCode(): int\n    {\n        return $this->statusCode;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n\n    public function getBody(): string\n    {\n        return $this->body;\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($key) . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($name) . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->getUrl());\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->getMethod());\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->getBody()) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->getBody());\n        }\n\n        $headers = array_merge(['Expect:'], $request->getHeaders());\n        $formattedHeaders = [];\n        foreach ($headers as $key => $value) {\n            if (is_numeric($key)) {\n                $formattedHeaders[] = self::escapeQuotes($value);\n            } else {\n                $formattedHeaders[] = self::ucwordsHyphen($key) . \": \" . self::escapeQuotes($value);\n            }\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $formattedHeaders);\n\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n        $info = curl_getinfo($ch);\n        curl_close($ch);\n\n        if ($errno) {\n            throw new Exception($error, $errno);\n        }\n\n        list($headerStr, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $headers = self::parseHeaders($headerStr);\n\n        return new Response($info['http_code'], $headers, $body);\n    }\n\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (Your SDK Name)';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", $raw);\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', '-', ucwords(strtolower(str_replace('-', ' ', $str))));\n    }\n}\n\nclass Request\n{\n    private string $method;\n    private string $url;\n    private mixed $body;\n    private array $headers;\n\n    public function __construct(string $method, string $url, mixed $body = null, array $headers = [])\n    {\n        $this->method = $method;\n        $this->url = $url;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getUrl(): string\n    {\n        return $this->url;\n    }\n\n    public function getBody(): mixed\n    {\n        return $this->body;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n}\n\nclass Response\n{\n    private int $statusCode;\n    private array $headers;\n    private string $body;\n\n    public function __construct(int $statusCode, array $headers, string $body)\n    {\n        $this->statusCode = $statusCode;\n        $this->headers = $headers;\n        $this->body = $body;\n    }\n\n    public function getStatusCode(): int\n    {\n        return $this->statusCode;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n\n    public function getBody(): string\n    {\n        return $this->body;\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($key) . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($name) . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->getUrl());\n        curl_setopt_array($ch, [\n            CURLOPT_CUSTOMREQUEST => $request->getMethod(),\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HEADER => true,\n            CURLOPT_USERAGENT => self::userAgent(),\n        ]);\n\n        if ($request->getBody()) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->getBody());\n        }\n\n        $processedHeaders = [];\n        foreach ($request->getHeaders() as $key => $value) {\n            $processedHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $processedHeaders);\n\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($httpCode, self::parseHeaders($headers), $body, $error, $errno);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (Your SDK Name)';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", trim($raw));\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                [$key, $value] = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', '-', ucwords(strtolower(str_replace('-', ' ', $str))));\n    }\n}\n\nclass Request\n{\n    private string $method;\n    private string $url;\n    private mixed $body;\n    private array $headers;\n\n    public function __construct(string $method, string $url, mixed $body = null, array $headers = [])\n    {\n        $this->method = $method;\n        $this->url = $url;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getUrl(): string\n    {\n        return $this->url;\n    }\n\n    public function getBody(): mixed\n    {\n        return $this->body;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n}\n\nclass Response\n{\n    private int $httpCode;\n    private array $headers;\n    private string $body;\n    private string $error;\n    private int $errno;\n\n    public function __construct(int $httpCode, array $headers, string $body, string $error, int $errno)\n    {\n        $this->httpCode = $httpCode;\n        $this->headers = $headers;\n        $this->body = $body;\n        $this->error = $error;\n        $this->errno = $errno;\n    }\n\n    public function getHttpCode(): int\n    {\n        return $this->httpCode;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n\n    public function getBody(): string\n    {\n        return $this->body;\n    }\n\n    public function getError(): string\n    {\n        return $this->error;\n    }\n\n    public function getErrno(): int\n    {\n        return $this->errno;\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($key) . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($name) . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->getUrl());\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->getMethod());\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->getBody()) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->getBody());\n        }\n\n        $processedHeaders = [];\n        foreach ($request->getHeaders() as $key => $value) {\n            $processedHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $processedHeaders);\n\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($errno) {\n            throw new Exception($error, $errno);\n        }\n\n        return new Response($httpCode, self::parseHeaders($headers), $body);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (' . php_uname('s') . ')';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = array();\n        $lines = explode(\"\\r\\n\", trim($raw));\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', '-', ucwords(strtolower(str_replace('-', ' ', $str))));\n    }\n}\n\nclass Request\n{\n    private string $method;\n    private string $url;\n    private mixed $body;\n    private array $headers;\n\n    public function __construct(string $method, string $url, mixed $body = null, array $headers = array())\n    {\n        $this->method = $method;\n        $this->url = $url;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getUrl(): string\n    {\n        return $this->url;\n    }\n\n    public function getBody(): mixed\n    {\n        return $this->body;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n}\n\nclass Response\n{\n    private int $httpCode;\n    private array $headers;\n    private string $body;\n\n\n    public function __construct(int $httpCode, array $headers, string $body)\n    {\n        $this->httpCode = $httpCode;\n        $this->headers = $headers;\n        $this->body = $body;\n    }\n\n    public function getHttpCode(): int\n    {\n        return $this->httpCode;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n\n    public function getBody(): string\n    {\n        return $this->body;\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($key) . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($name) . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->getUrl());\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->getMethod());\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->getBody()) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->getBody());\n        }\n\n        $processedHeaders = [];\n        foreach ($request->getHeaders() as $key => $value) {\n            $processedHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $processedHeaders);\n\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($httpCode, self::parseHeaders($headers), $body, $error, $errno);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' ' . php_uname('s') . '/' . php_uname('r');\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", trim($raw));\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                [$key, $value] = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', '-', ucwords(strtolower(str_replace('-', ' ', $str))));\n    }\n}\n\nclass Request\n{\n    private string $method;\n    private string $url;\n    private mixed $body;\n    private array $headers;\n\n    public function __construct(string $method, string $url, mixed $body = null, array $headers = [])\n    {\n        $this->method = $method;\n        $this->url = $url;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getUrl(): string\n    {\n        return $this->url;\n    }\n\n    public function getBody(): mixed\n    {\n        return $this->body;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n}\n\nclass Response\n{\n    private int $httpCode;\n    private array $headers;\n    private string $body;\n    private string $error;\n    private int $errno;\n\n    public function __construct(int $httpCode, array $headers, string $body, string $error, int $errno)\n    {\n        $this->httpCode = $httpCode;\n        $this->headers = $headers;\n        $this->body = $body;\n        $this->error = $error;\n        $this->errno = $errno;\n    }\n\n    public function getHttpCode(): int\n    {\n        return $this->httpCode;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n\n    public function getBody(): string\n    {\n        return $this->body;\n    }\n\n    public function getError(): string\n    {\n        return $this->error;\n    }\n\n    public function getErrno(): int\n    {\n        return $this->errno;\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($key) . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($name) . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->getUrl());\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->getMethod());\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->getBody()) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->getBody());\n        }\n\n        $processedHeaders = [];\n        foreach ($request->getHeaders() as $key => $value) {\n            $processedHeaders[] = self::ucwordsHyphen($key) . \": \" . self::escapeQuotes($value);\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $processedHeaders);\n\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n\n        if ($errno) {\n            throw new Exception(\"cURL error: {$error}\", $errno);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = self::parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($statusCode, $headers, $body);\n\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (Your SDK Name)';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", trim($raw));\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                [$key, $value] = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', '-', ucwords(strtolower(str_replace('-', ' ', $str))));\n    }\n}\n\nclass Request\n{\n    private string $method;\n    private string $url;\n    private mixed $body;\n    private array $headers;\n\n    public function __construct(string $method, string $url, mixed $body = null, array $headers = [])\n    {\n        $this->method = $method;\n        $this->url = $url;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getUrl(): string\n    {\n        return $this->url;\n    }\n\n    public function getBody(): mixed\n    {\n        return $this->body;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n}\n\nclass Response\n{\n    private int $statusCode;\n    private array $headers;\n    private string $body;\n\n\n    public function __construct(int $statusCode, array $headers, string $body)\n    {\n        $this->statusCode = $statusCode;\n        $this->headers = $headers;\n        $this->body = $body;\n    }\n\n    public function getStatusCode(): int\n    {\n        return $this->statusCode;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n\n    public function getBody(): string\n    {\n        return $this->body;\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($key) . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($name) . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->getUrl());\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->getMethod());\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->getBody()) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->getBody());\n        }\n\n        $headers = $request->getHeaders();\n        if (!empty($headers)) {\n            $formattedHeaders = [];\n            foreach ($headers as $key => $value) {\n                $formattedHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n            }\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $formattedHeaders);\n        }\n\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n        $info = curl_getinfo($ch);\n        curl_close($ch);\n\n        if ($errno) {\n            throw new Exception($error, $errno);\n        }\n\n        list($headerStr, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $headers = self::parseHeaders($headerStr);\n\n        return new Response($info['http_code'], $body, $headers);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (Your SDK Name)';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $raw) as $header) {\n            if (strpos($header, ':') !== false) {\n                list($key, $value) = explode(':', $header, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', '-', ucwords(strtolower(str_replace('-', ' ', $str))));\n    }\n}\n\nclass Request\n{\n    private string $method;\n    private string $url;\n    private mixed $body;\n    private array $headers;\n\n    public function __construct(string $method, string $url, mixed $body = null, array $headers = [])\n    {\n        $this->method = $method;\n        $this->url = $url;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getUrl(): string\n    {\n        return $this->url;\n    }\n\n    public function getBody(): mixed\n    {\n        return $this->body;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n}\n\nclass Response\n{\n    private int $statusCode;\n    private string $body;\n    private array $headers;\n\n    public function __construct(int $statusCode, string $body, array $headers)\n    {\n        $this->statusCode = $statusCode;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n\n    public function getStatusCode(): int\n    {\n        return $this->statusCode;\n    }\n\n    public function getBody(): string\n    {\n        return $this->body;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($key) . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($name) . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->getUrl());\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->getMethod());\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->getBody()) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->getBody());\n        }\n\n        $processedHeaders = [];\n        foreach ($request->getHeaders() as $key => $value) {\n            $processedHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $processedHeaders);\n\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($errno) {\n            throw new Exception($error, $errno);\n        }\n\n        return new Response($httpCode, self::parseHeaders($headers), $body);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (Your SDK Name)';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", trim($raw));\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                [$key, $value] = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', '-', ucwords(strtolower(str_replace('-', ' ', $str))));\n    }\n}\n\nclass Request\n{\n    private string $method;\n    private string $url;\n    private mixed $body;\n    private array $headers;\n\n    public function __construct(string $method, string $url, mixed $body = null, array $headers = [])\n    {\n        $this->method = $method;\n        $this->url = $url;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getUrl(): string\n    {\n        return $this->url;\n    }\n\n    public function getBody(): mixed\n    {\n        return $this->body;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n}\n\nclass Response\n{\n    private int $httpCode;\n    private array $headers;\n    private string $body;\n\n    public function __construct(int $httpCode, array $headers, string $body)\n    {\n        $this->httpCode = $httpCode;\n        $this->headers = $headers;\n        $this->body = $body;\n    }\n\n    public function getHttpCode(): int\n    {\n        return $this->httpCode;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n\n    public function getBody(): string\n    {\n        return $this->body;\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($key) . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($name) . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->body);\n        }\n\n        $processedHeaders = [];\n        foreach ($request->headers as $key => $value) {\n            $processedHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $processedHeaders);\n\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n\n        if ($errno) {\n            throw new Exception($error, $errno);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = self::parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($statusCode, $body, $headers);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' ' . php_uname('s') . '/' . php_uname('r');\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", trim($raw));\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                [$key, $value] = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', '-', ucwords(strtolower(str_replace('-', ' ', $str))));\n    }\n}\n\nclass Request\n{\n    public function __construct(\n        public string $method,\n        public string $url,\n        public mixed $body,\n        public array $headers\n    ) {\n    }\n}\n\nclass Response\n{\n    public function __construct(\n        public int $statusCode,\n        public string $body,\n        public array $headers\n    ) {\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Implement a PHP class for interacting with the BTCPay payment gateway to create invoices and process payments.\n\nClass Description: The BTCPay class encapsulates functionality for communicating with the BTCPay server API. It handles authentication, request formatting, and response processing for invoice creation.\n\nAttributes:\n- config: [array] - Stores configuration parameters including BTCPay server URL, store ID, and API key\n\nMethods:\n- __construct($config): [void] - Initializes the class with configuration parameters\n  - $config: [array] - Configuration array containing:\n    - btcpay_url: [string] - Base URL of BTCPay server\n    - btcpay_storeId: [string] - Store identifier\n    - btcpay_api_key: [string] - API authentication token\n\n- pay($order): [array] - Creates a payment invoice in BTCPay\n  - $order: [array] - Order details containing:\n    - total_amount: [numeric] - Order amount in smallest currency unit (e.g., cents)\n    - trade_no: [string] - Unique order identifier\n  - Returns: [array] - Payment response containing:\n    - type: [integer] - Response type identifier\n    - data: [string] - Checkout URL for payment\n\n- _curlPost($url, $params): [string] - Internal method for making HTTP POST requests\n  - $url: [string] - API endpoint URL\n  - $params: [string|false] - JSON-encoded request body or false for empty body\n  - Returns: [string] - Raw API response",
    "Canonical_solution": "namespace App\\Payments;\n\nclass BTCPay {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    public function pay($order) {\n        $params = [\n            'jsonResponse' => true,\n            'amount' => sprintf('%.2f', $order['total_amount'] / 100),\n            'currency' => 'CNY',\n            'metadata' => [\n                'orderId' => $order['trade_no']\n            ]\n        ];\n\n        $params_string = @json_encode($params);\n        $ret_raw = $this->_curlPost($this->config['btcpay_url'] . 'api/v1/stores/' . $this->config['btcpay_storeId'] . '/invoices', $params_string);\n        $ret = @json_decode($ret_raw, true);\n        \n        if(empty($ret['checkoutLink'])) {\n            abort(500, \"error!\");\n        }\n        return [\n            'type' => 1,\n            'data' => $ret['checkoutLink'],\n        ];\n    }\n\n    private function _curlPost($url, $params=false) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 0);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 300);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        curl_setopt(\n            $ch, \n            CURLOPT_HTTPHEADER, \n            array(\n                'Authorization:' .'token '.$this->config['btcpay_api_key'], \n                'Content-Type: application/json'\n            )\n        );\n        $result = curl_exec($ch);\n        curl_close($ch);\n        return $result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass BTCPay {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    public function pay($order) {\n        $url = $this->config['btcpay_url'] . '/stores/' . $this->config['btcpay_storeId'] . '/invoices';\n        $params = json_encode([\n            'price' => $order['total_amount'] / 100,\n            'currency' => 'USD',\n            'orderId' => $order['trade_no'],\n            'checkout' => [\n                'redirectURL' => 'https://yourwebsite.com/payment_success',\n                'paymentMethods' => ['BTC']\n            ]\n        ]);\n\n        $response = $this->_curlPost($url, $params);\n        $decodedResponse = json_decode($response, true);\n\n        if (isset($decodedResponse['checkoutLink'])) {\n            return [\n                'type' => 1,\n                'data' => $decodedResponse['checkoutLink']\n            ];\n        } else {\n            return [\n                'type' => 0,\n                'data' => 'Error creating invoice'\n            ];\n        }\n    }\n\n\n    private function _curlPost($url, $params) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        }\n        $headers = [\n            'Content-Type: application/json',\n            'Authorization: token ' . $this->config['btcpay_api_key']\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass BTCPay {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    public function pay($order) {\n        $url = $this->config['btcpay_url'] . '/stores/' . $this->config['btcpay_storeId'] . '/invoices';\n        $params = json_encode([\n            'price' => $order['total_amount'] / 100,\n            'currency' => 'USD',\n            'orderId' => $order['trade_no'],\n            'checkout' => [\n                'redirectURL' => 'https://yourwebsite.com/payment_success',\n                'paymentMethods' => ['BTC']\n            ]\n        ]);\n\n        $response = $this->_curlPost($url, $params);\n        $decodedResponse = json_decode($response, true);\n\n        if (isset($decodedResponse['checkoutLink'])) {\n            return [\n                'type' => 1,\n                'data' => $decodedResponse['checkoutLink']\n            ];\n        } else {\n            return [\n                'type' => 0,\n                'data' => 'Error creating invoice'\n            ];\n        }\n    }\n\n\n    private function _curlPost($url, $params) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        }\n        $headers = [\n            'Content-Type: application/json',\n            'Authorization: token ' . $this->config['btcpay_api_key']\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        $result = curl_exec($ch);\n        curl_close($ch);\n        return $result;\n    }\n}\n?>\n",
      "<?php\nclass BTCPay {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    public function pay($order) {\n        $url = $this->config['btcpay_url'] . '/stores/' . $this->config['btcpay_storeId'] . '/invoices';\n        $params = json_encode([\n            'price' => $order['total_amount'] / 100,\n            'currency' => 'USD',\n            'orderId' => $order['trade_no'],\n            'checkout' => [\n                'redirectURL' => 'https://yourwebsite.com/return_url',\n            ]\n        ]);\n\n        $response = $this->_curlPost($url, $params);\n        $decodedResponse = json_decode($response, true);\n\n        if (isset($decodedResponse['checkoutLink'])) {\n            return [\n                'type' => 1,\n                'data' => $decodedResponse['checkoutLink']\n            ];\n        } else {\n            return [\n                'type' => 0,\n                'data' => 'Error creating invoice'\n            ];\n        }\n    }\n\n\n    private function _curlPost($url, $params) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        }\n        $headers = [\n            'Content-Type: application/json',\n            'Authorization: token ' . $this->config['btcpay_api_key']\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass BTCPay {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    public function pay($order) {\n        $url = $this->config['btcpay_url'] . '/stores/' . $this->config['btcpay_storeId'] . '/invoices';\n        $params = json_encode([\n            'price' => $order['total_amount'] / 100,\n            'currency' => 'USD',\n            'orderId' => $order['trade_no'],\n            'checkout' => [\n                'redirectURL' => 'https://yourwebsite.com/payment_success',\n                'paymentMethods' => ['BTC']\n            ]\n        ]);\n\n        $response = $this->_curlPost($url, $params);\n        $decodedResponse = json_decode($response, true);\n\n        if (isset($decodedResponse['checkoutLink'])) {\n            return [\n                'type' => 1,\n                'data' => $decodedResponse['checkoutLink']\n            ];\n        } else {\n            return [\n                'type' => 0,\n                'data' => 'Error creating invoice'\n            ];\n        }\n    }\n\n\n    private function _curlPost($url, $params) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        }\n        $headers = [\n            'Content-Type: application/json',\n            'Authorization: token ' . $this->config['btcpay_api_key']\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        $result = curl_exec($ch);\n        curl_close($ch);\n        return $result;\n    }\n}\n?>\n",
      "<?php\nclass BTCPay {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    public function pay($order) {\n        $url = $this->config['btcpay_url'] . '/stores/' . $this->config['btcpay_storeId'] . '/invoices';\n        $params = json_encode([\n            'price' => $order['total_amount'] / 100,\n            'currency' => 'USD',\n            'orderId' => $order['trade_no'],\n            'checkout' => [\n                'redirectURL' => 'https://yourwebsite.com/payment_success',\n                'paymentMethods' => ['BTC']\n            ]\n        ]);\n\n        $response = $this->_curlPost($url, $params);\n        $responseData = json_decode($response, true);\n\n        if (isset($responseData['checkoutLink'])) {\n            return [\n                'type' => 1,\n                'data' => $responseData['checkoutLink']\n            ];\n        } else {\n            return [\n                'type' => 0,\n                'data' => 'Error creating invoice'\n            ];\n        }\n    }\n\n\n    private function _curlPost($url, $params) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        }\n        $headers = [\n            'Content-Type: application/json',\n            'Authorization: token ' . $this->config['btcpay_api_key']\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass BTCPay {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    public function pay($order) {\n        $url = $this->config['btcpay_url'] . '/stores/' . $this->config['btcpay_storeId'] . '/invoices';\n        $params = json_encode([\n            'price' => $order['total_amount'] / 100,\n            'currency' => 'USD',\n            'orderId' => $order['trade_no'],\n            'checkout' => [\n                'redirectURL' => 'https://yourwebsite.com/payment_success', \n                'paymentMethods' => ['BTC']\n            ]\n        ]);\n\n        $response = $this->_curlPost($url, $params);\n        $decodedResponse = json_decode($response, true);\n\n        if (isset($decodedResponse['checkoutLink'])) {\n            return [\n                'type' => 1,\n                'data' => $decodedResponse['checkoutLink']\n            ];\n        } else {\n            return [\n                'type' => 0,\n                'data' => 'Error creating invoice'\n            ];\n        }\n    }\n\n\n    private function _curlPost($url, $params) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        }\n        $headers = [\n            'Content-Type: application/json',\n            'Authorization: token ' . $this->config['btcpay_api_key']\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass BTCPay {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    public function pay($order) {\n        $url = $this->config['btcpay_url'] . '/stores/' . $this->config['btcpay_storeId'] . '/invoices';\n        $params = json_encode([\n            'price' => $order['total_amount'] / 100,\n            'currency' => 'USD',\n            'orderId' => $order['trade_no'],\n            'checkout' => [\n                'redirectURL' => 'https://yourwebsite.com/return_url',\n            ]\n        ]);\n\n        $response = $this->_curlPost($url, $params);\n        $decodedResponse = json_decode($response, true);\n\n        if (isset($decodedResponse['checkoutLink'])) {\n            return [\n                'type' => 1,\n                'data' => $decodedResponse['checkoutLink']\n            ];\n        } else {\n            return [\n                'type' => 0,\n                'data' => 'Error creating invoice'\n            ];\n        }\n    }\n\n\n    private function _curlPost($url, $params) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        }\n        $headers = [\n            'Content-Type: application/json',\n            'Authorization: token ' . $this->config['btcpay_api_key']\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass BTCPay {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    public function pay($order) {\n        $url = $this->config['btcpay_url'] . '/stores/' . $this->config['btcpay_storeId'] . '/invoices';\n        $params = json_encode([\n            'price' => $order['total_amount'] / 100,\n            'currency' => 'USD',\n            'orderId' => $order['trade_no'],\n            'checkout' => [\n                'redirectURL' => 'https://yourwebsite.com/payment_success', \n            ]\n        ]);\n\n        $response = $this->_curlPost($url, $params);\n        $decodedResponse = json_decode($response, true);\n\n        if (isset($decodedResponse['checkoutLink'])) {\n            return [\n                'type' => 1,\n                'data' => $decodedResponse['checkoutLink']\n            ];\n        } else {\n            return [\n                'type' => 0,\n                'data' => 'Error creating invoice' \n            ];\n        }\n    }\n\n\n    private function _curlPost($url, $params) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        }\n        $headers = [\n            'Content-Type: application/json',\n            'Authorization: token ' . $this->config['btcpay_api_key']\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass BTCPay {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    public function pay($order) {\n        $url = $this->config['btcpay_url'] . '/stores/' . $this->config['btcpay_storeId'] . '/invoices';\n        $params = json_encode([\n            'price' => $order['total_amount'] / 100,\n            'currency' => 'USD',\n            'orderId' => $order['trade_no'],\n            'checkout' => [\n                'redirectURL' => 'https://yourwebsite.com/payment_success',\n                'paymentMethods' => ['BTC']\n            ]\n        ]);\n\n        $response = $this->_curlPost($url, $params);\n        $decodedResponse = json_decode($response, true);\n\n        if (isset($decodedResponse['checkoutLink'])) {\n            return [\n                'type' => 1,\n                'data' => $decodedResponse['checkoutLink']\n            ];\n        } else {\n            return [\n                'type' => 0,\n                'data' => 'Error creating invoice'\n            ];\n        }\n    }\n\n\n    private function _curlPost($url, $params) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        }\n        $headers = [\n            'Content-Type: application/json',\n            'Authorization: token ' . $this->config['btcpay_api_key']\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n",
      "<?php\nclass BTCPay {\n    private $config;\n\n    public function __construct($config) {\n        $this->config = $config;\n    }\n\n    public function pay($order) {\n        $url = $this->config['btcpay_url'] . '/stores/' . $this->config['btcpay_storeId'] . '/invoices';\n        $params = json_encode([\n            'price' => $order['total_amount'] / 100,\n            'currency' => 'USD',\n            'orderId' => $order['trade_no'],\n            'checkout' => [\n                'redirectURL' => 'https://yourwebsite.com/payment_success',\n                'paymentMethods' => ['BTC']\n            ]\n        ]);\n\n        $response = $this->_curlPost($url, $params);\n        $responseData = json_decode($response, true);\n\n        if (isset($responseData['checkoutLink'])) {\n            return [\n                'type' => 1,\n                'data' => $responseData['checkoutLink']\n            ];\n        } else {\n            return [\n                'type' => 0,\n                'data' => 'Error creating invoice'\n            ];\n        }\n    }\n\n\n    private function _curlPost($url, $params) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_POST, true);\n        if ($params) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $params);\n        }\n        $headers = [\n            'Content-Type: application/json',\n            'Authorization: token ' . $this->config['btcpay_api_key']\n        ];\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a PHP function that makes an HTTP request using cURL with specific configurations for timeout, headers, SSL verification, and referer settings.\n\nFunction Description: The function performs an HTTP GET request to a specified URL using PHP's cURL library. It includes custom headers (including a mobile user agent), disables SSL verification for development purposes, sets a referer header, and ensures the response is returned as a string. The function handles the complete cURL lifecycle from initialization to cleanup.\n\nInput: \n- $url (string): The target URL to which the HTTP request will be made\n\nOutput: \n- string: The contents of the response from the HTTP request, or false if the request fails",
    "Canonical_solution": "function curl($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5000);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, array(\n        'User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4'\n    ));\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REDIR_PROTOCOLS, -1);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.58pic.com/c/15990160');\n    $contents = curl_exec($ch);\n    curl_close($ch);\n    return $contents;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Accept-Language: en-US,en;q=0.9',\n        'Cache-Control: max-age=0',\n    ]);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n    $response = curl_exec($ch);\n    if ($response === false) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Accept-Language: en-US,en;q=0.9',\n        'Cache-Control: max-age=0',\n    ]);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Accept-Language: en-US,en;q=0.9',\n        'Cache-Control: max-age=0',\n    ]);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Accept-Encoding: gzip, deflate',\n        'Accept-Language: en-US,en;q=0.9',\n        'Cache-Control: max-age=0',\n        'Connection: keep-alive',\n        'Upgrade-Insecure-Requests: 1'\n    ]);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n    $response = curl_exec($ch);\n    if ($response === false) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Accept-Encoding: gzip, deflate',\n        'Accept-Language: en-US,en;q=0.9',\n        'Cache-Control: max-age=0',\n        'Connection: keep-alive',\n        'Upgrade-Insecure-Requests: 1'\n    ]);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Accept-Language: en-US,en;q=0.9',\n        'Cache-Control: max-age=0',\n    ]);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Accept-Encoding: gzip, deflate',\n        'Accept-Language: en-US,en;q=0.9',\n        'Cache-Control: max-age=0',\n        'Connection: keep-alive',\n        'Upgrade-Insecure-Requests: 1'\n    ]);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.117 Mobile Safari/537.36');\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Accept-Encoding: gzip, deflate, br',\n        'Accept-Language: en-US,en;q=0.9',\n        'Cache-Control: no-cache',\n        'Connection: keep-alive',\n        'Pragma: no-cache',\n        'Sec-Fetch-Dest: document',\n        'Sec-Fetch-Mode: navigate',\n        'Sec-Fetch-Site: none',\n        'Sec-Fetch-User: ?1',\n        'Upgrade-Insecure-Requests: 1'\n    ]);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 11; SM-A205U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.140 Mobile Safari/537.36');\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',\n        'Accept-Language: en-US,en;q=0.9',\n        'Cache-Control: max-age=0',\n        'Sec-Ch-Ua: \"Chromium\";v=\"116\", \"Not)A;Brand\";v=\"24\", \"Google Chrome\";v=\"116\"',\n        'Sec-Ch-Ua-Mobile: ?1',\n        'Sec-Ch-Ua-Platform: \"Android\"',\n        'Sec-Fetch-Dest: document',\n        'Sec-Fetch-Mode: navigate',\n        'Sec-Fetch-Site: none',\n        'Sec-Fetch-User: ?1',\n        'Upgrade-Insecure-Requests: 1'\n    ]);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Linux; Android 11; SM-A205U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.140 Mobile Safari/537.36');\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',\n        'Accept-Language: en-US,en;q=0.9',\n        'Cache-Control: max-age=0',\n        'Upgrade-Insecure-Requests: 1'\n    ]);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com/');\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Implement a PHP class that provides HTTP client functionality using Guzzle library, supporting various HTTP methods, request/response handling, and error logging.\n\nClass Description: The Guzzle class is an HTTP client implementation that wraps GuzzleHttp\\Client functionality. It supports GET, POST, PUT, PATCH, and DELETE methods, handles different content types (including multipart/form-data and JSON), manages request/response data, and provides logging capabilities.\n\nAttributes:\n- requestArguments: [array] - Stores request parameters including URI, method, parameters, and headers\n- requestHeader: [array] - Contains HTTP headers for the request\n- responseBody: [string] - Stores the response body content\n- responseHeader: [array] - Contains HTTP headers from the response\n- responseHttpCode: [int] - HTTP status code from the response\n- responseClientError: [string|null] - Stores any client error messages\n- responseClientInfo: [array] - Additional client information\n- logger: [object|null] - Logger instance for debugging and error logging\n- client: [GuzzleHttp\\Client] - Guzzle HTTP client instance\n\nMethods:\n- __construct([GuzzleHttp\\Client|null] $client, [array] $config) -> [void] - Initializes the HTTP client with optional existing client instance and configuration\n- request([string] $uri, [string] $method, [array] $parameters, [array] $headers, [bool] $multipart) -> [string] - Executes HTTP request and returns response body\n- getResponse() -> [array] - Returns complete request/response information including headers, body, and status code\n- setLogger([object] $logger) -> [void] - Sets a logger instance for debugging\n- getResponseBody() -> [string] - Returns the response body content\n- getResponseHeader() -> [array] - Returns response headers\n- getResponseHttpCode() -> [int] - Returns HTTP status code\n- getResponseClientError() -> [string|null] - Returns client error message if any\n- getResponseClientInfo() -> [array] - Returns additional client information (protected)\n- getRequestArguments() -> [array] - Returns request arguments (protected)",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse GuzzleHttp\\Exception\\TransferException;\n\nclass Guzzle implements HttpClientInterface\n{\n    protected $requestArguments = [];\n    protected $requestHeader = [];\n    protected $responseBody = '';\n    protected $responseHeader = [];\n    protected $responseHttpCode = 0;\n    protected $responseClientError = null;\n    protected $responseClientInfo = [];\n    protected $logger = null;\n    protected $client = null;\n\n    public function __construct($client = null, $config = [])\n    {\n        $this->client = $client ? $client : new Client($config);\n    }\n\n    public function request($uri, $method = 'GET', $parameters = [], $headers = [], $multipart = false)\n    {\n        $this->requestHeader = array_replace($this->requestHeader, (array)$headers);\n\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $this->requestHeader,\n        ];\n\n        $response = null;\n\n        try {\n            switch ($method) {\n                case 'GET':\n                case 'DELETE':\n                    $response = $this->client->request($method, $uri, [\n                        'query' => $parameters,\n                        'headers' => $this->requestHeader,\n                    ]);\n                    break;\n                case 'PUT':\n                case 'PATCH':\n                case 'POST':\n                    $body_type = $multipart ? 'multipart' : 'form_params';\n\n                    if (isset($this->requestHeader['Content-Type'])\n                        && $this->requestHeader['Content-Type'] === 'application/json'\n                    ) {\n                        $body_type = 'json';\n                    }\n\n                    $body_content = $parameters;\n                    if ($multipart) {\n                        $body_content = [];\n                        foreach ($parameters as $key => $val) {\n                            if ($val instanceof \\CURLFile) {\n                                $val = fopen($val->getFilename(), 'r');\n                            }\n\n                            $body_content[] = [\n                                'name' => $key,\n                                'contents' => $val,\n                            ];\n                        }\n                    }\n\n                    $response = $this->client->request($method, $uri, [\n                        $body_type => $body_content,\n                        'headers' => $this->requestHeader,\n                    ]);\n                    break;\n            }\n        } catch (\\Exception $e) {\n            $response = $e->getResponse();\n            $this->responseClientError = $e->getMessage();\n        }\n\n        if (!$this->responseClientError) {\n            $this->responseBody = $response->getBody();\n            $this->responseHttpCode = $response->getStatusCode();\n            $this->responseHeader = $response->getHeaders();\n        }\n\n        if ($this->logger) {\n            $this->logger->debug(sprintf('%s::request( %s, %s ), response:', get_class($this), $uri, $method), $this->getResponse());\n\n            if ($this->responseClientError) {\n                $this->logger->error(sprintf('%s::request( %s, %s ), error:', get_class($this), $uri, $method), [$this->responseClientError]);\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n    public function getResponse()\n    {\n        return [\n            'request' => $this->getRequestArguments(),\n            'response' => [\n                'code' => $this->getResponseHttpCode(),\n                'headers' => $this->getResponseHeader(),\n                'body' => $this->getResponseBody(),\n            ],\n            'client' => [\n                'error' => $this->getResponseClientError(),\n                'info' => $this->getResponseClientInfo(),\n                'opts' => null,\n            ],\n        ];\n    }\n\n    public function setLogger($logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody()\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader()\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode()\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError()\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo()\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments()\n    {\n        return $this->requestArguments;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Log\\LoggerInterface;\n\nclass Guzzle\n{\n    private array $requestArguments = [];\n    private array $requestHeader = [];\n    private string $responseBody = '';\n    private array $responseHeader = [];\n    private int $responseHttpCode = 0;\n    private ?string $responseClientError = null;\n    private array $responseClientInfo = [];\n    private ?LoggerInterface $logger = null;\n    private Client $client;\n\n    public function __construct(?Client $client = null, array $config = [])\n    {\n        $this->client = $client ?? new Client($config);\n    }\n\n    public function request(string $uri, string $method, array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $headers,\n        ];\n        $this->requestHeader = $headers;\n\n        $options = [\n            'headers' => $headers,\n        ];\n\n        if ($method === 'GET') {\n            $options['query'] = $parameters;\n        } else {\n            if ($multipart) {\n                $options['multipart'] = $parameters;\n            } else {\n                $options['json'] = $parameters;\n            }\n        }\n\n\n        try {\n            $response = $this->client->request($method, $uri, $options);\n            $this->responseBody = $response->getBody()->getContents();\n            $this->responseHeader = $response->getHeaders();\n            $this->responseHttpCode = $response->getStatusCode();\n        } catch (RequestException $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($e->hasResponse()) {\n                $this->responseBody = $e->getResponse()->getBody()->getContents();\n                $this->responseHeader = $e->getResponse()->getHeaders();\n                $this->responseHttpCode = $e->getResponse()->getStatusCode();\n            }\n            if ($this->logger) {\n                $this->logger->error($e->getMessage());\n            }\n        } catch (\\Exception $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($this->logger) {\n                $this->logger->error($e->getMessage());\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n    public function getResponse(): array\n    {\n        return [\n            'request' => $this->requestArguments,\n            'header' => $this->responseHeader,\n            'body' => $this->responseBody,\n            'http_code' => $this->responseHttpCode,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Log\\LoggerInterface;\n\nclass Guzzle\n{\n    private array $requestArguments = [];\n    private array $requestHeader = [];\n    private string $responseBody = '';\n    private array $responseHeader = [];\n    private int $responseHttpCode = 0;\n    private ?string $responseClientError = null;\n    private array $responseClientInfo = [];\n    private ?LoggerInterface $logger = null;\n    private Client $client;\n\n    public function __construct(?Client $client = null, array $config = [])\n    {\n        $this->client = $client ?? new Client($config);\n    }\n\n    public function request(string $uri, string $method, array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $headers,\n        ];\n        $this->requestHeader = $headers;\n\n        $options = [\n            'headers' => $headers,\n        ];\n\n        if ($method === 'GET') {\n            $options['query'] = $parameters;\n        } else {\n            if ($multipart) {\n                $options['multipart'] = $parameters;\n            } else {\n                $options['json'] = $parameters;\n            }\n        }\n\n\n        try {\n            $response = $this->client->request($method, $uri, $options);\n            $this->responseBody = $response->getBody()->getContents();\n            $this->responseHeader = $response->getHeaders();\n            $this->responseHttpCode = $response->getStatusCode();\n        } catch (RequestException $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($e->hasResponse()) {\n                $this->responseBody = $e->getResponse()->getBody()->getContents();\n                $this->responseHeader = $e->getResponse()->getHeaders();\n                $this->responseHttpCode = $e->getResponse()->getStatusCode();\n            }\n            if ($this->logger) {\n                $this->logger->error($e->getMessage());\n            }\n        } catch (\\Exception $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($this->logger) {\n                $this->logger->error($e->getMessage());\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n    public function getResponse(): array\n    {\n        return [\n            'request' => $this->requestArguments,\n            'header' => $this->responseHeader,\n            'body' => $this->responseBody,\n            'http_code' => $this->responseHttpCode,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Log\\LoggerInterface;\n\nclass Guzzle\n{\n    private array $requestArguments = [];\n    private array $requestHeader = [];\n    private string $responseBody = '';\n    private array $responseHeader = [];\n    private int $responseHttpCode = 0;\n    private ?string $responseClientError = null;\n    private array $responseClientInfo = [];\n    private ?LoggerInterface $logger = null;\n    private Client $client;\n\n    public function __construct(?Client $client = null, array $config = [])\n    {\n        $this->client = $client ?? new Client($config);\n    }\n\n    public function request(string $uri, string $method, array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $headers,\n        ];\n        $this->requestHeader = $headers;\n\n        $options = [\n            'headers' => $headers,\n        ];\n\n        if ($method === 'GET') {\n            $options['query'] = $parameters;\n        } else {\n            if ($multipart) {\n                $options['multipart'] = $parameters;\n            } else {\n                $options['json'] = $parameters;\n            }\n        }\n\n\n        try {\n            $response = $this->client->request($method, $uri, $options);\n            $this->responseBody = $response->getBody()->getContents();\n            $this->responseHeader = $response->getHeaders();\n            $this->responseHttpCode = $response->getStatusCode();\n        } catch (RequestException $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($e->hasResponse()) {\n                $this->responseBody = $e->getResponse()->getBody()->getContents();\n                $this->responseHeader = $e->getResponse()->getHeaders();\n                $this->responseHttpCode = $e->getResponse()->getStatusCode();\n            }\n\n            if ($this->logger) {\n                $this->logger->error($e->getMessage());\n            }\n        } catch (\\Exception $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($this->logger) {\n                $this->logger->error($e->getMessage());\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n\n    public function getResponse(): array\n    {\n        return [\n            'request' => $this->requestArguments,\n            'header' => $this->responseHeader,\n            'body' => $this->responseBody,\n            'http_code' => $this->responseHttpCode,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Log\\LoggerInterface;\n\nclass Guzzle\n{\n    private array $requestArguments = [];\n    private array $requestHeader = [];\n    private string $responseBody = '';\n    private array $responseHeader = [];\n    private int $responseHttpCode = 0;\n    private ?string $responseClientError = null;\n    private array $responseClientInfo = [];\n    private ?LoggerInterface $logger = null;\n    private Client $client;\n\n    public function __construct(?Client $client = null, array $config = [])\n    {\n        $this->client = $client ?? new Client($config);\n    }\n\n    public function request(string $uri, string $method, array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $headers,\n        ];\n        $this->requestHeader = $headers;\n\n        $options = [\n            'headers' => $headers,\n        ];\n\n        if ($method === 'GET') {\n            $options['query'] = $parameters;\n        } else {\n            if ($multipart) {\n                $options['multipart'] = $parameters;\n            } else {\n                $options['json'] = $parameters;\n            }\n        }\n\n\n        try {\n            $response = $this->client->request($method, $uri, $options);\n            $this->responseBody = $response->getBody()->getContents();\n            $this->responseHeader = $response->getHeaders();\n            $this->responseHttpCode = $response->getStatusCode();\n        } catch (RequestException $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($e->hasResponse()) {\n                $this->responseBody = $e->getResponse()->getBody()->getContents();\n                $this->responseHeader = $e->getResponse()->getHeaders();\n                $this->responseHttpCode = $e->getResponse()->getStatusCode();\n            }\n\n            if ($this->logger) {\n                $this->logger->error($e->getMessage(), ['exception' => $e]);\n            }\n        } catch (\\Exception $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($this->logger) {\n                $this->logger->error($e->getMessage(), ['exception' => $e]);\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n    public function getResponse(): array\n    {\n        return [\n            'request' => $this->requestArguments,\n            'header' => $this->responseHeader,\n            'body' => $this->responseBody,\n            'http_code' => $this->responseHttpCode,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Log\\LoggerInterface;\n\nclass Guzzle\n{\n    private array $requestArguments = [];\n    private array $requestHeader = [];\n    private string $responseBody = '';\n    private array $responseHeader = [];\n    private int $responseHttpCode = 0;\n    private ?string $responseClientError = null;\n    private array $responseClientInfo = [];\n    private ?LoggerInterface $logger = null;\n    private Client $client;\n\n    public function __construct(?Client $client = null, array $config = [])\n    {\n        $this->client = $client ?? new Client($config);\n    }\n\n    public function request(string $uri, string $method, array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $headers,\n        ];\n        $this->requestHeader = $headers;\n\n        $options = [\n            'headers' => $headers,\n        ];\n\n        if ($method === 'GET') {\n            $options['query'] = $parameters;\n        } else {\n            if ($multipart) {\n                $options['multipart'] = $parameters;\n            } else {\n                $options['json'] = $parameters;\n            }\n        }\n\n\n        try {\n            $response = $this->client->request($method, $uri, $options);\n            $this->responseBody = $response->getBody()->getContents();\n            $this->responseHeader = $response->getHeaders();\n            $this->responseHttpCode = $response->getStatusCode();\n        } catch (RequestException $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($e->hasResponse()) {\n                $this->responseBody = $e->getResponse()->getBody()->getContents();\n                $this->responseHeader = $e->getResponse()->getHeaders();\n                $this->responseHttpCode = $e->getResponse()->getStatusCode();\n            }\n\n            if ($this->logger) {\n                $this->logger->error($e->getMessage(), ['exception' => $e]);\n            }\n        } catch (\\Exception $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($this->logger) {\n                $this->logger->error($e->getMessage(), ['exception' => $e]);\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n    public function getResponse(): array\n    {\n        return [\n            'request' => $this->requestArguments,\n            'header' => $this->responseHeader,\n            'body' => $this->responseBody,\n            'http_code' => $this->responseHttpCode,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Log\\LoggerInterface;\n\nclass Guzzle\n{\n    private array $requestArguments = [];\n    private array $requestHeader = [];\n    private string $responseBody = '';\n    private array $responseHeader = [];\n    private int $responseHttpCode = 0;\n    private ?string $responseClientError = null;\n    private array $responseClientInfo = [];\n    private ?LoggerInterface $logger = null;\n    private Client $client;\n\n    public function __construct(?Client $client = null, array $config = [])\n    {\n        $this->client = $client ?? new Client($config);\n    }\n\n    public function request(string $uri, string $method, array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $headers,\n        ];\n        $this->requestHeader = $headers;\n\n        $options = [\n            'headers' => $headers,\n        ];\n\n        if ($method === 'GET') {\n            $options['query'] = $parameters;\n        } else {\n            if ($multipart) {\n                $options['multipart'] = $this->buildMultipartData($parameters);\n            } else {\n                $options['json'] = $parameters;\n            }\n        }\n\n\n        try {\n            $response = $this->client->request($method, $uri, $options);\n            $this->responseBody = $response->getBody()->getContents();\n            $this->responseHeader = $response->getHeaders();\n            $this->responseHttpCode = $response->getStatusCode();\n        } catch (RequestException $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($e->hasResponse()) {\n                $this->responseBody = $e->getResponse()->getBody()->getContents();\n                $this->responseHeader = $e->getResponse()->getHeaders();\n                $this->responseHttpCode = $e->getResponse()->getStatusCode();\n            }\n\n            if ($this->logger) {\n                $this->logger->error($e->getMessage(), ['exception' => $e]);\n            }\n        } catch (\\Exception $e) {\n            $this->responseClientError = $e->getMessage();\n\n            if ($this->logger) {\n                $this->logger->error($e->getMessage(), ['exception' => $e]);\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n    public function getResponse(): array\n    {\n        return [\n            'request' => $this->requestArguments,\n            'header' => $this->responseHeader,\n            'body' => $this->responseBody,\n            'http_code' => $this->responseHttpCode,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n\n    private function buildMultipartData(array $parameters): array\n    {\n        $multipart = [];\n        foreach ($parameters as $key => $value) {\n            $multipart[] = [\n                'name' => $key,\n                'contents' => $value,\n            ];\n        }\n        return $multipart;\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Log\\LoggerInterface;\n\nclass Guzzle\n{\n    private array $requestArguments = [];\n    private array $requestHeader = [];\n    private string $responseBody = '';\n    private array $responseHeader = [];\n    private int $responseHttpCode = 0;\n    private ?string $responseClientError = null;\n    private array $responseClientInfo = [];\n    private ?LoggerInterface $logger = null;\n    private Client $client;\n\n    public function __construct(?Client $client = null, array $config = [])\n    {\n        $this->client = $client ?? new Client($config);\n    }\n\n    public function request(string $uri, string $method, array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $headers,\n        ];\n        $this->requestHeader = $headers;\n\n        $options = [\n            'headers' => $headers,\n        ];\n\n        if ($method === 'GET') {\n            $options['query'] = $parameters;\n        } else {\n            if ($multipart) {\n                $options['multipart'] = $this->buildMultipartData($parameters);\n            } else {\n                $options['json'] = $parameters;\n            }\n        }\n\n\n        try {\n            $response = $this->client->request($method, $uri, $options);\n            $this->responseBody = $response->getBody()->getContents();\n            $this->responseHeader = $response->getHeaders();\n            $this->responseHttpCode = $response->getStatusCode();\n        } catch (RequestException $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($e->hasResponse()) {\n                $this->responseBody = $e->getResponse()->getBody()->getContents();\n                $this->responseHeader = $e->getResponse()->getHeaders();\n                $this->responseHttpCode = $e->getResponse()->getStatusCode();\n            }\n            if ($this->logger) {\n                $this->logger->error($e->getMessage());\n            }\n        } catch (\\Exception $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($this->logger) {\n                $this->logger->error($e->getMessage());\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n    public function getResponse(): array\n    {\n        return [\n            'request' => $this->requestArguments,\n            'header' => $this->responseHeader,\n            'body' => $this->responseBody,\n            'http_code' => $this->responseHttpCode,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n\n    private function buildMultipartData(array $parameters): array\n    {\n        $multipart = [];\n        foreach ($parameters as $key => $value) {\n            $multipart[] = [\n                'name' => $key,\n                'contents' => $value,\n            ];\n        }\n        return $multipart;\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Log\\LoggerInterface;\n\nclass Guzzle\n{\n    private array $requestArguments = [];\n    private array $requestHeader = [];\n    private string $responseBody = '';\n    private array $responseHeader = [];\n    private int $responseHttpCode = 0;\n    private ?string $responseClientError = null;\n    private array $responseClientInfo = [];\n    private ?LoggerInterface $logger = null;\n    private Client $client;\n\n    public function __construct(?Client $client = null, array $config = [])\n    {\n        $this->client = $client ?? new Client($config);\n    }\n\n    public function request(string $uri, string $method, array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $headers,\n        ];\n        $this->requestHeader = $headers;\n\n        try {\n            $options = [];\n            if ($method === 'GET') {\n                $options['query'] = $parameters;\n            } else {\n                if ($multipart) {\n                    $options['multipart'] = $parameters;\n                } else if (!empty($parameters) && $headers['Content-Type'] === 'application/json') {\n                    $options['json'] = $parameters;\n                } else {\n                    $options['form_params'] = $parameters;\n                }\n            }\n            $options['headers'] = $headers;\n\n\n            $response = $this->client->request($method, $uri, $options);\n\n            $this->responseBody = $response->getBody()->getContents();\n            $this->responseHeader = $response->getHeaders();\n            $this->responseHttpCode = $response->getStatusCode();\n\n        } catch (RequestException $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($e->hasResponse()) {\n                $this->responseBody = $e->getResponse()->getBody()->getContents();\n                $this->responseHttpCode = $e->getResponse()->getStatusCode();\n            }\n            if ($this->logger) {\n                $this->logger->error($e->getMessage());\n            }\n        } catch (\\Exception $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($this->logger) {\n                $this->logger->error($e->getMessage());\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n    public function getResponse(): array\n    {\n        return [\n            'request' => $this->requestArguments,\n            'header' => $this->responseHeader,\n            'body' => $this->responseBody,\n            'http_code' => $this->responseHttpCode,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Log\\LoggerInterface;\n\nclass Guzzle\n{\n    private array $requestArguments = [];\n    private array $requestHeader = [];\n    private string $responseBody = '';\n    private array $responseHeader = [];\n    private int $responseHttpCode = 0;\n    private ?string $responseClientError = null;\n    private array $responseClientInfo = [];\n    private ?LoggerInterface $logger = null;\n    private Client $client;\n\n    public function __construct(?Client $client = null, array $config = [])\n    {\n        $this->client = $client ?? new Client($config);\n    }\n\n    public function request(string $uri, string $method, array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $headers,\n        ];\n        $this->requestHeader = $headers;\n\n        $options = [\n            'headers' => $headers,\n        ];\n\n        if ($method === 'GET') {\n            $options['query'] = $parameters;\n        } else {\n            if ($multipart) {\n                $options['multipart'] = $parameters;\n            } else {\n                $options['json'] = $parameters;\n            }\n        }\n\n\n        try {\n            $response = $this->client->request($method, $uri, $options);\n            $this->responseBody = $response->getBody()->getContents();\n            $this->responseHeader = $response->getHeaders();\n            $this->responseHttpCode = $response->getStatusCode();\n        } catch (RequestException $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($e->hasResponse()) {\n                $this->responseBody = $e->getResponse()->getBody()->getContents();\n                $this->responseHeader = $e->getResponse()->getHeaders();\n                $this->responseHttpCode = $e->getResponse()->getStatusCode();\n            }\n\n            if ($this->logger) {\n                $this->logger->error($e->getMessage(), ['exception' => $e]);\n            }\n        } catch (\\Exception $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($this->logger) {\n                $this->logger->error($e->getMessage(), ['exception' => $e]);\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n    public function getResponse(): array\n    {\n        return [\n            'request' => $this->requestArguments,\n            'header' => $this->responseHeader,\n            'body' => $this->responseBody,\n            'http_code' => $this->responseHttpCode,\n            'client_error' => $this->responseClientError,\n            'client_info' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Log\\LoggerInterface;\n\nclass Guzzle\n{\n    private array $requestArguments = [];\n    private array $requestHeader = [];\n    private string $responseBody = '';\n    private array $responseHeader = [];\n    private int $responseHttpCode = 0;\n    private ?string $responseClientError = null;\n    private array $responseClientInfo = [];\n    private ?LoggerInterface $logger = null;\n    private Client $client;\n\n    public function __construct(?Client $client = null, array $config = [])\n    {\n        $this->client = $client ?? new Client($config);\n    }\n\n    public function request(string $uri, string $method, array $parameters = [], array $headers = [], bool $multipart = false): string\n    {\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $headers,\n        ];\n        $this->requestHeader = $headers;\n\n        $options = [\n            'headers' => $headers,\n        ];\n\n        if ($method === 'GET') {\n            $options['query'] = $parameters;\n        } else {\n            if ($multipart) {\n                $options['multipart'] = $parameters;\n            } else {\n                $options['json'] = $parameters;\n            }\n        }\n\n\n        try {\n            $response = $this->client->request($method, $uri, $options);\n            $this->responseBody = $response->getBody()->getContents();\n            $this->responseHeader = $response->getHeaders();\n            $this->responseHttpCode = $response->getStatusCode();\n        } catch (RequestException $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($e->hasResponse()) {\n                $this->responseBody = $e->getResponse()->getBody()->getContents();\n                $this->responseHeader = $e->getResponse()->getHeaders();\n                $this->responseHttpCode = $e->getResponse()->getStatusCode();\n            }\n\n            if ($this->logger) {\n                $this->logger->error($e->getMessage(), ['exception' => $e]);\n            }\n        } catch (\\Exception $e) {\n            $this->responseClientError = $e->getMessage();\n            if ($this->logger) {\n                $this->logger->error($e->getMessage(), ['exception' => $e]);\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n\n    public function getResponse(): array\n    {\n        return [\n            'request' => $this->requestArguments,\n            'response' => [\n                'header' => $this->responseHeader,\n                'body' => $this->responseBody,\n                'http_code' => $this->responseHttpCode,\n                'client_error' => $this->responseClientError,\n                'client_info' => $this->responseClientInfo,\n            ],\n        ];\n    }\n\n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody(): string\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader(): array\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode(): int\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError(): ?string\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo(): array\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments(): array\n    {\n        return $this->requestArguments;\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Create a PHP function that makes an HTTP request using cURL with specific configurations for timeout, headers, SSL verification, and referer settings.\n\nFunction Description: The function performs an HTTP GET request to a specified URL using PHP's cURL library. It includes custom configurations such as a user agent string, disabled SSL verification, a referer header, and a connection timeout. The function returns the raw response content from the requested URL.\n\nInput: \n- $url (string): The target URL to which the HTTP request will be made.\n\nOutput: \n- string: The raw content returned from the HTTP request. Returns false if the request fails.",
    "Canonical_solution": "function curl($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5000);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, array(\n        'User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4'\n    ));\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REDIR_PROTOCOLS, -1);\n    curl_setopt($ch, CURLOPT_REFERER, 'http://www.cctv.com/');\n    $contents = curl_exec($ch);\n    curl_close($ch);\n    return $contents;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction custom_http_request(string $url): string|false {\n    $ch = curl_init($url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_REFERER => 'https://www.example.com',\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_TIMEOUT => 30,\n    ]);\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction custom_http_request(string $url): string|false {\n    $ch = curl_init($url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_REFERER => 'https://www.example.com',\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_TIMEOUT => 30,\n    ]);\n    $response = curl_exec($ch);\n    if ($response === false) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com');\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com');\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction custom_http_request(string $url): string|false {\n    $ch = curl_init($url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_REFERER => 'https://www.example.com',\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_TIMEOUT => 30,\n    ]);\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction custom_http_request(string $url): string|false {\n    $ch = curl_init($url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_REFERER => 'https://www.example.com',\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction make_http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.example.com');\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction custom_http_request(string $url): string|false {\n    $ch = curl_init($url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_REFERER => 'https://www.example.com',\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_TIMEOUT => 30, \n    ]);\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction http_request($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://www.google.com');\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    $response = curl_exec($ch);\n    if(curl_errno($ch)){\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction custom_http_request(string $url): string|false {\n    $ch = curl_init($url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_REFERER => 'https://www.example.com',\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Implement functions to verify transactions from different payment gateways (NowPayments, NextPay, and ZarinPal) using their respective APIs.\n\nFunction Description: The functions will interact with payment gateway APIs to verify transaction details and return the verification results.\n\nInput: \n- verify_nowpayment_transaction: \n  - $paymentKeys (array): Contains API keys for different payment gateways\n  - $hash_id (string): Unique transaction identifier from NowPayments\n\n- verify_nextpay_transaction:\n  - $paymentKeys (array): Contains API keys for different payment gateways\n  - $amount (numeric): Transaction amount to verify\n  - $payid (string): Transaction ID from NextPay\n\n- verify_zarinpal_transaction:\n  - $paymentKeys (array): Contains API keys for different payment gateways\n  - $Authority (string): Transaction authority code from ZarinPal\n  - $amount (numeric): Transaction amount to verify\n\nOutput:\n- All functions return the decoded API response from the respective payment gateway, typically containing transaction verification details and status.\n- Return type is object/mixed (decoded JSON response for NowPayments/NextPay, SOAP response object for ZarinPal)",
    "Canonical_solution": "function verify_nowpayment_transaction($paymentKeys, $hash_id) {\n    $base_url = 'https://api.nowpayments.io/v1/payment/' . $hash_id;\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, ['X-API-KEY: ' . $paymentKeys['nowpayment']]);\n    curl_setopt($ch, CURLOPT_URL, $base_url);\n    \n    $res = json_decode(curl_exec($ch));\n    curl_close($ch);\n    \n    return $res;\n}\n\nfunction verify_nextpay_transaction($paymentKeys, $amount, $payid) {\n    $curl = curl_init();\n    curl_setopt_array($curl, array(\n        CURLOPT_URL => 'https://nextpay.org/nx/gateway/verify',\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_ENCODING => '',\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 0,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n        CURLOPT_CUSTOMREQUEST => 'POST',\n        CURLOPT_POSTFIELDS => 'api_key='.$paymentKeys['nextpay'].'&amount='.$amount.'&currency=IRT&trans_id='.$payid,\n    ));\n    \n    $response = curl_exec($curl);\n    curl_close($curl);\n    \n    return json_decode($response);\n}\n\nfunction verify_zarinpal_transaction($paymentKeys, $Authority, $amount) {\n    $client = new SoapClient('https://www.zarinpal.com/pg/services/WebGate/wsdl', ['encoding' => 'UTF-8']);\n    $result = $client->PaymentVerification([\n        'MerchantID' => $paymentKeys['zarinpal'],\n        'Authority' => $Authority,\n        'Amount' => $amount,\n    ]);\n    \n    return $result;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nfunction verify_nowpayment_transaction($paymentKeys, $hash_id) {\n    $url = 'https://api.nowpayments.io/v1/payment/' . $hash_id;\n    $headers = array(\n        'x-api-key: ' . $paymentKeys['nowpayments']['api_key']\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_nextpay_transaction($paymentKeys, $amount, $payid) {\n    $url = 'https://nextpay.org/nx/gateway/verify';\n    $data = array(\n        'api_key' => $paymentKeys['nextpay']['api_key'],\n        'amount' => $amount,\n        'trans_id' => $payid\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_zarinpal_transaction($paymentKeys, $Authority, $amount) {\n    $client = new SoapClient('https://www.zarinpal.com/pg/services/WebGate/wsdl', array('encoding' => 'UTF-8'));\n    $result = $client->PaymentVerification(\n        array(\n            'MerchantID' => $paymentKeys['zarinpal']['merchant_id'],\n            'Authority' => $Authority,\n            'Amount' => $amount,\n        )\n    );\n    return $result;\n}\n\n?>\n",
      "<?php\n\nfunction verify_nowpayment_transaction($paymentKeys, $hash_id) {\n    $url = 'https://api.nowpayments.io/v1/payment/' . $hash_id;\n    $headers = array(\n        'x-api-key: ' . $paymentKeys['nowpayments']['api_key']\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_nextpay_transaction($paymentKeys, $amount, $payid) {\n    $url = 'https://nextpay.org/nx/gateway/verify';\n    $data = array(\n        'api_key' => $paymentKeys['nextpay']['api_key'],\n        'amount' => $amount,\n        'trans_id' => $payid\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\n\nfunction verify_zarinpal_transaction($paymentKeys, $Authority, $amount) {\n    $client = new SoapClient('https://www.zarinpal.com/pg/services/WebGate/wsdl', array('encoding' => 'UTF-8'));\n    $result = $client->PaymentVerification(\n        array(\n            'MerchantID' => $paymentKeys['zarinpal']['merchant_id'],\n            'Authority' => $Authority,\n            'Amount' => $amount,\n        )\n    );\n    return $result;\n}\n\n?>\n",
      "<?php\n\nfunction verify_nowpayment_transaction($paymentKeys, $hash_id) {\n    $url = 'https://api.nowpayments.io/v1/payment/' . $hash_id;\n    $headers = array(\n        'x-api-key: ' . $paymentKeys['nowpayments']['api_key']\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_nextpay_transaction($paymentKeys, $amount, $payid) {\n    $url = 'https://nextpay.org/nx/gateway/verify';\n    $data = array(\n        'api_key' => $paymentKeys['nextpay']['api_key'],\n        'amount' => $amount,\n        'trans_id' => $payid\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_zarinpal_transaction($paymentKeys, $Authority, $amount) {\n    $client = new SoapClient('https://www.zarinpal.com/pg/services/WebGate/wsdl', array('encoding' => 'UTF-8'));\n    $result = $client->PaymentVerification(\n        array(\n            'MerchantID' => $paymentKeys['zarinpal']['merchant_id'],\n            'Authority' => $Authority,\n            'Amount' => $amount,\n        )\n    );\n    return $result;\n}\n\n?>\n",
      "<?php\n\nfunction verify_nowpayment_transaction($paymentKeys, $hash_id) {\n    $url = 'https://api.nowpayments.io/v1/payment/' . $hash_id;\n    $headers = array(\n        'x-api-key: ' . $paymentKeys['nowpayments']['api_key']\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_nextpay_transaction($paymentKeys, $amount, $payid) {\n    $url = 'https://nextpay.org/nx/gateway/verify';\n    $data = array(\n        'api_key' => $paymentKeys['nextpay']['api_key'],\n        'amount' => $amount,\n        'trans_id' => $payid\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_zarinpal_transaction($paymentKeys, $Authority, $amount) {\n    $client = new SoapClient('https://www.zarinpal.com/pg/services/WebGate/wsdl', ['encoding' => 'UTF-8']);\n    $result = $client->PaymentVerification(\n        [\n            'MerchantID' => $paymentKeys['zarinpal']['merchant_id'],\n            'Authority' => $Authority,\n            'Amount' => $amount,\n        ]\n    );\n    return $result;\n}\n\n?>\n",
      "<?php\n\nfunction verify_nowpayment_transaction($paymentKeys, $hash_id) {\n    $url = 'https://api.nowpayments.io/v1/payment/' . $hash_id;\n    $headers = array(\n        'x-api-key: ' . $paymentKeys['nowpayments']['api_key']\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_nextpay_transaction($paymentKeys, $amount, $payid) {\n    $url = 'https://nextpay.org/nx/gateway/verify';\n    $data = array(\n        'api_key' => $paymentKeys['nextpay']['api_key'],\n        'amount' => $amount,\n        'trans_id' => $payid\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_zarinpal_transaction($paymentKeys, $Authority, $amount) {\n    $client = new SoapClient('https://www.zarinpal.com/pg/services/WebGate/wsdl', array('encoding' => 'UTF-8'));\n    $result = $client->PaymentVerification(\n        array(\n            'MerchantID' => $paymentKeys['zarinpal']['merchant_id'],\n            'Authority' => $Authority,\n            'Amount' => $amount,\n        )\n    );\n    return $result;\n}\n\n?>\n",
      "<?php\n\nfunction verify_nowpayment_transaction($paymentKeys, $hash_id) {\n    $url = 'https://api.nowpayments.io/v1/payment/' . $hash_id;\n    $headers = [\n        'x-api-key: ' . $paymentKeys['nowpayments']['api_key'],\n        'Content-Type: application/json'\n    ];\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_nextpay_transaction($paymentKeys, $amount, $payid) {\n    $url = 'https://nextpay.org/nx/gateway/verify';\n    $data = [\n        'api_key' => $paymentKeys['nextpay']['api_key'],\n        'amount' => $amount,\n        'trans_id' => $payid\n    ];\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_zarinpal_transaction($paymentKeys, $Authority, $amount) {\n    $client = new SoapClient('https://www.zarinpal.com/pg/services/WebGate/wsdl', ['encoding' => 'UTF-8']);\n    $result = $client->PaymentVerification(\n        [\n            'MerchantID' => $paymentKeys['zarinpal']['merchant_id'],\n            'Authority' => $Authority,\n            'Amount' => $amount,\n        ]\n    );\n    return $result;\n}\n\n?>\n",
      "<?php\n\nfunction verify_nowpayment_transaction($paymentKeys, $hash_id) {\n    $url = 'https://api.nowpayments.io/v1/payment/' . $hash_id;\n    $headers = array(\n        'x-api-key: ' . $paymentKeys['nowpayments']['api_key']\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_nextpay_transaction($paymentKeys, $amount, $payid) {\n    $url = 'https://nextpay.org/nx/gateway/verify';\n    $data = array(\n        'api_key' => $paymentKeys['nextpay']['api_key'],\n        'amount' => $amount,\n        'trans_id' => $payid\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\n\nfunction verify_zarinpal_transaction($paymentKeys, $Authority, $amount) {\n    $client = new SoapClient('https://www.zarinpal.com/pg/services/WebGate/wsdl', ['encoding' => 'UTF-8']);\n    $result = $client->PaymentVerification(\n        [\n            'MerchantID' => $paymentKeys['zarinpal']['merchant_id'],\n            'Authority' => $Authority,\n            'Amount' => $amount,\n        ]\n    );\n    return $result;\n}\n\n?>\n",
      "<?php\n\nfunction verify_nowpayment_transaction($paymentKeys, $hash_id) {\n    $url = 'https://api.nowpayments.io/v1/payment/' . $hash_id;\n    $headers = array(\n        'x-api-key: ' . $paymentKeys['nowpayments']['api_key']\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_nextpay_transaction($paymentKeys, $amount, $payid) {\n    $url = 'https://nextpay.org/nx/gateway/verify';\n    $data = array(\n        'api_key' => $paymentKeys['nextpay']['api_key'],\n        'amount' => $amount,\n        'trans_id' => $payid\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_zarinpal_transaction($paymentKeys, $Authority, $amount) {\n    $client = new SoapClient('https://www.zarinpal.com/pg/services/WebGate/wsdl', array('encoding' => 'UTF-8'));\n    $result = $client->PaymentVerification(\n        array(\n            'MerchantID' => $paymentKeys['zarinpal']['merchant_id'],\n            'Authority' => $Authority,\n            'Amount' => $amount,\n        )\n    );\n    return $result;\n}\n\n?>\n",
      "<?php\n\nfunction verify_nowpayment_transaction($paymentKeys, $hash_id) {\n    $url = 'https://api.nowpayments.io/v1/payment/' . $hash_id;\n    $headers = array(\n        'x-api-key: ' . $paymentKeys['nowpayments']['api_key']\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_nextpay_transaction($paymentKeys, $amount, $payid) {\n    $url = 'https://nextpay.org/nx/gateway/verify';\n    $data = array(\n        'api_key' => $paymentKeys['nextpay']['api_key'],\n        'amount' => $amount,\n        'trans_id' => $payid\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_zarinpal_transaction($paymentKeys, $Authority, $amount) {\n    $client = new SoapClient('https://www.zarinpal.com/pg/services/WebGate/wsdl', array('encoding' => 'UTF-8'));\n    $result = $client->PaymentVerification(\n        array(\n            'MerchantID' => $paymentKeys['zarinpal']['merchant_id'],\n            'Authority' => $Authority,\n            'Amount' => $amount,\n        )\n    );\n    return $result;\n}\n\n?>\n",
      "<?php\n\nfunction verify_nowpayment_transaction($paymentKeys, $hash_id) {\n    $url = 'https://api.nowpayments.io/v1/payment/' . $hash_id;\n    $headers = array(\n        'x-api-key: ' . $paymentKeys['nowpayments']['api_key']\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\nfunction verify_nextpay_transaction($paymentKeys, $amount, $payid) {\n    $url = 'https://nextpay.org/nx/gateway/verify';\n    $data = array(\n        'api_key' => $paymentKeys['nextpay']['api_key'],\n        'amount' => $amount,\n        'trans_id' => $payid\n    );\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return json_decode($response);\n}\n\n\nfunction verify_zarinpal_transaction($paymentKeys, $Authority, $amount) {\n    $client = new SoapClient('https://www.zarinpal.com/pg/services/WebGate/wsdl', array('encoding' => 'UTF-8'));\n    $result = $client->PaymentVerification(\n        array(\n            'MerchantID' => $paymentKeys['zarinpal']['merchant_id'],\n            'Authority' => $Authority,\n            'Amount' => $amount,\n        )\n    );\n    return $result;\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 52,
    "Instruction": "Task Description: Create a PHP class for interacting with the GoDaddy DNS API to manage domain records, including retrieving domains, getting DNS records, and creating/updating records.\n\nClass Description: The GodaddyDns class provides methods to interact with GoDaddy's DNS API. It handles authentication, domain parsing, and various DNS record operations through HTTP requests using cURL.\n\nAttributes:\n- accessKeyId: [string] - The API access key ID for GoDaddy authentication\n- accessSecrec: [string] - The API secret key for GoDaddy authentication\n- DomainName: [string] - The domain name being managed\n- Host: [string] - The host portion of the domain (default empty)\n- Path: [string] - The path portion of the domain (default empty)\n\nMethods:\n- __construct([string]$accessKeyId, [string]$accessSecrec, [string]$domain = \"\") -> [void] - Initializes the class with API credentials and optional domain name\n- getDomain([string]$domain) -> [array] - Static method that parses a domain into its components (self domain, second-level domain)\n- curl([string]$url, [array]$header = '', [string]$data = '', [string]$method = 'get') -> [array] - Private method that handles cURL requests and returns response\n- getDomains() -> [array] - Retrieves all domains associated with the account\n- GetDNSRecord([string]$domain, [string]$record, [string]$recordType = 'TXT') -> [array] - Gets a specific DNS record for a domain\n- UpdateDNSRecord([string]$domain, [string]$name, [string]$value, [string]$recordType = 'TXT') -> [array] - Updates an existing DNS record\n- CreateDNSRecord([string]$domain, [string]$name, [string]$value, [string]$recordType = 'TXT') -> [array] - Creates a new DNS record",
    "Canonical_solution": "$domainfile = $dir . DIRECTORY_SEPARATOR . \"domain.ini\";\n\nclass GodaddyDns\n{\n    private $accessKeyId  = null;\n    private $accessSecrec = null;\n    private $DomainName   = null;\n    private $Host         = \"\";\n    private $Path         = \"\";\n\n    public function __construct($accessKeyId, $accessSecrec, $domain = \"\")\n    {\n        $this->accessKeyId  = $accessKeyId;\n        $this->accessSecrec = $accessSecrec;\n        $this->DomainName   = $domain;\n    }\n\n    public static function getDomain($domain)\n    {\n        global $domainfile;\n        $tmp = file($domainfile);\n        $arr = array();\n        foreach ($tmp as $k=>$v) {\n            $v = trim($v);\n            if ($v!=\"\")\n                $arr[]= \".\" . $v;\n        }\n\n        $seconddomain = \"\";\n        $selfdomain   = \"\";\n        $rootdomain   = \"\";\n        foreach ($arr as $k => $v) {\n            $pos = stripos($domain, $v);\n            if ($pos) {\n                $rootdomain   = substr($domain, $pos);\n                $s            = explode(\".\", substr($domain, 0, $pos));\n                $seconddomain = $s[count($s) - 1].$rootdomain;\n                for ($i = 0; $i < count($s) - 1; $i++)\n                    $selfdomain .= $s[$i] . \".\";\n                $selfdomain = substr($selfdomain,0,strlen($selfdomain)-1);\n                break;\n            }\n        }\n        if ($rootdomain == \"\") {\n            $seconddomain = $domain;\n            $selfdomain   = \"\";\n        }\n        return array($selfdomain, $seconddomain);\n    }\n\n    private function curl($url, $header = '', $data = '', $method = 'get')\n    {\n        $ch       = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        $result   = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        return array(\n            'result' => $result,\n            'httpCode' => $httpCode\n        );\n    }\n\n    public function getDomains()\n    {\n        $url    = \"https://api.godaddy.com/v1/domains\";\n        $header = ['accept: application/json', 'authorization:sso-key '.$this->accessKeyId.':'.$this->accessSecrec];\n        return $this->curl($url, $header);\n    }\n\n    public function GetDNSRecord($domain, $record, $recordType = 'TXT')\n    {\n        $url    = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType/$record\";\n        $header = ['accept: application/json', 'authorization:sso-key '.$this->accessKeyId.':'.$this->accessSecrec];\n        return $this->curl($url, $header);\n    }\n\n    public function UpdateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $url    = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType/$name\";\n        $header = ['accept: application/json', 'Content-Type: application/json',\n            'authorization:sso-key '.$this->accessKeyId.':'.$this->accessSecrec];\n        $data   = array(\n            array(\n                'data' => $value,\n                'name' => $name,\n                'ttl' => 3600,\n                'type' => $recordType)\n        );\n        return $this->curl($url, $header, json_encode($data), 'put');\n    }\n\n    public function CreateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $url    = \"https://api.godaddy.com/v1/domains/$domain/records\";\n        $header = ['accept: application/json', 'Content-Type: application/json',\n            'authorization:sso-key '.$this->accessKeyId.':'.$this->accessSecrec];\n        $data   = array(\n            array(\n                'data' => $value,\n                'name' => $name,\n                'ttl' => 3600,\n                'type' => $recordType)\n        );\n        return $this->curl($url, $header, json_encode($data), 'PATCH');\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass GodaddyDns\n{\n    private $accessKeyId;\n    private $accessSecrec;\n    private $DomainName;\n    private $Host = '';\n    private $Path = '';\n\n    public function __construct($accessKeyId, $accessSecrec, $domain = \"\")\n    {\n        $this->accessKeyId = $accessKeyId;\n        $this->accessSecrec = $accessSecrec;\n        if ($domain) {\n            $this->DomainName = $domain;\n        }\n    }\n\n    public static function getDomain($domain)\n    {\n        $domainParts = explode('.', $domain);\n        $sld = $domainParts[count($domainParts) - 2];\n        $tld = $domainParts[count($domainParts) - 1];\n        $selfDomain = $sld . '.' . $tld;\n        return ['selfDomain' => $selfDomain, 'sld' => $sld, 'tld' => $tld];\n    }\n\n    private function curl($url, $header = '', $data = '', $method = 'get')\n    {\n        $ch = curl_init();\n        $header = array_merge(['Authorization: sso-key ' . $this->accessKeyId . ':' . $this->accessSecrec], $header);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n\n        if ($method == 'post') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'put') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'delete') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n        }\n\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return ['code' => $httpCode, 'data' => json_decode($output, true)];\n    }\n\n    public function getDomains()\n    {\n        $url = 'https://api.godaddy.com/v1/domains';\n        return $this->curl($url);\n    }\n\n\n    public function GetDNSRecord($domain, $record, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records/{$recordType}/{$record}\";\n        return $this->curl($url);\n    }\n\n    public function UpdateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records/{$recordType}/{$name}\";\n        $data = json_encode([['data' => $value, 'ttl' => 3600, 'name' => $name, 'type' => $recordType]]);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'put');\n    }\n\n    public function CreateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records\";\n        $data = json_encode([['data' => $value, 'ttl' => 3600, 'name' => $name, 'type' => $recordType]]);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'patch');\n    }\n}\n\n?>\n",
      "<?php\nclass GodaddyDns\n{\n    private $accessKeyId;\n    private $accessSecrec;\n    private $DomainName;\n    private $Host = '';\n    private $Path = '';\n\n    public function __construct($accessKeyId, $accessSecrec, $domain = \"\")\n    {\n        $this->accessKeyId = $accessKeyId;\n        $this->accessSecrec = $accessSecrec;\n        if ($domain) {\n            $this->DomainName = $domain;\n        }\n    }\n\n    public static function getDomain($domain)\n    {\n        $domainParts = explode('.', $domain);\n        $sld = $domainParts[count($domainParts) - 2];\n        $tld = $domainParts[count($domainParts) - 1];\n        $selfDomain = $sld . '.' . $tld;\n        return ['selfDomain' => $selfDomain, 'sld' => $sld, 'tld' => $tld];\n    }\n\n    private function curl($url, $header = '', $data = '', $method = 'get')\n    {\n        $ch = curl_init();\n        $header = array_merge(['Authorization: sso-key ' . $this->accessKeyId . ':' . $this->accessSecrec], $header);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n\n        if ($method == 'post') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'put') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'delete') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n        }\n\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n        return ['code' => $httpCode, 'data' => json_decode($output, true)];\n    }\n\n    public function getDomains()\n    {\n        $url = 'https://api.godaddy.com/v1/domains';\n        return $this->curl($url);\n    }\n\n\n    public function GetDNSRecord($domain, $record, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records/{$recordType}/{$record}\";\n        return $this->curl($url);\n    }\n\n    public function UpdateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records/{$recordType}/{$name}\";\n        $data = json_encode([['data' => $value, 'ttl' => 3600, 'name' => $name, 'type' => $recordType]]);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'put');\n    }\n\n    public function CreateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records/{$recordType}\";\n        $data = json_encode([['data' => $value, 'ttl' => 3600, 'name' => $name, 'type' => $recordType]]);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'post');\n    }\n}\n\n?>\n",
      "<?php\nclass GodaddyDns\n{\n    private $accessKeyId;\n    private $accessSecrec;\n    private $DomainName;\n    private $Host = '';\n    private $Path = '';\n\n    public function __construct($accessKeyId, $accessSecrec, $domain = \"\")\n    {\n        $this->accessKeyId = $accessKeyId;\n        $this->accessSecrec = $accessSecrec;\n        if ($domain) {\n            $this->DomainName = $domain;\n        }\n    }\n\n    public static function getDomain($domain)\n    {\n        $domainParts = explode('.', $domain);\n        $sld = $domainParts[count($domainParts) - 2];\n        $tld = $domainParts[count($domainParts) - 1];\n        $selfDomain = $sld . '.' . $tld;\n        return ['selfDomain' => $selfDomain, 'sld' => $sld, 'tld' => $tld];\n    }\n\n    private function curl($url, $header = '', $data = '', $method = 'get')\n    {\n        $ch = curl_init();\n        $header = array_merge(['Authorization: sso-key ' . $this->accessKeyId . ':' . $this->accessSecrec], $header);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n\n        if ($method == 'post') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'put') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'delete') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n        }\n\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        return ['code' => $httpCode, 'data' => json_decode($output, true)];\n    }\n\n    public function getDomains()\n    {\n        $url = 'https://api.godaddy.com/v1/domains';\n        return $this->curl($url);\n    }\n\n\n    public function GetDNSRecord($domain, $record, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records/{$recordType}/{$record}\";\n        return $this->curl($url);\n    }\n\n    public function UpdateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records/{$recordType}/{$name}\";\n        $data = json_encode([['data' => $value, 'ttl' => 3600]]);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'put');\n    }\n\n    public function CreateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records\";\n        $data = json_encode([['type' => $recordType, 'name' => $name, 'data' => $value, 'ttl' => 3600]]);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'patch');\n    }\n}\n\n?>\n",
      "<?php\nclass GodaddyDns\n{\n    private $accessKeyId;\n    private $accessSecrec;\n    private $DomainName;\n    private $Host = '';\n    private $Path = '';\n\n    public function __construct($accessKeyId, $accessSecrec, $domain = \"\")\n    {\n        $this->accessKeyId = $accessKeyId;\n        $this->accessSecrec = $accessSecrec;\n        if ($domain) {\n            $this->DomainName = $domain;\n        }\n    }\n\n    public static function getDomain($domain)\n    {\n        $domainParts = explode('.', $domain);\n        $sld = $domainParts[count($domainParts) - 2];\n        $tld = $domainParts[count($domainParts) - 1];\n        $selfDomain = $sld . '.' . $tld;\n        return ['selfDomain' => $selfDomain, 'sld' => $sld, 'tld' => $tld];\n    }\n\n\n    private function curl($url, $header = '', $data = '', $method = 'get')\n    {\n        $ch = curl_init();\n        $header = array_merge($header, ['Authorization: sso-key ' . $this->accessKeyId . ':' . $this->accessSecrec]);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n        if (strtolower($method) == 'post') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif (strtolower($method) == 'put') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif (strtolower($method) == 'delete') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n        }\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        return ['code' => $httpCode, 'data' => json_decode($output, true)];\n    }\n\n    public function getDomains()\n    {\n        $url = \"https://api.godaddy.com/v1/domains\";\n        return $this->curl($url);\n    }\n\n    public function GetDNSRecord($domain, $record, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType/$record\";\n        return $this->curl($url);\n    }\n\n    public function UpdateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType/$name\";\n        $data = [['data' => $value, 'ttl' => 3600]];\n        $data = json_encode($data);\n        $header = ['Content-Type: application/json'];\n        return $this->curl($url, $header, $data, 'put');\n    }\n\n    public function CreateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType\";\n        $data = [['name' => $name, 'data' => $value, 'ttl' => 3600]];\n        $data = json_encode($data);\n        $header = ['Content-Type: application/json'];\n        return $this->curl($url, $header, $data, 'patch');\n    }\n}\n\n",
      "<?php\nclass GodaddyDns\n{\n    private $accessKeyId;\n    private $accessSecrec;\n    private $DomainName;\n    private $Host = '';\n    private $Path = '';\n\n    public function __construct($accessKeyId, $accessSecrec, $domain = \"\")\n    {\n        $this->accessKeyId = $accessKeyId;\n        $this->accessSecrec = $accessSecrec;\n        if ($domain) {\n            $this->DomainName = $domain;\n        }\n    }\n\n    public static function getDomain($domain)\n    {\n        $domainParts = explode('.', $domain);\n        $sld = $domainParts[count($domainParts) - 2];\n        $tld = $domainParts[count($domainParts) - 1];\n        $selfDomain = $sld . '.' . $tld;\n        return ['selfDomain' => $selfDomain, 'sld' => $sld, 'tld' => $tld];\n    }\n\n    private function curl($url, $header = '', $data = '', $method = 'get')\n    {\n        $ch = curl_init();\n        $header = array_merge(['Authorization: sso-key ' . $this->accessKeyId . ':' . $this->accessSecrec], $header);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n\n        if ($method == 'post') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'put') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'delete') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n        }\n\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n        return ['code' => $httpCode, 'data' => json_decode($output, true)];\n    }\n\n    public function getDomains()\n    {\n        $url = 'https://api.godaddy.com/v1/domains';\n        return $this->curl($url);\n    }\n\n\n    public function GetDNSRecord($domain, $record, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records/{$recordType}/{$record}\";\n        return $this->curl($url);\n    }\n\n    public function UpdateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records/{$recordType}/{$name}\";\n        $data = json_encode([['data' => $value, 'ttl' => 3600]]);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'put');\n    }\n\n    public function CreateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/{$domainInfo['selfDomain']}/records\";\n        $data = json_encode([['type' => $recordType, 'name' => $name, 'data' => $value, 'ttl' => 3600]]);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'patch');\n    }\n}\n\n?>\n",
      "<?php\nclass GodaddyDns\n{\n    private $accessKeyId;\n    private $accessSecrec;\n    private $DomainName;\n    private $Host = '';\n    private $Path = '';\n\n    public function __construct($accessKeyId, $accessSecrec, $domain = \"\")\n    {\n        $this->accessKeyId = $accessKeyId;\n        $this->accessSecrec = $accessSecrec;\n        if ($domain) {\n            $this->DomainName = $domain;\n        }\n    }\n\n    public static function getDomain($domain)\n    {\n        $domainParts = explode('.', $domain);\n        $sld = $domainParts[count($domainParts) - 2];\n        $tld = $domainParts[count($domainParts) - 1];\n        $selfDomain = $sld . '.' . $tld;\n        return ['selfDomain' => $selfDomain, 'sld' => $sld, 'tld' => $tld];\n    }\n\n    private function curl($url, $header = '', $data = '', $method = 'get')\n    {\n        $ch = curl_init();\n        $header = array_merge(['Authorization: sso-key ' . $this->accessKeyId . ':' . $this->accessSecrec], $header);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n\n        if ($method == 'post') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'put') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'delete') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n        }\n\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        return ['code' => $httpCode, 'data' => json_decode($output, true)];\n    }\n\n    public function getDomains()\n    {\n        $url = 'https://api.godaddy.com/v1/domains';\n        return $this->curl($url);\n    }\n\n\n    public function GetDNSRecord($domain, $record, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType/$record\";\n        return $this->curl($url);\n    }\n\n    public function UpdateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType/$name\";\n        $data = json_encode([['data' => $value, 'ttl' => 3600]]);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'put');\n    }\n\n    public function CreateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType\";\n        $data = json_encode([['name' => $name, 'data' => $value, 'ttl' => 3600]]);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'post');\n    }\n}\n\n?>\n",
      "<?php\nclass GodaddyDns\n{\n    private $accessKeyId;\n    private $accessSecrec;\n    private $DomainName;\n    private $Host = '';\n    private $Path = '';\n\n    public function __construct($accessKeyId, $accessSecrec, $domain = \"\")\n    {\n        $this->accessKeyId = $accessKeyId;\n        $this->accessSecrec = $accessSecrec;\n        if ($domain) {\n            $this->DomainName = $domain;\n        }\n    }\n\n    public static function getDomain($domain)\n    {\n        $domainParts = explode('.', $domain);\n        $sld = $domainParts[count($domainParts) - 2];\n        $tld = $domainParts[count($domainParts) - 1];\n        $selfDomain = \"$sld.$tld\";\n        return ['selfDomain' => $selfDomain, 'sld' => $sld, 'tld' => $tld];\n    }\n\n\n    private function curl($url, $header = '', $data = '', $method = 'get')\n    {\n        $ch = curl_init();\n        $header = array_merge($header, ['Authorization: sso-key ' . $this->accessKeyId . ':' . $this->accessSecrec]);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n        if (strtolower($method) == 'post') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif (strtolower($method) == 'put') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif (strtolower($method) == 'delete') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n        }\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        return ['code' => $httpCode, 'data' => json_decode($output, true)];\n    }\n\n    public function getDomains()\n    {\n        $url = \"https://api.godaddy.com/v1/domains\";\n        return $this->curl($url);\n    }\n\n    public function GetDNSRecord($domain, $record, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/\" . $domainInfo['selfDomain'] . \"/records/$recordType/$record\";\n        return $this->curl($url);\n    }\n\n\n    public function UpdateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/\" . $domainInfo['selfDomain'] . \"/records/$recordType/$name\";\n        $data = [['data' => $value, 'ttl' => 3600]];\n        $data = json_encode($data);\n        $header = ['Content-Type: application/json'];\n        return $this->curl($url, $header, $data, 'PUT');\n    }\n\n    public function CreateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/\" . $domainInfo['selfDomain'] . \"/records/$recordType/$name\";\n        $data = [['data' => $value, 'ttl' => 3600]];\n        $data = json_encode($data);\n        $header = ['Content-Type: application/json'];\n        return $this->curl($url, $header, $data, 'PUT');\n    }\n}\n\n",
      "<?php\nclass GodaddyDns\n{\n    private $accessKeyId;\n    private $accessSecrec;\n    private $DomainName;\n    private $Host = '';\n    private $Path = '';\n\n    public function __construct($accessKeyId, $accessSecrec, $domain = \"\")\n    {\n        $this->accessKeyId = $accessKeyId;\n        $this->accessSecrec = $accessSecrec;\n        if ($domain) {\n            $this->DomainName = $domain;\n        }\n    }\n\n    public static function getDomain($domain)\n    {\n        $domainParts = explode('.', $domain);\n        $sld = $domainParts[count($domainParts) - 2];\n        $tld = $domainParts[count($domainParts) - 1];\n        $selfDomain = $sld . '.' . $tld;\n        return ['selfDomain' => $selfDomain, 'sld' => $sld, 'tld' => $tld];\n    }\n\n\n    private function curl($url, $header = '', $data = '', $method = 'get')\n    {\n        $ch = curl_init();\n        $header = array_merge($header, ['Authorization: sso-key ' . $this->accessKeyId . ':' . $this->accessSecrec]);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n\n        if ($method == 'post') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'put') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'delete') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n        }\n\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n        return ['code' => $httpCode, 'data' => json_decode($output, true)];\n    }\n\n    public function getDomains()\n    {\n        $url = \"https://api.godaddy.com/v1/domains\";\n        return $this->curl($url);\n    }\n\n\n    public function GetDNSRecord($domain, $record, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType/$record\";\n        return $this->curl($url);\n    }\n\n    public function UpdateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType/$name\";\n        $data = json_encode([['data' => $value, 'ttl' => 3600]]);\n        return $this->curl($url, [], $data, 'put');\n    }\n\n    public function CreateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType\";\n        $data = json_encode([['name' => $name, 'data' => $value, 'ttl' => 3600]]);\n        return $this->curl($url, [], $data, 'post');\n    }\n}\n\n",
      "<?php\nclass GodaddyDns\n{\n    private $accessKeyId;\n    private $accessSecrec;\n    private $DomainName;\n    private $Host = '';\n    private $Path = '';\n\n    public function __construct($accessKeyId, $accessSecrec, $domain = \"\")\n    {\n        $this->accessKeyId = $accessKeyId;\n        $this->accessSecrec = $accessSecrec;\n        if ($domain) {\n            $this->DomainName = $domain;\n        }\n    }\n\n    public static function getDomain($domain)\n    {\n        $domainParts = explode('.', $domain);\n        $sld = $domainParts[count($domainParts) - 2];\n        $tld = $domainParts[count($domainParts) - 1];\n        $selfDomain = $sld . '.' . $tld;\n        return ['selfDomain' => $selfDomain, 'sld' => $sld, 'tld' => $tld];\n    }\n\n    private function curl($url, $header = '', $data = '', $method = 'get')\n    {\n        $ch = curl_init();\n        $header = array_merge(['Authorization: sso-key ' . $this->accessKeyId . ':' . $this->accessSecrec], $header);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n\n        if ($method == 'post') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'put') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'delete') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n        }\n\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return ['code' => $httpCode, 'data' => json_decode($output, true)];\n    }\n\n    public function getDomains()\n    {\n        $url = 'https://api.godaddy.com/v1/domains';\n        return $this->curl($url);\n    }\n\n\n    public function GetDNSRecord($domain, $record, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType/$record\";\n        return $this->curl($url);\n    }\n\n    public function UpdateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType/$name\";\n        $data = [['data' => $value, 'ttl' => 3600]];\n        $data = json_encode($data);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'put');\n    }\n\n    public function CreateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $url = \"https://api.godaddy.com/v1/domains/$domain/records/$recordType/$name\";\n        $data = [['data' => $value, 'ttl' => 3600]];\n        $data = json_encode($data);\n        return $this->curl($url, ['Content-Type: application/json'], $data, 'post');\n    }\n}\n\n?>\n",
      "<?php\nclass GodaddyDns\n{\n    private $accessKeyId;\n    private $accessSecrec;\n    private $DomainName;\n    private $Host = '';\n    private $Path = '';\n\n    public function __construct($accessKeyId, $accessSecrec, $domain = \"\")\n    {\n        $this->accessKeyId = $accessKeyId;\n        $this->accessSecrec = $accessSecrec;\n        if ($domain) {\n            $this->DomainName = $domain;\n        }\n    }\n\n    public static function getDomain($domain)\n    {\n        $domainParts = explode('.', $domain);\n        $sld = $domainParts[count($domainParts) - 2];\n        $tld = $domainParts[count($domainParts) - 1];\n        $selfDomain = $sld . '.' . $tld;\n        return ['selfDomain' => $selfDomain, 'sld' => $sld, 'tld' => $tld];\n    }\n\n    private function curl($url, $header = '', $data = '', $method = 'get')\n    {\n        $ch = curl_init();\n        $header = array_merge(['Authorization: sso-key ' . $this->accessKeyId . ':' . $this->accessSecrec], $header);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n\n        if ($method == 'post') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'put') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } elseif ($method == 'delete') {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n        }\n\n\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        return ['code' => $httpCode, 'data' => json_decode($output, true)];\n    }\n\n    public function getDomains()\n    {\n        $url = \"https://api.godaddy.com/v1/domains\";\n        return $this->curl($url);\n    }\n\n\n    public function GetDNSRecord($domain, $record, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/\" . $domainInfo['selfDomain'] . \"/records/\" . $recordType . \"/\" . $record;\n        return $this->curl($url);\n    }\n\n    public function UpdateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/\" . $domainInfo['selfDomain'] . \"/records/\" . $recordType . \"/\" . $name;\n        $data = [['data' => $value, 'ttl' => 3600, 'name' => $name, 'type' => $recordType]];\n        $header = ['Content-Type: application/json'];\n\n        return $this->curl($url, $header, json_encode($data), 'put');\n    }\n\n    public function CreateDNSRecord($domain, $name, $value, $recordType = 'TXT')\n    {\n        $domainInfo = self::getDomain($domain);\n        $url = \"https://api.godaddy.com/v1/domains/\" . $domainInfo['selfDomain'] . \"/records\";\n        $data = [['data' => $value, 'ttl' => 3600, 'name' => $name, 'type' => $recordType]];\n        $header = ['Content-Type: application/json'];\n        return $this->curl($url, $header, json_encode($data), 'post');\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a PHP class that handles file downloads using cURL with proper error handling and resource management.\n\nClass Description: The CurlDownloader class provides functionality to download files from a given URL using PHP's cURL library. It manages temporary file creation, download execution, and cleanup of resources. The class includes methods to set a custom temporary directory, perform the download, retrieve the downloaded filename, and clean up downloaded files.\n\nAttributes:\n- tempDir: ?string - Optional custom directory for storing temporary files. If not set, uses system temp directory.\n- outputFile: ?string - Path to the downloaded file. Null until download is completed.\n\nMethods:\n- setTempDir(string $tempDir) -> void - Sets a custom temporary directory for storing downloaded files.\n- download(string $url) -> bool - Downloads a file from the specified URL. Returns true on success, throws ErrorException on failure.\n- getFilename() -> string - Returns the path to the downloaded file. Throws RuntimeException if called before download().\n- cleanup() -> void - Removes the downloaded file if it exists.",
    "Canonical_solution": "use Psy\\Exception\\ErrorException;\nuse Psy\\Exception\\RuntimeException;\nuse Psy\\Shell;\n\nclass CurlDownloader\n{\n    private ?string $tempDir = null;\n    private ?string $outputFile = null;\n\n    public function setTempDir(string $tempDir)\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?: \\sys_get_temp_dir();\n        $this->outputFile = \\tempnam($tempDir, 'psysh-archive-');\n        $targetName = $this->outputFile.'.tar.gz';\n\n        if (!\\rename($this->outputFile, $targetName)) {\n            return false;\n        }\n\n        $this->outputFile = $targetName;\n\n        $outputHandle = \\fopen($this->outputFile, 'w');\n        if (!$outputHandle) {\n            return false;\n        }\n\n        $curl = \\curl_init();\n        \\curl_setopt_array($curl, [\n            \\CURLOPT_FAILONERROR    => true,\n            \\CURLOPT_HEADER         => 0,\n            \\CURLOPT_FOLLOWLOCATION => true,\n            \\CURLOPT_TIMEOUT        => 10,\n            \\CURLOPT_FILE           => $outputHandle,\n            \\CURLOPT_HTTPHEADER     => [\n                'User-Agent' => 'PsySH/'.Shell::VERSION,\n            ],\n        ]);\n        \\curl_setopt($curl, \\CURLOPT_URL, $url);\n        $result = \\curl_exec($curl);\n        $error = \\curl_error($curl);\n        \\curl_close($curl);\n\n        \\fclose($outputHandle);\n\n        if (!$result) {\n            throw new ErrorException('cURL Error: '.$error);\n        }\n\n        return (bool) $result;\n    }\n\n    public function getFilename(): string\n    {\n        if ($this->outputFile === null) {\n            throw new RuntimeException('Call download() first');\n        }\n\n        return $this->outputFile;\n    }\n\n    public function cleanup()\n    {\n        if ($this->outputFile !== null && \\file_exists($this->outputFile)) {\n            \\unlink($this->outputFile);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass CurlDownloader\n{\n    private ?string $tempDir = null;\n    private ?string $outputFile = null;\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?? sys_get_temp_dir();\n        $this->outputFile = tempnam($tempDir, 'download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file: \" . $this->outputFile);\n        }\n\n        $ch = curl_init($url);\n        if (!$ch) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(\"Failed to initialize cURL\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            fclose($fp);\n            unlink($this->outputFile);\n            curl_close($ch);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n        return true;\n    }\n\n    public function getFilename(): string\n    {\n        if ($this->outputFile === null) {\n            throw new RuntimeException(\"Download must be completed before getting filename.\");\n        }\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if ($this->outputFile !== null && file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n            $this->outputFile = null;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private ?string $tempDir = null;\n    private ?string $outputFile = null;\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?? sys_get_temp_dir();\n        $this->outputFile = tempnam($tempDir, 'download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file: \" . $this->outputFile);\n        }\n\n        $ch = curl_init($url);\n        if (!$ch) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(\"Failed to initialize cURL\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            fclose($fp);\n            unlink($this->outputFile);\n            curl_close($ch);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n    public function getFilename(): string\n    {\n        if ($this->outputFile === null) {\n            throw new RuntimeException(\"Download must be performed before getting the filename.\");\n        }\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if ($this->outputFile !== null && file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n            $this->outputFile = null;\n        }\n    }\n}\n",
      "<?php\n\nclass CurlDownloader\n{\n    private ?string $tempDir = null;\n    private ?string $outputFile = null;\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?? sys_get_temp_dir();\n        $this->outputFile = tempnam($tempDir, 'download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file: \" . $this->outputFile);\n        }\n\n        $ch = curl_init($url);\n        if (!$ch) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(\"Failed to initialize cURL\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            fclose($fp);\n            unlink($this->outputFile);\n            curl_close($ch);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n    public function getFilename(): string\n    {\n        if ($this->outputFile === null) {\n            throw new RuntimeException(\"Download must be completed before getting filename.\");\n        }\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if ($this->outputFile !== null && file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n            $this->outputFile = null;\n        }\n    }\n}\n",
      "<?php\n\nclass CurlDownloader\n{\n    private ?string $tempDir = null;\n    private ?string $outputFile = null;\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?? sys_get_temp_dir();\n        $outputFile = tempnam($tempDir, 'download_');\n\n        if ($outputFile === false) {\n            throw new ErrorException(\"Failed to create temporary file.\");\n        }\n\n        $fp = fopen($outputFile, 'w');\n\n        if ($fp === false) {\n            throw new ErrorException(\"Failed to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n\n        if ($ch === false) {\n            fclose($fp);\n            unlink($outputFile);\n            throw new ErrorException(\"Failed to initialize cURL.\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            fclose($fp);\n            unlink($outputFile);\n            curl_close($ch);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n\n        fclose($fp);\n        curl_close($ch);\n\n        $this->outputFile = $outputFile;\n        return true;\n    }\n\n    public function getFilename(): string\n    {\n        if ($this->outputFile === null) {\n            throw new RuntimeException(\"Download must be performed before getting filename.\");\n        }\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if ($this->outputFile !== null && file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n            $this->outputFile = null;\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private ?string $tempDir = null;\n    private ?string $outputFile = null;\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?? sys_get_temp_dir();\n        $this->outputFile = tempnam($tempDir, 'download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file: \" . $this->outputFile);\n        }\n\n        $ch = curl_init($url);\n        if (!$ch) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(\"Failed to initialize cURL\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            fclose($fp);\n            unlink($this->outputFile);\n            curl_close($ch);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        if ($this->outputFile === null) {\n            throw new RuntimeException(\"Download must be completed before getting filename.\");\n        }\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if ($this->outputFile !== null && file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n            $this->outputFile = null;\n        }\n    }\n}\n",
      "<?php\n\nclass CurlDownloader\n{\n    private ?string $tempDir = null;\n    private ?string $outputFile = null;\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?? sys_get_temp_dir();\n        $this->outputFile = tempnam($tempDir, 'download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file: \" . $this->outputFile);\n        }\n\n        $ch = curl_init($url);\n        if (!$ch) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(\"Failed to initialize cURL\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            fclose($fp);\n            unlink($this->outputFile);\n            curl_close($ch);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        if ($this->outputFile === null) {\n            throw new RuntimeException(\"Download must be completed before getting filename.\");\n        }\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if ($this->outputFile !== null && file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n            $this->outputFile = null;\n        }\n    }\n}\n",
      "<?php\n\nclass CurlDownloader\n{\n    private ?string $tempDir = null;\n    private ?string $outputFile = null;\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?? sys_get_temp_dir();\n        $this->outputFile = tempnam($tempDir, 'download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file: \" . $this->outputFile);\n        }\n\n        $ch = curl_init($url);\n        if (!$ch) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(\"Failed to initialize cURL\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            fclose($fp);\n            unlink($this->outputFile);\n            curl_close($ch);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        if ($this->outputFile === null) {\n            throw new RuntimeException(\"Download must be performed before getting the filename.\");\n        }\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if ($this->outputFile !== null && file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n            $this->outputFile = null;\n        }\n    }\n}\n",
      "<?php\n\nclass CurlDownloader\n{\n    private ?string $tempDir = null;\n    private ?string $outputFile = null;\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?? sys_get_temp_dir();\n        $this->outputFile = tempnam($tempDir, 'download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file: \" . $this->outputFile);\n        }\n\n        $ch = curl_init($url);\n        if (!$ch) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(\"Failed to initialize cURL\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            fclose($fp);\n            unlink($this->outputFile);\n            curl_close($ch);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n    public function getFilename(): string\n    {\n        if ($this->outputFile === null) {\n            throw new RuntimeException(\"Download must be completed before getting filename.\");\n        }\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if ($this->outputFile !== null && file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n            $this->outputFile = null;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private ?string $tempDir = null;\n    private ?string $outputFile = null;\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?? sys_get_temp_dir();\n        $this->outputFile = tempnam($tempDir, 'download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file: \" . $this->outputFile);\n        }\n\n        $ch = curl_init($url);\n        if (!$ch) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(\"Failed to initialize cURL\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            fclose($fp);\n            unlink($this->outputFile);\n            curl_close($ch);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n        return true;\n    }\n\n    public function getFilename(): string\n    {\n        if ($this->outputFile === null) {\n            throw new RuntimeException(\"Download must be completed before getting filename.\");\n        }\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if ($this->outputFile !== null && file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n            $this->outputFile = null;\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private ?string $tempDir = null;\n    private ?string $outputFile = null;\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?? sys_get_temp_dir();\n        $this->outputFile = tempnam($tempDir, 'download_');\n\n        $fp = fopen($this->outputFile, 'w+');\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file: \" . $this->outputFile);\n        }\n\n        $ch = curl_init($url);\n        if (!$ch) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(\"Failed to initialize cURL\");\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_FAILONERROR => true,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            fclose($fp);\n            unlink($this->outputFile);\n            curl_close($ch);\n            throw new ErrorException(\"cURL download failed: \" . $error);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        if ($this->outputFile === null) {\n            throw new RuntimeException(\"Download must be performed before getting the filename.\");\n        }\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if ($this->outputFile !== null && file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n            $this->outputFile = null;\n        }\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Create a PHP class that implements OAuth 1.0 authentication for interacting with the Twitter API, handling both GET and POST requests with proper parameter encoding and signature generation.\n\nClass Description: TwitterAPIExchange is a PHP class that provides a convenient way to interact with Twitter's API using OAuth 1.0 authentication. It handles the construction of OAuth signatures, request headers, and performs HTTP requests using cURL.\n\nAttributes:\n- oauth_access_token: string - Twitter OAuth access token\n- oauth_access_token_secret: string - Twitter OAuth access token secret\n- consumer_key: string - Twitter API consumer key\n- consumer_secret: string - Twitter API consumer secret\n- postfields: array - Data to be sent in POST requests\n- getfield: string - Query string for GET requests\n- oauth: array - OAuth parameters for request signing\n- url: string - API endpoint URL\n\nMethods:\n- __construct(array $settings) -> void - Constructor that validates and sets OAuth credentials\n- setPostfields(array $array) -> self - Sets POST data and returns instance for method chaining\n- setGetfield(string $string) -> self - Sets GET query string and returns instance for method chaining\n- getGetfield() -> string|null - Returns current GET query string\n- getPostfields() -> array|null - Returns current POST data\n- buildOauth(string $url, string $requestMethod) -> self - Builds OAuth signature and parameters\n- performRequest(bool $return = true) -> string|void - Executes the API request and returns response\n- buildBaseString(string $baseURI, string $method, array $params) -> string - Private method to build base string for signature\n- buildAuthorizationHeader(array $oauth) -> string - Private method to build OAuth header",
    "Canonical_solution": "class TwitterAPIExchange \n{\n    private $oauth_access_token;\n    private $oauth_access_token_secret;\n    private $consumer_key;\n    private $consumer_secret;\n    private $postfields;\n    private $getfield;\n    protected $oauth;\n    public $url;\n\n    public function __construct(array $settings)\n    {\n        if (!in_array('curl', get_loaded_extensions())) \n        {\n            throw new Exception('You need to install cURL, see: http://curl.haxx.se/docs/install.html');\n        }\n        \n        if (!isset($settings['oauth_access_token'])\n            || !isset($settings['oauth_access_token_secret'])\n            || !isset($settings['consumer_key'])\n            || !isset($settings['consumer_secret']))\n        {\n            throw new Exception('Make sure you are passing in the correct parameters');\n        }\n\n        $this->oauth_access_token = $settings['oauth_access_token'];\n        $this->oauth_access_token_secret = $settings['oauth_access_token_secret'];\n        $this->consumer_key = $settings['consumer_key'];\n        $this->consumer_secret = $settings['consumer_secret'];\n    }\n    \n    public function setPostfields(array $array)\n    {\n        if (!is_null($this->getGetfield())) \n        { \n            throw new Exception('You can only choose get OR post fields.'); \n        }\n        \n        if (isset($array['status']) && substr($array['status'], 0, 1) === '@')\n        {\n            $array['status'] = sprintf(\"\\0%s\", $array['status']);\n        }\n        \n        $this->postfields = $array;\n        \n        return $this;\n    }\n    \n    public function setGetfield($string)\n    {\n        if (!is_null($this->getPostfields())) \n        { \n            throw new Exception('You can only choose get OR post fields.'); \n        }\n        \n        $search = array('#', ',', '+', ':');\n        $replace = array('%23', '%2C', '%2B', '%3A');\n        $string = str_replace($search, $replace, $string);  \n        \n        $this->getfield = $string;\n        \n        return $this;\n    }\n    \n    public function getGetfield()\n    {\n        return $this->getfield;\n    }\n    \n    public function getPostfields()\n    {\n        return $this->postfields;\n    }\n    \n    public function buildOauth($url, $requestMethod)\n    {\n        if (!in_array(strtolower($requestMethod), array('post', 'get')))\n        {\n            throw new Exception('Request method must be either POST or GET');\n        }\n        \n        $consumer_key = $this->consumer_key;\n        $consumer_secret = $this->consumer_secret;\n        $oauth_access_token = $this->oauth_access_token;\n        $oauth_access_token_secret = $this->oauth_access_token_secret;\n        \n        $oauth = array( \n            'oauth_consumer_key' => $consumer_key,\n            'oauth_nonce' => time(),\n            'oauth_signature_method' => 'HMAC-SHA1',\n            'oauth_token' => $oauth_access_token,\n            'oauth_timestamp' => time(),\n            'oauth_version' => '1.0'\n        );\n        \n        $getfield = $this->getGetfield();\n        \n        if (!is_null($getfield))\n        {\n            $getfields = str_replace('?', '', explode('&', $getfield));\n            foreach ($getfields as $g)\n            {\n                $split = explode('=', $g);\n                $oauth[$split[0]] = $split[1];\n            }\n        }\n        \n        $base_info = $this->buildBaseString($url, $requestMethod, $oauth);\n        $composite_key = rawurlencode($consumer_secret) . '&' . rawurlencode($oauth_access_token_secret);\n        $oauth_signature = base64_encode(hash_hmac('sha1', $base_info, $composite_key, true));\n        $oauth['oauth_signature'] = $oauth_signature;\n        \n        $this->url = $url;\n        $this->oauth = $oauth;\n        \n        return $this;\n    }\n    \n    public function performRequest($return = true)\n    {\n        if (!is_bool($return)) \n        { \n            throw new Exception('performRequest parameter must be true or false'); \n        }\n        \n        $header = array($this->buildAuthorizationHeader($this->oauth), 'Expect:');\n        \n        $getfield = $this->getGetfield();\n        $postfields = $this->getPostfields();\n\n        $options = array( \n            CURLOPT_HTTPHEADER => $header,\n            CURLOPT_HEADER => false,\n            CURLOPT_URL => $this->url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_SSL_VERIFYPEER => false\n        );\n\n        if (!is_null($postfields))\n        {\n            $options[CURLOPT_POSTFIELDS] = $postfields;\n        }\n        else\n        {\n            if ($getfield !== '')\n            {\n                $options[CURLOPT_URL] .= $getfield;\n            }\n        }\n\n        $feed = curl_init();\n        curl_setopt_array($feed, $options);\n        $json = curl_exec($feed);\n        curl_close($feed);\n\n        if ($return) { return $json; }\n    }\n    \n    private function buildBaseString($baseURI, $method, $params) \n    {\n        $return = array();\n        ksort($params);\n        \n        foreach($params as $key=>$value)\n        {\n            $return[] = \"$key=\" . $value;\n        }\n        \n        return $method . \"&\" . rawurlencode($baseURI) . '&' . rawurlencode(implode('&', $return)); \n    }\n    \n    private function buildAuthorizationHeader($oauth) \n    {\n        $return = 'Authorization: OAuth ';\n        $values = array();\n        \n        foreach($oauth as $key => $value)\n        {\n            $values[] = \"$key=\\\"\" . rawurlencode($value) . \"\\\"\";\n        }\n        \n        $return .= implode(', ', $values);\n        return $return;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass TwitterAPIExchange\n{\n    private $oauth_access_token;\n    private $oauth_access_token_secret;\n    private $consumer_key;\n    private $consumer_secret;\n    private $postfields;\n    private $getfield;\n    protected $oauth;\n    public $url;\n\n    public function __construct(array $settings)\n    {\n        if (!in_array('oauth_access_token', array_keys($settings)) ||\n            !in_array('oauth_access_token_secret', array_keys($settings)) ||\n            !in_array('consumer_key', array_keys($settings)) ||\n            !in_array('consumer_secret', array_keys($settings)))\n        {\n            throw new Exception('Make sure you are passing in the correct parameters');\n        }\n        $this->oauth_access_token = $settings['oauth_access_token'];\n        $this->oauth_access_token_secret = $settings['oauth_access_token_secret'];\n        $this->consumer_key = $settings['consumer_key'];\n        $this->consumer_secret = $settings['consumer_secret'];\n    }\n\n    public function setPostfields(array $array)\n    {\n        $this->postfields = $array;\n        return $this;\n    }\n\n    public function setGetfield($string)\n    {\n        $this->getfield = $string;\n        return $this;\n    }\n\n    public function getGetfield()\n    {\n        return $this->getfield;\n    }\n\n    public function getPostfields()\n    {\n        return $this->postfields;\n    }\n\n    public function buildOauth($url, $requestMethod)\n    {\n        $consumer_key = $this->consumer_key;\n        $consumer_secret = $this->consumer_secret;\n        $oauth_access_token = $this->oauth_access_token;\n        $oauth_access_token_secret = $this->oauth_access_token_secret;\n\n        $oauth = array(\n            'oauth_consumer_key' => $consumer_key,\n            'oauth_nonce' => time(),\n            'oauth_signature_method' => 'HMAC-SHA1',\n            'oauth_token' => $oauth_access_token,\n            'oauth_timestamp' => time(),\n            'oauth_version' => '1.0'\n        );\n\n        $getfield = $this->getGetfield();\n\n        if (!is_null($getfield))\n        {\n            $getfields = str_replace('?', '', explode('&', $getfield));\n            foreach ($getfields as $g)\n            {\n                $split = explode('=', $g);\n                $oauth[$split[0]] = $split[1];\n            }\n        }\n\n        $base_info = $this->buildBaseString($url, $requestMethod, $oauth);\n        $composite_key = rawurlencode($consumer_secret) . '&' . rawurlencode($oauth_access_token_secret);\n        $oauth_signature = base64_encode(hash_hmac('sha1', $base_info, $composite_key, true));\n        $oauth['oauth_signature'] = $oauth_signature;\n\n        $this->url = $url;\n        $this->oauth = $oauth;\n\n        return $this;\n    }\n\n    private function buildBaseString($baseURI, $method, $params)\n    {\n        $r = array();\n        ksort($params);\n        foreach($params as $key=>$value)\n        {\n            $r[] = \"$key=\" . rawurlencode($value);\n        }\n        return $method.\"&\" . rawurlencode($baseURI) . '&' . rawurlencode(implode('&', $r));\n    }\n\n    private function buildAuthorizationHeader(array $oauth)\n    {\n        $r = 'Authorization: OAuth ';\n        $values = array();\n        foreach($oauth as $key=>$value)\n            $values[] = \"$key=\\\"\" . rawurlencode($value) . \"\\\"\";\n        $r .= implode(', ', $values);\n        return $r;\n    }\n\n    public function performRequest($return = true)\n    {\n        if (!is_bool($return))\n        {\n            throw new Exception('performRequest parameter must be true or false');\n        }\n\n        $header = array($this->buildAuthorizationHeader($this->oauth), 'Expect:');\n\n        $getfield = $this->getGetfield();\n        $postfields = $this->getPostfields();\n\n        $options = array(\n            CURLOPT_HTTPHEADER => $header,\n            CURLOPT_HEADER => false,\n            CURLOPT_URL => $this->url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_SSL_VERIFYPEER => false\n        );\n\n        if (!is_null($postfields))\n        {\n            $options[CURLOPT_POSTFIELDS] = http_build_query($postfields);\n        }\n        else\n        {\n            if ($getfield !== '')\n            {\n                $options[CURLOPT_URL] .= '?'.$getfield;\n            }\n        }\n\n\n        $feed = curl_init();\n        curl_setopt_array($feed, $options);\n        $json = curl_exec($feed);\n        curl_close($feed);\n\n        if ($return) { return $json; }\n    }\n}\n\n?>\n",
      "<?php\nclass TwitterAPIExchange\n{\n    private $oauth_access_token;\n    private $oauth_access_token_secret;\n    private $consumer_key;\n    private $consumer_secret;\n    private $postfields;\n    private $getfield;\n    protected $oauth;\n    public $url;\n\n    public function __construct(array $settings)\n    {\n        if (!in_array('oauth_access_token', array_keys($settings)) ||\n            !in_array('oauth_access_token_secret', array_keys($settings)) ||\n            !in_array('consumer_key', array_keys($settings)) ||\n            !in_array('consumer_secret', array_keys($settings)))\n        {\n            throw new Exception('Make sure you are passing in the correct parameters');\n        }\n        $this->oauth_access_token = $settings['oauth_access_token'];\n        $this->oauth_access_token_secret = $settings['oauth_access_token_secret'];\n        $this->consumer_key = $settings['consumer_key'];\n        $this->consumer_secret = $settings['consumer_secret'];\n    }\n\n    public function setPostfields(array $array)\n    {\n        $this->postfields = $array;\n        return $this;\n    }\n\n    public function setGetfield($string)\n    {\n        $this->getfield = $string;\n        return $this;\n    }\n\n    public function getGetfield()\n    {\n        return $this->getfield;\n    }\n\n    public function getPostfields()\n    {\n        return $this->postfields;\n    }\n\n    public function buildOauth($url, $requestMethod)\n    {\n        $consumer_key = $this->consumer_key;\n        $consumer_secret = $this->consumer_secret;\n        $oauth_access_token = $this->oauth_access_token;\n        $oauth_access_token_secret = $this->oauth_access_token_secret;\n\n        $oauth = array(\n            'oauth_consumer_key' => $consumer_key,\n            'oauth_nonce' => time(),\n            'oauth_signature_method' => 'HMAC-SHA1',\n            'oauth_token' => $oauth_access_token,\n            'oauth_timestamp' => time(),\n            'oauth_version' => '1.0'\n        );\n\n        $getfield = $this->getGetfield();\n\n        if (!is_null($getfield))\n        {\n            $getfields = str_replace('?', '', explode('&', $getfield));\n            foreach ($getfields as $g)\n            {\n                $split = explode('=', $g);\n                $oauth[$split[0]] = $split[1];\n            }\n        }\n\n        $base_info = $this->buildBaseString($url, $requestMethod, $oauth);\n        $composite_key = rawurlencode($consumer_secret) . '&' . rawurlencode($oauth_access_token_secret);\n        $oauth_signature = base64_encode(hash_hmac('sha1', $base_info, $composite_key, true));\n        $oauth['oauth_signature'] = $oauth_signature;\n\n        $this->url = $url;\n        $this->oauth = $oauth;\n\n        return $this;\n    }\n\n    private function buildBaseString($baseURI, $method, $params)\n    {\n        $r = array();\n        ksort($params);\n        foreach($params as $key=>$value)\n        {\n            $r[] = \"$key=\" . rawurlencode($value);\n        }\n        return $method.\"&\" . rawurlencode($baseURI) . '&' . rawurlencode(implode('&', $r));\n    }\n\n    private function buildAuthorizationHeader(array $oauth)\n    {\n        $r = 'Authorization: OAuth ';\n        $values = array();\n        foreach($oauth as $key=>$value)\n            $values[] = \"$key=\\\"\" . rawurlencode($value) . \"\\\"\";\n        $r .= implode(', ', $values);\n        return $r;\n    }\n\n    public function performRequest($return = true)\n    {\n        if (!is_bool($return))\n        {\n            throw new Exception('performRequest parameter must be true or false');\n        }\n\n        $header = array($this->buildAuthorizationHeader($this->oauth), 'Expect:');\n\n        $getfield = $this->getGetfield();\n        $postfields = $this->getPostfields();\n\n        $options = array(\n            CURLOPT_HTTPHEADER => $header,\n            CURLOPT_HEADER => false,\n            CURLOPT_URL => $this->url,\n            CURLOPT_RETURNTRANSFER => $return,\n            CURLOPT_SSL_VERIFYPEER => false\n        );\n\n\n        if (!is_null($postfields))\n        {\n            $options[CURLOPT_POSTFIELDS] = http_build_query($postfields);\n        }\n        else\n        {\n            if ($getfield !== '')\n            {\n                $options[CURLOPT_URL] .= '?'.$getfield;\n            }\n        }\n\n\n        $feed = curl_init();\n        curl_setopt_array($feed, $options);\n        $json = curl_exec($feed);\n        curl_close($feed);\n\n        return $json;\n    }\n}\n?>\n",
      "<?php\nclass TwitterAPIExchange\n{\n    private $oauth_access_token;\n    private $oauth_access_token_secret;\n    private $consumer_key;\n    private $consumer_secret;\n    private $postfields;\n    private $getfield;\n    protected $oauth;\n    public $url;\n\n    public function __construct(array $settings)\n    {\n        if (!in_array('oauth_access_token', array_keys($settings)) ||\n            !in_array('oauth_access_token_secret', array_keys($settings)) ||\n            !in_array('consumer_key', array_keys($settings)) ||\n            !in_array('consumer_secret', array_keys($settings)))\n        {\n            throw new Exception('Make sure you are passing in the correct parameters');\n        }\n        $this->oauth_access_token = $settings['oauth_access_token'];\n        $this->oauth_access_token_secret = $settings['oauth_access_token_secret'];\n        $this->consumer_key = $settings['consumer_key'];\n        $this->consumer_secret = $settings['consumer_secret'];\n    }\n\n    public function setPostfields(array $array)\n    {\n        $this->postfields = $array;\n        return $this;\n    }\n\n    public function setGetfield($string)\n    {\n        $this->getfield = $string;\n        return $this;\n    }\n\n    public function getGetfield()\n    {\n        return $this->getfield;\n    }\n\n    public function getPostfields()\n    {\n        return $this->postfields;\n    }\n\n    public function buildOauth($url, $requestMethod)\n    {\n        $consumer_key = $this->consumer_key;\n        $consumer_secret = $this->consumer_secret;\n        $oauth_access_token = $this->oauth_access_token;\n        $oauth_access_token_secret = $this->oauth_access_token_secret;\n\n        $oauth = array(\n            'oauth_consumer_key' => $consumer_key,\n            'oauth_nonce' => time(),\n            'oauth_signature_method' => 'HMAC-SHA1',\n            'oauth_token' => $oauth_access_token,\n            'oauth_timestamp' => time(),\n            'oauth_version' => '1.0'\n        );\n\n        $getfield = $this->getGetfield();\n\n        if (!is_null($getfield))\n        {\n            $getfields = str_replace('?', '', explode('&', $getfield));\n            foreach ($getfields as $g)\n            {\n                $split = explode('=', $g);\n                $oauth[$split[0]] = $split[1];\n            }\n        }\n\n        $base_info = $this->buildBaseString($url, $requestMethod, $oauth);\n        $composite_key = rawurlencode($consumer_secret) . '&' . rawurlencode($oauth_access_token_secret);\n        $oauth_signature = base64_encode(hash_hmac('sha1', $base_info, $composite_key, true));\n        $oauth['oauth_signature'] = $oauth_signature;\n\n        $this->url = $url;\n        $this->oauth = $oauth;\n\n        return $this;\n    }\n\n    private function buildBaseString($baseURI, $method, $params)\n    {\n        $r = array();\n        ksort($params);\n        foreach($params as $key=>$value)\n        {\n            $r[] = \"$key=\" . rawurlencode($value);\n        }\n        return $method.\"&\" . rawurlencode($baseURI) . '&' . rawurlencode(implode('&', $r));\n    }\n\n    private function buildAuthorizationHeader(array $oauth)\n    {\n        $r = 'Authorization: OAuth ';\n        $values = array();\n        foreach($oauth as $key=>$value)\n            $values[] = \"$key=\\\"\" . rawurlencode($value) . \"\\\"\";\n        $r .= implode(', ', $values);\n        return $r;\n    }\n\n    public function performRequest($return = true)\n    {\n        if (!is_bool($return))\n        {\n            throw new Exception('performRequest parameter must be true or false');\n        }\n\n        $header = array($this->buildAuthorizationHeader($this->oauth), 'Expect:');\n\n        $getfield = $this->getGetfield();\n        $postfields = $this->getPostfields();\n\n        $options = array(\n            CURLOPT_HTTPHEADER => $header,\n            CURLOPT_HEADER => false,\n            CURLOPT_URL => $this->url,\n            CURLOPT_RETURNTRANSFER => $return,\n            CURLOPT_SSL_VERIFYPEER => false\n        );\n\n\n        if (!is_null($postfields))\n        {\n            $options[CURLOPT_POSTFIELDS] = http_build_query($postfields);\n        }\n        else\n        {\n            if ($getfield !== '')\n            {\n                $options[CURLOPT_URL] .= '?'.$getfield;\n            }\n        }\n\n\n        $feed = curl_init();\n        curl_setopt_array($feed, $options);\n        $json = curl_exec($feed);\n        curl_close($feed);\n\n        return $json;\n    }\n}\n?>\n",
      "<?php\nclass TwitterAPIExchange\n{\n    private $oauth_access_token;\n    private $oauth_access_token_secret;\n    private $consumer_key;\n    private $consumer_secret;\n    private $postfields;\n    private $getfield;\n    protected $oauth;\n    public $url;\n\n    public function __construct(array $settings)\n    {\n        if (!in_array('oauth_access_token', array_keys($settings)) ||\n            !in_array('oauth_access_token_secret', array_keys($settings)) ||\n            !in_array('consumer_key', array_keys($settings)) ||\n            !in_array('consumer_secret', array_keys($settings)))\n        {\n            throw new Exception('Make sure you are passing in the correct parameters');\n        }\n        $this->oauth_access_token = $settings['oauth_access_token'];\n        $this->oauth_access_token_secret = $settings['oauth_access_token_secret'];\n        $this->consumer_key = $settings['consumer_key'];\n        $this->consumer_secret = $settings['consumer_secret'];\n    }\n\n    public function setPostfields(array $array)\n    {\n        $this->postfields = $array;\n        return $this;\n    }\n\n    public function setGetfield($string)\n    {\n        $this->getfield = $string;\n        return $this;\n    }\n\n    public function getGetfield()\n    {\n        return $this->getfield;\n    }\n\n    public function getPostfields()\n    {\n        return $this->postfields;\n    }\n\n    public function buildOauth($url, $requestMethod)\n    {\n        $consumer_key = $this->consumer_key;\n        $consumer_secret = $this->consumer_secret;\n        $oauth_access_token = $this->oauth_access_token;\n        $oauth_access_token_secret = $this->oauth_access_token_secret;\n\n        $oauth = array(\n            'oauth_consumer_key' => $consumer_key,\n            'oauth_nonce' => time(),\n            'oauth_signature_method' => 'HMAC-SHA1',\n            'oauth_token' => $oauth_access_token,\n            'oauth_timestamp' => time(),\n            'oauth_version' => '1.0'\n        );\n\n        $getfield = $this->getGetfield();\n\n        if (!is_null($getfield))\n        {\n            $getfields = str_replace('?', '', explode('&', $getfield));\n            foreach ($getfields as $g)\n            {\n                $split = explode('=', $g);\n                $oauth[$split[0]] = $split[1];\n            }\n        }\n\n        $base_info = $this->buildBaseString($url, $requestMethod, $oauth);\n        $composite_key = rawurlencode($consumer_secret) . '&' . rawurlencode($oauth_access_token_secret);\n        $oauth_signature = base64_encode(hash_hmac('sha1', $base_info, $composite_key, true));\n        $oauth['oauth_signature'] = $oauth_signature;\n\n        $this->url = $url;\n        $this->oauth = $oauth;\n\n        return $this;\n    }\n\n    private function buildBaseString($baseURI, $method, $params)\n    {\n        $r = array();\n        ksort($params);\n        foreach($params as $key=>$value)\n        {\n            $r[] = \"$key=\" . rawurlencode($value);\n        }\n        return $method.\"&\" . rawurlencode($baseURI) . '&' . rawurlencode(implode('&', $r));\n    }\n\n    private function buildAuthorizationHeader(array $oauth)\n    {\n        $r = 'Authorization: OAuth ';\n        $values = array();\n        foreach($oauth as $key=>$value)\n            $values[] = \"$key=\\\"\" . rawurlencode($value) . \"\\\"\";\n        $r .= implode(', ', $values);\n        return $r;\n    }\n\n    public function performRequest($return = true)\n    {\n        if (!is_bool($return))\n        {\n            throw new Exception('performRequest parameter must be true or false');\n        }\n\n        $header = array($this->buildAuthorizationHeader($this->oauth), 'Expect:');\n\n        $getfield = $this->getGetfield();\n        $postfields = $this->getPostfields();\n\n        $options = array(\n            CURLOPT_HTTPHEADER => $header,\n            CURLOPT_HEADER => false,\n            CURLOPT_URL => $this->url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_SSL_VERIFYPEER => false\n        );\n\n        if (!is_null($postfields))\n        {\n            $options[CURLOPT_POSTFIELDS] = http_build_query($postfields);\n        }\n        else\n        {\n            if ($getfield !== '')\n            {\n                $options[CURLOPT_URL] .= '?'.$getfield;\n            }\n        }\n\n        $feed = curl_init();\n        curl_setopt_array($feed, $options);\n        $json = curl_exec($feed);\n        curl_close($feed);\n\n        if ($return) { return $json; }\n    }\n}\n\n?>\n",
      "<?php\nclass TwitterAPIExchange\n{\n    private $oauth_access_token;\n    private $oauth_access_token_secret;\n    private $consumer_key;\n    private $consumer_secret;\n    private $postfields;\n    private $getfield;\n    protected $oauth;\n    public $url;\n\n    public function __construct(array $settings)\n    {\n        if (!in_array('oauth_access_token', array_keys($settings)) ||\n            !in_array('oauth_access_token_secret', array_keys($settings)) ||\n            !in_array('consumer_key', array_keys($settings)) ||\n            !in_array('consumer_secret', array_keys($settings)))\n        {\n            throw new Exception('Make sure you are passing in the correct parameters');\n        }\n        $this->oauth_access_token = $settings['oauth_access_token'];\n        $this->oauth_access_token_secret = $settings['oauth_access_token_secret'];\n        $this->consumer_key = $settings['consumer_key'];\n        $this->consumer_secret = $settings['consumer_secret'];\n    }\n\n    public function setPostfields(array $array)\n    {\n        $this->postfields = $array;\n        return $this;\n    }\n\n    public function setGetfield($string)\n    {\n        $this->getfield = $string;\n        return $this;\n    }\n\n    public function getGetfield()\n    {\n        return $this->getfield;\n    }\n\n    public function getPostfields()\n    {\n        return $this->postfields;\n    }\n\n    public function buildOauth($url, $requestMethod)\n    {\n        $consumer_key = $this->consumer_key;\n        $consumer_secret = $this->consumer_secret;\n        $oauth_access_token = $this->oauth_access_token;\n        $oauth_access_token_secret = $this->oauth_access_token_secret;\n\n        $oauth = array(\n            'oauth_consumer_key' => $consumer_key,\n            'oauth_nonce' => time(),\n            'oauth_signature_method' => 'HMAC-SHA1',\n            'oauth_token' => $oauth_access_token,\n            'oauth_timestamp' => time(),\n            'oauth_version' => '1.0'\n        );\n\n        $getfield = $this->getGetfield();\n\n        if (!is_null($getfield))\n        {\n            $getfields = str_replace('?', '', explode('&', $getfield));\n            foreach ($getfields as $g)\n            {\n                $split = explode('=', $g);\n                $oauth[$split[0]] = $split[1];\n            }\n        }\n\n        $base_info = $this->buildBaseString($url, $requestMethod, $oauth);\n        $composite_key = rawurlencode($consumer_secret) . '&' . rawurlencode($oauth_access_token_secret);\n        $oauth_signature = base64_encode(hash_hmac('sha1', $base_info, $composite_key, true));\n        $oauth['oauth_signature'] = $oauth_signature;\n\n        $this->url = $url;\n        $this->oauth = $oauth;\n\n        return $this;\n    }\n\n    private function buildBaseString($baseURI, $method, $params)\n    {\n        $r = array();\n        ksort($params);\n        foreach($params as $key=>$value)\n        {\n            $r[] = \"$key=\" . rawurlencode($value);\n        }\n        return $method.\"&\" . rawurlencode($baseURI) . '&' . rawurlencode(implode('&', $r));\n    }\n\n    private function buildAuthorizationHeader(array $oauth)\n    {\n        $r = 'Authorization: OAuth ';\n        $values = array();\n        foreach($oauth as $key=>$value)\n            $values[] = \"$key=\\\"\" . rawurlencode($value) . \"\\\"\";\n        $r .= implode(', ', $values);\n        return $r;\n    }\n\n    public function performRequest($return = true)\n    {\n        if (!is_bool($return))\n        {\n            throw new Exception('performRequest parameter must be true or false');\n        }\n\n        $header = array($this->buildAuthorizationHeader($this->oauth), 'Expect:');\n\n        $getfield = $this->getGetfield();\n        $postfields = $this->getPostfields();\n\n        $options = array(\n            CURLOPT_HTTPHEADER => $header,\n            CURLOPT_HEADER => false,\n            CURLOPT_URL => $this->url,\n            CURLOPT_RETURNTRANSFER => $return,\n            CURLOPT_SSL_VERIFYPEER => false\n        );\n\n\n        if (!is_null($postfields))\n        {\n            $options[CURLOPT_POSTFIELDS] = http_build_query($postfields);\n        }\n        else\n        {\n            if ($getfield !== '')\n            {\n                $options[CURLOPT_URL] .= '?'.$getfield;\n            }\n        }\n\n        $feed = curl_init();\n        curl_setopt_array($feed, $options);\n        $json = curl_exec($feed);\n        curl_close($feed);\n\n        return $json;\n    }\n}\n?>\n",
      "<?php\nclass TwitterAPIExchange\n{\n    private $oauth_access_token;\n    private $oauth_access_token_secret;\n    private $consumer_key;\n    private $consumer_secret;\n    private $postfields;\n    private $getfield;\n    protected $oauth;\n    public $url;\n\n    public function __construct(array $settings)\n    {\n        if (!in_array('oauth_access_token', array_keys($settings)) ||\n            !in_array('oauth_access_token_secret', array_keys($settings)) ||\n            !in_array('consumer_key', array_keys($settings)) ||\n            !in_array('consumer_secret', array_keys($settings)))\n        {\n            throw new Exception('Make sure you are passing in the correct parameters');\n        }\n        $this->oauth_access_token = $settings['oauth_access_token'];\n        $this->oauth_access_token_secret = $settings['oauth_access_token_secret'];\n        $this->consumer_key = $settings['consumer_key'];\n        $this->consumer_secret = $settings['consumer_secret'];\n    }\n\n    public function setPostfields(array $array)\n    {\n        $this->postfields = $array;\n        return $this;\n    }\n\n    public function setGetfield($string)\n    {\n        $this->getfield = $string;\n        return $this;\n    }\n\n    public function getGetfield()\n    {\n        return $this->getfield;\n    }\n\n    public function getPostfields()\n    {\n        return $this->postfields;\n    }\n\n    public function buildOauth($url, $requestMethod)\n    {\n        $consumer_key = $this->consumer_key;\n        $consumer_secret = $this->consumer_secret;\n        $oauth_access_token = $this->oauth_access_token;\n        $oauth_access_token_secret = $this->oauth_access_token_secret;\n\n        $oauth = array(\n            'oauth_consumer_key' => $consumer_key,\n            'oauth_nonce' => time(),\n            'oauth_signature_method' => 'HMAC-SHA1',\n            'oauth_token' => $oauth_access_token,\n            'oauth_timestamp' => time(),\n            'oauth_version' => '1.0'\n        );\n\n        $getfield = $this->getGetfield();\n\n        if (!is_null($getfield))\n        {\n            $getfields = str_replace('?', '', explode('&', $getfield));\n            foreach ($getfields as $g)\n            {\n                $split = explode('=', $g);\n                $oauth[$split[0]] = $split[1];\n            }\n        }\n\n        $base_info = $this->buildBaseString($url, $requestMethod, $oauth);\n        $composite_key = rawurlencode($consumer_secret) . '&' . rawurlencode($oauth_access_token_secret);\n        $oauth_signature = base64_encode(hash_hmac('sha1', $base_info, $composite_key, true));\n        $oauth['oauth_signature'] = $oauth_signature;\n\n        $this->url = $url;\n        $this->oauth = $oauth;\n\n        return $this;\n    }\n\n    private function buildBaseString($baseURI, $method, $params)\n    {\n        $r = array();\n        ksort($params);\n        foreach($params as $key=>$value)\n        {\n            $r[] = \"$key=\" . rawurlencode($value);\n        }\n        return $method.\"&\" . rawurlencode($baseURI) . '&' . rawurlencode(implode('&', $r));\n    }\n\n    private function buildAuthorizationHeader(array $oauth)\n    {\n        $r = 'Authorization: OAuth ';\n        $values = array();\n        foreach($oauth as $key=>$value)\n            $values[] = \"$key=\\\"\" . rawurlencode($value) . \"\\\"\";\n        $r .= implode(', ', $values);\n        return $r;\n    }\n\n    public function performRequest($return = true)\n    {\n        if (!is_bool($return))\n        {\n            throw new Exception('performRequest parameter must be true or false');\n        }\n\n        $header = array($this->buildAuthorizationHeader($this->oauth), 'Expect:');\n\n        $getfield = $this->getGetfield();\n        $postfields = $this->getPostfields();\n\n        $options = array(\n            CURLOPT_HTTPHEADER => $header,\n            CURLOPT_HEADER => false,\n            CURLOPT_URL => $this->url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_SSL_VERIFYPEER => false\n        );\n\n        if (!is_null($postfields))\n        {\n            $options[CURLOPT_POSTFIELDS] = http_build_query($postfields);\n        }\n        else\n        {\n            if ($getfield !== '')\n            {\n                $options[CURLOPT_URL] .= '?'.$getfield;\n            }\n        }\n\n        $feed = curl_init();\n        curl_setopt_array($feed, $options);\n        $json = curl_exec($feed);\n        curl_close($feed);\n\n        if ($return) { return $json; }\n    }\n}\n\n?>\n",
      "<?php\nclass TwitterAPIExchange\n{\n    private $oauth_access_token;\n    private $oauth_access_token_secret;\n    private $consumer_key;\n    private $consumer_secret;\n    private $postfields;\n    private $getfield;\n    protected $oauth;\n    public $url;\n\n    public function __construct(array $settings)\n    {\n        if (!in_array('oauth_access_token', array_keys($settings)) ||\n            !in_array('oauth_access_token_secret', array_keys($settings)) ||\n            !in_array('consumer_key', array_keys($settings)) ||\n            !in_array('consumer_secret', array_keys($settings)))\n        {\n            throw new Exception('Make sure you are passing in the correct parameters');\n        }\n        $this->oauth_access_token = $settings['oauth_access_token'];\n        $this->oauth_access_token_secret = $settings['oauth_access_token_secret'];\n        $this->consumer_key = $settings['consumer_key'];\n        $this->consumer_secret = $settings['consumer_secret'];\n    }\n\n    public function setPostfields(array $array)\n    {\n        $this->postfields = $array;\n        return $this;\n    }\n\n    public function setGetfield($string)\n    {\n        $this->getfield = $string;\n        return $this;\n    }\n\n    public function getGetfield()\n    {\n        return $this->getfield;\n    }\n\n    public function getPostfields()\n    {\n        return $this->postfields;\n    }\n\n    public function buildOauth($url, $requestMethod)\n    {\n        $consumer_key = $this->consumer_key;\n        $consumer_secret = $this->consumer_secret;\n        $oauth_access_token = $this->oauth_access_token;\n        $oauth_access_token_secret = $this->oauth_access_token_secret;\n\n        $oauth = array(\n            'oauth_consumer_key' => $consumer_key,\n            'oauth_nonce' => time(),\n            'oauth_signature_method' => 'HMAC-SHA1',\n            'oauth_token' => $oauth_access_token,\n            'oauth_timestamp' => time(),\n            'oauth_version' => '1.0'\n        );\n\n        $getfield = $this->getGetfield();\n\n        if (!is_null($getfield))\n        {\n            $getfields = str_replace('?', '', explode('&', $getfield));\n            foreach ($getfields as $g)\n            {\n                $split = explode('=', $g);\n                $oauth[$split[0]] = $split[1];\n            }\n        }\n\n        $base_info = $this->buildBaseString($url, $requestMethod, $oauth);\n        $composite_key = rawurlencode($consumer_secret) . '&' . rawurlencode($oauth_access_token_secret);\n        $oauth_signature = base64_encode(hash_hmac('sha1', $base_info, $composite_key, true));\n        $oauth['oauth_signature'] = $oauth_signature;\n\n        $this->url = $url;\n        $this->oauth = $oauth;\n\n        return $this;\n    }\n\n    private function buildBaseString($baseURI, $method, $params)\n    {\n        $r = array();\n        ksort($params);\n        foreach($params as $key=>$value)\n        {\n            $r[] = \"$key=\" . rawurlencode($value);\n        }\n        return $method.\"&\" . rawurlencode($baseURI) . '&' . rawurlencode(implode('&', $r));\n    }\n\n    private function buildAuthorizationHeader(array $oauth)\n    {\n        $r = 'Authorization: OAuth ';\n        $values = array();\n        foreach($oauth as $key=>$value)\n            $values[] = \"$key=\\\"\" . rawurlencode($value) . \"\\\"\";\n        $r .= implode(', ', $values);\n        return $r;\n    }\n\n    public function performRequest($return = true)\n    {\n        if (!is_bool($return))\n        {\n            throw new Exception('performRequest parameter must be true or false');\n        }\n\n        $header = array($this->buildAuthorizationHeader($this->oauth), 'Expect:');\n\n        $getfield = $this->getGetfield();\n        $postfields = $this->getPostfields();\n\n        $options = array(\n            CURLOPT_HTTPHEADER => $header,\n            CURLOPT_HEADER => false,\n            CURLOPT_URL => $this->url,\n            CURLOPT_RETURNTRANSFER => $return,\n            CURLOPT_SSL_VERIFYPEER => false\n        );\n\n\n        if (!is_null($postfields))\n        {\n            $options[CURLOPT_POSTFIELDS] = http_build_query($postfields);\n        }\n        else\n        {\n            if ($getfield !== '')\n            {\n                $options[CURLOPT_URL] .= '?'.$getfield;\n            }\n        }\n\n\n        $feed = curl_init();\n        curl_setopt_array($feed, $options);\n        $json = curl_exec($feed);\n        curl_close($feed);\n\n        return $json;\n    }\n}\n?>\n",
      "<?php\nclass TwitterAPIExchange\n{\n    protected $oauth_access_token;\n    protected $oauth_access_token_secret;\n    protected $consumer_key;\n    protected $consumer_secret;\n    protected $postfields;\n    protected $getfield;\n    protected $oauth;\n    public $url;\n\n    public function __construct(array $settings)\n    {\n        if (!in_array('oauth_access_token', array_keys($settings)) ||\n            !in_array('oauth_access_token_secret', array_keys($settings)) ||\n            !in_array('consumer_key', array_keys($settings)) ||\n            !in_array('consumer_secret', array_keys($settings)))\n        {\n            throw new Exception('Make sure you are passing in the correct parameters');\n        }\n        $this->oauth_access_token = $settings['oauth_access_token'];\n        $this->oauth_access_token_secret = $settings['oauth_access_token_secret'];\n        $this->consumer_key = $settings['consumer_key'];\n        $this->consumer_secret = $settings['consumer_secret'];\n    }\n\n    public function setPostfields(array $array)\n    {\n        $this->postfields = $array;\n        return $this;\n    }\n\n    public function setGetfield($string)\n    {\n        $this->getfield = $string;\n        return $this;\n    }\n\n    public function getGetfield()\n    {\n        return $this->getfield;\n    }\n\n    public function getPostfields()\n    {\n        return $this->postfields;\n    }\n\n    public function buildOauth($url, $requestMethod)\n    {\n        $consumer_key = $this->consumer_key;\n        $consumer_secret = $this->consumer_secret;\n        $oauth_access_token = $this->oauth_access_token;\n        $oauth_access_token_secret = $this->oauth_access_token_secret;\n\n        $oauth = array(\n            'oauth_consumer_key' => $consumer_key,\n            'oauth_nonce' => time(),\n            'oauth_signature_method' => 'HMAC-SHA1',\n            'oauth_token' => $oauth_access_token,\n            'oauth_timestamp' => time(),\n            'oauth_version' => '1.0'\n        );\n\n        $getfield = $this->getGetfield();\n\n        if (!is_null($getfield))\n        {\n            $getfields = str_replace('?', '', explode('&', $getfield));\n            foreach ($getfields as $g)\n            {\n                $split = explode('=', $g);\n                $oauth[$split[0]] = $split[1];\n            }\n        }\n\n        $base_info = $this->buildBaseString($url, $requestMethod, $oauth);\n        $composite_key = rawurlencode($consumer_secret) . '&' . rawurlencode($oauth_access_token_secret);\n        $oauth_signature = base64_encode(hash_hmac('sha1', $base_info, $composite_key, true));\n        $oauth['oauth_signature'] = $oauth_signature;\n\n        $this->url = $url;\n        $this->oauth = $oauth;\n\n        return $this;\n    }\n\n    private function buildBaseString($baseURI, $method, $params)\n    {\n        $r = array();\n        ksort($params);\n        foreach($params as $key=>$value)\n        {\n            $r[] = \"$key=\" . rawurlencode($value);\n        }\n        return $method.\"&\" . rawurlencode($baseURI) . '&' . rawurlencode(implode('&', $r));\n    }\n\n    private function buildAuthorizationHeader(array $oauth)\n    {\n        $r = 'Authorization: OAuth ';\n        $values = array();\n        foreach($oauth as $key=>$value)\n            $values[] = \"$key=\\\"\" . rawurlencode($value) . \"\\\"\";\n        $r .= implode(', ', $values);\n        return $r;\n    }\n\n    public function performRequest($return = true)\n    {\n        if (!is_bool($return))\n        {\n            throw new Exception('performRequest parameter must be true or false');\n        }\n\n        $header = array($this->buildAuthorizationHeader($this->oauth), 'Expect:');\n\n        $getfield = $this->getGetfield();\n        $postfields = $this->getPostfields();\n\n        $options = array(\n            CURLOPT_HTTPHEADER => $header,\n            CURLOPT_HEADER => false,\n            CURLOPT_URL => $this->url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_SSL_VERIFYPEER => false\n        );\n\n        if (!is_null($postfields))\n        {\n            $options[CURLOPT_POSTFIELDS] = $postfields;\n        }\n        else\n        {\n            if ($getfield !== '')\n            {\n                $options[CURLOPT_URL] .= '?'.$getfield;\n            }\n        }\n\n\n        $feed = curl_init();\n        curl_setopt_array($feed, $options);\n        $json = curl_exec($feed);\n        curl_close($feed);\n\n        if ($return) { return $json; }\n    }\n}\n\n",
      "<?php\nclass TwitterAPIExchange\n{\n    private $oauth_access_token;\n    private $oauth_access_token_secret;\n    private $consumer_key;\n    private $consumer_secret;\n    private $postfields;\n    private $getfield;\n    protected $oauth;\n    public $url;\n\n    public function __construct(array $settings)\n    {\n        if (!in_array('oauth_access_token', array_keys($settings)) ||\n            !in_array('oauth_access_token_secret', array_keys($settings)) ||\n            !in_array('consumer_key', array_keys($settings)) ||\n            !in_array('consumer_secret', array_keys($settings)))\n        {\n            throw new Exception('Make sure you are passing in the correct parameters');\n        }\n        $this->oauth_access_token = $settings['oauth_access_token'];\n        $this->oauth_access_token_secret = $settings['oauth_access_token_secret'];\n        $this->consumer_key = $settings['consumer_key'];\n        $this->consumer_secret = $settings['consumer_secret'];\n    }\n\n    public function setPostfields(array $array)\n    {\n        $this->postfields = $array;\n        return $this;\n    }\n\n    public function setGetfield($string)\n    {\n        $this->getfield = $string;\n        return $this;\n    }\n\n    public function getGetfield()\n    {\n        return $this->getfield;\n    }\n\n    public function getPostfields()\n    {\n        return $this->postfields;\n    }\n\n    public function buildOauth($url, $requestMethod)\n    {\n        $consumer_key = $this->consumer_key;\n        $consumer_secret = $this->consumer_secret;\n        $oauth_access_token = $this->oauth_access_token;\n        $oauth_access_token_secret = $this->oauth_access_token_secret;\n\n        $oauth = array(\n            'oauth_consumer_key' => $consumer_key,\n            'oauth_nonce' => time(),\n            'oauth_signature_method' => 'HMAC-SHA1',\n            'oauth_token' => $oauth_access_token,\n            'oauth_timestamp' => time(),\n            'oauth_version' => '1.0'\n        );\n\n        $getfield = $this->getGetfield();\n\n        if (!is_null($getfield))\n        {\n            $getfields = str_replace('?', '', explode('&', $getfield));\n            foreach ($getfields as $g)\n            {\n                $split = explode('=', $g);\n                $oauth[$split[0]] = $split[1];\n            }\n        }\n\n        $base_info = $this->buildBaseString($url, $requestMethod, $oauth);\n        $composite_key = rawurlencode($consumer_secret) . '&' . rawurlencode($oauth_access_token_secret);\n        $oauth_signature = base64_encode(hash_hmac('sha1', $base_info, $composite_key, true));\n        $oauth['oauth_signature'] = $oauth_signature;\n\n        $this->url = $url;\n        $this->oauth = $oauth;\n\n        return $this;\n    }\n\n    private function buildBaseString($baseURI, $method, $params)\n    {\n        $r = array();\n        ksort($params);\n        foreach($params as $key=>$value)\n        {\n            $r[] = \"$key=\" . rawurlencode($value);\n        }\n        return $method.\"&\" . rawurlencode($baseURI) . '&' . rawurlencode(implode('&', $r));\n    }\n\n    private function buildAuthorizationHeader(array $oauth)\n    {\n        $r = 'Authorization: OAuth ';\n        $values = array();\n        foreach($oauth as $key=>$value)\n            $values[] = \"$key=\\\"\" . rawurlencode($value) . \"\\\"\";\n        $r .= implode(', ', $values);\n        return $r;\n    }\n\n    public function performRequest($return = true)\n    {\n        if (!is_bool($return))\n        {\n            throw new Exception('performRequest parameter must be true or false');\n        }\n\n        $header = array($this->buildAuthorizationHeader($this->oauth), 'Expect:');\n\n        $getfield = $this->getGetfield();\n        $postfields = $this->getPostfields();\n\n        $options = array(\n            CURLOPT_HTTPHEADER => $header,\n            CURLOPT_HEADER => false,\n            CURLOPT_URL => $this->url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_SSL_VERIFYPEER => false\n        );\n\n        if (!is_null($postfields))\n        {\n            $options[CURLOPT_POSTFIELDS] = $postfields;\n        }\n        else\n        {\n            if ($getfield !== '')\n            {\n                $options[CURLOPT_URL] .= '?'.$getfield;\n            }\n        }\n\n\n        $feed = curl_init();\n        curl_setopt_array($feed, $options);\n        $json = curl_exec($feed);\n        curl_close($feed);\n\n        if ($return) { return $json; }\n    }\n}\n\n?>\n",
      "<?php\nclass TwitterAPIExchange\n{\n    private $oauth_access_token;\n    private $oauth_access_token_secret;\n    private $consumer_key;\n    private $consumer_secret;\n    private $postfields;\n    private $getfield;\n    protected $oauth;\n    public $url;\n\n    public function __construct(array $settings)\n    {\n        if (!in_array('oauth_access_token', array_keys($settings)) ||\n            !in_array('oauth_access_token_secret', array_keys($settings)) ||\n            !in_array('consumer_key', array_keys($settings)) ||\n            !in_array('consumer_secret', array_keys($settings)))\n        {\n            throw new Exception('Make sure you are passing in the correct parameters');\n        }\n        $this->oauth_access_token = $settings['oauth_access_token'];\n        $this->oauth_access_token_secret = $settings['oauth_access_token_secret'];\n        $this->consumer_key = $settings['consumer_key'];\n        $this->consumer_secret = $settings['consumer_secret'];\n    }\n\n    public function setPostfields(array $array)\n    {\n        $this->postfields = $array;\n        return $this;\n    }\n\n    public function setGetfield($string)\n    {\n        $this->getfield = $string;\n        return $this;\n    }\n\n    public function getGetfield()\n    {\n        return $this->getfield;\n    }\n\n    public function getPostfields()\n    {\n        return $this->postfields;\n    }\n\n    public function buildOauth($url, $requestMethod)\n    {\n        $consumer_key = $this->consumer_key;\n        $consumer_secret = $this->consumer_secret;\n        $oauth_access_token = $this->oauth_access_token;\n        $oauth_access_token_secret = $this->oauth_access_token_secret;\n\n        $oauth = array(\n            'oauth_consumer_key' => $consumer_key,\n            'oauth_nonce' => time(),\n            'oauth_signature_method' => 'HMAC-SHA1',\n            'oauth_token' => $oauth_access_token,\n            'oauth_timestamp' => time(),\n            'oauth_version' => '1.0'\n        );\n\n        $getfield = $this->getGetfield();\n\n        if (!is_null($getfield))\n        {\n            $getfields = str_replace('?', '', explode('&', $getfield));\n            foreach ($getfields as $g)\n            {\n                $split = explode('=', $g);\n                $oauth[$split[0]] = $split[1];\n            }\n        }\n\n        $base_info = $this->buildBaseString($url, $requestMethod, $oauth);\n        $composite_key = rawurlencode($consumer_secret) . '&' . rawurlencode($oauth_access_token_secret);\n        $oauth_signature = base64_encode(hash_hmac('sha1', $base_info, $composite_key, true));\n        $oauth['oauth_signature'] = $oauth_signature;\n\n        $this->url = $url;\n        $this->oauth = $oauth;\n\n        return $this;\n    }\n\n    private function buildBaseString($baseURI, $method, $params)\n    {\n        $r = array();\n        ksort($params);\n        foreach($params as $key=>$value)\n        {\n            $r[] = \"$key=\" . rawurlencode($value);\n        }\n        return $method.\"&\" . rawurlencode($baseURI) . '&' . rawurlencode(implode('&', $r));\n    }\n\n    private function buildAuthorizationHeader(array $oauth)\n    {\n        $r = 'Authorization: OAuth ';\n        $values = array();\n        foreach($oauth as $key=>$value)\n            $values[] = \"$key=\\\"\" . rawurlencode($value) . \"\\\"\";\n        $r .= implode(', ', $values);\n        return $r;\n    }\n\n    public function performRequest($return = true)\n    {\n        if (!is_bool($return))\n        {\n            throw new Exception('performRequest parameter must be true or false');\n        }\n\n        $header = array($this->buildAuthorizationHeader($this->oauth), 'Expect:');\n\n        $getfield = $this->getGetfield();\n        $postfields = $this->getPostfields();\n\n        $options = array(\n            CURLOPT_HTTPHEADER => $header,\n            CURLOPT_HEADER => false,\n            CURLOPT_URL => $this->url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_SSL_VERIFYPEER => false\n        );\n\n        if (!is_null($postfields))\n        {\n            $options[CURLOPT_POSTFIELDS] = http_build_query($postfields);\n        }\n        else\n        {\n            if ($getfield !== '')\n            {\n                $options[CURLOPT_URL] .= '?'.$getfield;\n            }\n        }\n\n\n        $feed = curl_init();\n        curl_setopt_array($feed, $options);\n        $json = curl_exec($feed);\n        curl_close($feed);\n\n        if ($return) { return $json; }\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create a PHP function that makes an HTTP request to the OpenAI API using cURL, handles the response, and manages potential errors.\n\nFunction Description: The function `make_curl_request` initializes a cURL session to interact with the OpenAI API. It sets necessary headers including authentication, configures cURL options for the request, and implements a callback function to handle the response stream. The function processes both successful responses and errors, setting appropriate cookies for error conditions and returning the response data.\n\nInput:\n- `$postData` (string) - The JSON-encoded data to be sent in the POST request body.\n- `$OPENAI_API_KEY` (string) - The API key for authenticating with the OpenAI API.\n\nOutput:\n- `$responsedata` (string) - The raw response data from the API, which could be either a successful response or an error message. The function also sets cookies for error conditions when they occur.",
    "Canonical_solution": "function make_curl_request($postData, $OPENAI_API_KEY) {\n    $responsedata = \"\";\n    $ch = curl_init();\n    \n    $headers = [\n        'Accept: application/json',\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    ];\n\n    setcookie(\"errcode\", \"\");\n    setcookie(\"errmsg\", \"\");\n\n    $callback = function ($ch, $data) {\n        global $responsedata;\n        $complete = json_decode($data);\n        if (isset($complete->error)) {\n            setcookie(\"errcode\", $complete->error->code);\n            setcookie(\"errmsg\", $data);\n            if (strpos($complete->error->message, \"Rate limit reached\") === 0) {\n                setcookie(\"errcode\", \"rate_limit_reached\");\n            }\n            if (strpos($complete->error->message, \"Your access was terminated\") === 0) {\n                setcookie(\"errcode\", \"access_terminated\");\n            }\n            if (strpos($complete->error->message, \"You didn't provide an API key\") === 0) {\n                setcookie(\"errcode\", \"no_api_key\");\n            }\n            if (strpos($complete->error->message, \"You exceeded your current quota\") === 0) {\n                setcookie(\"errcode\", \"insufficient_quota\");\n            }\n            if (strpos($complete->error->message, \"That model is currently overloaded\") === 0) {\n                setcookie(\"errcode\", \"model_overloaded\");\n            }\n            $responsedata = $data;\n        } else {\n            echo $data;\n            $responsedata .= $data;\n            flush();\n        }\n        return strlen($data);\n    };\n\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    curl_setopt($ch, CURLOPT_URL, 'https://api.openai.com/v1/chat/completions');\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_WRITEFUNCTION, $callback);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 120);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 3);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_AUTOREFERER, true);\n\n    curl_exec($ch);\n    curl_close($ch);\n\n    return $responsedata;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction make_curl_request($postData, $OPENAI_API_KEY) {\n    $ch = curl_init();\n    $headers = array(\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    );\n    curl_setopt($ch, CURLOPT_URL, 'https://api.openai.com/v1/chat/completions');\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $responsedata = '';\n    $headerCallback = function ($ch, $header) use (&$responsedata) {\n        $len = strlen($header);\n        if (preg_match('/^Set-Cookie:\\s*([^=]+)=([^;]+);/', $header, $matches)) {\n            setcookie($matches[1], $matches[2]);\n        }\n        return $len;\n    };\n\n\n    curl_setopt($ch, CURLOPT_HEADERFUNCTION, $headerCallback);\n\n\n    $responsedata = curl_exec($ch);\n\n\n    if (curl_errno($ch)) {\n        $responsedata = curl_error($ch);\n    }\n\n    curl_close($ch);\n    return $responsedata;\n}\n?>\n",
      "<?php\nfunction make_curl_request($postData, $OPENAI_API_KEY) {\n    $ch = curl_init('https://api.openai.com/v1/chat/completions');\n    $headers = array(\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    );\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_POST, true);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HEADERFUNCTION, function ($curl, $header) use (&$cookies) {\n        if (preg_match('/^Set-Cookie:\\s*([^;]*)/mi', $header, $cookie) == 1) {\n            $cookies[] = $cookie[1];\n        }\n        return strlen($header);\n    });\n\n\n    $responsedata = curl_exec($ch);\n\n\n    if (curl_errno($ch)) {\n        $error_msg = curl_error($ch);\n        if (isset($cookies)) {\n            foreach ($cookies as $cookie) {\n                header('Set-Cookie: ' . $cookie);\n            }\n        }\n        $responsedata = '{\"error\": \"' . $error_msg . '\"}';\n    }\n\n\n    curl_close($ch);\n    return $responsedata;\n}\n?>\n",
      "<?php\nfunction make_curl_request($postData, $OPENAI_API_KEY) {\n    $ch = curl_init();\n    $headers = array(\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    );\n    curl_setopt($ch, CURLOPT_URL, 'https://api.openai.com/v1/chat/completions');\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $responsedata = '';\n    curl_setopt($ch, CURLOPT_WRITEFUNCTION, function ($ch, $chunk) use (&$responsedata) {\n        $responsedata .= $chunk;\n        return strlen($chunk);\n    });\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        setcookie(\"error\", $error, time() + (86400 * 30), \"/\"); \n        $responsedata = $error;\n    } else {\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            setcookie(\"error\", $responsedata, time() + (86400 * 30), \"/\");\n        }\n    }\n\n    curl_close($ch);\n    return $responsedata;\n}\n?>\n",
      "<?php\nfunction make_curl_request($postData, $OPENAI_API_KEY) {\n    $ch = curl_init('https://api.openai.com/v1/chat/completions');\n    $headers = array(\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    );\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_POST, true);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HEADERFUNCTION, function ($curl, $header) use (&$cookies) {\n        if (preg_match('/^Set-Cookie:\\s*([^;]*)/mi', $header, $cookie) == 1) {\n            $cookies[] = $cookie[1];\n        }\n        return strlen($header);\n    });\n\n\n    $responsedata = curl_exec($ch);\n\n\n    if (curl_errno($ch)) {\n        $error_msg = curl_error($ch);\n        if (isset($cookies)) {\n            foreach ($cookies as $cookie) {\n                header('Set-Cookie: ' . $cookie);\n            }\n        }\n        $responsedata = '{\"error\": \"' . $error_msg . '\"}';\n    }\n\n\n    if ($responsedata === false) {\n        if (isset($cookies)) {\n            foreach ($cookies as $cookie) {\n                header('Set-Cookie: ' . $cookie);\n            }\n        }\n        $responsedata = '{\"error\": \"Failed to get response from OpenAI API.\"}';\n    }\n\n\n    curl_close($ch);\n    return $responsedata;\n}\n?>\n",
      "<?php\nfunction make_curl_request($postData, $OPENAI_API_KEY) {\n    $ch = curl_init();\n    $headers = array(\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    );\n    curl_setopt($ch, CURLOPT_URL, 'https://api.openai.com/v1/chat/completions');\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $responsedata = '';\n    curl_setopt($ch, CURLOPT_WRITEFUNCTION, function ($ch, $chunk) use (&$responsedata) {\n        $responsedata .= $chunk;\n        return strlen($chunk);\n    });\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        setcookie(\"error\", $error, time() + (86400 * 30), \"/\"); \n        $responsedata = $error;\n    } else {\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            setcookie(\"error\", $responsedata, time() + (86400 * 30), \"/\"); \n        }\n    }\n\n    curl_close($ch);\n    return $responsedata;\n}\n?>\n",
      "<?php\nfunction make_curl_request($postData, $OPENAI_API_KEY) {\n    $ch = curl_init();\n    $headers = array(\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    );\n    curl_setopt($ch, CURLOPT_URL, 'https://api.openai.com/v1/chat/completions');\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $responsedata = '';\n    $headerData = [];\n    curl_setopt($ch, CURLOPT_HEADERFUNCTION,\n        function ($curl, $header) use (&$headerData) {\n            $len = strlen($header);\n            $header = explode(':', $header, 2);\n            if (count($header) < 2) {\n                return $len;\n            }\n\n            $headerData[strtolower(trim($header[0]))][] = trim($header[1]);\n\n            return $len;\n        }\n    );\n\n\n    curl_setopt($ch, CURLOPT_WRITEFUNCTION,\n        function ($curl, $body) use (&$responsedata) {\n            $responsedata .= $body;\n            return strlen($body);\n        }\n    );\n\n\n    if (curl_exec($ch) === false) {\n        $responsedata = curl_error($ch);\n        setcookie(\"error\", $responsedata, time()+3600, \"/\");\n    } else {\n        if (isset($headerData['set-cookie'])) {\n            foreach ($headerData['set-cookie'] as $cookie) {\n                header('Set-Cookie: ' . $cookie);\n            }\n        }\n    }\n    curl_close($ch);\n    return $responsedata;\n}\n?>\n",
      "<?php\nfunction make_curl_request($postData, $OPENAI_API_KEY) {\n    $ch = curl_init('https://api.openai.com/v1/chat/completions');\n    $headers = array(\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    );\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_POST, true);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HEADERFUNCTION, function ($curl, $header) use (&$cookies) {\n        if (preg_match('/^Set-Cookie:\\s*([^=]+)=([^;]+)/mi', $header, $matches)) {\n            $cookies[$matches[1]] = $matches[2];\n        }\n        return strlen($header);\n    });\n\n\n    $responsedata = curl_exec($ch);\n\n\n    if (curl_errno($ch)) {\n        $error_msg = curl_error($ch);\n        if (isset($cookies) && is_array($cookies)) {\n            foreach ($cookies as $name => $value) {\n                setcookie($name, $value, time() + 3600, \"/\");\n            }\n        }\n        $responsedata = $error_msg;\n    }\n\n\n    curl_close($ch);\n    return $responsedata;\n}\n?>\n",
      "<?php\nfunction make_curl_request($postData, $OPENAI_API_KEY) {\n    $ch = curl_init();\n    $headers = array(\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    );\n    curl_setopt($ch, CURLOPT_URL, 'https://api.openai.com/v1/chat/completions');\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $responsedata = '';\n    $headerData = [];\n    curl_setopt($ch, CURLOPT_HEADERFUNCTION,\n        function ($curl, $header) use (&$headerData) {\n            $len = strlen($header);\n            $header = explode(':', $header, 2);\n            if (count($header) < 2) {\n                return $len;\n            }\n\n            $headerData[strtolower(trim($header[0]))][] = trim($header[1]);\n\n            return $len;\n        }\n    );\n\n\n    curl_setopt($ch, CURLOPT_WRITEFUNCTION,\n        function ($curl, $body) use (&$responsedata) {\n            $responsedata .= $body;\n            return strlen($body);\n        }\n    );\n\n\n    if (curl_exec($ch) === false) {\n        $responsedata = curl_error($ch);\n        setcookie(\"error\", $responsedata, time()+3600);\n    } else {\n        if (isset($headerData['set-cookie'])) {\n            foreach ($headerData['set-cookie'] as $cookie) {\n                header('Set-Cookie: ' . $cookie, false);\n            }\n        }\n    }\n    curl_close($ch);\n    return $responsedata;\n}\n?>\n",
      "<?php\nfunction make_curl_request($postData, $OPENAI_API_KEY) {\n    $ch = curl_init();\n    $headers = array(\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    );\n    curl_setopt($ch, CURLOPT_URL, 'https://api.openai.com/v1/chat/completions');\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $responsedata = '';\n    curl_setopt($ch, CURLOPT_WRITEFUNCTION, function ($ch, $chunk) use (&$responsedata) {\n        $responsedata .= $chunk;\n        return strlen($chunk);\n    });\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        setcookie('error_message', $error, time() + (86400 * 30), \"/\");\n        $responsedata = $error;\n    } else {\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            setcookie('error_message', $responsedata, time() + (86400 * 30), \"/\");\n        }\n    }\n\n    curl_close($ch);\n    return $responsedata;\n}\n?>\n",
      "<?php\nfunction make_curl_request($postData, $OPENAI_API_KEY) {\n    $ch = curl_init();\n    $headers = array(\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    );\n    curl_setopt($ch, CURLOPT_URL, 'https://api.openai.com/v1/chat/completions');\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $responsedata = '';\n    curl_setopt($ch, CURLOPT_WRITEFUNCTION, function ($ch, $chunk) use (&$responsedata) {\n        $responsedata .= $chunk;\n        return strlen($chunk);\n    });\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        setcookie(\"error\", $error, time() + (86400 * 30), \"/\"); \n        $responsedata = $error;\n    } else {\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            setcookie(\"error\", $responsedata, time() + (86400 * 30), \"/\"); \n        }\n    }\n\n    curl_close($ch);\n    return $responsedata;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Create a PHP function that performs an HTTP GET request using cURL with secure SSL verification and returns the response.\n\nFunction Description: The function should initialize a cURL session, configure it with appropriate security settings (including SSL verification with a custom CA certificate), set a timeout, execute the request, handle errors, and return the response. The function should properly clean up resources after execution.\n\nInput: \n- $url (string): The URL to which the GET request will be sent\n\nOutput: \n- Returns the response from the server as a string if successful\n- Returns false if the request fails (though error handling should be implemented separately)",
    "Canonical_solution": "function curlGet($url)\n{\n    $curl = curl_init();\n\n    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($curl, CURLOPT_HEADER, 0);\n    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 1);\n    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2);\n    curl_setopt($curl, CURLOPT_CAINFO, 'usr/plugins/TeStore/data/cacert.pem');\n    curl_setopt($curl, CURLOPT_TIMEOUT, 30);\n    curl_setopt($curl, CURLOPT_URL, $url);\n\n    $result = curl_exec($curl);\n    curl_close($curl);\n\n    return $result;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction secureHttpGet($url) {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => true,\n        CURLOPT_SSL_VERIFYHOST => 2,\n        CURLOPT_CAINFO => '/path/to/your/cacert.pem', // Replace with the actual path\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Handle error appropriately (e.g., log, throw exception)\n        // Example: error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction secureHttpGet($url) {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => true,\n        CURLOPT_SSL_VERIFYHOST => 2,\n        CURLOPT_CAINFO => '/path/to/your/cacert.pem', // Replace with the actual path\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Error handling (e.g., logging) should be done here\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction secureHttpGet($url) {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => true,\n        CURLOPT_SSL_VERIFYHOST => 2,\n        CURLOPT_CAINFO => '/path/to/your/ca-bundle.crt', // Replace with the actual path\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Handle error appropriately (e.g., log, throw exception)\n        // Example: error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction secureHttpGet($url) {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => true,\n        CURLOPT_SSL_VERIFYHOST => 2,\n        CURLOPT_CAINFO => '/path/to/your/ca-bundle.crt', // Replace with the actual path\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Handle error appropriately, e.g., log the error\n        // error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction secureHttpGet($url) {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => true,\n        CURLOPT_SSL_VERIFYHOST => 2,\n        CURLOPT_CAINFO => '/path/to/your/ca-bundle.crt', // Replace with the actual path\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Handle error appropriately, e.g., log the error\n        // error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction secureHttpGet($url) {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => true,\n        CURLOPT_SSL_VERIFYHOST => 2,\n        CURLOPT_CAINFO => '/path/to/your/ca-bundle.crt', // Replace with the actual path\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Handle error appropriately, e.g., log the error\n        // error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction secureHttpGet($url) {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => true,\n        CURLOPT_SSL_VERIFYHOST => 2,\n        CURLOPT_CAINFO => '/path/to/your/cacert.pem', // Replace with the actual path\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Handle the error appropriately, e.g., log the error\n        // error_log('cURL error: ' . curl_error($ch)); \n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction secureHttpGet($url) {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => true,\n        CURLOPT_SSL_VERIFYHOST => 2,\n        CURLOPT_CAINFO => '/path/to/your/cacert.pem', // Replace with the actual path\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Handle error appropriately (e.g., log, throw exception)\n        // Example: error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction secureHttpGet($url) {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => true,\n        CURLOPT_SSL_VERIFYHOST => 2,\n        CURLOPT_CAINFO => '/path/to/your/cacert.pem', // Replace with the actual path\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Handle the error appropriately (e.g., log, throw exception)\n        // For this example, we'll just return false\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction secureHttpGet($url) {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => true,\n        CURLOPT_SSL_VERIFYHOST => 2,\n        CURLOPT_CAINFO => '/path/to/your/ca-bundle.crt', // Replace with the actual path\n        CURLOPT_TIMEOUT => 30,\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Handle the error appropriately, e.g., log the error\n        // error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a PHP function that uses cURL to make an HTTP request to a URL shortening service and return the shortened URL.\n\nFunction Description: The function `curl_sg` initializes a cURL session, configures it with appropriate options (including timeout settings, headers, and SSL verification), makes a GET request to the Sogou URL shortening service, and returns the response. The function handles the entire cURL lifecycle from initialization to cleanup.\n\nInput: \n- `$url` (string): The original URL to be shortened.\n\nOutput: \n- (string): The shortened URL returned by the Sogou service, or false if the request fails.",
    "Canonical_solution": "function curl_sg($url)\n{\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5000);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, array(\n        'User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4'\n    ));\n    curl_setopt($ch, CURLOPT_URL, \"https://sa.sogou.com/gettiny?url=\".$url);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REDIR_PROTOCOLS, -1);\n    $contents = curl_exec($ch);\n    curl_close($ch);\n    return $contents;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction curl_sg($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, 'https://sa.sogou.com/getshorturl?url=' . urlencode($url));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode != 200 || curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n\n    return $response;\n}\n?>\n",
      "<?php\nfunction curl_sg($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, 'https://sa.sogou.com/getshorturl?url=' . urlencode($url));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $response = curl_exec($ch);\n    if (curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction curl_sg($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, 'https://sa.sogou.com/getShortUrl?url=' . urlencode($url));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 200 && $httpCode < 300 && $response !== false) {\n        $json = json_decode($response, true);\n        if (isset($json['short_url'])) {\n            curl_close($ch);\n            return $json['short_url'];\n        }\n    }\n\n    curl_close($ch);\n    return false;\n}\n?>\n",
      "<?php\nfunction curl_sg($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, 'https://sa.sogou.com/getshorturl?url=' . urlencode($url));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 200 && $httpCode < 300 && $response !== false) {\n        curl_close($ch);\n        return $response;\n    } else {\n        curl_close($ch);\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction curl_sg($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, 'https://sa.sogou.com/getshorturl?url=' . urlencode($url));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $output = curl_exec($ch);\n    if ($output === false) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $output;\n}\n?>\n",
      "<?php\nfunction curl_sg($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, 'https://sa.sogou.com/getshorturl?url=' . urlencode($url));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode != 200 || curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n\n    $json = json_decode($response, true);\n    if (isset($json['short_url'])) {\n        return $json['short_url'];\n    } else {\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction curl_sg($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, 'https://sa.sogou.com/getshorturl?url=' . urlencode($url));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 200 && $httpCode < 300 && $response !== false) {\n        $shortenedUrl = trim($response);\n        curl_close($ch);\n        return $shortenedUrl;\n    } else {\n        curl_close($ch);\n        return false;\n    }\n}\n?>\n",
      "<?php\nfunction curl_sg($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, 'https://sa.sogou.com/getShortUrl?url=' . urlencode($url));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); \n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 200 && $httpCode < 300 && $response !== false) {\n        $json = json_decode($response, true);\n        if (isset($json['short_url'])) {\n            curl_close($ch);\n            return $json['short_url'];\n        }\n    }\n    \n    if ($ch) {\n        curl_close($ch);\n    }\n    return false;\n}\n?>\n",
      "<?php\nfunction curl_sg($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, 'https://sa.sogou.com/getshorturl?url=' . urlencode($url));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 200 && $httpCode < 300 && $response) {\n        $json = json_decode($response, true);\n        if (isset($json['short_url'])) {\n            curl_close($ch);\n            return $json['short_url'];\n        }\n    }\n\n    curl_close($ch);\n    return false;\n}\n?>\n",
      "<?php\nfunction curl_sg($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, 'https://sa.sogou.com/getshorturl?url=' . urlencode($url));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $output = curl_exec($ch);\n    if (curl_errno($ch)) {\n        curl_close($ch);\n        return false;\n    }\n    curl_close($ch);\n    return $output;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a PHP function that makes HTTP requests to the Heroku API using cURL, with support for various HTTP methods, custom headers, and error handling.\n\nFunction Description: The function `HerokuAPI` is designed to interact with the Heroku API by sending HTTP requests. It supports multiple HTTP methods (including PATCH and POST for sending data), sets appropriate headers including authorization, and handles the response. The function includes timeout settings and SSL verification options for secure communication.\n\nInput:\n- $method: [string] - The HTTP method to use (e.g., 'GET', 'POST', 'PATCH', etc.)\n- $url: [string] - The URL to which the request will be sent\n- $data: [string] - Optional. The payload to send with the request (typically for POST/PATCH methods)\n- $apikey: [string] - The Heroku API key used for authorization\n\nOutput:\n- Returns an associative array with two keys:\n  - 'body': [string] - The response body from the API\n  - 'stat': [int] - The HTTP status code of the response",
    "Canonical_solution": "function HerokuAPI($method, $url, $data = '', $apikey)\n{\n    if ($method=='PATCH'||$method=='POST') {\n        $headers['Content-Type'] = 'application/json';\n    } \n    $headers['Authorization'] = 'Bearer ' . $apikey;\n    $headers['Accept'] = 'application/vnd.heroku+json; version=3';\n    $sendHeaders = array();\n    foreach ($headers as $headerName => $headerVal) {\n        $sendHeaders[] = $headerName . ': ' . $headerVal;\n    }\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_CUSTOMREQUEST,$method);\n    curl_setopt($ch, CURLOPT_POSTFIELDS,$data);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $sendHeaders);\n    $response['body'] = curl_exec($ch);\n    $response['stat'] = curl_getinfo($ch,CURLINFO_HTTP_CODE);\n    curl_close($ch);\n    return $response;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction HerokuAPI($method, $url, $data = null, $apikey) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: application/vnd.heroku+json; version=3',\n        'Authorization: Bearer ' . $apikey,\n        'Content-Type: application/json'\n    ]);\n    if ($data) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n    $response = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n    return ['body' => $response, 'stat' => $status];\n}\n?>\n",
      "<?php\nfunction HerokuAPI($method, $url, $data = null, $apikey) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: application/vnd.heroku+json; version=3',\n        'Authorization: Bearer ' . $apikey,\n        'Content-Type: application/json'\n    ]);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PATCH':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PATCH');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'DELETE':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n            break;\n        case 'PUT':\n            curl_setopt($ch, CURLOPT_PUT, true);\n            if ($data) {\n                $fp = fopen('php://temp/maxmemory:256000', 'w');\n                if (!$fp) {\n                    return ['body' => 'Failed to open temporary file', 'stat' => 500];\n                }\n                fwrite($fp, $data);\n                fseek($fp, 0);\n                curl_setopt($ch, CURLOPT_INFILE, $fp);\n                curl_setopt($ch, CURLOPT_INFILESIZE, strlen($data));\n            }\n            break;\n\n    }\n\n\n    $response = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n\n    return ['body' => $response, 'stat' => $status];\n}\n?>\n",
      "<?php\nfunction HerokuAPI($method, $url, $data = null, $apikey) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: application/vnd.heroku+json; version=3',\n        'Authorization: Bearer ' . $apikey,\n        'Content-Type: application/json'\n    ]);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PATCH':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PATCH');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'DELETE':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n            break;\n        case 'PUT':\n            curl_setopt($ch, CURLOPT_PUT, true);\n            if ($data) {\n                $fp = fopen('php://temp', 'r+');\n                fwrite($fp, $data);\n                rewind($fp);\n                curl_setopt($ch, CURLOPT_INFILE, $fp);\n                curl_setopt($ch, CURLOPT_INFILESIZE, strlen($data));\n            }\n            break;\n\n    }\n\n\n    $response = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n\n    return ['body' => $response, 'stat' => $status];\n}\n?>\n",
      "<?php\nfunction HerokuAPI($method, $url, $data = null, $apikey) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: application/vnd.heroku+json; version=3',\n        'Authorization: Bearer ' . $apikey,\n        'Content-Type: application/json'\n    ]);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PATCH':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PATCH');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'DELETE':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n            break;\n        case 'PUT':\n            curl_setopt($ch, CURLOPT_PUT, true);\n            if ($data) {\n                $fp = fopen('php://temp/maxmemory:256000', 'w');\n                if (!$fp) {\n                    return ['body' => 'Failed to open temporary file', 'stat' => 500];\n                }\n                fwrite($fp, $data);\n                fseek($fp, 0);\n                curl_setopt($ch, CURLOPT_INFILE, $fp);\n                curl_setopt($ch, CURLOPT_INFILESIZE, strlen($data));\n            }\n            break;\n\n    }\n\n\n    $response = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n\n    return ['body' => $response, 'stat' => $status];\n}\n?>\n",
      "<?php\nfunction HerokuAPI($method, $url, $data = null, $apikey) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: application/vnd.heroku+json; version=3',\n        'Authorization: Bearer ' . $apikey,\n        'Content-Type: application/json'\n    ]);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PATCH':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PATCH');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'DELETE':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n            break;\n        case 'PUT':\n            curl_setopt($ch, CURLOPT_PUT, true);\n            if ($data) {\n                $fp = fopen('php://temp', 'r+');\n                fwrite($fp, $data);\n                rewind($fp);\n                curl_setopt($ch, CURLOPT_INFILE, $fp);\n                curl_setopt($ch, CURLOPT_INFILESIZE, strlen($data));\n            }\n            break;\n\n    }\n\n\n    $response = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n\n    return ['body' => $response, 'stat' => $status];\n}\n?>\n",
      "<?php\nfunction HerokuAPI($method, $url, $data = null, $apikey) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: application/vnd.heroku+json; version=3',\n        'Authorization: Bearer ' . $apikey,\n        'Content-Type: application/json'\n    ]);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PATCH':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PATCH');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'DELETE':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n            break;\n        case 'PUT':\n            curl_setopt($ch, CURLOPT_PUT, true);\n            if ($data) {\n                $fp = fopen('php://temp/maxmemory:256000', 'w');\n                if (!$fp) {\n                    return ['body' => 'Failed to open temporary file', 'stat' => 500];\n                }\n                fwrite($fp, $data);\n                fseek($fp, 0);\n                curl_setopt($ch, CURLOPT_INFILE, $fp);\n                curl_setopt($ch, CURLOPT_INFILESIZE, strlen($data));\n            }\n            break;\n\n    }\n\n\n    $response = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n\n    return ['body' => $response, 'stat' => $status];\n}\n?>\n",
      "<?php\nfunction HerokuAPI($method, $url, $data = null, $apikey) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: application/vnd.heroku+json; version=3',\n        'Authorization: Bearer ' . $apikey,\n        'Content-Type: application/json'\n    ]);\n\n    switch (strtoupper($method)) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'PATCH':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PATCH');\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'DELETE':\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');\n            break;\n        case 'PUT':\n            curl_setopt($ch, CURLOPT_PUT, true);\n            if ($data) {\n                $fp = fopen('php://temp', 'r+');\n                fwrite($fp, $data);\n                rewind($fp);\n                curl_setopt($ch, CURLOPT_INFILE, $fp);\n                curl_setopt($ch, CURLOPT_INFILESIZE, strlen($data));\n            }\n            break;\n\n    }\n\n\n    $response = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n\n    return ['body' => $response, 'stat' => $status];\n}\n?>\n",
      "<?php\nfunction HerokuAPI($method, $url, $data = null, $apikey) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: application/vnd.heroku+json; version=3',\n        'Authorization: Bearer ' . $apikey,\n        'Content-Type: application/json'\n    ]);\n    if ($data) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n    $response = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n    return ['body' => $response, 'stat' => $status];\n}\n?>\n",
      "<?php\nfunction HerokuAPI($method, $url, $data = null, $apikey) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: application/vnd.heroku+json; version=3',\n        'Authorization: Bearer ' . $apikey,\n        'Content-Type: application/json'\n    ]);\n    if ($data) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n    $response = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n    return ['body' => $response, 'stat' => $status];\n}\n?>\n",
      "<?php\nfunction HerokuAPI($method, $url, $data = null, $apikey) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'Accept: application/vnd.heroku+json; version=3',\n        'Authorization: Bearer ' . $apikey,\n        'Content-Type: application/json'\n    ]);\n    if ($data) {\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n    $response = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n    return ['body' => $response, 'stat' => $status];\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Implement an OAuth2 client class in PHP that handles HTTP requests for OAuth2 authentication flows, including obtaining authorization codes and access tokens.\n\nClass Description: This abstract class provides a base implementation for OAuth2 client functionality. It includes methods for making HTTP requests and stores OAuth2 configuration parameters. Concrete implementations should extend this class for specific OAuth2 providers.\n\nAttributes:\n- version: [string] - OAuth version being used (default: '2.0')\n- appKey: [string] - Application/client ID for OAuth2\n- appSecret: [string] - Application/client secret for OAuth2\n- responseType: [string] - OAuth2 response type (default: 'code')\n- grantType: [string] - OAuth2 grant type (default: 'authorization_code')\n- callback: [string] - Callback URL for OAuth2 flow\n- authorize: [string] - Authorization endpoint URL\n- getRequestCodeURL: [string] - URL to request authorization code\n- getAccessTokenURL: [string] - URL to exchange code for access token\n- apiBase: [string] - Base URL for API endpoints\n- token: [mixed] - Stores the access token (null by default)\n\nMethods:\n- http: [http](string $url, array $params, string $method = 'GET', array $header = [], bool $multi = false) -> string - Makes an HTTP request using cURL with the specified parameters. Handles both GET and POST methods, with support for multipart POST requests. Returns the response body or throws an exception on error.",
    "Canonical_solution": "namespace cmf\\lib;\n\nabstract class Oauth2\n{\n    protected $version = '2.0';\n    protected $appKey = '';\n    protected $appSecret = '';\n    protected $responseType = 'code';\n    protected $grantType = 'authorization_code';\n    protected $callback = '';\n    protected $authorize = '';\n    protected $getRequestCodeURL = '';\n    protected $getAccessTokenURL = '';\n    protected $apiBase = '';\n    protected $token = null;\n\n    protected function http($url, $params, $method = 'GET', $header = [], $multi = false)\n    {\n        $opts = [\n            CURLOPT_TIMEOUT        => 30,\n            CURLOPT_RETURNTRANSFER => 1,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HTTPHEADER     => $header\n        ];\n\n        switch (strtoupper($method)) {\n            case 'GET':\n                $opts[CURLOPT_URL] = $url . '?' . http_build_query($params);\n                break;\n            case 'POST':\n                $params                   = $multi ? $params : http_build_query($params);\n                $opts[CURLOPT_URL]        = $url;\n                $opts[CURLOPT_POST]       = 1;\n                $opts[CURLOPT_POSTFIELDS] = $params;\n                break;\n            default:\n                throw new \\Exception('不支持的请求方式！');\n        }\n\n        $ch = curl_init();\n        curl_setopt_array($ch, $opts);\n        $data  = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n        if ($error) throw new \\Exception('请求发生错误：' . $error);\n        return $data;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nabstract class OAuth2Handler {\n\n    protected $version = '2.0';\n    protected $appKey;\n    protected $appSecret;\n    protected $responseType = 'code';\n    protected $grantType = 'authorization_code';\n    protected $callback;\n    protected $authorize;\n    protected $getRequestCodeURL;\n    protected $getAccessTokenURL;\n    protected $apiBase;\n    protected $token = null;\n\n\n    public function http($url, $params = [], $method = 'GET', $header = [], $multi = false) {\n        $opts = [\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_RETURNTRANSFER => 1,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HTTPHEADER => $header\n        ];\n\n        switch (strtoupper($method)) {\n            case 'GET':\n                if (!empty($params)) {\n                    $url .= (strpos($url, '?') !== false ? '&' : '?') . http_build_query($params);\n                }\n                $opts[CURLOPT_URL] = $url;\n                break;\n            case 'POST':\n                $opts[CURLOPT_URL] = $url;\n                $opts[CURLOPT_POST] = 1;\n                $opts[CURLOPT_POSTFIELDS] = $multi ? $params : http_build_query($params);\n                break;\n            default:\n                throw new Exception('Unsupported request method.');\n        }\n\n        $ch = curl_init();\n        curl_setopt_array($ch, $opts);\n        $data  = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        if ($error) throw new Exception('Request error: ' . $error);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nabstract class OAuth2Handler {\n\n    protected $version = '2.0';\n    protected $appKey;\n    protected $appSecret;\n    protected $responseType = 'code';\n    protected $grantType = 'authorization_code';\n    protected $callback;\n    protected $authorize;\n    protected $getRequestCodeURL;\n    protected $getAccessTokenURL;\n    protected $apiBase;\n    protected $token = null;\n\n\n    public function http($url, $params = [], $method = 'GET', $header = [], $multi = false) {\n        $opts = [\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_RETURNTRANSFER => 1,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HTTPHEADER => $header\n        ];\n\n        switch (strtoupper($method)) {\n            case 'GET':\n                if (!empty($params)) {\n                    $url .= (strpos($url, '?') !== false ? '&' : '?') . http_build_query($params);\n                }\n                $opts[CURLOPT_URL] = $url;\n                break;\n            case 'POST':\n                $opts[CURLOPT_URL] = $url;\n                $opts[CURLOPT_POST] = 1;\n                $opts[CURLOPT_POSTFIELDS] = $multi ? $params : http_build_query($params);\n                break;\n            default:\n                throw new Exception('Unsupported method: ' . $method);\n        }\n\n        $ch = curl_init();\n        curl_setopt_array($ch, $opts);\n        $data  = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        if ($error) throw new Exception('Request error: ' . $error);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nabstract class OAuth2Handler {\n\n    protected $version = '2.0';\n    protected $appKey;\n    protected $appSecret;\n    protected $responseType = 'code';\n    protected $grantType = 'authorization_code';\n    protected $callback;\n    protected $authorize;\n    protected $getRequestCodeURL;\n    protected $getAccessTokenURL;\n    protected $apiBase;\n    protected $token = null;\n\n\n    public function http($url, $params = [], $method = 'GET', $header = [], $multi = false) {\n        $opts = [\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_RETURNTRANSFER => 1,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HTTPHEADER => $header\n        ];\n\n        switch (strtoupper($method)) {\n            case 'GET':\n                if (!empty($params)) {\n                    $url .= (strpos($url, '?') === false ? '?' : '&') . http_build_query($params);\n                }\n                $opts[CURLOPT_URL] = $url;\n                break;\n            case 'POST':\n                $opts[CURLOPT_URL] = $url;\n                $opts[CURLOPT_POST] = 1;\n                $opts[CURLOPT_POSTFIELDS] = $multi ? $params : http_build_query($params);\n                break;\n            default:\n                throw new Exception('Unsupported request method.');\n        }\n\n        $ch = curl_init();\n        curl_setopt_array($ch, $opts);\n        $data  = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        if ($error) throw new Exception('Request error: ' . $error);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nabstract class OAuth2Handler {\n\n    protected $version = '2.0';\n    protected $appKey;\n    protected $appSecret;\n    protected $responseType = 'code';\n    protected $grantType = 'authorization_code';\n    protected $callback;\n    protected $authorize;\n    protected $getRequestCodeURL;\n    protected $getAccessTokenURL;\n    protected $apiBase;\n    protected $token = null;\n\n\n    public function http($url, $params = [], $method = 'GET', $header = [], $multi = false) {\n        $opts = [\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_RETURNTRANSFER => 1,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HTTPHEADER => $header\n        ];\n\n        switch (strtoupper($method)) {\n            case 'GET':\n                if (!empty($params)) {\n                    $url .= (strpos($url, '?') !== false ? '&' : '?') . http_build_query($params);\n                }\n                $opts[CURLOPT_URL] = $url;\n                break;\n            case 'POST':\n                $opts[CURLOPT_URL] = $url;\n                $opts[CURLOPT_POST] = 1;\n                $opts[CURLOPT_POSTFIELDS] = $multi ? $params : http_build_query($params);\n                break;\n            default:\n                throw new Exception('Unsupported method: ' . $method);\n        }\n\n        $ch = curl_init();\n        curl_setopt_array($ch, $opts);\n        $data  = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        if ($error) throw new Exception('Request error: ' . $error);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nabstract class OAuth2Handler {\n\n    protected $version = '2.0';\n    protected $appKey;\n    protected $appSecret;\n    protected $responseType = 'code';\n    protected $grantType = 'authorization_code';\n    protected $callback;\n    protected $authorize;\n    protected $getRequestCodeURL;\n    protected $getAccessTokenURL;\n    protected $apiBase;\n    protected $token = null;\n\n\n    public function http($url, $params = [], $method = 'GET', $header = [], $multi = false) {\n        $opts = [\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_RETURNTRANSFER => 1,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HTTPHEADER => $header\n        ];\n\n        switch (strtoupper($method)) {\n            case 'GET':\n                if (!empty($params)) {\n                    $url .= (strpos($url, '?') !== false ? '&' : '?') . http_build_query($params);\n                }\n                $opts[CURLOPT_URL] = $url;\n                break;\n            case 'POST':\n                $opts[CURLOPT_URL] = $url;\n                $opts[CURLOPT_POST] = 1;\n                $opts[CURLOPT_POSTFIELDS] = $multi ? $params : http_build_query($params);\n                break;\n            default:\n                throw new Exception('Unsupported request method.');\n        }\n\n        $ch = curl_init();\n        curl_setopt_array($ch, $opts);\n        $data  = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        if ($error) throw new Exception('Request error: ' . $error);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nabstract class OAuth2Handler {\n\n    protected $version = '2.0';\n    protected $appKey;\n    protected $appSecret;\n    protected $responseType = 'code';\n    protected $grantType = 'authorization_code';\n    protected $callback;\n    protected $authorize;\n    protected $getRequestCodeURL;\n    protected $getAccessTokenURL;\n    protected $apiBase;\n    protected $token = null;\n\n\n    public function http($url, $params = [], $method = 'GET', $header = [], $multi = false) {\n        $opts = [\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_RETURNTRANSFER => 1,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HTTPHEADER => $header\n        ];\n\n        switch (strtoupper($method)) {\n            case 'GET':\n                if (!empty($params)) {\n                    $url .= (strpos($url, '?') !== false ? '&' : '?') . http_build_query($params);\n                }\n                $opts[CURLOPT_URL] = $url;\n                break;\n            case 'POST':\n                $opts[CURLOPT_URL] = $url;\n                $opts[CURLOPT_POST] = 1;\n                $opts[CURLOPT_POSTFIELDS] = $multi ? $params : http_build_query($params);\n                break;\n            default:\n                throw new Exception('Unsupported method: ' . $method);\n        }\n\n        $ch = curl_init();\n        curl_setopt_array($ch, $opts);\n        $data  = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        if ($error) throw new Exception('Request error: ' . $error);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nabstract class OAuth2Handler {\n\n    protected $version = '2.0';\n    protected $appKey;\n    protected $appSecret;\n    protected $responseType = 'code';\n    protected $grantType = 'authorization_code';\n    protected $callback;\n    protected $authorize;\n    protected $getRequestCodeURL;\n    protected $getAccessTokenURL;\n    protected $apiBase;\n    protected $token = null;\n\n\n    public function http($url, $params = [], $method = 'GET', $header = [], $multi = false) {\n        $opts = [\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_RETURNTRANSFER => 1,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HTTPHEADER => $header\n        ];\n\n        switch (strtoupper($method)) {\n            case 'GET':\n                if (!empty($params)) {\n                    $url .= (strpos($url, '?') === false ? '?' : '&') . http_build_query($params);\n                }\n                $opts[CURLOPT_URL] = $url;\n                break;\n            case 'POST':\n                $opts[CURLOPT_URL] = $url;\n                $opts[CURLOPT_POST] = 1;\n                if ($multi) {\n                    foreach ($multi as $key => $file) {\n                        $params[$key] = new \\CURLFile(realpath($file), 'image/jpeg', $key);\n                    }\n                    $opts[CURLOPT_POSTFIELDS] = $params;\n                } else {\n                    $opts[CURLOPT_POSTFIELDS] = http_build_query($params);\n                }\n                break;\n            default:\n                throw new \\Exception('Unsuppored method ' . $method);\n        }\n\n        $ch = curl_init();\n        curl_setopt_array($ch, $opts);\n        $data  = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        if ($error) throw new \\Exception('Request error: ' . $error);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nabstract class OAuth2Handler {\n\n    protected $version = '2.0';\n    protected $appKey;\n    protected $appSecret;\n    protected $responseType = 'code';\n    protected $grantType = 'authorization_code';\n    protected $callback;\n    protected $authorize;\n    protected $getRequestCodeURL;\n    protected $getAccessTokenURL;\n    protected $apiBase;\n    protected $token = null;\n\n\n    public function http($url, $params = [], $method = 'GET', $header = [], $multi = false) {\n        $opts = [\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_RETURNTRANSFER => 1,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HTTPHEADER => $header\n        ];\n\n        switch (strtoupper($method)) {\n            case 'GET':\n                if (!empty($params)) {\n                    $url .= (strpos($url, '?') !== false ? '&' : '?') . http_build_query($params);\n                }\n                $opts[CURLOPT_URL] = $url;\n                break;\n            case 'POST':\n                $opts[CURLOPT_URL] = $url;\n                $opts[CURLOPT_POST] = 1;\n                $opts[CURLOPT_POSTFIELDS] = $multi ? $params : http_build_query($params);\n                break;\n            default:\n                throw new Exception('Unsupported request method.');\n        }\n\n        $ch = curl_init();\n        curl_setopt_array($ch, $opts);\n        $data  = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        if ($error) throw new Exception('Request error: ' . $error);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nabstract class OAuth2Handler {\n\n    protected $version = '2.0';\n    protected $appKey;\n    protected $appSecret;\n    protected $responseType = 'code';\n    protected $grantType = 'authorization_code';\n    protected $callback;\n    protected $authorize;\n    protected $getRequestCodeURL;\n    protected $getAccessTokenURL;\n    protected $apiBase;\n    protected $token = null;\n\n\n    public function http($url, $params = [], $method = 'GET', $header = [], $multi = false) {\n        $opts = [\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_RETURNTRANSFER => 1,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HTTPHEADER => $header\n        ];\n\n        switch (strtoupper($method)) {\n            case 'GET':\n                if (!empty($params)) {\n                    $url .= (strpos($url, '?') !== false ? '&' : '?') . http_build_query($params);\n                }\n                $opts[CURLOPT_URL] = $url;\n                break;\n            case 'POST':\n                $opts[CURLOPT_URL] = $url;\n                $opts[CURLOPT_POST] = 1;\n                $opts[CURLOPT_POSTFIELDS] = $multi ? $params : http_build_query($params);\n                break;\n            default:\n                throw new Exception('Unsupported method: ' . $method);\n        }\n\n        $ch = curl_init();\n        curl_setopt_array($ch, $opts);\n        $data  = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        if ($error) throw new Exception('Request error: ' . $error);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nabstract class OAuth2Handler {\n\n    protected $version = '2.0';\n    protected $appKey;\n    protected $appSecret;\n    protected $responseType = 'code';\n    protected $grantType = 'authorization_code';\n    protected $callback;\n    protected $authorize;\n    protected $getRequestCodeURL;\n    protected $getAccessTokenURL;\n    protected $apiBase;\n    protected $token = null;\n\n\n    public function http($url, $params = [], $method = 'GET', $header = [], $multi = false) {\n        $opts = [\n            CURLOPT_TIMEOUT => 30,\n            CURLOPT_RETURNTRANSFER => 1,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HTTPHEADER => $header\n        ];\n\n        switch (strtoupper($method)) {\n            case 'GET':\n                if (!empty($params)) {\n                    $url .= (strpos($url, '?') !== false ? '&' : '?') . http_build_query($params);\n                }\n                $opts[CURLOPT_URL] = $url;\n                break;\n            case 'POST':\n                $opts[CURLOPT_URL] = $url;\n                $opts[CURLOPT_POST] = 1;\n                $opts[CURLOPT_POSTFIELDS] = $multi ? $params : http_build_query($params);\n                break;\n            default:\n                throw new Exception('Unsupported request method.');\n        }\n\n        $ch = curl_init();\n        curl_setopt_array($ch, $opts);\n        $data  = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        if ($error) throw new Exception('Request error: ' . $error);\n        return $data;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a PHP class that provides HTTP client functionality using Guzzle library, with error handling and testing capabilities.\n\nClass Description: The `SupportedApps` class is an abstract base class that provides HTTP client functionality using Guzzle. It handles HTTP requests with configurable timeouts and methods, includes error handling for connection and server exceptions, and provides a testing method to verify API connectivity.\n\nAttributes:\n- jar: [bool] - Flag indicating whether to use cookies (not implemented in current code)\n- method: [string] - Default HTTP method to use for requests (default: 'GET')\n- error: [string|null] - Stores the last error message encountered during request execution\n\nMethods:\n- execute($url, array $attrs = [], $overridevars = null, $overridemethod = null) -> [ResponseInterface|null] - Executes an HTTP request to the specified URL with optional attributes, overriding variables and method. Returns the response or null on failure.\n- appTest($url, array $attrs = []) -> [object] - Tests the connection to a specified URL, returning an object with status code, status message, and response body. Handles various HTTP status codes with appropriate messages.",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected $jar = false;\n    protected $method = 'GET';\n    protected $error;\n\n    public function execute(\n        $url,\n        array $attrs = [],\n        $overridevars = null,\n        $overridemethod = null\n    ): ?ResponseInterface {\n        $res = null;\n\n        $vars = ($overridevars === null || $overridevars === false) ?\n         [\n            'http_errors' => false,\n            'timeout' => 15,\n            'connect_timeout' => 15,\n        ] : $overridevars;\n\n        $client = new Client($vars);\n\n        $method = ($overridemethod === null || $overridemethod === false) ? $this->method : $overridemethod;\n\n        try {\n            return $client->request($method, $url, $attrs);\n        } catch (ConnectException $e) {\n            $this->error = 'Connection refused - '.(string) $e->getMessage();\n        } catch (ServerException $e) {\n            $this->error = (string) $e->getResponse()->getBody();\n        }\n        $this->error = 'General error connecting with API';\n\n        return $res;\n    }\n\n    public function appTest($url, array $attrs = []): object\n    {\n        if (empty($this->config->url)) {\n            return (object) [\n                'code' => 404,\n                'status' => 'No URL has been specified',\n                'response' => 'No URL has been specified',\n            ];\n        }\n        $res = $this->execute($url, $attrs);\n        if ($res == null) {\n            return (object) [\n                'code' => null,\n                'status' => $this->error,\n                'response' => 'Connection failed',\n            ];\n        }\n        switch ($res->getStatusCode()) {\n            case 200:\n                $status = 'Successfully communicated with the API';\n                break;\n            case 401:\n                $status = 'Failed: Invalid credentials';\n                break;\n            case 404:\n                $status = 'Failed: Please make sure your URL is correct and that there is a trailing slash';\n                break;\n            default:\n                $status = 'Something went wrong... Code: '.$res->getStatusCode();\n                break;\n        }\n\n        return (object) [\n            'code' => $res->getStatusCode(),\n            'status' => $status,\n            'response' => $res->getBody(),\n        ];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected bool $jar = false;\n    protected string $method = 'GET';\n    protected ?string $error = null;\n\n\n    public function execute(string $url, array $attrs = [], $overridevars = null, $overridemethod = null): ?ResponseInterface\n    {\n        $client = new Client(['timeout' => 60]);\n        $method = $overridemethod ?? $this->method;\n\n        try {\n            $response = $client->request($method, $url, $attrs);\n            return $response;\n        } catch (ConnectException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (ServerException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public function appTest(string $url, array $attrs = []): object\n    {\n        $response = $this->execute($url, $attrs);\n\n        if ($response) {\n            $statusCode = $response->getStatusCode();\n            $body = (string)$response->getBody();\n\n            switch ($statusCode) {\n                case 200:\n                    $statusMessage = 'OK';\n                    break;\n                case 204:\n                    $statusMessage = 'No Content';\n                    break;\n                case 400:\n                    $statusMessage = 'Bad Request';\n                    break;\n                case 401:\n                    $statusMessage = 'Unauthorized';\n                    break;\n                case 404:\n                    $statusMessage = 'Not Found';\n                    break;\n                case 500:\n                    $statusMessage = 'Internal Server Error';\n                    break;\n                default:\n                    $statusMessage = 'Unknown Status';\n            }\n\n            return (object)[\n                'statusCode' => $statusCode,\n                'statusMessage' => $statusMessage,\n                'body' => $body\n            ];\n        } else {\n            return (object)[\n                'statusCode' => 0,\n                'statusMessage' => $this->error ?? 'Connection Error',\n                'body' => ''\n            ];\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected bool $jar = false;\n    protected string $method = 'GET';\n    protected ?string $error = null;\n\n\n    public function execute(string $url, array $attrs = [], $overridevars = null, $overridemethod = null): ?ResponseInterface\n    {\n        $client = new Client(['timeout' => 60]);\n        $method = $overridemethod ?? $this->method;\n\n        try {\n            $response = $client->request($method, $url, $attrs);\n            return $response;\n        } catch (ConnectException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (ServerException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public function appTest(string $url, array $attrs = []): object\n    {\n        $response = $this->execute($url, $attrs);\n\n        if ($response) {\n            $statusCode = $response->getStatusCode();\n            $body = (string)$response->getBody();\n\n            switch ($statusCode) {\n                case 200:\n                    $statusMessage = 'OK';\n                    break;\n                case 204:\n                    $statusMessage = 'No Content';\n                    $body = 'No Content';\n                    break;\n                case 400:\n                    $statusMessage = 'Bad Request';\n                    break;\n                case 401:\n                    $statusMessage = 'Unauthorized';\n                    break;\n                case 404:\n                    $statusMessage = 'Not Found';\n                    break;\n                case 500:\n                    $statusMessage = 'Internal Server Error';\n                    break;\n                default:\n                    $statusMessage = 'Unknown Status';\n            }\n\n            return (object)[\n                'statusCode' => $statusCode,\n                'statusMessage' => $statusMessage,\n                'body' => $body\n            ];\n        } else {\n            return (object)[\n                'statusCode' => 0,\n                'statusMessage' => 'Connection Failed: ' . $this->error,\n                'body' => ''\n            ];\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected bool $jar = false;\n    protected string $method = 'GET';\n    protected ?string $error = null;\n\n\n    public function execute(string $url, array $attrs = [], $overridevars = null, $overridemethod = null): ?ResponseInterface\n    {\n        $client = new Client(['timeout' => 60]);\n        $method = $overridemethod ?? $this->method;\n\n        try {\n            $response = $client->request($method, $url, $attrs);\n            return $response;\n        } catch (ConnectException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (ServerException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (Exception $e) {\n            $this->error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public function appTest(string $url, array $attrs = []): object\n    {\n        $response = $this->execute($url, $attrs);\n\n        if ($response) {\n            $statusCode = $response->getStatusCode();\n            $body = (string)$response->getBody();\n\n            switch ($statusCode) {\n                case 200:\n                    $statusMessage = 'OK';\n                    break;\n                case 204:\n                    $statusMessage = 'No Content';\n                    break;\n                case 400:\n                    $statusMessage = 'Bad Request';\n                    break;\n                case 401:\n                    $statusMessage = 'Unauthorized';\n                    break;\n                case 404:\n                    $statusMessage = 'Not Found';\n                    break;\n                case 500:\n                    $statusMessage = 'Internal Server Error';\n                    break;\n                default:\n                    $statusMessage = 'Unknown Status';\n            }\n\n            return (object)[\n                'statusCode' => $statusCode,\n                'statusMessage' => $statusMessage,\n                'body' => $body\n            ];\n        } else {\n            return (object)[\n                'statusCode' => 0,\n                'statusMessage' => $this->error ?? 'Connection Error',\n                'body' => ''\n            ];\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected bool $jar = false;\n    protected string $method = 'GET';\n    protected ?string $error = null;\n\n    public function execute(string $url, array $attrs = [], $overridevars = null, $overridemethod = null): ?ResponseInterface\n    {\n        $client = new Client(['timeout' => 60]);\n        $method = $overridemethod ?? $this->method;\n\n        try {\n            $response = $client->request($method, $url, $attrs);\n            return $response;\n        } catch (ConnectException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (ServerException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public function appTest(string $url, array $attrs = []): object\n    {\n        $response = $this->execute($url, $attrs);\n\n        if ($response) {\n            $statusCode = $response->getStatusCode();\n            $body = (string)$response->getBody();\n\n            switch ($statusCode) {\n                case 200:\n                    $statusMessage = 'OK';\n                    break;\n                case 204:\n                    $statusMessage = 'No Content';\n                    break;\n                case 400:\n                    $statusMessage = 'Bad Request';\n                    break;\n                case 401:\n                    $statusMessage = 'Unauthorized';\n                    break;\n                case 404:\n                    $statusMessage = 'Not Found';\n                    break;\n                case 500:\n                    $statusMessage = 'Internal Server Error';\n                    break;\n                default:\n                    $statusMessage = 'Unknown Status';\n            }\n\n            return (object)[\n                'statusCode' => $statusCode,\n                'statusMessage' => $statusMessage,\n                'body' => $body\n            ];\n        } else {\n            return (object)[\n                'statusCode' => 0,\n                'statusMessage' => $this->error ?? 'Connection Error',\n                'body' => ''\n            ];\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected bool $jar = false;\n    protected string $method = 'GET';\n    protected ?string $error = null;\n\n\n    public function execute(string $url, array $attrs = [], $overridevars = null, $overridemethod = null): ?ResponseInterface\n    {\n        $client = new Client(['timeout' => 60]);\n        $method = $overridemethod ?? $this->method;\n\n        try {\n            $response = $client->request($method, $url, $attrs);\n            return $response;\n        } catch (ConnectException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (ServerException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (Exception $e) {\n            $this->error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public function appTest(string $url, array $attrs = []): object\n    {\n        $response = $this->execute($url, $attrs);\n\n        if ($response) {\n            $statusCode = $response->getStatusCode();\n            $body = (string)$response->getBody();\n\n            switch ($statusCode) {\n                case 200:\n                    $statusMessage = 'OK';\n                    break;\n                case 204:\n                    $statusMessage = 'No Content';\n                    break;\n                case 400:\n                    $statusMessage = 'Bad Request';\n                    break;\n                case 401:\n                    $statusMessage = 'Unauthorized';\n                    break;\n                case 404:\n                    $statusMessage = 'Not Found';\n                    break;\n                case 500:\n                    $statusMessage = 'Internal Server Error';\n                    break;\n                default:\n                    $statusMessage = 'Unknown Status';\n            }\n\n            return (object)[\n                'statusCode' => $statusCode,\n                'statusMessage' => $statusMessage,\n                'body' => $body\n            ];\n        } else {\n            return (object)[\n                'statusCode' => 0,\n                'statusMessage' => $this->error ?? 'Unknown Error',\n                'body' => ''\n            ];\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected bool $jar = false;\n    protected string $method = 'GET';\n    protected ?string $error = null;\n\n\n    public function execute(string $url, array $attrs = [], $overridevars = null, $overridemethod = null): ?ResponseInterface\n    {\n        $client = new Client(['timeout' => 60]);\n        $method = $overridemethod ?? $this->method;\n        try {\n            if ($overridevars) {\n                if ($method == 'GET') {\n                    $response = $client->request($method, $url, ['query' => $overridevars]);\n                } else {\n                    $response = $client->request($method, $url, ['form_params' => $overridevars]);\n                }\n            } else {\n                $response = $client->request($method, $url, $attrs);\n            }\n\n            return $response;\n        } catch (ConnectException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (ServerException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public function appTest(string $url, array $attrs = []): object\n    {\n        $response = $this->execute($url, $attrs);\n\n        if ($response) {\n            $statusCode = $response->getStatusCode();\n            $body = (string)$response->getBody();\n\n            switch ($statusCode) {\n                case 200:\n                    $statusMessage = 'OK';\n                    break;\n                case 204:\n                    $statusMessage = 'No Content';\n                    break;\n                case 400:\n                    $statusMessage = 'Bad Request';\n                    break;\n                case 401:\n                    $statusMessage = 'Unauthorized';\n                    break;\n                case 404:\n                    $statusMessage = 'Not Found';\n                    break;\n                case 500:\n                    $statusMessage = 'Internal Server Error';\n                    break;\n                default:\n                    $statusMessage = 'Unknown Status';\n            }\n\n            return (object)[\n                'statusCode' => $statusCode,\n                'statusMessage' => $statusMessage,\n                'body' => $body\n            ];\n        } else {\n            return (object)[\n                'statusCode' => 0,\n                'statusMessage' => $this->error ?? 'Connection Error',\n                'body' => ''\n            ];\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected bool $jar = false;\n    protected string $method = 'GET';\n    protected ?string $error = null;\n\n\n    public function execute(string $url, array $attrs = [], $overridevars = null, $overridemethod = null): ?ResponseInterface\n    {\n        $client = new Client(['timeout' => 60]);\n        $method = $overridemethod ?? $this->method;\n\n        try {\n            $response = $client->request($method, $url, $attrs);\n            return $response;\n        } catch (ConnectException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (ServerException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (Exception $e) {\n            $this->error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public function appTest(string $url, array $attrs = []): object\n    {\n        $response = $this->execute($url, $attrs);\n\n        if ($response) {\n            $statusCode = $response->getStatusCode();\n            $body = (string)$response->getBody();\n\n            switch ($statusCode) {\n                case 200:\n                    $statusMessage = 'OK';\n                    break;\n                case 204:\n                    $statusMessage = 'No Content';\n                    break;\n                case 400:\n                    $statusMessage = 'Bad Request';\n                    break;\n                case 401:\n                    $statusMessage = 'Unauthorized';\n                    break;\n                case 404:\n                    $statusMessage = 'Not Found';\n                    break;\n                case 500:\n                    $statusMessage = 'Internal Server Error';\n                    break;\n                default:\n                    $statusMessage = 'Unknown Status';\n            }\n\n            return (object)[\n                'statusCode' => $statusCode,\n                'statusMessage' => $statusMessage,\n                'body' => $body\n            ];\n        } else {\n            return (object)[\n                'statusCode' => 0,\n                'statusMessage' => $this->error ?? 'Connection Failed',\n                'body' => ''\n            ];\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected bool $jar = false;\n    protected string $method = 'GET';\n    protected ?string $error = null;\n\n\n    public function execute(string $url, array $attrs = [], $overridevars = null, $overridemethod = null): ?ResponseInterface\n    {\n        $client = new Client(['timeout' => 60]);\n        $method = $overridemethod ?? $this->method;\n\n        try {\n            $response = $client->request($method, $url, $attrs);\n            return $response;\n        } catch (ConnectException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (ServerException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public function appTest(string $url, array $attrs = []): object\n    {\n        $response = $this->execute($url, $attrs);\n\n        if ($response) {\n            $status_code = $response->getStatusCode();\n            $body = (string)$response->getBody();\n\n            switch ($status_code) {\n                case 200:\n                    $status_message = 'OK';\n                    break;\n                case 204:\n                    $status_message = 'No Content';\n                    break;\n                case 400:\n                    $status_message = 'Bad Request';\n                    break;\n                case 401:\n                    $status_message = 'Unauthorized';\n                    break;\n                case 404:\n                    $status_message = 'Not Found';\n                    break;\n                case 500:\n                    $status_message = 'Internal Server Error';\n                    break;\n                default:\n                    $status_message = 'Unknown Status';\n            }\n\n            return (object)[\n                'status_code' => $status_code,\n                'status_message' => $status_message,\n                'body' => $body\n            ];\n        } else {\n            return (object)[\n                'status_code' => 0,\n                'status_message' => $this->error ?? 'Connection Error',\n                'body' => ''\n            ];\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected bool $jar = false;\n    protected string $method = 'GET';\n    protected ?string $error = null;\n\n    public function execute(string $url, array $attrs = [], $overridevars = null, $overridemethod = null): ?ResponseInterface\n    {\n        $client = new Client(['timeout' => 60]);\n        $method = $overridemethod ?? $this->method;\n\n        try {\n            $response = $client->request($method, $url, $attrs);\n            return $response;\n        } catch (ConnectException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (ServerException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (Exception $e) {\n            $this->error = $e->getMessage();\n            return null;\n        }\n    }\n\n\n    public function appTest(string $url, array $attrs = []): object\n    {\n        $response = $this->execute($url, $attrs);\n\n        if ($response) {\n            $statusCode = $response->getStatusCode();\n            $body = (string)$response->getBody();\n\n            switch ($statusCode) {\n                case 200:\n                    $statusMessage = 'OK';\n                    break;\n                case 204:\n                    $statusMessage = 'No Content';\n                    break;\n                case 400:\n                    $statusMessage = 'Bad Request';\n                    break;\n                case 401:\n                    $statusMessage = 'Unauthorized';\n                    break;\n                case 404:\n                    $statusMessage = 'Not Found';\n                    break;\n                case 500:\n                    $statusMessage = 'Internal Server Error';\n                    break;\n                default:\n                    $statusMessage = 'Unknown Status';\n            }\n\n            return (object)[\n                'statusCode' => $statusCode,\n                'statusMessage' => $statusMessage,\n                'body' => $body\n            ];\n        } else {\n            return (object)[\n                'statusCode' => 0,\n                'statusMessage' => $this->error ?? 'Connection Failed',\n                'body' => ''\n            ];\n        }\n    }\n}\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected bool $jar = false;\n    protected string $method = 'GET';\n    protected ?string $error = null;\n\n\n    public function execute(string $url, array $attrs = [], $overridevars = null, $overridemethod = null): ?ResponseInterface\n    {\n        $client = new Client(['timeout' => 60]);\n        $method = $overridemethod ?? $this->method;\n\n        try {\n            $response = $client->request($method, $url, $attrs);\n            return $response;\n        } catch (ConnectException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (ServerException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (Exception $e) {\n            $this->error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public function appTest(string $url, array $attrs = []): object\n    {\n        $response = $this->execute($url, $attrs);\n\n        if ($response) {\n            $statusCode = $response->getStatusCode();\n            $body = (string)$response->getBody();\n\n            switch ($statusCode) {\n                case 200:\n                    $statusMessage = 'OK';\n                    break;\n                case 204:\n                    $statusMessage = 'No Content';\n                    break;\n                case 400:\n                    $statusMessage = 'Bad Request';\n                    break;\n                case 401:\n                    $statusMessage = 'Unauthorized';\n                    break;\n                case 404:\n                    $statusMessage = 'Not Found';\n                    break;\n                case 500:\n                    $statusMessage = 'Internal Server Error';\n                    break;\n                default:\n                    $statusMessage = 'Unknown Status';\n            }\n\n            return (object)[\n                'statusCode' => $statusCode,\n                'statusMessage' => $statusMessage,\n                'body' => $body\n            ];\n        } else {\n            return (object)[\n                'statusCode' => 0,\n                'statusMessage' => $this->error ?? 'Connection Failed',\n                'body' => ''\n            ];\n        }\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a PHP class for interacting with Alipay's API to send red packets (digital cash gifts) with proper authentication and request handling.\n\nClass Description: The AlipayService class encapsulates functionality for sending red packets through Alipay's payment platform. It handles request configuration, signature generation, and API communication while maintaining security through proper certificate and key management.\n\nAttributes:\n- appId: [string] - Alipay application ID\n- alipayRootCertSn: [string] - Alipay root certificate serial number  \n- appCertSn: [string] - Application certificate serial number\n- notifyUrl: [string] - Callback URL for payment notifications\n- charset: [string] - Character encoding (default: utf-8)\n- rsaPrivateKey: [string] - RSA private key for signing requests\n- totalFee: [float] - Payment amount\n- outTradeNo: [string] - Merchant transaction number\n- orderName: [string] - Order description\n- userid: [string] - Recipient's Alipay user ID\n\nMethods:\n- __construct() -> [void] - Initializes the class with default charset\n- setAppid(string $appid) -> [void] - Sets the Alipay application ID\n- setAlipayRootCertSn(string $alipayRootCertSn) -> [void] - Sets root certificate serial number\n- setAppCertSn(string $appCertSn) -> [void] - Sets application certificate serial number  \n- setNotifyUrl(string $notifyUrl) -> [void] - Sets notification callback URL\n- setRsaPrivateKey(string $saPrivateKey) -> [void] - Sets RSA private key\n- setTotalFee(float $payAmount) -> [void] - Sets payment amount\n- setOutTradeNo(string $outTradeNo) -> [void] - Sets merchant transaction number\n- setOrderName(string $orderName) -> [void] - Sets order description\n- setUserId(string $userid) -> [void] - Sets recipient's Alipay user ID\n- sendRedPacket() -> [array] - Sends red packet request and returns response\n- generateSign(array $params, string $signType) -> [string] - Generates request signature\n- sign(string $data, string $signType) -> [string] - Creates cryptographic signature\n- checkEmpty(mixed $value) -> [bool] - Checks if value is empty\n- getSignContent(array $params) -> [string] - Prepares string for signing\n- characet(string $data, string $targetCharset) -> [string] - Handles character encoding\n- curlPost(string $url, mixed $postData, array $options) -> [string] - Executes cURL request to API",
    "Canonical_solution": "class AlipayService\n{\n    protected $appId;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $notifyUrl;\n    protected $charset;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $userid;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setAlipayRootCertSn($alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn($appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($saPrivateKey)\n    {\n        $this->rsaPrivateKey = $saPrivateKey;\n    }\n\n    public function setTotalFee($payAmount)\n    {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setUserId($userid)\n    {\n        $this->userid = $userid;\n    }\n\n    public function sendRedPacket()\n    {\n        $requestConfigs = array(\n            'out_biz_no'=>$this->outTradeNo,\n            'trans_amount'=>$this->totalFee,\n            'product_code'=>'STD_RED_PACKET',\n            'biz_scene'=>'DIRECT_TRANSFER',\n            'remark'=>$this->orderName,\n            'order_title'=>$this->orderName,\n            'payee_info'=>array(\n                'identity'=>$this->userid,\n                'identity_type'=>'ALIPAY_USER_ID',\n            ),\n            'business_params'=>array(\n                'sub_biz_scene'=>'REDPACKET',\n            )\n        );\n        $commonConfigs = array(\n            'alipay_root_cert_sn' => $this->alipayRootCertSn,\n            'app_cert_sn' => $this->appCertSn,\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset'=>'utf-8',\n            'sign_type'=>'RSA2',\n            'timestamp'=>date('Y-m-d H:i:s'),\n            'version'=>'1.0',\n            'biz_content'=>json_encode($requestConfigs),\n        );\n\n        $commonConfigs[\"sign\"] = $this->generateSign($commonConfigs, $commonConfigs['sign_type']);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do?charset='.$this->charset,$commonConfigs);\n        return json_decode($result,true);\n    }\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey=$this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, version_compare(PHP_VERSION,'5.4.0', '<') ? SHA256 : OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    protected function checkEmpty($value) {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n        return false;\n    }\n\n    public function getSignContent($params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                $v = $this->characet($v, $this->charset);\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array())\n    {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $userid;\n\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid(string $appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function setNotifyUrl(string $notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey(string $rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee(float $totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo(string $outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName(string $orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setUserId(string $userid)\n    {\n        $this->userid = $userid;\n    }\n\n\n    public function sendRedPacket()\n    {\n        $bizContent = [\n            'product_code' => 'STD_RED_PACKET',\n            'total_amount' => $this->totalFee,\n            'out_trade_no' => $this->outTradeNo,\n            'subject' => $this->orderName,\n            'receiver_id' => $this->userid,\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n\n        return $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n    }\n\n\n    public function generateSign(array $params, string $signType = \"RSA\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign(string $data, string $signType = \"RSA\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    public function checkEmpty($value)\n    {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent(array $params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset)\n    {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost(string $url, mixed $postData, array $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        $postBodyString = \"\";\n        $encodeArray = [];\n        $postMultipart = false;\n\n\n        if (is_array($postData) && 0 < count($postData)) {\n\n            foreach ($postData as $k => $v) {\n                if (\"@\" != substr($v, 0, 1)) {\n\n                    $postBodyString .= \"$k=\" . urlencode($this->characet($v, $this->charset)) . \"&\";\n                    $encodeArray[$k] = $this->characet($v, $this->charset);\n                } else {\n                    $postMultipart = true;\n                }\n            }\n            unset($k, $v);\n            curl_setopt($ch, CURLOPT_POST, true);\n            if ($postMultipart) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n            } else {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, substr($postBodyString, 0, -1));\n            }\n        }\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n\n            throw new Exception(curl_error($ch), 0);\n        } else {\n            $httpStatusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if (200 !== $httpStatusCode) {\n                throw new Exception($response, $httpStatusCode);\n            }\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $userid;\n\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setAlipayRootCertSn($alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn($appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setUserId($userid)\n    {\n        $this->userid = $userid;\n    }\n\n\n    public function sendRedPacket()\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_biz_no' => $this->outTradeNo,\n                'trans_amount' => $this->totalFee,\n                'product_code' => 'STD_RED_PACKET',\n                'biz_scene' => 'PERSONAL_COLLECTION',\n                'order_title' => $this->orderName,\n                'payee_info' => [\n                    'identity' => $this->userid,\n                    'identity_type' => 'ALIPAY_USER_ID'\n                ]\n            ])\n        ];\n\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n\n        return $this->curlPost($url, $params);\n\n    }\n\n\n    public function generateSign(array $params, string $signType = \"RSA\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    public function checkEmpty($value)\n    {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url, $postData, $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        $postBodyString = \"\";\n        $encodeArray = Array();\n        $postMultipart = false;\n\n\n        if (is_array($postData) && 0 < count($postData)) {\n\n            foreach ($postData as $k => $v) {\n                if (\"@\" != substr($v, 0, 1)) //判断是不是文件上传\n                {\n\n                    $postBodyString .= \"$k=\" . urlencode($this->characet($v, $this->charset)) . \"&\";\n                    $encodeArray[$k] = $this->characet($v, $this->charset);\n                } else //文件上传用multipart/form-data，否则用www-form-urlencoded\n                {\n                    $postMultipart = true;\n                    $encodeArray[$k] = new \\CURLFile(substr($v, 1));\n                }\n\n            }\n            unset ($k, $v);\n            curl_setopt($ch, CURLOPT_POST, true);\n            if ($postMultipart) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $encodeArray);\n            } else {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, substr($postBodyString, 0, -1));\n            }\n        }\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n\n            throw new \\Exception(curl_error($ch), 0);\n        } else {\n            $httpStatusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if (200 !== $httpStatusCode) {\n                throw new \\Exception($response, $httpStatusCode);\n            }\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $userid;\n\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid(string $appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function setNotifyUrl(string $notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey(string $rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee(float $totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo(string $outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName(string $orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setUserId(string $userid)\n    {\n        $this->userid = $userid;\n    }\n\n\n    public function sendRedPacket()\n    {\n        $bizContent = [\n            'out_biz_no' => $this->outTradeNo,\n            'trans_amount' => $this->totalFee,\n            'product_code' => 'STD_RED_PACKET',\n            'biz_scene' => 'PERSONAL_PAY',\n            'order_title' => $this->orderName,\n            'payer_info' => [\n                'identity_type' => 'ALIPAY_USER_ID',\n                'identity' => $this->userid,\n            ],\n            'remark' => $this->orderName,\n        ];\n        $data = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n            'app_cert_sn' => $this->appCertSn,\n            'alipay_root_cert_sn' => $this->alipayRootCertSn\n        ];\n\n        $data['sign'] = $this->generateSign($data, 'RSA2');\n        return $this->curlPost('https://openapi.alipay.com/gateway.do', $data);\n    }\n\n\n    public function generateSign(array $params, string $signType = \"RSA\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign(string $data, string $signType = \"RSA\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    public function checkEmpty($value)\n    {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent(array $params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset)\n    {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost(string $url, mixed $postData, array $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        $postBodyString = \"\";\n        $encodeArray = [];\n        $postMultipart = false;\n\n\n        if (is_array($postData) && 0 < count($postData)) {\n\n            foreach ($postData as $k => $v) {\n                if (\"@\" != substr($v, 0, 1)) {\n\n                    $postBodyString .= \"$k=\" . urlencode($this->characet($v, $this->charset)) . \"&\";\n                    $encodeArray[$k] = $this->characet($v, $this->charset);\n                } else {\n                    $postMultipart = true;\n                }\n            }\n            unset($k, $v);\n            curl_setopt($ch, CURLOPT_POST, true);\n            if ($postMultipart) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n            } else {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, substr($postBodyString, 0, -1));\n            }\n        }\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n\n            throw new Exception(curl_error($ch), 0);\n        } else {\n            $httpStatusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if (200 !== $httpStatusCode) {\n                throw new Exception($response, $httpStatusCode);\n            }\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $userid;\n\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid(string $appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setAlipayRootCertSn(string $alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn(string $appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function setNotifyUrl(string $notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey(string $rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee(float $totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo(string $outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName(string $orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setUserId(string $userid)\n    {\n        $this->userid = $userid;\n    }\n\n\n    public function sendRedPacket()\n    {\n        $bizContent = [\n            'product_code' => 'STD_RED_PACKET',\n            'total_amount' => $this->totalFee,\n            'out_trade_no' => $this->outTradeNo,\n            'subject' => $this->orderName,\n            'receiver_id' => $this->userid,\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n\n        return $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n    }\n\n\n    public function generateSign(array $params, string $signType = \"RSA\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign(string $data, string $signType = \"RSA\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    public function checkEmpty($value)\n    {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent(array $params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset)\n    {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost(string $url, mixed $postData, array $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new \\Exception(curl_error($ch), 0);\n        } else {\n            $httpStatusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if (200 !== $httpStatusCode) {\n                throw new \\Exception($response, $httpStatusCode);\n            }\n        }\n        curl_close($ch);\n        return $response;\n    }\n}\n\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $userid;\n\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setAlipayRootCertSn($alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn($appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setUserId($userid)\n    {\n        $this->userid = $userid;\n    }\n\n\n    public function sendRedPacket()\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_biz_no' => $this->outTradeNo,\n                'trans_amount' => $this->totalFee,\n                'product_code' => 'STD_RED_PACKET',\n                'biz_scene' => 'PERSONAL_COLLECTION',\n                'order_title' => $this->orderName,\n                'payee_info' => [\n                    'identity' => $this->userid,\n                    'identity_type' => 'ALIPAY_LOGON_ID'\n                ]\n            ]),\n            'app_cert_sn' => $this->appCertSn,\n            'alipay_root_cert_sn' => $this->alipayRootCertSn\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        return $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    public function checkEmpty($value)\n    {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url, $postData, $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        $postBodyString = \"\";\n        $encodeArray = Array();\n        $postMultipart = false;\n\n\n        if (is_array($postData) && 0 < count($postData)) {\n\n            foreach ($postData as $k => $v) {\n                if (\"@\" != substr($v, 0, 1)) //判断是不是文件上传\n                {\n\n                    $postBodyString .= \"$k=\" . urlencode($this->characet($v, $this->charset)) . \"&\";\n                    $encodeArray[$k] = $this->characet($v, $this->charset);\n                } else //文件上传用multipart/form-data，否则用www-form-urlencoded\n                {\n                    $postMultipart = true;\n                    $encodeArray[$k] = new \\CURLFile(substr($v, 1));\n                }\n\n            }\n            unset($k, $v);\n            curl_setopt($ch, CURLOPT_POST, true);\n            if ($postMultipart) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $encodeArray);\n            } else {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, substr($postBodyString, 0, -1));\n            }\n        }\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n\n            throw new \\Exception(curl_error($ch), 0);\n        } else {\n            $httpStatusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if (200 !== $httpStatusCode) {\n                throw new \\Exception($response, $httpStatusCode);\n            }\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $userid;\n\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setAlipayRootCertSn($alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn($appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setUserId($userid)\n    {\n        $this->userid = $userid;\n    }\n\n\n    public function sendRedPacket()\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_biz_no' => $this->outTradeNo,\n                'trans_amount' => $this->totalFee,\n                'product_code' => 'STD_RED_PACKET',\n                'order_title' => $this->orderName,\n                'payee_info' => [\n                    'identity' => $this->userid,\n                    'identity_type' => 'ALIPAY_LOGON_ID'\n                ]\n            ])\n        ];\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        return $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    public function checkEmpty($value)\n    {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url, $postData, $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        $postBodyString = \"\";\n        $encodeArray = [];\n        $postMultipart = false;\n\n\n        if (is_array($postData) && 0 < count($postData)) {\n\n            foreach ($postData as $k => $v) {\n                if (\"@\" != substr($v, 0, 1)) {\n\n                    $postBodyString .= \"$k=\" . urlencode($this->characet($v, $this->charset)) . \"&\";\n                    $encodeArray[$k] = $this->characet($v, $this->charset);\n                } else {\n                    $postMultipart = true;\n                    $encodeArray[$k] = new \\CURLFile(substr($v, 1));\n                }\n            }\n            unset($k, $v);\n            curl_setopt($ch, CURLOPT_POST, true);\n            if ($postMultipart) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $encodeArray);\n            } else {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, substr($postBodyString, 0, -1));\n            }\n        }\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n\n            throw new Exception(curl_error($ch), 0);\n        } else {\n            $httpStatusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if (200 !== $httpStatusCode) {\n                throw new Exception($response, $httpStatusCode);\n            }\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $userid;\n\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setAlipayRootCertSn($alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn($appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setUserId($userid)\n    {\n        $this->userid = $userid;\n    }\n\n\n    public function sendRedPacket()\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_biz_no' => $this->outTradeNo,\n                'trans_amount' => $this->totalFee,\n                'product_code' => 'STD_RED_PACKET',\n                'biz_scene' => 'PERSONAL_COLLECTION',\n                'order_title' => $this->orderName,\n                'payee_info' => [\n                    'identity' => $this->userid,\n                    'identity_type' => 'ALIPAY_USER_ID'\n                ]\n            ])\n        ];\n\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n\n        return $this->curlPost($url, $params);\n\n    }\n\n\n    public function generateSign(array $params, string $signType = \"RSA\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    public function checkEmpty($value)\n    {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url, $postData, $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        $postBodyString = \"\";\n        $encodeArray = Array();\n        $postMultipart = false;\n\n\n        if (is_array($postData) && 0 < count($postData)) {\n\n            foreach ($postData as $k => $v) {\n                if (\"@\" != substr($v, 0, 1)) //判断是不是文件上传\n                {\n\n                    $postBodyString .= \"$k=\" . urlencode($this->characet($v, $this->charset)) . \"&\";\n                    $encodeArray[$k] = $this->characet($v, $this->charset);\n                } else //文件上传用multipart/form-data，否则用www-form-urlencoded\n                {\n                    $postMultipart = true;\n                    $encodeArray[$k] = new \\CURLFile(substr($v, 1));\n                }\n\n            }\n            unset($k, $v);\n            curl_setopt($ch, CURLOPT_POST, true);\n            if ($postMultipart) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $encodeArray);\n            } else {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, substr($postBodyString, 0, -1));\n            }\n        }\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n\n            throw new \\Exception(curl_error($ch), 0);\n        } else {\n            $httpStatusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if (200 !== $httpStatusCode) {\n                throw new \\Exception($response, $httpStatusCode);\n            }\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $userid;\n\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setAlipayRootCertSn($alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn($appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setUserId($userid)\n    {\n        $this->userid = $userid;\n    }\n\n\n    public function sendRedPacket()\n    {\n        $bizContent = [\n            'product_code' => 'STD_RED_PACKET',\n            'total_amount' => $this->totalFee,\n            'out_trade_no' => $this->outTradeNo,\n            'subject' => $this->orderName,\n            'touch_user_id' => $this->userid,\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode($bizContent),\n        ];\n\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, $params);\n\n        return json_decode($result, true);\n    }\n\n\n    public function generateSign(array $params, string $signType = \"RSA\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    public function checkEmpty($value)\n    {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url, $postData, $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        $postBodyString = \"\";\n        $encodeArray = Array();\n        $postMultipart = false;\n\n\n        if (is_array($postData) && 0 < count($postData)) {\n\n            foreach ($postData as $k => $v) {\n                if (\"@\" != substr($v, 0, 1)) //判断是不是文件上传\n                {\n\n                    $postBodyString .= \"$k=\" . urlencode($this->characet($v, $this->charset)) . \"&\";\n                    $encodeArray[$k] = $this->characet($v, $this->charset);\n                } else //文件上传用multipart/form-data，否则用www-form-urlencoded\n                {\n                    $postMultipart = true;\n                    $encodeArray[$k] = new \\CURLFile(substr($v, 1));\n                }\n\n            }\n            unset($k, $v);\n            curl_setopt($ch, CURLOPT_POST, true);\n            if ($postMultipart) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $encodeArray);\n            } else {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, substr($postBodyString, 0, -1));\n            }\n        }\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n\n            throw new \\Exception(curl_error($ch), 0);\n        } else {\n            $httpStatusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if (200 !== $httpStatusCode) {\n                throw new \\Exception($response, $httpStatusCode);\n            }\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $userid;\n\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setAlipayRootCertSn($alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn($appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setUserId($userid)\n    {\n        $this->userid = $userid;\n    }\n\n\n    public function sendRedPacket()\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_biz_no' => $this->outTradeNo,\n                'trans_amount' => $this->totalFee,\n                'product_code' => 'STD_RED_PACKET',\n                'biz_scene' => 'PERSONAL_COLLECTION',\n                'order_title' => $this->orderName,\n                'payee_info' => [\n                    'identity' => $this->userid,\n                    'identity_type' => 'ALIPAY_LOGON_ID',\n                    'name' => $this->orderName\n                ],\n                'remark' => $this->orderName,\n            ]),\n            'app_cert_sn' => $this->appCertSn,\n            'alipay_root_cert_sn' => $this->alipayRootCertSn,\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n\n        return $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    public function checkEmpty($value)\n    {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url, $postData, $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        $postBodyString = \"\";\n        $encodeArray = [];\n        $postMultipart = false;\n\n\n        if (is_array($postData) && 0 < count($postData)) {\n\n            foreach ($postData as $k => $v) {\n                if (\"@\" != substr($v, 0, 1)) {\n\n                    $postBodyString .= \"$k=\" . urlencode($this->characet($v, $this->charset)) . \"&\";\n                    $encodeArray[$k] = $this->characet($v, $this->charset);\n                } else {\n                    $postMultipart = true;\n                    $encodeArray[$k] = new \\CURLFile(substr($v, 1));\n                }\n            }\n            unset($k, $v);\n            curl_setopt($ch, CURLOPT_POST, true);\n            if ($postMultipart) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $encodeArray);\n            } else {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, substr($postBodyString, 0, -1));\n            }\n        }\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new \\Exception(curl_error($ch), 0);\n        } else {\n            $httpStatusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if (200 !== $httpStatusCode) {\n                throw new \\Exception($response, $httpStatusCode);\n            }\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n}\n\n",
      "<?php\n\nclass AlipayService\n{\n    protected $appId;\n    protected $alipayRootCertSn;\n    protected $appCertSn;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $userid;\n\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setAlipayRootCertSn($alipayRootCertSn)\n    {\n        $this->alipayRootCertSn = $alipayRootCertSn;\n    }\n\n    public function setAppCertSn($appCertSn)\n    {\n        $this->appCertSn = $appCertSn;\n    }\n\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee)\n    {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setUserId($userid)\n    {\n        $this->userid = $userid;\n    }\n\n\n    public function sendRedPacket()\n    {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.fund.trans.uni.transfer',\n            'format' => 'JSON',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_biz_no' => $this->outTradeNo,\n                'trans_amount' => $this->totalFee,\n                'product_code' => 'STD_RED_PACKET',\n                'biz_scene' => 'PERSONAL_COLLECTION',\n                'order_title' => $this->orderName,\n                'payee_info' => [\n                    'identity' => $this->userid,\n                    'identity_type' => 'ALIPAY_USER_ID'\n                ]\n            ])\n        ];\n\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n\n        return $this->curlPost($url, $params);\n\n    }\n\n\n    public function generateSign(array $params, string $signType = \"RSA\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    public function checkEmpty($value)\n    {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url, $postData, $options = [])\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, false);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n        $postBodyString = \"\";\n        $encodeArray = Array();\n        $postMultipart = false;\n\n\n        if (is_array($postData) && 0 < count($postData)) {\n\n            foreach ($postData as $k => $v) {\n                if (\"@\" != substr($v, 0, 1)) //判断是不是文件上传\n                {\n\n                    $postBodyString .= \"$k=\" . urlencode($this->characet($v, $this->charset)) . \"&\";\n                    $encodeArray[$k] = $this->characet($v, $this->charset);\n                } else //文件上传用multipart/form-data，否则用www-form-urlencoded\n                {\n                    $postMultipart = true;\n                    $encodeArray[$k] = new \\CURLFile(substr($v, 1));\n                }\n\n            }\n            unset($k, $v);\n            curl_setopt($ch, CURLOPT_POST, true);\n            if ($postMultipart) {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $encodeArray);\n            } else {\n                curl_setopt($ch, CURLOPT_POSTFIELDS, substr($postBodyString, 0, -1));\n            }\n        }\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n\n\n        if (curl_errno($ch)) {\n\n            throw new \\Exception(curl_error($ch), 0);\n        } else {\n            $httpStatusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if (200 !== $httpStatusCode) {\n                throw new \\Exception($response, $httpStatusCode);\n            }\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a PHP class that provides HTTP client functionality using cURL, supporting various HTTP methods, headers, cookies, proxies, and file uploads.\n\nClass Description: The `requests` class is a static HTTP client implementation that handles HTTP requests through cURL. It supports GET, POST, and other HTTP methods, manages cookies, headers, user agents, proxies, and file uploads. The class maintains connection settings and request history.\n\nAttributes:\n\nVERSION: [string] - The version number of the requests class\nch: [resource|null] - The cURL handle resource\ntimeout: [int|array] - Timeout settings for the connection\nencoding: [string|null] - Request encoding\noutput_encoding: [string|null] - Response encoding\ncookies: [array] - Global cookies to be sent with requests\nrawheaders: [array] - Request headers\ndomain_cookies: [array] - Domain-specific cookies\nheaders: [array] - Response headers\nuseragents: [array] - List of user agent strings\nclient_ips: [array] - List of client IP addresses for spoofing\nproxies: [array] - List of proxy servers\nraw: [string] - Raw response including headers\nhead: [string] - Response headers\ncontent: [string] - Response body\ntext: [string] - Processed response text\ninfo: [array] - cURL request information\nhistory: [int] - HTTP redirect history status code\nstatus_code: [int] - HTTP response status code\nerror: [string] - Error message if request fails\n\nMethods:\n\ninit(): [void] -> [resource] - Initializes the cURL session with default settings\nrequest($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) -> [string|bool] - Executes an HTTP request to the specified URL with given parameters\n_is_url($url) -> [bool] - Validates if the input string is a valid URL\nget_cookies($domain = '') -> [array] - Retrieves cookies for a specific domain\nget_response_headers($header) -> [array] - Parses response headers\nget_response_cookies($header, $domain) -> [void] - Extracts cookies from response headers\nsplit_header_body() -> [array] - Splits response into headers and body\nget_history($header) -> [int] - Gets redirect history from response headers\nget_mimetype($filepath) -> [string] - Gets MIME type of a file",
    "Canonical_solution": "namespace phpspider\\core;\n\nclass requests\n{\n    const VERSION = '2.0.1';\n    protected static $ch = null;\n\n    public static $timeout = 15;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\"requests/2.0.0\");\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = \"\";\n    public static $head = \"\";\n    public static $content = \"\";\n    public static $text = \"\";\n    public static $info = array();\n    public static $history = 302;\n    public static $status_code = 0;\n    public static $error = \"\";\n\n    public static function init()\n    {\n        if (!is_resource(self::$ch))\n        {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, false);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, \"phpspider-requests/\".self::VERSION);\n            if (is_array(self::$timeout))\n            {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n            }\n            else\n            {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, ceil(self::$timeout / 2));\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n            }\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 5);\n            curl_setopt(self::$ch, CURLOPT_NOSIGNAL, true);\n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL)\n    {\n        $method = strtoupper($method);\n        if(!self::_is_url($url))\n        {\n            self::$error = \"You have requested URL ({$url}) is not a valid HTTP address\";\n            return false;\n        }\n\n        if ($method == 'GET' && !empty($fields))\n        {\n            $url = $url.(strpos($url, '?') === false ? '?' : '&').http_build_query($fields);\n        }\n\n        $parse_url = parse_url($url);\n        if (empty($parse_url) || empty($parse_url['host']) || !in_array($parse_url['scheme'], array('http', 'https')))\n        {\n            self::$error = \"No connection adapters were found for '{$url}'\";\n            return false;\n        }\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n\n        if ($method != 'GET')\n        {\n            if ($method == 'POST')\n            {\n                $tmpheaders = array_change_key_case(self::$rawheaders, CASE_LOWER);\n                if (isset($tmpheaders['content-type']) && $tmpheaders['content-type'] == 'application/json')\n                {\n                    curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n                }\n                else\n                {\n                    curl_setopt(self::$ch, CURLOPT_POST, true);\n                }\n\n                $file_fields = array();\n                if (!empty($files))\n                {\n                    foreach ($files as $postname => $file)\n                    {\n                        $filepath = realpath($file);\n                        if (!file_exists($filepath))\n                        {\n                            continue;\n                        }\n                        $filename = basename($filepath);\n                        $type = self::get_mimetype($filepath);\n                        $file_fields[$postname] = curl_file_create($filepath, $type, $filename);\n                    }\n                }\n\n                if (empty($file_fields))\n                {\n                    if (is_array($fields))\n                    {\n                        $fields = http_build_query($fields);\n                    }\n                }\n                else\n                {\n                    if (is_array($fields) && !empty($fields))\n                    {\n                        $fields = array_merge($fields, $file_fields);\n                    }\n                    else\n                    {\n                        $fields = $file_fields;\n                    }\n                }\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n            }\n            else\n            {\n                self::$rawheaders['X-HTTP-Method-Override'] = $method;\n                curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n            }\n        }\n\n        $cookies = self::get_cookies();\n        $domain_cookies = self::get_cookies($parse_url['host']);\n        $cookies = array_merge($cookies, $domain_cookies);\n        if (!empty($cookies))\n        {\n            foreach ($cookies as $key=>$value)\n            {\n                $cookie_arr[] = $key.'='.$value;\n            }\n            $cookies = implode('; ', $cookie_arr);\n            curl_setopt(self::$ch, CURLOPT_COOKIE, $cookies);\n        }\n\n        if (!empty(self::$useragents))\n        {\n            $key = rand(0, count(self::$useragents) - 1);\n            self::$rawheaders['User-Agent'] = self::$useragents[$key];\n        }\n\n        if (!empty(self::$client_ips))\n        {\n            $key = rand(0, count(self::$client_ips) - 1);\n            self::$rawheaders['CLIENT-IP'] = self::$client_ips[$key];\n            self::$rawheaders['X-FORWARDED-FOR'] = self::$client_ips[$key];\n        }\n\n        if (self::$rawheaders)\n        {\n            $http_headers = array();\n            foreach (self::$rawheaders as $k=>$v)\n            {\n                $http_headers[] = $k.': '.$v;\n            }\n            curl_setopt(self::$ch, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        curl_setopt(self::$ch, CURLOPT_ENCODING, 'gzip');\n\n        if ($parse_url['scheme'] == 'https')\n        {\n            curl_setopt(self::$ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt(self::$ch, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        if (self::$proxies)\n        {\n            $key = rand(0, count(self::$proxies) - 1);\n            $proxy = self::$proxies[$key];\n            curl_setopt(self::$ch, CURLOPT_PROXY, $proxy);\n        }\n\n        curl_setopt(self::$ch, CURLOPT_HEADER, true);\n        if ($allow_redirects)\n        {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n        if (self::$raw === false)\n        {\n            self::$error = 'Curl error: ' . curl_error(self::$ch);\n        }\n\n        curl_close(self::$ch);\n\n        list($header, $text) = self::split_header_body();\n        self::$history = self::get_history($header);\n        self::$headers = self::get_response_headers($header);\n        self::get_response_cookies($header, $parse_url['host']);\n        return $text;\n    }\n\n    private static function _is_url($url)\n    {\n        $pattern = \"/\\b(([\\w-]+:\\/\\/?|www[.])[^\\s()<>]+(?:\\([\\w\\d]+\\)|([^[:punct:]\\s]|\\/)))/\";\n        return preg_match($pattern, $url) ? true : false;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [],
    "unmatched_results": [
      "<?php\nclass requests {\n    public static $VERSION = '1.7';\n    protected static $ch = null;\n    public static $timeout = 30;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0',\n        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15'\n    );\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = '';\n    public static $head = '';\n    public static $content = '';\n    public static $text = '';\n    public static $info = array();\n    public static $history = 0;\n    public static $status_code = 0;\n    public static $error = '';\n\n    public static function init() {\n        if (!is_resource(self::$ch)) {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, true);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, self::$useragents[array_rand(self::$useragents)]);\n            if (self::$encoding !== null) {\n                curl_setopt(self::$ch, CURLOPT_ENCODING, self::$encoding);\n            }\n            if (is_array(self::$timeout)) {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n            }\n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) {\n        self::init();\n\n        $method = strtoupper($method);\n        $url = self::_is_url($url) ? $url : 'http://' . $url;\n\n        $headers = self::$rawheaders;\n        $cookies = self::get_cookies($url);\n\n        if (!empty($cookies)) {\n            $headers[] = 'Cookie: ' . implode('; ', $cookies);\n        }\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n        curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n        curl_setopt(self::$ch, CURLOPT_HTTPHEADER, $headers);\n\n        if ($method == 'POST' || $method == 'PUT' || $method == 'PATCH') {\n            if (!empty($files)) {\n                foreach ($files as $key => $file) {\n                    if (file_exists($file)) {\n                        $fields[$key] = curl_file_create($file, self::get_mimetype($file), basename($file));\n                    }\n                }\n            }\n            curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n        }\n\n\n        if ($allow_redirects) {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 10);\n        } else {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, false);\n        }\n\n        if (!empty(self::$proxies)) {\n            $proxy = self::$proxies[array_rand(self::$proxies)];\n            curl_setopt(self::$ch, CURLOPT_PROXY, $proxy);\n        }\n\n        if (!empty(self::$client_ips)) {\n            $client_ip = self::$client_ips[array_rand(self::$client_ips)];\n            curl_setopt(self::$ch, CURLOPT_INTERFACE, $client_ip);\n        }\n\n        if ($cert !== NULL) {\n            curl_setopt(self::$ch, CURLOPT_CAINFO, $cert);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n\n        if (self::$raw === false) {\n            self::$error = curl_error(self::$ch);\n            return false;\n        }\n\n        list(self::$head, self::$content) = self::split_header_body();\n        self::$headers = self::get_response_headers(self::$head);\n        self::get_response_cookies(self::$head, $url);\n        self::$history = self::get_history(self::$head);\n\n        if (self::$output_encoding) {\n            self::$text = mb_convert_encoding(self::$content, self::$output_encoding, self::$encoding);\n        } else {\n            self::$text = self::$content;\n        }\n\n        return self::$text;\n    }\n\n\n    protected static function _is_url($url) {\n        return filter_var($url, FILTER_VALIDATE_URL) !== false;\n    }\n\n    public static function get_cookies($domain = '') {\n        $cookies = array();\n        if (empty($domain)) {\n            $cookies = self::$cookies;\n        } else {\n            $domain = str_replace('www.', '', $domain);\n            foreach (self::$domain_cookies as $domain_pattern => $cks) {\n                if (strpos($domain, $domain_pattern) !== false) {\n                    $cookies = array_merge($cookies, $cks);\n                }\n            }\n        }\n        return $cookies;\n    }\n\n    public static function get_response_headers($header) {\n        $headers = array();\n        $lines = explode(\"\\r\\n\", $header);\n        foreach ($lines as $line) {\n            $parts = explode(': ', $line, 2);\n            if (count($parts) == 2) {\n                $headers[trim($parts[0])] = trim($parts[1]);\n            }\n        }\n        return $headers;\n    }\n\n    public static function get_response_cookies($header, $domain) {\n        preg_match_all('/Set-Cookie: (.*?);/i', $header, $matches);\n        if (!empty($matches[1])) {\n            $domain = str_replace('www.', '', $domain);\n            foreach ($matches[1] as $cookie) {\n                $parts = explode('=', $cookie, 2);\n                $name = trim($parts[0]);\n                $value = trim($parts[1]);\n                self::$domain_cookies[$domain][$name] = $value;\n            }\n        }\n    }\n\n    public static function split_header_body() {\n        $pos = strpos(self::$raw, \"\\r\\n\\r\\n\");\n        if ($pos !== false) {\n            return array(substr(self::$raw, 0, $pos), substr(self::$raw, $pos + 4));\n        }\n        return array(self::$raw, '');\n    }\n\n    public static function get_history($header) {\n        preg_match_all('/HTTP\\/.* ([0-9]{3})/i', $header, $matches);\n        if (!empty($matches[1])) {\n            return (int)end($matches[1]);\n        }\n        return 0;\n    }\n\n    public static function get_mimetype($filepath) {\n        return mime_content_type($filepath);\n    }\n}\n?>\n",
      "<?php\nclass requests {\n    public static $VERSION = '1.7.2';\n    public static $ch = null;\n    public static $timeout = 30;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0',\n        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15'\n    );\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = '';\n    public static $head = '';\n    public static $content = '';\n    public static $text = '';\n    public static $info = array();\n    public static $history = 0;\n    public static $status_code = 0;\n    public static $error = '';\n\n    public static function init() {\n        if (!is_resource(self::$ch)) {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, true);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, self::$useragents[array_rand(self::$useragents)]);\n            if (is_array(self::$timeout)) {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n            }\n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) {\n        self::init();\n        $method = strtoupper($method);\n        $url = self::_is_url($url) ? $url : null;\n\n        if (!$url) return false;\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n        curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n\n        if ($allow_redirects) {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 10);\n        } else {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, false);\n        }\n\n        if (!empty($files)) {\n            foreach ($files as $key => $file) {\n                if (file_exists($file)) {\n                    $fields[$key] = curl_file_create($file, self::get_mimetype($file), basename($file));\n                }\n            }\n            curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n        } else if (!empty($fields) && is_array($fields)) {\n            curl_setopt(self::$ch, CURLOPT_POSTFIELDS, http_build_query($fields));\n        }\n\n\n        $cookies = self::get_cookies($url);\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . $value . '; ';\n        }\n        curl_setopt(self::$ch, CURLOPT_COOKIE, $cookie_string);\n\n\n        if (!empty(self::$rawheaders)) {\n            curl_setopt(self::$ch, CURLOPT_HTTPHEADER, self::$rawheaders);\n        }\n\n        if (!empty(self::$proxies)) {\n            $proxy = self::$proxies[array_rand(self::$proxies)];\n            curl_setopt(self::$ch, CURLOPT_PROXY, $proxy);\n        }\n\n        if (!empty(self::$client_ips)) {\n            $client_ip = self::$client_ips[array_rand(self::$client_ips)];\n            curl_setopt(self::$ch, CURLOPT_INTERFACE, $client_ip);\n        }\n\n        if ($cert) {\n            curl_setopt(self::$ch, CURLOPT_CAINFO, $cert);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n\n        if (self::$raw === false) {\n            self::$error = curl_error(self::$ch);\n            return false;\n        }\n\n        list(self::$head, self::$content) = self::split_header_body();\n        self::$headers = self::get_response_headers(self::$head);\n        self::get_response_cookies(self::$head, $url);\n        self::$history = self::get_history(self::$head);\n\n        if (self::$output_encoding) {\n            self::$text = mb_convert_encoding(self::$content, self::$output_encoding, self::$encoding);\n        } else {\n            self::$text = self::$content;\n        }\n\n        return self::$text;\n    }\n\n\n    private static function _is_url($url) {\n        return filter_var($url, FILTER_VALIDATE_URL) !== false;\n    }\n\n    public static function get_cookies($domain = '') {\n        return !empty($domain) ? self::$domain_cookies[$domain] ?? [] : self::$cookies;\n    }\n\n    public static function get_response_headers($header) {\n        $headers = array();\n        $lines = explode(\"\\r\\n\", $header);\n        foreach ($lines as $line) {\n            $parts = explode(':', $line, 2);\n            if (count($parts) == 2) {\n                $headers[trim($parts[0])] = trim($parts[1]);\n            }\n        }\n        return $headers;\n    }\n\n    public static function get_response_cookies($header, $domain) {\n        preg_match_all('/Set-Cookie: (.*?);/i', $header, $matches);\n        if (!empty($matches[1])) {\n            foreach ($matches[1] as $cookie) {\n                $parts = explode('=', $cookie, 2);\n                $key = trim($parts[0]);\n                $value = trim($parts[1]);\n                self::$cookies[$key] = $value;\n                self::$domain_cookies[$domain][$key] = $value;\n            }\n        }\n    }\n\n    public static function split_header_body() {\n        $parts = explode(\"\\r\\n\\r\\n\", self::$raw, 2);\n        return count($parts) == 2 ? $parts : array($parts[0], '');\n    }\n\n\n    public static function get_history($header) {\n        preg_match_all('/HTTP\\/.* ([0-9]{3})/i', $header, $matches);\n        return isset($matches[1][1]) ? (int)$matches[1][1] : 0;\n    }\n\n    public static function get_mimetype($filepath) {\n        return mime_content_type($filepath);\n    }\n}\n\n?>\n",
      "<?php\nclass requests {\n    public static $VERSION = '1.7';\n    public static $ch = null;\n    public static $timeout = 30;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0',\n        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15'\n    );\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = '';\n    public static $head = '';\n    public static $content = '';\n    public static $text = '';\n    public static $info = array();\n    public static $history = 0;\n    public static $status_code = 0;\n    public static $error = '';\n\n    public static function init() {\n        if (!is_resource(self::$ch)) {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, true);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, self::$useragents[array_rand(self::$useragents)]);\n            curl_setopt(self::$ch, CURLOPT_ENCODING, ''); \n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) {\n        self::init();\n\n        $method = strtoupper($method);\n        $url = self::_is_url($url) ? $url : null;\n\n        if (!$url) return false;\n\n        $cookies = self::get_cookies($url);\n        $domain = parse_url($url, PHP_URL_HOST);\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n        curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n        if (is_array(self::$timeout)) {\n            curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n            curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n        } else {\n            curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n        }\n\n        if ($allow_redirects) {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 10);\n        } else {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, false);\n        }\n\n        if (!empty($cookies)) {\n            curl_setopt(self::$ch, CURLOPT_COOKIE, implode('; ', $cookies));\n        }\n\n        if (!empty(self::$rawheaders)) {\n            curl_setopt(self::$ch, CURLOPT_HTTPHEADER, self::$rawheaders);\n        }\n\n        if (!empty(self::$proxies)) {\n            $proxy = self::$proxies[array_rand(self::$proxies)];\n            curl_setopt(self::$ch, CURLOPT_PROXY, $proxy);\n        }\n\n        if (!empty(self::$client_ips)) {\n            $client_ip = self::$client_ips[array_rand(self::$client_ips)];\n            curl_setopt(self::$ch, CURLOPT_INTERFACE, $client_ip);\n        }\n\n        if ($method == 'POST' || $method == 'PUT' || $method == 'PATCH') {\n            if (!empty($files)) {\n                foreach ($files as $key => $file) {\n                    if (file_exists($file)) {\n                        $fields[$key] = curl_file_create($file, self::get_mimetype($file), basename($file));\n                    }\n                }\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n            } else if (!empty($fields)) {\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, http_build_query($fields));\n            }\n        }\n        if (!is_null($cert)) {\n            curl_setopt(self::$ch, CURLOPT_CAINFO, $cert);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n\n        if (self::$raw === false) {\n            self::$error = curl_error(self::$ch);\n            return false;\n        }\n\n        list(self::$head, self::$content) = self::split_header_body();\n        self::$headers = self::get_response_headers(self::$head);\n        self::get_response_cookies(self::$head, $domain);\n        self::$history = self::get_history(self::$head);\n        self::$text = self::$content;\n        if (self::$output_encoding) {\n            self::$text = mb_convert_encoding(self::$text, self::$output_encoding, self::$encoding);\n        }\n        return self::$text;\n    }\n\n\n    private static function _is_url($url) {\n        return filter_var($url, FILTER_VALIDATE_URL) !== false;\n    }\n\n\n    public static function get_cookies($domain = '') {\n        $cookies = array();\n        if (empty($domain)) {\n            $cookies = self::$cookies;\n        } else {\n            if (isset(self::$domain_cookies[$domain])) {\n                $cookies = self::$domain_cookies[$domain];\n            }\n        }\n        return $cookies;\n    }\n\n    public static function get_response_headers($header) {\n        $headers = array();\n        $header_lines = explode(\"\\r\\n\", $header);\n        foreach ($header_lines as $line) {\n            if (strpos($line, ': ') !== false) {\n                list($key, $value) = explode(': ', $line, 2);\n                $headers[$key] = $value;\n            }\n        }\n        return $headers;\n    }\n\n    public static function get_response_cookies($header, $domain) {\n        preg_match_all('/Set-Cookie: (.*?);/i', $header, $matches);\n        if (!empty($matches[1])) {\n            foreach ($matches[1] as $cookie) {\n                list($name, $value) = explode('=', $cookie, 2);\n                $value = explode(';', $value)[0];\n                self::$domain_cookies[$domain][$name] = $value;\n                self::$cookies[$name] = $value;\n            }\n        }\n    }\n\n    public static function split_header_body() {\n        $pos = strpos(self::$raw, \"\\r\\n\\r\\n\");\n        if ($pos !== false) {\n            return array(substr(self::$raw, 0, $pos), substr(self::$raw, $pos + 4));\n        }\n        return array('', self::$raw);\n    }\n\n    public static function get_history($header) {\n        preg_match_all('/HTTP\\/\\d\\.\\d (\\d{3}) (.*?)\\r\\n/i', $header, $matches);\n        if (!empty($matches[1])) {\n            return (int)end($matches[1]);\n        }\n        return 0;\n    }\n\n    public static function get_mimetype($filepath) {\n        return mime_content_type($filepath);\n    }\n}\n\n?>\n",
      "<?php\nclass requests {\n    public static $VERSION = '1.7';\n    protected static $ch = null;\n    public static $timeout = 30;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0',\n        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15'\n    );\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = '';\n    public static $head = '';\n    public static $content = '';\n    public static $text = '';\n    public static $info = array();\n    public static $history = 0;\n    public static $status_code = 0;\n    public static $error = '';\n\n    public static function init() {\n        if (!is_resource(self::$ch)) {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, true);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, self::$useragents[array_rand(self::$useragents)]);\n            if (is_array(self::$timeout)) {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n            }\n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) {\n        self::init();\n        $method = strtoupper($method);\n        $url = self::_is_url($url) ? $url : 'http://' . $url;\n        $cookies = self::$cookies;\n        if (isset(self::$domain_cookies[$url])) {\n            $cookies = array_merge($cookies, self::$domain_cookies[$url]);\n        }\n        $headers = self::$rawheaders;\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n        curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n        if ($method == 'POST' || $method == 'PUT') {\n            if (!empty($files)) {\n                foreach ($files as $key => $file) {\n                    if (file_exists($file)) {\n                        $fields[$key] = curl_file_create($file, self::get_mimetype($file), basename($file));\n                    }\n                }\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, http_build_query($fields));\n            }\n        }\n\n        if (count(self::$proxies) > 0) {\n            $proxy = self::$proxies[array_rand(self::$proxies)];\n            curl_setopt(self::$ch, CURLOPT_PROXY, $proxy);\n        }\n\n        if (count(self::$client_ips) > 0) {\n            $client_ip = self::$client_ips[array_rand(self::$client_ips)];\n            $headers[] = 'X-Forwarded-For: ' . $client_ip;\n        }\n\n        if (count($headers) > 0) {\n            curl_setopt(self::$ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if (count($cookies) > 0) {\n            $cookie_string = '';\n            foreach ($cookies as $key => $value) {\n                $cookie_string .= $key . '=' . $value . '; ';\n            }\n            curl_setopt(self::$ch, CURLOPT_COOKIE, $cookie_string);\n        }\n\n        if ($allow_redirects) {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 10);\n        } else {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, false);\n        }\n\n        if ($cert) {\n            curl_setopt(self::$ch, CURLOPT_CAINFO, $cert);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n\n        if (self::$raw === false) {\n            self::$error = curl_error(self::$ch);\n            return false;\n        }\n\n        list(self::$head, self::$content) = self::split_header_body();\n        self::$headers = self::get_response_headers(self::$head);\n        self::get_response_cookies(self::$head, $url);\n        self::$history = self::get_history(self::$head);\n\n        if (self::$output_encoding) {\n            self::$text = mb_convert_encoding(self::$content, self::$output_encoding, self::$encoding);\n        } else {\n            self::$text = self::$content;\n        }\n\n        return self::$text;\n    }\n\n\n    protected static function _is_url($url) {\n        return filter_var($url, FILTER_VALIDATE_URL) !== false;\n    }\n\n    public static function get_cookies($domain = '') {\n        return $domain ? self::$domain_cookies[$domain] : self::$cookies;\n    }\n\n    public static function get_response_headers($header) {\n        $headers = array();\n        $lines = explode(\"\\r\\n\", $header);\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function get_response_cookies($header, $domain) {\n        preg_match_all('/Set-Cookie: (.*?);/i', $header, $matches);\n        if (!empty($matches[1])) {\n            foreach ($matches[1] as $cookie) {\n                list($key, $value) = explode('=', $cookie, 2);\n                $key = trim($key);\n                $value = trim($value);\n                self::$domain_cookies[$domain][$key] = $value;\n                self::$cookies[$key] = $value;\n            }\n        }\n    }\n\n    public static function split_header_body() {\n        $pos = strpos(self::$raw, \"\\r\\n\\r\\n\");\n        return array(substr(self::$raw, 0, $pos), substr(self::$raw, $pos + 4));\n    }\n\n    public static function get_history($header) {\n        preg_match_all('/HTTP\\/.* ([0-9]{3})/i', $header, $matches);\n        return isset($matches[1]) ? end($matches[1]) : 0;\n    }\n\n    public static function get_mimetype($filepath) {\n        $finfo = finfo_open(FILEINFO_MIME_TYPE);\n        $mimetype = finfo_file($finfo, $filepath);\n        finfo_close($finfo);\n        return $mimetype;\n    }\n}\n?>\n",
      "<?php\nclass requests {\n    public static $VERSION = '1.7';\n    protected static $ch = null;\n    public static $timeout = 30;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0',\n        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15'\n    );\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = '';\n    public static $head = '';\n    public static $content = '';\n    public static $text = '';\n    public static $info = array();\n    public static $history = 0;\n    public static $status_code = 0;\n    public static $error = '';\n\n    public static function init() {\n        if (!is_resource(self::$ch)) {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, true);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, self::$useragents[array_rand(self::$useragents)]);\n            if (self::$encoding !== null) {\n                curl_setopt(self::$ch, CURLOPT_ENCODING, self::$encoding);\n            }\n            if (is_array(self::$timeout)) {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n            }\n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) {\n        self::init();\n        $method = strtoupper($method);\n        $url = self::_is_url($url) ? $url : 'http://' . $url;\n        $cookies = self::get_cookies($url);\n        $domain = parse_url($url, PHP_URL_HOST);\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n        curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n        if ($method == 'POST' || $method == 'PUT' || $method == 'PATCH') {\n            if (!empty($files)) {\n                foreach ($files as $key => $file) {\n                    if (file_exists($file)) {\n                        $fields[$key] = curl_file_create($file, self::get_mimetype($file), basename($file));\n                    }\n                }\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, http_build_query($fields));\n            }\n        }\n\n        if (!empty(self::$client_ips)) {\n            curl_setopt(self::$ch, CURLOPT_INTERFACE, self::$client_ips[array_rand(self::$client_ips)]);\n        }\n        if (!empty(self::$proxies)) {\n            $proxy = self::$proxies[array_rand(self::$proxies)];\n            curl_setopt(self::$ch, CURLOPT_PROXY, $proxy);\n        }\n        if (!empty($cookies)) {\n            curl_setopt(self::$ch, CURLOPT_COOKIE, implode('; ', $cookies));\n        }\n        if (!empty(self::$rawheaders)) {\n            curl_setopt(self::$ch, CURLOPT_HTTPHEADER, self::$rawheaders);\n        }\n        if ($allow_redirects) {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 10);\n        } else {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, false);\n        }\n        if (!is_null($cert)) {\n            curl_setopt(self::$ch, CURLOPT_CAINFO, $cert);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n\n        if (self::$raw === false) {\n            self::$error = curl_error(self::$ch);\n            return false;\n        }\n\n        list(self::$head, self::$content) = self::split_header_body();\n        self::$headers = self::get_response_headers(self::$head);\n        self::get_response_cookies(self::$head, $domain);\n        self::$history = self::get_history(self::$head);\n\n        if (self::$output_encoding) {\n            self::$text = mb_convert_encoding(self::$content, self::$output_encoding, self::$info['content_type']);\n        } else {\n            self::$text = self::$content;\n        }\n\n        return self::$text;\n    }\n\n\n    protected static function _is_url($url) {\n        return filter_var($url, FILTER_VALIDATE_URL) !== false;\n    }\n\n    public static function get_cookies($domain = '') {\n        $cookies = array();\n        if (empty($domain)) {\n            $cookies = self::$cookies;\n        } else {\n            if (isset(self::$domain_cookies[$domain])) {\n                $cookies = self::$domain_cookies[$domain];\n            }\n        }\n        return $cookies;\n    }\n\n\n    public static function get_response_headers($header) {\n        $headers = array();\n        $lines = explode(\"\\r\\n\", $header);\n        foreach ($lines as $line) {\n            $parts = explode(': ', $line, 2);\n            if (count($parts) == 2) {\n                $headers[strtolower($parts[0])] = $parts[1];\n            }\n        }\n        return $headers;\n    }\n\n    public static function get_response_cookies($header, $domain) {\n        preg_match_all('/Set-Cookie: (.*?);/i', $header, $matches);\n        if (!empty($matches[1])) {\n            foreach ($matches[1] as $cookie) {\n                $parts = explode('=', $cookie, 2);\n                $name = trim($parts[0]);\n                $value = trim($parts[1]);\n                self::$domain_cookies[$domain][$name] = $value;\n                self::$cookies[$name] = $value;\n            }\n        }\n    }\n\n    public static function split_header_body() {\n        $pos = strpos(self::$raw, \"\\r\\n\\r\\n\");\n        return array(substr(self::$raw, 0, $pos), substr(self::$raw, $pos + 4));\n    }\n\n    public static function get_history($header) {\n        preg_match_all('/HTTP\\/\\d\\.\\d (\\d{3})/', $header, $matches);\n        return isset($matches[1][0]) ? (int)$matches[1][0] : 0;\n    }\n\n    public static function get_mimetype($filepath) {\n        return mime_content_type($filepath);\n    }\n}\n\n?>\n",
      "<?php\nclass requests {\n    public static $VERSION = '1.7';\n    public static $ch = null;\n    public static $timeout = 30;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0',\n        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15'\n    );\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = '';\n    public static $head = '';\n    public static $content = '';\n    public static $text = '';\n    public static $info = array();\n    public static $history = 0;\n    public static $status_code = 0;\n    public static $error = '';\n\n    public static function init() {\n        self::$ch = curl_init();\n        curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt(self::$ch, CURLOPT_HEADER, true);\n        curl_setopt(self::$ch, CURLOPT_USERAGENT, self::$useragents[array_rand(self::$useragents)]);\n        curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) {\n        if (!self::_is_url($url)) {\n            self::$error = 'Invalid URL';\n            return false;\n        }\n\n        if (!self::$ch) {\n            self::init();\n        }\n\n        $method = strtoupper($method);\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n        curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n\n        if ($method == 'POST' || $method == 'PUT') {\n            $postfields = array();\n            if ($files) {\n                foreach ($files as $key => $file) {\n                    if (file_exists($file)) {\n                        $postfields[$key] = curl_file_create($file, self::get_mimetype($file), basename($file));\n                    }\n                }\n                foreach ($fields as $key => $value) {\n                    $postfields[$key] = $value;\n                }\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $postfields);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, http_build_query($fields));\n            }\n        }\n\n\n        $cookies = self::get_cookies(parse_url($url, PHP_URL_HOST));\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . $value . '; ';\n        }\n        curl_setopt(self::$ch, CURLOPT_COOKIE, $cookie_string);\n\n\n        if ($allow_redirects) {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 10);\n        }\n\n        if ($cert) {\n            curl_setopt(self::$ch, CURLOPT_CAINFO, $cert);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n\n        if (self::$raw === false) {\n            self::$error = curl_error(self::$ch);\n            return false;\n        }\n\n        list(self::$head, self::$content) = self::split_header_body();\n        self::$text = self::$content;\n        self::$headers = self::get_response_headers(self::$head);\n        self::get_response_cookies(self::$head, parse_url($url, PHP_URL_HOST));\n        self::$history = self::get_history(self::$head);\n\n        return self::$content;\n    }\n\n\n    private static function _is_url($url) {\n        return filter_var($url, FILTER_VALIDATE_URL);\n    }\n\n    public static function get_cookies($domain = '') {\n        if (!$domain) {\n            return self::$cookies;\n        }\n        return isset(self::$domain_cookies[$domain]) ? self::$domain_cookies[$domain] : array();\n    }\n\n\n    public static function get_response_headers($header) {\n        $headers = array();\n        $header_lines = explode(\"\\r\\n\", $header);\n        foreach ($header_lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function get_response_cookies($header, $domain) {\n        preg_match_all('/Set-Cookie: (.*?);/i', $header, $matches);\n        if (!empty($matches[1])) {\n            foreach ($matches[1] as $cookie) {\n                list($name, $value) = explode('=', $cookie, 2);\n                $name = trim($name);\n                $value = trim($value);\n                self::$cookies[$name] = $value;\n                self::$domain_cookies[$domain][$name] = $value;\n            }\n        }\n    }\n\n    public static function split_header_body() {\n        $pos = strpos(self::$raw, \"\\r\\n\\r\\n\");\n        return array(substr(self::$raw, 0, $pos), substr(self::$raw, $pos + 4));\n    }\n\n    public static function get_history($header) {\n        preg_match_all('/HTTP\\/.* ([0-9]{3})/i', $header, $matches);\n        if (isset($matches[1]) && is_array($matches[1]) && count($matches[1]) > 1) {\n            return (int)end($matches[1]);\n        }\n        return 0;\n    }\n\n    public static function get_mimetype($filepath) {\n        return mime_content_type($filepath);\n    }\n}\n?>\n",
      "<?php\nclass requests {\n    const VERSION = '1.0';\n    public static $ch = null;\n    public static $timeout = 30;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array();\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = null;\n    public static $head = null;\n    public static $content = null;\n    public static $text = null;\n    public static $info = null;\n    public static $history = null;\n    public static $status_code = null;\n    public static $error = null;\n\n    public static function init() {\n        self::$ch = curl_init();\n        curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt(self::$ch, CURLOPT_HEADER, true);\n        curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) {\n        if (!self::_is_url($url)) {\n            self::$error = \"Invalid URL: $url\";\n            return false;\n        }\n\n        if (!self::$ch) self::init();\n\n        $method = strtoupper($method);\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n        curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n\n        if ($method == 'POST' || $method == 'PUT') {\n            $postfields = array();\n            if (!empty($files)) {\n                foreach ($files as $key => $file) {\n                    if (file_exists($file)) {\n                        $postfields[$key] = curl_file_create($file, self::get_mimetype($file), basename($file));\n                    }\n                }\n                foreach ($fields as $key => $value) {\n                    $postfields[$key] = $value;\n                }\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $postfields);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, http_build_query($fields));\n            }\n        }\n\n\n        $cookies = self::$cookies;\n        $domain = parse_url($url, PHP_URL_HOST);\n        if (isset(self::$domain_cookies[$domain])) {\n            $cookies = array_merge($cookies, self::$domain_cookies[$domain]);\n        }\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= \"$key=$value; \";\n        }\n        curl_setopt(self::$ch, CURLOPT_COOKIE, $cookie_string);\n\n\n        $headers = self::$rawheaders;\n        curl_setopt(self::$ch, CURLOPT_HTTPHEADER, $headers);\n\n        if ($allow_redirects) {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 5);\n        }\n\n        if ($cert) {\n            curl_setopt(self::$ch, CURLOPT_CAINFO, $cert);\n        }\n\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n\n        list(self::$head, self::$content) = self::split_header_body();\n        self::$headers = self::get_response_headers(self::$head);\n        self::get_response_cookies(self::$head, $domain);\n        self::$history = self::get_history(self::$head);\n\n        self::$text = self::$content;\n\n        if (self::$status_code >= 400) {\n            self::$error = \"HTTP Error \" . self::$status_code;\n            return false;\n        }\n\n        return self::$text;\n    }\n\n\n    protected static function _is_url($url) {\n        return filter_var($url, FILTER_VALIDATE_URL) !== false;\n    }\n\n    public static function get_cookies($domain = '') {\n        if ($domain) {\n            return isset(self::$domain_cookies[$domain]) ? self::$domain_cookies[$domain] : array();\n        }\n        return self::$cookies;\n    }\n\n\n    public static function get_response_headers($header) {\n        $headers = array();\n        $header_lines = explode(\"\\r\\n\", $header);\n        foreach ($header_lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function get_response_cookies($header, $domain) {\n        preg_match_all('/Set-Cookie: (.*?);/i', $header, $matches);\n        if (!empty($matches[1])) {\n            foreach ($matches[1] as $cookie) {\n                list($name, $value) = explode('=', $cookie, 2);\n                self::$domain_cookies[$domain][trim($name)] = trim($value);\n            }\n        }\n    }\n\n    public static function split_header_body() {\n        $header_size = self::$info['header_size'];\n        return array(substr(self::$raw, 0, $header_size), substr(self::$raw, $header_size));\n    }\n\n    public static function get_history($header) {\n        preg_match_all('/HTTP\\/.* ([0-9]{3})/i', $header, $matches);\n        if (isset($matches[1]) && !empty($matches[1])) {\n            return (int)end($matches[1]);\n        }\n        return null;\n    }\n\n    public static function get_mimetype($filepath) {\n        return mime_content_type($filepath);\n    }\n}\n?>\n",
      "<?php\nclass requests {\n    public static $VERSION = '1.7.2';\n    public static $ch = null;\n    public static $timeout = 30;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0',\n        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15'\n    );\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = '';\n    public static $head = '';\n    public static $content = '';\n    public static $text = '';\n    public static $info = array();\n    public static $history = 0;\n    public static $status_code = 0;\n    public static $error = '';\n\n    public static function init() {\n        if (!is_resource(self::$ch)) {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, true);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, self::$useragents[array_rand(self::$useragents)]);\n            if (is_array(self::$timeout)) {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n            }\n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) {\n        self::init();\n        $method = strtoupper($method);\n        $url = self::_is_url($url) ? $url : null;\n        if (!$url) return false;\n\n        $cookies = self::get_cookies($url);\n        $domain = parse_url($url, PHP_URL_HOST);\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n        curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n        if ($method == 'POST' || $method == 'PUT' || $method == 'PATCH') {\n            if (!empty($files)) {\n                foreach ($files as $key => $file) {\n                    if (file_exists($file)) {\n                        $fields[$key] = curl_file_create($file, self::get_mimetype($file), basename($file));\n                    }\n                }\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, http_build_query($fields));\n            }\n        }\n\n        if (!empty(self::$rawheaders)) {\n            curl_setopt(self::$ch, CURLOPT_HTTPHEADER, self::$rawheaders);\n        }\n\n        curl_setopt(self::$ch, CURLOPT_COOKIE, $cookies);\n\n        if ($allow_redirects) {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 10);\n        } else {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, false);\n        }\n\n        if ($cert) {\n            curl_setopt(self::$ch, CURLOPT_CAINFO, $cert);\n        }\n\n        if (!empty(self::$proxies)) {\n            $proxy = self::$proxies[array_rand(self::$proxies)];\n            curl_setopt(self::$ch, CURLOPT_PROXY, $proxy);\n        }\n\n        if (!empty(self::$client_ips)) {\n            $client_ip = self::$client_ips[array_rand(self::$client_ips)];\n            curl_setopt(self::$ch, CURLOPT_INTERFACE, $client_ip);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n\n        if (self::$raw === false) {\n            self::$error = curl_error(self::$ch);\n            return false;\n        }\n\n        list(self::$head, self::$content) = self::split_header_body();\n        self::$headers = self::get_response_headers(self::$head);\n        self::get_response_cookies(self::$head, $domain);\n        self::$history = self::get_history(self::$head);\n\n        if (self::$output_encoding) {\n            self::$text = mb_convert_encoding(self::$content, self::$output_encoding, self::$encoding);\n        } else {\n            self::$text = self::$content;\n        }\n\n        return self::$text;\n    }\n\n\n    private static function _is_url($url) {\n        return filter_var($url, FILTER_VALIDATE_URL) !== false;\n    }\n\n    public static function get_cookies($domain = '') {\n        $cookies = array();\n        if (empty($domain)) {\n            $cookies = self::$cookies;\n        } else {\n            if (isset(self::$domain_cookies[$domain])) {\n                $cookies = self::$domain_cookies[$domain];\n            }\n        }\n        foreach ($cookies as $key => $value) {\n            $cookies[] = $key . '=' . $value;\n        }\n        return implode('; ', $cookies);\n    }\n\n    public static function get_response_headers($header) {\n        $headers = array();\n        $header_lines = explode(\"\\r\\n\", $header);\n        foreach ($header_lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n\n    public static function get_response_cookies($header, $domain) {\n        preg_match_all('/Set-Cookie: (.*?);/i', $header, $matches);\n        if (!empty($matches[1])) {\n            foreach ($matches[1] as $cookie) {\n                list($key, $value) = explode('=', $cookie, 2);\n                $key = trim($key);\n                $value = trim($value);\n                self::$domain_cookies[$domain][$key] = $value;\n                self::$cookies[$key] = $value;\n            }\n        }\n    }\n\n    public static function split_header_body() {\n        $pos = strpos(self::$raw, \"\\r\\n\\r\\n\");\n        return array(substr(self::$raw, 0, $pos), substr(self::$raw, $pos + 4));\n    }\n\n    public static function get_history($header) {\n        preg_match_all('/HTTP\\/.* ([0-9]{3})/i', $header, $matches);\n        return isset($matches[1][0]) ? (int)$matches[1][0] : 0;\n    }\n\n    public static function get_mimetype($filepath) {\n        return mime_content_type($filepath);\n    }\n}\n\n?>\n",
      "<?php\nclass requests {\n    public static $VERSION = '1.7';\n    protected static $ch = null;\n    public static $timeout = 30;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0',\n        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15'\n    );\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = '';\n    public static $head = '';\n    public static $content = '';\n    public static $text = '';\n    public static $info = array();\n    public static $history = 0;\n    public static $status_code = 0;\n    public static $error = '';\n\n    public static function init() {\n        if (!is_resource(self::$ch)) {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, true);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, self::$useragents[array_rand(self::$useragents)]);\n            if (self::$encoding !== null) {\n                curl_setopt(self::$ch, CURLOPT_ENCODING, self::$encoding);\n            }\n            if (is_array(self::$timeout)) {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n            }\n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) {\n        self::init();\n        $method = strtoupper($method);\n        $url = self::_is_url($url) ? $url : 'http://' . $url;\n        $cookies = self::get_cookies($url);\n        $domain = parse_url($url, PHP_URL_HOST);\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n        curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n        if ($method == 'POST' || $method == 'PUT' || $method == 'PATCH') {\n            if (!empty($files)) {\n                foreach ($files as $key => $file) {\n                    if (file_exists($file)) {\n                        $fields[$key] = curl_file_create($file, self::get_mimetype($file), basename($file));\n                    }\n                }\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n            } else {\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, http_build_query($fields));\n            }\n        }\n\n        if (!empty(self::$client_ips)) {\n            curl_setopt(self::$ch, CURLOPT_INTERFACE, self::$client_ips[array_rand(self::$client_ips)]);\n        }\n\n        if (!empty(self::$proxies)) {\n            $proxy = self::$proxies[array_rand(self::$proxies)];\n            curl_setopt(self::$ch, CURLOPT_PROXY, $proxy);\n        }\n\n        if (!empty($cookies)) {\n            curl_setopt(self::$ch, CURLOPT_COOKIE, implode('; ', $cookies));\n        }\n\n        if (!empty(self::$rawheaders)) {\n            curl_setopt(self::$ch, CURLOPT_HTTPHEADER, self::$rawheaders);\n        }\n\n        if ($allow_redirects) {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 10);\n        } else {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, false);\n        }\n\n        if ($cert !== NULL) {\n            curl_setopt(self::$ch, CURLOPT_CAINFO, $cert);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n\n        if (self::$raw === false) {\n            self::$error = curl_error(self::$ch);\n            return false;\n        }\n\n        list(self::$head, self::$content) = self::split_header_body();\n        self::$headers = self::get_response_headers(self::$head);\n        self::get_response_cookies(self::$head, $domain);\n        self::$history = self::get_history(self::$head);\n\n        if (self::$output_encoding) {\n            self::$text = mb_convert_encoding(self::$content, self::$output_encoding, self::$encoding);\n        } else {\n            self::$text = self::$content;\n        }\n\n\n        return self::$text;\n    }\n\n\n    protected static function _is_url($url) {\n        return filter_var($url, FILTER_VALIDATE_URL) !== false;\n    }\n\n    public static function get_cookies($domain = '') {\n        $cookies = array();\n        if (empty($domain)) {\n            $cookies = self::$cookies;\n        } else {\n            if (isset(self::$domain_cookies[$domain])) {\n                $cookies = self::$domain_cookies[$domain];\n            }\n        }\n        return $cookies;\n    }\n\n    public static function get_response_headers($header) {\n        $headers = array();\n        $lines = explode(\"\\r\\n\", $header);\n        foreach ($lines as $line) {\n            $parts = explode(': ', $line, 2);\n            if (count($parts) == 2) {\n                $headers[strtolower($parts[0])] = $parts[1];\n            }\n        }\n        return $headers;\n    }\n\n    public static function get_response_cookies($header, $domain) {\n        preg_match_all('/Set-Cookie: (.*?);/i', $header, $matches);\n        if (!empty($matches[1])) {\n            foreach ($matches[1] as $cookie) {\n                $parts = explode('=', $cookie, 2);\n                $name = trim($parts[0]);\n                $value = trim($parts[1]);\n                self::$domain_cookies[$domain][$name] = $value;\n                self::$cookies[$name] = $value;\n            }\n        }\n    }\n\n    public static function split_header_body() {\n        $parts = explode(\"\\r\\n\\r\\n\", self::$raw, 2);\n        return $parts;\n    }\n\n    public static function get_history($header) {\n        preg_match_all('/HTTP\\/.* ([0-9]{3})/i', $header, $matches);\n        if (!empty($matches[1])) {\n            return (int)end($matches[1]);\n        }\n        return 0;\n    }\n\n    public static function get_mimetype($filepath) {\n        $finfo = finfo_open(FILEINFO_MIME_TYPE);\n        $mimetype = finfo_file($finfo, $filepath);\n        finfo_close($finfo);\n        return $mimetype;\n    }\n}\n\n?>\n",
      "<?php\nclass requests {\n    public static $VERSION = '1.7';\n    protected static $ch = null;\n    public static $timeout = 30;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0',\n        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15'\n    );\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = '';\n    public static $head = '';\n    public static $content = '';\n    public static $text = '';\n    public static $info = array();\n    public static $history = 0;\n    public static $status_code = 0;\n    public static $error = '';\n\n    public static function init() {\n        if (!is_resource(self::$ch)) {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, true);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, self::$useragents[array_rand(self::$useragents)]);\n            if (self::$proxies) {\n                curl_setopt(self::$ch, CURLOPT_PROXY, self::$proxies[array_rand(self::$proxies)]);\n            }\n            if (self::$client_ips) {\n                curl_setopt(self::$ch, CURLOPT_INTERFACE, self::$client_ips[array_rand(self::$client_ips)]);\n            }\n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) {\n        self::init();\n        $method = strtoupper($method);\n        $url = self::_is_url($url) ? $url : null;\n        if (!$url) return false;\n\n        $cookies = self::$cookies;\n        if (isset(self::$domain_cookies[$url])) {\n            $cookies = array_merge($cookies, self::$domain_cookies[$url]);\n        }\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . $value . '; ';\n        }\n        curl_setopt(self::$ch, CURLOPT_COOKIE, $cookie_string);\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n        if (is_array(self::$timeout)) {\n            curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n            curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n        } else {\n            curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n        }\n        curl_setopt(self::$ch, CURLOPT_ENCODING, self::$encoding);\n\n        $headers = self::$rawheaders;\n        if ($method == 'POST') {\n            curl_setopt(self::$ch, CURLOPT_POST, true);\n            if ($files) {\n                foreach ($files as $key => $file) {\n                    if (file_exists($file)) {\n                        $fields[$key] = curl_file_create($file, self::get_mimetype($file), basename($file));\n                    }\n                }\n                $headers[] = 'Content-Type: multipart/form-data';\n            }\n            curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n        } elseif ($method != 'GET') {\n            curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n            curl_setopt(self::$ch, CURLOPT_POSTFIELDS, http_build_query($fields));\n        } else {\n            if ($fields) {\n                $url .= (strpos($url, '?') === false ? '?' : '&') . http_build_query($fields);\n                curl_setopt(self::$ch, CURLOPT_URL, $url);\n            }\n        }\n\n        curl_setopt(self::$ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, $allow_redirects);\n        if ($cert) {\n            curl_setopt(self::$ch, CURLOPT_CAINFO, $cert);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n        if (self::$raw === false) {\n            self::$error = curl_error(self::$ch);\n            return false;\n        }\n\n        list(self::$head, self::$content) = self::split_header_body();\n        self::$headers = self::get_response_headers(self::$head);\n        self::get_response_cookies(self::$head, $url);\n        self::$history = self::get_history(self::$head);\n\n        if (self::$output_encoding) {\n            self::$text = mb_convert_encoding(self::$content, self::$output_encoding, self::$encoding);\n        } else {\n            self::$text = self::$content;\n        }\n\n        return self::$text;\n    }\n\n\n    protected static function _is_url($url) {\n        return filter_var($url, FILTER_VALIDATE_URL) !== false;\n    }\n\n    public static function get_cookies($domain = '') {\n        return $domain ? self::$domain_cookies[$domain] : self::$cookies;\n    }\n\n    public static function get_response_headers($header) {\n        $headers = array();\n        foreach (explode(\"\\r\\n\", $header) as $i => $line) {\n            if ($i === 0) continue;\n            list($key, $value) = explode(': ', $line, 2);\n            $headers[$key] = $value;\n        }\n        return $headers;\n    }\n\n    public static function get_response_cookies($header, $domain) {\n        preg_match_all('/Set-Cookie: (.*?);/i', $header, $matches);\n        foreach ($matches[1] as $c) {\n            list($key, $value) = explode('=', $c, 2);\n            self::$domain_cookies[$domain][$key] = $value;\n            self::$cookies[$key] = $value;\n        }\n    }\n\n    public static function split_header_body() {\n        $pos = strpos(self::$raw, \"\\r\\n\\r\\n\");\n        return array(substr(self::$raw, 0, $pos), substr(self::$raw, $pos + 4));\n    }\n\n    public static function get_history($header) {\n        preg_match_all('/HTTP\\/.* ([0-9]{3})/i', $header, $matches);\n        return isset($matches[1]) ? end($matches[1]) : 0;\n    }\n\n    public static function get_mimetype($filepath) {\n        return mime_content_type($filepath);\n    }\n}\n\n"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a PHP class that implements HTTP scraping functionality using cURL to make requests to a specified URL with query parameters and handle the response.\n\nClass Description: The HttpScraper class extends a BaseScraper and provides functionality to make HTTP GET requests using cURL. It includes timeout configuration and basic error handling for HTTP status codes.\n\nAttributes:\ntimeout: [int] - The maximum time in seconds the cURL request is allowed to take.\n\nMethods:\nrequest: [Name]([string $url, array $query]) -> [string|null] - Makes an HTTP GET request to the specified URL with the given query parameters. Returns the response body as a string if the request is successful (HTTP 200), or null otherwise.",
    "Canonical_solution": "use Rych\\Bencode\\Bencode;\nuse Rych\\Bencode\\Exception\\RuntimeException;\n\nclass HttpScraper extends BaseScraper\n{\n    protected $timeout = 30;\n\n    public function request($url, array $query)\n    {\n        $ch = curl_init();\n        curl_setopt_array($ch, [\n            CURLOPT_URL => $url . '?' . join('&', $query),\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => $this->timeout,\n        ]);\n\n        $result = curl_exec($ch);\n\n        $code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($code != 200) {\n            $result = null;\n        }\n\n        curl_close($ch);\n\n        return $result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass BaseScraper {}\n\nclass HttpScraper extends BaseScraper\n{\n    private int $timeout;\n\n    public function __construct(int $timeout = 5)\n    {\n        $this->timeout = $timeout;\n    }\n\n    public function request(string $url, array $query = []): ?string\n    {\n        $queryString = http_build_query($query);\n        $fullUrl = $url . ($queryString ? '?' . $queryString : '');\n\n        $ch = curl_init($fullUrl);\n\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => $this->timeout,\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($httpCode === 200) {\n            return $response;\n        }\n\n        return null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass BaseScraper {}\n\nclass HttpScraper extends BaseScraper\n{\n    private int $timeout;\n\n    public function __construct(int $timeout = 5)\n    {\n        $this->timeout = $timeout;\n    }\n\n    public function request(string $url, array $query = []): ?string\n    {\n        $queryString = http_build_query($query);\n        $fullUrl = $url . ($queryString ? '?' . $queryString : '');\n\n        $ch = curl_init($fullUrl);\n\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => $this->timeout,\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($httpCode === 200 && $response !== false) {\n            return $response;\n        }\n\n        return null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass BaseScraper {}\n\nclass HttpScraper extends BaseScraper\n{\n    private int $timeout;\n\n    public function __construct(int $timeout = 5)\n    {\n        $this->timeout = $timeout;\n    }\n\n    public function request(string $url, array $query = []): ?string\n    {\n        $queryString = http_build_query($query);\n        $fullUrl = $url . ($queryString ? '?' . $queryString : '');\n\n        $ch = curl_init($fullUrl);\n\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => $this->timeout,\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($httpCode === 200) {\n            return $response;\n        }\n\n        return null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass BaseScraper {}\n\nclass HttpScraper extends BaseScraper\n{\n    private int $timeout;\n\n    public function __construct(int $timeout = 5)\n    {\n        $this->timeout = $timeout;\n    }\n\n    public function request(string $url, array $query = []): ?string\n    {\n        $queryString = http_build_query($query);\n        $fullUrl = $url . ($queryString ? '?' . $queryString : '');\n\n        $ch = curl_init($fullUrl);\n\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => $this->timeout,\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($httpCode === 200) {\n            return $response;\n        }\n\n        return null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass BaseScraper {}\n\nclass HttpScraper extends BaseScraper\n{\n    private int $timeout;\n\n    public function __construct(int $timeout = 5)\n    {\n        $this->timeout = $timeout;\n    }\n\n    public function request(string $url, array $query = []): ?string\n    {\n        $queryString = http_build_query($query);\n        $fullUrl = $url . ($queryString ? '?' . $queryString : '');\n\n        $ch = curl_init($fullUrl);\n\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => $this->timeout,\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($httpCode === 200) {\n            return $response;\n        }\n\n        return null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass BaseScraper {}\n\nclass HttpScraper extends BaseScraper\n{\n    private int $timeout;\n\n    public function __construct(int $timeout = 5)\n    {\n        $this->timeout = $timeout;\n    }\n\n    public function request(string $url, array $query = []): ?string\n    {\n        $queryString = http_build_query($query);\n        $fullUrl = $url . ($queryString ? '?' . $queryString : '');\n\n        $ch = curl_init($fullUrl);\n\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => $this->timeout,\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($httpCode === 200 && $response !== false) {\n            return $response;\n        }\n\n        return null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass BaseScraper {}\n\nclass HttpScraper extends BaseScraper\n{\n    private int $timeout;\n\n    public function __construct(int $timeout = 5)\n    {\n        $this->timeout = $timeout;\n    }\n\n    public function request(string $url, array $query = []): ?string\n    {\n        $queryString = http_build_query($query);\n        $fullUrl = $url . ($queryString ? '?' . $queryString : '');\n\n        $ch = curl_init($fullUrl);\n\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => $this->timeout,\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($httpCode === 200) {\n            return $response;\n        }\n\n        return null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass BaseScraper {}\n\nclass HttpScraper extends BaseScraper\n{\n    private int $timeout;\n\n    public function __construct(int $timeout = 5)\n    {\n        $this->timeout = $timeout;\n    }\n\n    public function request(string $url, array $query = []): ?string\n    {\n        $queryString = http_build_query($query);\n        $fullUrl = $url . ($queryString ? '?' . $queryString : '');\n\n        $ch = curl_init($fullUrl);\n\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => $this->timeout,\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($httpCode === 200) {\n            return $response;\n        }\n\n        return null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass BaseScraper {}\n\nclass HttpScraper extends BaseScraper\n{\n    private int $timeout;\n\n    public function __construct(int $timeout = 5)\n    {\n        $this->timeout = $timeout;\n    }\n\n    public function request(string $url, array $query = []): ?string\n    {\n        $queryString = http_build_query($query);\n        $fullUrl = $url . ($queryString ? '?' . $queryString : '');\n\n        $ch = curl_init($fullUrl);\n\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => $this->timeout,\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($httpCode === 200) {\n            return $response;\n        }\n\n        return null;\n    }\n}\n\n?>\n",
      "<?php\n\nclass BaseScraper {}\n\nclass HttpScraper extends BaseScraper\n{\n    private int $timeout;\n\n    public function __construct(int $timeout = 5)\n    {\n        $this->timeout = $timeout;\n    }\n\n    public function request(string $url, array $query = []): ?string\n    {\n        $queryString = http_build_query($query);\n        $fullUrl = $url . ($queryString ? '?' . $queryString : '');\n\n        $ch = curl_init($fullUrl);\n\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => $this->timeout,\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        if ($httpCode === 200 && $response !== false) {\n            return $response;\n        }\n\n        return null;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Implement a class that handles file downloads using cURL in PHP, with support for temporary file management and cleanup.\n\nClass Description: The CurlDownloader class provides functionality to download files from a given URL using cURL, storing them in a temporary directory, and managing the downloaded files including cleanup operations.\n\nAttributes:\n- tempDir: string - The directory path where temporary files will be stored. Defaults to system temp directory if not specified.\n- outputFile: string - The path to the downloaded file.\n\nMethods:\n- setTempDir(string $tempDir) -> void - Sets the temporary directory for storing downloaded files.\n- download(string $url) -> bool - Downloads a file from the specified URL using cURL. Returns true on success, throws ErrorException on failure.\n- getFilename() -> string - Returns the path to the downloaded file.\n- cleanup() -> void - Removes the downloaded file if it exists.\n\nInput:\n- For setTempDir(): A string representing the directory path.\n- For download(): A string representing the URL to download from.\n\nOutput:\n- For download(): A boolean indicating success (true) or failure (false).\n- For getFilename(): A string representing the path to the downloaded file.\n- setTempDir() and cleanup() have no return value.",
    "Canonical_solution": "use Psy\\Exception\\ErrorException;\nuse Psy\\Shell;\n\nclass CurlDownloader implements Downloader\n{\n    private $tempDir = null;\n    private $outputFile = null;\n\n    public function setTempDir(string $tempDir)\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $tempDir = $this->tempDir ?: \\sys_get_temp_dir();\n        $this->outputFile = \\tempnam($tempDir, 'psysh-archive-');\n        $targetName = $this->outputFile.'.tar.gz';\n\n        if (!\\rename($this->outputFile, $targetName)) {\n            return false;\n        }\n\n        $this->outputFile = $targetName;\n\n        $outputHandle = \\fopen($this->outputFile, 'w');\n        if (!$outputHandle) {\n            return false;\n        }\n        $curl = \\curl_init();\n        \\curl_setopt_array($curl, [\n            \\CURLOPT_FAILONERROR    => true,\n            \\CURLOPT_HEADER         => 0,\n            \\CURLOPT_FOLLOWLOCATION => true,\n            \\CURLOPT_TIMEOUT        => 10,\n            \\CURLOPT_FILE           => $outputHandle,\n            \\CURLOPT_HTTPHEADER     => [\n                'User-Agent' => 'PsySH/'.Shell::VERSION,\n            ],\n        ]);\n        \\curl_setopt($curl, \\CURLOPT_URL, $url);\n        $result = \\curl_exec($curl);\n        $error = \\curl_error($curl);\n        \\curl_close($curl);\n\n        \\fclose($outputHandle);\n\n        if (!$result) {\n            throw new ErrorException('cURL Error: '.$error);\n        }\n\n        return (bool) $result;\n    }\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup()\n    {\n        if (\\file_exists($this->outputFile)) {\n            \\unlink($this->outputFile);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct()\n    {\n        $this->tempDir = sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_') . '.tmp';\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n\n        if ($success === false) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(curl_error($ch));\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct()\n    {\n        $this->tempDir = sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_') . '.tmp';\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n\n        if ($success === false) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(curl_error($ch));\n        }\n\n        fclose($fp);\n        curl_close($ch);\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct()\n    {\n        $this->tempDir = sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_', true);\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n\n        if ($success === false) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(curl_error($ch));\n        }\n\n        curl_close($ch);\n        fclose($fp);\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct()\n    {\n        $this->tempDir = sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_') . '.tmp';\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n\n        if ($success === false) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(curl_error($ch));\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct()\n    {\n        $this->tempDir = sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_') . '.tmp';\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n\n        if ($success === false) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(curl_error($ch));\n        }\n\n        fclose($fp);\n        curl_close($ch);\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct()\n    {\n        $this->tempDir = sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_') . '.tmp';\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n\n        if ($success === false) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(curl_error($ch));\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct()\n    {\n        $this->tempDir = sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_', true);\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n\n        if ($success === false) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(curl_error($ch));\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct()\n    {\n        $this->tempDir = sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_') . '.tmp';\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n\n        if ($success === false) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(curl_error($ch));\n        }\n\n        curl_close($ch);\n        fclose($fp);\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct()\n    {\n        $this->tempDir = sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_', true);\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_FAILONERROR, true);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(curl_error($ch));\n        }\n\n        curl_close($ch);\n        fclose($fp);\n\n        return true;\n    }\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass CurlDownloader\n{\n    private string $tempDir;\n    private string $outputFile;\n\n    public function __construct()\n    {\n        $this->tempDir = sys_get_temp_dir();\n    }\n\n    public function setTempDir(string $tempDir): void\n    {\n        $this->tempDir = $tempDir;\n    }\n\n    public function download(string $url): bool\n    {\n        $this->outputFile = $this->tempDir . '/' . uniqid('download_') . '.tmp';\n        $fp = fopen($this->outputFile, 'w+');\n\n        if (!$fp) {\n            throw new ErrorException(\"Unable to open temporary file for writing.\");\n        }\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $success = curl_exec($ch);\n\n        if ($success === false) {\n            fclose($fp);\n            unlink($this->outputFile);\n            throw new ErrorException(curl_error($ch));\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return true;\n    }\n\n\n    public function getFilename(): string\n    {\n        return $this->outputFile;\n    }\n\n    public function cleanup(): void\n    {\n        if (file_exists($this->outputFile)) {\n            unlink($this->outputFile);\n        }\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a PHP HTTP client class that handles various types of HTTP requests (GET, POST, PUT, DELETE, multipart POST) using cURL, with proper error handling and response processing.\n\nClass Description: The Client class provides static methods to send HTTP requests and process responses. It handles request construction, cURL session management, response parsing, and error handling.\n\nAttributes: (This class has no instance attributes as all methods are static)\n\nMethods:\n\n1. get(string $url, array $headers = array()) -> Response\n   - Sends a GET request to the specified URL with optional headers\n   - Returns a Response object containing status code, headers, body, and timing information\n\n2. delete(string $url, array $headers = array()) -> Response\n   - Sends a DELETE request to the specified URL with optional headers\n   - Returns a Response object\n\n3. post(string $url, mixed $body, array $headers = array()) -> Response\n   - Sends a POST request with body content to the specified URL\n   - Returns a Response object\n\n4. put(string $url, mixed $body, array $headers = array()) -> Response\n   - Sends a PUT request with body content to the specified URL\n   - Returns a Response object\n\n5. multipartPost(\n     string $url,\n     array $fields,\n     string $name,\n     string $fileName,\n     string $fileBody,\n     string $mimeType = null,\n     array $headers = array()\n   ) -> Response\n   - Sends a multipart/form-data POST request with file upload\n   - Returns a Response object\n\n6. sendRequest(Request $request) -> Response\n   - Internal method that executes the cURL request\n   - Handles cURL initialization, option setting, execution, and cleanup\n   - Returns a Response object with request results\n\n7. userAgent() -> string\n   - Generates a User-Agent string with SDK, system, and PHP version information\n   - Returns the formatted User-Agent string\n\n8. parseHeaders(string $raw) -> array\n   - Parses raw HTTP response headers into an associative array\n   - Returns array of headers with normalized keys\n\n9. escapeQuotes(string $str) -> string\n   - Escapes quotes in a string for use in multipart form data\n   - Returns the escaped string\n\n10. ucwordsHyphen(string $str) -> string\n    - Converts hyphenated header names to proper case (e.g., 'content-type' becomes 'Content-Type')\n    - Returns the properly cased string",
    "Canonical_solution": "namespace Qiniu\\Http;\n\nuse Qiniu\\Config;\n\nfinal class Client\n{\n    public static function get($url, array $headers = array())\n    {\n        $request = new Request('GET', $url, $headers);\n        return self::sendRequest($request);\n    }\n\n    public static function delete($url, array $headers = array())\n    {\n        $request = new Request('DELETE', $url, $headers);\n        return self::sendRequest($request);\n    }\n\n    public static function post($url, $body, array $headers = array())\n    {\n        $request = new Request('POST', $url, $headers, $body);\n        return self::sendRequest($request);\n    }\n\n    public static function PUT($url, $body, array $headers = array())\n    {\n        $request = new Request('PUT', $url, $headers, $body);\n        return self::sendRequest($request);\n    }\n\n    public static function multipartPost(\n        $url,\n        $fields,\n        $name,\n        $fileName,\n        $fileBody,\n        $mimeType = null,\n        array $headers = array()\n    ) {\n        $data = array();\n        $mimeBoundary = md5(microtime());\n\n        foreach ($fields as $key => $val) {\n            array_push($data, '--' . $mimeBoundary);\n            array_push($data, \"Content-Disposition: form-data; name=\\\"$key\\\"\");\n            array_push($data, '');\n            array_push($data, $val);\n        }\n\n        array_push($data, '--' . $mimeBoundary);\n        $finalMimeType = empty($mimeType) ? 'application/octet-stream' : $mimeType;\n        $finalFileName = self::escapeQuotes($fileName);\n        array_push($data, \"Content-Disposition: form-data; name=\\\"$name\\\"; filename=\\\"$finalFileName\\\"\");\n        array_push($data, \"Content-Type: $finalMimeType\");\n        array_push($data, '');\n        array_push($data, $fileBody);\n\n        array_push($data, '--' . $mimeBoundary . '--');\n        array_push($data, '');\n\n        $body = implode(\"\\r\\n\", $data);\n        $contentType = 'multipart/form-data; boundary=' . $mimeBoundary;\n        $headers['Content-Type'] = $contentType;\n        $request = new Request('POST', $url, $headers, $body);\n        return self::sendRequest($request);\n    }\n\n    public static function sendRequest($request)\n    {\n        $t1 = microtime(true);\n        $ch = curl_init();\n        $options = array(\n            CURLOPT_USERAGENT => self::userAgent(),\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HEADER => true,\n            CURLOPT_NOBODY => false,\n            CURLOPT_CUSTOMREQUEST => $request->method,\n            CURLOPT_URL => $request->url,\n        );\n        if (!ini_get('safe_mode') && !ini_get('open_basedir')) {\n            $options[CURLOPT_FOLLOWLOCATION] = true;\n        }\n        if (!empty($request->headers)) {\n            $headers = array();\n            foreach ($request->headers as $key => $val) {\n                array_push($headers, \"$key: $val\");\n            }\n            $options[CURLOPT_HTTPHEADER] = $headers;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, array('Expect:'));\n        if (!empty($request->body)) {\n            $options[CURLOPT_POSTFIELDS] = $request->body;\n        }\n        curl_setopt_array($ch, $options);\n        $result = curl_exec($ch);\n        $t2 = microtime(true);\n        $duration = round($t2 - $t1, 3);\n        $ret = curl_errno($ch);\n        if ($ret !== 0) {\n            $r = new Response(-1, $duration, array(), null, curl_error($ch));\n            curl_close($ch);\n            return $r;\n        }\n        $code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = self::parseHeaders(substr($result, 0, $header_size));\n        $body = substr($result, $header_size);\n        curl_close($ch);\n        return new Response($code, $duration, $headers, $body, null);\n    }\n\n    private static function userAgent()\n    {\n        $sdkInfo = \"QiniuPHP/\" . Config::SDK_VER;\n        $systemInfo = php_uname(\"s\");\n        $machineInfo = php_uname(\"m\");\n        $envInfo = \"($systemInfo/$machineInfo)\";\n        $phpVer = phpversion();\n        $ua = \"$sdkInfo $envInfo PHP/$phpVer\";\n        return $ua;\n    }\n\n    private static function parseHeaders($raw)\n    {\n        $headers = array();\n        $headerLines = explode(\"\\r\\n\", $raw);\n        foreach ($headerLines as $line) {\n            $headerLine = trim($line);\n            $kv = explode(':', $headerLine);\n            if (count($kv) > 1) {\n                $kv[0] =self::ucwordsHyphen($kv[0]);\n                $headers[$kv[0]] = trim($kv[1]);\n            }\n        }\n        return $headers;\n    }\n\n    private static function escapeQuotes($str)\n    {\n        $find = array(\"\\\\\", \"\\\"\");\n        $replace = array(\"\\\\\\\\\", \"\\\\\\\"\");\n        return str_replace($find, $replace, $str);\n    }\n    \n    private static function ucwordsHyphen($str)\n    {\n        return str_replace('- ', '-', ucwords(str_replace('-', '- ', $str)));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function put(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('PUT', $url, $body, $headers));\n    }\n\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n\n        foreach ($fields as $key => $value) {\n            $body .= \"--\" . $boundary . \"\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . $key . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n\n        $body .= \"--\" . $boundary . \"\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . $name . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--\" . $boundary . \"--\\r\\n\";\n\n        $headers['Content-Type'] = 'multipart/form-data; boundary=' . $boundary;\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->url);\n\n        $headers = array_merge(['User-Agent' => self::userAgent()], $request->headers);\n\n        $curlHeaders = [];\n        foreach ($headers as $key => $value) {\n            $curlHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_CUSTOMREQUEST => $request->method,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HEADER => true,\n            CURLOPT_HTTPHEADER => $curlHeaders,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_MAXREDIRS => 10,\n            CURLOPT_TIMEOUT => 30,\n        ]);\n\n        if ($request->body !== null) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->body);\n        }\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n        $info = curl_getinfo($ch);\n        curl_close($ch);\n\n        if ($errno) {\n            throw new Exception(\"cURL error: \" . $error, $errno);\n        }\n\n        list($headerStr, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $headers = self::parseHeaders($headerStr);\n\n        return new Response($info['http_code'], $headers, $body, $info);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (Generic Client)';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $raw) as $header) {\n            if (strpos($header, ':') !== false) {\n                list($key, $value) = explode(':', $header, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', ' ', ucwords(str_replace('-', ' ', $str)));\n    }\n}\n\nclass Request\n{\n    public function __construct(\n        public string $method,\n        public string $url,\n        public mixed $body,\n        public array $headers\n    ) {\n    }\n}\n\nclass Response\n{\n    public function __construct(\n        public int $statusCode,\n        public array $headers,\n        public string $body,\n        public array $info\n    ) {\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function put(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('PUT', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"{$key}\\\"\\r\\n\\r\\n\";\n            $body .= \"{$value}\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"{$name}\\\"; filename=\\\"{$fileName}\\\"\\r\\n\";\n        $body .= \"Content-Type: {$mimeType}\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->body);\n        }\n\n        $requestHeaders = $request->headers;\n        if (!isset($requestHeaders['Expect'])) {\n            $requestHeaders['Expect'] = ''; //Fixes 417 Expectation Failed\n        }\n\n        $headers = [];\n        foreach ($requestHeaders as $key => $value) {\n            $headers[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        $response = curl_exec($ch);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $totalTime = curl_getinfo($ch, CURLINFO_TOTAL_TIME);\n\n        $responseHeaders = substr($response, 0, $headerSize);\n        $responseBody = substr($response, $headerSize);\n\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch));\n        }\n\n        curl_close($ch);\n\n        return new Response($statusCode, self::parseHeaders($responseHeaders), $responseBody, $totalTime);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (' . php_uname('s') . ')';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = array();\n        $lines = explode(\"\\r\\n\", $raw);\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', ' ', ucwords(str_replace('-', ' ', $str)));\n    }\n}\n\nclass Request\n{\n    public function __construct(\n        public string $method,\n        public string $url,\n        public mixed $body,\n        public array $headers\n    ) {\n    }\n}\n\nclass Response\n{\n    public function __construct(\n        public int $statusCode,\n        public array $headers,\n        public string $body,\n        public float $totalTime\n    ) {\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function put(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('PUT', $url, $body, $headers));\n    }\n\n\n    public static function multipartPost(\n        string $url,\n        array $fields,\n        string $name,\n        string $fileName,\n        string $fileBody,\n        string $mimeType = null,\n        array $headers = array()\n    ): Response {\n        $boundary = uniqid();\n        $body = '';\n\n        foreach ($fields as $key => $value) {\n            $body .= \"--\" . $boundary . \"\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($key) . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n\n        $body .= \"--\" . $boundary . \"\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . self::escapeQuotes($name) . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        if ($mimeType) {\n            $body .= \"Content-Type: \" . $mimeType . \"\\r\\n\";\n        }\n        $body .= \"\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--\" . $boundary . \"--\\r\\n\";\n\n        $headers['Content-Type'] = 'multipart/form-data; boundary=' . $boundary;\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->url);\n\n        $headers = array_merge(['User-Agent' => self::userAgent()], $request->headers);\n\n        $curlHeaders = [];\n        foreach ($headers as $key => $value) {\n            $curlHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_CUSTOMREQUEST => $request->method,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HEADER => true,\n            CURLOPT_HTTPHEADER => $curlHeaders,\n            CURLOPT_CONNECTTIMEOUT => 10,\n            CURLOPT_TIMEOUT => 60\n        ]);\n\n        if ($request->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->body);\n        }\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n        $info = curl_getinfo($ch);\n        curl_close($ch);\n\n        if ($errno) {\n            throw new Exception($error, $errno);\n        }\n\n        list($headerStr, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $headers = self::parseHeaders($headerStr);\n\n        return new Response($info['http_code'], $headers, $body, $info);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (' . php_uname('s') . ')';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", $raw);\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', ' ', ucwords(str_replace('-', ' ', $str)));\n    }\n}\n\nclass Request\n{\n    public function __construct(\n        public string $method,\n        public string $url,\n        public mixed $body,\n        public array $headers\n    ) {\n    }\n}\n\nclass Response\n{\n    public function __construct(\n        public int $statusCode,\n        public array $headers,\n        public string $body,\n        public array $info\n    ) {\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function put(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('PUT', $url, $body, $headers));\n    }\n\n\n    public static function multipartPost(\n        string $url,\n        array $fields,\n        string $name,\n        string $fileName,\n        string $fileBody,\n        string $mimeType = null,\n        array $headers = array()\n    ): Response {\n        $boundary = uniqid();\n        $body = '';\n\n        foreach ($fields as $key => $value) {\n            $body .= \"--\" . $boundary . \"\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . $key . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n\n        $body .= \"--\" . $boundary . \"\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . $name . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        if ($mimeType) {\n            $body .= \"Content-Type: \" . $mimeType . \"\\r\\n\";\n        }\n        $body .= \"\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--\" . $boundary . \"--\\r\\n\";\n\n\n        $headers['Content-Type'] = 'multipart/form-data; boundary=' . $boundary;\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->url);\n\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->body);\n        }\n\n        $processedHeaders = [];\n\n        foreach ($request->headers as $key => $value) {\n            $processedHeaders[] = self::ucwordsHyphen($key) . ': ' . $value;\n        }\n\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $processedHeaders);\n\n\n        $response = curl_exec($ch);\n        $info = curl_getinfo($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        $headerSize = $info['header_size'];\n        $headers = self::parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n\n        return new Response($info['http_code'], $headers, $body, $info['total_time'], $error);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (Something/1.0)';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", trim($raw));\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                [$key, $value] = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', ' ', ucwords(str_replace('-', ' ', $str)));\n    }\n}\n\nclass Request\n{\n    public function __construct(\n        public string $method,\n        public string $url,\n        public mixed $body,\n        public array $headers\n    ) {\n    }\n}\n\nclass Response\n{\n    public function __construct(\n        public int $statusCode,\n        public array $headers,\n        public string $body,\n        public float $totalTime,\n        public string $error\n    ) {\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function put(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('PUT', $url, $body, $headers));\n    }\n\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n\n        foreach ($fields as $key => $value) {\n            $body .= \"--\" . $boundary . \"\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . $key . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n\n        $body .= \"--\" . $boundary . \"\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . $name . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--\" . $boundary . \"--\\r\\n\";\n\n        $headers['Content-Type'] = 'multipart/form-data; boundary=' . $boundary;\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->body);\n        }\n\n        $headers = $request->headers;\n        if (!isset($headers['Expect'])) {\n            $headers['Expect'] = '';\n        }\n\n        $formattedHeaders = [];\n        foreach ($headers as $key => $value) {\n            $formattedHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $formattedHeaders);\n\n\n        $response = curl_exec($ch);\n        $info = curl_getinfo($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        list($headerStr, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $headers = self::parseHeaders($headerStr);\n\n        return new Response($info['http_code'], $headers, $body, $info['total_time'], $error);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (Something/1.0)';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $raw) as $header) {\n            if (strpos($header, ':') !== false) {\n                list($key, $value) = explode(':', $header, 2);\n                $headers[self::ucwordsHyphen(trim($key))] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', ' ', ucwords(strtolower(str_replace('_', '-', $str))));\n    }\n}\n\nclass Request\n{\n    public function __construct(\n        public string $method,\n        public string $url,\n        public mixed $body,\n        public array $headers\n    ) {\n    }\n}\n\nclass Response\n{\n    public function __construct(\n        public int $statusCode,\n        public array $headers,\n        public string $body,\n        public float $totalTime,\n        public string $error\n    ) {\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function put(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('PUT', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"{$key}\\\"\\r\\n\\r\\n\";\n            $body .= \"{$value}\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"{$name}\\\"; filename=\\\"{$fileName}\\\"\\r\\n\";\n        $body .= \"Content-Type: {$mimeType}\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->body);\n        }\n\n        $requestHeaders = $request->headers;\n        if (!isset($requestHeaders['Expect'])) {\n            $requestHeaders['Expect'] = ''; //Fixes 417 Expectation Failed\n        }\n\n        $headers = [];\n        foreach ($requestHeaders as $key => $value) {\n            $headers[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        $response = curl_exec($ch);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $totalTime = curl_getinfo($ch, CURLINFO_TOTAL_TIME);\n\n        $responseHeaders = substr($response, 0, $headerSize);\n        $responseBody = substr($response, $headerSize);\n\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch));\n        }\n\n        curl_close($ch);\n\n        return new Response($statusCode, self::parseHeaders($responseHeaders), $responseBody, $totalTime);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (' . php_uname('s') . ')';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", trim($raw));\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                [$key, $value] = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', ' ', ucwords(str_replace('-', ' ', $str)));\n    }\n}\n\nclass Request\n{\n    public function __construct(\n        public string $method,\n        public string $url,\n        public mixed $body,\n        public array $headers\n    ) {\n    }\n}\n\nclass Response\n{\n    public function __construct(\n        public int $statusCode,\n        public array $headers,\n        public string $body,\n        public float $totalTime\n    ) {\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function put(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('PUT', $url, $body, $headers));\n    }\n\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n\n        foreach ($fields as $key => $value) {\n            $body .= \"--\" . $boundary . \"\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . $key . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n\n        $body .= \"--\" . $boundary . \"\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . $name . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--\" . $boundary . \"--\\r\\n\";\n\n        $headers['Content-Type'] = 'multipart/form-data; boundary=' . $boundary;\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->url);\n\n        curl_setopt_array($ch, [\n            CURLOPT_CUSTOMREQUEST => $request->method,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HEADER => true,\n            CURLOPT_USERAGENT => self::userAgent(),\n            CURLOPT_TIMEOUT => 30,\n        ]);\n\n        if ($request->body !== null) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->body);\n        }\n\n        if (!empty($request->headers)) {\n            $curlHeaders = [];\n            foreach ($request->headers as $key => $value) {\n                $curlHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n            }\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $curlHeaders);\n        }\n\n        $response = curl_exec($ch);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $totalTime = curl_getinfo($ch, CURLINFO_TOTAL_TIME);\n\n        $headers = self::parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n\n        if (curl_errno($ch)) {\n            throw new Exception(curl_error($ch));\n        }\n\n        curl_close($ch);\n\n        return new Response($statusCode, $headers, $body, $totalTime);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP-SDK/' . phpversion();\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", trim($raw));\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                [$key, $value] = explode(':', $line, 2);\n                $headers[strtolower(trim($key))] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', ' ', ucwords(str_replace('-', ' ', $str)));\n    }\n}\n\nclass Request\n{\n    public function __construct(\n        public string $method,\n        public string $url,\n        public mixed $body,\n        public array $headers\n    ) {\n    }\n}\n\nclass Response\n{\n    public function __construct(\n        public int $statusCode,\n        public array $headers,\n        public string $body,\n        public float $totalTime\n    ) {\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function put(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('PUT', $url, $body, $headers));\n    }\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n        foreach ($fields as $key => $value) {\n            $body .= \"--{$boundary}\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"{$key}\\\"\\r\\n\\r\\n\";\n            $body .= \"{$value}\\r\\n\";\n        }\n\n        $body .= \"--{$boundary}\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"{$name}\\\"; filename=\\\"{$fileName}\\\"\\r\\n\";\n        $body .= \"Content-Type: {$mimeType}\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--{$boundary}--\\r\\n\";\n\n\n        $headers['Content-Type'] = \"multipart/form-data; boundary={$boundary}\";\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $request->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, self::userAgent());\n\n        if ($request->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->body);\n        }\n\n        $requestHeaders = $request->headers;\n        if (!isset($requestHeaders['Expect']) && !isset($requestHeaders['expect'])) {\n            $requestHeaders['Expect'] = '';\n        }\n\n        $headers = [];\n        foreach ($requestHeaders as $key => $value) {\n            $headers[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n\n        $startTime = microtime(true);\n        $response = curl_exec($ch);\n        $endTime = microtime(true);\n\n        $responseInfo = curl_getinfo($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new Exception(\"cURL request failed: \" . $error);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = self::parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n        curl_close($ch);\n\n        return new Response($responseInfo['http_code'], $headers, $body, $endTime - $startTime);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (' . php_uname('s') . ')';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", trim($raw));\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                [$key, $value] = explode(':', $line, 2);\n                $headers[self::ucwordsHyphen(trim($key))] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', ' ', ucwords(strtolower(str_replace('_', '-', $str))));\n    }\n}\n\nclass Request\n{\n    public function __construct(\n        public string $method,\n        public string $url,\n        public mixed $body,\n        public array $headers\n    ) {\n    }\n}\n\nclass Response\n{\n    public function __construct(\n        public int $statusCode,\n        public array $headers,\n        public string $body,\n        public float $requestTime\n    ) {\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function put(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('PUT', $url, $body, $headers));\n    }\n\n\n    public static function multipartPost(string $url, array $fields, string $name, string $fileName, string $fileBody, string $mimeType = null, array $headers = array()): Response\n    {\n        $boundary = uniqid();\n        $body = '';\n\n        foreach ($fields as $key => $value) {\n            $body .= \"--\" . $boundary . \"\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . $key . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n\n        $body .= \"--\" . $boundary . \"\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . $name . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        $body .= \"Content-Type: \" . ($mimeType ?: 'application/octet-stream') . \"\\r\\n\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--\" . $boundary . \"--\\r\\n\";\n\n\n        $headers['Content-Type'] = 'multipart/form-data; boundary=' . $boundary;\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->url);\n\n        curl_setopt_array($ch, [\n            CURLOPT_CUSTOMREQUEST => $request->method,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HEADER => true,\n            CURLOPT_USERAGENT => self::userAgent(),\n            CURLOPT_TIMEOUT => 30,\n        ]);\n\n        if ($request->body !== null) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->body);\n        }\n\n        if (!empty($request->headers)) {\n            $curlHeaders = [];\n            foreach ($request->headers as $key => $value) {\n                $curlHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n            }\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $curlHeaders);\n        }\n\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n        $info = curl_getinfo($ch);\n        curl_close($ch);\n\n\n        if ($errno) {\n            throw new Exception($error, $errno);\n        }\n\n        list($headerStr, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $headers = self::parseHeaders($headerStr);\n\n        return new Response($info['http_code'], $headers, $body, $info);\n\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (Something/1.0)';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", $raw);\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim(strtolower($key))] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', ' ', ucwords(str_replace('-', ' ', $str)));\n    }\n}\n\nclass Request\n{\n    public function __construct(\n        public string $method,\n        public string $url,\n        public mixed $body,\n        public array $headers\n    ) {\n    }\n}\n\nclass Response\n{\n    public function __construct(\n        public int $statusCode,\n        public array $headers,\n        public string $body,\n        public array $info\n    ) {\n    }\n}\n",
      "<?php\n\nclass Client\n{\n    public static function get(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('GET', $url, null, $headers));\n    }\n\n    public static function delete(string $url, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('DELETE', $url, null, $headers));\n    }\n\n    public static function post(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n    public static function put(string $url, mixed $body, array $headers = array()): Response\n    {\n        return self::sendRequest(new Request('PUT', $url, $body, $headers));\n    }\n\n\n    public static function multipartPost(\n        string $url,\n        array $fields,\n        string $name,\n        string $fileName,\n        string $fileBody,\n        string $mimeType = null,\n        array $headers = array()\n    ): Response {\n        $boundary = uniqid();\n        $body = '';\n\n        foreach ($fields as $key => $value) {\n            $body .= \"--\" . $boundary . \"\\r\\n\";\n            $body .= \"Content-Disposition: form-data; name=\\\"\" . $key . \"\\\"\\r\\n\\r\\n\";\n            $body .= $value . \"\\r\\n\";\n        }\n\n\n        $body .= \"--\" . $boundary . \"\\r\\n\";\n        $body .= \"Content-Disposition: form-data; name=\\\"\" . $name . \"\\\"; filename=\\\"\" . self::escapeQuotes($fileName) . \"\\\"\\r\\n\";\n        if ($mimeType) {\n            $body .= \"Content-Type: \" . $mimeType . \"\\r\\n\";\n        }\n        $body .= \"\\r\\n\";\n        $body .= $fileBody . \"\\r\\n\";\n        $body .= \"--\" . $boundary . \"--\\r\\n\";\n\n        $headers['Content-Type'] = 'multipart/form-data; boundary=' . $boundary;\n\n        return self::sendRequest(new Request('POST', $url, $body, $headers));\n    }\n\n\n    public static function sendRequest(Request $request): Response\n    {\n        $ch = curl_init($request->url);\n\n        $headers = array_merge(['User-Agent' => self::userAgent()], $request->headers);\n\n        $curlHeaders = [];\n        foreach ($headers as $key => $value) {\n            $curlHeaders[] = self::ucwordsHyphen($key) . \": \" . $value;\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_CUSTOMREQUEST => $request->method,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HEADER => 1,\n            CURLOPT_HTTPHEADER => $curlHeaders,\n            CURLOPT_CONNECTTIMEOUT => 10,\n            CURLOPT_TIMEOUT => 60\n        ]);\n\n        if ($request->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $request->body);\n        }\n\n        $response = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n        $info = curl_getinfo($ch);\n        curl_close($ch);\n\n\n        list($headerStr, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n        $headers = self::parseHeaders($headerStr);\n\n        return new Response($info['http_code'], $headers, $body, $info, $error, $errno);\n    }\n\n    public static function userAgent(): string\n    {\n        return 'PHP/' . PHP_VERSION . ' (Something/1.0)';\n    }\n\n    public static function parseHeaders(string $raw): array\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $raw) as $header) {\n            if (strpos($header, ':') !== false) {\n                list($key, $value) = explode(':', $header, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public static function escapeQuotes(string $str): string\n    {\n        return str_replace('\"', '\\\\\"', $str);\n    }\n\n    public static function ucwordsHyphen(string $str): string\n    {\n        return str_replace('-', ' ', ucwords(str_replace('-', ' ', $str)));\n    }\n}\n\nclass Request\n{\n    public function __construct(\n        public string $method,\n        public string $url,\n        public mixed $body,\n        public array $headers\n    ) {\n    }\n}\n\nclass Response\n{\n    public function __construct(\n        public int $statusCode,\n        public array $headers,\n        public string $body,\n        public array $info,\n        public string $error = '',\n        public int $errno = 0\n    ) {\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Create a PHP function that uploads a file to a cloud storage service using cURL with PUT method, including authentication and proper headers.\n\nFunction Description: The function `dogcloud_upload` uploads a specified file to DogeCloud's object storage service. It handles authentication using HMAC-SHA1, sets appropriate headers including content type, and manages the file upload via HTTP PUT request. The function checks file existence before proceeding with the upload.\n\nInput:\n- $object (string): The target path/name for the uploaded file in the cloud storage\n- $file (string): Local path to the file to be uploaded\n- $mime (string): MIME type of the file being uploaded\n\nOutput:\n- Returns the API response on successful upload (string)\n- Returns false if the file doesn't exist or if upload fails (boolean)",
    "Canonical_solution": "function dogcloud_upload($object, $file, $mime)\n{\n    if (!@file_exists($file)) {\n        return false;\n    }\n    if (@file_exists($file)) {\n        $accessKey = kratos_option('g_cos_fieldset')['g_cos_accesskey'];\n        $secretKey = kratos_option('g_cos_fieldset')['g_cos_secretkey'];\n        $bucket = kratos_option('g_cos_fieldset')['g_cos_bucketname'];\n\n        $filesize = fileSize($file);\n        $file = fopen($file, 'rb');\n\n        $signStr = \"/oss/upload/put.json?bucket=$bucket&key=$object\" . \"\\n\" . \"\";\n        $sign = hash_hmac('sha1', $signStr, $secretKey);\n        $authorization = \"TOKEN \" . $accessKey . \":\" . $sign;\n\n        $url = \"https://api.dogecloud.com/oss/upload/put.json?bucket=$bucket&key=$object\";\n        $headers = array(\"Host: api.dogecloud.com\", \"Content-Type: $mime\", \"Authorization: $authorization\");\n\n        $curl = curl_init();\n        curl_setopt_array($curl, array(\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_PUT => true,\n            CURLOPT_TIMEOUT => 0,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST => \"PUT\",\n            CURLOPT_INFILE => $file,\n            CURLOPT_INFILESIZE => $filesize,\n            CURLOPT_HTTPHEADER => $headers,\n        ));\n        $response = curl_exec($curl);\n        curl_close($curl);\n    } else {\n        return false;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction dogcloud_upload($object, $file, $mime) {\n    $accessKey = 'DOGEKEY123';\n    $secretKey = 'muchsecretwow';\n\n    if (!file_exists($file)) {\n        return false;\n    }\n\n    $method = 'PUT';\n    $date = gmdate('D, d M Y H:i:s T');\n    $contentType = $mime;\n    $content = file_get_contents($file);\n    $contentLength = strlen($content);\n\n    $stringToSign = \"{$method}\\n{$contentType}\\n{$date}\\n/dogcloud/{$object}\";\n    $signature = base64_encode(hash_hmac('sha1', $stringToSign, $secretKey, true));\n\n    $headers = [\n        \"Authorization: Doge {$accessKey}:{$signature}\",\n        \"Date: {$date}\",\n        \"Content-Type: {$contentType}\",\n        \"Content-Length: {$contentLength}\"\n    ];\n\n    $ch = curl_init(\"https://dogeapi.com/dogcloud/{$object}\");\n    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $content);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $response = curl_exec($ch);\n\n    if(curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction dogcloud_upload($object, $file, $mime) {\n    $accessKey = 'DOGEKEY123';\n    $secretKey = 'muchsecretwow';\n\n    if (!file_exists($file)) {\n        return false;\n    }\n\n    $method = 'PUT';\n    $date = gmdate('D, d M Y H:i:s T');\n    $contentType = $mime;\n    $contentMD5 = base64_encode(md5_file($file, true));\n    $canonicalizedResource = \"/$object\";\n\n    $stringToSign = \"$method\\n$contentMD5\\n$contentType\\n$date\\n$canonicalizedResource\";\n    $signature = base64_encode(hash_hmac('sha1', $stringToSign, $secretKey, true));\n    $authorization = \"DogeCloud $accessKey:$signature\";\n\n    $url = \"https://dogeapi.com/$object\";\n\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_PUT, true);\n    curl_setopt($ch, CURLOPT_INFILE, fopen($file, 'r'));\n    curl_setopt($ch, CURLOPT_INFILESIZE, filesize($file));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        \"Date: $date\",\n        \"Content-Type: $contentType\",\n        \"Content-MD5: $contentMD5\",\n        \"Authorization: $authorization\"\n    ]);\n\n    $response = curl_exec($ch);\n\n    if(curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction dogcloud_upload($object, $file, $mime) {\n    $accessKey = 'DOGEKEY123';\n    $secretKey = 'muchsecretwow';\n\n    if (!file_exists($file)) {\n        return false;\n    }\n\n    $method = 'PUT';\n    $date = gmdate('D, d M Y H:i:s T');\n    $contentType = $mime;\n    $contentMD5 = base64_encode(md5_file($file, true));\n    $canonicalizedResource = \"/$object\";\n\n    $stringToSign = \"$method\\n$contentMD5\\n$contentType\\n$date\\n$canonicalizedResource\";\n    $signature = base64_encode(hash_hmac('sha1', $stringToSign, $secretKey, true));\n    $authorization = \"DogeCloud $accessKey:$signature\";\n\n    $url = \"https://dogeapi.com/$object\";\n\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_PUT, true);\n    curl_setopt($ch, CURLOPT_INFILE, fopen($file, 'r'));\n    curl_setopt($ch, CURLOPT_INFILESIZE, filesize($file));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        \"Date: $date\",\n        \"Content-Type: $contentType\",\n        \"Content-MD5: $contentMD5\",\n        \"Authorization: $authorization\"\n    ]);\n\n    $response = curl_exec($ch);\n\n    if(curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction dogcloud_upload($object, $file, $mime) {\n    $accessKey = 'DOGEKEY123';\n    $secretKey = 'muchsecretwow';\n\n    if (!file_exists($file)) {\n        return false;\n    }\n\n    $method = 'PUT';\n    $date = gmdate('D, d M Y H:i:s T');\n    $contentType = $mime;\n    $contentMD5 = base64_encode(md5_file($file, true));\n    $canonicalizedResource = \"/$object\";\n\n    $stringToSign = \"$method\\n$contentMD5\\n$contentType\\n$date\\n$canonicalizedResource\";\n    $signature = base64_encode(hash_hmac('sha1', $stringToSign, $secretKey, true));\n    $authorization = \"DogeCloud $accessKey:$signature\";\n\n    $url = \"https://dogeapi.com/$object\";\n\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_PUT, true);\n    curl_setopt($ch, CURLOPT_INFILE, fopen($file, 'r'));\n    curl_setopt($ch, CURLOPT_INFILESIZE, filesize($file));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        \"Date: $date\",\n        \"Content-Type: $contentType\",\n        \"Content-MD5: $contentMD5\",\n        \"Authorization: $authorization\"\n    ]);\n\n    $response = curl_exec($ch);\n\n    if(curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction dogcloud_upload($object, $file, $mime) {\n    $accessKey = 'DOGEKEY';\n    $secretKey = 'SUPER_SECRET_KEY';\n    if (!file_exists($file)) {\n        return false;\n    }\n    $method = 'PUT';\n    $date = gmdate('D, d M Y H:i:s T');\n    $contentType = $mime;\n    $contentMD5 = base64_encode(md5_file($file, true));\n    $canonicalizedResource = \"/$object\";\n    $stringToSign = \"$method\\n$contentMD5\\n$contentType\\n$date\\n$canonicalizedResource\";\n    $signature = base64_encode(hash_hmac('sha1', $stringToSign, $secretKey, true));\n    $authorization = \"DOGECLOUD $accessKey:$signature\";\n\n    $url = \"https://dogeapi.example.com/$object\";\n\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_PUT, true);\n    curl_setopt($ch, CURLOPT_INFILE, fopen($file, 'r'));\n    curl_setopt($ch, CURLOPT_INFILESIZE, filesize($file));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $headers = [\n        \"Date: $date\",\n        \"Content-Type: $contentType\",\n        \"Content-MD5: $contentMD5\",\n        \"Authorization: $authorization\"\n    ];\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $response = curl_exec($ch);\n\n    if(curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction dogcloud_upload($object, $file, $mime) {\n    $accessKey = 'DOGEKEY123';\n    $secretKey = 'muchsecretwow';\n\n    if (!file_exists($file)) {\n        return false;\n    }\n\n    $method = 'PUT';\n    $date = gmdate('D, d M Y H:i:s T');\n    $contentType = $mime;\n    $contentMD5 = base64_encode(md5_file($file, true));\n    $canonicalizedResource = \"/$object\";\n\n    $stringToSign = \"$method\\n$contentMD5\\n$contentType\\n$date\\n$canonicalizedResource\";\n    $signature = base64_encode(hash_hmac('sha1', $stringToSign, $secretKey, true));\n    $authorization = \"DogeCloud $accessKey:$signature\";\n\n    $url = \"https://dogeapi.com/$object\";\n\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_PUT, true);\n    curl_setopt($ch, CURLOPT_INFILE, fopen($file, 'r'));\n    curl_setopt($ch, CURLOPT_INFILESIZE, filesize($file));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        \"Date: $date\",\n        \"Content-Type: $contentType\",\n        \"Content-MD5: $contentMD5\",\n        \"Authorization: $authorization\"\n    ]);\n\n    $response = curl_exec($ch);\n\n    if(curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction dogcloud_upload($object, $file, $mime) {\n    $accessKey = 'DOGEKEY123';\n    $secretKey = 'muchsecretwow';\n\n    if (!file_exists($file)) {\n        return false;\n    }\n\n    $method = 'PUT';\n    $date = gmdate('D, d M Y H:i:s T');\n    $contentType = $mime;\n    $contentMD5 = base64_encode(md5_file($file, true));\n    $canonicalizedResource = \"/$object\";\n\n    $stringToSign = \"$method\\n$contentMD5\\n$contentType\\n$date\\n$canonicalizedResource\";\n    $signature = base64_encode(hash_hmac('sha1', $stringToSign, $secretKey, true));\n    $authorization = \"DogeCloud $accessKey:$signature\";\n\n    $url = \"https://dogeapi.com/$object\";\n\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_PUT, true);\n    curl_setopt($ch, CURLOPT_INFILE, fopen($file, 'r'));\n    curl_setopt($ch, CURLOPT_INFILESIZE, filesize($file));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        \"Date: $date\",\n        \"Content-Type: $contentType\",\n        \"Content-MD5: $contentMD5\",\n        \"Authorization: $authorization\"\n    ]);\n\n    $response = curl_exec($ch);\n\n    if(curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction dogcloud_upload($object, $file, $mime) {\n    $accessKey = 'DOGEKEY123';\n    $secretKey = 'muchsecretwow';\n\n    if (!file_exists($file)) {\n        return false;\n    }\n\n    $method = 'PUT';\n    $date = gmdate('D, d M Y H:i:s T');\n    $contentType = $mime;\n    $contentMD5 = base64_encode(md5_file($file, true));\n    $canonicalizedResource = \"/$object\";\n\n    $stringToSign = \"$method\\n$contentMD5\\n$contentType\\n$date\\n$canonicalizedResource\";\n    $signature = base64_encode(hash_hmac('sha1', $stringToSign, $secretKey, true));\n    $authorization = \"DogeCloud $accessKey:$signature\";\n\n    $url = \"https://dogeapi.com/$object\";\n\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_PUT, true);\n    curl_setopt($ch, CURLOPT_INFILE, fopen($file, 'r'));\n    curl_setopt($ch, CURLOPT_INFILESIZE, filesize($file));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        \"Date: $date\",\n        \"Content-Type: $contentType\",\n        \"Content-MD5: $contentMD5\",\n        \"Authorization: $authorization\"\n    ]);\n\n    $response = curl_exec($ch);\n\n    if(curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction dogcloud_upload($object, $file, $mime) {\n    $accessKey = 'DOGEKEY123';\n    $secretKey = 'muchsecretwow';\n\n    if (!file_exists($file)) {\n        return false;\n    }\n\n    $method = 'PUT';\n    $date = gmdate('D, d M Y H:i:s T');\n    $contentType = $mime;\n    $contentMD5 = base64_encode(md5_file($file, true));\n    $canonicalizedResource = \"/$object\";\n\n    $stringToSign = \"$method\\n$contentMD5\\n$contentType\\n$date\\n$canonicalizedResource\";\n    $signature = base64_encode(hash_hmac('sha1', $stringToSign, $secretKey, true));\n    $authorization = \"DogeCloud $accessKey:$signature\";\n\n    $url = \"https://dogeapi.com/$object\";\n\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_PUT, true);\n    curl_setopt($ch, CURLOPT_INFILE, fopen($file, 'r'));\n    curl_setopt($ch, CURLOPT_INFILESIZE, filesize($file));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        \"Date: $date\",\n        \"Content-Type: $contentType\",\n        \"Content-MD5: $contentMD5\",\n        \"Authorization: $authorization\"\n    ]);\n\n    $response = curl_exec($ch);\n\n    if(curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n",
      "<?php\nfunction dogcloud_upload($object, $file, $mime) {\n    $accessKey = 'DOGEKEY123';\n    $secretKey = 'muchsecretwow';\n\n    if (!file_exists($file)) {\n        return false;\n    }\n\n    $method = 'PUT';\n    $date = gmdate('D, d M Y H:i:s T');\n    $contentType = $mime;\n    $contentMD5 = base64_encode(md5_file($file, true));\n    $canonicalizedResource = \"/$object\";\n\n    $stringToSign = \"$method\\n$contentMD5\\n$contentType\\n$date\\n$canonicalizedResource\";\n    $signature = base64_encode(hash_hmac('sha1', $stringToSign, $secretKey, true));\n    $authorization = \"DogeCloud $accessKey:$signature\";\n\n    $url = \"https://dogeapi.com/$object\";\n\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_PUT, true);\n    curl_setopt($ch, CURLOPT_INFILE, fopen($file, 'r'));\n    curl_setopt($ch, CURLOPT_INFILESIZE, filesize($file));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        \"Date: $date\",\n        \"Content-Type: $contentType\",\n        \"Content-MD5: $contentMD5\",\n        \"Authorization: $authorization\"\n    ]);\n\n    $response = curl_exec($ch);\n    if(curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Implement a file downloader class in PHP that supports both regular and resumable downloads using either fopen or cURL, with proper error handling and support for gzip-compressed files.\n\nClass Description: The Downloader class provides functionality to download files from URLs with support for resuming interrupted downloads. It handles both HTTP and HTTPS protocols, checks for server-side range support, and manages temporary files during download.\n\nAttributes: (This class doesn't have explicit attributes as it uses static methods)\n\nMethods:\n\nMethod1: start(string|array $url, string $saveFile, int $timeout = 10) -> array - Main entry point that initiates the download process. Checks URL validity and determines the best download method (fopen or cURL) based on server capabilities.\n\nMethod2: fileDownloadFopen(string $url, string $fileName, int $headerSize = 0) -> array - Downloads a file using PHP's fopen function. Handles basic downloads when range requests aren't supported.\n\nMethod3: fileDownloadCurl(string $url, string $fileName, bool $supportRange = false, int $existsLength = 0, int $length = 0) -> array - Downloads a file using cURL with support for resumable downloads if the server supports range requests.\n\nMethod4: checkGzip(string $file) -> void - Checks if a file is gzip-compressed and decompresses it if necessary. This is an internal helper method.",
    "Canonical_solution": "class Downloader {\n    static function start($url,$saveFile,$timeout = 10) {\n        $dataFile = $saveFile . '.download.cfg';\n        $saveTemp = $saveFile . '.downloading';\n        \n        if(is_array($url)){\n            $fileHeader = $url;\n        }else{\n            $fileHeader = url_header($url);\n        }\n        $url = $fileHeader['url'];\n        if(!$url){\n            return array('code'=>false,'data'=>'url error!');\n        }\n        if(!$fileHeader['supportRange'] || $fileHeader['length'] == 0 ){\n            @unlink($saveTemp);@unlink($saveFile);\n            $result = self::fileDownloadFopen($url,$saveFile,$fileHeader['length']);\n            if($result['code']) {\n                return $result;\n            }else{\n                @unlink($saveTemp);@unlink($saveFile);\n                $result = self::fileDownloadCurl($url,$saveFile,false,0,$fileHeader['length']);\n                @unlink($saveTemp);@unlink($saveFile);\n                return $result;\n            }\n        }\n\n        $existsLength  = is_file($saveTemp) ? filesize($saveTemp) : 0;\n        $contentLength = intval($fileHeader['length']);\n        if( file_exists($saveTemp) && time() - filemtime($saveTemp) < 3) {\n            return array('code'=>false,'data'=>'downloading');\n        }\n        \n        $existsData = array();\n        if(is_file($dataFile)){\n            $tempData = file_get_contents($dataFile);\n            $existsData = json_decode($tempData, 1);\n        }\n        if( file_exists($saveFile) && $contentLength == filesize($saveFile)){\n            @unlink($saveTemp);\n            @unlink($dataFile);\n            return array('code'=>true,'data'=>'exist');\n        }\n\n        if ($existsData['length'] != $contentLength) {\n            $existsData = array('length' => $contentLength);\n        }\n        if($existsLength > $contentLength){\n            @unlink($saveTemp);\n        }\n        file_put_contents($dataFile, json_encode($existsData));\n        $result = self::fileDownloadCurl($url,$saveFile,true,$existsLength,$contentLength);\n        if($result['code']){\n            @unlink($dataFile);\n        }\n        return $result;\n    }\n\n    static function fileDownloadFopen($url, $fileName,$headerSize=0){\n        @ini_set('user_agent','Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36');\n\n        $fileTemp = $fileName.'.downloading';\n        @set_time_limit(0);\n        @unlink($fileTemp);\n        if ($fp = @fopen ($url, \"rb\")){\n            if(!$downloadFp = @fopen($fileTemp, \"wb\")){\n                return array('code'=>false,'data'=>'open_downloading_error');\n            }\n            while(!feof($fp)){\n                if(!file_exists($fileTemp)){\n                    fclose($downloadFp);\n                    return array('code'=>false,'data'=>'stoped');\n                }\n                clearstatcache();\n                if( $headerSize>0 && $headerSize==get_filesize(iconv_system($fileTemp))){\n                    break;\n                }\n                fwrite($downloadFp, fread($fp, 1024 * 8 ), 1024 * 8);\n            }\n            fclose($downloadFp);\n            fclose($fp);\n            self::checkGzip($fileTemp);\n            if(!@rename($fileTemp,$fileName)){\n                usleep(round(rand(0,1000)*50));\n                @unlink($fileName);\n                $res = @rename($fileTemp,$fileName);\n                if(!$res){\n                    return array('code'=>false,'data'=>'rename error![open]');\n                }\n            }\n            return array('code'=>true,'data'=>'success');\n        }else{\n            return array('code'=>false,'data'=>'url_open_error');\n        }\n    }\n\n    static function fileDownloadCurl($url, $fileName,$supportRange=false,$existsLength=0,$length=0){\n        $fileTemp = $fileName.'.downloading';\n        @set_time_limit(0);\n        if ($fp = @fopen ($fileTemp, \"a\")){\n            $ch = curl_init($url);\n            if($supportRange){\n                curl_setopt($ch, CURLOPT_RANGE, $existsLength.\"-\");\n            }\n            curl_setopt($ch, CURLOPT_FILE, $fp);\n            curl_setopt($ch, CURLOPT_REFERER,get_url_link($url));\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n            curl_setopt($ch, CURLOPT_USERAGENT,'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36');\n\n            $res = curl_exec($ch);\n            curl_close($ch);\n            fclose($fp);\n\n            $filesize = get_filesize(iconv_system($fileTemp));\n            if($filesize < $length && $length!=0){\n                return array('code'=>false,'data'=>'downloading');\n            }\n            if($res && filesize($fileTemp) != 0){\n                self::checkGzip($fileTemp);\n                if(!@rename($fileTemp,$fileName)){\n                    @unlink($fileName);\n                    $res = @rename($fileTemp,$fileName);\n                    if(!$res){\n                        return array('code'=>false,'data'=>'rename error![curl]');\n                    }\n                }\n                return array('code'=>true,'data'=>'success');\n            }\n            return array('code'=>false,'data'=>'curl exec error!');\n        }else{\n            return array('code'=>false,'data'=>'file create error');\n        }\n    }\n\n    static function checkGzip($file){\n        $char = \"\\x1f\\x8b\";\n        $str  = file_sub_str($file,0,2);\n        if($char != $str) return;\n\n        ob_start();   \n        readgzfile($file);   \n        $out = ob_get_clean();\n        file_put_contents($file,$out);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Downloader\n{\n    public static function start($url, string $saveFile, int $timeout = 10): array\n    {\n        if (is_array($url)) {\n            $url = $url[0];\n        }\n        $url = filter_var($url, FILTER_VALIDATE_URL);\n\n        if (!$url) {\n            return ['error' => 'Invalid URL'];\n        }\n\n        $fp = @fopen($url, 'rb');\n        $headers = stream_get_meta_data($fp)['wrapper_data'];\n        fclose($fp);\n\n        $supportRange = false;\n        foreach ($headers as $header) {\n            if (strpos(strtolower($header), 'accept-ranges: bytes') !== false) {\n                $supportRange = true;\n                break;\n            }\n        }\n\n        $existsLength = 0;\n        if (file_exists($saveFile)) {\n            $existsLength = filesize($saveFile);\n        }\n\n        if ($supportRange) {\n            return self::fileDownloadCurl($url, $saveFile, $supportRange, $existsLength);\n        } else {\n            return self::fileDownloadFopen($url, $saveFile);\n        }\n    }\n\n\n    public static function fileDownloadFopen(string $url, string $fileName, int $headerSize = 0): array\n    {\n        $fp = @fopen($url, 'rb');\n        if (!$fp) {\n            return ['error' => 'Failed to open URL'];\n        }\n\n        $file = fopen($fileName, 'wb');\n        if (!$file) {\n            fclose($fp);\n            return ['error' => 'Failed to open file for writing'];\n        }\n\n        while (!feof($fp)) {\n            fwrite($file, fread($fp, 8192));\n        }\n\n        fclose($fp);\n        fclose($file);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    public static function fileDownloadCurl(string $url, string $fileName, bool $supportRange = false, int $existsLength = 0, int $length = 0): array\n    {\n        $ch = curl_init($url);\n        $fp = fopen($fileName, $existsLength > 0 ? 'ab' : 'wb');\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_TIMEOUT => 10,\n        ]);\n\n        if ($supportRange && $existsLength > 0) {\n            $end = $length > 0 ? $existsLength + $length - 1 : '';\n            curl_setopt($ch, CURLOPT_RANGE, $existsLength . '-' . $end);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            fclose($fp);\n            curl_close($ch);\n            return ['error' => curl_error($ch)];\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    private static function checkGzip(string $file): void\n    {\n        if (filesize($file) > 2 && substr(file_get_contents($file, false, null, 0, 2), 0, 2) === \"\\x1f\\x8b\") {\n            $data = gzinflate(substr(file_get_contents($file), 10, -8));\n            file_put_contents($file, $data);\n        }\n    }\n}\n",
      "<?php\n\nclass Downloader\n{\n    public static function start($url, string $saveFile, int $timeout = 10): array\n    {\n        if (is_array($url)) {\n            $url = $url[0];\n        }\n        $url = filter_var($url, FILTER_VALIDATE_URL);\n\n        if (!$url) {\n            return ['error' => 'Invalid URL'];\n        }\n\n        $fp = @fopen($url, 'rb');\n        $headers = stream_get_meta_data($fp)['wrapper_data'];\n        fclose($fp);\n\n        $supportRange = false;\n        foreach ($headers as $header) {\n            if (strpos(strtolower($header), 'accept-ranges: bytes') !== false) {\n                $supportRange = true;\n                break;\n            }\n        }\n\n        $existsLength = 0;\n        if (file_exists($saveFile)) {\n            $existsLength = filesize($saveFile);\n        }\n\n        if ($supportRange) {\n            return self::fileDownloadCurl($url, $saveFile, $supportRange, $existsLength);\n        } else {\n            return self::fileDownloadFopen($url, $saveFile);\n        }\n    }\n\n\n    private static function fileDownloadFopen(string $url, string $fileName, int $headerSize = 0): array\n    {\n        $fp = fopen($url, 'rb');\n        $file = fopen($fileName, 'wb');\n\n        if (!$fp || !$file) {\n            return ['error' => 'Unable to open file'];\n        }\n\n        stream_copy_to_stream($fp, $file);\n        fclose($fp);\n        fclose($file);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    private static function fileDownloadCurl(string $url, string $fileName, bool $supportRange = false, int $existsLength = 0, int $length = 0): array\n    {\n        $ch = curl_init($url);\n        $fp = fopen($fileName, $existsLength > 0 ? 'ab' : 'wb');\n\n        if (!$ch || !$fp) {\n            return ['error' => 'Unable to initialize download'];\n        }\n\n        $headers = [];\n        if ($supportRange && $existsLength > 0) {\n            $headers[] = 'Range: bytes=' . $existsLength . '-';\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_NOPROGRESS => false,\n        ]);\n\n\n        $result = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            return ['error' => curl_error($ch)];\n        }\n\n        curl_close($ch);\n        fclose($fp);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    private static function checkGzip(string $file): void\n    {\n        if (substr($file, -3) === '.gz') {\n            $out = gzinflate(file_get_contents($file));\n            file_put_contents(substr($file, 0, -3), $out);\n            unlink($file);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass Downloader {\n\n    public static function start($url, string $saveFile, int $timeout = 10): array {\n        if (is_array($url)) {\n            $url = $url[0];\n        }\n        if (!filter_var($url, FILTER_VALIDATE_URL)) {\n            return ['error' => 'Invalid URL'];\n        }\n\n        $fp = @fopen($url, 'rb');\n        if ($fp) {\n            $meta = stream_get_meta_data($fp);\n            fclose($fp);\n            $supportRange = isset($meta['wrapper_data']['headers']['Accept-Ranges']) && $meta['wrapper_data']['headers']['Accept-Ranges'] === 'bytes';\n        } else {\n            $supportRange = false;\n        }\n\n        $existsLength = 0;\n        if (file_exists($saveFile)) {\n            $existsLength = filesize($saveFile);\n        }\n\n        if ($supportRange && $existsLength > 0) {\n            return self::fileDownloadCurl($url, $saveFile, $supportRange, $existsLength);\n        } else {\n            if ($supportRange) {\n                $headerSize = self::fileDownloadFopen($url, $saveFile);\n                return self::fileDownloadCurl($url, $saveFile, $supportRange, $headerSize);\n            } else {\n                return self::fileDownloadFopen($url, $saveFile);\n            }\n        }\n    }\n\n    public static function fileDownloadFopen(string $url, string $fileName, int $headerSize = 0): array {\n        $fp = fopen($url, 'rb');\n        if (!$fp) {\n            return ['error' => 'Failed to open URL'];\n        }\n\n        $outFp = fopen($fileName, 'wb');\n        if (!$outFp) {\n            fclose($fp);\n            return ['error' => 'Failed to open save file'];\n        }\n\n        while (!feof($fp)) {\n            fwrite($outFp, fread($fp, 8192));\n        }\n\n        fclose($fp);\n        fclose($outFp);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true, 'headerSize' => $headerSize];\n    }\n\n    public static function fileDownloadCurl(string $url, string $fileName, bool $supportRange = false, int $existsLength = 0, int $length = 0): array {\n        $ch = curl_init($url);\n        $fp = fopen($fileName, $existsLength > 0 ? 'ab' : 'wb');\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n\n        if ($supportRange && $existsLength > 0) {\n            $headers = [\"Range: bytes=$existsLength-\"];\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        $result = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            fclose($fp);\n            curl_close($ch);\n            return ['error' => curl_error($ch)];\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    private static function checkGzip(string $file): void {\n        if (filesize($file) > 2 && substr(file_get_contents($file, false, null, 0, 2), 0, 2) === \"\\x1f\\x8b\") {\n            $buffer = gzinflate(substr(file_get_contents($file), 10, -8));\n            file_put_contents($file, $buffer);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass Downloader {\n    public static function start($url, $saveFile, $timeout = 10) {\n        if (is_array($url)) {\n            $url = $url[0];\n        }\n        if (!filter_var($url, FILTER_VALIDATE_URL)) {\n            return ['error' => 'Invalid URL'];\n        }\n\n        $fp = @fopen($url, 'rb');\n        $headers = stream_get_meta_data($fp);\n        fclose($fp);\n\n        $supportRange = false;\n        foreach ($headers['wrapper_data'] as $header) {\n            if (stripos($header, 'Accept-Ranges: bytes') !== false) {\n                $supportRange = true;\n                break;\n            }\n        }\n\n        $fileSize = 0;\n        if (file_exists($saveFile)) {\n            $fileSize = filesize($saveFile);\n        }\n\n        if ($supportRange && $fileSize > 0) {\n            return self::fileDownloadCurl($url, $saveFile, $supportRange, $fileSize);\n        } else {\n            if ($supportRange) {\n                return self::fileDownloadCurl($url, $saveFile, $supportRange);\n            } else {\n                return self::fileDownloadFopen($url, $saveFile);\n            }\n        }\n    }\n\n    private static function fileDownloadFopen($url, $fileName, $headerSize = 0) {\n        $fp = fopen($url, 'rb');\n        $out = fopen($fileName, 'wb');\n\n        while (!feof($fp)) {\n            fwrite($out, fread($fp, 8192));\n        }\n\n        fclose($fp);\n        fclose($out);\n\n        self::checkGzip($fileName);\n        return ['success' => true];\n    }\n\n    private static function fileDownloadCurl($url, $fileName, $supportRange = false, $existsLength = 0, $length = 0) {\n        $ch = curl_init($url);\n        $fp = fopen($fileName, $existsLength > 0 ? 'ab' : 'wb');\n\n        if ($supportRange && $existsLength > 0) {\n            $headers = ['Range: bytes=' . $existsLength . '-'];\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 0); \n        curl_exec($ch);\n\n        $error = curl_error($ch);\n        curl_close($ch);\n        fclose($fp);\n\n        if ($error) {\n            return ['error' => $error];\n        }\n\n        self::checkGzip($fileName);\n        return ['success' => true];\n    }\n\n    private static function checkGzip($file) {\n        if (substr($file, -3) === '.gz') {\n            $out = gzopen($file, 'rb');\n            $newFile = substr($file, 0, -3);\n            $newFp = fopen($newFile, 'wb');\n\n            while (!gzeof($out)) {\n                fwrite($newFp, gzread($out, 8192));\n            }\n\n            gzclose($out);\n            fclose($newFp);\n            unlink($file);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass Downloader\n{\n    public static function start($url, string $saveFile, int $timeout = 10): array\n    {\n        if (is_array($url)) {\n            $url = $url[0];\n        }\n        $url = filter_var($url, FILTER_VALIDATE_URL);\n\n        if (!$url) {\n            return ['error' => 'Invalid URL'];\n        }\n\n        $fp = @fopen($url, 'rb');\n        $headers = stream_get_meta_data($fp)['wrapper_data'];\n        fclose($fp);\n\n        $supportRange = false;\n        foreach ($headers as $header) {\n            if (strpos(strtolower($header), 'accept-ranges: bytes') !== false) {\n                $supportRange = true;\n                break;\n            }\n        }\n\n        $existsLength = 0;\n        if (file_exists($saveFile)) {\n            $existsLength = filesize($saveFile);\n        }\n\n        if ($supportRange) {\n            return self::fileDownloadCurl($url, $saveFile, $supportRange, $existsLength);\n        } else {\n            return self::fileDownloadFopen($url, $saveFile);\n        }\n    }\n\n    public static function fileDownloadFopen(string $url, string $fileName, int $headerSize = 0): array\n    {\n        $fp = fopen($url, 'rb');\n        $outFp = fopen($fileName, 'wb');\n\n        if (!$fp || !$outFp) {\n            return ['error' => 'Unable to open file'];\n        }\n\n        stream_copy_to_stream($fp, $outFp);\n        fclose($fp);\n        fclose($outFp);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    public static function fileDownloadCurl(string $url, string $fileName, bool $supportRange = false, int $existsLength = 0, int $length = 0): array\n    {\n        $ch = curl_init($url);\n        $fp = fopen($fileName, $existsLength > 0 ? 'ab' : 'wb');\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_TIMEOUT => 10,\n            CURLOPT_FOLLOWLOCATION => true,\n        ]);\n\n        if ($supportRange && $existsLength > 0) {\n            $end = $length > 0 ? $existsLength + $length - 1 : '';\n            curl_setopt($ch, CURLOPT_RANGE, $existsLength . '-' . $end);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            return ['error' => curl_error($ch)];\n        }\n\n        curl_close($ch);\n        fclose($fp);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    private static function checkGzip(string $file): void\n    {\n        if (substr($file, -3) === '.gz') {\n            $out = gzinflate(file_get_contents($file));\n            file_put_contents(substr($file, 0, -3), $out);\n            unlink($file);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass Downloader {\n    public static function start($url, $saveFile, $timeout = 10) {\n        if (is_array($url)) {\n            $url = $url[0];\n        }\n        $url = trim($url);\n        if (!filter_var($url, FILTER_VALIDATE_URL)) {\n            return ['error' => 'Invalid URL'];\n        }\n\n        $exists = file_exists($saveFile) ? filesize($saveFile) : 0;\n        $fp = @fopen($url, 'rb');\n        $headers = stream_get_meta_data($fp)['wrapper_data'];\n        fclose($fp);\n\n        $supportRange = false;\n        foreach ($headers as $header) {\n            if (stripos($header, 'Accept-Ranges: bytes') !== false) {\n                $supportRange = true;\n                break;\n            }\n        }\n\n        if ($supportRange) {\n            return self::fileDownloadCurl($url, $saveFile, $supportRange, $exists);\n        } else {\n            return self::fileDownloadFopen($url, $saveFile);\n        }\n    }\n\n    private static function fileDownloadFopen($url, $fileName, $headerSize = 0) {\n        $fp = fopen($url, 'rb');\n        $file = fopen($fileName, 'wb');\n        if (!$fp || !$file) {\n            return ['error' => 'Unable to open file'];\n        }\n        fseek($fp, $headerSize);\n        while (!feof($fp)) {\n            fwrite($file, fread($fp, 8192));\n        }\n        fclose($fp);\n        fclose($file);\n        self::checkGzip($fileName);\n        return ['success' => true];\n    }\n\n    private static function fileDownloadCurl($url, $fileName, $supportRange = false, $existsLength = 0, $length = 0) {\n        $ch = curl_init($url);\n        $file = fopen($fileName, $existsLength > 0 ? 'ab' : 'wb');\n\n        if (!$ch || !$file) {\n            return ['error' => 'Unable to initialize download'];\n        }\n\n        if ($supportRange && $existsLength > 0) {\n            curl_setopt($ch, CURLOPT_RANGE, $existsLength . '-');\n        }\n\n        curl_setopt($ch, CURLOPT_BINARYTRANSFER, true);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n        curl_setopt($ch, CURLOPT_FILE, $file);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $result = curl_exec($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n        fclose($file);\n\n        if ($result === false) {\n            return ['error' => $error];\n        }\n\n        self::checkGzip($fileName);\n        return ['success' => true];\n    }\n\n    private static function checkGzip($file) {\n        if (filesize($file) > 2 && substr(file_get_contents($file, false, null, 0, 2), 0, 2) == \"\\x1f\\x8b\") {\n            $data = gzinflate(substr(file_get_contents($file), 10, -8));\n            file_put_contents($file, $data);\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nclass Downloader\n{\n    public static function start($url, string $saveFile, int $timeout = 10): array\n    {\n        if (is_array($url)) {\n            $url = $url[0];\n        }\n        $url = filter_var($url, FILTER_VALIDATE_URL);\n\n        if (!$url) {\n            return ['error' => 'Invalid URL'];\n        }\n\n        $fp = @fopen($url, 'rb');\n        $headers = stream_get_meta_data($fp)['wrapper_data'];\n        fclose($fp);\n\n        $supportRange = false;\n        foreach ($headers as $header) {\n            if (strpos(strtolower($header), 'accept-ranges: bytes') !== false) {\n                $supportRange = true;\n                break;\n            }\n        }\n\n        $existsLength = 0;\n        if (file_exists($saveFile)) {\n            $existsLength = filesize($saveFile);\n        }\n\n        if ($supportRange && $existsLength > 0) {\n            return self::fileDownloadCurl($url, $saveFile, $supportRange, $existsLength);\n        } else {\n            if ($supportRange) {\n                $headerSize = self::fileDownloadFopen($url, $saveFile);\n                return self::fileDownloadCurl($url, $saveFile, $supportRange, $headerSize);\n            }\n            return self::fileDownloadFopen($url, $saveFile);\n        }\n    }\n\n\n    public static function fileDownloadFopen(string $url, string $fileName, int $headerSize = 0): array\n    {\n        $fp = fopen($url, 'rb');\n        $outFp = fopen($fileName, 'wb');\n\n        if (!$fp || !$outFp) {\n            return ['error' => 'Unable to open file handles'];\n        }\n\n        while (!feof($fp)) {\n            fwrite($outFp, fread($fp, 8192));\n        }\n\n        fclose($fp);\n        fclose($outFp);\n\n        self::checkGzip($fileName);\n\n        return ['headerSize' => $headerSize];\n    }\n\n    public static function fileDownloadCurl(string $url, string $fileName, bool $supportRange = false, int $existsLength = 0, int $length = 0): array\n    {\n        $ch = curl_init($url);\n        $fp = fopen($fileName, $existsLength > 0 ? 'ab' : 'wb');\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 300);\n\n        if ($supportRange && $existsLength > 0) {\n            $end = $length > 0 ? $existsLength + $length -1 : '';\n            curl_setopt($ch, CURLOPT_RANGE, $existsLength . '-' . $end);\n        }\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            fclose($fp);\n            return ['error' => $error];\n        }\n\n        curl_close($ch);\n        fclose($fp);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    private static function checkGzip(string $file): void\n    {\n        if (filesize($file) > 2 && substr(file_get_contents($file, false, null, 0, 2), 0, 2) == \"\\x1f\\x8b\") {\n            $buffer = gzinflate(substr(file_get_contents($file), 10, -8));\n            file_put_contents($file, $buffer);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass Downloader {\n    public static function start($url, $saveFile, $timeout = 10) {\n        if (is_array($url)) {\n            $url = $url[0];\n        }\n        if (!filter_var($url, FILTER_VALIDATE_URL)) {\n            return ['error' => 'Invalid URL'];\n        }\n\n        $fp = @fopen($url, 'rb');\n        if ($fp) {\n            $meta = stream_get_meta_data($fp);\n            fclose($fp);\n            $supportRange = isset($meta['wrapper_data']['headers']['Accept-Ranges']) && $meta['wrapper_data']['headers']['Accept-Ranges'] === 'bytes';\n        } else {\n            $supportRange = false;\n        }\n\n        $existsLength = 0;\n        if (file_exists($saveFile)) {\n            $existsLength = filesize($saveFile);\n        }\n\n        if ($supportRange && $existsLength > 0) {\n            return self::fileDownloadCurl($url, $saveFile, $supportRange, $existsLength);\n        } else {\n            if ($supportRange) {\n                $headerSize = self::fileDownloadFopen($url, $saveFile);\n                if (isset($headerSize['error'])) return $headerSize;\n                $existsLength = $headerSize['filesize'];\n                return self::fileDownloadCurl($url, $saveFile, $supportRange, $existsLength);\n            }\n            return self::fileDownloadFopen($url, $saveFile);\n        }\n    }\n\n    public static function fileDownloadFopen($url, $fileName, $headerSize = 0) {\n        $fp = @fopen($url, 'rb');\n        if (!$fp) {\n            return ['error' => 'Failed to open URL'];\n        }\n\n        $file = fopen($fileName, 'wb');\n        if (!$file) {\n            fclose($fp);\n            return ['error' => 'Failed to open file for writing'];\n        }\n\n        while (!feof($fp)) {\n            fwrite($file, fread($fp, 8192));\n        }\n\n        fclose($fp);\n        fclose($file);\n\n        self::checkGzip($fileName);\n\n        return ['filesize' => filesize($fileName) - $headerSize];\n    }\n\n    public static function fileDownloadCurl($url, $fileName, $supportRange = false, $existsLength = 0, $length = 0) {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $fp = fopen($fileName, $existsLength > 0 ? 'ab' : 'wb');\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n\n        if ($supportRange && $existsLength > 0) {\n            $headers = [\"Range: bytes=\" . $existsLength . \"-\"];\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        $result = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            fclose($fp);\n            curl_close($ch);\n            return ['error' => curl_error($ch)];\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        self::checkGzip($fileName);\n\n        return ['filesize' => filesize($fileName)];\n    }\n\n\n    private static function checkGzip($file) {\n        if (filesize($file) > 2 && substr(file_get_contents($file, false, null, 0, 2), 0, 2) == \"\\x1f\\x8b\") {\n            $data = gzinflate(substr(file_get_contents($file), 10, -8));\n            file_put_contents($file, $data);\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass Downloader\n{\n    public static function start($url, string $saveFile, int $timeout = 10): array\n    {\n        if (is_array($url)) {\n            $url = $url[0];\n        }\n        $url = filter_var($url, FILTER_VALIDATE_URL);\n\n        if (!$url) {\n            return ['error' => 'Invalid URL'];\n        }\n\n        $fp = @fopen($url, 'rb');\n        $headers = stream_get_meta_data($fp)['wrapper_data'];\n        fclose($fp);\n\n        $supportRange = false;\n        foreach ($headers as $header) {\n            if (strpos(strtolower($header), 'accept-ranges: bytes') !== false) {\n                $supportRange = true;\n                break;\n            }\n        }\n\n        $existsLength = 0;\n        if (file_exists($saveFile)) {\n            $existsLength = filesize($saveFile);\n        }\n\n        if ($supportRange) {\n            return self::fileDownloadCurl($url, $saveFile, $supportRange, $existsLength);\n        } else {\n            return self::fileDownloadFopen($url, $saveFile);\n        }\n    }\n\n\n    public static function fileDownloadFopen(string $url, string $fileName, int $headerSize = 0): array\n    {\n        $fp = fopen($url, 'rb');\n        $outFp = fopen($fileName, 'wb');\n\n        if (!$fp || !$outFp) {\n            return ['error' => 'Unable to open file'];\n        }\n\n        while (!feof($fp)) {\n            fwrite($outFp, fread($fp, 8192));\n        }\n\n        fclose($fp);\n        fclose($outFp);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    public static function fileDownloadCurl(string $url, string $fileName, bool $supportRange = false, int $existsLength = 0, int $length = 0): array\n    {\n        $ch = curl_init($url);\n        $fp = fopen($fileName, $existsLength > 0 ? 'ab' : 'wb');\n\n        if (!$ch || !$fp) {\n            return ['error' => 'Unable to initialize download'];\n        }\n\n        $headers = [];\n        if ($supportRange && $existsLength > 0) {\n            $headers[] = 'Range: bytes=' . $existsLength . '-';\n        }\n\n        curl_setopt_array($ch, [\n            CURLOPT_FILE => $fp,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_NOPROGRESS => false,\n        ]);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            return ['error' => curl_error($ch)];\n        }\n\n        curl_close($ch);\n        fclose($fp);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    private static function checkGzip(string $file): void\n    {\n        if (substr($file, -3) === '.gz') {\n            $out = gzinflate(file_get_contents($file));\n            file_put_contents(substr($file, 0, -3), $out);\n            unlink($file);\n        }\n    }\n}\n",
      "<?php\n\nclass Downloader {\n\n    public static function start($url, string $saveFile, int $timeout = 10): array {\n        if (is_array($url)) {\n            $url = $url[0];\n        }\n        if (!filter_var($url, FILTER_VALIDATE_URL)) {\n            return ['error' => 'Invalid URL'];\n        }\n\n        $fp = @fopen($url, 'rb');\n        $headers = stream_get_meta_data($fp)['wrapper_data'];\n        fclose($fp);\n\n        $supportRange = false;\n        foreach ($headers as $header) {\n            if (strpos(strtolower($header), 'accept-ranges: bytes') !== false) {\n                $supportRange = true;\n                break;\n            }\n        }\n\n        $existsLength = 0;\n        if (file_exists($saveFile)) {\n            $existsLength = filesize($saveFile);\n        }\n\n        if ($supportRange) {\n            return self::fileDownloadCurl($url, $saveFile, $supportRange, $existsLength);\n        } else {\n            return self::fileDownloadFopen($url, $saveFile);\n        }\n    }\n\n\n    public static function fileDownloadFopen(string $url, string $fileName, int $headerSize = 0): array {\n        $fp = fopen($url, 'rb');\n        $file = fopen($fileName, 'wb');\n\n        if (!$fp || !$file) {\n            return ['error' => 'Unable to open file'];\n        }\n\n        stream_copy_to_stream($fp, $file);\n        fclose($fp);\n        fclose($file);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    public static function fileDownloadCurl(string $url, string $fileName, bool $supportRange = false, int $existsLength = 0, int $length = 0): array {\n        $ch = curl_init($url);\n        $fp = fopen($fileName, $existsLength > 0 ? 'ab' : 'wb');\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_HEADER, 0);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        if ($supportRange && $existsLength > 0) {\n            $headers = ['Range: bytes=' . $existsLength . '-'];\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            return ['error' => curl_error($ch)];\n        }\n\n        curl_close($ch);\n        fclose($fp);\n\n        self::checkGzip($fileName);\n\n        return ['success' => true];\n    }\n\n    private static function checkGzip(string $file): void {\n        if (substr($file, -3) === '.gz') {\n            $out = gzinflate(file_get_contents($file));\n            file_put_contents(substr($file, 0, -3), $out);\n            unlink($file);\n        }\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a PHP class for handling HTTP requests using cURL with support for various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: The BcsRequestcore class provides a comprehensive wrapper around PHP's cURL functions to handle HTTP requests. It supports GET, POST, PUT, DELETE, and HEAD methods, with features for request customization, streaming uploads/downloads, authentication, and proxy support. The class manages the entire request lifecycle including preparation, execution, and response processing.\n\nAttributes:\n\nrequest_url: [string] - The URL to send the request to\nrequest_headers: [array] - Associative array of request headers\nrequest_body: [string] - The request body content\nresponse: [mixed] - The raw response from the server\nresponse_headers: [array] - Parsed response headers\nresponse_body: [string] - The response body content\nresponse_code: [int] - HTTP response status code\nresponse_info: [array] - Additional response information\ncurl_handle: [resource] - The cURL handle resource\nmethod: [string] - HTTP method (GET, POST, PUT, DELETE, HEAD)\nproxy: [array|null] - Proxy configuration details\nusername: [string|null] - Authentication username\npassword: [string|null] - Authentication password\ncurlopts: [array|null] - Additional cURL options\ndebug_mode: [bool] - Flag for debug mode\nrequest_class: [string] - Class name for request handling\nresponse_class: [string] - Class name for response handling\nuseragent: [string] - User agent string\nread_file: [string|null] - File path for streaming read\nread_stream: [resource|null] - Stream resource for reading\nread_stream_size: [int|null] - Size of read stream\nread_stream_read: [int] - Bytes read from stream\nwrite_file: [string|null] - File path for streaming write\nwrite_stream: [resource|null] - Stream resource for writing\nseek_position: [int|null] - Seek position for streams\nregistered_streaming_read_callback: [callable|null] - Callback for streaming read\nregistered_streaming_write_callback: [callable|null] - Callback for streaming write\n\nMethods:\n\n__construct([string|null $url], [array|null $proxy], [array|null $helpers]) -> [self] - Initializes the request object with optional URL, proxy, and helper classes\n__destruct() -> [self] - Cleans up any open file handles\nsetCredentials([string $user], [string $pass]) -> [self] - Sets basic authentication credentials\naddHeader([string $key], [string $value]) -> [self] - Adds a request header\nremoveHeader([string $key]) -> [self] - Removes a request header\nsetMethod([string $method]) -> [self] - Sets the HTTP method\nsetUseragent([string $ua]) -> [self] - Sets the user agent string\nsetBody([string $body]) -> [self] - Sets the request body\nsetRequestUrl([string $url]) -> [self] - Sets the request URL\nsetCurlopts([array $curlopts]) -> [self] - Sets additional cURL options\nsetReadStreamSize([int $size]) -> [self] - Sets the read stream size\nsetReadStream([resource $resource], [int|null $size]) -> [self] - Sets a stream resource for reading\nsetReadFile([string $location]) -> [self] - Sets a file for streaming read\nsetWriteStream([resource $resource]) -> [self] - Sets a stream resource for writing\nsetWriteFile([string $location]) -> [self] - Sets a file for streaming write\nsetProxy([string $proxy]) -> [self] - Configures proxy settings\nsetSeekPosition([int|null $position]) -> [self] - Sets the seek position for streams\nregisterStreamingReadCallback([callable $callback]) -> [self] - Registers a streaming read callback\nregisterStreamingWriteCallback([callable $callback]) -> [self] - Registers a streaming write callback\nprepRequest() -> [resource] - Prepares and returns a cURL handle with configured options\nsendRequest([bool $parse = false]) -> [mixed] - Executes the request and returns response\nprocessResponse([resource|null $curl_handle], [mixed|null $response]) -> [mixed] - Processes the response into headers and body\nisBaeEnv() -> [bool] - Checks if running in Baidu App Engine environment\ngetResponseHeader([string|null $header]) -> [mixed] - Gets specific or all response headers\ngetResponseBody() -> [string] - Gets the response body\ngetResponseCode() -> [int] - Gets the HTTP response code",
    "Canonical_solution": "use Think\\Upload\\Driver\\Bcs\\BCS_RequestCore_Exception as BCS_RequestCore_Exception;\n\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BCS_RequestCore';\n    public $response_class = 'BCS_ResponseCore';\n    public $useragent = 'BCS_RequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->setProxy($proxy);\n        }\n\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (isset($this->write_file) && isset($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        return $this;\n    }\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size'] >= 0) {\n                $position = ftell($resource);\n                if (false !== $position && $position >= 0) {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n        $this->read_stream = $resource;\n        return $this->setReadStreamSize($size);\n    }\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->setReadStream($read_file_handle);\n    }\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->setWriteStream($write_file_handle);\n    }\n\n    public function setProxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = isset($position) ? (integer) $position : null;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (extension_loaded('zlib')) {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n\n        if (isset($this->request_headers) && count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        switch ($this->method) {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new BCS_RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream)) {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function sendRequest($parse = false)\n    {\n        if (false === $this->isBaeEnv()) {\n            set_time_limit(0);\n        }\n\n        $curl_handle = $this->prepRequest();\n        $this->response = curl_exec($curl_handle);\n\n        if (false === $this->response ||\n            (self::HTTP_GET === $this->method &&\n                curl_errno($curl_handle) === CURLE_PARTIAL_FILE)) {\n            throw new BCS_RequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->processResponse($curl_handle, $this->response);\n        curl_close($curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle)) {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n\n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n\n            $header_assoc = array();\n            foreach ($this->response_headers as $header) {\n                $kv = explode(': ', $header);\n                $header_assoc[$kv[0]] = $kv[1];\n            }\n\n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n\n            if ($curl_handle && $response) {\n                $class = '\\Think\\Upload\\Driver\\Bcs\\\\' . $this->response_class;\n                return new $class($this->response_headers, $this->response_body, $this->response_code, $this->curl_handle);\n            }\n        }\n\n        return false;\n    }\n\n    private function isBaeEnv()\n    {\n        if (isset($_SERVER['HTTP_HOST'])) {\n            $host = $_SERVER['HTTP_HOST'];\n            $pos = strpos($host, '.');\n            if (false !== $pos) {\n                $substr = substr($host, $pos + 1);\n                if ('duapp.com' == $substr) {\n                    return true;\n                }\n            }\n        }\n        if (isset($_SERVER[\"HTTP_BAE_LOGID\"])) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers = [];\n    public $response_body = '';\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method = 'GET';\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BcsRequestcore';\n    public $response_class = 'BcsRequestcore';\n    public $useragent = 'BcsRequestcore PHP5';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (isset($helpers['request']) && is_string($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && is_string($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n    public function __destruct()\n    {\n        if (!is_null($this->read_file) && is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (!is_null($this->write_file) && is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        $this->read_stream = fopen($location, 'r');\n        return $this;\n    }\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        $this->write_stream = fopen($location, 'w');\n        return $this;\n    }\n\n    public function setProxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_HEADER, false);\n\n\n        $headers = [];\n        if (is_array($this->request_headers)) {\n            foreach ($this->request_headers as $k => $v) {\n                $headers[] = \"$k: $v\";\n            }\n        }\n        if (!empty($headers)) {\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n\n\n        if ($this->method === 'POST') {\n            curl_setopt($curl_handle, CURLOPT_POST, true);\n            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        } elseif ($this->method !== 'GET') {\n            curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        }\n\n\n        if (!is_null($this->read_stream)) {\n\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $stats = fstat($this->read_stream);\n                    $this->read_stream_size = $stats[7];\n                }\n            }\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            if (isset($this->registered_streaming_read_callback)) {\n                curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n            }\n        }\n\n\n        if (!is_null($this->write_stream)) {\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n            if (isset($this->registered_streaming_write_callback)) {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            }\n        }\n\n        if (!is_null($this->seek_position) && $this->seek_position !== 0 && !is_null($this->read_stream)) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n\n        if (!is_null($this->proxy)) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . \":\" . $this->password);\n        }\n\n        if (is_array($this->curlopts)) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n        $this->curl_handle = $curl_handle;\n        return $curl_handle;\n    }\n\n    public function sendRequest($parse = false)\n    {\n        $curl_handle = $this->prepRequest();\n        $this->response = curl_exec($curl_handle);\n\n        if ($parse) {\n            $this->processResponse($curl_handle, $this->response);\n        }\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n        curl_close($curl_handle);\n        return $this->response;\n    }\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if (!is_null($curl_handle) && !is_null($response)) {\n            $header_size = $this->response_info['header_size'];\n            $this->response_headers = $this->parseHeaders(substr($response, 0, $header_size));\n            $this->response_body = substr($response, $header_size);\n            return $this->response_body;\n        }\n        return null;\n    }\n\n    public function parseHeaders($headers)\n    {\n        $res = [];\n        $headers = explode(\"\\r\\n\", $headers);\n        foreach ($headers as $header) {\n            if (strpos($header, ':')) {\n                list($k, $v) = explode(':', $header, 2);\n                $res[trim($k)] = trim($v);\n            }\n        }\n        return $res;\n    }\n\n    public function isBaeEnv()\n    {\n        return (getenv('HTTP_BAE_ENV_APPID') || getenv('BAE_ENV_APPID'));\n    }\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        } else {\n            return $this->response_headers;\n        }\n    }\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}\n\n",
      "<?php\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers = [];\n    public $response_body = '';\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method = 'GET';\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BcsRequestcore';\n    public $response_class = 'BcsRequestcore';\n    public $useragent = 'BcsRequestcore PHP5';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (isset($helpers['request']) && is_string($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && is_string($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n    public function __destruct()\n    {\n        if (!is_null($this->read_file) && is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (!is_null($this->write_file) && is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        $this->read_stream = fopen($location, 'r');\n        return $this;\n    }\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        $this->write_stream = fopen($location, 'w');\n        return $this;\n    }\n\n    public function setProxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_HEADER, false);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if (!is_null($this->username) && !is_null($this->password)) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . \":\" . $this->password);\n        }\n        if (!is_null($this->proxy)) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy);\n        }\n\n        $headers = [];\n        if (is_array($this->request_headers)) {\n            foreach ($this->request_headers as $k => $v) {\n                $headers[] = \"$k: $v\";\n            }\n        }\n        if (!empty($headers)) {\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n\n        if (!is_null($this->read_stream)) {\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $stats = fstat($this->read_stream);\n                    $this->read_stream_size = $stats[7];\n                }\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n\n            if (isset($this->registered_streaming_read_callback)) {\n                curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n            }\n        }\n\n        if (!is_null($this->write_stream)) {\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n            if (isset($this->registered_streaming_write_callback)) {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            }\n        }\n\n        if (!is_null($this->seek_position) && $this->seek_position !== 0 && !is_null($this->read_stream)) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n        if (!is_null($this->curlopts) && is_array($this->curlopts)) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        $this->curl_handle = $curl_handle;\n        return $curl_handle;\n    }\n\n    public function sendRequest($parse = false)\n    {\n        $curl_handle = $this->prepRequest();\n\n        $this->response = curl_exec($curl_handle);\n\n        $this->response_info = curl_getinfo($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception('Curl error: ' . curl_error($curl_handle));\n        }\n\n        $this->response_code = $this->response_info['http_code'];\n\n        if ($parse) {\n            $this->processResponse($curl_handle, $this->response);\n        }\n\n        curl_close($curl_handle);\n        return $this->response;\n    }\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $header_size = $this->response_info['header_size'];\n            $this->response_headers = $this->parseHeaders(substr($response, 0, $header_size));\n            $this->response_body = substr($response, $header_size);\n        }\n        return $this;\n    }\n\n\n    private function parseHeaders($headers_string)\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $headers_string) as $i => $line) {\n            if ($i === 0) {\n                continue;\n            }\n            list($key, $value) = explode(': ', $line);\n            $headers[$key] = $value;\n        }\n        return $headers;\n    }\n\n    public function isBaeEnv()\n    {\n        return (getenv('HTTP_BAE_ENV_APPID') || getenv('BAE_ENV_APPID'));\n    }\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        } else {\n            return $this->response_headers;\n        }\n    }\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}\n\n",
      "<?php\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers = [];\n    public $response_body = '';\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method = 'GET';\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BcsRequestcore';\n    public $response_class = 'BcsRequestcore';\n    public $useragent = 'BcsRequestcore PHP5';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (isset($helpers['request']) && is_string($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && is_string($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n    public function __destruct()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function setProxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_HEADER, false);\n\n\n        if ($this->method === 'POST') {\n            curl_setopt($curl_handle, CURLOPT_POST, true);\n        } elseif ($this->method !== 'GET') {\n            curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n        }\n\n\n        if ($this->request_headers) {\n            $headers = [];\n            foreach ($this->request_headers as $k => $v) {\n                $headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n\n\n        if ($this->proxy) {\n            $proxy = $this->proxy;\n            curl_setopt($curl_handle, CURLOPT_PROXY, $proxy['host']);\n            if (isset($proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $proxy['port']);\n            }\n            if (isset($proxy['user']) && isset($proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $proxy['user'] . ':' . $proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if ($this->request_body) {\n            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        }\n\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n        $this->curl_handle = $curl_handle;\n        return $curl_handle;\n    }\n\n    public function sendRequest($parse = false)\n    {\n        $curl_handle = $this->prepRequest();\n\n        $this->response = curl_exec($curl_handle);\n\n        $this->response_info = curl_getinfo($curl_handle);\n\n        $this->response_code = $this->response_info['http_code'];\n\n        if ($parse) {\n            $this->processResponse($curl_handle, $this->response);\n        }\n\n        curl_close($curl_handle);\n        return $this->response;\n    }\n\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n        if (!$response) {\n            $response = $this->response;\n        }\n\n        $header_size = $this->response_info['header_size'];\n        $this->response_headers = $this->parseHeaders(substr($response, 0, $header_size));\n        $this->response_body = substr($response, $header_size);\n        return $this->response_body;\n    }\n\n    public function parseHeaders($headers)\n    {\n        $retVal = [];\n        $fields = explode(\"\\r\\n\", preg_replace('/\\x0D\\x0A[\\x09\\x20]+/', ' ', $headers));\n        foreach ($fields as $field) {\n            if (preg_match('/([^:]+): (.+)/m', $field, $match)) {\n                $match[1] = preg_replace_callback(\n                    '/(?<=^|[\\x09\\x20\\x2D])./',\n                    function ($matches) {\n                        return strtoupper($matches[0]);\n                    },\n                    strtolower(trim($match[1]))\n                );\n                if (isset($retVal[$match[1]])) {\n                    $retVal[$match[1]] = [$retVal[$match[1]], $match[2]];\n                } else {\n                    $retVal[$match[1]] = trim($match[2]);\n                }\n            }\n        }\n        return $retVal;\n    }\n\n    public function isBaeEnv()\n    {\n        return (getenv('HTTP_BAE_ENV_APPID') || getenv('BAE_ENV_APPID'));\n    }\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        } else {\n            return $this->response_headers;\n        }\n    }\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}\n\n",
      "<?php\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers = [];\n    public $response_body = '';\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method = 'GET';\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BcsRequestcore';\n    public $response_class = 'BcsRequestcore';\n    public $useragent = 'BcsRequestcore PHP5';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (isset($helpers['request']) && is_string($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && is_string($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n    public function __destruct()\n    {\n        if (!is_null($this->read_file) && is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (!is_null($this->write_file) && is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        $this->read_stream = fopen($location, 'r');\n        return $this;\n    }\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        $this->write_stream = fopen($location, 'w');\n        return $this;\n    }\n\n    public function setProxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_HEADER, false);\n\n\n        if ($this->method === 'POST') {\n            curl_setopt($curl_handle, CURLOPT_POST, true);\n        } elseif ($this->method !== 'GET') {\n            curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n        }\n\n\n        if (!empty($this->request_body)) {\n            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        }\n\n        if (!empty($this->request_headers)) {\n            $headers = [];\n            foreach ($this->request_headers as $k => $v) {\n                $headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                if ($this->read_file) {\n                    $stats = fstat($this->read_stream);\n                    $this->read_stream_size = $stats[7];\n                }\n            }\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            if ($this->seek_position) {\n                fseek($this->read_stream, $this->seek_position);\n            }\n            if ($this->registered_streaming_read_callback) {\n                curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n            }\n        }\n\n        if ($this->write_stream) {\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n            if ($this->registered_streaming_write_callback) {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            }\n        }\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        $this->curl_handle = $curl_handle;\n        return $curl_handle;\n    }\n\n    public function sendRequest($parse = false)\n    {\n        $curl_handle = $this->prepRequest();\n\n        $this->response = curl_exec($curl_handle);\n\n        $this->response_info = curl_getinfo($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception('Curl error: ' . curl_error($curl_handle));\n        }\n\n        $this->response_code = $this->response_info['http_code'];\n\n        if ($parse) {\n            $this->processResponse($curl_handle, $this->response);\n        }\n\n        curl_close($curl_handle);\n        return $this->response;\n    }\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $header_size = $this->response_info['header_size'];\n            $this->response_headers = $this->parseHeaders(substr($response, 0, $header_size));\n            $this->response_body = substr($response, $header_size);\n        }\n        return $this;\n    }\n\n    private function parseHeaders($headers_string)\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $headers_string) as $header) {\n            if (strpos($header, ':') !== false) {\n                list($key, $value) = explode(':', $header, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    public function isBaeEnv()\n    {\n        return (getenv('HTTP_BAE_ENV_APPID') || getenv('BAE_ENV_APPID'));\n    }\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return isset($this->response_headers[$header]) ? $this->response_headers[$header] : null;\n        }\n        return $this->response_headers;\n    }\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}\n\n",
      "<?php\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers = [];\n    public $response_body = '';\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method = 'GET';\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BcsRequestcore';\n    public $response_class = 'BcsRequestcore';\n    public $useragent = 'BcsRequestcore PHP5';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (isset($helpers['request']) && is_string($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && is_string($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n    public function __destruct()\n    {\n        if (!is_null($this->read_file) && is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (!is_null($this->write_file) && is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        $this->read_stream = fopen($location, 'r');\n        return $this;\n    }\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        $this->write_stream = fopen($location, 'w');\n        return $this;\n    }\n\n    public function setProxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_HEADER, false);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if (!is_null($this->username) && !is_null($this->password)) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . \":\" . $this->password);\n        }\n        if (!is_null($this->proxy)) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy);\n        }\n\n        $headers = [];\n        if (is_array($this->request_headers)) {\n            foreach ($this->request_headers as $k => $v) {\n                $headers[] = \"$k: $v\";\n            }\n        }\n        if (!empty($headers)) {\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n\n        if (!is_null($this->read_stream)) {\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $stats = fstat($this->read_stream);\n                    $this->read_stream_size = $stats[7];\n                }\n            }\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            if (isset($this->registered_streaming_read_callback)) {\n                curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n            }\n        }\n\n        if (!is_null($this->write_stream)) {\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n            if (isset($this->registered_streaming_write_callback)) {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            }\n        }\n\n        if (!is_null($this->seek_position) && $this->seek_position !== 0 && !is_null($this->read_stream)) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n        if (!is_null($this->curlopts) && is_array($this->curlopts)) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        $this->curl_handle = $curl_handle;\n        return $this->curl_handle;\n    }\n\n    public function sendRequest($parse = false)\n    {\n        $curl_handle = $this->prepRequest();\n        $this->response = curl_exec($curl_handle);\n\n        if ($parse) {\n            $this->processResponse($curl_handle, $this->response);\n        }\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n        curl_close($curl_handle);\n        return $this->response;\n    }\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if (!is_null($curl_handle) && !is_null($response)) {\n            $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = $this->parseHeaders(substr($response, 0, $header_size));\n            $this->response_body = substr($response, $header_size);\n            return $this->response_body;\n        }\n        return null;\n    }\n\n    private function parseHeaders($headers_string)\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", $headers_string);\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $key = trim($key);\n                $value = trim($value);\n                $headers[$key] = $value;\n            }\n        }\n        return $headers;\n    }\n\n\n    public function isBaeEnv()\n    {\n        return (getenv('HTTP_BAE_ENV_APPID') || getenv('BAE_ENV_APPID'));\n    }\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        } else {\n            return $this->response_headers;\n        }\n    }\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}\n\n",
      "<?php\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers = [];\n    public $response_body = '';\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method = 'GET';\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BcsRequestcore';\n    public $response_class = 'BcsRequestcore';\n    public $useragent = 'Bcs Client PHP SDK';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (isset($helpers['request']) && is_string($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && is_string($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n    public function __destruct()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function setProxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_HEADER, false);\n\n\n        $headers = [];\n        if (is_array($this->request_headers)) {\n            foreach ($this->request_headers as $k => $v) {\n                $headers[] = \"$k: $v\";\n            }\n        }\n        if (!empty($headers)) {\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n\n\n        if ($this->proxy) {\n            $proxy = $this->proxy;\n            curl_setopt($curl_handle, CURLOPT_PROXY, $proxy['host']);\n            if (isset($proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $proxy['port']);\n            }\n            if (isset($proxy['user']) && isset($proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $proxy['user'] . ':' . $proxy['pass']);\n            }\n        }\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if ($this->method === 'POST') {\n            curl_setopt($curl_handle, CURLOPT_POST, true);\n            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        } elseif ($this->method === 'PUT' || $this->method === 'DELETE' || $this->method === 'HEAD') {\n            curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n            if ($this->request_body) {\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n            }\n        }\n\n\n        if ($this->read_stream || $this->read_file) {\n\n            if ($this->read_file) {\n                $this->read_stream = fopen($this->read_file, 'r');\n            }\n\n            if (!$this->read_stream_size && $this->read_file) {\n                $stats = fstat($this->read_stream);\n                $this->read_stream_size = $stats['size'];\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, [$this, 'streaming_read_callback']);\n        }\n\n        if ($this->write_stream || $this->write_file) {\n            if ($this->write_file) {\n                $this->write_stream = fopen($this->write_file, 'w');\n            }\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, [$this, 'streaming_write_callback']);\n        }\n\n        if ($this->seek_position) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        $this->curl_handle = $curl_handle;\n        return $curl_handle;\n    }\n\n    public function sendRequest($parse = false)\n    {\n        $curl_handle = $this->prepRequest();\n        $this->response = curl_exec($curl_handle);\n\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n\n        if ($this->debug_mode) {\n            error_log(\"[DEBUG] HTTP Response Code: \" . $this->response_code);\n            error_log(\"[DEBUG] Raw Response: \" . $this->response);\n        }\n\n        if ($parse) {\n            $this->processResponse($curl_handle, $this->response);\n        }\n\n        curl_close($curl_handle);\n        return $this->response;\n    }\n\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n        if (!$response) {\n            $response = $this->response;\n        }\n\n        $header_size = $this->response_info['header_size'];\n        $this->response_headers = $this->parseHeaders(substr($response, 0, $header_size));\n        $this->response_body = substr($response, $header_size);\n        return $this->response_body;\n    }\n\n    private function parseHeaders($headers_string)\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", $headers_string);\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n\n    private function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->registered_streaming_read_callback) {\n            return call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $length);\n        } else {\n            $data = fread($file_handle, $length);\n            $this->read_stream_read += strlen($data);\n            return $data;\n        }\n    }\n\n\n    private function streaming_write_callback($curl_handle, $data)\n    {\n        if ($this->registered_streaming_write_callback) {\n            return call_user_func($this->registered_streaming_write_callback, $curl_handle, $data);\n        } else {\n            $bytes = fwrite($this->write_stream, $data);\n            return $bytes;\n        }\n    }\n\n\n    public function isBaeEnv()\n    {\n        return (getenv('HTTP_BAE_ENV_APPID') || getenv('BAE_ENV_APPID'));\n    }\n\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        } else {\n            return $this->response_headers;\n        }\n    }\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}\n\n",
      "<?php\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers = [];\n    public $response_body = '';\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method = 'GET';\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BcsRequestcore';\n    public $response_class = 'BcsRequestcore';\n    public $useragent = 'BcsRequestcore PHP5';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (isset($helpers['request']) && is_string($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && is_string($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n    public function __destruct()\n    {\n        if (!is_null($this->read_file) && is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (!is_null($this->write_file) && is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        $this->read_stream = fopen($location, 'r');\n        return $this;\n    }\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        $this->write_stream = fopen($location, 'w');\n        return $this;\n    }\n\n    public function setProxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_HEADER, false);\n\n\n        if ($this->method === 'POST') {\n            curl_setopt($curl_handle, CURLOPT_POST, true);\n        } elseif ($this->method !== 'GET') {\n            curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n        }\n\n\n        if (!empty($this->request_body)) {\n            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        }\n\n        if (!empty($this->request_headers)) {\n            $headers = [];\n            foreach ($this->request_headers as $k => $v) {\n                $headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n\n\n        if ($this->proxy) {\n            $proxy = $this->proxy;\n            curl_setopt($curl_handle, CURLOPT_PROXY, $proxy['host']);\n            if (isset($proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $proxy['port']);\n            }\n            if (isset($proxy['user']) && isset($proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $proxy['user'] . ':' . $proxy['pass']);\n            }\n        }\n\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $stats = fstat($this->read_stream);\n                    $this->read_stream_size = $stats[7];\n                }\n            }\n\n            $read_callback = $this->registered_streaming_read_callback;\n            if ($read_callback) {\n                curl_setopt($curl_handle, CURLOPT_READFUNCTION, $read_callback);\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n\n            if ($this->seek_position) {\n                fseek($this->read_stream, $this->seek_position);\n            }\n        }\n\n        if ($this->write_stream) {\n            $write_callback = $this->registered_streaming_write_callback;\n            if ($write_callback) {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $write_callback);\n            } else {\n                curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n            }\n        }\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        $this->curl_handle = $curl_handle;\n        return $curl_handle;\n    }\n\n\n    public function sendRequest($parse = false)\n    {\n        $curl_handle = $this->prepRequest();\n\n        $this->response = curl_exec($curl_handle);\n\n        $this->response_info = curl_getinfo($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception('Curl error: ' . curl_error($curl_handle));\n        }\n\n        $this->response_code = $this->response_info['http_code'];\n\n        if ($parse) {\n            $this->processResponse($curl_handle, $this->response);\n        }\n\n        curl_close($curl_handle);\n        return $this->response;\n    }\n\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $header_size = $this->response_info['header_size'];\n            $this->response_headers = $this->parseHeaders(substr($response, 0, $header_size));\n            $this->response_body = substr($response, $header_size);\n            return $this->response_body;\n        }\n        return null;\n    }\n\n    private function parseHeaders($headers_string)\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $headers_string) as $i => $line) {\n            if ($i === 0) {\n                continue;\n            }\n            list($key, $value) = explode(': ', $line);\n            $headers[$key] = $value;\n        }\n        return $headers;\n    }\n\n    public function isBaeEnv()\n    {\n        return getenv('HTTP_BAE_ENV_APPID') && getenv('HTTP_HOST') === 'bcs.duapp.com';\n    }\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        } else {\n            return $this->response_headers;\n        }\n    }\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}\n\n",
      "<?php\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers = [];\n    public $response_body = '';\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method = 'GET';\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BcsRequestcore';\n    public $response_class = 'BcsRequestcore';\n    public $useragent = 'Bcs Client PHP SDK';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (isset($helpers['request']) && is_string($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && is_string($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n\n    public function __destruct()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n\n    public function removeHeader($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n\n    public function setReadStream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n\n    public function setProxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_HEADER, false);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            $proxy = $this->proxy;\n            curl_setopt($curl_handle, CURLOPT_PROXY, $proxy['host']);\n            if (isset($proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $proxy['port']);\n            }\n            if (isset($proxy['user']) && isset($proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $proxy['user'] . ':' . $proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        $http_headers = [];\n        if (is_array($this->request_headers)) {\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n        }\n        if (count($http_headers) > 0) {\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, true);\n                break;\n        }\n\n\n        if ($this->read_stream || $this->read_file) {\n            if ($this->read_file) {\n                $this->read_stream = fopen($this->read_file, 'r');\n            }\n\n            if ($this->seek_position) {\n                fseek($this->read_stream, $this->seek_position);\n            }\n\n            if ($this->registered_streaming_read_callback) {\n                curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n            } else {\n                curl_setopt($curl_handle, CURLOPT_READFUNCTION, function ($ch, $fd, $length) {\n                    return fread($this->read_stream, $length);\n                });\n            }\n\n            if ($this->read_stream_size) {\n                curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            }\n            curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n        }\n\n\n        if ($this->write_stream || $this->write_file) {\n            if ($this->write_file) {\n                $this->write_stream = fopen($this->write_file, 'w');\n            }\n\n            if ($this->registered_streaming_write_callback) {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            } else {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, function ($ch, $data) {\n                    return fwrite($this->write_stream, $data);\n                });\n            }\n\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        }\n\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        $this->curl_handle = $curl_handle;\n        return $curl_handle;\n    }\n\n\n    public function sendRequest($parse = false)\n    {\n        $curl_handle = $this->prepRequest();\n        $this->response = curl_exec($curl_handle);\n\n        if ($parse) {\n            $this->processResponse($curl_handle, $this->response);\n        }\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n\n        curl_close($curl_handle);\n        return $this->response;\n    }\n\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n        if (!$response) {\n            $response = $this->response;\n        }\n\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = $this->parseHeaders(substr($response, 0, $header_size));\n        $this->response_body = substr($response, $header_size);\n\n        return $this->response_body;\n    }\n\n\n    private function parseHeaders($headers_string)\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", $headers_string);\n        foreach ($lines as $line) {\n            $line = trim($line);\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $key = trim($key);\n                $value = trim($value);\n                $headers[$key] = $value;\n            }\n        }\n        return $headers;\n    }\n\n\n    public function isBaeEnv()\n    {\n        return getenv('HTTP_BAE_ENV_APPID') && getenv('HTTP_HOST');\n    }\n\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return isset($this->response_headers[$header]) ? $this->response_headers[$header] : null;\n        }\n        return $this->response_headers;\n    }\n\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}\n\n",
      "<?php\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers = [];\n    public $response_body = '';\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method = 'GET';\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BcsRequestcore';\n    public $response_class = 'BcsRequestcore';\n    public $useragent = 'BcsRequestcore PHP5';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (isset($helpers['request']) && is_string($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && is_string($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n\n    public function __destruct()\n    {\n        if (!is_null($this->read_file) && is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (!is_null($this->write_file) && is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n\n    public function removeHeader($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n\n    public function setReadStream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        $this->read_stream = fopen($location, 'r');\n        return $this;\n    }\n\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        $this->write_stream = fopen($location, 'w');\n        return $this;\n    }\n\n\n    public function setProxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_HEADER, false);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if (!is_null($this->username) && !is_null($this->password)) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . \":\" . $this->password);\n        }\n        if (!is_null($this->proxy)) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy);\n        }\n\n        $headers = [];\n        if (is_array($this->request_headers)) {\n            foreach ($this->request_headers as $k => $v) {\n                $headers[] = \"$k: $v\";\n            }\n        }\n        if (!empty($headers)) {\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n\n        if (!is_null($this->read_stream)) {\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $stats = fstat($this->read_stream);\n                    $this->read_stream_size = $stats[7];\n                }\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            if (!is_null($this->seek_position) && $this->seek_position !== ftell($this->read_stream)) {\n                if (fseek($this->read_stream, $this->seek_position) !== 0) {\n                    throw new Exception('Could not seek to specified position in stream.');\n                }\n            }\n\n            if ($this->registered_streaming_read_callback) {\n                curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n            }\n        }\n\n        if (!is_null($this->write_stream)) {\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n            if ($this->registered_streaming_write_callback) {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            }\n        }\n\n\n        if (is_array($this->curlopts)) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n        $this->curl_handle = $curl_handle;\n        return $curl_handle;\n    }\n\n\n    public function sendRequest($parse = false)\n    {\n        $curl_handle = $this->prepRequest();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception(\"Curl request failed: \" . curl_error($curl_handle));\n        }\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n\n        if ($parse) {\n            $this->processResponse($curl_handle, $this->response);\n        }\n\n        curl_close($curl_handle);\n        return $this->response;\n    }\n\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $header_size = $this->response_info['header_size'];\n            $this->response_headers = $this->parseHeaders(substr($response, 0, $header_size));\n            $this->response_body = substr($response, $header_size);\n        }\n        return $this;\n    }\n\n\n    private function parseHeaders($headers_string)\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $headers_string) as $i => $line) {\n            if ($i === 0) {\n                continue;\n            }\n            list($key, $value) = explode(': ', $line);\n            $headers[$key] = $value;\n        }\n        return $headers;\n    }\n\n\n    public function isBaeEnv()\n    {\n        return (getenv('HTTP_BAE_ENV_APPID') || getenv('BAE_ENV_APPID'));\n    }\n\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        } else {\n            return $this->response_headers;\n        }\n    }\n\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}\n\n",
      "<?php\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers = [];\n    public $response_body = '';\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method = 'GET';\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BcsRequestcore';\n    public $response_class = 'BcsRequestcore';\n    public $useragent = 'BcsRequestcore PHP5';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (isset($helpers['request']) && is_string($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && is_string($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n\n    public function __destruct()\n    {\n        if (!is_null($this->read_file) && is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (!is_null($this->write_file) && is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n\n    public function removeHeader($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n\n    public function setReadStream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        $this->read_stream = fopen($location, 'r');\n        return $this;\n    }\n\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        $this->write_stream = fopen($location, 'w');\n        return $this;\n    }\n\n\n    public function setProxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n\n        $options = [\n            CURLOPT_URL => $this->request_url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HEADER => true,\n            CURLOPT_USERAGENT => $this->useragent,\n            CURLOPT_CUSTOMREQUEST => $this->method\n        ];\n\n        if (isset($this->request_headers) && is_array($this->request_headers)) {\n            $options[CURLOPT_HTTPHEADER] = [];\n            foreach ($this->request_headers as $k => $v) {\n                $options[CURLOPT_HTTPHEADER][] = \"$k: $v\";\n            }\n        }\n\n        if (!is_null($this->read_stream)) {\n            $options[CURLOPT_INFILE] = $this->read_stream;\n            $options[CURLOPT_INFILESIZE] = $this->read_stream_size;\n            $options[CURLOPT_READFUNCTION] = function ($ch, $fd, $length) {\n                if (!is_null($this->registered_streaming_read_callback)) {\n                    return call_user_func($this->registered_streaming_read_callback, $ch, $fd, $length);\n                }\n                return fread($this->read_stream, $length);\n            };\n        } elseif (isset($this->request_body)) {\n            $options[CURLOPT_POSTFIELDS] = $this->request_body;\n        }\n\n        if (!is_null($this->write_stream)) {\n            $options[CURLOPT_FILE] = $this->write_stream;\n            $options[CURLOPT_WRITEFUNCTION] = function ($ch, $data) {\n                if (!is_null($this->registered_streaming_write_callback)) {\n                    $written = call_user_func($this->registered_streaming_write_callback, $ch, $data);\n                    return ($written === true ? strlen($data) : $written);\n                }\n                return fwrite($this->write_stream, $data);\n            };\n        }\n\n        if (!is_null($this->seek_position) && isset($options[CURLOPT_INFILE])) {\n            fseek($options[CURLOPT_INFILE], $this->seek_position);\n        }\n\n        if (!is_null($this->proxy)) {\n            $options[CURLOPT_PROXY] = $this->proxy;\n        }\n\n        if (!is_null($this->username) && !is_null($this->password)) {\n            $options[CURLOPT_USERPWD] = $this->username . \":\" . $this->password;\n        }\n\n        if (is_array($this->curlopts)) {\n            foreach ($this->curlopts as $k => $v) {\n                $options[$k] = $v;\n            }\n        }\n\n        curl_setopt_array($curl_handle, $options);\n        $this->curl_handle = $curl_handle;\n        return $curl_handle;\n    }\n\n\n    public function sendRequest($parse = false)\n    {\n        $curl_handle = $this->prepRequest();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception('Curl error: ' . curl_error($curl_handle));\n        }\n\n        $this->response_info = curl_getinfo($curl_handle);\n\n        if ($parse) {\n            $this->processResponse($curl_handle, $this->response);\n        }\n\n        curl_close($curl_handle);\n        return $this->response;\n    }\n\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->response_info = curl_getinfo($curl_handle);\n            $header_size = $this->response_info['header_size'];\n            $this->response_headers = $this->parseHeaders(substr($response, 0, $header_size));\n            $this->response_body = substr($response, $header_size);\n            $this->response_code = $this->response_info['http_code'];\n        }\n        return $this;\n    }\n\n\n    private function parseHeaders($headers)\n    {\n        $retVal = [];\n        $fields = explode(\"\\r\\n\", preg_replace('/\\x0D\\x0A[\\x09\\x20]+/', ' ', $headers));\n        foreach ($fields as $field) {\n            if (preg_match('/([^:]+): (.+)/m', $field, $match)) {\n                $match[1] = preg_replace_callback(\n                    '/(?<=^|[\\x09\\x20\\x2D])./',\n                    function ($matches) {\n                        return strtoupper($matches[0]);\n                    },\n                    strtolower(trim($match[1]))\n                );\n                if (isset($retVal[$match[1]])) {\n                    $retVal[$match[1]] = [$retVal[$match[1]], $match[2]];\n                } else {\n                    $retVal[$match[1]] = trim($match[2]);\n                }\n            }\n        }\n        return $retVal;\n    }\n\n\n    public function isBaeEnv()\n    {\n        return (getenv('HTTP_BAE_ENV_APPID') || getenv('BAE_ENV_APPID'));\n    }\n\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        } else {\n            return $this->response_headers;\n        }\n    }\n\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}\n\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 68,
    "Instruction": "Task Description: Create a PHP class that implements a simple HTTP client using cURL for making GET requests, with configurable options and proper error handling.\n\nClass Description: The SimpleHttpClient class provides functionality to send HTTP GET requests using PHP's cURL extension. It includes default cURL options that can be customized, handles errors appropriately, and parses the response into status code, headers, and body.\n\nAttributes:\n\ncurlOptions: [array] - An associative array of default cURL options including settings for headers, redirects, timeouts, and response handling.\n\nMethods:\n\nhttpGet: [Name]($url, $options) -> [array] - Sends an HTTP GET request to the specified URL with optional configuration. Returns an associative array containing the response status code, headers, and body.\n- Parameters:\n  - $url: [string] - The target URL for the GET request\n  - $options: [array] - Optional configuration array (currently only supports 'timeout' override)\n- Return: [array] - Associative array with keys: 'statusCode' (int), 'headers' (array), and 'body' (string)\n- Throws: RuntimeException when cURL encounters an error",
    "Canonical_solution": "namespace Hhxsv5\\LaravelS\\Components\\HttpClient;\n\nuse Swoole\\Coroutine\\Http\\Client as CoroutineClient;\n\nclass SimpleHttpClient\n{\n    protected $curlOptions = [\n        CURLOPT_HEADER         => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_MAXREDIRS      => 3,\n        CURLOPT_TIMEOUT        => 5,\n        CURLOPT_CONNECTTIMEOUT => 3,\n    ];\n\n    public function httpGet($url, array $options)\n    {\n        $handle = curl_init();\n        $finalOptions = [\n                CURLOPT_URL     => $url,\n                CURLOPT_HTTPGET => true,\n            ] + $this->curlOptions;\n        if (isset($options['timeout'])) {\n            $finalOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        }\n        curl_setopt_array($handle, $finalOptions);\n        $responseStr = curl_exec($handle);\n        $errno = curl_errno($handle);\n        $errmsg = curl_error($handle);\n        if ($errno !== 0 || $errmsg !== '') {\n            curl_close($handle);\n            $msg = sprintf('Failed to send Http request(%s), errcode=%d, errmsg=%s', $url, $errno, $errmsg);\n            throw new \\RuntimeException($msg, $errno);\n        }\n\n        $headerSize = curl_getinfo($handle, CURLINFO_HEADER_SIZE);\n        $statusCode = curl_getinfo($handle, CURLINFO_HTTP_CODE);\n        curl_close($handle);\n\n        $header = substr($responseStr, 0, $headerSize);\n        $body = substr($responseStr, $headerSize);\n        $lines = explode(\"\\n\", $header);\n        array_shift($lines);\n\n        $headers = [];\n        foreach ($lines as $part) {\n            $middle = explode(':', $part);\n            $key = trim($middle[0]);\n            if ($key === '') {\n                continue;\n            }\n            if (isset($headers[$key])) {\n                $headers[$key] = (array)$headers[$key];\n                $headers[$key][] = isset($middle[1]) ? trim($middle[1]) : '';\n            } else {\n                $headers[$key] = isset($middle[1]) ? trim($middle[1]) : '';\n            }\n        }\n        return ['statusCode' => $statusCode, 'headers' => $headers, 'body' => $body];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass SimpleHttpClient\n{\n    private $curlOptions = [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_FAILONERROR => false,\n    ];\n\n    public function httpGet(string $url, array $options = []): array\n    {\n        $ch = curl_init($url);\n\n        $mergedOptions = $this->curlOptions;\n        if (isset($options['timeout'])) {\n            $mergedOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        }\n\n        curl_setopt_array($ch, $mergedOptions);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new RuntimeException(\"cURL Error: \" . $error);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = $this->parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return [\n            'statusCode' => $statusCode,\n            'headers' => $headers,\n            'body' => $body,\n        ];\n    }\n\n\n    private function parseHeaders(string $rawHeaders): array\n    {\n        $headers = [];\n        $headerLines = explode(\"\\r\\n\", trim($rawHeaders));\n        array_shift($headerLines); \n\n        foreach ($headerLines as $headerLine) {\n            [$key, $value] = explode(':', $headerLine, 2);\n            $headers[trim($key)] = trim($value);\n        }\n\n        return $headers;\n    }\n}\n\n?>\n",
      "<?php\n\nclass SimpleHttpClient\n{\n    private $curlOptions = [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_FAILONERROR => true,\n    ];\n\n    public function httpGet(string $url, array $options = []): array\n    {\n        $ch = curl_init($url);\n\n        $mergedOptions = $this->curlOptions;\n        if (isset($options['timeout'])) {\n            $mergedOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        }\n\n        curl_setopt_array($ch, $mergedOptions);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new RuntimeException(\"cURL Error: \" . $error);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = $this->parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return [\n            'statusCode' => $statusCode,\n            'headers' => $headers,\n            'body' => $body,\n        ];\n    }\n\n    private function parseHeaders(string $rawHeaders): array\n    {\n        $headers = [];\n        $headerLines = explode(\"\\r\\n\", trim($rawHeaders));\n        array_shift($headerLines); // Remove the HTTP status line\n\n        foreach ($headerLines as $headerLine) {\n            [$key, $value] = explode(':', $headerLine, 2);\n            $headers[trim($key)] = trim($value);\n        }\n\n        return $headers;\n    }\n}\n\n?>\n",
      "<?php\n\nclass SimpleHttpClient\n{\n    private $curlOptions = [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 5,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_FAILONERROR => false,\n    ];\n\n    public function httpGet(string $url, array $options = []): array\n    {\n        $ch = curl_init($url);\n\n        $mergedOptions = $this->curlOptions;\n        if (isset($options['timeout'])) {\n            $mergedOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        }\n\n        curl_setopt_array($ch, $mergedOptions);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new RuntimeException(\"cURL error: \" . $error);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = $this->parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return [\n            'statusCode' => $statusCode,\n            'headers' => $headers,\n            'body' => $body,\n        ];\n    }\n\n    private function parseHeaders(string $rawHeaders): array\n    {\n        $headers = [];\n        $headerLines = explode(\"\\r\\n\", trim($rawHeaders));\n        array_shift($headerLines); // Remove HTTP status line\n\n        foreach ($headerLines as $headerLine) {\n            [$key, $value] = explode(':', $headerLine, 2);\n            $headers[trim($key)] = trim($value);\n        }\n\n        return $headers;\n    }\n}\n\n?>\n",
      "<?php\n\nclass SimpleHttpClient\n{\n    private $curlOptions = [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_FAILONERROR => false,\n    ];\n\n    public function httpGet($url, $options = [])\n    {\n        $ch = curl_init($url);\n\n        $mergedOptions = $this->curlOptions;\n        if (isset($options['timeout'])) {\n            $mergedOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        }\n\n        curl_setopt_array($ch, $mergedOptions);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new RuntimeException(\"cURL Error: \" . $error);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = $this->parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return [\n            'statusCode' => $statusCode,\n            'headers' => $headers,\n            'body' => $body,\n        ];\n    }\n\n\n    private function parseHeaders($rawHeaders)\n    {\n        $headers = [];\n        $headerLines = explode(\"\\r\\n\", trim($rawHeaders));\n        array_shift($headerLines); // Remove HTTP status line\n\n        foreach ($headerLines as $headerLine) {\n            list($key, $value) = explode(':', $headerLine, 2);\n            $headers[trim($key)] = trim($value);\n        }\n\n        return $headers;\n    }\n}\n\n?>\n",
      "<?php\n\nclass SimpleHttpClient\n{\n    private $curlOptions = [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_FAILONERROR => false,\n    ];\n\n    public function httpGet(string $url, array $options = []): array\n    {\n        $ch = curl_init($url);\n\n        $mergedOptions = $this->curlOptions;\n        if (isset($options['timeout'])) {\n            $mergedOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        }\n\n        curl_setopt_array($ch, $mergedOptions);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new RuntimeException(\"cURL Error: \" . $error);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = $this->parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return [\n            'statusCode' => $statusCode,\n            'headers' => $headers,\n            'body' => $body,\n        ];\n    }\n\n\n    private function parseHeaders(string $rawHeaders): array\n    {\n        $headers = [];\n        $headerLines = explode(\"\\r\\n\", trim($rawHeaders));\n        array_shift($headerLines); \n\n        foreach ($headerLines as $headerLine) {\n            [$key, $value] = explode(':', $headerLine, 2);\n            $headers[trim($key)] = trim($value);\n        }\n\n        return $headers;\n    }\n}\n\n?>\n",
      "<?php\n\nclass SimpleHttpClient\n{\n    private $curlOptions = [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_FAILONERROR => false,\n    ];\n\n    public function httpGet(string $url, array $options = []): array\n    {\n        $ch = curl_init($url);\n\n        $mergedOptions = $this->curlOptions;\n        if (isset($options['timeout'])) {\n            $mergedOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        }\n\n        curl_setopt_array($ch, $mergedOptions);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new RuntimeException(\"cURL error: \" . $error);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $headers = $this->parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n\n        curl_close($ch);\n\n        return [\n            'statusCode' => $statusCode,\n            'headers' => $headers,\n            'body' => $body,\n        ];\n    }\n\n\n    private function parseHeaders(string $rawHeaders): array\n    {\n        $headers = [];\n        $headerLines = explode(\"\\r\\n\", trim($rawHeaders));\n        array_shift($headerLines); \n\n        foreach ($headerLines as $headerLine) {\n            [$key, $value] = explode(':', $headerLine, 2);\n            $headers[trim($key)] = trim($value);\n        }\n\n        return $headers;\n    }\n}\n\n?>\n",
      "<?php\n\nclass SimpleHttpClient\n{\n    private $curlOptions = [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 5,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_FAILONERROR => false,\n    ];\n\n    public function httpGet(string $url, array $options = []): array\n    {\n        $ch = curl_init($url);\n\n        $mergedOptions = $this->curlOptions;\n        if (isset($options['timeout'])) {\n            $mergedOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        }\n\n        curl_setopt_array($ch, $mergedOptions);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new RuntimeException(\"cURL Error: \" . $error);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = $this->parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return [\n            'statusCode' => $statusCode,\n            'headers' => $headers,\n            'body' => $body,\n        ];\n    }\n\n\n    private function parseHeaders(string $rawHeaders): array\n    {\n        $headers = [];\n        $headerLines = explode(\"\\r\\n\", trim($rawHeaders));\n        array_shift($headerLines); // Remove the HTTP status line\n\n        foreach ($headerLines as $headerLine) {\n            [$key, $value] = explode(':', $headerLine, 2);\n            $headers[trim($key)] = trim($value);\n        }\n\n        return $headers;\n    }\n}\n\n?>\n",
      "<?php\n\nclass SimpleHttpClient\n{\n    private $curlOptions = [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_FAILONERROR => false,\n    ];\n\n    public function httpGet($url, $options = [])\n    {\n        $ch = curl_init($url);\n\n        $mergedOptions = $this->curlOptions;\n        if (isset($options['timeout'])) {\n            $mergedOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        }\n\n        curl_setopt_array($ch, $mergedOptions);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new RuntimeException(\"cURL error: \" . $error);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $headers = $this->parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n\n        curl_close($ch);\n\n        return [\n            'statusCode' => $statusCode,\n            'headers' => $headers,\n            'body' => $body,\n        ];\n    }\n\n\n    private function parseHeaders($rawHeaders)\n    {\n        $headers = [];\n        $headerLines = explode(\"\\r\\n\", trim($rawHeaders));\n        array_shift($headerLines); \n\n        foreach ($headerLines as $headerLine) {\n            list($key, $value) = explode(':', $headerLine, 2);\n            $headers[trim($key)] = trim($value);\n        }\n\n        return $headers;\n    }\n}\n\n?>\n",
      "<?php\n\nclass SimpleHttpClient\n{\n    private $curlOptions = [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_FAILONERROR => false,\n    ];\n\n    public function httpGet(string $url, array $options = []): array\n    {\n        $ch = curl_init($url);\n\n        $mergedOptions = $this->curlOptions;\n        if (isset($options['timeout'])) {\n            $mergedOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        }\n\n        curl_setopt_array($ch, $mergedOptions);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new RuntimeException(\"cURL Error: \" . $error);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $headers = $this->parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n\n        curl_close($ch);\n\n        return [\n            'statusCode' => $statusCode,\n            'headers' => $headers,\n            'body' => $body,\n        ];\n    }\n\n    private function parseHeaders(string $rawHeaders): array\n    {\n        $headers = [];\n        $headerLines = explode(\"\\r\\n\", trim($rawHeaders));\n        array_shift($headerLines); // Remove HTTP status line\n\n        foreach ($headerLines as $headerLine) {\n            [$key, $value] = explode(':', $headerLine, 2);\n            $headers[trim($key)] = trim($value);\n        }\n\n        return $headers;\n    }\n}\n\n?>\n",
      "<?php\n\nclass SimpleHttpClient\n{\n    private $curlOptions = [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HEADER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_FAILONERROR => false,\n    ];\n\n    public function httpGet(string $url, array $options = []): array\n    {\n        $ch = curl_init($url);\n\n        $mergedOptions = $this->curlOptions;\n        if (isset($options['timeout'])) {\n            $mergedOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        }\n\n        curl_setopt_array($ch, $mergedOptions);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            throw new RuntimeException(\"cURL error: \" . $error);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = $this->parseHeaders(substr($response, 0, $headerSize));\n        $body = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return [\n            'statusCode' => $statusCode,\n            'headers' => $headers,\n            'body' => $body,\n        ];\n    }\n\n    private function parseHeaders(string $rawHeaders): array\n    {\n        $headers = [];\n        $headerLines = explode(\"\\r\\n\", trim($rawHeaders));\n        array_shift($headerLines); // Remove the HTTP status line\n\n        foreach ($headerLines as $headerLine) {\n            [$name, $value] = explode(':', $headerLine, 2);\n            $headers[trim($name)] = trim($value);\n        }\n\n        return $headers;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Implement a class for interacting with Baidu Cloud Storage (BCS) using HTTP requests through cURL in PHP, handling file uploads, downloads, and other operations with proper error handling and response parsing.\n\nClass Description: The Bcs class provides an interface to interact with Baidu Cloud Storage (BCS) service. It handles authentication, HTTP requests, and response processing for various operations on cloud storage.\n\nAttributes:\n- rootPath: [string] - The root path for storage operations\n- error: [string] - Stores the last error message encountered\n- config: [array] - Configuration array containing AccessKey, SecretKey, bucket, rename, and timeout settings\n- bcs: [BaiduBCS|null] - Instance of the BaiduBCS client\n\nMethods:\n- __construct([array $config]) -> [void] - Initializes the BCS client with configuration including AccessKey, SecretKey, and other settings\n- request([string $path], [string $method], [array|null $headers], [mixed $body]) -> [mixed] - Makes an HTTP request to BCS service and processes the response\n- response([string $text]) -> [array] - Parses the JSON response from BCS into an array\n- error([string $header]) -> [void] - Processes error responses from BCS and sets the error message\n\nThe request method specifically handles:\n1. Initializing cURL session\n2. Setting request headers and body\n3. Configuring request method (GET, POST, PUT, HEAD)\n4. Executing the request\n5. Processing response and errors\n6. Cleaning up resources",
    "Canonical_solution": "use Think\\Upload\\Driver\\Bcs\\BaiduBCS;\n\nclass Bcs\n{\n    private $rootPath;\n    const DEFAULT_URL = 'bcs.duapp.com';\n    private $error = '';\n    public $config = array(\n        'AccessKey'=> '',\n        'SecretKey'=> '',\n        'bucket'   => '',\n        'rename'   => false,\n        'timeout'  => 3600,\n    );\n    public $bcs = null;\n\n    public function __construct($config)\n    {\n        $this->config = array_merge($this->config, $config);\n        $bcsClass = dirname(__FILE__). \"/Bcs/bcs.class.php\";\n        if(is_file($bcsClass))\n            require_once($bcsClass);\n        $this->bcs = new BaiduBCS($this->config['AccessKey'], $this->config['SecretKey'], self::DEFAULT_URL);\n    }\n\n    private function request($path, $method, $headers = null, $body = null)\n    {\n        $ch = curl_init($path);\n        $_headers = array('Expect:');\n        if (!is_null($headers) && is_array($headers)){\n            foreach($headers as $k => $v) {\n                array_push($_headers, \"{$k}: {$v}\");\n            }\n        }\n\n        $length = 0;\n        $date = gmdate('D, d M Y H:i:s \\G\\M\\T');\n        if (!is_null($body)) {\n            if(is_resource($body)){\n                fseek($body, 0, SEEK_END);\n                $length = ftell($body);\n                fseek($body, 0);\n                array_push($_headers, \"Content-Length: {$length}\");\n                curl_setopt($ch, CURLOPT_INFILE, $body);\n                curl_setopt($ch, CURLOPT_INFILESIZE, $length);\n            } else {\n                $length = @strlen($body);\n                array_push($_headers, \"Content-Length: {$length}\");\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $body);\n            }\n        } else {\n            array_push($_headers, \"Content-Length: {$length}\");\n        }\n\n        array_push($_headers, \"Date: {$date}\");\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $_headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->config['timeout']);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 0);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n\n        if ($method == 'PUT' || $method == 'POST') {\n            curl_setopt($ch, CURLOPT_POST, 1);\n        } else {\n            curl_setopt($ch, CURLOPT_POST, 0);\n        }\n\n        if ($method == 'HEAD') {\n            curl_setopt($ch, CURLOPT_NOBODY, true);\n        }\n\n        $response = curl_exec($ch);\n        $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        list($header, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n        if ($status == 200) {\n            if ($method == 'GET') {\n                return $body;\n            } else {\n                $data = $this->response($header);\n                return count($data) > 0 ? $data : true;\n            }\n        } else {\n            $this->error($header);\n            return false;\n        }\n    }\n\n    private function response($text)\n    {\n        $items = json_decode($text, true);\n        return $items;\n    }\n\n    private function error($header)\n    {\n        list($status, $stash) = explode(\"\\r\\n\", $header, 2);\n        list($v, $code, $message) = explode(\" \", $status, 3);\n        $message = is_null($message) ? 'File Not Found' : \"[{$status}]:{$message}\";\n        $this->error = $message;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass Bcs {\n    public $rootPath;\n    public $error;\n    protected $config;\n    protected $bcs;\n\n    public function __construct($config) {\n        $this->config = array_merge([\n            'AccessKey' => '',\n            'SecretKey' => '',\n            'bucket' => '',\n            'rename' => false,\n            'timeout' => 60,\n        ], $config);\n        $this->rootPath = $this->config['bucket'] . '/';\n    }\n\n    public function request($path, $method, $headers = null, $body = null) {\n        $url = 'http://bcs.duapp.com' . $this->rootPath . $path;\n        $ch = curl_init($url);\n        $headers = $headers ?: [];\n        $headers[] = 'Content-Type: application/x-www-form-urlencoded';\n\n        $options = [\n            CURLOPT_CUSTOMREQUEST => $method,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_HEADER => true,\n            CURLOPT_TIMEOUT => $this->config['timeout'],\n        ];\n\n        if ($body) {\n            $options[CURLOPT_POSTFIELDS] = $body;\n        }\n\n        curl_setopt_array($ch, $options);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $this->error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        curl_close($ch);\n\n        if (strpos($header, 'HTTP/1.1 200') === false) {\n            $this->error($header);\n            return false;\n        }\n\n        return $this->response($body);\n    }\n\n    public function response($text) {\n        return json_decode($text, true);\n    }\n\n    protected function error($header) {\n        preg_match('/HTTP\\/1.1 ([0-9]{3}) (.*)\\r\\n/', $header, $matches);\n        $this->error = $matches[1] . ' ' . $matches[2];\n    }\n}\n?>\n",
      "<?php\nclass Bcs {\n    public $rootPath;\n    public $error;\n    protected $config;\n    protected $bcs;\n\n    public function __construct($config) {\n        $this->config = array_merge([\n            'AccessKey' => '',\n            'SecretKey' => '',\n            'bucket' => '',\n            'rename' => false,\n            'timeout' => 60,\n        ], $config);\n        $this->rootPath = $this->config['bucket'] . '/';\n    }\n\n    public function request($path, $method, $headers = null, $body = null) {\n        $url = 'http://bcs.duapp.com/' . $this->rootPath . $path;\n        $ch = curl_init($url);\n        $options = [\n            CURLOPT_CUSTOMREQUEST => $method,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HEADER => true,\n            CURLOPT_TIMEOUT => $this->config['timeout'],\n        ];\n\n        if ($headers) {\n            $options[CURLOPT_HTTPHEADER] = $headers;\n        }\n\n        if ($body) {\n            $options[CURLOPT_POSTFIELDS] = $body;\n        }\n\n        curl_setopt_array($ch, $options);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $this->error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        curl_close($ch);\n\n        if (strpos($header, 'HTTP/1.1 2') !== 0) {\n            $this->error($header);\n            return false;\n        }\n\n        return $this->response($body);\n    }\n\n    public function response($text) {\n        return json_decode($text, true);\n    }\n\n    protected function error($header) {\n        $matches = [];\n        preg_match('/HTTP\\/1.1 ([0-9]{3}) (.*)\\r\\n/', $header, $matches);\n        $this->error = $matches[1] . ' ' . $matches[2];\n    }\n}\n?>\n",
      "<?php\n\nclass Bcs {\n    public $rootPath;\n    public $error;\n    protected $config;\n    protected $bcs;\n\n    public function __construct($config) {\n        $this->config = array_merge([\n            'AccessKey' => '',\n            'SecretKey' => '',\n            'bucket' => '',\n            'rename' => false,\n            'timeout' => 60,\n        ], $config);\n        $this->rootPath = $config['bucket'];\n    }\n\n    public function request($path, $method, $headers = null, $body = null) {\n        $url = \"http://bcs.duapp.com\" . $path;\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->config['timeout']);\n\n        if ($headers) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $body);\n        }\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $this->error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        curl_close($ch);\n\n        if (strpos($header, 'HTTP/1.1 200') === 0) {\n            return $body ? $this->response($body) : true;\n        } else {\n            $this->error($header);\n            return false;\n        }\n    }\n\n    public function response($text) {\n        return json_decode($text, true);\n    }\n\n    public function error($header) {\n        $matches = [];\n        preg_match('/HTTP\\/1.1 (\\d+) (.*?)\\r\\n/', $header, $matches);\n        $status_code = $matches[1];\n        $status_message = $matches[2];\n        $this->error = \"HTTP Status: \" . $status_code . \" \" . $status_message;\n    }\n}\n\n?>\n",
      "<?php\nclass Bcs {\n    public $rootPath;\n    public $error;\n    protected $config;\n    protected $bcs;\n\n    public function __construct($config) {\n        $this->config = array_merge([\n            'AccessKey' => '',\n            'SecretKey' => '',\n            'bucket' => '',\n            'rename' => false,\n            'timeout' => 60,\n        ], $config);\n        $this->rootPath = $config['bucket'];\n    }\n\n    public function request($path, $method, $headers = null, $body = null) {\n        $url = \"http://bcs.duapp.com\" . $path;\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->config['timeout']);\n\n        if ($headers) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $body);\n        }\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $this->error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        curl_close($ch);\n\n        if (strpos($header, 'HTTP/1.1 200') === 0) {\n            return $body ? $this->response($body) : true;\n        } else {\n            $this->error($header);\n            return false;\n        }\n    }\n\n\n    public function response($text) {\n        return json_decode($text, true);\n    }\n\n    public function error($header) {\n        $matches = [];\n        preg_match('/HTTP\\/1.1 (\\d+) (.*?)\\r\\n/', $header, $matches);\n        $code = $matches[1];\n        $message = $matches[2];\n        $this->error = \"HTTP Error: \" . $code . \" \" . $message;\n    }\n}\n?>\n",
      "<?php\n\nclass Bcs {\n    public $rootPath;\n    public $error;\n    protected $config;\n    protected $bcs;\n\n    public function __construct($config) {\n        $this->config = array_merge([\n            'AccessKey' => '',\n            'SecretKey' => '',\n            'bucket' => '',\n            'rename' => false,\n            'timeout' => 60,\n        ], $config);\n        $this->rootPath = $config['bucket'];\n    }\n\n    public function request($path, $method, $headers = null, $body = null) {\n        $url = \"http://bcs.duapp.com\" . $path;\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->config['timeout']);\n\n        if ($headers) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $body);\n        }\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $this->error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        curl_close($ch);\n\n        if (strpos($header, 'HTTP/1.1 200') === 0) {\n            return $body ? $this->response($body) : true;\n        } else {\n            $this->error($header);\n            return false;\n        }\n    }\n\n    public function response($text) {\n        return json_decode($text, true);\n    }\n\n    public function error($header) {\n        $matches = [];\n        preg_match('/HTTP\\/1.1 (\\d+) (.*?)\\r\\n/', $header, $matches);\n        $status_code = $matches[1];\n        $status_message = $matches[2];\n\n        $this->error = \"HTTP Status Code: \" . $status_code . \" - \" . $status_message;\n\n        if (preg_match('/x-bs-error-code: (.*?)\\r\\n/', $header, $matches)) {\n            $this->error .= \", BCS Error Code: \" . $matches[1];\n        }\n\n        if (preg_match('/x-bs-error-message: (.*?)\\r\\n/', $header, $matches)) {\n            $this->error .= \", BCS Error Message: \" . $matches[1];\n        }\n    }\n}\n?>\n",
      "<?php\n\nclass Bcs {\n    public $rootPath;\n    public $error;\n    protected $config;\n    protected $bcs;\n\n    public function __construct($config) {\n        $this->config = array_merge([\n            'AccessKey' => '',\n            'SecretKey' => '',\n            'bucket' => '',\n            'rename' => false,\n            'timeout' => 300,\n        ], $config);\n        $this->rootPath = $this->config['bucket'] . '/';\n    }\n\n    public function request($path, $method, $headers = null, $body = null) {\n        $url = 'http://bcs.duapp.com/' . $this->rootPath . $path;\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->config['timeout']);\n\n        if ($headers) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $body);\n        }\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $this->error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        curl_close($ch);\n\n        if (strpos($header, 'HTTP/1.1 200') === 0) {\n            return $body;\n        } else {\n            $this->error($header);\n            return false;\n        }\n    }\n\n\n    public function response($text) {\n        return json_decode($text, true);\n    }\n\n    public function error($header) {\n        $lines = explode(\"\\r\\n\", $header);\n        foreach ($lines as $line) {\n            if (strpos($line, 'HTTP/1.1') === 0) {\n                $this->error = $line;\n                break;\n            }\n        }\n    }\n}\n\n?>\n",
      "<?php\nclass Bcs {\n    public $rootPath;\n    public $error;\n    protected $config;\n    protected $bcs;\n\n    public function __construct($config) {\n        $this->config = array_merge([\n            'AccessKey' => '',\n            'SecretKey' => '',\n            'bucket' => '',\n            'rename' => false,\n            'timeout' => 300,\n        ], $config);\n        $this->rootPath = $config['bucket'];\n    }\n\n    public function request($path, $method, $headers = null, $body = null) {\n        $url = \"http://bcs.duapp.com\" . $path;\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->config['timeout']);\n\n        if ($headers) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $body);\n        }\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $this->error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        curl_close($ch);\n\n        if (strpos($header, 'HTTP/1.1 200') === false) {\n            $this->error($header);\n            return false;\n        }\n\n        return $this->response($body);\n    }\n\n\n    public function response($text) {\n        return json_decode($text, true);\n    }\n\n    protected function error($header) {\n        $matches = [];\n        preg_match('/HTTP\\/1.1 ([0-9]{3}) (.*)\\r\\n/', $header, $matches);\n        $this->error = $matches[2];\n    }\n}\n\n?>\n",
      "<?php\n\nclass Bcs {\n    public $rootPath;\n    public $error;\n    protected $config;\n    protected $bcs;\n\n    public function __construct($config) {\n        $this->config = array_merge([\n            'AccessKey' => '',\n            'SecretKey' => '',\n            'bucket' => '',\n            'rename' => false,\n            'timeout' => 60,\n        ], $config);\n        $this->rootPath = $config['bucket'] . '/';\n    }\n\n    public function request($path, $method, $headers = null, $body = null) {\n        $url = 'http://bcs.duapp.com/' . $this->rootPath . $path;\n        $ch = curl_init($url);\n        $options = [\n            CURLOPT_CUSTOMREQUEST => $method,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HEADER => true,\n            CURLOPT_TIMEOUT => $this->config['timeout'],\n        ];\n\n        if ($headers) {\n            $options[CURLOPT_HTTPHEADER] = $headers;\n        }\n\n        if ($body) {\n            $options[CURLOPT_POSTFIELDS] = $body;\n        }\n\n        curl_setopt_array($ch, $options);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $this->error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        curl_close($ch);\n\n        if (strpos($header, 'HTTP/1.1 200') === 0) {\n            return $body;\n        } else {\n            $this->error($header);\n            return false;\n        }\n    }\n\n    public function response($text) {\n        return json_decode($text, true);\n    }\n\n    public function error($header) {\n        $matches = [];\n        preg_match('/HTTP\\/1.1 ([0-9]{3}) (.*)\\r\\n/', $header, $matches);\n        $status = $matches[1];\n        $message = $matches[2];\n        $this->error = \"HTTP Status: \" . $status . \", Message: \" . $message;\n    }\n}\n\n?>\n",
      "<?php\n\nclass Bcs {\n    public $rootPath;\n    public $error;\n    protected $config;\n    protected $bcs;\n\n    public function __construct($config) {\n        $this->config = array_merge([\n            'AccessKey' => '',\n            'SecretKey' => '',\n            'bucket' => '',\n            'rename' => false,\n            'timeout' => 60,\n        ], $config);\n        $this->rootPath = $this->config['bucket'] . '/';\n    }\n\n    public function request($path, $method, $headers = null, $body = null) {\n        $url = 'http://bcs.duapp.com/' . $this->rootPath . $path;\n        $ch = curl_init($url);\n        $headers = $headers ?: [];\n        $headers[] = 'Content-Type: application/x-www-form-urlencoded';\n\n        $options = [\n            CURLOPT_CUSTOMREQUEST => $method,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_HEADER => true,\n            CURLOPT_TIMEOUT => $this->config['timeout'],\n        ];\n\n        if ($body !== null) {\n            $options[CURLOPT_POSTFIELDS] = $body;\n        }\n\n        curl_setopt_array($ch, $options);\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $this->error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        curl_close($ch);\n\n        if (strpos($header, 'HTTP/1.1 200') === false) {\n            $this->error($header);\n            return false;\n        }\n\n        return $this->response($body);\n    }\n\n\n    public function response($text) {\n        return json_decode($text, true);\n    }\n\n    protected function error($header) {\n        $matches = [];\n        preg_match('/HTTP\\/1.1 ([0-9]{3}) (.*)\\r\\n/', $header, $matches);\n        $this->error = $matches[1] . ' ' . $matches[2];\n    }\n}\n\n?>\n",
      "<?php\nclass Bcs {\n    public $rootPath;\n    public $error;\n    protected $config;\n    protected $bcs;\n\n    public function __construct($config) {\n        $this->config = array_merge([\n            'AccessKey' => '',\n            'SecretKey' => '',\n            'bucket' => '',\n            'rename' => false,\n            'timeout' => 60,\n        ], $config);\n        $this->rootPath = $config['bucket'];\n    }\n\n    public function request($path, $method, $headers = null, $body = null) {\n        $url = \"http://bcs.duapp.com\" . $path;\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->config['timeout']);\n\n        if ($headers) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $body);\n        }\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $this->error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        curl_close($ch);\n\n        if (strpos($header, 'HTTP/1.1 200') === 0) {\n            return $body ? $this->response($body) : true;\n        } else {\n            $this->error($header);\n            return false;\n        }\n    }\n\n    public function response($text) {\n        return json_decode($text, true);\n    }\n\n    public function error($header) {\n        $matches = [];\n        preg_match('/HTTP\\/1.1 (\\d+) (.*?)\\r\\n/', $header, $matches);\n        $status_code = $matches[1];\n        $status_message = $matches[2];\n        $this->error = \"{$status_code} {$status_message}\";\n\n        if (preg_match('/x-bs-error-message:\\s*(.*?)\\r\\n/i', $header, $matches)) {\n            $this->error .= \": \" . $matches[1];\n        }\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a PHP class that utilizes the Guzzle HTTP client to synchronize video processing tasks with a remote API endpoint, handling request signing and response parsing.\n\nClass Description: The SyncVideo class provides functionality to send video processing requests to a remote API endpoint using HTTP POST requests. It handles request signing, timeout configuration, and response parsing.\n\nAttributes:\n- config: [Upyun\\Config] - Configuration object containing service credentials, timeout settings, and endpoint information\n\nMethods:\n- __construct(Config $config) -> [void] - Initializes the class with the provided configuration object\n- process(array $params, string $path) -> [array] - Sends a synchronized video processing request to the specified path with the given parameters, returns the parsed JSON response",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse Upyun\\Config;\nuse Upyun\\Signature;\n\nclass SyncVideo {\n    protected $config;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n    }\n\n    public function process($params, $path) {\n        $client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n\n        $path = '/' . $this->config->serviceName . $path;\n        $method = 'POST';\n        $signedHeaders = Signature::getHeaderSign($this->config, $method, $path);\n\n        $url = $this->config->getSyncVideoEndPoint() . $path;\n        $response = $client->request($method, $url, [\n            'headers' => $signedHeaders,\n            'json' => $params\n        ]);\n\n        $body = $response->getBody()->getContents();\n        return json_decode($body, true);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [
      "<?php\n\nuse Upyun\\Config;\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass SyncVideo\n{\n    private Config $config;\n    private Client $client;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $url = $this->config->endpoint . $path;\n        $date = gmdate('D, d M Y H:i:s \\G\\M\\T');\n        $signature = md5('POST' . \"\\n\" . $date . \"\\n\" . $path . \"\\n\" . $this->config->password);\n        $headers = [\n            'Authorization' => 'UpYun ' . $this->config->operator . ':' . $signature,\n            'Date' => $date,\n        ];\n\n        try {\n            $response = $this->client->request('POST', $url, [\n                'headers' => $headers,\n                'form_params' => $params,\n            ]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\Exception('Request failed: ' . $e->getMessage());\n        }\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse Upyun\\Config;\n\nclass SyncVideo\n{\n    private Config $config;\n    private Client $client;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $url = $this->config->endpoint . $path;\n        $date = gmdate('D, d M Y H:i:s') . ' GMT';\n        $signature = md5('POST' . \"\\n\" . $date . \"\\n\" . $path . \"\\n\" . $this->config->password);\n        $headers = [\n            'Authorization' => 'UpYun ' . $this->config->username . ':' . $signature,\n            'Date' => $date,\n        ];\n\n        try {\n            $response = $this->client->post($url, [\n                'headers' => $headers,\n                'json' => $params,\n            ]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\Exception(\"Failed to process video: \" . $e->getMessage());\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse Upyun\\Config;\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass SyncVideo\n{\n    private Config $config;\n    private Client $client;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $url = $this->config->endpoint . $path;\n        $date = gmdate('D, d M Y H:i:s \\G\\M\\T');\n        $signature = md5('POST' . \"\\n\" . $date . \"\\n\" . $path . \"\\n\" . $this->config->password);\n        $headers = [\n            'Authorization' => 'UpYun ' . $this->config->username . ':' . $signature,\n            'Date' => $date,\n        ];\n\n        try {\n            $response = $this->client->post($url, [\n                'headers' => $headers,\n                'form_params' => $params,\n            ]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\Exception(\"Failed to process video: \" . $e->getMessage());\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse Upyun\\Config;\n\nclass SyncVideo\n{\n    private Config $config;\n    private Client $client;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $url = $this->config->endpoint . $path;\n        $date = gmdate('D, d M Y H:i:s \\G\\M\\T');\n        $signature = md5('POST' . \"\\n\" . $date . \"\\n\" . $path . \"\\n\" . $this->config->password);\n        $headers = [\n            'Authorization' => 'UpYun ' . $this->config->username . ':' . $signature,\n            'Date' => $date,\n        ];\n\n        try {\n            $response = $this->client->post($url, [\n                'headers' => $headers,\n                'json' => $params,\n            ]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\Exception(\"Failed to process video: \" . $e->getMessage());\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse Upyun\\Config;\n\nclass SyncVideo\n{\n    private Config $config;\n    private Client $client;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $url = $this->config->endpoint . $path;\n        $date = gmdate('D, d M Y H:i:s \\G\\M\\T');\n        $signature = md5('POST' . \"\\n\" . $date . \"\\n\" . $path . \"\\n\" . $this->config->password);\n        $headers = [\n            'Authorization' => 'UpYun ' . $this->config->username . ':' . $signature,\n            'Date' => $date,\n        ];\n\n        try {\n            $response = $this->client->post($url, [\n                'headers' => $headers,\n                'form_params' => $params,\n            ]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\Exception(\"Failed to process video: \" . $e->getMessage());\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse Upyun\\Config;\n\nclass SyncVideo\n{\n    private Config $config;\n    private Client $client;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $url = $this->config->endpoint . $path;\n        $date = gmdate('D, d M Y H:i:s \\G\\M\\T');\n        $signature = md5('POST' . \"\\n\" . $date . \"\\n\" . $path . \"\\n\" . $this->config->password);\n        $headers = [\n            'Authorization' => 'UpYun ' . $this->config->operator . ':' . $signature,\n            'Date' => $date,\n        ];\n\n        try {\n            $response = $this->client->post($url, [\n                'headers' => $headers,\n                'form_params' => $params,\n            ]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\Exception(\"Failed to process video: \" . $e->getMessage());\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse Upyun\\Config;\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass SyncVideo\n{\n    private Config $config;\n    private Client $client;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $url = $this->config->endpoint . $path;\n        $date = gmdate('D, d M Y H:i:s \\G\\M\\T');\n        $signature = md5('POST' . \"\\n\" . $date . \"\\n\" . $path . \"\\n\" . $this->config->password);\n        $headers = [\n            'Authorization' => 'UpYun ' . $this->config->operator . ':' . $signature,\n            'Date' => $date,\n        ];\n\n        try {\n            $response = $this->client->post($url, [\n                'headers' => $headers,\n                'form_params' => $params,\n            ]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\Exception('Failed to process video: ' . $e->getMessage());\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse Upyun\\Config;\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass SyncVideo\n{\n    private Config $config;\n    private Client $client;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $url = $this->config->endpoint . $path;\n        $date = gmdate('D, d M Y H:i:s \\G\\M\\T');\n        $signature = md5('POST' . \"\\n\" . $date . \"\\n\" . $path . \"\\n\" . $this->config->password);\n        $headers = [\n            'Authorization' => 'UpYun ' . $this->config->username . ':' . $signature,\n            'Date' => $date,\n        ];\n\n        try {\n            $response = $this->client->post($url, [\n                'headers' => $headers,\n                'form_params' => $params,\n            ]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\Exception(\"Failed to process video: \" . $e->getMessage());\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse Upyun\\Config;\n\nclass SyncVideo\n{\n    private Config $config;\n    private Client $client;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $url = $this->config->endpoint . $path;\n        $date = gmdate('D, d M Y H:i:s \\G\\M\\T');\n        $signature = md5('POST' . \"\\n\" . $date . \"\\n\" . $path . \"\\n\" . $this->config->password);\n        $headers = [\n            'Authorization' => 'UpYun ' . $this->config->username . ':' . $signature,\n            'Date' => $date,\n        ];\n\n        try {\n            $response = $this->client->post($url, [\n                'headers' => $headers,\n                'form_params' => $params,\n            ]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\Exception(\"Failed to process video: \" . $e->getMessage());\n        }\n    }\n}\n\n?>\n",
      "<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse Upyun\\Config;\n\nclass SyncVideo\n{\n    private Config $config;\n    private Client $client;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n        $this->client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $url = $this->config->endpoint . $path;\n        $date = gmdate('D, d M Y H:i:s \\G\\M\\T');\n        $signature = md5('POST' . \"\\n\" . $date . \"\\n\" . $path . \"\\n\" . $this->config->password);\n        $headers = [\n            'Authorization' => 'UpYun ' . $this->config->operator . ':' . $signature,\n            'Date' => $date,\n        ];\n\n        try {\n            $response = $this->client->post($url, [\n                'headers' => $headers,\n                'form_params' => $params,\n            ]);\n            return json_decode($response->getBody()->getContents(), true);\n        } catch (GuzzleException $e) {\n            throw new \\Exception(\"Failed to process video: \" . $e->getMessage());\n        }\n    }\n}\n\n?>\n"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a PHP class that handles interactions with the Alipay API, specifically for processing settlements and generating required signatures for secure communication.\n\nClass Description: The AlipayService class provides functionality to interact with Alipay's payment gateway, focusing on settlement operations. It handles request configuration, signature generation, and HTTP communication using cURL.\n\nAttributes:\n- appId: [string] - The application ID for Alipay API\n- charset: [string] - Character encoding (default: 'utf-8')\n- notifyUrl: [string] - Notification URL for callbacks\n- rsaPrivateKey: [string] - RSA private key for signing requests\n- totalFee: [float] - Total amount for the transaction\n- outTradeNo: [string] - Merchant's unique order number\n- orderName: [string] - Description of the order\n- tradeNo: [string] - Alipay's transaction number\n- tranOut: [string] - Account transferring funds\n- tranIn: [string] - Account receiving funds\n- amountPercentage: [float] - Percentage of amount to transfer\n\nMethods:\n- __construct() -> [void] - Initializes the class with default charset\n- setAppid($appid) -> [void] - Sets the Alipay application ID\n- setTradeNo($tradeNo) -> [void] - Sets the Alipay transaction number\n- setTranOut($tranOut) -> [void] - Sets the transferring account\n- setTranIn($tranIn) -> [void] - Sets the receiving account\n- setRsaPrivateKey($rsaPrivateKey) -> [void] - Sets the RSA private key\n- setTotalFee($payAmount) -> [void] - Sets the transaction amount\n- setOutTradeNo($outTradeNo) -> [void] - Sets the merchant order number\n- doSettle() -> [array] - Executes the settlement request to Alipay\n- generateSign($params, $signType = \"RSA\") -> [string] - Generates signature for request\n- sign($data, $signType = \"RSA\") -> [string] - Creates RSA signature\n- checkEmpty($value) -> [bool] - Checks if a value is empty\n- getSignContent($params) -> [string] - Prepares content for signing\n- characet($data, $targetCharset) -> [string] - Handles character encoding conversion\n- curlPost($url = '', $postData = '', $options = array()) -> [string] - Executes HTTP POST request using cURL",
    "Canonical_solution": "class AlipayService\n{\n    protected $appId;\n    protected $charset;\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $tradeNo;\n    protected $tranOut;\n    protected $tranIn;\n    protected $amountPercentage;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setTradeNo($tradeNo)\n    {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setTranOut($tranOut)\n    {\n        $this->tranOut = $tranOut;\n    }\n\n    public function setTranIn($tranIn)\n    {\n        $this->tranIn = $tranIn;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($payAmount)\n    {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function doSettle()\n    {\n        $requestConfigs = array(\n            'out_request_no'=>$this->outTradeNo,\n            'trade_no'=>$this->tradeNo,\n            'royalty_parameters'=>array(\n                array(\n                    'trans_out'=>$this->tranOut,\n                    'trans_in'=>$this->tranIn,\n                    'amount'=>$this->totalFee,\n                    'desc'=>'分账给'.$this->tranIn,\n                )\n            ),\n            'operator_id'=>'A001',\n        );\n        $commonConfigs = array(\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.order.settle',\n            'format' => 'JSON',\n            'charset'=>$this->charset,\n            'sign_type'=>'RSA2',\n            'timestamp'=>date('Y-m-d H:i:s'),\n            'version'=>'1.0',\n            'app_auth_token'=>'',\n            'biz_content'=>json_encode($requestConfigs),\n        );\n        $commonConfigs[\"sign\"] = $this->generateSign($commonConfigs, $commonConfigs['sign_type']);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do?charset='.$this->charset,$commonConfigs);\n        return json_decode($result,true);\n    }\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey=$this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, version_compare(PHP_VERSION,'5.4.0', '<') ? SHA256 : OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    protected function checkEmpty($value) {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n        return false;\n    }\n\n    public function getSignContent($params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                $v = $this->characet($v, $this->charset);\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array())\n    {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass AlipayService {\n\n    protected $appId;\n    protected $charset = 'utf-8';\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n\n    protected $tradeNo;\n    protected $tranOut;\n    protected $tranIn;\n    protected $amountPercentage;\n\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) { $this->appId = $appid; }\n    public function setTradeNo($tradeNo) { $this->tradeNo = $tradeNo; }\n    public function setTranOut($tranOut) { $this->tranOut = $tranOut; }\n    public function setTranIn($tranIn) { $this->tranIn = $tranIn; }\n    public function setRsaPrivateKey($rsaPrivateKey) { $this->rsaPrivateKey = $rsaPrivateKey; }\n    public function setTotalFee($payAmount) { $this->totalFee = $payAmount; }\n    public function setOutTradeNo($outTradeNo) { $this->outTradeNo = $outTradeNo; }\n\n\n    public function doSettle() {\n        $bizContent = json_encode([\n            \"out_request_no\" => $this->outTradeNo,\n            \"trade_no\" => $this->tradeNo,\n            \"royalty_parameters\" => [[\n                \"trans_out\" => $this->tranOut,\n                \"trans_in\" => $this->tranIn,\n                \"amount_percentage\" => $this->amountPercentage,\n                \"amount\" => $this->totalFee\n            ]]\n        ]);\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.order.settle',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => $bizContent,\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, http_build_query($params));\n        return json_decode($result, true);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey=$this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    protected function checkEmpty($value) {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent($params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array()) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https请求 不验证证书和host\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $charset = 'utf-8';\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $tradeNo;\n    protected $tranOut;\n    protected $tranIn;\n    protected $amountPercentage;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setTradeNo($tradeNo) {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setTranOut($tranOut) {\n        $this->tranOut = $tranOut;\n    }\n\n    public function setTranIn($tranIn) {\n        $this->tranIn = $tranIn;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($payAmount) {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n\n    public function doSettle() {\n        $bizContent = json_encode([\n            \"out_request_no\" => $this->outTradeNo,\n            \"trade_no\" => $this->tradeNo,\n            \"royalty_parameters\" => [[\n                \"trans_out\" => $this->tranOut,\n                \"trans_in\" => $this->tranIn,\n                \"amount_percentage\" => $this->amountPercentage,\n                \"amount\" => $this->totalFee\n            ]]\n        ]);\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.order.settle',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => $bizContent,\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n        return json_decode($result, true);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty($value) {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array()) {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https请求 不验证证书和host\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $charset = 'utf-8';\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $tradeNo;\n    protected $tranOut;\n    protected $tranIn;\n    protected $amountPercentage;\n\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setTradeNo($tradeNo) {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setTranOut($tranOut) {\n        $this->tranOut = $tranOut;\n    }\n\n    public function setTranIn($tranIn) {\n        $this->tranIn = $tranIn;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($payAmount) {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n\n    public function doSettle() {\n        $bizContent = json_encode([\n            \"out_request_no\" => $this->outTradeNo,\n            \"trade_no\" => $this->tradeNo,\n            \"royalty_parameters\" => [[\n                \"trans_out\" => $this->tranOut,\n                \"trans_in\" => $this->tranIn,\n                \"amount_percentage\" => $this->amountPercentage,\n                \"amount\" => $this->totalFee\n            ]]\n        ]);\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.order.settle',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => $bizContent,\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n        return json_decode($result, true);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty($value) {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent($params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array()) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $charset = 'utf-8';\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $tradeNo;\n    protected $tranOut;\n    protected $tranIn;\n    protected $amountPercentage;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setTradeNo($tradeNo) {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setTranOut($tranOut) {\n        $this->tranOut = $tranOut;\n    }\n\n    public function setTranIn($tranIn) {\n        $this->tranIn = $tranIn;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($payAmount) {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n\n    public function doSettle() {\n        $bizContent = json_encode([\n            \"out_request_no\" => $this->outTradeNo,\n            \"trade_no\" => $this->tradeNo,\n            \"royalty_parameters\" => [[\n                \"trans_out\" => $this->tranOut,\n                \"trans_in\" => $this->tranIn,\n                \"amount_percentage\" => $this->amountPercentage,\n                \"amount\" => $this->totalFee\n            ]]\n        ]);\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.order.settle',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => $bizContent,\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n        $url = 'https://openapi.alipay.com/gateway.do';\n        return $this->curlPost($url, $params);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty($value) {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset);\n                //\t\t\t\t$data = iconv($fileType, $targetCharset.'//IGNORE', $data);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array()) {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https请求 不验证证书和host\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $charset = 'utf-8';\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $tradeNo;\n    protected $tranOut;\n    protected $tranIn;\n    protected $amountPercentage;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setTradeNo($tradeNo) {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setTranOut($tranOut) {\n        $this->tranOut = $tranOut;\n    }\n\n    public function setTranIn($tranIn) {\n        $this->tranIn = $tranIn;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($payAmount) {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n\n    public function doSettle() {\n        $bizContent = json_encode([\n            \"out_request_no\" => $this->outTradeNo,\n            \"trade_no\" => $this->tradeNo,\n            \"royalty_parameters\" => [[\n                \"trans_out\" => $this->tranOut,\n                \"trans_in\" => $this->tranIn,\n                \"amount_percentage\" => $this->amountPercentage,\n                \"amount\" => $this->totalFee\n            ]]\n        ]);\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.order.settle',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => $bizContent,\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n        return json_decode($result, true);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty($value) {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array()) {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $charset = 'utf-8';\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $tradeNo;\n    protected $tranOut;\n    protected $tranIn;\n    protected $amountPercentage;\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setTradeNo($tradeNo) {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setTranOut($tranOut) {\n        $this->tranOut = $tranOut;\n    }\n\n    public function setTranIn($tranIn) {\n        $this->tranIn = $tranIn;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($payAmount) {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n\n    public function doSettle() {\n        $bizContent = json_encode([\n            \"out_request_no\" => $this->outTradeNo,\n            \"trade_no\" => $this->tradeNo,\n            \"royalty_parameters\" => [[\n                \"trans_out\" => $this->tranOut,\n                \"trans_in\" => $this->tranIn,\n                \"amount_percentage\" => $this->amountPercentage,\n                \"amount\" => $this->totalFee\n            ]]\n        ]);\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.order.settle',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => $bizContent,\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n        return json_decode($result, true);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty($value) {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent($params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array()) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $charset = 'utf-8';\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $tradeNo;\n    protected $tranOut;\n    protected $tranIn;\n    protected $amountPercentage;\n\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setTradeNo($tradeNo) {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setTranOut($tranOut) {\n        $this->tranOut = $tranOut;\n    }\n\n    public function setTranIn($tranIn) {\n        $this->tranIn = $tranIn;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($payAmount) {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n\n    public function doSettle() {\n        $bizContent = [\n            \"out_request_no\" => $this->outTradeNo,\n            \"trade_no\" => $this->tradeNo,\n            \"royalty_parameters\" => [\n                [\n                    \"trans_out\" => $this->tranOut,\n                    \"trans_in\" => $this->tranIn,\n                    \"amount_percentage\" => $this->amountPercentage,\n                    \"amount\" => $this->totalFee\n                ]\n            ]\n        ];\n        $data = [\n            \"app_id\" => $this->appId,\n            \"method\" => \"alipay.trade.order.settle\",\n            \"charset\" => $this->charset,\n            \"sign_type\" => \"RSA2\",\n            \"timestamp\" => date('Y-m-d H:i:s'),\n            \"version\" => \"1.0\",\n            \"biz_content\" => json_encode($bizContent, JSON_UNESCAPED_UNICODE)\n        ];\n        $data['sign'] = $this->generateSign($data);\n        return $this->curlPost('https://openapi.alipay.com/gateway.do', $data);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    public function checkEmpty($value) {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array()) {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https请求 不验证证书和host\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $charset = 'utf-8';\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $tradeNo;\n    protected $tranOut;\n    protected $tranIn;\n    protected $amountPercentage;\n\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setTradeNo($tradeNo) {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setTranOut($tranOut) {\n        $this->tranOut = $tranOut;\n    }\n\n    public function setTranIn($tranIn) {\n        $this->tranIn = $tranIn;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($payAmount) {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n\n    public function doSettle() {\n        $bizContent = json_encode([\n            \"out_request_no\" => $this->outTradeNo,\n            \"trade_no\" => $this->tradeNo,\n            \"royalty_parameters\" => [[\n                \"trans_out\" => $this->tranOut,\n                \"trans_in\" => $this->tranIn,\n                \"amount_percentage\" => $this->amountPercentage,\n                \"amount\" => $this->totalFee\n            ]]\n        ]);\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.order.settle',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => $bizContent,\n        ];\n        $params['sign'] = $this->generateSign($params);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n        return json_decode($result, true);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty($value) {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent($params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array()) {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $charset = 'utf-8';\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $tradeNo;\n    protected $tranOut;\n    protected $tranIn;\n    protected $amountPercentage;\n\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setTradeNo($tradeNo) {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setTranOut($tranOut) {\n        $this->tranOut = $tranOut;\n    }\n\n    public function setTranIn($tranIn) {\n        $this->tranIn = $tranIn;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($payAmount) {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n\n    public function doSettle() {\n        $bizContent = json_encode([\n            \"out_request_no\" => $this->outTradeNo,\n            \"trade_no\" => $this->tradeNo,\n            \"royalty_parameters\" => [[\n                \"trans_out\" => $this->tranOut,\n                \"trans_in\" => $this->tranIn,\n                \"amount_percentage\" => $this->amountPercentage,\n                \"amount\" => $this->totalFee\n            ]]\n        ]);\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.order.settle',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => $bizContent,\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, $params);\n        return json_decode($result, true);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty($value) {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent($params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array()) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\nclass AlipayService {\n    protected $appId;\n    protected $charset = 'utf-8';\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $tradeNo;\n    protected $tranOut;\n    protected $tranIn;\n    protected $amountPercentage;\n\n\n    public function __construct() {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setTradeNo($tradeNo) {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setTranOut($tranOut) {\n        $this->tranOut = $tranOut;\n    }\n\n    public function setTranIn($tranIn) {\n        $this->tranIn = $tranIn;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($payAmount) {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n\n    public function doSettle() {\n        $bizContent = json_encode([\n            \"out_request_no\" => $this->outTradeNo,\n            \"trade_no\" => $this->tradeNo,\n            \"royalty_parameters\" => [[\n                \"trans_out\" => $this->tranOut,\n                \"trans_in\" => $this->tranIn,\n                \"amount_percentage\" => $this->amountPercentage,\n                \"amount\" => $this->totalFee\n            ]]\n        ]);\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.order.settle',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => $bizContent,\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n        return json_decode($result, true);\n    }\n\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n\n    protected function checkEmpty($value) {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent($params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array()) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); \n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}\n\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client using cURL for making HTTP requests, handling cookies, headers, and connection management.\n\nClass Description: HproseHttpClient is a PHP class that extends HproseBaseHttpClient to provide HTTP client functionality using cURL. It handles request sending, response processing, cookie management, and connection settings.\n\nAttributes:\n- curl: resource - The cURL session handle\n- url: string - The target URL for HTTP requests\n- header: array - Additional HTTP headers to be sent with requests\n- keepAlive: bool - Whether to use keep-alive connection\n- keepAliveTimeout: int - Timeout for keep-alive connection in seconds\n- proxy: string - Proxy server address if configured\n- timeout: int - Request timeout in milliseconds\n\nMethods:\n- __construct(string $url = '') -> void - Initializes the client with optional target URL and creates a cURL session\n- formatCookie(array $cookies) -> string - Formats cookies into a header string\n- send(string $request) -> string - Sends an HTTP request and returns the response body\n  - Input: $request - The request payload to send\n  - Output: The response body from the server\n- __destruct() -> void - Cleans up by closing the cURL session\n\nThe class handles:\n1. cURL session initialization and configuration\n2. Request header construction (including cookies)\n3. SSL verification settings\n4. Connection management (keep-alive or close)\n5. Proxy configuration\n6. Timeout handling\n7. Response processing and error checking\n8. Resource cleanup",
    "Canonical_solution": "require_once('HproseCommon.php');\nrequire_once('HproseIO.php');\nrequire_once('HproseClient.php');\n\nclass HproseHttpClient extends HproseBaseHttpClient {\n    private $curl;\n    protected function formatCookie($cookies) {\n        if (count($cookies) > 0) {\n            return \"Cookie: \" . implode('; ', $cookies);\n        }\n        return '';\n    }\n    public function __construct($url = '') {\n        parent::__construct($url);\n        $this->curl = curl_init();\n    }\n    protected function send($request) {\n        curl_setopt($this->curl, CURLOPT_URL, $this->url);\n        curl_setopt($this->curl, CURLOPT_HEADER, TRUE);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n        curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, TRUE);\n        curl_setopt($this->curl, CURLOPT_POST, TRUE);\n        curl_setopt($this->curl, CURLOPT_POSTFIELDS, $request);\n        $headers_array = array($this->getCookie(),\n                                \"Content-Length: \" . strlen($request));\n        if ($this->keepAlive) {\n            $headers_array[] = \"Connection: keep-alive\";\n            $headers_array[] = \"Keep-Alive: \" . $this->keepAliveTimeout;\n        }\n        else {\n            $headers_array[] = \"Connection: close\";\n        }\n        foreach ($this->header as $name => $value) {\n            $headers_array[] = $name . \": \" . $value;\n        }\n        curl_setopt($this->curl, CURLOPT_HTTPHEADER, $headers_array);\n        if ($this->proxy) {\n            curl_setopt($this->curl, CURLOPT_PROXY, $this->proxy);\n        }\n        if (defined(CURLOPT_TIMEOUT_MS)) {\n            curl_setopt($this->curl, CURLOPT_TIMEOUT_MS, $this->timeout);\n        }\n        else {\n            curl_setopt($this->curl, CURLOPT_TIMEOUT, $this->timeout / 1000);\n        }\n        $response = curl_exec($this->curl);\n        $errno = curl_errno($this->curl);\n        if ($errno) {\n            throw new HproseException($errno . \": \" . curl_error($this->curl));\n        }\n        do {\n            list($response_headers, $response) = explode(\"\\r\\n\\r\\n\", $response, 2); \n            $http_response_header = explode(\"\\r\\n\", $response_headers);\n            $http_response_firstline = array_shift($http_response_header); \n            if (preg_match('@^HTTP/[0-9]\\.[0-9]\\s([0-9]{3})\\s(.*)@',\n                           $http_response_firstline, $matches)) { \n                $response_code = $matches[1];\n                $response_status = trim($matches[2]);\n            }\n            else {\n                $response_code = \"500\";\n                $response_status = \"Unknown Error.\";                \n            }\n        } while (substr($response_code, 0, 1) == \"1\");\n        if ($response_code != '200') {\n            throw new HproseException($response_code . \": \" . $response_status);\n        }\n        $this->setCookie($http_response_header);\n        return $response;\n    }\n    public function __destruct() {\n        curl_close($this->curl);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass HproseBaseHttpClient {\n    public function setHeader($name, $value) {}\n    public function setHeaders($headers) {}\n    public function addHeader($name, $value) {}\n    public function addHeaders($headers) {}\n    public function removeHeader($name) {}\n    public function useHarmonyHeaders($enable = true) {}\n    public function setProxy($proxy) {}\n    public function setTimeout($timeout) {}\n    public function setKeepAlive($keepAlive = true) {}\n    public function setKeepAliveTimeout($timeout) {}\n}\n\nclass HproseHttpClient extends HproseBaseHttpClient {\n    public $curl;\n    public $url;\n    public $header = array();\n    public $keepAlive = true;\n    public $keepAliveTimeout = 300;\n    public $proxy;\n    public $timeout;\n\n    public function __construct($url = '') {\n        $this->url = $url;\n        $this->curl = curl_init();\n        curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl, CURLOPT_HEADER, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);\n    }\n\n    public function formatCookie(array $cookies) {\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . $value . '; ';\n        }\n        return trim($cookie_string, '; ');\n    }\n\n    public function send($request) {\n        $header = $this->header;\n        if ($this->keepAlive) {\n            $header[] = 'Connection: Keep-Alive';\n            $header[] = 'Keep-Alive: timeout=' . $this->keepAliveTimeout . ', max=1000';\n        }\n        else {\n            $header[] = 'Connection: close';\n        }\n        if ($this->proxy) {\n            curl_setopt($this->curl, CURLOPT_PROXY, $this->proxy);\n        }\n        if ($this->timeout > 0) {\n            curl_setopt($this->curl, CURLOPT_TIMEOUT_MS, $this->timeout);\n        }\n        curl_setopt($this->curl, CURLOPT_URL, $this->url);\n        curl_setopt($this->curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($this->curl, CURLOPT_POSTFIELDS, $request);\n        $response = curl_exec($this->curl);\n        if (curl_errno($this->curl)) {\n            throw new Exception(curl_error($this->curl));\n        }\n        return $response;\n    }\n\n    public function __destruct() {\n        curl_close($this->curl);\n    }\n}\n?>\n",
      "<?php\nclass HproseBaseHttpClient {\n    public function setHeader($name, $value) {}\n    public function setHeaders($headers) {}\n    public function isKeepAlive() {}\n    public function setKeepAlive($keepAlive = true) {}\n    public function getKeepAliveTimeout() {}\n    public function setKeepAliveTimeout($timeout) {}\n    public function getTimeout() {}\n    public function setTimeout($timeout) {}\n    public function getProxy() {}\n    public function setProxy($proxy) {}\n}\nclass HproseHttpClient extends HproseBaseHttpClient {\n    public $curl;\n    public $url;\n    protected $header = array();\n    protected $keepAlive = true;\n    protected $keepAliveTimeout = 300;\n    protected $proxy = '';\n    protected $timeout = 30000;\n\n    public function __construct($url = '') {\n        $this->url = $url;\n        $this->curl = curl_init();\n        curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl, CURLOPT_HEADER, true);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);\n    }\n\n    public function formatCookie(array $cookies) {\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . $value . '; ';\n        }\n        return trim($cookie_string, '; ');\n    }\n\n    public function send($request) {\n        $header = $this->header;\n        if ($this->keepAlive) {\n            $header[] = 'Connection: Keep-Alive';\n            $header[] = 'Keep-Alive: timeout=' . $this->keepAliveTimeout . ', max=1000';\n        }\n        else {\n            $header[] = 'Connection: close';\n        }\n        if ($this->proxy) {\n            curl_setopt($this->curl, CURLOPT_PROXY, $this->proxy);\n        }\n        curl_setopt($this->curl, CURLOPT_URL, $this->url);\n        curl_setopt($this->curl, CURLOPT_TIMEOUT_MS, $this->timeout);\n        curl_setopt($this->curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($this->curl, CURLOPT_POSTFIELDS, $request);\n        $response = curl_exec($this->curl);\n        $header_size = curl_getinfo($this->curl, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $httpCode = curl_getinfo($this->curl, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            throw new Exception($body, $httpCode);\n        }\n        return $body;\n    }\n\n    public function __destruct() {\n        curl_close($this->curl);\n    }\n\n    public function setHeader($name, $value) {\n        $this->header[] = $name . ': ' . $value;\n    }\n\n    public function setHeaders($headers) {\n        foreach ($headers as $name => $value) {\n            $this->header[] = $name . ': ' . $value;\n        }\n    }\n\n    public function isKeepAlive() {\n        return $this->keepAlive;\n    }\n\n    public function setKeepAlive($keepAlive = true) {\n        $this->keepAlive = $keepAlive;\n    }\n\n    public function getKeepAliveTimeout() {\n        return $this->keepAliveTimeout;\n    }\n\n    public function setKeepAliveTimeout($timeout) {\n        $this->keepAliveTimeout = $timeout;\n    }\n\n    public function getTimeout() {\n        return $this->timeout;\n    }\n\n    public function setTimeout($timeout) {\n        $this->timeout = $timeout;\n    }\n\n    public function getProxy() {\n        return $this->proxy;\n    }\n\n    public function setProxy($proxy) {\n        $this->proxy = $proxy;\n    }\n}\n?>\n",
      "<?php\nclass HproseBaseHttpClient {\n    public function setHeader($name, $value) {}\n    public function setHeaders($headers) {}\n    public function isKeepAlive() {}\n    public function setKeepAlive($keepAlive = true) {}\n    public function getKeepAliveTimeout() {}\n    public function setKeepAliveTimeout($timeout) {}\n    public function getTimeout() {}\n    public function setTimeout($timeout) {}\n    public function getProxy() {}\n    public function setProxy($proxy) {}\n}\nclass HproseHttpClient extends HproseBaseHttpClient {\n    public $curl;\n    public $url;\n    protected $header = array();\n    protected $keepAlive = true;\n    protected $keepAliveTimeout = 300;\n    protected $proxy = '';\n    protected $timeout = 30000;\n\n    public function __construct($url = '') {\n        $this->url = $url;\n        $this->curl = curl_init();\n        curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl, CURLOPT_HEADER, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);\n    }\n\n    public function formatCookie($cookies) {\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . urlencode($value) . '; ';\n        }\n        return trim($cookie_string, '; ');\n    }\n\n    public function send($request) {\n        $header = $this->header;\n        if ($this->keepAlive) {\n            $header[] = 'Connection: Keep-Alive';\n            $header[] = 'Keep-Alive: timeout=' . $this->keepAliveTimeout . ', max=1000';\n        }\n        else {\n            $header[] = 'Connection: close';\n        }\n        if ($this->proxy) {\n            curl_setopt($this->curl, CURLOPT_PROXY, $this->proxy);\n        }\n        curl_setopt($this->curl, CURLOPT_URL, $this->url);\n        curl_setopt($this->curl, CURLOPT_TIMEOUT_MS, $this->timeout);\n        curl_setopt($this->curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($this->curl, CURLOPT_POSTFIELDS, $request);\n        $response = curl_exec($this->curl);\n        if (curl_errno($this->curl)) {\n            throw new Exception(curl_error($this->curl));\n        }\n        return $response;\n    }\n\n    public function __destruct() {\n        curl_close($this->curl);\n    }\n\n    public function setHeader($name, $value) {\n        $this->header[] = $name . ': ' . $value;\n    }\n\n    public function setHeaders($headers) {\n        foreach ($headers as $name => $value) {\n            $this->header[] = $name . ': ' . $value;\n        }\n    }\n\n    public function isKeepAlive() {\n        return $this->keepAlive;\n    }\n\n    public function setKeepAlive($keepAlive = true) {\n        $this->keepAlive = $keepAlive;\n    }\n\n    public function getKeepAliveTimeout() {\n        return $this->keepAliveTimeout;\n    }\n\n    public function setKeepAliveTimeout($timeout) {\n        $this->keepAliveTimeout = $timeout;\n    }\n\n    public function getTimeout() {\n        return $this->timeout;\n    }\n\n    public function setTimeout($timeout) {\n        $this->timeout = $timeout;\n    }\n\n    public function getProxy() {\n        return $this->proxy;\n    }\n\n    public function setProxy($proxy) {\n        $this->proxy = $proxy;\n    }\n}\n?>\n",
      "<?php\nclass HproseHttpClient extends HproseBaseHttpClient\n{\n    public $curl;\n    public function __construct($url = '') {\n        parent::__construct($url);\n        $this->curl = curl_init();\n        $this->timeout = 30000;\n        $this->keepAlive = true;\n        $this->keepAliveTimeout = 300;\n    }\n    public function formatCookie(array $cookies) {\n        $cookie = '';\n        foreach ($cookies as $name => $value) {\n            if ($cookie != '') {\n                $cookie .= '; ';\n            }\n            $cookie .= $name . '=' . $value;\n        }\n        return $cookie;\n    }\n    public function send($request) {\n        $url = $this->url;\n        $header = $this->header;\n        $cookies = $this->cookies;\n        $options = array();\n        if (!empty($cookies)) {\n            $header['Cookie'] = $this->formatCookie($cookies);\n        }\n        $options[CURLOPT_URL] = $url;\n        $options[CURLOPT_RETURNTRANSFER] = true;\n        $options[CURLOPT_HEADER] = true;\n        $options[CURLOPT_HTTPHEADER] = $this->httpHeaders($header);\n        $options[CURLOPT_POSTFIELDS] = $request;\n        $options[CURLOPT_USERAGENT] = $this->userAgent;\n        $options[CURLOPT_CONNECTTIMEOUT_MS] = $this->connectTimeout;\n        $options[CURLOPT_TIMEOUT_MS] = $this->timeout;\n        if ($this->proxy) {\n            $options[CURLOPT_PROXY] = $this->proxy;\n        }\n        if ($this->sslVerifyPeer) {\n            $options[CURLOPT_SSL_VERIFYPEER] = true;\n            if ($this->caCert) {\n                $options[CURLOPT_CAINFO] = $this->caCert;\n            }\n        }\n        else {\n            $options[CURLOPT_SSL_VERIFYPEER] = false;\n        }\n        if ($this->keepAlive) {\n            $options[CURLOPT_FRESH_CONNECT] = false;\n            $options[CURLOPT_FORBID_REUSE] = false;\n        }\n        else {\n            $options[CURLOPT_FRESH_CONNECT] = true;\n            $options[CURLOPT_FORBID_REUSE] = true;\n        }\n        curl_setopt_array($this->curl, $options);\n        $response = curl_exec($this->curl);\n        $info = curl_getinfo($this->curl);\n        $error = curl_error($this->curl);\n        if ($error != '') {\n            throw new HproseException($error);\n        }\n        $this->header = $this->parseHeader(substr($response, 0, $info['header_size']));\n        $responseBody = substr($response, $info['header_size']);\n        $this->setCookies($this->header['set-cookie']);\n        return $responseBody;\n    }\n    public function __destruct() {\n        curl_close($this->curl);\n    }\n}\n?>\n",
      "<?php\nclass HproseBaseHttpClient {\n    public function setHeader($name, $value) {}\n    public function setHeaders($headers) {}\n    public function isKeepAlive() {}\n    public function setKeepAlive($keepAlive = true) {}\n    public function getKeepAliveTimeout() {}\n    public function setKeepAliveTimeout($timeout) {}\n    public function getProxy() {}\n    public function setProxy($proxy) {}\n    public function getTimeout() {}\n    public function setTimeout($timeout) {}\n}\n\nclass HproseHttpClient extends HproseBaseHttpClient {\n    public $curl;\n    private $url;\n    private $header = array();\n    private $keepAlive = true;\n    private $keepAliveTimeout = 300;\n    private $proxy;\n    private $timeout;\n\n    public function __construct($url = '') {\n        $this->url = $url;\n        $this->curl = curl_init();\n        curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl, CURLOPT_HEADER, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);\n    }\n\n    public function formatCookie(array $cookies) {\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . $value . '; ';\n        }\n        return trim($cookie_string, '; ');\n    }\n\n    public function send($request) {\n        curl_setopt($this->curl, CURLOPT_URL, $this->url);\n        $header = $this->header;\n        if ($this->keepAlive) {\n            $header[] = 'Connection: Keep-Alive';\n            $header[] = 'Keep-Alive: timeout=' . $this->keepAliveTimeout;\n        } else {\n            $header[] = 'Connection: close';\n        }\n        if ($this->proxy) {\n            curl_setopt($this->curl, CURLOPT_PROXY, $this->proxy);\n        }\n        if ($this->timeout > 0) {\n            curl_setopt($this->curl, CURLOPT_TIMEOUT_MS, $this->timeout);\n        }\n        curl_setopt($this->curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($this->curl, CURLOPT_POSTFIELDS, $request);\n        $response = curl_exec($this->curl);\n        if (curl_errno($this->curl)) {\n            throw new Exception(curl_error($this->curl));\n        }\n        return $response;\n    }\n\n    public function setHeader($name, $value) {\n        $this->header[] = $name . ': ' . $value;\n    }\n\n    public function setHeaders($headers) {\n        foreach ($headers as $name => $value) {\n            $this->header[] = $name . ': ' . $value;\n        }\n    }\n\n    public function isKeepAlive() {\n        return $this->keepAlive;\n    }\n\n    public function setKeepAlive($keepAlive = true) {\n        $this->keepAlive = $keepAlive;\n    }\n\n    public function getKeepAliveTimeout() {\n        return $this->keepAliveTimeout;\n    }\n\n    public function setKeepAliveTimeout($timeout) {\n        $this->keepAliveTimeout = $timeout;\n    }\n\n    public function getProxy() {\n        return $this->proxy;\n    }\n\n    public function setProxy($proxy) {\n        $this->proxy = $proxy;\n    }\n\n    public function getTimeout() {\n        return $this->timeout;\n    }\n\n    public function setTimeout($timeout) {\n        $this->timeout = $timeout;\n    }\n\n    public function __destruct() {\n        curl_close($this->curl);\n    }\n}\n?>\n",
      "<?php\nclass HproseBaseHttpClient {\n    public function setHeader($name, $value) {}\n    public function setHeaders($headers) {}\n    public function isKeepAlive() {}\n    public function setKeepAlive($keepAlive = true) {}\n    public function getKeepAliveTimeout() {}\n    public function setKeepAliveTimeout($timeout) {}\n    public function getProxy() {}\n    public function setProxy($proxy) {}\n    public function getTimeout() {}\n    public function setTimeout($timeout) {}\n}\nclass HproseHttpClient extends HproseBaseHttpClient {\n    public $curl;\n    public $url;\n    protected $header = array();\n    protected $keepAlive = true;\n    protected $keepAliveTimeout = 300;\n    protected $proxy;\n    protected $timeout = 30000;\n\n    public function __construct($url = '') {\n        $this->url = $url;\n        $this->curl = curl_init();\n        curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl, CURLOPT_HEADER, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);\n    }\n\n    public function formatCookie(array $cookies) {\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . $value . '; ';\n        }\n        return trim($cookie_string, '; ');\n    }\n\n    public function send($request) {\n        $header = $this->header;\n        if ($this->keepAlive) {\n            $header[] = 'Connection: Keep-Alive';\n            $header[] = 'Keep-Alive: timeout=' . $this->keepAliveTimeout . ', max=1000';\n        }\n        else {\n            $header[] = 'Connection: close';\n        }\n        if ($this->proxy) {\n            curl_setopt($this->curl, CURLOPT_PROXY, $this->proxy);\n        }\n        curl_setopt($this->curl, CURLOPT_URL, $this->url);\n        curl_setopt($this->curl, CURLOPT_TIMEOUT_MS, $this->timeout);\n        curl_setopt($this->curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($this->curl, CURLOPT_POSTFIELDS, $request);\n        $response = curl_exec($this->curl);\n        if (curl_errno($this->curl)) {\n            throw new Exception(curl_error($this->curl));\n        }\n        return $response;\n    }\n\n    public function __destruct() {\n        curl_close($this->curl);\n    }\n\n    public function setHeader($name, $value) {\n        $this->header[] = $name . ': ' . $value;\n    }\n\n    public function setHeaders($headers) {\n        foreach ($headers as $name => $value) {\n            $this->header[] = $name . ': ' . $value;\n        }\n    }\n\n    public function isKeepAlive() {\n        return $this->keepAlive;\n    }\n\n    public function setKeepAlive($keepAlive = true) {\n        $this->keepAlive = $keepAlive;\n    }\n\n    public function getKeepAliveTimeout() {\n        return $this->keepAliveTimeout;\n    }\n\n    public function setKeepAliveTimeout($timeout) {\n        $this->keepAliveTimeout = $timeout;\n    }\n\n    public function getProxy() {\n        return $this->proxy;\n    }\n\n    public function setProxy($proxy) {\n        $this->proxy = $proxy;\n    }\n\n    public function getTimeout() {\n        return $this->timeout;\n    }\n\n    public function setTimeout($timeout) {\n        $this->timeout = $timeout;\n    }\n}\n?>\n",
      "<?php\nclass HproseBaseHttpClient {\n    public function setHeader($name, $value) {}\n    public function setHeaders($headers) {}\n    public function isKeepAlive() {}\n    public function setKeepAlive($keepAlive = true) {}\n    public function getKeepAliveTimeout() {}\n    public function setKeepAliveTimeout($timeout) {}\n    public function getProxy() {}\n    public function setProxy($proxy) {}\n    public function getTimeout() {}\n    public function setTimeout($timeout) {}\n}\nclass HproseHttpClient extends HproseBaseHttpClient {\n    public $curl;\n    private $url;\n    private $header = array();\n    private $keepAlive = true;\n    private $keepAliveTimeout = 300;\n    private $proxy;\n    private $timeout;\n\n    public function __construct($url = '') {\n        $this->url = $url;\n        $this->curl = curl_init();\n        curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl, CURLOPT_HEADER, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);\n    }\n\n    public function formatCookie(array $cookies) {\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . $value . '; ';\n        }\n        return trim($cookie_string, '; ');\n    }\n\n    public function send($request) {\n        $header = $this->header;\n        if ($this->keepAlive) {\n            $header[] = 'Connection: Keep-Alive';\n            $header[] = 'Keep-Alive: timeout=' . $this->keepAliveTimeout;\n        } else {\n            $header[] = 'Connection: close';\n        }\n        if ($this->proxy) {\n            curl_setopt($this->curl, CURLOPT_PROXY, $this->proxy);\n        }\n        curl_setopt($this->curl, CURLOPT_URL, $this->url);\n        curl_setopt($this->curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($this->curl, CURLOPT_POSTFIELDS, $request);\n        if ($this->timeout > 0) {\n            curl_setopt($this->curl, CURLOPT_TIMEOUT_MS, $this->timeout);\n        }\n        $response = curl_exec($this->curl);\n        if (curl_errno($this->curl)) {\n            throw new Exception(curl_error($this->curl));\n        }\n        return $response;\n    }\n\n    public function __destruct() {\n        curl_close($this->curl);\n    }\n\n    public function setHeader($name, $value) {\n        $this->header[] = $name . ': ' . $value;\n    }\n\n    public function setHeaders($headers) {\n        foreach ($headers as $name => $value) {\n            $this->header[] = $name . ': ' . $value;\n        }\n    }\n\n    public function isKeepAlive() {\n        return $this->keepAlive;\n    }\n\n    public function setKeepAlive($keepAlive = true) {\n        $this->keepAlive = $keepAlive;\n    }\n\n    public function getKeepAliveTimeout() {\n        return $this->keepAliveTimeout;\n    }\n\n    public function setKeepAliveTimeout($timeout) {\n        $this->keepAliveTimeout = $timeout;\n    }\n\n    public function getProxy() {\n        return $this->proxy;\n    }\n\n    public function setProxy($proxy) {\n        $this->proxy = $proxy;\n    }\n\n    public function getTimeout() {\n        return $this->timeout;\n    }\n\n    public function setTimeout($timeout) {\n        $this->timeout = $timeout;\n    }\n}\n?>\n",
      "<?php\nclass HproseBaseHttpClient {\n    public function setHeader($name, $value) {}\n    public function setHeaders($headers) {}\n    public function addHeader($name, $value) {}\n    public function addHeaders($headers) {}\n    public function removeHeader($name) {}\n    public function useHarmonyHeaders($enable = true) {}\n}\nclass HproseHttpClient extends HproseBaseHttpClient {\n    public $curl;\n    public $url;\n    public $header = array();\n    public $keepAlive = true;\n    public $keepAliveTimeout = 300;\n    public $proxy;\n    public $timeout;\n\n    public function __construct($url = '') {\n        $this->url = $url;\n        $this->curl = curl_init();\n        curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl, CURLOPT_HEADER, true);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);\n    }\n\n    public function formatCookie(array $cookies) {\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . $value . '; ';\n        }\n        return trim($cookie_string, '; ');\n    }\n\n    public function send($request) {\n        $header = $this->header;\n        if ($this->keepAlive) {\n            $header[] = 'Connection: keep-alive';\n            $header[] = 'Keep-Alive: timeout=' . $this->keepAliveTimeout;\n        } else {\n            $header[] = 'Connection: close';\n        }\n        curl_setopt($this->curl, CURLOPT_URL, $this->url);\n        curl_setopt($this->curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($this->curl, CURLOPT_POSTFIELDS, $request);\n        if ($this->proxy) {\n            curl_setopt($this->curl, CURLOPT_PROXY, $this->proxy);\n        }\n        if ($this->timeout > 0) {\n            curl_setopt($this->curl, CURLOPT_TIMEOUT_MS, $this->timeout);\n        }\n        $response = curl_exec($this->curl);\n        $info = curl_getinfo($this->curl);\n        if ($response === false) {\n            throw new Exception(curl_error($this->curl));\n        }\n        $header_size = $info['header_size'];\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        if ($info['http_code'] >= 400) {\n            throw new Exception($body, $info['http_code']);\n        }\n        return $body;\n    }\n\n    public function __destruct() {\n        curl_close($this->curl);\n    }\n}\n?>\n",
      "<?php\nclass HproseBaseHttpClient {\n    public function setHeader($name, $value) {}\n    public function setHeaders($headers) {}\n    public function isKeepAlive() {}\n    public function setKeepAlive($keepAlive = true) {}\n    public function getKeepAliveTimeout() {}\n    public function setKeepAliveTimeout($timeout) {}\n    public function getProxy() {}\n    public function setProxy($proxy) {}\n    public function getTimeout() {}\n    public function setTimeout($timeout) {}\n}\n\nclass HproseHttpClient extends HproseBaseHttpClient {\n    public $curl;\n    private $url;\n    private $header = array();\n    private $keepAlive = true;\n    private $keepAliveTimeout = 300;\n    private $proxy;\n    private $timeout;\n\n    public function __construct($url = '') {\n        $this->url = $url;\n        $this->curl = curl_init();\n        curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl, CURLOPT_HEADER, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);\n    }\n\n    public function formatCookie(array $cookies) {\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . $value . '; ';\n        }\n        return trim($cookie_string, '; ');\n    }\n\n    public function send($request) {\n        curl_setopt($this->curl, CURLOPT_URL, $this->url);\n        $header = $this->header;\n        if ($this->keepAlive) {\n            $header[] = 'Connection: keep-alive';\n            $header[] = 'Keep-Alive: timeout=' . $this->keepAliveTimeout;\n        } else {\n            $header[] = 'Connection: close';\n        }\n        if ($this->proxy) {\n            curl_setopt($this->curl, CURLOPT_PROXY, $this->proxy);\n        }\n        if ($this->timeout > 0) {\n            curl_setopt($this->curl, CURLOPT_TIMEOUT_MS, $this->timeout);\n        }\n        curl_setopt($this->curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($this->curl, CURLOPT_POSTFIELDS, $request);\n        $response = curl_exec($this->curl);\n        if (curl_errno($this->curl)) {\n            throw new Exception(curl_error($this->curl));\n        }\n        return $response;\n    }\n\n    public function __destruct() {\n        curl_close($this->curl);\n    }\n\n    public function setHeader($name, $value) {\n        $this->header[] = $name . ': ' . $value;\n    }\n\n    public function setHeaders($headers) {\n        foreach ($headers as $name => $value) {\n            $this->setHeader($name, $value);\n        }\n    }\n\n    public function isKeepAlive() {\n        return $this->keepAlive;\n    }\n\n    public function setKeepAlive($keepAlive = true) {\n        $this->keepAlive = $keepAlive;\n    }\n\n    public function getKeepAliveTimeout() {\n        return $this->keepAliveTimeout;\n    }\n\n    public function setKeepAliveTimeout($timeout) {\n        $this->keepAliveTimeout = $timeout;\n    }\n\n    public function getProxy() {\n        return $this->proxy;\n    }\n\n    public function setProxy($proxy) {\n        $this->proxy = $proxy;\n    }\n\n    public function getTimeout() {\n        return $this->timeout;\n    }\n\n    public function setTimeout($timeout) {\n        $this->timeout = $timeout;\n    }\n}\n?>\n",
      "<?php\nclass HproseBaseHttpClient {\n    public function setHeader($name, $value) {}\n    public function setHeaders($headers) {}\n    public function addHeader($name, $value) {}\n    public function addHeaders($headers) {}\n    public function removeHeader($name) {}\n}\nclass HproseHttpClient extends HproseBaseHttpClient {\n    public $curl;\n    public $url;\n    public $header = array();\n    public $keepAlive = true;\n    public $keepAliveTimeout = 300;\n    public $proxy;\n    public $timeout;\n\n    public function __construct($url = '') {\n        $this->url = $url;\n        $this->curl = curl_init();\n        curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl, CURLOPT_HEADER, true);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);\n    }\n\n    public function formatCookie(array $cookies) {\n        $cookie_string = '';\n        foreach ($cookies as $key => $value) {\n            $cookie_string .= $key . '=' . $value . '; ';\n        }\n        return trim($cookie_string, '; ');\n    }\n\n    public function send($request) {\n        $header = $this->header;\n        if ($this->keepAlive) {\n            $header[] = 'Connection: keep-alive';\n            $header[] = 'Keep-Alive: timeout=' . $this->keepAliveTimeout;\n        } else {\n            $header[] = 'Connection: close';\n        }\n        if ($this->proxy) {\n            curl_setopt($this->curl, CURLOPT_PROXY, $this->proxy);\n        }\n        curl_setopt($this->curl, CURLOPT_URL, $this->url);\n        curl_setopt($this->curl, CURLOPT_HTTPHEADER, $header);\n        curl_setopt($this->curl, CURLOPT_POSTFIELDS, $request);\n        if ($this->timeout > 0) {\n            curl_setopt($this->curl, CURLOPT_TIMEOUT_MS, $this->timeout);\n        }\n        $response = curl_exec($this->curl);\n        $header_size = curl_getinfo($this->curl, CURLINFO_HEADER_SIZE);\n        $header = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $httpCode = curl_getinfo($this->curl, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            throw new Exception(\"HTTP request failed with code: \" . $httpCode . \"\\n\" . $body);\n        }\n        return $body;\n    }\n\n    public function __destruct() {\n        curl_close($this->curl);\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Create a function to download an image from a given URL and save it to a specified file path using PHP's cURL library.\n\nFunction Description: The function uses cURL to make an HTTP request to download an image from the provided URL. It saves the downloaded image to the specified file path. The function includes error handling for the cURL session and file operations.\n\nInput:\n- $url (string): The URL of the image to download\n- $filepath (string): The local file path where the image should be saved\n\nOutput:\n- void: The function does not return a value but outputs a success message when the download is complete\n- The downloaded image is saved to the specified file path\n- Errors during the download process are handled by cURL's error reporting",
    "Canonical_solution": "function downloadImage($url, $filepath)\n{\n    $ch = curl_init($url);\n    $fp = fopen($filepath, 'wb');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_REFERER, 'https://ft07.com');\n    curl_exec($ch);\n    curl_close($ch);\n    fclose($fp);\n    echo \"Downloaded: $filepath\\n\";\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction downloadImage($url, $filepath) {\n    $ch = curl_init($url);\n    $fp = fopen($filepath, 'wb');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_exec($ch);\n    if(curl_errno($ch)) {\n        echo 'Error:' . curl_error($ch);\n    } else {\n        echo \"Image downloaded successfully to $filepath\";\n    }\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction downloadImage($url, $filepath) {\n    $ch = curl_init($url);\n    $fp = fopen($filepath, 'wb');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_exec($ch);\n    if(curl_errno($ch)) {\n        echo 'Error:' . curl_error($ch);\n    } else {\n        echo \"Image downloaded successfully to $filepath\";\n    }\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction downloadImage($url, $filepath) {\n    $ch = curl_init($url);\n    $fp = fopen($filepath, 'wb');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_exec($ch);\n    if(curl_errno($ch)) {\n        echo 'Error:' . curl_error($ch);\n    } else {\n        echo 'Image downloaded successfully to ' . $filepath;\n    }\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction downloadImage($url, $filepath) {\n    $ch = curl_init($url);\n    $fp = fopen($filepath, 'wb');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_exec($ch);\n    if(curl_errno($ch)) {\n        echo 'Error:' . curl_error($ch);\n    } else {\n        echo \"Image downloaded successfully to $filepath\";\n    }\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction downloadImage($url, $filepath) {\n    $ch = curl_init($url);\n    $fp = fopen($filepath, 'wb');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_exec($ch);\n    if(curl_errno($ch)) {\n        echo 'Error:' . curl_error($ch);\n    } else {\n        echo \"Image downloaded successfully to $filepath\";\n    }\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\n\nfunction downloadImage($url, $filepath) {\n    $ch = curl_init($url);\n    $fp = fopen($filepath, 'wb');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 200 && $httpCode < 300) {\n        echo \"Image downloaded successfully to $filepath\\n\";\n    } else {\n        echo \"Error downloading image: HTTP code $httpCode\\n\";\n    }\n\n\n    curl_close($ch);\n    fclose($fp);\n\n}\n\n\n?>\n",
      "<?php\nfunction downloadImage($url, $filepath) {\n    $ch = curl_init($url);\n    $fp = fopen($filepath, 'wb');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_exec($ch);\n    if(curl_errno($ch)) {\n        echo 'Error:' . curl_error($ch);\n    } else {\n        echo \"Image downloaded successfully to $filepath\";\n    }\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction downloadImage($url, $filepath) {\n    $ch = curl_init($url);\n    $fp = fopen($filepath, 'wb');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_exec($ch);\n    if(curl_errno($ch)) {\n        echo 'Error:' . curl_error($ch);\n    } else {\n        echo \"Image downloaded successfully to $filepath\";\n    }\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction downloadImage($url, $filepath) {\n    $ch = curl_init($url);\n    $fp = fopen($filepath, 'wb');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_exec($ch);\n    if(curl_errno($ch)) {\n        echo 'Error:' . curl_error($ch);\n    } else {\n        echo \"Image downloaded successfully to $filepath\";\n    }\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n",
      "<?php\nfunction downloadImage($url, $filepath) {\n    $ch = curl_init($url);\n    $fp = fopen($filepath, 'wb');\n    curl_setopt($ch, CURLOPT_FILE, $fp);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_exec($ch);\n    if(curl_errno($ch)) {\n        echo 'Error:' . curl_error($ch);\n    } else {\n        echo \"Image downloaded successfully to $filepath\";\n    }\n    curl_close($ch);\n    fclose($fp);\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a PHP class for making HTTP requests using cURL with support for various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: The `baiduRequestCore` class provides a comprehensive wrapper around PHP's cURL functions to simplify HTTP requests. It supports GET, POST, PUT, DELETE, and HEAD methods, handles authentication, manages request/response headers and bodies, and includes streaming capabilities for both uploads and downloads.\n\nAttributes:\n\nrequest_url: [string] - The URL to send the request to\nrequest_headers: [array] - Associative array of request headers\nrequest_body: [string] - The request body content\nresponse: [string] - The complete response from the server\nresponse_headers: [array] - Associative array of response headers\nresponse_body: [string] - The response body content\nresponse_code: [int] - The HTTP response status code\nresponse_info: [array] - Additional cURL response information\ncurl_handle: [resource] - The cURL handle resource\nmethod: [string] - The HTTP method to use (GET, POST, etc.)\nproxy: [array|null] - Proxy configuration details\nusername: [string|null] - Username for authentication\npassword: [string|null] - Password for authentication\ncurlopts: [array|null] - Additional cURL options\ndebug_mode: [bool] - Whether to enable debug mode\nrequest_class: [string] - Class name for request handling\nresponse_class: [string] - Class name for response handling\nuseragent: [string] - User agent string\nread_file: [string|null] - File path for reading data\nread_stream: [resource|null] - Stream resource for reading data\nread_stream_size: [int|null] - Size of the read stream\nread_stream_read: [int] - Bytes read from the stream\nwrite_file: [string|null] - File path for writing data\nwrite_stream: [resource|null] - Stream resource for writing data\nseek_position: [int|null] - Position to seek in the read stream\nregistered_streaming_read_callback: [callable|null] - Callback for streaming reads\nregistered_streaming_write_callback: [callable|null] - Callback for streaming writes\n\nMethods:\n\n__construct: [function]([string|null $url, array|null $proxy, array|null $helpers]) -> [self] - Initializes the request object with optional URL, proxy, and helper classes\n__destruct: [function]() -> [self] - Cleans up any open file handles\nset_credentials: [function]([string $user, string $pass]) -> [self] - Sets authentication credentials\nadd_header: [function]([string $key, string $value]) -> [self] - Adds a request header\nremove_header: [function]([string $key]) -> [self] - Removes a request header\nset_method: [function]([string $method]) -> [self] - Sets the HTTP method\nset_useragent: [function]([string $ua]) -> [self] - Sets the user agent string\nset_body: [function]([string $body]) -> [self] - Sets the request body\nset_request_url: [function]([string $url]) -> [self] - Sets the request URL\nset_curlopts: [function]([array $curlopts]) -> [self] - Sets additional cURL options\nset_read_stream_size: [function]([int $size]) -> [self] - Sets the read stream size\nset_read_stream: [function]([resource $resource, int|null $size]) -> [self] - Sets the read stream resource\nset_read_file: [function]([string $location]) -> [self] - Sets a file to read from\nset_write_stream: [function]([resource $resource]) -> [self] - Sets the write stream resource\nset_write_file: [function]([string $location]) -> [self] - Sets a file to write to\nset_proxy: [function]([string $proxy]) -> [self] - Configures proxy settings\nset_seek_position: [function]([int|null $position]) -> [self] - Sets the seek position for the read stream\nregister_streaming_read_callback: [function]([callable $callback]) -> [self] - Registers a streaming read callback\nregister_streaming_write_callback: [function]([callable $callback]) -> [self] - Registers a streaming write callback\nstreaming_read_callback: [function]([resource $curl_handle, resource $file_handle, int $length]) -> [string] - Callback for streaming reads\nstreaming_write_callback: [function]([resource $curl_handle, string $data]) -> [int] - Callback for streaming writes\nprep_request: [function]() -> [resource] - Prepares and returns a cURL handle with configured options\nprocess_response: [function]([resource|null $curl_handle, string|null $response]) -> [mixed] - Processes the cURL response\nsend_request: [function]([bool $parse]) -> [mixed] - Sends the request and returns the response\nget_response_header: [function]([string|null $header]) -> [mixed] - Gets a specific response header or all headers\nget_response_body: [function]() -> [string] - Gets the response body\nget_response_code: [function]() -> [int] - Gets the response status code",
    "Canonical_solution": "class baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduResponseCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n        \n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (isset($this->write_file) && isset($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        return $this;\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size'] >= 0) {\n                $position = ftell($resource);\n                if ($position !== false && $position >= 0) {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->set_read_stream($read_file_handle);\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->set_write_stream($write_file_handle);\n    }\n\n    public function set_proxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = isset($position) ? (integer) $position : null;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n        if ($this->read_stream_read == 0 && isset($this->seek_position) && $this->seek_position !== ftell($this->read_stream)) {\n            if (fseek($this->read_stream, $this->seek_position) !== 0) {\n                throw new baiduRequestCore_Exception('The stream does not support seeking and is either not at the requested position or the position is unknown.');\n            }\n        }\n        $read = fread($this->read_stream, min($this->read_stream_size - $this->read_stream_read, $length));\n        $this->read_stream_read += strlen($read);\n        $out = $read === false ? '' : $read;\n        if ($this->registered_streaming_read_callback) {\n            call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $out);\n        }\n        return $out;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n        while ($written_total < $length) {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n            if ($written_last === false) {\n                return $written_total;\n            }\n            $written_total += $written_last;\n        }\n        if ($this->registered_streaming_write_callback) {\n            call_user_func($this->registered_streaming_write_callback, $curl_handle, $written_total);\n        }\n        return $written_total;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n        \n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n        \n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n        \n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n        \n        if (extension_loaded('zlib')) {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n        \n        if (isset($this->request_headers) && count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n        \n        switch ($this->method) {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new baiduRequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream)) {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n        \n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n        \n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n        \n        if (is_resource($this->curl_handle)) {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n            \n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n            \n            $header_assoc = array();\n            foreach ($this->response_headers as $header) {\n                $kv = explode(': ', $header);\n                $header_assoc[$kv[0]] = $kv[1];\n            }\n            \n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n            \n            if ($curl_handle && $response) {\n                return new $this->response_class($this->response_headers, $this->response_body, $this->response_code, $this->curl_handle);\n            }\n        }\n        \n        return false;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n        \n        if ($this->response === false) {\n            throw new baiduRequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n        \n        $parsed_response = $this->process_response($curl_handle, $this->response);\n        curl_close($curl_handle);\n        \n        if ($parse) {\n            return $parsed_response;\n        }\n        \n        return $this->response;\n    }\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduRequestCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($helpers && is_array($helpers)) {\n            foreach (array('request', 'response') as $cls) {\n                if (isset($helpers[$cls . '_class'])) {\n                    $this->{$cls . '_class'} = $helpers[$cls . '_class'];\n                }\n            }\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->close_read_stream();\n        $this->close_write_stream();\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, 0);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->registered_streaming_write_callback) {\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n        }\n        \n\n        // Set user-defined options.\n        if (!is_null($this->curlopts) && is_array($this->curlopts)) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        // Handle authentication.\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        // Handle the proxy.\n        if ($this->proxy && is_array($this->proxy)) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        // Handle the user agent.\n        if ($this->useragent) {\n            curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        }\n\n        // Handle the HTTP method.\n        switch ($this->method) {\n            case 'GET': break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n        // Handle the headers.\n        if (count($this->request_headers) > 0) {\n            $headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n        if (!$response) {\n            $response = curl_exec($curl_handle);\n        }\n\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n\n        if ($response === false) {\n            throw new Exception('cURL resource: ' . (string)$curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $header_size = $this->response_info['header_size'];\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        $this->response = $response;\n\n        curl_close($curl_handle);\n        return $this;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->curl_handle = $curl_handle;\n\n        $this->response = curl_exec($curl_handle);\n\n        $this->process_response($this->curl_handle, $this->response);\n\n        return $this->response_body;\n    }\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            $match = array();\n            preg_match(\"/^\" . $header . \": (.*?)$/m\", $this->response_headers, $match);\n            if (isset($match[1])) {\n                return $match[1];\n            }\n            return null;\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n\n    private function close_read_stream() {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n    }\n\n    private function close_write_stream() {\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n}\n\n?>\n",
      "```php\n<?php\nclass baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduRequestCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n\n    public $write_file = null;\n    public $write_stream = null;\n\n    public $seek_position = null;\n\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($helpers && is_array($helpers)) {\n            foreach (array('request', 'response') as $cls) {\n                if (isset($helpers[$cls . '_class'])) {\n                    $this->{$cls . '_class'} = $helpers[$cls . '_class'];\n                }\n            }\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->close_read_stream();\n        $this->close_write_stream();\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n\n        while ($written_total < $length) {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n            if ($written_last === false) {\n                return $written_total;\n            }\n\n            $written_total += $written_last;\n        }\n\n        return $written_total;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $this->read_stream_size = filesize($this->read_file);\n                }\n            }\n\n            $read_callback = $this->registered_streaming_read_callback;\n            if (!$read_callback) {\n                $read_callback = array($this, 'streaming_read_callback');\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $read_callback);\n        }\n\n        if ($this->write_stream) {\n            $write_callback = $this->registered_streaming_write_callback;\n            if (!$write_callback) {\n                $write_callback = array($this, 'streaming_write_callback');\n            }\n\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $write_callback);\n        }\n\n\n        if ($this->read_file) {\n            if (!isset($this->read_stream_size)) {\n                $this->read_stream_size = filesize($this->read_file);\n            }\n\n            $this->read_stream = fopen($this->read_file, 'r');\n            $read_callback = $this->registered_streaming_read_callback;\n            if (!$read_callback) {\n                $read_callback = array($this, 'streaming_read_callback');\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $read_callback);\n        }\n\n        if ($this->write_file) {\n            $this->write_stream = fopen($this->write_file, 'w');\n            $write_callback = $this->registered_streaming_write_callback;\n            if (!$write_callback) {\n                $write_callback = array($this, 'streaming_write_callback');\n            }\n\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        }\n\n\n        if ($this->seek_position) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n        }\n\n\n        if (count($this->request_headers) || !isset($this->request_headers['Expect'])) {\n            $curl_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $curl_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $curl_headers);\n        }\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n\n        if (!$response) {\n            $response = curl_exec($curl_handle);\n        }\n\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        $this->response = $response;\n\n        curl_close($curl_handle);\n        $this->curl_handle = null;\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->curl_handle = $curl_handle;\n\n        $this->response = curl_exec($curl_handle);\n\n        $this->process_response($this->curl_handle, $this->response);\n\n        return $this->response_body;\n    }\n\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            $match = array();\n            if (preg_match(\"/^$header:\\s*(.*?)$/mi\", $this->response_headers, $match)) {\n                return $match[1];\n            }\n            return null;\n        }\n        $headers = array();\n        foreach (explode(\"\\r\\n\", $this->response_headers) as $i => $line) {\n            if ($i === 0) {\n                continue;\n            }\n\n            list($key, $value) = explode(': ', $line, 2);\n            $headers[$key] = $value;\n        }\n        return $headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n\n    private function close_read_stream()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n            $this->read_stream = null;\n            $this->read_stream_read = 0;\n        }\n    }\n\n    private function close_write_stream()\n    {\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n            $this->write_stream = null;\n        }\n    }\n}\n\n```",
      "<?php\nclass baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduRequestCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->close_read_stream();\n        $this->close_write_stream();\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n        }\n\n\n        $headers = array();\n        foreach ($this->request_headers as $k => $v) {\n            $headers[] = $k . ': ' . $v;\n        }\n        curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n\n\n        if ($this->read_file) {\n            if (!file_exists($this->read_file)) {\n                throw new baiduException('File does not exist: ' . $this->read_file);\n            }\n\n            $fh = fopen($this->read_file, 'r');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $fh);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, filesize($this->read_file));\n            $this->read_stream =  $fh;\n        }\n\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_stream) {\n                    $stats = fstat($this->read_stream);\n                    $this->read_stream_size = $stats[7];\n                }\n            }\n\n            $this->registered_streaming_read_callback = array($this, 'streaming_read_callback');\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n\n            if ($this->seek_position !== null) {\n                fseek($this->read_stream, $this->seek_position);\n                if (ftell($this->read_stream) != $this->seek_position) {\n                    throw new baiduException('Could not seek to specified position: '\n                        . $this->seek_position);\n                }\n            }\n        }\n\n        if ($this->write_file) {\n            $fh = fopen($this->write_file, 'w');\n            curl_setopt($curl_handle, CURLOPT_FILE, $fh);\n            $this->write_stream = $fh;\n        }\n\n        if ($this->write_stream) {\n            $this->registered_streaming_write_callback = array($this, 'streaming_write_callback');\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (self::is_empty_response($this->response)) {\n            throw new baiduException(\"Bad response from server: \" . $this->response);\n        }\n\n        $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n        $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n        $this->response_info = curl_getinfo($this->curl_handle);\n\n        return $this;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new baiduException('cURL resource: ' . (string)$curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed = $this->process_response($curl_handle, $this->response);\n\n        curl_close($this->curl_handle);\n\n        if ($parse) {\n            return $this->parse_response($parsed);\n        }\n\n        return $parsed;\n    }\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            if (isset($this->response_headers[$header])) {\n                return $this->response_headers[$header];\n            }\n            return null;\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n\n    public function close_read_stream()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n    }\n\n    public function close_write_stream()\n    {\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public static function is_empty_response($response)\n    {\n        return !$response;\n    }\n\n    private function parse_response($parsed)\n    {\n        $request_class = $this->request_class;\n        $response_class = $this->response_class;\n\n        $request = new $request_class();\n        $response = new $response_class($parsed);\n\n        return $response;\n    }\n}\n\n\nclass baiduException extends Exception\n{\n}\n",
      "<?php\nclass baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduRequestCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($helpers && is_array($helpers)) {\n            foreach (array('request', 'response') as $cls) {\n                if (isset($helpers[$cls . '_class'])) {\n                    $this->{$cls . '_class'} = $helpers[$cls . '_class'];\n                }\n            }\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->close_read_stream();\n        $this->close_write_stream();\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($pos)\n    {\n        $this->seek_position = $pos;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->seek_position !== null) {\n            fseek($this->read_stream, $this->seek_position);\n            $this->seek_position = null;\n        }\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $written = fwrite($this->write_stream, $data);\n        return $written;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, 0);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->registered_streaming_write_callback) {\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n        }\n\n        if (!ini_get('safe_mode') && !ini_get('open_basedir')) {\n            curl_setopt($curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        if ($this->proxy) {\n            $proxy = is_array($this->proxy) ? $this->proxy : array('host' => $this->proxy);\n            curl_setopt($curl_handle, CURLOPT_PROXY, $proxy['host']);\n            if (isset($proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $proxy['port']);\n            }\n            if (isset($proxy['user']) && isset($proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $proxy['user'] . ':' . $proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n        }\n\n\n        $this->request_headers['User-Agent'] = $this->useragent;\n        $headers = array();\n        foreach ($this->request_headers as $k => $v) {\n            $headers[] = $k . ': ' . $v;\n        }\n        curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n\n\n        $this->curl_handle = $curl_handle;\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n\n        if (!$response) {\n            $response = curl_exec($curl_handle);\n        }\n\n        $this->response_info = curl_getinfo($curl_handle);\n\n        if ($this->response_info['http_code'] == 0) {\n            throw new Exception('The cURL request could not be executed. Check for network connectivity problems.');\n        }\n\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        $this->response_code = $this->response_info['http_code'];\n        $this->response = $response;\n\n        curl_close($curl_handle);\n        $this->curl_handle = null;\n\n        return $this->response_info;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception('cURL resource: ' . (string)$curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $this->process_response($curl_handle, $this->response);\n\n        return $this->response_body;\n    }\n\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            $match = array();\n            preg_match(\"/^\" . $header . \": (.*?)$/mi\", $this->response_headers, $match);\n            return isset($match[1]) ? trim($match[1]) : null;\n        }\n\n        $headers = array();\n        foreach (explode(\"\\r\\n\", $this->response_headers) as $i => $line) {\n            if ($i === 0) {\n                continue;\n            }\n            list($key, $value) = explode(': ', $line, 2);\n            $headers[$key] = $value;\n        }\n        return $headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n\n    private function close_read_stream()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n            $this->read_stream = null;\n            $this->read_stream_read = 0;\n        }\n    }\n\n    private function close_write_stream()\n    {\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n            $this->write_stream = null;\n        }\n    }\n}\n\n",
      "<?php\nclass baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduRequestCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->close_read_stream();\n        $this->close_write_stream();\n    }\n\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            curl_setopt($curl_handle, CURLOPT_PROXYTYPE, $this->proxy['type']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                $this->add_header('Content-Length', strlen($this->request_body));\n                if ($this->read_stream || $this->read_file) {\n                    if (!isset($this->read_stream_size)) {\n                        if ($this->read_file) {\n                            $this->read_stream_size = filesize($this->read_file);\n                        } else {\n\n                            $stats = fstat($this->read_stream);\n                            $this->read_stream_size = $stats[7];\n                        }\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream ? $this->read_stream : fopen($this->read_file, 'r'));\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    if ($this->seek_position !== null) {\n                        fseek($this->read_stream ? $this->read_stream : fopen($this->read_file, 'r'), $this->seek_position);\n                    }\n                    if ($this->registered_streaming_read_callback) {\n                        curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n                    } else {\n                        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n                    }\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default: // Assumed DELETE\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n        }\n\n\n        if ($this->write_stream || $this->write_file) {\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream ? $this->write_stream : fopen($this->write_file, 'w'));\n            if ($this->registered_streaming_write_callback) {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            } else {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n            }\n        }\n\n\n        $headers = array();\n        foreach ($this->request_headers as $k => $v) {\n            $headers[] = $k . ': ' . $v;\n        }\n        curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n\n        $this->curl_handle = $curl_handle;\n        return $this->curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n\n        if (!$response) {\n            $response = curl_exec($curl_handle);\n        }\n\n        $this->response = $response;\n\n        if ($curl_handle) {\n            $this->response_info = curl_getinfo($curl_handle);\n        }\n\n        if (!isset($this->response_info['http_code'])) {\n            $this->response_code = 0;\n        } else {\n            $this->response_code = $this->response_info['http_code'];\n        }\n\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n\n        curl_close($curl_handle);\n        $this->curl_handle = null;\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n        $this->process_response($curl_handle, $this->response);\n        return $this->response_body;\n    }\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            $match = array();\n            preg_match(\"/^$header: (.*?)$/m\", $this->response_headers, $match);\n            if (isset($match[1])) {\n                return $match[1];\n            }\n            return null;\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n\n    private function close_read_stream()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n            $this->read_stream = null;\n            $this->read_stream_read = 0;\n        }\n    }\n\n    private function close_write_stream()\n    {\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n            $this->write_stream = null;\n        }\n    }\n}\n\n",
      "<?php\nclass baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduRequestCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($helpers && is_array($helpers)) {\n            foreach (array('request', 'response') as $cls) {\n                if (isset($helpers[$cls . '_class'])) {\n                    $this->{$cls . '_class'} = $helpers[$cls . '_class'];\n                }\n            }\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->close_read_stream();\n        $this->close_write_stream();\n    }\n\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n\n        if (!is_null($size)) {\n            $this->set_read_stream_size($size);\n        }\n\n        return $this;\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n\n        while ($written_total < $length) {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n\n            if ($written_last === false) {\n                return $written_total;\n            }\n\n            $written_total += $written_last;\n        }\n\n        return $written_total;\n    }\n\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            $port = isset($this->proxy['port']) ? $this->proxy['port'] : 8080;\n            curl_setopt($curl_handle, CURLOPT_PROXYPORT, $port);\n\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $this->read_stream_size = filesize($this->read_file);\n                }\n            }\n\n            $this->register_streaming_read_callback(array($this, 'streaming_read_callback'));\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n        } elseif ($this->read_file) {\n            if ($this->seek_position !== null) {\n                $this->add_header('Range', 'bytes=' . $this->seek_position . '-');\n            }\n\n            $fp = fopen($this->read_file, 'r');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $fp);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, filesize($this->read_file));\n            curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n        } elseif ($this->request_body) {\n            curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        }\n\n        $request_headers = array();\n        foreach ($this->request_headers as $key => $value) {\n            $request_headers[] = $key . ': ' . $value;\n        }\n\n        if (isset($this->request_headers['Expect']) && $this->request_headers['Expect'] == '') {\n            unset($request_headers['Expect']);\n        }\n\n        switch ($this->method) {\n            case 'GET': break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                break;\n            case 'PUT':\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_NOBODY, true);\n                break;\n        }\n\n        if (count($request_headers) > 0) {\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $request_headers);\n        }\n\n        if ($this->write_stream) {\n            $this->register_streaming_write_callback(array($this, 'streaming_write_callback'));\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        } elseif ($this->write_file) {\n            $fp = fopen($this->write_file, 'w');\n            curl_setopt($curl_handle, CURLOPT_FILE, $fp);\n        }\n\n        if ($this->curlopts) {\n            curl_setopt_array($curl_handle, $this->curlopts);\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if (!$curl_handle) {\n            $curl_handle = $this->curl_handle;\n        }\n\n        if (!$response) {\n            $response = curl_exec($curl_handle);\n        }\n\n        $this->response_info = curl_getinfo($curl_handle);\n\n        if ($this->response_info['http_code'] == 0) {\n            throw new Exception('The cURL request could not be executed. Check for network connectivity problems.');\n        }\n\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        $this->response_code = $this->response_info['http_code'];\n        $this->response = $response;\n\n        curl_close($curl_handle);\n\n        $this->close_read_stream();\n        $this->close_write_stream();\n\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->curl_handle = $curl_handle;\n        $response = $this->process_response($this->curl_handle);\n\n        return $response;\n    }\n\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            $match = array();\n\n            if (preg_match('/' . $header . ': (.+?)(\\r\\n|$)/is', $this->response_headers, $match)) {\n                return $match[1];\n            }\n\n            return null;\n        }\n\n        $headers = array();\n        $lines = explode(\"\\r\\n\", $this->response_headers);\n\n        foreach ($lines as $line) {\n            if (strpos($line, ': ') !== false) {\n                list($key, $value) = explode(': ', $line);\n                $headers[$key] = $value;\n            }\n        }\n\n        return $headers;\n    }\n\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n\n\n    private function close_read_stream()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        $this->read_stream = null;\n        $this->read_stream_size = null;\n        $this->read_stream_read = 0;\n    }\n\n\n    private function close_write_stream()\n    {\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        $this->write_stream = null;\n    }\n}\n\n",
      "<?php\nclass baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduRequestCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->close_read_stream();\n        $this->close_write_stream();\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            curl_setopt($curl_handle, CURLOPT_PROXYTYPE, $this->proxy['type']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                throw new baiduException('The stream size for reading cannot be less than 0.');\n            }\n\n            if ($this->seek_position !== null) {\n                fseek($this->read_stream, $this->seek_position);\n            }\n\n            if ($this->registered_streaming_read_callback) {\n                curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n            } else {\n                curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n        } elseif ($this->read_file) {\n            if ($this->seek_position !== null) {\n                fseek(fopen($this->read_file, 'r'), $this->seek_position);\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILE, fopen($this->read_file, 'r'));\n            curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, filesize($this->read_file));\n        }\n\n\n        if ($this->write_stream) {\n            if ($this->registered_streaming_write_callback) {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            } else {\n                curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n            }\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        } elseif ($this->write_file) {\n            curl_setopt($curl_handle, CURLOPT_FILE, fopen($this->write_file, 'w'));\n        } else {\n            curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        }\n\n\n        if (!empty($this->request_headers)) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if (!$curl_handle && !$response) {\n            return false;\n        }\n\n        if ($curl_handle) {\n            $this->response = curl_exec($curl_handle);\n            $this->response_info = curl_getinfo($curl_handle);\n            $this->response_code = $this->response_info['http_code'];\n\n            if (curl_errno($curl_handle) > 0) {\n                throw new baiduException(curl_error($curl_handle), curl_errno($curl_handle));\n            }\n        } else {\n            $this->response = $response;\n        }\n\n        $header_size = $this->response_info['header_size'];\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n\n        $this->curl_handle = $curl_handle;\n\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->process_response($curl_handle);\n        curl_close($curl_handle);\n        return $this->response_body;\n    }\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            $match = array();\n            if (preg_match(\"/^$header:\\s*(.*?)$/im\", $this->response_headers, $match)) {\n                return $match[1];\n            }\n            return null;\n        }\n        $headers = array();\n        foreach (explode(\"\\r\\n\", $this->response_headers) as $i => $line) {\n            if ($i === 0) {\n                continue;\n            }\n            list($key, $value) = explode(': ', $line);\n            $headers[$key] = $value;\n        }\n        return $headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n\n    private function close_read_stream()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n    }\n\n    private function close_write_stream()\n    {\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n}\n\nclass baiduException extends Exception\n{\n}\n"
    ],
    "unmatched_results": [
      "<?php\nclass baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduRequestCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->close_read_stream();\n        $this->close_write_stream();\n    }\n\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n\n        if (!is_null($size)) {\n            $this->set_read_stream_size($size);\n        }\n\n        return $this;\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, 0);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, 1);\n        }\n\n        if (!ini_get('safe_mode') && !ini_get('open_basedir')) {\n            curl_setopt($curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            $parts = parse_url($this->request_url);\n            if (isset($parts['scheme']) && $parts['scheme'] == 'https') {\n                curl_setopt($curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n            }\n\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if ($this->registered_streaming_write_callback) {\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n        }\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n        }\n\n        $request_headers = array();\n        foreach ($this->request_headers as $key => $value) {\n            $request_headers[] = $key . ': ' . $value;\n        }\n\n        if (!empty($request_headers)) {\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $request_headers);\n        }\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if (!is_resource($curl_handle)) {\n            return false;\n        }\n\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response = $response ? $response : curl_multi_getcontent($curl_handle);\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n        $this->response_code = curl_getinfo($curl_handle, CURLINFO_HTTP_CODE);\n        $this->response_info = curl_getinfo($curl_handle);\n\n        curl_close($curl_handle);\n        $this->curl_handle = null;\n        return $this->response_code;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->curl_handle = $curl_handle;\n\n        if (is_resource($this->read_stream)) {\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $this->read_stream_size = filesize($this->read_file);\n                } elseif (isset($this->request_headers['Content-Length'])) {\n                    $this->read_stream_size = (int) $this->request_headers['Content-Length'];\n                }\n            }\n\n            if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                $this->read_stream_size = $this->seek_position;\n            }\n\n            if (isset($this->read_stream_size) && $this->read_stream_size >= 0 && fseek($this->read_stream, $this->seek_position) === 0) {\n                if (isset($this->request_headers['Content-Length'])) {\n                    $this->request_headers['Content-Length'] = $this->read_stream_size;\n                }\n            }\n        }\n\n        if ($this->write_file) {\n            $fp = fopen($this->write_file, 'w');\n            $this->write_stream = $fp;\n        }\n\n        $this->response = curl_exec($curl_handle);\n        $this->response_code = $this->process_response($curl_handle, $this->response);\n\n        return $this->response_code;\n    }\n\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            if (isset($this->response_headers[$header])) {\n                return $this->response_headers[$header];\n            }\n            return false;\n        }\n        return $this->response_headers;\n    }\n\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n\n    private function close_read_stream() {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n    }\n\n    private function close_write_stream() {\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n}\n\n",
      "<?php\nclass baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduRequestCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->close_read_stream();\n        $this->close_write_stream();\n    }\n\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n\n        if (!is_null($size)) {\n            $this->set_read_stream_size($size);\n        }\n\n        return $this;\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            curl_setopt($curl_handle, CURLOPT_PROXYTYPE, $this->proxy['type']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if (is_array($this->request_headers) && !empty($this->request_headers)) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $this->read_stream_size = filesize($this->read_file);\n                }\n            }\n\n            $read_callback = $this->registered_streaming_read_callback;\n            if (!isset($read_callback)) {\n                $read_callback = array($this, 'streaming_read_callback');\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $read_callback);\n        }\n\n        if ($this->write_stream) {\n            $write_callback = $this->registered_streaming_write_callback;\n            if (!isset($write_callback)) {\n                $write_callback = array($this, 'streaming_write_callback');\n            }\n\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $write_callback);\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        }\n\n\n        if ($this->seek_position !== null) {\n            curl_setopt($curl_handle, CURLOPT_RESUME_FROM, $this->seek_position);\n        }\n\n        if (!is_null($this->curlopts) && is_array($this->curlopts)) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if (!is_resource($curl_handle)) {\n            return false;\n        }\n\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response = $response;\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        $this->response_code = curl_getinfo($curl_handle, CURLINFO_HTTP_CODE);\n        $this->response_info = curl_getinfo($curl_handle);\n\n        curl_close($curl_handle);\n        $this->curl_handle = null;\n\n        if (500 <= $this->response_code) {\n            return false;\n        }\n\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->curl_handle = $curl_handle;\n\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception(\"cURL request failed: \" . curl_error($curl_handle));\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            if (isset($this->response_headers[$header])) {\n                return $this->response_headers[$header];\n            }\n            return false;\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n\n    private function close_read_stream()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        $this->read_stream = null;\n        $this->read_stream_size = null;\n        $this->read_stream_read = 0;\n    }\n\n    private function close_write_stream()\n    {\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        $this->write_stream = null;\n    }\n}\n\n",
      "```php\n<?php\nclass baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduRequestCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->close_read_stream();\n        $this->close_write_stream();\n    }\n\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n\n        if (!is_null($size)) {\n            $this->set_read_stream_size($size);\n        }\n\n        return $this;\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n\n        while ($written_total < $length) {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n\n            if ($written_last === false) {\n                return $written_total;\n            }\n\n            $written_total += $written_last;\n        }\n\n        return $written_total;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            curl_setopt($curl_handle, CURLOPT_PROXYTYPE, $this->proxy['type']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if (array_key_exists('Expect', $this->request_headers)) {\n            unset($this->request_headers['Expect']);\n        }\n\n        if (!empty($this->request_headers)) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                $this->close_read_stream();\n                if (!is_null($this->read_stream)) {\n                    $this->registered_streaming_read_callback = array($this, 'streaming_read_callback');\n                    curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        }\n\n\n        if (!is_null($this->write_stream)) {\n            $this->registered_streaming_write_callback = array($this, 'streaming_write_callback');\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        } elseif (!is_null($this->write_file)) {\n            curl_setopt($curl_handle, CURLOPT_FILE, fopen($this->write_file, 'w'));\n        }\n\n        if (!is_null($this->read_file)) {\n            curl_setopt($curl_handle, CURLOPT_INFILE, fopen($this->read_file, 'r'));\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, filesize($this->read_file));\n        }\n\n        if (!is_null($this->seek_position) && $this->seek_position !== 0 && !is_null($this->read_file)) {\n            fseek(fopen($this->read_file, 'r'), $this->seek_position);\n        }\n\n        if (!is_null($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if (is_null($curl_handle)) {\n            $curl_handle = $this->curl_handle;\n        }\n\n        if (is_null($response)) {\n            $response = curl_exec($curl_handle);\n        }\n\n        if ($response === false) {\n            throw new Exception('cURL resource: ' . (string)$curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        $this->response_code = curl_getinfo($curl_handle, CURLINFO_HTTP_CODE);\n        $this->response_info = curl_getinfo($curl_handle);\n\n        $this->close_read_stream();\n        $this->close_write_stream();\n\n        return $this->response_class == 'baiduRequestCore' ? $this : new $this->response_class($this->response_headers, $this->response_body, $this->response_code, $this->response_info);\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->curl_handle = $curl_handle;\n\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception('cURL resource: ' . (string)$curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            if (isset($this->response_headers[$header])) {\n                return $this->response_headers[$header];\n            }\n            return false;\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n\n    private function close_read_stream()\n    {\n        if (!is_null($this->read_stream)) {\n            fclose($this->read_stream);\n            $this->read_stream = null;\n        }\n    }\n\n    private function close_write_stream()\n    {\n        if (!is_null($this->write_stream)) {\n            fclose($this->write_stream);\n            $this->write_stream = null;\n        }\n    }\n}\n\n```"
    ],
    "match_count": 7,
    "pass@3": 0.9916666666666667,
    "pass@5": 1.0
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a PHP class that handles HTTP requests using cURL with file download capabilities, including error handling and size limitations.\n\nClass Description: The timthumb class provides functionality to download files from URLs using cURL with progress tracking and size limitations. It includes error handling for common HTTP status codes and fallback to file_get_contents when cURL is not available.\n\nAttributes:\n- $curlFH: [resource|false] - File handle for writing downloaded data\n- $curlDataWritten: [int] - Tracks the amount of data written during download\n- $lastURLError: [string|false] - Stores the last error message encountered during URL fetching\n\nMethods:\n- curlWrite($h, $d): [int] - [Static callback function for cURL write operations. Writes data to file and tracks total size written. Returns 0 if size limit exceeded, otherwise returns bytes written]\n  - $h: [resource] - cURL handle\n  - $d: [string] - Data to write\n  - Returns: [int] - Number of bytes processed\n\n- getURL($url, $tempfile): [bool] - [Fetches content from URL and saves to temporary file. Uses cURL if available, falls back to file_get_contents. Handles HTTP errors and size limitations]\n  - $url: [string] - URL to fetch\n  - $tempfile: [string] - Path to temporary file for saving content\n  - Returns: [bool] - True on success, False on failure",
    "Canonical_solution": "class timthumb\n{\n    protected static $curlFH = false;\n    protected static $curlDataWritten = 0;\n    protected $lastURLError = false;\n\n    public static function curlWrite($h, $d)\n    {\n        fwrite(self::$curlFH, $d);\n        self::$curlDataWritten += strlen($d);\n        if (self::$curlDataWritten > MAX_FILE_SIZE) {\n            return 0;\n        } else {\n            return strlen($d);\n        }\n    }\n\n    protected function getURL($url, $tempfile)\n    {\n        $this->lastURLError = false;\n        $url = preg_replace('/ /', '%20', $url);\n        if (function_exists('curl_init')) {\n            $this->debug(3, \"Curl is installed so using it to fetch URL.\");\n            self::$curlFH = fopen($tempfile, 'w');\n            if (!self::$curlFH) {\n                $this->error(\"Could not open $tempfile for writing.\");\n                return false;\n            }\n            self::$curlDataWritten = 0;\n            $this->debug(3, \"Fetching url with curl: $url\");\n            $curl = curl_init($url);\n            curl_setopt($curl, CURLOPT_TIMEOUT, CURL_TIMEOUT);\n            curl_setopt($curl, CURLOPT_USERAGENT, \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.122 Safari/534.30\");\n            curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\n            curl_setopt($curl, CURLOPT_HEADER, 0);\n            curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n            curl_setopt($curl, CURLOPT_WRITEFUNCTION, 'timthumb::curlWrite');\n            @curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n            @curl_setopt($curl, CURLOPT_MAXREDIRS, 10);\n\n            $curlResult = curl_exec($curl);\n            fclose(self::$curlFH);\n            $httpStatus = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n            if ($httpStatus == 404) {\n                $this->set404();\n            }\n            if ($httpStatus == 302) {\n                $this->error(\"External Image is Redirecting. Try alternate image url\");\n                return false;\n            }\n            if ($curlResult) {\n                curl_close($curl);\n                return true;\n            } else {\n                $this->lastURLError = curl_error($curl);\n                curl_close($curl);\n                return false;\n            }\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === false) {\n                $err = error_get_last();\n                if (is_array($err) && $err['message']) {\n                    $this->lastURLError = $err['message'];\n                } else {\n                    $this->lastURLError = $err;\n                }\n                if (preg_match('/404/', $this->lastURLError)) {\n                    $this->set404();\n                }\n\n                return false;\n            }\n            if (!file_put_contents($tempfile, $img)) {\n                $this->error(\"Could not write to $tempfile.\");\n                return false;\n            }\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($this->curlFH, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $this->curlDataWritten += $return;\n        return $return;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                fclose($this->curlFH);\n                return false;\n            }\n\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n            curl_setopt($ch, CURLOPT_HEADER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FAILONERROR, true);\n            $curl_result = curl_exec($ch);\n\n            if ($curl_result === false) {\n                $this->lastURLError = curl_error($ch);\n                curl_close($ch);\n                fclose($this->curlFH);\n                return false;\n            } else {\n                $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n                if ($http_code != 200) {\n                    $this->lastURLError = 'HTTP error: ' . $http_code;\n                    curl_close($ch);\n                    fclose($this->curlFH);\n                    return false;\n                }\n            }\n            curl_close($ch);\n        } else {\n            $max_filesize = 10485760;\n            $img = file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents failed';\n                fclose($this->curlFH);\n                return false;\n            }\n            $filesize = strlen($img);\n            if ($filesize > $max_filesize) {\n                $this->lastURLError = 'Exceeded filesize limit';\n                fclose($this->curlFH);\n                return false;\n            }\n            fwrite($this->curlFH, $img);\n        }\n\n        fclose($this->curlFH);\n        return true;\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($this->curlFH, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $this->curlDataWritten += $return;\n        return $return;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                fclose($this->curlFH);\n                return false;\n            }\n\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n            curl_setopt($ch, CURLOPT_HEADER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FAILONERROR, true);\n            $curl_result = curl_exec($ch);\n\n            if ($curl_result === false) {\n                $this->lastURLError = curl_error($ch);\n                curl_close($ch);\n                fclose($this->curlFH);\n                return false;\n            } else {\n                $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n                if ($http_code != 200) {\n                    $this->lastURLError = 'HTTP error: ' . $http_code;\n                    curl_close($ch);\n                    fclose($this->curlFH);\n                    return false;\n                }\n            }\n            curl_close($ch);\n        } else {\n            $max_filesize = 10485760;\n            $img = file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents failed';\n                fclose($this->curlFH);\n                return false;\n            }\n            $filesize = strlen($img);\n            if ($filesize > $max_filesize) {\n                $this->lastURLError = 'Exceeded filesize limit';\n                fclose($this->curlFH);\n                return false;\n            }\n            fwrite($this->curlFH, $img);\n        }\n        fclose($this->curlFH);\n        return true;\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $fp = $h;\n        $data = $d;\n        fwrite($fp, $data);\n        $written = strlen($data);\n        $thisObj = &timthumb::getInstance();\n        $thisObj->curlDataWritten += $written;\n        if ($thisObj->curlDataWritten > 10485760) {\n            return 0;\n        }\n        return $written;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->curlDataWritten = 0;\n        if (function_exists('curl_init')) {\n            $ch = curl_init();\n            $this->curlFH = fopen($tempfile, 'w');\n            if (!$this->curlFH) {\n                $this->lastURLError = 'Could not open temporary file for writing.';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_URL, $url);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.122 Safari/534.30');\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 0);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_exec($ch);\n\n            if (curl_errno($ch)) {\n                $this->lastURLError = curl_error($ch);\n                fclose($this->curlFH);\n                return false;\n            }\n\n            $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($http_code != 200) {\n                $this->lastURLError = 'HTTP error: ' . $http_code;\n                fclose($this->curlFH);\n                return false;\n            }\n\n            fclose($this->curlFH);\n            curl_close($ch);\n            return true;\n\n        } else {\n            $img = file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL';\n                return false;\n            }\n            if (file_put_contents($tempfile, $img) === false) {\n                $this->lastURLError = 'Could not write to temporary file.';\n                return false;\n            }\n            return true;\n        }\n    }\n\n    private static $instance = null;\n    public static function &getInstance() {\n        if (!self::$instance) {\n            self::$instance = new timthumb();\n        }\n        return self::$instance;\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($h, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $timthumb_instance = self::getInstance();\n        $timthumb_instance->curlDataWritten += $return;\n        if ($timthumb_instance->curlDataWritten > 10485760) {\n            return 0;\n        }\n        return $return;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlDataWritten = 0;\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            $this->curlFH = fopen($tempfile, 'w');\n            if (!$this->curlFH) {\n                $this->lastURLError = 'Could not open temporary file';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_URL, $url);\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_exec($ch);\n            $code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($code != 200 && $code != 304) {\n                $this->lastURLError = $code;\n            }\n            curl_close($ch);\n            fclose($this->curlFH);\n            if ($this->lastURLError) {\n                return false;\n            }\n            return true;\n        } else {\n            $img = file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL';\n                return false;\n            }\n            if (file_put_contents($tempfile, $img) === false) {\n                $this->lastURLError = 'Could not write to temporary file';\n                return false;\n            }\n            return true;\n        }\n    }\n\n\n    private static $instance;\n\n    private function __construct() {}\n\n    public static function getInstance() {\n        if (!self::$instance) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n}\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($this->curlFH, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $this->curlDataWritten += $return;\n        return $return;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                fclose($this->curlFH);\n                return false;\n            }\n\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n            curl_setopt($ch, CURLOPT_HEADER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_exec($ch);\n\n            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($httpCode != 200) {\n                $this->lastURLError = $httpCode;\n                curl_close($ch);\n                fclose($this->curlFH);\n                return false;\n            }\n\n            curl_close($ch);\n        } else {\n            $maxFileSize = 10485760;\n            $img = file_get_contents($url);\n            if ($img === false) {\n                fclose($this->curlFH);\n                return false;\n            }\n            $this->curlDataWritten = strlen($img);\n            fwrite($this->curlFH, $img);\n        }\n\n        fclose($this->curlFH);\n        return true;\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($h, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $size = strlen($d);\n        $GLOBALS['timthumb']->curlDataWritten += $size;\n        if ($GLOBALS['timthumb']->curlDataWritten > 10485760) {\n            return 0;\n        }\n        return $return;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlDataWritten = 0;\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            $this->curlFH = fopen($tempfile, 'w');\n            if (!$this->curlFH) {\n                $this->lastURLError = 'Could not open temporary file';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_URL, $url);\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt($ch, CURLOPT_MAXREDIRS, 3);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            $data = curl_exec($ch);\n            fclose($this->curlFH);\n            if (curl_errno($ch)) {\n                $this->lastURLError = curl_error($ch);\n                return false;\n            }\n            $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($http_code != 200) {\n                $this->lastURLError = 'HTTP error: ' . $http_code;\n                return false;\n            }\n            curl_close($ch);\n            return true;\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL';\n                return false;\n            }\n            if (file_put_contents($tempfile, $img) === false) {\n                $this->lastURLError = 'Could not write to temporary file';\n                return false;\n            }\n            return true;\n        }\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($this->curlFH, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $this->curlDataWritten += $return;\n        return $return;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                fclose($this->curlFH);\n                return false;\n            }\n\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:20.0) Gecko/20100101 Firefox/20.0');\n            curl_setopt($ch, CURLOPT_MAXREDIRS, 5);\n            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n            curl_setopt($ch, CURLOPT_HEADER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_exec($ch);\n\n            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($httpCode != 200) {\n                $this->lastURLError = $httpCode;\n                curl_close($ch);\n                fclose($this->curlFH);\n                return false;\n            }\n\n            curl_close($ch);\n        } else {\n            $maxFileSize = 10485760;\n            $img = @file_get_contents($url);\n            if ($img === false) {\n                fclose($this->curlFH);\n                return false;\n            }\n            $this->curlDataWritten = fwrite($this->curlFH, $img);\n            if ($this->curlDataWritten === false || strlen($img) > $maxFileSize) {\n                fclose($this->curlFH);\n                return false;\n            }\n        }\n\n        fclose($this->curlFH);\n        return true;\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($this->curlFH, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $this->curlDataWritten += $return;\n        return $return;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                fclose($this->curlFH);\n                return false;\n            }\n\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n            curl_setopt($ch, CURLOPT_HEADER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FAILONERROR, true);\n            $curl_result = curl_exec($ch);\n\n            if ($curl_result === false) {\n                $this->lastURLError = curl_error($ch);\n                curl_close($ch);\n                fclose($this->curlFH);\n                return false;\n            } else {\n                $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n                if ($http_code != 200) {\n                    $this->lastURLError = 'HTTP error ' . $http_code;\n                    curl_close($ch);\n                    fclose($this->curlFH);\n                    return false;\n                }\n            }\n            curl_close($ch);\n        } else {\n            $max_filesize = 10485760;\n            $img = file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents failed';\n                fclose($this->curlFH);\n                return false;\n            }\n            $filesize = strlen($img);\n            if ($filesize > $max_filesize) {\n                $this->lastURLError = 'Exceeded filesize limit';\n                fclose($this->curlFH);\n                return false;\n            }\n            fwrite($this->curlFH, $img);\n        }\n        fclose($this->curlFH);\n        return true;\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($h, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $size = strlen($d);\n        $thisObj = &self::getInstance();\n        $thisObj->curlDataWritten += $size;\n        if ($thisObj->curlDataWritten > 10485760) {\n            return 0;\n        }\n        return $return;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->curlDataWritten = 0;\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            $this->curlFH = fopen($tempfile, 'wb');\n            if (! $this->curlFH) {\n                $this->lastURLError = 'Could not open temporary file for writing.';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this,'curlWrite'));\n            $data = curl_exec($ch);\n            fclose($this->curlFH);\n            if (curl_errno($ch)) {\n                $this->lastURLError = curl_error($ch);\n                return false;\n            }\n            $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($http_code != 200) {\n                $this->lastURLError = 'HTTP error: ' . $http_code;\n                return false;\n            }\n            curl_close($ch);\n            return true;\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === FALSE) {\n                $this->lastURLError = 'Could not retrieve URL with file_get_contents.  ';\n                return false;\n            }\n            if (file_put_contents($tempfile, $img) === FALSE) {\n                $this->lastURLError = 'Could not write to temporary file.';\n                return false;\n            }\n            return true;\n        }\n    }\n\n    private static function &getInstance() {\n        static $instance = null;\n        if (null === $instance) {\n            $instance = new self();\n        }\n        return $instance;\n    }\n}\n?>\n",
      "<?php\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    public static function curlWrite($h, $d) {\n        $return = fwrite($this->curlFH, $d);\n        if ($return === false) {\n            return 0;\n        }\n        $this->curlDataWritten += $return;\n        if ($this->curlDataWritten > 10485760) {\n            return 0;\n        }\n        return $return;\n    }\n\n\n    public function getURL($url, $tempfile) {\n        $this->curlDataWritten = 0;\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                $this->lastURLError = 'Could not initialize cURL';\n                return false;\n            }\n\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_HEADER, false);\n            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt($ch, CURLOPT_MAXREDIRS, 3);\n\n            $curl_result = curl_exec($ch);\n            if ($curl_result === false) {\n                $this->lastURLError = curl_error($ch);\n            }\n            $http_response_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            curl_close($ch);\n\n            if ($http_response_code != 200) {\n                $this->lastURLError = 'HTTP response code: ' . $http_response_code;\n                fclose($this->curlFH);\n                return false;\n            }\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL';\n                fclose($this->curlFH);\n                return false;\n            }\n            fwrite($this->curlFH, $img);\n        }\n\n        fclose($this->curlFH);\n        return true;\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using cURL, supporting various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: The RequestCore class provides a comprehensive HTTP client implementation using PHP's cURL extension. It supports standard HTTP methods (GET, POST, PUT, DELETE, HEAD), handles request/response processing, streaming uploads/downloads, authentication, proxy configuration, and SSL verification.\n\nAttributes:\n\nrequest_url: string - The URL to send the request to\nrequest_headers: array - Associative array of request headers\nrequest_body: string - The request body content\nresponse: string - The complete response including headers and body\nresponse_headers: array - Parsed response headers\nresponse_body: string - The response body content\nresponse_code: int - HTTP response status code\nresponse_info: array - Additional cURL response information\ncurl_handle: resource - The cURL handle resource\nmethod: string - HTTP method (GET, POST, PUT, DELETE, HEAD)\nproxy: array|null - Proxy configuration details\nusername: string|null - Username for authentication\npassword: string|null - Password for authentication\ncurlopts: array|null - Additional cURL options\ndebug_mode: bool - Whether to enable debug mode\nrequest_class: string - Class name for request handling\nresponse_class: string - Class name for response handling\nuseragent: string - User-Agent header value\nread_file: string|null - File path for streaming read\nread_stream: resource|null - Stream resource for reading\nread_stream_size: int|null - Size of read stream\nread_stream_read: int - Bytes read from stream\nwrite_file: string|null - File path for streaming write\nwrite_stream: resource|null - Stream resource for writing\nseek_position: int|null - Position to seek in read stream\ncacert_location: mixed - CA certificate location\nssl_verification: bool - Whether to verify SSL\nregistered_streaming_read_callback: callable|null - Callback for streaming read\nregistered_streaming_write_callback: callable|null - Callback for streaming write\ntimeout: int - Request timeout in seconds\nconnect_timeout: int - Connection timeout in seconds\n\nMethods:\n\n__construct(string $url = null, string $proxy = null, array $helpers = null) -> self - Initializes the request with URL and optional proxy/helpers\n__destruct() -> self - Cleans up open file handles\nset_credentials(string $user, string $pass) -> self - Sets authentication credentials\nadd_header(string $key, string $value) -> self - Adds a request header\nremove_header(string $key) -> self - Removes a request header\nset_method(string $method) -> self - Sets the HTTP method\nset_useragent(string $ua) -> self - Sets the User-Agent header\nset_body(string $body) -> self - Sets the request body\nset_request_url(string $url) -> self - Sets the request URL\nset_curlopts(array $curlopts) -> self - Sets additional cURL options\nset_read_stream_size(int $size) -> self - Sets the read stream size\nset_read_stream(resource $resource, int $size = null) -> self - Sets the read stream resource\nset_read_file(string $location) -> self - Sets a file for streaming read\nset_write_stream(resource $resource) -> self - Sets the write stream resource\nset_write_file(string $location) -> self - Sets a file for streaming write\nset_proxy(string $proxy) -> self - Configures proxy settings\nset_seek_position(int $position) -> self - Sets the seek position for read stream\nregister_streaming_read_callback(callable $callback) -> self - Registers streaming read callback\nregister_streaming_write_callback(callable $callback) -> self - Registers streaming write callback\nstreaming_read_callback(resource $curl_handle, resource $file_handle, int $length) -> string - Callback for streaming read\nstreaming_write_callback(resource $curl_handle, string $data) -> int - Callback for streaming write\nprep_request() -> resource - Prepares and returns a cURL handle\nprocess_response(resource $curl_handle = null, string $response = null) -> mixed - Processes the cURL response\nsend_request(bool $parse = false) -> mixed - Sends the request and returns response\nsend_multi_request(array $handles, array $opt = null) -> array - Sends multiple requests in parallel",
    "Canonical_solution": "namespace NOS\\Http;\n\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'NOS\\Http\\RequestCore';\n    public $response_class = 'NOS\\Http\\ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n    public $timeout = 5184000;\n    public $connect_timeout = 10;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n\n        if (isset($this->write_file) && isset($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n\n        return $this;\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n\n            if ($stats && $stats['size'] >= 0) {\n                $position = ftell($resource);\n\n                if ($position !== false && $position >= 0) {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->set_read_stream($read_file_handle);\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->set_write_stream($write_file_handle);\n    }\n\n    public function set_proxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = isset($position) ? (integer)$position : null;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        if ($this->read_stream_read == 0 && isset($this->seek_position) && $this->seek_position !== ftell($this->read_stream)) {\n            if (fseek($this->read_stream, $this->seek_position) !== 0) {\n                throw new RequestCore_Exception('The stream does not support seeking and is either not at the requested position or the position is unknown.');\n            }\n        }\n\n        $read = fread($this->read_stream, min($this->read_stream_size - $this->read_stream_read, $length));\n        $this->read_stream_read += strlen($read);\n        $out = $read === false ? '' : $read;\n\n        if ($this->registered_streaming_read_callback) {\n            call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $out);\n        }\n\n        return $out;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n\n        while ($written_total < $length) {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n\n            if ($written_last === false) {\n                return $written_total;\n            }\n\n            $written_total += $written_last;\n        }\n\n        if ($this->registered_streaming_write_callback) {\n            call_user_func($this->registered_streaming_write_callback, $curl_handle, $written_total);\n        }\n\n        return $written_total;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, $this->connect_timeout);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        if ($this->cacert_location === true) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, dirname(__FILE__) . '/cacert.pem');\n        } elseif (is_string($this->cacert_location)) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if (!ini_get('safe_mode') && !ini_get('open_basedir')) {\n            curl_setopt($curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (extension_loaded('zlib')) {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n\n        if (isset($this->request_headers) && count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        switch ($this->method) {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream)) {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle)) {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n\n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n\n            $header_assoc = array();\n            foreach ($this->response_headers as $header) {\n                $kv = explode(': ', $header);\n                $header_assoc[strtolower($kv[0])] = isset($kv[1]) ? $kv[1] : '';\n            }\n\n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n\n            if ($curl_handle && $response) {\n                return new ResponseCore($this->response_headers, $this->response_body, $this->response_code);\n            }\n        }\n\n        return false;\n    }\n\n    public function send_request($parse = false)\n    {\n        set_time_limit(0);\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new RequestCore_Exception('cURL resource: ' . (string)$curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n        curl_close($curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        set_time_limit(0);\n        if (count($handles) === 0) return array();\n        if (!$opt) $opt = array();\n\n        $limit = isset($opt['limit']) ? $opt['limit'] : -1;\n        $handle_list = $handles;\n        $http = new $this->request_class();\n        $multi_handle = curl_multi_init();\n        $handles_post = array();\n        $added = count($handles);\n        $last_handle = null;\n        $count = 0;\n        $i = 0;\n\n        while ($i < $added) {\n            if ($limit > 0 && $i >= $limit) break;\n            curl_multi_add_handle($multi_handle, array_shift($handles));\n            $i++;\n        }\n\n        do {\n            $active = false;\n            while (($status = curl_multi_exec($multi_handle, $active)) === CURLM_CALL_MULTI_PERFORM) {\n                if (count($handles) > 0) break;\n            }\n\n            $to_process = array();\n            while ($done = curl_multi_info_read($multi_handle)) {\n                if ($done['result'] > 0) {\n                    throw new RequestCore_Exception('cURL resource: ' . (string)$done['handle'] . '; cURL error: ' . curl_error($done['handle']) . ' (' . $done['result'] . ')');\n                } elseif (!isset($to_process[(int)$done['handle']])) {\n                    $to_process[(int)$done['handle']] = $done;\n                }\n            }\n\n            foreach ($to_process as $pkey => $done) {\n                $response = $http->process_response($done['handle'], curl_multi_getcontent($done['handle']));\n                $key = array_search($done['handle'], $handle_list, true);\n                $handles_post[$key] = $response;\n\n                if (count($handles) > 0) {\n                    curl_multi_add_handle($multi_handle, array_shift($handles));\n                }\n\n                curl_multi_remove_handle($multi_handle, $done['handle']);\n                curl_close($done['handle']);\n            }\n        } while ($active || count($handles_post) < $added);\n\n        curl_multi_close($multi_handle);\n        ksort($handles_post, SORT_N",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n    public $timeout = 30;\n    public $connect_timeout = 30;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        // Set up the proxy.\n        $this->set_proxy($proxy);\n        $this->request_url = $url;\n        $this->method = 'GET';\n    }\n\n    public function __destruct()\n    {\n\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, $this->connect_timeout);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n        if ($this->request_headers) {\n            $headers = array();\n            foreach ($this->request_headers as $key => $value) {\n                $headers[] = $key . ': ' . $value;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n        // Handle the read file.\n        if ($this->read_file) {\n            $fh = fopen($this->read_file, 'r');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $fh);\n            curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n\n            if (isset($this->read_stream_size)) {\n                curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            }\n        }\n\n\n        if ($this->read_stream) {\n\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_stream_size = fstat($this->read_stream)['size']) {\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                }\n            }\n\n            $this->registered_streaming_read_callback =\n                array($this, 'streaming_read_callback');\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n            curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n        }\n\n\n        if ($this->write_file) {\n            $fh = fopen($this->write_file, 'w');\n            curl_setopt($curl_handle, CURLOPT_FILE, $fh);\n        }\n\n        if ($this->write_stream) {\n            $this->registered_streaming_write_callback =\n                array($this, 'streaming_write_callback');\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        }\n\n        if ($this->seek_position) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n\n        if ($this->cacert_location === true) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, dirname(__FILE__) . '/cacert.pem');\n        } else if (is_string($this->cacert_location)) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if (!$this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n\n        } else if ($curl_handle) {\n            $this->response = curl_exec($curl_handle);\n            $this->response_info = curl_getinfo($curl_handle);\n        }\n\n        if ($this->response_info['http_code'] == 0) {\n            throw new Exception('Unable to connect to ' . $this->request_url);\n        }\n\n        if (is_string($this->response) && !empty($this->response)) {\n            $header_size = $this->response_info['header_size'];\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = $this->response_info['http_code'];\n        }\n\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->curl_handle = $curl_handle;\n        $this->response = curl_exec($curl_handle);\n        $this->response_info = curl_getinfo($curl_handle);\n\n        if ($this->response === false) {\n\n            throw new Exception(\"cURL request failed: \" . curl_error($curl_handle));\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        curl_close($curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        } else {\n            return $this->response;\n        }\n    }\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        $mh = curl_multi_init();\n        foreach ($handles as $curl_handle) {\n            curl_multi_add_handle($mh, $curl_handle);\n        }\n        $running = null;\n        do {\n            curl_multi_exec($mh, $running);\n            curl_multi_select($mh);\n        } while ($running > 0);\n\n        $response = array();\n        foreach ($handles as $curl_handle) {\n            $response[] = $this->process_response($curl_handle);\n            curl_multi_remove_handle($mh, $curl_handle);\n        }\n        curl_multi_close($mh);\n        return $response;\n    }\n}\n\n?>\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n    public $timeout = 30;\n    public $connect_timeout = 30;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n\n\n        $this->ssl_verification = true;\n\n\n        $this->cacert_location = __DIR__ . '/cacert.pem';\n    }\n\n    public function __destruct()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n\n    public function remove_header($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n\n        if (!isset($size)) {\n            if (isset($this->read_stream_size)) {\n                $this->read_stream_size = $size;\n            } else {\n                $stats = fstat($this->read_stream);\n                $this->read_stream_size = $stats[7];\n            }\n        } else {\n            $this->read_stream_size = $size;\n        }\n\n        return $this;\n    }\n\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, $this->connect_timeout);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                throw new RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n\n            if (!isset($this->registered_streaming_read_callback)) {\n                $this->register_streaming_read_callback(array($this, 'streaming_read_callback'));\n            }\n\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n        }\n\n\n        if ($this->write_stream) {\n            if (!isset($this->registered_streaming_write_callback)) {\n                $this->register_streaming_write_callback(array($this, 'streaming_write_callback'));\n            }\n\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        }\n\n\n        if ($this->read_file) {\n            if (!is_file($this->read_file)) {\n                throw new RequestCore_Exception('The file to read from cannot be found: ' . $this->read_file);\n            }\n\n            $fh = fopen($this->read_file, 'rb');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $fh);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, filesize($this->read_file));\n            $this->read_stream = $fh;\n        }\n\n        if ($this->write_file) {\n            $fh = fopen($this->write_file, 'wb');\n            curl_setopt($curl_handle, CURLOPT_FILE, $fh);\n            $this->write_stream = $fh;\n        }\n\n        if ($this->seek_position) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n\n        $request_headers = array();\n        foreach ($this->request_headers as $key => $value) {\n            $request_headers[] = $key . ': ' . $value;\n        }\n\n        if (count($request_headers) > 0) {\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $request_headers);\n        }\n\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n\n        if (is_resource($this->curl_handle)) {\n            $this->response_info = curl_getinfo($this->curl_handle);\n        }\n\n\n        if ($this->response_info['http_code'] == 0) {\n            throw new RequestCore_Exception(curl_error($this->curl_handle), curl_errno($this->curl_handle));\n        }\n\n\n        $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n        $this->response_code = $this->response_info['http_code'];\n\n\n        return $this;\n    }\n\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n        $parsed = $this->process_response($curl_handle, $this->response);\n\n        curl_close($this->curl_handle);\n\n        if ($parse) {\n            return $parsed;\n        }\n\n        return $this->response;\n    }\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        $mh = curl_multi_init();\n        $requestMap = array();\n        foreach ($handles as $handle) {\n            curl_multi_add_handle($mh, $handle);\n            $ch = $handle;\n            $key = (string) $ch;\n            $requestMap[$key] = $ch;\n        }\n\n        $running = null;\n        do {\n            curl_multi_exec($mh, $running);\n            curl_multi_select($mh);\n        } while ($running > 0);\n\n        $response = array();\n        foreach ($requestMap as $key => $ch) {\n            $response[$key] = curl_multi_getcontent($ch);\n            $this->process_response($ch, $response[$key]);\n            curl_multi_remove_handle($mh, $ch);\n        }\n\n        curl_multi_close($mh);\n        return $response;\n    }\n}\n\nclass RequestCore_Exception extends Exception\n{\n}\n?>\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n    public $timeout = 30;\n    public $connect_timeout = 30;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = 'GET';\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n\n\n        $this->ssl_verification = true;\n\n\n        $this->cacert_location = __DIR__ . '/cacert.pem';\n    }\n\n\n    public function __destruct()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n\n    public function remove_header($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n\n        if (!isset($size)) {\n            if (isset($this->read_stream_size)) {\n                $size = $this->read_stream_size;\n            } else {\n\n                $stats = fstat($resource);\n                if ($stats && isset($stats['size'])) {\n                    $size = $stats['size'];\n                }\n            }\n        }\n\n        $this->set_read_stream_size($size);\n        return $this;\n    }\n\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, $this->connect_timeout);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy);\n        }\n\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if (isset($this->read_stream)) {\n            $this->registered_streaming_read_callback = array($this, 'streaming_read_callback');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n        }\n\n\n        if (isset($this->write_stream)) {\n            $this->registered_streaming_write_callback = array($this, 'streaming_write_callback');\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        }\n\n\n        if (isset($this->seek_position) && $this->seek_position !== ftell($this->read_stream)) {\n            rewind($this->read_stream);\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n\n        $request_headers = array();\n        foreach ($this->request_headers as $key => $value) {\n            $request_headers[] = $key . ': ' . $value;\n        }\n        curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $request_headers);\n\n\n        if ($this->curlopts && is_array($this->curlopts)) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if (!isset($curl_handle) && !isset($response)) {\n            return false;\n        }\n\n\n        if (isset($curl_handle)) {\n            $this->response = curl_exec($curl_handle);\n            $this->response_info = curl_getinfo($curl_handle);\n            $this->response_code = $this->response_info['http_code'];\n        } else {\n            $this->response = $response;\n        }\n\n\n        if (isset($this->response) && !empty($this->response)) {\n            $header_size = $this->response_info['header_size'];\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_headers = $this->get_response_headers($this->response_headers);\n        }\n\n        curl_close($curl_handle);\n        return $this->response_code;\n    }\n\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->process_response($curl_handle);\n        return $this->response_body;\n    }\n\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        $mh = curl_multi_init();\n        foreach ($handles as $handle) {\n            curl_multi_add_handle($mh, $handle);\n        }\n\n        $running = null;\n        do {\n            curl_multi_exec($mh, $running);\n        } while ($running > 0);\n\n        $response = array();\n        foreach ($handles as $handle) {\n            $response[] = curl_multi_getcontent($handle);\n            curl_multi_remove_handle($mh, $handle);\n        }\n        curl_multi_close($mh);\n        return $response;\n    }\n\n    private function get_response_headers($headers)\n    {\n        $headers = explode(\"\\r\\n\", $headers);\n        $response_headers = array();\n        foreach ($headers as $header) {\n            if (strpos($header, ':')) {\n                list($key, $value) = explode(':', $header, 2);\n                $response_headers[$key] = trim($value);\n            }\n        }\n        return $response_headers;\n    }\n}\n\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n    public $timeout = 30;\n    public $connect_timeout = 30;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        // Set up a class for handling requests and responses.\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($url) {\n            $this->set_request_url($url);\n        }\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n    }\n\n    public function __destruct()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n    \n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size']) {\n                $this->read_stream_size = $stats['size'];\n            }\n        } else {\n            $this->read_stream_size = $size;\n        }\n\n        return $this;\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, $this->connect_timeout);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->cacert_location === true) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, dirname(__FILE__) . '/cacert.pem');\n        } elseif (is_string($this->cacert_location)) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if (!$this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 1);\n        }\n\n\n        // Handle user authentication.\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        // Handle the proxy.\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy);\n        }\n\n        // Handle the user agent.\n        if ($this->useragent) {\n            curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        }\n\n        // Handle the HTTP method.\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n        // Handle the headers.\n        if (isset($this->request_headers) && is_array($this->request_headers)) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n\n        // Handle streaming uploads.\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                throw new RequestCore_Exception('The stream size for upload cannot be determined.');\n            }\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n        }\n\n        // Handle streaming downloads.\n        if ($this->write_stream) {\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n        }\n\n\n        if ($this->seek_position) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n        if ($this->curlopts && is_array($this->curlopts)) {\n            curl_setopt_array($curl_handle, $this->curlopts);\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n\n        if (curl_errno($this->curl_handle) > 0) {\n            throw new RequestCore_Exception(curl_error($this->curl_handle), curl_errno($this->curl_handle));\n        }\n\n        $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n        $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n        $this->response_info = curl_getinfo($this->curl_handle);\n\n        if ($this->response_code >= 400) {\n            throw new RequestCore_Exception($this->response_body, $this->response_code);\n        }\n\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        curl_close($this->curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        $mh = curl_multi_init();\n        foreach ($handles as $handle) {\n            curl_multi_add_handle($mh, $handle);\n        }\n\n        $running = null;\n        do {\n            curl_multi_exec($mh, $running);\n            usleep(10000);\n        } while ($running > 0);\n\n        $response = array();\n        foreach ($handles as $handle) {\n            $response[] = curl_multi_getcontent($handle);\n            curl_multi_remove_handle($mh, $handle);\n        }\n        curl_multi_close($mh);\n\n        return $response;\n    }\n}\n\n\nclass RequestCore_Exception extends Exception\n{\n}\n?>\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n    public $timeout = 30;\n    public $connect_timeout = 30;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        // Set up the proxy.\n        $this->set_proxy($proxy);\n        $this->request_url = $url;\n        $this->method = 'GET';\n    }\n\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && is_resource($this->read_file)) {\n            fclose($this->read_file);\n        }\n\n        if (isset($this->write_file) && is_resource($this->write_file)) {\n            fclose($this->write_file);\n        }\n    }\n\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            $this->read_stream_size = $stats[7];\n        } else {\n            $this->read_stream_size = $size;\n        }\n\n        return $this;\n    }\n\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n\n        while ($written_total < $length) {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n\n            if ($written_last === false) {\n                return 0;\n            }\n\n            $written_total += $written_last;\n        }\n\n        return $written_total;\n    }\n\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, $this->connect_timeout);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->cacert_location !== false) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n\n\n        // Handle user authentication.\n        if (isset($this->username, $this->password)) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        // Handle the proxy.\n        if (isset($this->proxy)) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy);\n        }\n\n\n        // Handle the user agent.\n        if (isset($this->useragent)) {\n            curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        }\n\n\n        // Handle the HTTP method.\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n\n        // Handle the headers.\n        if (isset($this->request_headers)) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n\n        // Handle streaming file reading.\n        if (isset($this->read_file)) {\n            $fh = fopen($this->read_file, 'r');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $fh);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, filesize($this->read_file));\n            $this->read_stream =  $fh;\n        }\n\n\n        // Handle streaming file writing.\n        if (isset($this->write_file)) {\n            $fh = fopen($this->write_file, 'w');\n            curl_setopt($curl_handle, CURLOPT_FILE, $fh);\n            $this->write_stream = $fh;\n        }\n\n\n        // Handle streaming custom callbacks.\n        if (isset($this->read_stream)) {\n            if (!isset($this->registered_streaming_read_callback)) {\n                $this->registered_streaming_read_callback = array($this, 'streaming_read_callback');\n            }\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n        }\n\n\n        if (isset($this->write_stream)) {\n            if (!isset($this->registered_streaming_write_callback)) {\n                $this->registered_streaming_write_callback = array($this, 'streaming_write_callback');\n            }\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        }\n\n\n        if (isset($this->seek_position) && $this->seek_position !== ftell($this->read_stream)) {\n            rewind($this->read_stream);\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n        // Set additional cURL options.\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        // Accept a custom one if it's passed.\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n\n        if (isset($this->curl_handle) && isset($this->response)) {\n            $this->response_info = curl_getinfo($this->curl_handle);\n            $this->response_code = $this->response_info['http_code'];\n\n            if (isset($this->response_info['content_type'])) {\n                $this->response_info['content_type'] = $this->response_info['content_type'];\n            }\n\n\n            // Only set the CURLOPT_RETURNTRANSFER to true to get the response.\n            if (curl_getinfo($this->curl_handle, CURLINFO_HEADER_OUT) === true) {\n                $this->response_headers = $this->get_response_headers($this->response);\n                $this->response_body = $this->get_response_body($this->response);\n            } else {\n                $this->response_body = $this->response;\n            }\n        }\n\n        return $this;\n    }\n\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception(\"cURL request failed: \" . curl_error($curl_handle));\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        curl_close($this->curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response_body;\n    }\n\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        // Initialize any missing opt variables.\n        $multi_handle = curl_multi_init();\n        $anymore = false;\n        $msg_num = 0;\n\n        // Add the handles to the multi handle.\n        foreach ($handles as $handle) {\n            curl_multi_add_handle($multi_handle, $handle);\n        }\n\n        do {\n            while (($mrc = curl_multi_exec($multi_handle, $anymore)) == CURLM_CALL_MULTI_PERFORM)\n                ;\n\n            while ($info = curl_multi_info_read($multi_handle)) {\n                $ch = $info['handle'];\n                $request = $this->find_request_by_handle($handles, $ch);\n                $response = curl_multi_getcontent($ch);\n                $request = $request->process_response($ch, $response);\n                curl_multi_remove_handle($multi_handle, $ch);\n            }\n\n            if ($anymore) {\n                curl_multi_select($multi_handle, 0.5);\n            }\n        } while ($anymore);\n\n        curl_multi_close($multi_handle);\n        return $handles;\n    }\n\n    private function find_request_by_handle($requests, $needle)\n    {\n        foreach ($requests as $request) {\n            if ($request->curl_handle === $needle) {\n                return $request;\n            }\n        }\n    }\n\n    private function get_response_headers($response)\n    {\n        $headers = array();\n        $header_text = substr($response, 0, strpos($response, \"\\r\\n\\r\\n\"));\n\n        foreach (explode(\"\\r\\n\", $header_text) as $i => $line) {\n            if ($i === 0) {\n                $headers['http_code'] = $line;\n            } else {\n                list ($key, $value) = explode(': ', $line);\n                $headers[$key] = $value;\n            }\n        }\n\n        return $headers;\n    }\n\n\n    private function get_response_body($response)\n    {\n        return substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n    }\n}\n\nclass ResponseCore\n{\n    public $header;\n    public $body;\n    public $status;\n\n    public function __construct($header, $body, $status)\n    {\n        $this->header = $header;\n        $this->body = $body;\n        $this->status = $status;\n    }\n}\n\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n    public $timeout = 30;\n    public $connect_timeout = 30;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        // Set up the proxy.\n        $this->set_proxy($proxy);\n        $this->request_url = $url;\n        $this->method = 'GET';\n    }\n\n    public function __destruct()\n    {\n\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, $this->connect_timeout);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n        if ($this->request_headers) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n\n        // Handle the read file.\n        if ($this->read_file) {\n            if (!is_file($this->read_file)) {\n                throw new RequestCore_Exception('read_file is not a file');\n            }\n\n            $fh = fopen($this->read_file, 'rb');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $fh);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, filesize($this->read_file));\n            $this->read_stream =  $fh;\n        }\n\n\n        if ($this->read_stream) {\n\n            if (!isset($this->read_stream_size)) {\n                if ($this->method == 'POST' || $this->method == 'PUT') {\n                    throw new RequestCore_Exception('The stream size for ' . $this->method . ' requests needs to be set.');\n                }\n            } else {\n                curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            }\n\n            $this->register_streaming_read_callback(array($this, 'streaming_read_callback'));\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n        }\n\n\n        if ($this->write_file) {\n            $fh = fopen($this->write_file, 'wb');\n            curl_setopt($curl_handle, CURLOPT_FILE, $fh);\n            $this->write_stream = $fh;\n        }\n\n        if ($this->write_stream) {\n            $this->register_streaming_write_callback(array($this, 'streaming_write_callback'));\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        }\n\n        if ($this->seek_position) {\n            fseek($this->read_stream, $this->seek_position);\n        }\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            if ($this->cacert_location === true) {\n                curl_setopt($curl_handle, CURLOPT_CAINFO, dirname(__FILE__) . '/cacert.pem');\n            } elseif (is_string($this->cacert_location)) {\n                curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n            }\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 0);\n        }\n\n        // Set any custom CURLOPTs.\n        if (is_array($this->curlopts) && isset($this->curlopts)) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        // Accept a custom one if it's passed.\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n\n        if (curl_errno($this->curl_handle) > 0) {\n            throw new RequestCore_Exception(curl_error($this->curl_handle), curl_errno($this->curl_handle));\n        }\n\n        $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n        $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n        $this->response_info = curl_getinfo($this->curl_handle);\n\n        // Parse out the headers.\n        $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n        $this->response_headers = array_pop($this->response_headers);\n        $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n        array_shift($this->response_headers);\n\n        $header_assoc = array();\n        foreach ($this->response_headers as $header) {\n            $kv = explode(': ', $header);\n            $header_assoc[strtolower($kv[0])] = isset($kv[1]) ? $kv[1] : '';\n        }\n\n        $this->response_headers = $header_assoc;\n        return $this;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n        $parsed = $this->process_response($curl_handle, $this->response);\n\n        curl_close($this->curl_handle);\n\n        if ($parse) {\n            return $parsed;\n        }\n\n        return $this->response;\n    }\n\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        // Initialize any missing options.\n        $multi_handle = curl_multi_init();\n        $handles_post = array();\n        $added = count($handles);\n        $last_handle = $added - 1;\n\n        foreach ($handles as $handle) {\n            $err = curl_multi_add_handle($multi_handle, $handle);\n            if ($err === CURLM_OK || $err === CURLM_CALL_MULTI_PERFORM) {\n                $handles_post[(int) $handle] = $handle;\n            }\n        }\n\n        do {\n            $active = curl_multi_exec($multi_handle, $running);\n        } while ($running > 0);\n\n        $responses = array();\n        foreach ($handles_post as $handle) {\n            $responses[] = $this->process_response($handle, curl_multi_getcontent($handle));\n            curl_multi_remove_handle($multi_handle, $handle);\n            curl_close($handle);\n        }\n\n        curl_multi_close($multi_handle);\n        return $responses;\n    }\n}\n\nclass RequestCore_Exception extends Exception\n{\n}\n?>\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n    public $timeout = 30;\n    public $connect_timeout = 30;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        // Set up the proxy.\n        $this->set_proxy($proxy);\n        $this->request_url = $url;\n        $this->method = 'GET';\n    }\n\n    public function __destruct()\n    {\n\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, $this->connect_timeout);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        //if (!ini_get('safe_mode') && !ini_get('open_basedir')) {\n            //curl_setopt($curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        //}\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if ($this->cacert_location !== false) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n\n        if (!isset($this->read_stream)) {\n            if ($this->read_file) {\n                $fh = fopen($this->read_file, 'r');\n                $this->read_stream = $fh;\n                $stats = fstat($fh);\n                $this->read_stream_size = $stats[7];\n            }\n        }\n\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size)) {\n                if ($this->read_file) {\n                    $stats = fstat($this->read_stream);\n                    $this->read_stream_size = $stats[7];\n                }\n            }\n\n            $read_callback = array($this, 'streaming_read_callback');\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $read_callback);\n        }\n\n        if ($this->write_stream) {\n            $write_callback = array($this, 'streaming_write_callback');\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $write_callback);\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        } else if ($this->write_file) {\n            $fp = fopen($this->write_file, 'w');\n            curl_setopt($curl_handle, CURLOPT_FILE, $fp);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        }\n\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n        if (is_array($this->request_headers)) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        if ($this->curlopts !== null) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($curl_handle, $key, $value);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n\n        } else if ($curl_handle) {\n            $this->response = curl_exec($curl_handle);\n            $this->response_info = curl_getinfo($curl_handle);\n        }\n\n        if ($this->response) {\n            $header_size = $this->response_info['header_size'];\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = $this->response_info['http_code'];\n\n            return $this->response_body;\n        } else {\n            return false;\n        }\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->curl_handle = $curl_handle;\n        $this->response = curl_exec($curl_handle);\n        $this->response_info = curl_getinfo($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception(\"cURL request failed: \" . curl_error($curl_handle));\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        curl_close($curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        } else {\n            return $this->response;\n        }\n    }\n\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        $mh = curl_multi_init();\n        foreach ($handles as $handle) {\n            curl_multi_add_handle($mh, $handle);\n        }\n\n        $running = null;\n        do {\n            curl_multi_exec($mh, $running);\n            curl_multi_select($mh);\n        } while ($running > 0);\n\n        $res = array();\n        foreach ($handles as $handle) {\n            $res[] = curl_multi_getcontent($handle);\n            curl_multi_remove_handle($mh, $handle);\n        }\n        curl_multi_close($mh);\n\n        return $res;\n    }\n}\n\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n    public $timeout = 30;\n    public $connect_timeout = 30;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        // Set up the proxy.\n        $this->set_proxy($proxy);\n        $this->request_url = $url;\n        $this->method = 'GET';\n    }\n\n    public function __destruct()\n    {\n\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, $this->connect_timeout);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n\n        if ($this->read_stream) {\n            if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                throw new RequestCore_Exception('The stream size for the read stream needs to be set.');\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n\n            if (!isset($this->registered_streaming_read_callback)) {\n                $this->register_streaming_read_callback(array($this, 'streaming_read_callback'));\n            }\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n        }\n\n\n        if ($this->write_stream) {\n            if (!isset($this->registered_streaming_write_callback)) {\n                $this->register_streaming_write_callback(array($this, 'streaming_write_callback'));\n            }\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        }\n\n\n        if ($this->request_headers) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'DELETE':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n        }\n\n\n        if ($this->curlopts && is_array($this->curlopts)) {\n            foreach ($this->curlopts as $opt => $value) {\n                curl_setopt($curl_handle, $opt, $value);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        // Accept a custom one if it's passed.\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n\n        if (curl_errno($this->curl_handle) > 0) {\n            throw new RequestCore_Exception(curl_error($this->curl_handle), curl_errno($this->curl_handle));\n        }\n\n        $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($this->response, 0, $header_size);\n        $this->response_body = substr($this->response, $header_size);\n        $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n        $this->response_info = curl_getinfo($this->curl_handle);\n\n        return $this->response_body;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        curl_close($this->curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        $mh = curl_multi_init();\n        foreach ($handles as $handle) {\n            curl_multi_add_handle($mh, $handle);\n        }\n\n        $running = null;\n        do {\n            curl_multi_exec($mh, $running);\n            usleep(10000);\n        } while ($running > 0);\n\n        $response = array();\n        foreach ($handles as $handle) {\n            $response[] = curl_multi_getcontent($handle);\n            curl_multi_remove_handle($mh, $handle);\n        }\n        curl_multi_close($mh);\n\n        return $response;\n    }\n}\n\n\nclass RequestCore_Exception extends Exception\n{\n\n}\n?>\n"
    ],
    "unmatched_results": [
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n    public $timeout = 30;\n    public $connect_timeout = 30;\n\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        // Set up the proxy.\n        $this->set_proxy($proxy);\n        $this->request_url = $url;\n        $this->method = 'GET';\n    }\n\n    public function __destruct()\n    {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n    \n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        $read = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($read);\n        return $read;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        // Set default options.\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, $this->connect_timeout);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n        if ($this->cacert_location !== false) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        }\n\n\n        switch ($this->method) {\n            case 'GET':\n                curl_setopt($curl_handle, CURLOPT_HTTPGET, true);\n                break;\n            case 'POST':\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if ($this->read_stream || $this->read_file) {\n                    if (!isset($this->read_stream_size)) {\n                        if ($this->read_file) {\n                            $this->read_stream_size = filesize($this->read_file);\n                        }\n                    }\n                    $this->apply_stream_params($curl_handle);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case 'HEAD':\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'HEAD');\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if ($this->read_stream || $this->read_file) {\n                    if (!isset($this->read_stream_size)) {\n                        if ($this->read_file) {\n                            $this->read_stream_size = filesize($this->read_file);\n                        }\n                    }\n                    $this->apply_stream_params($curl_handle);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n\n        // Merge in the CURLOPTs\n        if (is_array($this->curlopts) && !empty($this->curlopts)) {\n            curl_setopt_array($curl_handle, $this->curlopts);\n        }\n\n        if (is_array($this->request_headers) && !empty($this->request_headers)) {\n            $http_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $http_headers[] = \"$k: $v\";\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        // Extract the response info\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n\n        // Extract the headers and response body\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        $this->response = $response;\n\n        curl_close($curl_handle);\n        return $this->response_code;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->curl_handle = $curl_handle;\n\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new Exception(\"cURL request failed: \" . curl_error($curl_handle));\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        return $parsed_response;\n    }\n\n\n    public function apply_stream_params(&$curl_handle)\n    {\n        if (is_resource($this->read_stream)) {\n            if (!isset($this->read_stream_size)) {\n                throw new Exception('The stream size needs to be set.');\n            }\n\n            if ($this->seek_position !== null) {\n                fseek($this->read_stream, $this->seek_position);\n            }\n\n            if (!isset($this->registered_streaming_read_callback)) {\n                $this->register_streaming_read_callback(array($this, 'streaming_read_callback'));\n            }\n\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_stream);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n            curl_setopt($curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n        } elseif ($this->read_file) {\n            if ($this->seek_position !== null) {\n                fseek($this->read_file, $this->seek_position);\n            }\n            curl_setopt($curl_handle, CURLOPT_INFILE, $this->read_file);\n            curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n        }\n\n        if (is_resource($this->write_stream)) {\n            if (!isset($this->registered_streaming_write_callback)) {\n                $this->register_streaming_write_callback(array($this, 'streaming_write_callback'));\n            }\n\n            curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_stream);\n        } elseif ($this->write_file) {\n            curl_setopt($curl_handle, CURLOPT_FILE, $this->write_file);\n        }\n    }\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        $mh = curl_multi_init();\n        $active = null;\n\n        foreach ($handles as $handle) {\n            curl_multi_add_handle($mh, $handle);\n        }\n\n        do {\n            $mrc = curl_multi_exec($mh, $active);\n        } while ($mrc == CURLM_CALL_MULTI_PERFORM);\n\n        while ($active && $mrc == CURLM_OK) {\n            if (curl_multi_select($mh) != -1) {\n                do {\n                    $mrc = curl_multi_exec($mh, $active);\n                } while ($mrc == CURLM_CALL_MULTI_PERFORM);\n            }\n        }\n\n        $responses = array();\n        foreach ($handles as $handle) {\n            $responses[] = curl_multi_getcontent($handle);\n            curl_multi_remove_handle($mh, $handle);\n        }\n\n        curl_multi_close($mh);\n        return $responses;\n    }\n}\n?>\n",
      "<?php\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n    public $timeout = 30;\n    public $connect_timeout = 30;\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        // Initialize\n    }\n\n    public function __destruct()\n    {\n        $this->close_read_stream();\n        $this->close_write_stream();\n    }\n\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy)\n    {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        // ... implementation\n    }\n\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        // ... implementation\n    }\n\n\n    public function prep_request()\n    {\n        // ... implementation\n    }\n\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        // ... implementation\n    }\n\n\n    public function send_request($parse = false)\n    {\n        // ... implementation\n    }\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        // ... implementation\n    }\n\n\n    private function close_read_stream()\n    {\n        // ... implementation\n    }\n\n    private function close_write_stream()\n    {\n        // ... implementation\n    }\n}\n\n?>\n"
    ],
    "match_count": 8,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client using cURL to make HTTP requests, handle responses, and manage redirects while maintaining request details like headers, status codes, and response body.\n\nClass Description: The `File` class represents an HTTP client that uses cURL to make HTTP requests. It handles request execution, response parsing, redirect following, and error management. It implements the `SimplePie\\HTTP\\Response` interface, providing methods to access response details.\n\nAttributes:\n\n- url: string - The final requested URL after any redirects\n- useragent: string - The user agent string used for the request\n- success: bool - Indicates whether the request was successful\n- headers: array - The response headers from the request\n- body: string - The response body content\n- status_code: int - The HTTP status code of the response\n- redirects: int - The number of redirects followed\n- error: string - Any error message encountered during the request\n- method: int - The method used for the request (bitmask)\n- permanent_url: string - The original URL before any redirects\n- permanentUrlMutable: bool - Flag indicating if permanent URL can be changed\n\nMethods:\n\n- __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = []) -> void - Initializes the HTTP client, makes the request, and processes the response. Handles redirects recursively.\n- get_body_content(): string - Returns the response body content\n- get_headers(): array - Returns the response headers\n- get_status_code(): int - Returns the HTTP status code\n- get_final_requested_uri(): string - Returns the final URL after any redirects\n- get_permanent_uri(): string - Returns the original URL before any redirects",
    "Canonical_solution": "use SimplePie\\HTTP\\Response;\n\nclass File implements Response\n{\n    private $url;\n    private $useragent;\n    private $success = true;\n    private $headers = [];\n    private $body;\n    private $status_code = 0;\n    private $redirects = 0;\n    private $error;\n    private $method;\n    private $permanent_url;\n    private $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        $this->url = $url;\n        $this->permanent_url = $url;\n        $this->useragent = $useragent;\n\n        if (preg_match('/^http(s)?:\\/\\//i', $url)) {\n            if ($useragent === null) {\n                $useragent = ini_get('user_agent');\n                $this->useragent = $useragent;\n            }\n            if (!is_array($headers)) {\n                $headers = [];\n            }\n            if (!$force_fsockopen && function_exists('curl_exec')) {\n                $this->method = \\SimplePie\\SimplePie::FILE_SOURCE_REMOTE | \\SimplePie\\SimplePie::FILE_SOURCE_CURL;\n                $fp = curl_init();\n                $headers2 = [];\n                foreach ($headers as $key => $value) {\n                    $headers2[] = \"$key: $value\";\n                }\n                curl_setopt($fp, CURLOPT_URL, $url);\n                curl_setopt($fp, CURLOPT_HEADER, 1);\n                curl_setopt($fp, CURLOPT_RETURNTRANSFER, 1);\n                curl_setopt($fp, CURLOPT_FAILONERROR, 1);\n                curl_setopt($fp, CURLOPT_TIMEOUT, $timeout);\n                curl_setopt($fp, CURLOPT_CONNECTTIMEOUT, $timeout);\n                curl_setopt($fp, CURLOPT_REFERER, \\SimplePie\\Misc::url_remove_credentials($url));\n                curl_setopt($fp, CURLOPT_USERAGENT, $useragent);\n                curl_setopt($fp, CURLOPT_HTTPHEADER, $headers2);\n                foreach ($curl_options as $curl_param => $curl_value) {\n                    curl_setopt($fp, $curl_param, $curl_value);\n                }\n\n                $responseHeaders = curl_exec($fp);\n                $this->status_code = curl_getinfo($fp, CURLINFO_HTTP_CODE);\n                if (curl_errno($fp)) {\n                    $this->error = 'cURL error ' . curl_errno($fp) . ': ' . curl_error($fp);\n                    $this->success = false;\n                } else {\n                    if ($info = curl_getinfo($fp)) {\n                        $this->url = $info['url'];\n                    }\n                    curl_close($fp);\n                    $responseHeaders = \\SimplePie\\HTTP\\Parser::prepareHeaders($responseHeaders, $info['redirect_count'] + 1);\n                    $parser = new \\SimplePie\\HTTP\\Parser($responseHeaders, true);\n                    if ($parser->parse()) {\n                        $this->headers = $parser->headers;\n                        $this->body = trim($parser->body);\n                        $this->status_code = $parser->status_code;\n                        if ((in_array($this->status_code, [300, 301, 302, 303, 307]) || $this->status_code > 307 && $this->status_code < 400) && $this->redirects < $redirects) {\n                            $this->redirects++;\n                            $this->permanentUrlMutable = $this->permanentUrlMutable && ($this->status_code == 301 || $this->status_code == 308);\n                            $this->__construct($this->url, $timeout, $redirects, $headers, $useragent, $force_fsockopen, $curl_options);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public function get_body_content(): string\n    {\n        return (string) $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return (int) $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return (string) $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return (string) $this->permanent_url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nnamespace SimplePie\\HTTP;\n\nclass File implements Response\n{\n    public $url;\n    public $useragent;\n    public $success = true;\n    public $headers = [];\n    public $body;\n    public $status_code;\n    public $redirects = 0;\n    public $error;\n    public $method;\n    public $permanent_url;\n    public $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        $this->permanent_url = $url;\n        $this->url = $url;\n        $this->useragent = $useragent;\n        $this->method = SIMPLEPIE_HTTP_METHOD_GET;\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout * 1.25); // Give a little extra time for the request\n        if ($useragent) {\n            curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n        }\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        foreach ($curl_options as $option => $value) {\n            curl_setopt($ch, $option, $value);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch) === 28) {\n            $this->error = 'Operation timed out after ' . ($timeout * 1.25) . ' seconds with ' . curl_getinfo($ch, CURLINFO_SIZE_DOWNLOAD) . ' bytes received';\n            $this->success = false;\n            curl_close($ch);\n            return;\n        }\n\n        if (curl_errno($ch)) {\n            $this->error = curl_error($ch);\n            $this->success = false;\n            curl_close($ch);\n            return;\n        }\n\n        $info = curl_getinfo($ch);\n        curl_close($ch);\n\n        $this->status_code = $info['http_code'];\n        $this->headers = $this->parse_headers(substr($response, 0, $info['header_size']));\n        $this->body = substr($response, $info['header_size']);\n\n        if ($this->status_code > 300 && $this->status_code < 400 && $redirects > 0 && isset($this->headers['location'])) {\n            $this->redirects++;\n            if ($this->permanentUrlMutable) {\n                $this->permanent_url = $this->headers['location'];\n            }\n            $new = new File($this->headers['location'], $timeout, $redirects - 1, $headers, $useragent, $force_fsockopen, $curl_options);\n            $this->url = $new->url;\n            $this->success = $new->success;\n            $this->headers = $new->headers;\n            $this->body = $new->body;\n            $this->status_code = $new->status_code;\n            $this->error = $new->error;\n            $this->redirects += $new->redirects;\n        }\n    }\n\n    public function parse_headers($raw_headers): array\n    {\n        $headers = [];\n        $key = '';\n        foreach (explode(\"\\n\", $raw_headers) as $line) {\n            $line = trim($line);\n            if (preg_match('/^([^:]+): (.+)$/', $line, $matches)) {\n                $key = strtolower($matches[1]);\n                $headers[$key] = trim($matches[2]);\n            } elseif (strlen($line) > 0 && $key) {\n                $headers[$key] .= ' ' . $line;\n            }\n        }\n        return $headers;\n    }\n\n    public function get_body_content(): string\n    {\n        return $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return $this->permanent_url;\n    }\n}\n",
      "<?php\n\nclass File implements SimplePie_HTTP_Response\n{\n    public $url;\n    public $useragent;\n    public $success = true;\n    public $headers = [];\n    public $body;\n    public $status_code;\n    public $redirects = 0;\n    public $error;\n    public $method;\n    public $permanent_url;\n    public $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        if ($useragent === null) {\n            $useragent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36';\n        }\n        $this->permanent_url = $url;\n        $this->useragent = $useragent;\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout + 5); \n        curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, false);\n\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        foreach ($curl_options as $option => $value) {\n            curl_setopt($ch, $option, $value);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch) === 0) {\n            $info = curl_getinfo($ch);\n            $this->headers = $this->parse_headers(substr($response, 0, $info['header_size']));\n            $this->body = substr($response, $info['header_size']);\n            $this->status_code = $info['http_code'];\n            $this->url = $info['url'];\n\n            if ($this->status_code > 300 && $this->status_code < 400 && $redirects > 0 && isset($this->headers['location'])) {\n                $this->redirects++;\n                $location = $this->headers['location'];\n                if (strpos($location, '/') === 0) {\n                    $parts = parse_url($url);\n                    $location = $parts['scheme'] . '://' . $parts['host'] . $location;\n                }\n                $new = new File($location, $timeout, $redirects - 1, $headers, $useragent, $force_fsockopen, $curl_options);\n                $this->body = $new->body;\n                $this->headers = $new->headers;\n                $this->status_code = $new->status_code;\n                $this->url = $new->url;\n                $this->redirects += $new->redirects;\n                $this->success = $new->success;\n                $this->error = $new->error;\n            }\n        } else {\n            $this->error = curl_error($ch);\n            $this->success = false;\n        }\n\n        curl_close($ch);\n    }\n\n    private function parse_headers(string $raw_headers): array\n    {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", $raw_headers);\n        array_shift($lines);\n\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $key = strtolower(trim($key));\n                $value = trim($value);\n                if (isset($headers[$key])) {\n                    if (is_array($headers[$key])) {\n                        $headers[$key][] = $value;\n                    } else {\n                        $headers[$key] = [$headers[$key], $value];\n                    }\n                } else {\n                    $headers[$key] = $value;\n                }\n            }\n        }\n        return $headers;\n    }\n\n    public function get_body_content(): string\n    {\n        return $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return $this->permanent_url;\n    }\n}\n",
      "<?php\n\nnamespace SimplePie\\HTTP;\n\nclass File implements Response\n{\n    public $url;\n    public $useragent;\n    public $success = true;\n    public $headers = [];\n    public $body;\n    public $status_code;\n    public $redirects = 0;\n    public $error;\n    public $method;\n    public $permanent_url;\n    public $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        if ($useragent === null) {\n            $useragent = 'SimplePie/' . \\SimplePie::VERSION;\n        }\n\n        $this->permanent_url = $url;\n        $this->url = $url;\n        $this->useragent = $useragent;\n        $this->method = \\SimplePie::HTTP_METHOD_GET;\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_HEADER, 1);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, $timeout);\n        curl_setopt($curl, CURLOPT_TIMEOUT, $timeout * 1.25); // Give 25% more time for data/response\n        curl_setopt($curl, CURLOPT_USERAGENT, $useragent);\n        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, false); // We handle redirects ourselves\n\n        if (!empty($headers)) {\n            curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        foreach ($curl_options as $curl_option_key => $curl_option_value) {\n            curl_setopt($curl, $curl_option_key, $curl_option_value);\n        }\n\n        $response = curl_exec($curl);\n        $status_line = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        if (curl_errno($curl)) {\n            $this->error = curl_error($curl);\n            $this->success = false;\n        }\n        curl_close($curl);\n\n        if ($response) {\n            list($header, $this->body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n            $this->headers = $this->parse_headers($header);\n            $this->status_code = (int) $status_line;\n\n            if ($this->status_code > 300 && $this->status_code < 400 && $redirects > 0 && isset($this->headers['location'])) {\n                $this->redirects++;\n                $location = $this->headers['location'];\n                if (strpos($location, '/') === 0) {\n                    $parts = parse_url($url);\n                    $location = $parts['scheme'] . '://' . $parts['host'] . $location;\n                }\n                $new = new File($location, $timeout, $redirects - 1, $headers, $useragent, $force_fsockopen, $curl_options);\n                $this->url = $new->url;\n                if ($this->permanentUrlMutable) {\n                    $this->permanent_url = $new->permanent_url;\n                }\n                $this->success = $new->success;\n                $this->headers = $new->headers;\n                $this->body = $new->body;\n                $this->status_code = $new->status_code;\n                $this->redirects += $new->redirects;\n                $this->error = $new->error;\n            }\n        }\n    }\n\n    public function parse_headers(string $raw_headers): array\n    {\n        $headers = [];\n        $key = null;\n        foreach (explode(\"\\r\\n\", $raw_headers) as $line) {\n            if (preg_match('/^([^:]+): (.*)$/', $line, $matches)) {\n                $key = strtolower(trim($matches[1]));\n                $headers[$key] = trim($matches[2]);\n            } elseif (preg_match('/^\\s+(.*)$/', $line, $matches) && $key !== null) {\n                $headers[$key] .= ' ' . trim($matches[1]);\n            }\n        }\n        return $headers;\n    }\n\n    public function get_body_content(): string\n    {\n        return $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return $this->permanent_url;\n    }\n}\n",
      "<?php\n\nnamespace SimplePie\\HTTP;\n\nclass File implements Response\n{\n    public $url;\n    public $useragent;\n    public $success = true;\n    public $headers = [];\n    public $body;\n    public $status_code;\n    public $redirects = 0;\n    public $error;\n    public $method;\n    public $permanent_url;\n    public $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        $this->permanent_url = $url;\n        $this->url = $url;\n        $this->useragent = $useragent;\n        $this->method = SIMPLEPIE_HTTP_METHOD_GET;\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_HEADER, 1);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, $timeout);\n        curl_setopt($curl, CURLOPT_TIMEOUT, $timeout);\n        if (!ini_get('safe_mode') && !ini_get('open_basedir')) {\n            curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1);\n            curl_setopt($curl, CURLOPT_MAXREDIRS, $redirects);\n        } else {\n            curl_setopt($curl, CURLOPT_FOLLOWLOCATION, false);\n            curl_setopt($curl, CURLOPT_MAXREDIRS, 0);\n        }\n\n        if ($useragent) {\n            curl_setopt($curl, CURLOPT_USERAGENT, $useragent);\n        }\n\n        if (!empty($headers)) {\n            curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        foreach ($curl_options as $option => $value) {\n            curl_setopt($curl, $option, $value);\n        }\n\n        $response = curl_exec($curl);\n        $status_line = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        if (curl_errno($curl)) {\n            $this->error = curl_error($curl);\n            $this->success = false;\n        }\n\n        curl_close($curl);\n\n        if ($response) {\n            $exploded = explode(\"\\r\\n\\r\\n\", $response, 2);\n            $headers = $exploded[0];\n            $body = isset($exploded[1]) ? $exploded[1] : '';\n\n            $this->headers = $this->parse_headers($headers);\n            $this->body = $body;\n\n            if (isset($status_line)) {\n                $this->status_code = $status_line;\n            }\n\n            if ($this->status_code > 300 && $this->status_code < 400 && isset($this->headers['location'])) {\n                if ($this->redirects < $redirects) {\n                    $this->redirects++;\n                    $location = $this->headers['location'];\n                    if (strpos($location, '/') === 0)\n                    {\n                        $parsed_url = parse_url($url);\n                        $location = $parsed_url['scheme'] . '://' . $parsed_url['host'] . $location;\n                    }\n                    $new = new File($location, $timeout, $redirects, $headers, $useragent, $force_fsockopen, $curl_options);\n                    $this->url = $new->url;\n                    $this->success = $new->success;\n                    $this->headers = $new->headers;\n                    $this->body = $new->body;\n                    $this->status_code = $new->status_code;\n                    $this->error = $new->error;\n                    if ($this->permanentUrlMutable)\n                    {\n                        $this->permanent_url = $new->permanent_url;\n                    }\n                }\n            }\n        }\n    }\n\n\n    public function parse_headers($raw_headers)\n    {\n        $headers = [];\n        $key = '';\n        foreach (explode(\"\\n\", $raw_headers) as $line) {\n            $line = trim($line);\n            if (preg_match('/^([^:]+): (.+)$/', $line, $matches)) {\n                $key = strtolower(trim($matches[1]));\n                $value = trim($matches[2]);\n                if (isset($headers[$key])) {\n                    if (!is_array($headers[$key])) {\n                        $headers[$key] = [$headers[$key]];\n                    }\n                    $headers[$key][] = $value;\n                } else {\n                    $headers[$key] = $value;\n                }\n            } elseif ($line && $key) {\n                if (is_array($headers[$key])) {\n                    end($headers[$key]);\n                    $headers[$key][key($headers[$key])] .= ' ' . $line;\n                } else {\n                    $headers[$key] .= ' ' . $line;\n                }\n            }\n        }\n        return $headers;\n    }\n\n    public function get_body_content(): string\n    {\n        return $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return $this->permanent_url;\n    }\n}\n",
      "<?php\n\nnamespace SimplePie\\HTTP;\n\nclass File implements Response\n{\n    public $url;\n    public $useragent;\n    public $success = true;\n    public $headers = [];\n    public $body;\n    public $status_code;\n    public $redirects = 0;\n    public $error;\n    public $method;\n    public $permanent_url;\n    public $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        $this->permanent_url = $url;\n        $this->url = $url;\n        $this->useragent = $useragent;\n        $this->method = SIMPLEPIE_HTTP_METHOD_GET;\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout * 1.25); // Give a little extra time for the request\n        if ($useragent) {\n            curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n        }\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        foreach ($curl_options as $option => $value) {\n            curl_setopt($ch, $option, $value);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch) === 28) {\n            $this->error = 'Operation timed out after ' . ($timeout * 1.25) . ' seconds with ' . curl_getinfo($ch, CURLINFO_REDIRECT_COUNT) . ' redirects';\n            $this->success = false;\n            $this->status_code = 408; // Set timeout status code\n        } elseif (curl_errno($ch)) {\n            $this->error = curl_error($ch);\n            $this->success = false;\n        } else {\n            $info = curl_getinfo($ch);\n            $this->status_code = $info['http_code'];\n            $this->url = $info['url'];\n\n            if ($this->permanentUrlMutable) {\n                $this->permanent_url = $this->url;\n            }\n\n            if ($info['redirect_count'] > 0) {\n                $this->redirects = $info['redirect_count'];\n            }\n\n            list($headers, $this->body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n            $this->headers = $this->parseHeaders($headers);\n\n            if ($this->status_code > 300 && $this->status_code < 400 && $redirects > $this->redirects && isset($this->headers['location'])) {\n                curl_close($ch);\n                $redirect = new File($this->headers['location'], $timeout, $redirects - 1, $headers, $useragent, $force_fsockopen, $curl_options);\n                $this->url = $redirect->url;\n                $this->permanent_url = $redirect->permanent_url;\n                $this->success = $redirect->success;\n                $this->headers = $redirect->headers;\n                $this->body = $redirect->body;\n                $this->status_code = $redirect->status_code;\n                $this->redirects += $redirect->redirects;\n                $this->error = $redirect->error;\n                return;\n            }\n        }\n\n        curl_close($ch);\n    }\n\n    private function parseHeaders(string $headers): array\n    {\n        $parsedHeaders = [];\n        foreach (explode(\"\\r\\n\", $headers) as $header) {\n            if (strpos($header, ':') !== false) {\n                list($key, $value) = explode(':', $header, 2);\n                $parsedHeaders[strtolower(trim($key))] = trim($value);\n            }\n        }\n        return $parsedHeaders;\n    }\n\n\n    public function get_body_content(): string\n    {\n        return $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return $this->permanent_url;\n    }\n}\n",
      "<?php\n\nnamespace SimplePie\\HTTP;\n\nclass File implements Response\n{\n    public $url;\n    public $useragent;\n    public $success = true;\n    public $headers = [];\n    public $body;\n    public $status_code;\n    public $redirects = 0;\n    public $error;\n    public $method = SIMPLEPIE_HTTP_METHOD_GET;\n    public $permanent_url;\n    public $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        $this->permanent_url = $url;\n        $this->url = $url;\n        $this->useragent = $useragent;\n\n        if (function_exists('curl_init')) {\n            $curl = curl_init();\n            curl_setopt($curl, CURLOPT_URL, $url);\n            curl_setopt($curl, CURLOPT_HEADER, 1);\n            curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, $timeout);\n            curl_setopt($curl, CURLOPT_TIMEOUT, $timeout * 1.5);\n            if ($useragent) {\n                curl_setopt($curl, CURLOPT_USERAGENT, $useragent);\n            }\n            if (!empty($headers)) {\n                curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n            }\n\n            foreach ($curl_options as $curl_option_key => $curl_option_value) {\n                curl_setopt($curl, $curl_option_key, $curl_option_value);\n            }\n\n            $response = curl_exec($curl);\n            $status_line = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n            if (curl_errno($curl)) {\n                $this->error = curl_error($curl);\n                $this->success = false;\n            }\n            curl_close($curl);\n\n            if ($response) {\n                list($header, $this->body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n                $this->headers = $this->parse_headers($header);\n                $this->status_code = $status_line;\n\n                if ($status_line >= 300 && $status_line < 400 && $redirects > 0 && isset($this->headers['location'])) {\n                    $this->redirects++;\n                    $location = $this->headers['location'];\n                    if (strpos($location, '/') === 0) {\n                        $parts = parse_url($url);\n                        $location = $parts['scheme'] . '://' . $parts['host'] . $location;\n                    }\n                    $new = new File($location, $timeout, $redirects - 1, $headers, $useragent, $force_fsockopen, $curl_options);\n                    $this->url = $new->url;\n                    $this->success = $new->success;\n                    $this->headers = $new->headers;\n                    $this->body = $new->body;\n                    $this->status_code = $new->status_code;\n                    $this->error = $new->error;\n                    if ($this->permanentUrlMutable) {\n                        $this->permanent_url = $new->permanent_url;\n                    }\n                }\n            }\n        }\n    }\n\n    public function parse_headers(string $header_text): array\n    {\n        $headers = [];\n        $header_lines = explode(\"\\r\\n\", $header_text);\n        foreach ($header_lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $key = strtolower(trim($key));\n                $value = trim($value);\n                if (isset($headers[$key])) {\n                    if (is_array($headers[$key])) {\n                        $headers[$key][] = $value;\n                    } else {\n                        $headers[$key] = [$headers[$key], $value];\n                    }\n                } else {\n                    $headers[$key] = $value;\n                }\n            }\n        }\n        return $headers;\n    }\n\n    public function get_body_content(): string\n    {\n        return $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return $this->permanent_url;\n    }\n}\n",
      "<?php\n\nnamespace SimplePie\\HTTP;\n\nclass File implements Response\n{\n    public $url;\n    public $useragent;\n    public $success = true;\n    public $headers = [];\n    public $body;\n    public $status_code;\n    public $redirects = 0;\n    public $error;\n    public $method;\n    public $permanent_url;\n    public $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        if ($useragent === null) {\n            $useragent = 'SimplePie/' . \\SimplePie::VERSION;\n        }\n\n        $this->permanent_url = $url;\n        $this->url = $url;\n        $this->useragent = $useragent;\n        $this->method = \\SimplePie::HTTP_METHOD_GET;\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_HEADER, 1);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, $timeout);\n        curl_setopt($curl, CURLOPT_TIMEOUT, $timeout * 1.25); // Give a little extra time\n        curl_setopt($curl, CURLOPT_USERAGENT, $useragent);\n        curl_setopt($curl, CURLOPT_FAILONERROR, 0);\n\n        if (!empty($headers)) {\n            $headers_tmp = [];\n            foreach ($headers as $key => $value) {\n                $headers_tmp[] = \"$key: $value\";\n            }\n            curl_setopt($curl, CURLOPT_HTTPHEADER, $headers_tmp);\n        }\n\n        if (!empty($curl_options)) {\n            foreach ($curl_options as $key => $value) {\n                curl_setopt($curl, $key, $value);\n            }\n        }\n\n        $response = curl_exec($curl);\n        $status_line = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        if (preg_match('/^(\\d{3})\\s+(.+)$/', $status_line, $status)) {\n            $this->status_code = (int) $status[1];\n        }\n\n        if ($response) {\n            $header_size = curl_getinfo($curl, CURLINFO_HEADER_SIZE);\n            $this->headers = $this->parse_headers(substr($response, 0, $header_size));\n            $this->body = substr($response, $header_size);\n\n            if ((in_array($this->status_code, [300, 301, 302, 303, 307]) || $this->status_code > 307 && $this->status_code < 400) && $redirects > 0 && isset($this->headers['location'])) {\n                $this->redirects++;\n                $location = $this->headers['location'];\n                if (strpos($location, '/') === 0) {\n                    $parts = parse_url($url);\n                    $location = $parts['scheme'] . '://' . $parts['host'] . $location;\n                }\n                $new = new File($location, $timeout, $redirects - 1, $headers, $useragent, $force_fsockopen, $curl_options);\n                $this->headers = $new->headers;\n                $this->body = $new->body;\n                $this->status_code = $new->status_code;\n                $this->redirects += $new->redirects;\n                $this->url = $new->url;\n                if ($new->permanentUrlMutable) {\n                    $this->permanent_url = $new->permanent_url;\n                }\n            }\n        } else {\n            $this->success = false;\n            $this->error = curl_error($curl);\n        }\n\n        curl_close($curl);\n    }\n\n    public function parse_headers(string $raw_headers): array\n    {\n        $headers = [];\n        $key = '';\n        foreach (explode(\"\\n\", $raw_headers) as $line) {\n            $line = trim($line);\n            if (preg_match('/^([^:]+):\\s+(.*)$/', $line, $match)) {\n                $key = strtolower(trim($match[1]));\n                $value = trim($match[2]);\n                if (isset($headers[$key])) {\n                    if (is_array($headers[$key])) {\n                        $headers[$key][] = $value;\n                    } else {\n                        $headers[$key] = [$headers[$key], $value];\n                    }\n                } else {\n                    $headers[$key] = $value;\n                }\n            } elseif ($line && $key) {\n                if (is_array($headers[$key])) {\n                    $headers[$key][] = $line;\n                } else {\n                    $headers[$key] .= ' ' . $line;\n                }\n            }\n        }\n        return $headers;\n    }\n\n\n    public function get_body_content(): string\n    {\n        return $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return $this->permanent_url;\n    }\n}\n",
      "<?php\n\nnamespace SimplePie\\HTTP;\n\nclass File implements Response\n{\n    public $url;\n    public $useragent;\n    public $success = true;\n    public $headers = [];\n    public $body;\n    public $status_code;\n    public $redirects = 0;\n    public $error;\n    public $method;\n    public $permanent_url;\n    public $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        $this->permanent_url = $url;\n        $this->url = $url;\n        $this->useragent = $useragent;\n        $this->method = SIMPLEPIE_HTTP_METHOD_GET;\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout * 1.25); // Give a little extra time for the request\n        if ($useragent) {\n            curl_setopt($ch, CURLOPT_USERAGENT, $useragent);\n        }\n        if (!empty($headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        foreach ($curl_options as $option => $value) {\n            curl_setopt($ch, $option, $value);\n        }\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch) === 28) {\n            $this->error = 'Operation timed out after ' . ($timeout * 1.25) . ' seconds with ' . $url;\n            $this->success = false;\n        } elseif ($response === false) {\n            $this->error = curl_error($ch);\n            $this->success = false;\n        } else {\n            $info = curl_getinfo($ch);\n            $this->status_code = $info['http_code'];\n            $this->url = $info['url'];\n\n            if ($this->permanentUrlMutable) {\n                $this->permanent_url = $this->url;\n            }\n\n            if (in_array($this->status_code, [300, 301, 302, 303, 307]) && $redirects > 0) {\n                $this->redirects++;\n                $location = trim(preg_match('/^Location:\\s*(.*)$/im', $response, $matches) ? $matches[1] : '');\n                curl_close($ch);\n                $new = new File($location, $timeout, $redirects - 1, $headers, $useragent, $force_fsockopen, $curl_options);\n                $this->headers = $new->headers;\n                $this->body = $new->body;\n                $this->status_code = $new->status_code;\n                $this->redirects += $new->redirects;\n                $this->error = $new->error;\n                $this->url = $new->url;\n                if ($this->permanentUrlMutable) {\n                    $this->permanent_url = $new->permanent_url;\n                }\n                $this->permanentUrlMutable = false;\n                return;\n            }\n\n            $header_size = $info['header_size'];\n            $this->headers = $this->parse_headers(substr($response, 0, $header_size));\n            $this->body = substr($response, $header_size);\n        }\n\n        curl_close($ch);\n    }\n\n    public function parse_headers(string $raw_headers): array\n    {\n        $headers = [];\n        $key = '';\n        foreach (explode(\"\\n\", $raw_headers) as $line) {\n            $line = trim($line);\n            if (preg_match('/^([^:]+):\\s+(.*)$/', $line, $matches)) {\n                $key = strtolower($matches[1]);\n                $headers[$key] = trim($matches[2]);\n            } elseif (strlen($line) > 0) {\n                if (isset($headers[$key])) {\n                    $headers[$key] .= ' ' . $line;\n                }\n            }\n        }\n        return $headers;\n    }\n\n    public function get_body_content(): string\n    {\n        return $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return $this->permanent_url;\n    }\n}\n",
      "<?php\n\nnamespace SimplePie\\HTTP;\n\nclass File implements Response\n{\n    public $url;\n    public $useragent;\n    public $success = true;\n    public $headers = [];\n    public $body;\n    public $status_code;\n    public $redirects = 0;\n    public $error;\n    public $method;\n    public $permanent_url;\n    public $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        if ($useragent === null) {\n            $useragent = 'SimplePie/' . \\SimplePie::VERSION;\n        }\n\n        $this->permanent_url = $url;\n        $this->url = $url;\n        $this->useragent = $useragent;\n        $this->method = \\SimplePie::HTTP_METHOD_GET;\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_HEADER, 1);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, $timeout);\n        curl_setopt($curl, CURLOPT_TIMEOUT, $timeout * 1.25); // 25% timeout margin\n        curl_setopt($curl, CURLOPT_USERAGENT, $useragent);\n        curl_setopt($curl, CURLOPT_FAILONERROR, 0);\n\n        if (!empty($headers)) {\n            curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        foreach ($curl_options as $curl_option_key => $curl_option_value) {\n            curl_setopt($curl, $curl_option_key, $curl_option_value);\n        }\n\n        $response = curl_exec($curl);\n        $status_line = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        if (preg_match('/^(\\d{3})/', $response, $status)) {\n            $this->status_code = (int) $status[1];\n        }\n\n        if (curl_errno($curl)) {\n            $this->error = curl_error($curl);\n            $this->success = false;\n        }\n\n        curl_close($curl);\n\n        $separator = \"\\r\\n\\r\\n\";\n        if (strpos($response, $separator) !== false) {\n            list($headers, $this->body) = explode($separator, $response, 2);\n            $this->headers = $this->parse_headers($headers);\n        }\n\n        if ($this->status_code === 301 || $this->status_code === 307) {\n            if ($redirects > 0 && isset($this->headers['location'])) {\n                $this->redirects++;\n                $location = $this->headers['location'];\n                $new = new File($location, $timeout, $redirects - 1, $headers, $useragent, $force_fsockopen, $curl_options);\n                $this->url = $new->url;\n                $this->success = $new->success;\n                $this->headers = $new->headers;\n                $this->body = $new->body;\n                $this->status_code = $new->status_code;\n                $this->error = $new->error;\n                if ($this->permanentUrlMutable) {\n                    $this->permanent_url = $new->permanent_url;\n                }\n            }\n        }\n    }\n\n    public function parse_headers(string $raw_headers): array\n    {\n        $headers = [];\n        $raw_headers = explode(\"\\r\\n\", $raw_headers);\n        foreach ($raw_headers as $header) {\n            if (strpos($header, ':') !== false) {\n                list($key, $value) = explode(':', $header, 2);\n                $key = strtolower(trim($key));\n                $value = trim($value);\n                if (isset($headers[$key])) {\n                    if (is_array($headers[$key])) {\n                        $headers[$key][] = $value;\n                    } else {\n                        $headers[$key] = [$headers[$key], $value];\n                    }\n                } else {\n                    $headers[$key] = $value;\n                }\n            }\n        }\n        return $headers;\n    }\n\n    public function get_body_content(): string\n    {\n        return $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return $this->permanent_url;\n    }\n}\n",
      "<?php\n\nnamespace SimplePie\\HTTP;\n\nclass File implements Response\n{\n    public $url;\n    public $useragent;\n    public $success = true;\n    public $headers = [];\n    public $body;\n    public $status_code;\n    public $redirects = 0;\n    public $error;\n    public $method;\n    public $permanent_url;\n    public $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        if ($useragent === null) {\n            $useragent = 'SimplePie/' . \\SimplePie::VERSION;\n        }\n\n        $this->permanent_url = $url;\n        $this->url = $url;\n        $this->useragent = $useragent;\n        $this->method = \\SimplePie::HTTP_METHOD_GET;\n\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_HEADER, 1);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, $timeout);\n        curl_setopt($curl, CURLOPT_TIMEOUT, $timeout * 1.25); // Give a little extra time for the request\n        curl_setopt($curl, CURLOPT_USERAGENT, $useragent);\n        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, false); // Handle redirects manually\n\n        if (!empty($headers)) {\n            curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        foreach ($curl_options as $key => $value) {\n            curl_setopt($curl, $key, $value);\n        }\n\n        $response = curl_exec($curl);\n        $status_line = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        $this->status_code = (int) $status_line;\n        $this->headers = [];\n\n        if ($response) {\n            list($header_block, $this->body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n            $header_lines = explode(\"\\r\\n\", $header_block);\n\n            foreach ($header_lines as $line) {\n                $parts = explode(':', $line, 2);\n                if (isset($parts[1])) {\n                    $this->headers[trim($parts[0])] = trim($parts[1]);\n                }\n            }\n\n            if (($this->status_code === 300 || $this->status_code === 301 || $this->status_code === 302 || $this->status_code === 303 || $this->status_code === 307 || $this->status_code === 308) && $redirects > 0 && isset($this->headers['Location'])) {\n                $this->redirects++;\n                $redirect_url = $this->headers['Location'];\n                if (parse_url($redirect_url, PHP_URL_SCHEME) === null) {\n                    $redirect_url = \\SimplePie\\Misc::absolutize_url($redirect_url, $url);\n                }\n                $new_request = new File($redirect_url, $timeout, $redirects - 1, $headers, $useragent, $force_fsockopen, $curl_options);\n                $this->url = $new_request->url;\n                $this->permanentUrlMutable = $new_request->permanentUrlMutable;\n                $this->success = $new_request->success;\n                $this->headers = $new_request->headers;\n                $this->body = $new_request->body;\n                $this->status_code = $new_request->status_code;\n                $this->redirects += $new_request->redirects;\n                $this->error = $new_request->error;\n                if ($this->permanentUrlMutable) {\n                    $this->permanent_url = $new_request->permanent_url;\n                }\n            }\n        } else {\n            $this->success = false;\n            $this->error = curl_error($curl);\n        }\n\n        curl_close($curl);\n    }\n\n    public function get_body_content(): string\n    {\n        return $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return $this->permanent_url;\n    }\n}\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Implement a PHP class that interacts with the Online-Convert API to handle file conversion jobs, including creating new conversion jobs and checking job statuses.\n\nClass Description: The elFinderEditorOnlineConvert class extends elFinderEditor and provides functionality to interact with the Online-Convert API. It handles initialization, API key validation, and processing conversion requests through HTTP calls using cURL.\n\nAttributes:\n- allowed: array - Defines the allowed actions for this editor (init and api)\n\nMethods:\n- enabled() -> bool - Checks if the editor is enabled by verifying the API key constant and that Online-Convert isn't disabled\n- init() -> array - Initializes the editor and checks for API key and cURL availability\n- api() -> array - Main method to handle API interactions with Online-Convert service. Processes both job creation and status checking\n\nMethod Details:\n1. enabled() -> bool\n   - Input: None\n   - Output: Returns true if the editor is enabled (API key defined and Online-Convert not disabled)\n\n2. init() -> array\n   - Input: None\n   - Output: Returns array with API availability status (checks for API key and cURL function)\n\n3. api() -> array\n   - Input: (Handled through class properties)\n     - category: string - Conversion category\n     - convert: string - Target conversion format\n     - options: string/array - Conversion options\n     - source: string - Source file URL\n     - filename: string - Name of the file\n     - mime: string - MIME type of the file\n     - jobid: string - Job ID for status checking\n   - Output: Returns array containing either:\n     - API response data\n     - Error information\n     - Empty array for non-API conversions",
    "Canonical_solution": "class elFinderEditorOnlineConvert extends elFinderEditor\n{\n    protected $allowed = array('init', 'api');\n\n    public function enabled()\n    {\n        return defined('ELFINDER_ONLINE_CONVERT_APIKEY') && ELFINDER_ONLINE_CONVERT_APIKEY && (!defined('ELFINDER_DISABLE_ONLINE_CONVERT') || !ELFINDER_DISABLE_ONLINE_CONVERT);\n    }\n\n    public function init()\n    {\n        return array('api' => defined('ELFINDER_ONLINE_CONVERT_APIKEY') && ELFINDER_ONLINE_CONVERT_APIKEY && function_exists('curl_init'));\n    }\n\n    public function api()\n    {\n        $endpoint = 'https://api2.online-convert.com/jobs';\n        $category = $this->argValue('category');\n        $convert = $this->argValue('convert');\n        $options = $this->argValue('options');\n        $source = $this->argValue('source');\n        $filename = $this->argValue('filename');\n        $mime = $this->argValue('mime');\n        $jobid = $this->argValue('jobid');\n        $string_method = '';\n        $options = array();\n        $nonApi = array('android', 'blackberry', 'dpg', 'ipad', 'iphone', 'ipod', 'nintendo-3ds', 'nintendo-ds', 'ps3', 'psp', 'wii', 'xbox');\n        if (in_array($convert, $nonApi)) {\n            return array('apires' => array());\n        }\n        $ch = null;\n        if ($convert && $source) {\n            $request = array(\n                'input' => array(array(\n                    'type' => 'remote',\n                    'source' => $source\n                )),\n                'conversion' => array(array(\n                    'target' => $convert\n                ))\n            );\n\n            if ($filename !== '') {\n                $request['input'][0]['filename'] = $filename;\n            }\n\n            if ($mime !== '') {\n                $request['input'][0]['content_type'] = $mime;\n            }\n\n            if ($category) {\n                $request['conversion'][0]['category'] = $category;\n            }\n\n            if ($options && $options !== 'null') {\n                $options = json_decode($options, true);\n            }\n            if (!is_array($options)) {\n                $options = array();\n            }\n            if ($options) {\n                $request['conversion'][0]['options'] = $options;\n            }\n\n            $ch = curl_init($endpoint);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($request));\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');\n            curl_setopt($ch, CURLOPT_HTTPHEADER, array(\n                'X-Oc-Api-Key: ' . ELFINDER_ONLINE_CONVERT_APIKEY,\n                'Content-Type: application/json',\n                'cache-control: no-cache'\n            ));\n        } else if ($jobid) {\n            $ch = curl_init($endpoint . '/' . $jobid);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'GET');\n            curl_setopt($ch, CURLOPT_HTTPHEADER, array(\n                'X-Oc-Api-Key: ' . ELFINDER_ONLINE_CONVERT_APIKEY,\n                'cache-control: no-cache'\n            ));\n        }\n\n        if ($ch) {\n            $response = curl_exec($ch);\n            $info = curl_getinfo($ch);\n            $error = curl_error($ch);\n            curl_close($ch);\n\n            if (!empty($error)) {\n                $res = array('error' => $error);\n            } else {\n                $data = json_decode($response, true);\n                if (isset($data['status']) && isset($data['status']['code']) && $data['status']['code'] === 'completed') {\n                    $session = $this->elfinder->getSession();\n                    $urlContentSaveIds = $session->get('urlContentSaveIds', array());\n                    $urlContentSaveIds['OnlineConvert-' . $data['id']] = true;\n                    $session->set('urlContentSaveIds', $urlContentSaveIds);\n                }\n                $res = array('apires' => $data);\n            }\n\n            return $res;\n        } else {\n            return array('error' => array('errCmdParams', 'editor.OnlineConvert.api'));\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nclass elFinderEditorOnlineConvert extends elFinderEditor\n{\n    protected $allowed = ['init', 'api'];\n\n    public function enabled()\n    {\n        return defined('ELFINDER_ONLINE_CONVERT_API_KEY') && ELFINDER_ONLINE_CONVERT_API_KEY && !defined('ELFINDER_DISABLE_ONLINE_CONVERT');\n    }\n\n    public function init()\n    {\n        if ($this->enabled()) {\n            return ['api' => true];\n        }\n        return [];\n    }\n\n    public function api()\n    {\n        if (!$this->enabled()) {\n            return [];\n        }\n\n        $apiKey = ELFINDER_ONLINE_CONVERT_API_KEY;\n        $category = $this->arg('category');\n        $convert = $this->arg('convert');\n        $options = $this->arg('options');\n        $source = $this->arg('source');\n        $filename = $this->arg('filename');\n        $mime = $this->arg('mime');\n        $jobId = $this->arg('jobid');\n\n        if ($jobId) {\n            $url = \"https://api2.online-convert.com/jobs/$jobId\";\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, [\"X-Oc-Api-Key: $apiKey\"]);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result ? $result : ['error' => 'API request failed.'];\n        } else if ($category && $convert && $source && $filename && $mime) {\n            $url = 'https://api2.online-convert.com/jobs';\n            $data = [\n                'category' => $category,\n                'convert_to' => $convert,\n                'input' => [\n                    'type' => 'remote',\n                    'source' => $source\n                ]\n            ];\n            if (is_array($options)) {\n                $data['options'] = $options;\n            }\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));\n            curl_setopt($ch, CURLOPT_HTTPHEADER, [\"X-Oc-Api-Key: $apiKey\", \"Content-Type: application/json\"]);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result ? $result : ['error' => 'API request failed.'];\n        }\n\n        return [];\n    }\n}\n?>\n",
      "<?php\nclass elFinderEditorOnlineConvert extends elFinderEditor\n{\n    protected $allowed = ['init', 'api'];\n\n    public function enabled()\n    {\n        return defined('ELFINDER_ONLINE_CONVERT_API_KEY') && ELFINDER_ONLINE_CONVERT_API_KEY && !defined('ELFINDER_DISABLE_ONLINE_CONVERT');\n    }\n\n    public function init()\n    {\n        if ($this->enabled()) {\n            return ['api' => true];\n        }\n        return [];\n    }\n\n    public function api()\n    {\n        if (!$this->enabled()) {\n            return [];\n        }\n\n        $apiKey = ELFINDER_ONLINE_CONVERT_API_KEY;\n        $url = 'https://api2.online-convert.com/jobs';\n\n        if (isset($_POST['jobid'])) {\n            $url .= '/' . $_POST['jobid'];\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, ['X-Oc-Api-Key: ' . $apiKey]);\n        } else {\n            $postData = [\n                'category' => $_POST['category'],\n                'convert_to' => $_POST['convert'],\n                'options' => isset($_POST['options']) ? json_decode($_POST['options'], true) : [],\n            ];\n            if (isset($_POST['source'])) {\n                $postData['source'] = $_POST['source'];\n                $postData['filename'] = $_POST['filename'];\n            } else {\n                $postData['file'] = new CURLFile($_POST['upload']['tmp_name'], $_POST['mime'], $_POST['filename']);\n            }\n\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, ['X-Oc-Api-Key: ' . $apiKey]);\n        }\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($response === false) {\n            return ['error' => 'cURL Error: ' . curl_error($ch)];\n        }\n\n        if ($httpCode >= 400) {\n            return ['error' => 'API Error: ' . $response, 'code' => $httpCode];\n        }\n\n        return json_decode($response, true);\n    }\n}\n",
      "<?php\nclass elFinderEditorOnlineConvert extends elFinderEditor\n{\n    protected $allowed = ['init', 'api'];\n\n    public function enabled()\n    {\n        return defined('ELFINDER_ONLINE_CONVERT_API_KEY') && ELFINDER_ONLINE_CONVERT_API_KEY && !defined('ELFINDER_DISABLE_ONLINE_CONVERT');\n    }\n\n    public function init()\n    {\n        if ($this->enabled()) {\n            return ['api' => true];\n        }\n        return [];\n    }\n\n    public function api()\n    {\n        if (!$this->enabled()) {\n            return [];\n        }\n\n        $apiKey = ELFINDER_ONLINE_CONVERT_API_KEY;\n        $category = $this->arg('category');\n        $convert = $this->arg('convert');\n        $options = $this->arg('options');\n        $source = $this->arg('source');\n        $filename = $this->arg('filename');\n        $mime = $this->arg('mime');\n        $jobId = $this->arg('jobid');\n\n        if ($jobId) {\n            $url = 'https://api2.online-convert.com/jobs/' . $jobId;\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, ['X-Oc-Api-Key: ' . $apiKey]);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result ? $result : ['error' => 'API request failed.'];\n        } else if ($category && $convert && $source && $filename && $mime) {\n            $url = 'https://api2.online-convert.com/jobs';\n            $data = [\n                'category' => $category,\n                'convert_to' => $convert,\n                'input' => [\n                    'type' => 'remote',\n                    'source' => $source\n                ]\n            ];\n            if (is_array($options)) {\n                $data['options'] = $options;\n            }\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));\n            curl_setopt($ch, CURLOPT_HTTPHEADER, ['X-Oc-Api-Key: ' . $apiKey, 'Content-Type: application/json']);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result ? $result : ['error' => 'API request failed.'];\n        }\n\n        return [];\n    }\n}\n?>\n",
      "<?php\nclass elFinderEditorOnlineConvert extends elFinderEditor\n{\n    protected $allowed = ['init', 'api'];\n\n    public function enabled()\n    {\n        return defined('ELFINDER_ONLINE_CONVERT_API_KEY') && ELFINDER_ONLINE_CONVERT_API_KEY && !defined('ELFINDER_DISABLE_ONLINE_CONVERT');\n    }\n\n    public function init()\n    {\n        if ($this->enabled()) {\n            return ['api' => true];\n        }\n        return [];\n    }\n\n    public function api()\n    {\n        if (!$this->enabled()) {\n            return [];\n        }\n\n        $apiKey = ELFINDER_ONLINE_CONVERT_API_KEY;\n        $category = $this->arg('category');\n        $convert = $this->arg('convert');\n        $options = $this->arg('options');\n        $source = $this->arg('source');\n        $filename = $this->arg('filename');\n        $mime = $this->arg('mime');\n        $jobId = $this->arg('jobid');\n\n        if ($jobId) {\n            $url = 'https://api2.online-convert.com/jobs/' . $jobId;\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, ['X-Oc-Api-Key: ' . $apiKey]);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result ? $result : ['error' => 'API request failed'];\n        } else if ($category && $convert && $source && $filename && $mime) {\n            $url = 'https://api2.online-convert.com/jobs';\n            $data = [\n                'category' => $category,\n                'convert_to' => $convert,\n                'input' => [\n                    'type' => 'remote',\n                    'source' => $source\n                ]\n            ];\n            if (is_array($options)) {\n                $data['options'] = $options;\n            }\n\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));\n            curl_setopt($ch, CURLOPT_HTTPHEADER, ['X-Oc-Api-Key: ' . $apiKey, 'Content-Type: application/json']);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result ? $result : ['error' => 'API request failed'];\n        }\n\n        return [];\n    }\n}\n",
      "<?php\nclass elFinderEditorOnlineConvert extends elFinderEditor\n{\n    protected $allowed = ['init', 'api'];\n\n    public function enabled()\n    {\n        return defined('ELFINDER_ONLINE_CONVERT_API_KEY') && ELFINDER_ONLINE_CONVERT_API_KEY && !defined('ELFINDER_DISABLE_ONLINE_CONVERT');\n    }\n\n    public function init()\n    {\n        if ($this->enabled()) {\n            return ['api' => true];\n        }\n        return [];\n    }\n\n    public function api()\n    {\n        if (!$this->enabled()) {\n            return [];\n        }\n\n        $apiKey = ELFINDER_ONLINE_CONVERT_API_KEY;\n        $category = $this->arg('category');\n        $convert = $this->arg('convert');\n        $options = $this->arg('options');\n        $source = $this->arg('source');\n        $filename = $this->arg('filename');\n        $mime = $this->arg('mime');\n        $jobId = $this->arg('jobid');\n\n        if ($jobId) {\n            $url = \"https://api2.online-convert.com/jobs/$jobId\";\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, [\"X-Oc-Api-Key: $apiKey\"]);\n            $result = curl_exec($ch);\n            curl_close($ch);\n            return json_decode($result, true);\n        } else if ($category && $convert && $source && $filename && $mime) {\n            $url = 'https://api2.online-convert.com/jobs';\n            $data = [\n                'category' => $category,\n                'convert_to' => $convert,\n                'input' => [\n                    'type' => 'remote',\n                    'source' => $source\n                ],\n                'filename' => $filename\n            ];\n            if (is_array($options)) {\n                $data['options'] = $options;\n            }\n\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));\n            curl_setopt($ch, CURLOPT_HTTPHEADER, [\n                \"X-Oc-Api-Key: $apiKey\",\n                'Content-Type: application/json'\n            ]);\n            $result = curl_exec($ch);\n            curl_close($ch);\n            return json_decode($result, true);\n        }\n\n        return [];\n    }\n}\n?>\n",
      "<?php\nclass elFinderEditorOnlineConvert extends elFinderEditor\n{\n    protected $allowed = ['init', 'api'];\n\n    public function enabled()\n    {\n        return defined('ELFINDER_ONLINE_CONVERT_API_KEY') && ELFINDER_ONLINE_CONVERT_API_KEY && !defined('ELFINDER_DISABLE_ONLINE_CONVERT');\n    }\n\n    public function init()\n    {\n        if ($this->enabled()) {\n            return ['api' => true];\n        }\n        return [];\n    }\n\n    public function api()\n    {\n        if (!$this->enabled()) {\n            return [];\n        }\n\n        $apiKey = ELFINDER_ONLINE_CONVERT_API_KEY;\n        $category = $this->arg('category');\n        $convert = $this->arg('convert');\n        $options = $this->arg('options');\n        $source = $this->arg('source');\n        $filename = $this->arg('filename');\n        $mime = $this->arg('mime');\n        $jobId = $this->arg('jobid');\n\n        if ($jobId) {\n            $url = \"https://api2.online-convert.com/jobs/$jobId\";\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, [\"X-Oc-Api-Key: $apiKey\"]);\n            $result = curl_exec($ch);\n            curl_close($ch);\n            return json_decode($result, true);\n        } else if ($category && $convert && $source && $filename && $mime) {\n            $url = 'https://api2.online-convert.com/jobs';\n            $data = [\n                'category' => $category,\n                'convert_to' => $convert,\n                'input' => [\n                    'type' => 'remote',\n                    'source' => $source\n                ]\n            ];\n            if (is_array($options)) {\n                $data['options'] = $options;\n            }\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));\n            curl_setopt($ch, CURLOPT_HTTPHEADER, [\"X-Oc-Api-Key: $apiKey\", 'Content-Type: application/json']);\n            $result = curl_exec($ch);\n            curl_close($ch);\n            return json_decode($result, true);\n        }\n\n        return [];\n    }\n}\n?>\n",
      "<?php\nclass elFinderEditorOnlineConvert extends elFinderEditor\n{\n    protected $allowed = ['init', 'api'];\n\n    public function enabled()\n    {\n        return defined('ELFINDER_ONLINE_CONVERT_API_KEY') && ELFINDER_ONLINE_CONVERT_API_KEY && !defined('ELFINDER_DISABLE_ONLINE_CONVERT');\n    }\n\n    public function init()\n    {\n        if ($this->enabled()) {\n            return ['api' => true];\n        }\n        return [];\n    }\n\n    public function api()\n    {\n        if (!$this->enabled()) {\n            return [];\n        }\n\n        $apiKey = ELFINDER_ONLINE_CONVERT_API_KEY;\n        $category = $this->arg('category');\n        $convert = $this->arg('convert');\n        $options = $this->arg('options');\n        $source = $this->arg('source');\n        $filename = $this->arg('filename');\n        $mime = $this->arg('mime');\n        $jobId = $this->arg('jobid');\n\n        if ($jobId) {\n            $url = 'https://api2.online-convert.com/jobs/' . $jobId;\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, ['X-Oc-Api-Key: ' . $apiKey]);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result ? $result : ['error' => 'API request failed'];\n        } else if ($category && $convert && $source && $filename && $mime) {\n            $url = 'https://api2.online-convert.com/jobs';\n            $data = [\n                'category' => $category,\n                'convert_to' => $convert,\n                'input' => [\n                    'type' => 'remote',\n                    'source' => $source\n                ]\n            ];\n            if (is_array($options)) {\n                $data['options'] = $options;\n            }\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));\n            curl_setopt($ch, CURLOPT_HTTPHEADER, ['X-Oc-Api-Key: ' . $apiKey, 'Content-Type: application/json']);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result ? $result : ['error' => 'API request failed'];\n        }\n\n        return [];\n    }\n}\n?>\n",
      "<?php\nclass elFinderEditorOnlineConvert extends elFinderEditor\n{\n    protected $allowed = ['init', 'api'];\n\n    public function enabled()\n    {\n        return defined('ELFINDER_ONLINE_CONVERT_API_KEY') && ELFINDER_ONLINE_CONVERT_API_KEY && !defined('ELFINDER_DISABLE_ONLINE_CONVERT');\n    }\n\n    public function init()\n    {\n        if ($this->enabled()) {\n            return ['api' => true];\n        }\n        return [];\n    }\n\n    public function api()\n    {\n        if (!$this->enabled()) {\n            return [];\n        }\n\n        $apiKey = ELFINDER_ONLINE_CONVERT_API_KEY;\n        $category = $this->arg('category');\n        $convert = $this->arg('convert');\n        $options = $this->arg('options');\n        $source = $this->arg('source');\n        $filename = $this->arg('filename');\n        $mime = $this->arg('mime');\n        $jobId = $this->arg('jobid');\n\n        if ($jobId) {\n            $url = \"https://api2.online-convert.com/jobs/$jobId\";\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, [\"X-Oc-Api-Key: $apiKey\"]);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result ? $result : ['error' => 'API request failed.'];\n        } else if ($category && $convert && $source && $filename && $mime) {\n            $url = 'https://api2.online-convert.com/jobs';\n            $data = [\n                'category' => $category,\n                'convert_to' => $convert,\n                'input' => [\n                    'type' => 'remote',\n                    'source' => $source\n                ]\n            ];\n            if (is_array($options)) {\n                $data['options'] = $options;\n            }\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));\n            curl_setopt($ch, CURLOPT_HTTPHEADER, [\"X-Oc-Api-Key: $apiKey\", 'Content-Type: application/json']);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result ? $result : ['error' => 'API request failed.'];\n        }\n\n        return [];\n    }\n}\n?>\n",
      "<?php\nclass elFinderEditorOnlineConvert extends elFinderEditor\n{\n    protected $allowed = ['init', 'api'];\n\n    public function enabled()\n    {\n        return defined('ELFINDER_ONLINE_CONVERT_API_KEY') && ELFINDER_ONLINE_CONVERT_API_KEY && !defined('ELFINDER_DISABLE_ONLINE_CONVERT');\n    }\n\n    public function init()\n    {\n        if (!defined('ELFINDER_ONLINE_CONVERT_API_KEY') || !ELFINDER_ONLINE_CONVERT_API_KEY) {\n            return ['error' => 'Missing API Key'];\n        }\n        if (!function_exists('curl_init')) {\n            return ['error' => 'cURL is not available'];\n        }\n        return ['api' => true];\n    }\n\n    public function api()\n    {\n        if (!empty($this->arg('jobid'))) {\n            $url = 'https://api2.online-convert.com/jobs/' . $this->arg('jobid');\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, ['X-Oc-Api-Key: ' . ELFINDER_ONLINE_CONVERT_API_KEY]);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result;\n        } else if ($this->arg('category') && $this->arg('convert') && $this->arg('source') && $this->arg('filename') && $this->arg('mime')) {\n            $url = 'https://api2.online-convert.com/jobs';\n            $data = [\n                'input' => [\n                    'type' => 'remote',\n                    'source' => $this->arg('source')\n                ],\n                'conversion' => [\n                    'category' => $this->arg('category'),\n                    'target' => $this->arg('convert'),\n                    'options' => $this->arg('options', [])\n                ]\n            ];\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));\n            curl_setopt($ch, CURLOPT_HTTPHEADER, ['X-Oc-Api-Key: ' . ELFINDER_ONLINE_CONVERT_API_KEY, 'Content-Type: application/json']);\n            $result = json_decode(curl_exec($ch), true);\n            curl_close($ch);\n            return $result;\n        }\n        return [];\n    }\n}\n?>\n",
      "<?php\nclass elFinderEditorOnlineConvert extends elFinderEditor {\n    protected $allowed = array('init', 'api');\n\n    public function enabled() {\n        return defined('ELFINDER_ONLINE_CONVERT_API_KEY') && ELFINDER_ONLINE_CONVERT_API_KEY && !defined('ELFINDER_DISABLE_ONLINE_CONVERT');\n    }\n\n    public function init() {\n        if ($this->enabled()) {\n            return array('api' => true);\n        }\n        return array();\n    }\n\n    public function api() {\n        if (!$this->enabled()) {\n            return array();\n        }\n\n        $apiKey = ELFINDER_ONLINE_CONVERT_API_KEY;\n        $category = $this->arg('category');\n        $convert = $this->arg('convert');\n        $options = $this->arg('options');\n        $source = $this->arg('source');\n        $filename = $this->arg('filename');\n        $mime = $this->arg('mime');\n        $jobId = $this->arg('jobid');\n\n        if ($jobId) {\n            $url = 'https://api2.online-convert.com/jobs/' . $jobId;\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_HTTPHEADER, array('X-Oc-Api-Key: ' . $apiKey));\n            $result = curl_exec($ch);\n            curl_close($ch);\n            return json_decode($result, true);\n        } else if ($category && $convert && $source && $filename && $mime) {\n            $url = 'https://api2.online-convert.com/jobs';\n            $data = array(\n                'category' => $category,\n                'convert_to' => $convert,\n                'input' => array(\n                    array(\n                        'type' => 'remote',\n                        'source' => $source\n                    )\n                )\n            );\n\n            if (is_array($options)) {\n                $data['options'] = $options;\n            }\n\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));\n            curl_setopt($ch, CURLOPT_HTTPHEADER, array(\n                'X-Oc-Api-Key: ' . $apiKey,\n                'Content-Type: application/json'\n            ));\n\n            $result = curl_exec($ch);\n            curl_close($ch);\n            return json_decode($result, true);\n        }\n\n        return array();\n    }\n}\n?>\n"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Implement a PHP class for interacting with Google Drive API using OAuth 2.0 authentication and cURL for HTTP requests.\n\nClass Description: The Googledrive class provides functionality to authenticate with Google Drive API and make authorized API requests. It handles OAuth 2.0 token management and provides a method for making API calls.\n\nAttributes:\n\naccess_token: string - The OAuth 2.0 access token for API authentication\ndisktag: string - Identifier for the disk configuration\nclient_id: string - Google API client ID\nclient_secret: string - Google API client secret\nredirect_uri: string - OAuth redirect URI\noauth_url: string - Google OAuth endpoint URL\napi_url: string - Google Drive API endpoint URL\nscope: string - API access scope\ndriveId: string - Google Drive ID\nerror: array - Stores error information if any occurs\n\nMethods:\n\n__construct: [Name](tag: string) -> void - Constructor that initializes the class with configuration values\nGDAPI: [Name](method: string, url: string, data: string = '') -> array - Makes an authenticated API request to Google Drive\nget_access_token: [Name](refresh_token: string) -> bool - Retrieves and manages access tokens using refresh tokens",
    "Canonical_solution": "class Googledrive {\n    protected $access_token;\n    protected $disktag;\n    protected $client_id;\n    protected $client_secret;\n    protected $redirect_uri;\n    protected $oauth_url;\n    protected $api_url;\n    protected $scope;\n    protected $driveId;\n    protected $error;\n\n    public function __construct($tag) {\n        $this->disktag = $tag;\n        $this->redirect_uri = 'https://scfonedrive.github.io';\n        if (getConfig('client_id', $tag) && getConfig('client_secret', $tag)) {\n            $this->client_id = getConfig('client_id', $tag);\n            $this->client_secret = getConfig('client_secret', $tag);\n        } else {\n            $this->client_id = '106151778902-ajieetaab5ondhbvia97n4tr5k0cg8eo.apps.googleusercontent.com';\n            $this->client_secret = 'LlCV-rQClzYIKCEqiVddh68G';\n        }\n        $this->oauth_url = 'https://accounts.google.com/o/oauth2/';\n        $this->api_url = 'https://www.googleapis.com/drive/v3';\n        $this->scope = 'https://www.googleapis.com/auth/drive';\n        $this->client_secret = urlencode($this->client_secret);\n        $this->scope = urlencode($this->scope);\n        $this->driveId = getConfig('driveId', $tag);\n        $res = $this->get_access_token(getConfig('refresh_token', $tag));\n    }\n\n    protected function GDAPI($method, $url, $data = '') {\n        $headers['Authorization'] = 'Bearer ' . $this->access_token;\n        if (!isset($headers['Accept'])) $headers['Accept'] = '*/*';\n        $headers['Content-Type'] = 'application/json';\n        $sendHeaders = array();\n        foreach ($headers as $headerName => $headerVal) {\n            $sendHeaders[] = $headerName . ': ' . $headerVal;\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 0);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $sendHeaders);\n        $response['body'] = curl_exec($ch);\n        $response['stat'] = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        return $response;\n    }\n\n    protected function get_access_token($refresh_token) {\n        if (!$refresh_token) {\n            $tmp['stat'] = 0;\n            $tmp['body'] = 'No refresh_token';\n            $this->error = $tmp;\n            return false;\n        }\n        if (!($this->access_token = getcache('access_token', $this->disktag))) {\n            $p = 0;\n            $data['client_id'] = $this->client_id;\n            $data['client_secret'] = $this->client_secret;\n            $data['grant_type'] = 'refresh_token';\n            $data['refresh_token'] = $refresh_token;\n            while ($response['stat'] == 0 && $p < 3) {\n                $response = curl('POST', $this->oauth_url . 'token', json_encode($data));\n                $p++;\n            }\n            if ($response['stat'] == 200) $ret = json_decode($response['body'], true);\n            if (!isset($ret['access_token'])) {\n                error_log1($this->oauth_url . 'token' . '?client_id=' . $this->client_id . '&client_secret=' . $this->client_secret . '&grant_type=refresh_token&refresh_token=' . substr($refresh_token, 0, 20) . '******' . substr($refresh_token, -20));\n                error_log1('failed to get [' . $this->disktag . '] access_token. response: ' . $response['body']);\n                $response['body'] = json_encode(json_decode($response['body']), JSON_PRETTY_PRINT);\n                $response['body'] .= '\\nfailed to get [' . $this->disktag . '] access_token.';\n                $this->error = $response;\n                return false;\n            }\n            $tmp = $ret;\n            $tmp['access_token'] = substr($tmp['access_token'], 0, 10) . '******';\n            error_log1('[' . $this->disktag . '] Get access token:' . json_encode($tmp, JSON_PRETTY_PRINT));\n            $this->access_token = $ret['access_token'];\n            savecache('access_token', $this->access_token, $this->disktag, $ret['expires_in'] - 300);\n            return true;\n        }\n        return true;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Googledrive {\n\n    public $access_token;\n    public $disktag;\n    public $client_id;\n    public $client_secret;\n    public $redirect_uri;\n    public $oauth_url;\n    public $api_url;\n    public $scope;\n    public $driveId;\n    public $error;\n\n    public function __construct($tag) {\n        $this->disktag = $tag;\n        $this->client_id = ''; // Set your client ID\n        $this->client_secret = ''; // Set your client secret\n        $this->redirect_uri = ''; // Set your redirect URI\n        $this->oauth_url = 'https://accounts.google.com/o/oauth2/token';\n        $this->api_url = 'https://www.googleapis.com/drive/v3';\n        $this->scope = 'https://www.googleapis.com/auth/drive';\n        $this->driveId = ''; // Set your Google Drive ID if needed\n    }\n\n    public function GDAPI($method, $url, $data = '') {\n        $curl = curl_init();\n        $headers = [\n            'Authorization: Bearer ' . $this->access_token,\n            'Content-Type: application/json'\n        ];\n        $options = [\n            CURLOPT_URL => $this->api_url . $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_CUSTOMREQUEST => $method\n        ];\n\n        if ($data) {\n            $options[CURLOPT_POSTFIELDS] = $data;\n        }\n\n        curl_setopt_array($curl, $options);\n        $response = curl_exec($curl);\n        $info = curl_getinfo($curl);\n        curl_close($curl);\n\n        if ($info['http_code'] >= 200 && $info['http_code'] < 300) {\n            return json_decode($response, true);\n        } else {\n            $this->error = ['code' => $info['http_code'], 'message' => $response];\n            return false;\n        }\n    }\n\n    public function get_access_token($refresh_token) {\n        $data = [\n            'grant_type' => 'refresh_token',\n            'refresh_token' => $refresh_token,\n            'client_id' => $this->client_id,\n            'client_secret' => $this->client_secret\n        ];\n\n        $curl = curl_init($this->oauth_url);\n        curl_setopt_array($curl, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_POST => true,\n            CURLOPT_POSTFIELDS => http_build_query($data)\n        ]);\n\n        $response = curl_exec($curl);\n        curl_close($curl);\n        $token = json_decode($response, true);\n\n        if (isset($token['access_token'])) {\n            $this->access_token = $token['access_token'];\n            return true;\n        } else {\n            $this->error = $token;\n            return false;\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass Googledrive {\n\n    public $access_token;\n    public $disktag;\n    public $client_id;\n    public $client_secret;\n    public $redirect_uri;\n    public $oauth_url;\n    public $api_url;\n    public $scope;\n    public $driveId;\n    public $error;\n\n    public function __construct($tag) {\n        $this->disktag = $tag;\n        $this->client_id = ''; // Set your client ID\n        $this->client_secret = ''; // Set your client secret\n        $this->redirect_uri = ''; // Set your redirect URI\n        $this->oauth_url = 'https://accounts.google.com/o/oauth2/token';\n        $this->api_url = 'https://www.googleapis.com/drive/v3';\n        $this->scope = 'https://www.googleapis.com/auth/drive';\n        // Optionally set driveId if needed\n    }\n\n    public function GDAPI($method, $url, $data = '') {\n        $curl = curl_init();\n        $headers = [\n            'Authorization: Bearer ' . $this->access_token,\n            'Content-Type: application/json'\n        ];\n        $options = [\n            CURLOPT_URL => $this->api_url . $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_CUSTOMREQUEST => $method\n        ];\n        if ($data) {\n            $options[CURLOPT_POSTFIELDS] = $data;\n        }\n        curl_setopt_array($curl, $options);\n        $response = curl_exec($curl);\n        $info = curl_getinfo($curl);\n        curl_close($curl);\n        $result = json_decode($response, true);\n        if (isset($result['error'])) {\n            $this->error = $result['error'];\n            return false;\n        }\n        return ['info' => $info, 'data' => $result];\n    }\n\n    public function get_access_token($refresh_token) {\n        $data = [\n            'grant_type' => 'refresh_token',\n            'refresh_token' => $refresh_token,\n            'client_id' => $this->client_id,\n            'client_secret' => $this->client_secret\n        ];\n        $curl = curl_init($this->oauth_url);\n        curl_setopt_array($curl, [\n            CURLOPT_POST => true,\n            CURLOPT_POSTFIELDS => http_build_query($data),\n            CURLOPT_RETURNTRANSFER => true\n        ]);\n        $response = curl_exec($curl);\n        curl_close($curl);\n        $token = json_decode($response, true);\n        if (isset($token['access_token'])) {\n            $this->access_token = $token['access_token'];\n            return true;\n        } else {\n            $this->error = $token;\n            return false;\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass Googledrive {\n\n    public $access_token;\n    public $disktag;\n    public $client_id;\n    public $client_secret;\n    public $redirect_uri;\n    public $oauth_url;\n    public $api_url;\n    public $scope;\n    public $driveId;\n    public $error;\n\n    public function __construct($tag) {\n        $this->disktag = $tag;\n        $this->client_id = ''; // Set your client ID\n        $this->client_secret = ''; // Set your client secret\n        $this->redirect_uri = ''; // Set your redirect URI\n        $this->oauth_url = 'https://accounts.google.com/o/oauth2/token';\n        $this->api_url = 'https://www.googleapis.com/drive/v3';\n        $this->scope = 'https://www.googleapis.com/auth/drive';\n        $this->driveId = ''; // Set your Drive ID if needed\n    }\n\n    public function GDAPI($method, $url, $data = '') {\n        $curl = curl_init();\n        $headers = [\n            'Authorization: Bearer ' . $this->access_token,\n            'Content-Type: application/json'\n        ];\n        $options = [\n            CURLOPT_URL => $this->api_url . $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_CUSTOMREQUEST => $method\n        ];\n        if ($data) {\n            $options[CURLOPT_POSTFIELDS] = $data;\n        }\n        curl_setopt_array($curl, $options);\n        $response = curl_exec($curl);\n        $info = curl_getinfo($curl);\n        curl_close($curl);\n        $result = json_decode($response, true);\n        if (isset($result['error'])) {\n            $this->error = $result['error'];\n            return false;\n        }\n        return ['info' => $info, 'data' => $result];\n    }\n\n    public function get_access_token($refresh_token) {\n        $data = [\n            'grant_type' => 'refresh_token',\n            'refresh_token' => $refresh_token,\n            'client_id' => $this->client_id,\n            'client_secret' => $this->client_secret\n        ];\n        $curl = curl_init($this->oauth_url);\n        curl_setopt_array($curl, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_POST => true,\n            CURLOPT_POSTFIELDS => http_build_query($data)\n        ]);\n        $response = curl_exec($curl);\n        curl_close($curl);\n        $token = json_decode($response, true);\n        if (isset($token['access_token'])) {\n            $this->access_token = $token['access_token'];\n            return true;\n        } else {\n            $this->error = $token;\n            return false;\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass Googledrive {\n\n    public $access_token;\n    public $disktag;\n    public $client_id;\n    public $client_secret;\n    public $redirect_uri;\n    public $oauth_url;\n    public $api_url;\n    public $scope;\n    public $driveId;\n    public $error;\n\n    public function __construct($tag) {\n        $this->disktag = $tag;\n        $this->client_id = ''; // Your Google API client ID\n        $this->client_secret = ''; // Your Google API client secret\n        $this->redirect_uri = ''; // Your OAuth redirect URI\n        $this->oauth_url = 'https://accounts.google.com/o/oauth2/token';\n        $this->api_url = 'https://www.googleapis.com/drive/v3';\n        $this->scope = 'https://www.googleapis.com/auth/drive';\n        // Implement logic to retrieve access token and driveId based on $tag (e.g., from a database)\n        // Example:\n        // $this->access_token = get_access_token_from_database($tag);\n        // $this->driveId = get_drive_id_from_database($tag);\n    }\n\n    public function GDAPI($method, $url, $data = '') {\n        $curl = curl_init();\n        $headers = [\n            'Authorization: Bearer ' . $this->access_token,\n            'Content-Type: application/json'\n        ];\n        $options = [\n            CURLOPT_URL => $this->api_url . $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_CUSTOMREQUEST => $method\n        ];\n        if ($data) {\n            $options[CURLOPT_POSTFIELDS] = $data;\n        }\n        curl_setopt_array($curl, $options);\n        $response = curl_exec($curl);\n        $info = curl_getinfo($curl);\n        curl_close($curl);\n        if ($info['http_code'] >= 200 && $info['http_code'] < 300) {\n            return json_decode($response, true);\n        } else {\n            $this->error = ['code' => $info['http_code'], 'message' => $response];\n            return false;\n        }\n    }\n\n    public function get_access_token($refresh_token) {\n        // Implement logic to refresh access token using the refresh token\n        // Example using cURL:\n        // $data = [\n        //     'client_id' => $this->client_id,\n        //     'client_secret' => $this->client_secret,\n        //     'refresh_token' => $refresh_token,\n        //     'grant_type' => 'refresh_token'\n        // ];\n        // $response = // Make cURL request to $this->oauth_url with $data\n        // if (// Request successful) {\n        //     $this->access_token = $response['access_token'];\n        //     return true;\n        // } else {\n        //     $this->error = // Set error information\n        //     return false;\n        // }\n    }\n}\n\n?>",
      "<?php\n\nclass Googledrive {\n\n    public $access_token;\n    public $disktag;\n    public $client_id;\n    public $client_secret;\n    public $redirect_uri;\n    public $oauth_url;\n    public $api_url;\n    public $scope;\n    public $driveId;\n    public $error;\n\n    public function __construct($tag) {\n        $this->disktag = $tag;\n        $this->client_id = ''; // Your Google API client ID\n        $this->client_secret = ''; // Your Google API client secret\n        $this->redirect_uri = ''; // Your OAuth redirect URI\n        $this->oauth_url = 'https://oauth2.googleapis.com/token';\n        $this->api_url = 'https://www.googleapis.com/drive/v3';\n        $this->scope = 'https://www.googleapis.com/auth/drive';\n        $this->driveId = ''; // Your Google Drive ID if needed\n    }\n\n    public function GDAPI($method, $url, $data = '') {\n        $curl = curl_init();\n        $headers = [\n            'Authorization: Bearer ' . $this->access_token,\n            'Content-Type: application/json'\n        ];\n        $options = [\n            CURLOPT_URL => $this->api_url . $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_CUSTOMREQUEST => $method\n        ];\n\n        if ($data) {\n            $options[CURLOPT_POSTFIELDS] = $data;\n        }\n\n        curl_setopt_array($curl, $options);\n        $response = curl_exec($curl);\n        $info = curl_getinfo($curl);\n        curl_close($curl);\n\n        if ($info['http_code'] >= 200 && $info['http_code'] < 300) {\n            return json_decode($response, true);\n        } else {\n            $this->error = ['code' => $info['http_code'], 'message' => $response];\n            return false;\n        }\n    }\n\n    public function get_access_token($refresh_token) {\n        $data = [\n            'client_id' => $this->client_id,\n            'client_secret' => $this->client_secret,\n            'refresh_token' => $refresh_token,\n            'grant_type' => 'refresh_token'\n        ];\n\n        $curl = curl_init($this->oauth_url);\n        curl_setopt($curl, CURLOPT_POST, true);\n        curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($data));\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($curl);\n        curl_close($curl);\n\n        $tokenData = json_decode($response, true);\n\n        if (isset($tokenData['access_token'])) {\n            $this->access_token = $tokenData['access_token'];\n            return true;\n        } else {\n            $this->error = $tokenData;\n            return false;\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass Googledrive {\n\n    public $access_token;\n    public $disktag;\n    public $client_id;\n    public $client_secret;\n    public $redirect_uri;\n    public $oauth_url;\n    public $api_url;\n    public $scope;\n    public $driveId;\n    public $error;\n\n    public function __construct($tag) {\n        $this->disktag = $tag;\n        $this->client_id = ''; // Your Google API client ID\n        $this->client_secret = ''; // Your Google API client secret\n        $this->redirect_uri = ''; // Your OAuth redirect URI\n        $this->oauth_url = 'https://accounts.google.com/o/oauth2/token';\n        $this->api_url = 'https://www.googleapis.com/drive/v3';\n        $this->scope = 'https://www.googleapis.com/auth/drive';\n        $this->driveId = ''; // Your Google Drive ID\n        $this->error = [];\n    }\n\n    public function GDAPI($method, $url, $data = '') {\n        $curl = curl_init();\n        $headers = [\n            'Authorization: Bearer ' . $this->access_token,\n            'Content-Type: application/json'\n        ];\n        $options = [\n            CURLOPT_URL => $this->api_url . $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_CUSTOMREQUEST => $method\n        ];\n\n        if ($data) {\n            $options[CURLOPT_POSTFIELDS] = $data;\n        }\n\n        curl_setopt_array($curl, $options);\n        $response = curl_exec($curl);\n        $httpcode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($curl)) {\n            $this->error = ['error' => curl_error($curl)];\n            return false; // Or handle the error as needed\n        }\n\n        curl_close($curl);\n        return ['httpcode' => $httpcode, 'response' => json_decode($response, true)];\n    }\n\n    public function get_access_token($refresh_token) {\n        // Implementation for retrieving access token using refresh token\n        // This would involve making a request to the OAuth endpoint\n        // and handling the response to get the access token\n        // ...\n        return true; // Or false if token retrieval fails\n    }\n}\n\n?>",
      "<?php\n\nclass Googledrive {\n\n    public $access_token;\n    public $disktag;\n    public $client_id;\n    public $client_secret;\n    public $redirect_uri;\n    public $oauth_url;\n    public $api_url;\n    public $scope;\n    public $driveId;\n    public $error;\n\n    public function __construct($tag) {\n        $this->disktag = $tag;\n        $this->client_id = ''; // Your Google API client ID\n        $this->client_secret = ''; // Your Google API client secret\n        $this->redirect_uri = ''; // Your OAuth redirect URI\n        $this->oauth_url = 'https://accounts.google.com/o/oauth2/token';\n        $this->api_url = 'https://www.googleapis.com/drive/v3';\n        $this->scope = 'https://www.googleapis.com/auth/drive';\n        $this->driveId = ''; // Your Google Drive ID\n        $this->error = [];\n    }\n\n    public function GDAPI($method, $url, $data = '') {\n        $curl = curl_init();\n        $headers = [\n            'Authorization: Bearer ' . $this->access_token,\n            'Content-Type: application/json'\n        ];\n        $options = [\n            CURLOPT_URL => $this->api_url . $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_CUSTOMREQUEST => $method\n        ];\n\n        if ($data) {\n            $options[CURLOPT_POSTFIELDS] = $data;\n        }\n\n        curl_setopt_array($curl, $options);\n        $response = curl_exec($curl);\n        $info = curl_getinfo($curl);\n        curl_close($curl);\n\n        if ($info['http_code'] >= 200 && $info['http_code'] < 300) {\n            return json_decode($response, true);\n        } else {\n            $this->error = ['code' => $info['http_code'], 'message' => $response];\n            return false;\n        }\n    }\n\n    public function get_access_token($refresh_token) {\n        // Implementation for retrieving access token using refresh token\n        // This part needs to be implemented based on your specific token management\n        // and refresh logic.\n        return false; // Placeholder return\n    }\n}\n\n?>",
      "<?php\n\nclass Googledrive {\n\n    public $access_token;\n    public $disktag;\n    public $client_id;\n    public $client_secret;\n    public $redirect_uri;\n    public $oauth_url;\n    public $api_url;\n    public $scope;\n    public $driveId;\n    public $error;\n\n    public function __construct($tag) {\n        $this->disktag = $tag;\n        $this->client_id = ''; // Your Google API client ID\n        $this->client_secret = ''; // Your Google API client secret\n        $this->redirect_uri = ''; // Your OAuth redirect URI\n        $this->oauth_url = 'https://oauth2.googleapis.com/token';\n        $this->api_url = 'https://www.googleapis.com/drive/v3';\n        $this->scope = 'https://www.googleapis.com/auth/drive';\n        $this->driveId = ''; // Your Google Drive ID\n    }\n\n    public function GDAPI($method, $url, $data = '') {\n        $curl = curl_init();\n        $headers = [\n            'Authorization: Bearer ' . $this->access_token,\n            'Content-Type: application/json'\n        ];\n        $options = [\n            CURLOPT_URL => $this->api_url . $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_CUSTOMREQUEST => $method\n        ];\n\n        if ($data) {\n            $options[CURLOPT_POSTFIELDS] = $data;\n        }\n\n        curl_setopt_array($curl, $options);\n        $response = curl_exec($curl);\n        $info = curl_getinfo($curl);\n        curl_close($curl);\n\n        if ($info['http_code'] >= 200 && $info['http_code'] < 300) {\n            return json_decode($response, true);\n        } else {\n            $this->error = ['code' => $info['http_code'], 'message' => $response];\n            return false;\n        }\n    }\n\n    public function get_access_token($refresh_token) {\n        $data = [\n            'client_id' => $this->client_id,\n            'client_secret' => $this->client_secret,\n            'refresh_token' => $refresh_token,\n            'grant_type' => 'refresh_token'\n        ];\n\n        $curl = curl_init($this->oauth_url);\n        curl_setopt($curl, CURLOPT_POST, true);\n        curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($data));\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($curl);\n        curl_close($curl);\n\n        $token = json_decode($response, true);\n\n        if (isset($token['access_token'])) {\n            $this->access_token = $token['access_token'];\n            return true;\n        } else {\n            $this->error = $token;\n            return false;\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass Googledrive {\n\n    public $access_token;\n    public $disktag;\n    public $client_id;\n    public $client_secret;\n    public $redirect_uri;\n    public $oauth_url;\n    public $api_url;\n    public $scope;\n    public $driveId;\n    public $error;\n\n    public function __construct($tag) {\n        $this->disktag = $tag;\n        $this->client_id = ''; // Set your client ID\n        $this->client_secret = ''; // Set your client secret\n        $this->redirect_uri = ''; // Set your redirect URI\n        $this->oauth_url = 'https://accounts.google.com/o/oauth2/token';\n        $this->api_url = 'https://www.googleapis.com/drive/v3';\n        $this->scope = 'https://www.googleapis.com/auth/drive';\n        $this->driveId = ''; // Set your Drive ID if needed\n    }\n\n    public function GDAPI($method, $url, $data = '') {\n        $curl = curl_init();\n        $headers = [\n            'Authorization: Bearer ' . $this->access_token,\n            'Content-Type: application/json'\n        ];\n        $options = [\n            CURLOPT_URL => $this->api_url . $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_CUSTOMREQUEST => $method\n        ];\n        if ($data) {\n            $options[CURLOPT_POSTFIELDS] = $data;\n        }\n        curl_setopt_array($curl, $options);\n        $response = curl_exec($curl);\n        $httpcode = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n        curl_close($curl);\n        if ($httpcode >= 200 && $httpcode < 300) {\n            return json_decode($response, true);\n        } else {\n            $this->error = json_decode($response, true);\n            return false;\n        }\n    }\n\n    public function get_access_token($refresh_token) {\n        $data = [\n            'grant_type' => 'refresh_token',\n            'refresh_token' => $refresh_token,\n            'client_id' => $this->client_id,\n            'client_secret' => $this->client_secret\n        ];\n        $curl = curl_init($this->oauth_url);\n        curl_setopt_array($curl, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_POST => true,\n            CURLOPT_POSTFIELDS => http_build_query($data)\n        ]);\n        $response = curl_exec($curl);\n        curl_close($curl);\n        $token = json_decode($response, true);\n        if (isset($token['access_token'])) {\n            $this->access_token = $token['access_token'];\n            return true;\n        } else {\n            $this->error = $token;\n            return false;\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass Googledrive {\n\n    public $access_token;\n    public $disktag;\n    public $client_id;\n    public $client_secret;\n    public $redirect_uri;\n    public $oauth_url;\n    public $api_url;\n    public $scope;\n    public $driveId;\n    public $error;\n\n    public function __construct($tag) {\n        $this->disktag = $tag;\n        $this->client_id = ''; // Your Google API client ID\n        $this->client_secret = ''; // Your Google API client secret\n        $this->redirect_uri = ''; // Your OAuth redirect URI\n        $this->oauth_url = 'https://oauth2.googleapis.com/token';\n        $this->api_url = 'https://www.googleapis.com/drive/v3';\n        $this->scope = 'https://www.googleapis.com/auth/drive';\n        $this->driveId = ''; // Your Google Drive ID\n    }\n\n    public function GDAPI($method, $url, $data = '') {\n        $curl = curl_init();\n        $headers = [\n            'Authorization: Bearer ' . $this->access_token,\n            'Content-Type: application/json'\n        ];\n        $options = [\n            CURLOPT_URL => $this->api_url . $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_CUSTOMREQUEST => $method\n        ];\n\n        if ($data) {\n            $options[CURLOPT_POSTFIELDS] = $data;\n        }\n\n        curl_setopt_array($curl, $options);\n        $response = curl_exec($curl);\n        $info = curl_getinfo($curl);\n        curl_close($curl);\n\n        if ($info['http_code'] >= 200 && $info['http_code'] < 300) {\n            return json_decode($response, true);\n        } else {\n            $this->error = ['code' => $info['http_code'], 'message' => $response];\n            return false;\n        }\n    }\n\n    public function get_access_token($refresh_token) {\n        $data = [\n            'client_id' => $this->client_id,\n            'client_secret' => $this->client_secret,\n            'refresh_token' => $refresh_token,\n            'grant_type' => 'refresh_token'\n        ];\n\n        $curl = curl_init($this->oauth_url);\n        curl_setopt($curl, CURLOPT_POST, true);\n        curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($data));\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($curl);\n        curl_close($curl);\n\n        $token = json_decode($response, true);\n\n        if (isset($token['access_token'])) {\n            $this->access_token = $token['access_token'];\n            return true;\n        } else {\n            $this->error = $token;\n            return false;\n        }\n    }\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 79,
    "Instruction": "Task Description: Create a PHP class that provides a fluent interface for making HTTP requests using cURL, supporting various HTTP methods, request configurations, and response handling.\n\nClass Description: The Httpie class is a fluent HTTP client wrapper for cURL in PHP that simplifies making HTTP requests with method chaining. It supports GET, POST, PUT, PATCH, and DELETE methods, allows setting headers, query parameters, and different body types (raw, JSON, form), and provides options for error handling and response processing.\n\nAttributes:\n- method: string - The HTTP method to use for the request (GET, POST, etc.)\n- url: string - The target URL for the request\n- headers: array - Associative array of HTTP headers\n- body: string - The request body content\n- curlopts: array - Additional cURL options to set\n- nothrow: bool - Whether to suppress exceptions on errors\n\nMethods:\n- __construct() -> void - Constructor that checks for cURL extension availability\n- get(string $url) -> Httpie - Static constructor for GET requests\n- post(string $url) -> Httpie - Static constructor for POST requests\n- patch(string $url) -> Httpie - Static constructor for PATCH requests\n- put(string $url) -> Httpie - Static constructor for PUT requests\n- delete(string $url) -> Httpie - Static constructor for DELETE requests\n- query(array $params) -> self - Adds query parameters to the URL\n- header(string $header, string $value) -> self - Adds a single header\n- body(string $body) -> self - Sets raw request body\n- jsonBody(array $data) -> self - Sets JSON request body\n- formBody(array $data) -> self - Sets form-urlencoded request body\n- setopt(int $key, mixed $value) -> self - Sets custom cURL option\n- nothrow(bool $on = true) -> self - Configures error throwing behavior\n- send(?array &$info = null) -> string - Executes the request and returns response\n- getJson() -> mixed - Executes request and returns parsed JSON response",
    "Canonical_solution": "namespace Deployer\\Utility;\n\nuse Deployer\\Exception\\HttpieException;\n\nclass Httpie\n{\n    private string $method = 'GET';\n    private string $url = '';\n    private array $headers = [];\n    private string $body = '';\n    private array $curlopts = [];\n    private bool $nothrow = false;\n\n    public function __construct()\n    {\n        if (!extension_loaded('curl')) {\n            throw new \\Exception(\n                \"Please, install curl extension.\\n\" .\n                \"https://php.net/curl.installation\",\n            );\n        }\n    }\n\n    public static function get(string $url): Httpie\n    {\n        $http = new self();\n        $http->method = 'GET';\n        $http->url = $url;\n        return $http;\n    }\n\n    public static function post(string $url): Httpie\n    {\n        $http = new self();\n        $http->method = 'POST';\n        $http->url = $url;\n        return $http;\n    }\n\n    public static function patch(string $url): Httpie\n    {\n        $http = new self();\n        $http->method = 'PATCH';\n        $http->url = $url;\n        return $http;\n    }\n\n    public static function put(string $url): Httpie\n    {\n        $http = new self();\n        $http->method = 'PUT';\n        $http->url = $url;\n        return $http;\n    }\n\n    public static function delete(string $url): Httpie\n    {\n        $http = new self();\n        $http->method = 'DELETE';\n        $http->url = $url;\n        return $http;\n    }\n\n    public function query(array $params): self\n    {\n        $this->url .= '?' . http_build_query($params);\n        return $this;\n    }\n\n    public function header(string $header, string $value): self\n    {\n        $this->headers[$header] = $value;\n        return $this;\n    }\n\n    public function body(string $body): self\n    {\n        $this->body = $body;\n        $this->headers = array_merge($this->headers, [\n            'Content-Length' => strlen($this->body),\n        ]);\n        return $this;\n    }\n\n    public function jsonBody(array $data): self\n    {\n        $this->body = json_encode($data, JSON_PRETTY_PRINT);\n        $this->headers = array_merge($this->headers, [\n            'Content-Type' => 'application/json',\n            'Content-Length' => strlen($this->body),\n        ]);\n        return $this;\n    }\n\n    public function formBody(array $data): self\n    {\n        $this->body = http_build_query($data);\n        $this->headers = array_merge($this->headers, [\n            'Content-type' => 'application/x-www-form-urlencoded',\n            'Content-Length' => strlen($this->body),\n        ]);\n        return $this;\n    }\n\n    public function setopt(int $key, $value): self\n    {\n        $this->curlopts[$key] = $value;\n        return $this;\n    }\n\n    public function nothrow(bool $on = true): self\n    {\n        $this->nothrow = $on;\n        return $this;\n    }\n\n    public function send(?array &$info = null): string\n    {\n        if ($this->url === '') {\n            throw new \\RuntimeException('URL must not be empty to Httpie::send()');\n        }\n        $ch = curl_init($this->url);\n        curl_setopt($ch, CURLOPT_USERAGENT, 'Deployer ' . DEPLOYER_VERSION);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->method);\n        $headers = [];\n        foreach ($this->headers as $key => $value) {\n            $headers[] = \"$key: $value\";\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $this->body);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n        foreach ($this->curlopts as $key => $value) {\n            curl_setopt($ch, $key, $value);\n        }\n        $result = curl_exec($ch);\n        $info = curl_getinfo($ch);\n        if ($result === false) {\n            if ($this->nothrow) {\n                $result = '';\n            } else {\n                $error = curl_error($ch);\n                $errno = curl_errno($ch);\n                curl_close($ch);\n                throw new HttpieException($error, $errno);\n            }\n        }\n        curl_close($ch);\n        return $result;\n    }\n\n    public function getJson(): mixed\n    {\n        $result = $this->send();\n        $response = json_decode($result, true);\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            throw new HttpieException(\n                'JSON Error: ' . json_last_error_msg() . '\\n' .\n                'Response: ' . $result,\n            );\n        }\n        return $response;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Httpie {\n    private string $method;\n    private string $url;\n    private array $headers = [];\n    private string $body = '';\n    private array $curlopts = [];\n    private bool $nothrow = false;\n\n    public function __construct()\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\RuntimeException('cURL extension is not available.');\n        }\n    }\n\n    public static function get(string $url): self\n    {\n        return (new self())->method('GET')->url($url);\n    }\n\n    public static function post(string $url): self\n    {\n        return (new self())->method('POST')->url($url);\n    }\n\n    public static function patch(string $url): self\n    {\n        return (new self())->method('PATCH')->url($url);\n    }\n\n    public static function put(string $url): self\n    {\n        return (new self())->method('PUT')->url($url);\n    }\n\n    public static function delete(string $url): self\n    {\n        return (new self())->method('DELETE')->url($url);\n    }\n\n    private function method(string $method): self\n    {\n        $this->method = $method;\n        return $this;\n    }\n\n    private function url(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    public function query(array $params): self\n    {\n        $this->url .= (strpos($this->url, '?') === false ? '?' : '&') . http_build_query($params);\n        return $this;\n    }\n\n    public function header(string $header, string $value): self\n    {\n        $this->headers[] = \"$header: $value\";\n        return $this;\n    }\n\n    public function body(string $body): self\n    {\n        $this->body = $body;\n        return $this;\n    }\n\n    public function jsonBody(array $data): self\n    {\n        return $this->body(json_encode($data))->header('Content-Type', 'application/json');\n    }\n\n    public function formBody(array $data): self\n    {\n        return $this->body(http_build_query($data))->header('Content-Type', 'application/x-www-form-urlencoded');\n    }\n\n    public function setopt(int $key, mixed $value): self\n    {\n        $this->curlopts[$key] = $value;\n        return $this;\n    }\n\n    public function nothrow(bool $on = true): self\n    {\n        $this->nothrow = $on;\n        return $this;\n    }\n\n    public function send(?array &$info = null): string\n    {\n        $ch = curl_init($this->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        if ($this->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $this->body);\n        }\n        curl_setopt_array($ch, $this->curlopts);\n\n        $response = curl_exec($ch);\n        $info = curl_getinfo($ch);\n\n        if ($response === false && !$this->nothrow) {\n            throw new \\RuntimeException('cURL error: ' . curl_error($ch));\n        }\n\n        curl_close($ch);\n        return $response === false ? '' : $response;\n    }\n\n    public function getJson(): mixed\n    {\n        $response = $this->send();\n        return json_decode($response, true);\n    }\n}",
      "<?php\n\nclass Httpie {\n    private string $method;\n    private string $url;\n    private array $headers = [];\n    private string $body = '';\n    private array $curlopts = [];\n    private bool $nothrow = false;\n\n    public function __construct()\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\RuntimeException('cURL extension is not available.');\n        }\n    }\n\n    public static function get(string $url): self\n    {\n        return (new self())->method('GET')->url($url);\n    }\n\n    public static function post(string $url): self\n    {\n        return (new self())->method('POST')->url($url);\n    }\n\n    public static function patch(string $url): self\n    {\n        return (new self())->method('PATCH')->url($url);\n    }\n\n    public static function put(string $url): self\n    {\n        return (new self())->method('PUT')->url($url);\n    }\n\n    public static function delete(string $url): self\n    {\n        return (new self())->method('DELETE')->url($url);\n    }\n\n    private function method(string $method): self\n    {\n        $this->method = $method;\n        return $this;\n    }\n\n    private function url(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    public function query(array $params): self\n    {\n        $this->url .= (strpos($this->url, '?') === false ? '?' : '&') . http_build_query($params);\n        return $this;\n    }\n\n    public function header(string $header, string $value): self\n    {\n        $this->headers[] = \"$header: $value\";\n        return $this;\n    }\n\n    public function body(string $body): self\n    {\n        $this->body = $body;\n        return $this;\n    }\n\n    public function jsonBody(array $data): self\n    {\n        return $this->body(json_encode($data))->header('Content-Type', 'application/json');\n    }\n\n    public function formBody(array $data): self\n    {\n        return $this->body(http_build_query($data))->header('Content-Type', 'application/x-www-form-urlencoded');\n    }\n\n    public function setopt(int $key, mixed $value): self\n    {\n        $this->curlopts[$key] = $value;\n        return $this;\n    }\n\n    public function nothrow(bool $on = true): self\n    {\n        $this->nothrow = $on;\n        return $this;\n    }\n\n    public function send(?array &$info = null): string\n    {\n        $ch = curl_init($this->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        if (!empty($this->headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n        if (!empty($this->body)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $this->body);\n        }\n        foreach ($this->curlopts as $key => $value) {\n            curl_setopt($ch, $key, $value);\n        }\n        $response = curl_exec($ch);\n        if ($info !== null) {\n            $info = curl_getinfo($ch);\n        }\n\n        if ($response === false && !$this->nothrow) {\n            throw new \\RuntimeException('cURL error: ' . curl_error($ch));\n        }\n        curl_close($ch);\n        return $response;\n    }\n\n    public function getJson(): mixed\n    {\n        $response = $this->send();\n        $data = json_decode($response, true);\n        if (json_last_error() !== JSON_ERROR_NONE && !$this->nothrow) {\n            throw new \\RuntimeException('Invalid JSON response: ' . json_last_error_msg());\n        }\n        return $data;\n    }\n}",
      "<?php\n\nclass Httpie {\n    private string $method;\n    private string $url;\n    private array $headers = [];\n    private string $body = '';\n    private array $curlopts = [];\n    private bool $nothrow = false;\n\n    public function __construct()\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\RuntimeException('cURL extension is not available.');\n        }\n    }\n\n    public static function get(string $url): self\n    {\n        return (new self())->method('GET')->url($url);\n    }\n\n    public static function post(string $url): self\n    {\n        return (new self())->method('POST')->url($url);\n    }\n\n    public static function patch(string $url): self\n    {\n        return (new self())->method('PATCH')->url($url);\n    }\n\n    public static function put(string $url): self\n    {\n        return (new self())->method('PUT')->url($url);\n    }\n\n    public static function delete(string $url): self\n    {\n        return (new self())->method('DELETE')->url($url);\n    }\n\n    private function method(string $method): self\n    {\n        $this->method = $method;\n        return $this;\n    }\n\n    private function url(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    public function query(array $params): self\n    {\n        $this->url .= (strpos($this->url, '?') === false ? '?' : '&') . http_build_query($params);\n        return $this;\n    }\n\n    public function header(string $header, string $value): self\n    {\n        $this->headers[] = \"$header: $value\";\n        return $this;\n    }\n\n    public function body(string $body): self\n    {\n        $this->body = $body;\n        return $this;\n    }\n\n    public function jsonBody(array $data): self\n    {\n        return $this->header('Content-Type', 'application/json')->body(json_encode($data));\n    }\n\n    public function formBody(array $data): self\n    {\n        return $this->header('Content-Type', 'application/x-www-form-urlencoded')->body(http_build_query($data));\n    }\n\n    public function setopt(int $key, mixed $value): self\n    {\n        $this->curlopts[$key] = $value;\n        return $this;\n    }\n\n    public function nothrow(bool $on = true): self\n    {\n        $this->nothrow = $on;\n        return $this;\n    }\n\n    public function send(?array &$info = null): string\n    {\n        $ch = curl_init($this->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        if (!empty($this->headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n        if (!empty($this->body)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $this->body);\n        }\n        foreach ($this->curlopts as $key => $value) {\n            curl_setopt($ch, $key, $value);\n        }\n        $response = curl_exec($ch);\n        if ($info !== null) {\n            $info = curl_getinfo($ch);\n        }\n\n        if ($response === false && !$this->nothrow) {\n            throw new \\RuntimeException('cURL error: ' . curl_error($ch));\n        }\n        curl_close($ch);\n        return $response;\n    }\n\n    public function getJson(): mixed\n    {\n        $response = $this->send();\n        $data = json_decode($response, true);\n        if (json_last_error() !== JSON_ERROR_NONE && !$this->nothrow) {\n            throw new \\RuntimeException('Invalid JSON response: ' . json_last_error_msg());\n        }\n        return $data;\n    }\n}",
      "<?php\n\nclass Httpie {\n    private string $method;\n    private string $url;\n    private array $headers = [];\n    private string $body = '';\n    private array $curlopts = [];\n    private bool $nothrow = false;\n\n    public function __construct()\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\RuntimeException('cURL extension is not available.');\n        }\n    }\n\n    public static function get(string $url): self\n    {\n        return (new self())->method('GET')->url($url);\n    }\n\n    public static function post(string $url): self\n    {\n        return (new self())->method('POST')->url($url);\n    }\n\n    public static function patch(string $url): self\n    {\n        return (new self())->method('PATCH')->url($url);\n    }\n\n    public static function put(string $url): self\n    {\n        return (new self())->method('PUT')->url($url);\n    }\n\n    public static function delete(string $url): self\n    {\n        return (new self())->method('DELETE')->url($url);\n    }\n\n    private function method(string $method): self\n    {\n        $this->method = $method;\n        return $this;\n    }\n\n    private function url(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    public function query(array $params): self\n    {\n        $this->url .= (strpos($this->url, '?') === false ? '?' : '&') . http_build_query($params);\n        return $this;\n    }\n\n    public function header(string $header, string $value): self\n    {\n        $this->headers[] = \"$header: $value\";\n        return $this;\n    }\n\n    public function body(string $body): self\n    {\n        $this->body = $body;\n        return $this;\n    }\n\n    public function jsonBody(array $data): self\n    {\n        return $this->header('Content-Type', 'application/json')->body(json_encode($data));\n    }\n\n    public function formBody(array $data): self\n    {\n        return $this->header('Content-Type', 'application/x-www-form-urlencoded')->body(http_build_query($data));\n    }\n\n    public function setopt(int $key, mixed $value): self\n    {\n        $this->curlopts[$key] = $value;\n        return $this;\n    }\n\n    public function nothrow(bool $on = true): self\n    {\n        $this->nothrow = $on;\n        return $this;\n    }\n\n    public function send(?array &$info = null): string\n    {\n        $ch = curl_init($this->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        if (!empty($this->headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n        if (!empty($this->body)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $this->body);\n        }\n        foreach ($this->curlopts as $key => $value) {\n            curl_setopt($ch, $key, $value);\n        }\n        $response = curl_exec($ch);\n        if ($info !== null) {\n            $info = curl_getinfo($ch);\n        }\n\n        if ($response === false && !$this->nothrow) {\n            throw new \\RuntimeException('cURL error: ' . curl_error($ch));\n        }\n        curl_close($ch);\n        return $response;\n    }\n\n    public function getJson(): mixed\n    {\n        $response = $this->send();\n        $data = json_decode($response, true);\n        if (json_last_error() !== JSON_ERROR_NONE && !$this->nothrow) {\n            throw new \\RuntimeException('Invalid JSON response: ' . json_last_error_msg());\n        }\n        return $data;\n    }\n}",
      "<?php\n\nclass Httpie {\n    private string $method;\n    private string $url;\n    private array $headers = [];\n    private string $body = '';\n    private array $curlopts = [];\n    private bool $nothrow = false;\n\n    public function __construct()\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\RuntimeException('cURL extension is not available.');\n        }\n    }\n\n    public static function get(string $url): self\n    {\n        return (new self())->method('GET')->url($url);\n    }\n\n    public static function post(string $url): self\n    {\n        return (new self())->method('POST')->url($url);\n    }\n\n    public static function patch(string $url): self\n    {\n        return (new self())->method('PATCH')->url($url);\n    }\n\n    public static function put(string $url): self\n    {\n        return (new self())->method('PUT')->url($url);\n    }\n\n    public static function delete(string $url): self\n    {\n        return (new self())->method('DELETE')->url($url);\n    }\n\n    private function method(string $method): self\n    {\n        $this->method = $method;\n        return $this;\n    }\n\n    private function url(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    public function query(array $params): self\n    {\n        $this->url .= (strpos($this->url, '?') === false ? '?' : '&') . http_build_query($params);\n        return $this;\n    }\n\n    public function header(string $header, string $value): self\n    {\n        $this->headers[] = \"$header: $value\";\n        return $this;\n    }\n\n    public function body(string $body): self\n    {\n        $this->body = $body;\n        return $this;\n    }\n\n    public function jsonBody(array $data): self\n    {\n        return $this->body(json_encode($data))->header('Content-Type', 'application/json');\n    }\n\n    public function formBody(array $data): self\n    {\n        return $this->body(http_build_query($data))->header('Content-Type', 'application/x-www-form-urlencoded');\n    }\n\n    public function setopt(int $key, mixed $value): self\n    {\n        $this->curlopts[$key] = $value;\n        return $this;\n    }\n\n    public function nothrow(bool $on = true): self\n    {\n        $this->nothrow = $on;\n        return $this;\n    }\n\n    public function send(?array &$info = null): string\n    {\n        $ch = curl_init($this->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        if (!empty($this->headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n        if (!empty($this->body)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $this->body);\n        }\n        foreach ($this->curlopts as $key => $value) {\n            curl_setopt($ch, $key, $value);\n        }\n        $response = curl_exec($ch);\n        if ($info !== null) {\n            $info = curl_getinfo($ch);\n        }\n\n        if ($response === false && !$this->nothrow) {\n            throw new \\RuntimeException('cURL error: ' . curl_error($ch));\n        }\n        curl_close($ch);\n        return $response;\n    }\n\n    public function getJson(): mixed\n    {\n        $response = $this->send();\n        $data = json_decode($response, true);\n        if (json_last_error() !== JSON_ERROR_NONE && !$this->nothrow) {\n            throw new \\RuntimeException('Invalid JSON response: ' . json_last_error_msg());\n        }\n        return $data;\n    }\n}",
      "<?php\n\nclass Httpie {\n    private string $method;\n    private string $url;\n    private array $headers = [];\n    private string $body = '';\n    private array $curlopts = [];\n    private bool $nothrow = false;\n\n    public function __construct()\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\RuntimeException('cURL extension is not available.');\n        }\n    }\n\n    public static function get(string $url): self\n    {\n        return (new self())->method('GET')->url($url);\n    }\n\n    public static function post(string $url): self\n    {\n        return (new self())->method('POST')->url($url);\n    }\n\n    public static function patch(string $url): self\n    {\n        return (new self())->method('PATCH')->url($url);\n    }\n\n    public static function put(string $url): self\n    {\n        return (new self())->method('PUT')->url($url);\n    }\n\n    public static function delete(string $url): self\n    {\n        return (new self())->method('DELETE')->url($url);\n    }\n\n    private function method(string $method): self\n    {\n        $this->method = $method;\n        return $this;\n    }\n\n    private function url(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    public function query(array $params): self\n    {\n        $this->url .= (strpos($this->url, '?') === false ? '?' : '&') . http_build_query($params);\n        return $this;\n    }\n\n    public function header(string $header, string $value): self\n    {\n        $this->headers[] = \"$header: $value\";\n        return $this;\n    }\n\n    public function body(string $body): self\n    {\n        $this->body = $body;\n        return $this;\n    }\n\n    public function jsonBody(array $data): self\n    {\n        return $this->header('Content-Type', 'application/json')->body(json_encode($data));\n    }\n\n    public function formBody(array $data): self\n    {\n        return $this->header('Content-Type', 'application/x-www-form-urlencoded')->body(http_build_query($data));\n    }\n\n    public function setopt(int $key, mixed $value): self\n    {\n        $this->curlopts[$key] = $value;\n        return $this;\n    }\n\n    public function nothrow(bool $on = true): self\n    {\n        $this->nothrow = $on;\n        return $this;\n    }\n\n    public function send(?array &$info = null): string\n    {\n        $ch = curl_init($this->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        if (!empty($this->headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n        if (!empty($this->body)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $this->body);\n        }\n        foreach ($this->curlopts as $key => $value) {\n            curl_setopt($ch, $key, $value);\n        }\n        $response = curl_exec($ch);\n        if ($info !== null) {\n            $info = curl_getinfo($ch);\n        }\n\n        if ($response === false && !$this->nothrow) {\n            throw new \\RuntimeException('cURL error: ' . curl_error($ch));\n        }\n        curl_close($ch);\n        return $response;\n    }\n\n    public function getJson(): mixed\n    {\n        $response = $this->send();\n        $data = json_decode($response, true);\n        if (json_last_error() !== JSON_ERROR_NONE && !$this->nothrow) {\n            throw new \\RuntimeException('Invalid JSON response: ' . json_last_error_msg());\n        }\n        return $data;\n    }\n}",
      "<?php\n\nclass Httpie {\n    private string $method;\n    private string $url;\n    private array $headers = [];\n    private string $body = '';\n    private array $curlopts = [];\n    private bool $nothrow = false;\n\n    public function __construct()\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\RuntimeException('cURL extension is not available.');\n        }\n    }\n\n    public static function get(string $url): self\n    {\n        return (new self())->method('GET')->url($url);\n    }\n\n    public static function post(string $url): self\n    {\n        return (new self())->method('POST')->url($url);\n    }\n\n    public static function patch(string $url): self\n    {\n        return (new self())->method('PATCH')->url($url);\n    }\n\n    public static function put(string $url): self\n    {\n        return (new self())->method('PUT')->url($url);\n    }\n\n    public static function delete(string $url): self\n    {\n        return (new self())->method('DELETE')->url($url);\n    }\n\n    private function method(string $method): self\n    {\n        $this->method = $method;\n        return $this;\n    }\n\n    private function url(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    public function query(array $params): self\n    {\n        $this->url .= (strpos($this->url, '?') === false ? '?' : '&') . http_build_query($params);\n        return $this;\n    }\n\n    public function header(string $header, string $value): self\n    {\n        $this->headers[] = \"$header: $value\";\n        return $this;\n    }\n\n    public function body(string $body): self\n    {\n        $this->body = $body;\n        return $this;\n    }\n\n    public function jsonBody(array $data): self\n    {\n        return $this->header('Content-Type', 'application/json')->body(json_encode($data));\n    }\n\n    public function formBody(array $data): self\n    {\n        return $this->header('Content-Type', 'application/x-www-form-urlencoded')->body(http_build_query($data));\n    }\n\n    public function setopt(int $key, mixed $value): self\n    {\n        $this->curlopts[$key] = $value;\n        return $this;\n    }\n\n    public function nothrow(bool $on = true): self\n    {\n        $this->nothrow = $on;\n        return $this;\n    }\n\n    public function send(?array &$info = null): string\n    {\n        $ch = curl_init($this->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        if ($this->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $this->body);\n        }\n        curl_setopt_array($ch, $this->curlopts);\n\n        $response = curl_exec($ch);\n        $info = curl_getinfo($ch);\n\n        if ($response === false && !$this->nothrow) {\n            throw new \\RuntimeException('cURL error: ' . curl_error($ch));\n        }\n\n        curl_close($ch);\n        return $response === false ? '' : $response;\n    }\n\n    public function getJson(): mixed\n    {\n        return json_decode($this->send(), true);\n    }\n}",
      "<?php\n\nclass Httpie {\n    private string $method;\n    private string $url;\n    private array $headers = [];\n    private string $body = '';\n    private array $curlopts = [];\n    private bool $nothrow = false;\n\n    public function __construct()\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\RuntimeException('cURL extension is not available.');\n        }\n    }\n\n    public static function get(string $url): self\n    {\n        return (new self())->method('GET')->url($url);\n    }\n\n    public static function post(string $url): self\n    {\n        return (new self())->method('POST')->url($url);\n    }\n\n    public static function patch(string $url): self\n    {\n        return (new self())->method('PATCH')->url($url);\n    }\n\n    public static function put(string $url): self\n    {\n        return (new self())->method('PUT')->url($url);\n    }\n\n    public static function delete(string $url): self\n    {\n        return (new self())->method('DELETE')->url($url);\n    }\n\n    private function method(string $method): self\n    {\n        $this->method = $method;\n        return $this;\n    }\n\n    private function url(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    public function query(array $params): self\n    {\n        $this->url .= (strpos($this->url, '?') === false ? '?' : '&') . http_build_query($params);\n        return $this;\n    }\n\n    public function header(string $header, string $value): self\n    {\n        $this->headers[] = \"$header: $value\";\n        return $this;\n    }\n\n    public function body(string $body): self\n    {\n        $this->body = $body;\n        return $this;\n    }\n\n    public function jsonBody(array $data): self\n    {\n        return $this->header('Content-Type', 'application/json')->body(json_encode($data));\n    }\n\n    public function formBody(array $data): self\n    {\n        return $this->header('Content-Type', 'application/x-www-form-urlencoded')->body(http_build_query($data));\n    }\n\n    public function setopt(int $key, mixed $value): self\n    {\n        $this->curlopts[$key] = $value;\n        return $this;\n    }\n\n    public function nothrow(bool $on = true): self\n    {\n        $this->nothrow = $on;\n        return $this;\n    }\n\n    public function send(?array &$info = null): string\n    {\n        $ch = curl_init($this->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        if (!empty($this->headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n        if (!empty($this->body)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $this->body);\n        }\n        foreach ($this->curlopts as $key => $value) {\n            curl_setopt($ch, $key, $value);\n        }\n        $response = curl_exec($ch);\n        $info = curl_getinfo($ch);\n        if ($response === false && !$this->nothrow) {\n            throw new \\RuntimeException('cURL error: ' . curl_error($ch));\n        }\n        curl_close($ch);\n        return $response;\n    }\n\n    public function getJson(): mixed\n    {\n        $response = $this->send();\n        $header_size = $info['header_size'] ?? 0; // Use coalesce operator for PHP 7.0 compatibility\n        $body = substr($response, $header_size);\n        return json_decode($body, true);\n    }\n}",
      "<?php\n\nclass Httpie {\n    private string $method;\n    private string $url;\n    private array $headers = [];\n    private string $body = '';\n    private array $curlopts = [];\n    private bool $nothrow = false;\n\n    public function __construct()\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\RuntimeException('cURL extension is not available.');\n        }\n    }\n\n    public static function get(string $url): self\n    {\n        return (new self())->method('GET')->url($url);\n    }\n\n    public static function post(string $url): self\n    {\n        return (new self())->method('POST')->url($url);\n    }\n\n    public static function patch(string $url): self\n    {\n        return (new self())->method('PATCH')->url($url);\n    }\n\n    public static function put(string $url): self\n    {\n        return (new self())->method('PUT')->url($url);\n    }\n\n    public static function delete(string $url): self\n    {\n        return (new self())->method('DELETE')->url($url);\n    }\n\n    private function method(string $method): self\n    {\n        $this->method = $method;\n        return $this;\n    }\n\n    private function url(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    public function query(array $params): self\n    {\n        $this->url .= (strpos($this->url, '?') === false ? '?' : '&') . http_build_query($params);\n        return $this;\n    }\n\n    public function header(string $header, string $value): self\n    {\n        $this->headers[] = \"$header: $value\";\n        return $this;\n    }\n\n    public function body(string $body): self\n    {\n        $this->body = $body;\n        return $this;\n    }\n\n    public function jsonBody(array $data): self\n    {\n        return $this->body(json_encode($data))->header('Content-Type', 'application/json');\n    }\n\n    public function formBody(array $data): self\n    {\n        return $this->body(http_build_query($data))->header('Content-Type', 'application/x-www-form-urlencoded');\n    }\n\n    public function setopt(int $key, mixed $value): self\n    {\n        $this->curlopts[$key] = $value;\n        return $this;\n    }\n\n    public function nothrow(bool $on = true): self\n    {\n        $this->nothrow = $on;\n        return $this;\n    }\n\n    public function send(?array &$info = null): string\n    {\n        $ch = curl_init($this->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        if (!empty($this->headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n        if (!empty($this->body)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $this->body);\n        }\n        foreach ($this->curlopts as $key => $value) {\n            curl_setopt($ch, $key, $value);\n        }\n        $response = curl_exec($ch);\n        if ($info !== null) {\n            $info = curl_getinfo($ch);\n        }\n\n        if ($response === false && !$this->nothrow) {\n            throw new \\RuntimeException('cURL error: ' . curl_error($ch));\n        }\n        curl_close($ch);\n        return $response;\n    }\n\n    public function getJson(): mixed\n    {\n        $response = $this->send();\n        $data = json_decode($response, true);\n        if (json_last_error() !== JSON_ERROR_NONE && !$this->nothrow) {\n            throw new \\RuntimeException('Invalid JSON response: ' . json_last_error_msg());\n        }\n        return $data;\n    }\n}",
      "<?php\n\nclass Httpie {\n    private string $method;\n    private string $url;\n    private array $headers = [];\n    private string $body = '';\n    private array $curlopts = [];\n    private bool $nothrow = false;\n\n    public function __construct()\n    {\n        if (!function_exists('curl_init')) {\n            throw new \\RuntimeException('cURL extension is not available.');\n        }\n    }\n\n    public static function get(string $url): self\n    {\n        return (new self())->method('GET')->url($url);\n    }\n\n    public static function post(string $url): self\n    {\n        return (new self())->method('POST')->url($url);\n    }\n\n    public static function patch(string $url): self\n    {\n        return (new self())->method('PATCH')->url($url);\n    }\n\n    public static function put(string $url): self\n    {\n        return (new self())->method('PUT')->url($url);\n    }\n\n    public static function delete(string $url): self\n    {\n        return (new self())->method('DELETE')->url($url);\n    }\n\n    private function method(string $method): self\n    {\n        $this->method = $method;\n        return $this;\n    }\n\n    private function url(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    public function query(array $params): self\n    {\n        $this->url .= (strpos($this->url, '?') === false ? '?' : '&') . http_build_query($params);\n        return $this;\n    }\n\n    public function header(string $header, string $value): self\n    {\n        $this->headers[] = \"$header: $value\";\n        return $this;\n    }\n\n    public function body(string $body): self\n    {\n        $this->body = $body;\n        return $this;\n    }\n\n    public function jsonBody(array $data): self\n    {\n        return $this->body(json_encode($data))->header('Content-Type', 'application/json');\n    }\n\n    public function formBody(array $data): self\n    {\n        return $this->body(http_build_query($data))->header('Content-Type', 'application/x-www-form-urlencoded');\n    }\n\n    public function setopt(int $key, mixed $value): self\n    {\n        $this->curlopts[$key] = $value;\n        return $this;\n    }\n\n    public function nothrow(bool $on = true): self\n    {\n        $this->nothrow = $on;\n        return $this;\n    }\n\n    public function send(?array &$info = null): string\n    {\n        $ch = curl_init($this->url);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        if (!empty($this->headers)) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        }\n        if (!empty($this->body)) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $this->body);\n        }\n        foreach ($this->curlopts as $key => $value) {\n            curl_setopt($ch, $key, $value);\n        }\n        $response = curl_exec($ch);\n        if ($info !== null) {\n            $info = curl_getinfo($ch);\n        }\n\n        if ($response === false && !$this->nothrow) {\n            throw new \\RuntimeException('cURL error: ' . curl_error($ch));\n        }\n        curl_close($ch);\n        return $response;\n    }\n\n    public function getJson(): mixed\n    {\n        $response = $this->send();\n        return json_decode($response, true);\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a PHP class that utilizes the Guzzle HTTP client to fetch content from a URL and load it into a DOM object.\n\nClass Description: The `Dom` class provides functionality to load HTML content from a URL using the Guzzle HTTP client. It allows for optional customization of the HTTP client and request objects, and handles the response to extract the content for DOM processing.\n\nMethods:\n\nMethod1: `loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null)` -> `Dom` - Loads HTML content from the specified URL using the provided or default Guzzle HTTP client and request objects. The content is then loaded into a DOM object. Throws various exceptions for error handling.\n\nInput Parameters:\n- `$url`: string - The URL from which to fetch the HTML content.\n- `$options`: ?Options - Optional configuration options for the DOM loading process.\n- `$client`: ?ClientInterface - Optional Guzzle HTTP client instance. If not provided, a default client is created.\n- `$request`: ?RequestInterface - Optional Guzzle HTTP request instance. If not provided, a default GET request is created.\n\nOutput:\n- Returns an instance of `Dom` with the loaded HTML content.",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Request;\nuse Psr\\Http\\Client\\ClientExceptionInterface;\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\n\nclass Dom implements DomInterface\n{\n    /**\n     * Use a curl interface implementation to attempt to load\n     * the content from a url.\n     *\n     * @throws ChildNotFoundException\n     * @throws CircularException\n     * @throws Exceptions\\ContentLengthException\n     * @throws LogicalException\n     * @throws StrictException\n     * @throws ClientExceptionInterface\n     */\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        if ($client === null) {\n            $client = new Client();\n        }\n        if ($request === null) {\n            $request = new Request('GET', $url);\n        }\n\n        $response = $client->sendRequest($request);\n        $content = $response->getBody()->getContents();\n\n        return $this->loadStr($content, $options);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [
      "<?php\n\nnamespace App\\Services;\n\nuse DOMDocument;\nuse DOMXPath;\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\ClientInterface;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Psr7\\Request;\nuse GuzzleHttp\\Psr7\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass Dom\n{\n    private DOMDocument $dom;\n    private DOMXPath $xpath;\n\n    public function __construct()\n    {\n        $this->dom = new DOMDocument();\n    }\n\n    /**\n     * @throws GuzzleException\n     */\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        $client = $client ?? new Client();\n        $request = $request ?? new Request('GET', $url);\n\n        $response = $client->send($request);\n\n        $this->loadHtmlFromResponse($response);\n\n        return $this;\n    }\n\n    private function loadHtmlFromResponse(ResponseInterface $response): void\n    {\n        $html = $response->getBody()->getContents();\n        $this->dom->loadHTML($html);\n        $this->xpath = new DOMXPath($this->dom);\n    }\n\n    public function getDom(): DOMDocument\n    {\n        return $this->dom;\n    }\n\n    public function getXpath(): DOMXPath\n    {\n        return $this->xpath;\n    }\n}"
    ],
    "unmatched_results": [
      "<?php\n\nnamespace App\\Services;\n\nuse DOMDocument;\nuse DOMXPath;\nuse GuzzleHttp\\Client as GuzzleClient;\nuse GuzzleHttp\\ClientInterface;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Psr7\\Request as GuzzleRequest;\nuse GuzzleHttp\\Psr7\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass Dom\n{\n    private DOMDocument $dom;\n    private DOMXPath $xpath;\n\n    public function __construct()\n    {\n        $this->dom = new DOMDocument();\n    }\n\n    /**\n     * @throws GuzzleException\n     */\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        $client = $client ?? new GuzzleClient();\n        $request = $request ?? new GuzzleRequest('GET', $url);\n\n        $response = $client->send($request);\n\n        $this->loadHtmlFromResponse($response);\n\n        return $this;\n    }\n\n    private function loadHtmlFromResponse(ResponseInterface $response): void\n    {\n        $html = $response->getBody()->getContents();\n        $this->dom->loadHTML($html);\n        $this->xpath = new DOMXPath($this->dom);\n    }\n\n    public function getDom(): DOMDocument\n    {\n        return $this->dom;\n    }\n\n    public function getXpath(): DOMXPath\n    {\n        return $this->xpath;\n    }\n}",
      "<?php\n\nnamespace App\\Util;\n\nuse DOMDocument;\nuse DOMXPath;\nuse GuzzleHttp\\Client as GuzzleClient;\nuse GuzzleHttp\\ClientInterface;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Psr7\\Request as GuzzleRequest;\nuse GuzzleHttp\\Psr7\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass Dom\n{\n    private DOMDocument $dom;\n    private DOMXPath $xpath;\n\n    public function __construct()\n    {\n        $this->dom = new DOMDocument();\n    }\n\n    /**\n     * @throws GuzzleException\n     */\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        $client = $client ?? new GuzzleClient();\n        $request = $request ?? new GuzzleRequest('GET', $url);\n\n        $response = $client->send($request);\n\n        $this->loadFromResponse($response, $options);\n\n        return $this;\n    }\n\n    /**\n     * @throws GuzzleException\n     */\n    private function loadFromResponse(ResponseInterface $response, ?Options $options = null): void\n    {\n        $content = $response->getBody()->getContents();\n        $this->loadFromString($content, $options);\n    }\n\n    private function loadFromString(string $content, ?Options $options = null): void\n    {\n        $libxml_previous_state = libxml_use_internal_errors(true);\n        $this->dom->loadHTML($content, $options?->getLibxmlOptions() ?? LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);\n        libxml_clear_errors();\n        libxml_use_internal_errors($libxml_previous_state);\n\n        $this->xpath = new DOMXPath($this->dom);\n    }\n\n    public function getDom(): DOMDocument\n    {\n        return $this->dom;\n    }\n\n    public function getXpath(): DOMXPath\n    {\n        return $this->xpath;\n    }\n}\n\nclass Options\n{\n    private int $libxmlOptions;\n\n    public function __construct(int $libxmlOptions = LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD)\n    {\n        $this->libxmlOptions = $libxmlOptions;\n    }\n\n    public function getLibxmlOptions(): int\n    {\n        return $this->libxmlOptions;\n    }\n}",
      "<?php\n\nnamespace App\\Services;\n\nuse DOMDocument;\nuse DOMXPath;\nuse GuzzleHttp\\Client as HttpClient;\nuse GuzzleHttp\\ClientInterface;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Psr7\\Request as HttpRequest;\nuse GuzzleHttp\\Psr7\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass Dom\n{\n    private DOMDocument $dom;\n    private DOMXPath $xpath;\n    private Options $options;\n\n    public function __construct(Options $options)\n    {\n        $this->options = $options;\n        $this->dom = new DOMDocument();\n    }\n\n    /**\n     * Loads HTML content from the specified URL using the provided or default Guzzle HTTP client and request objects.\n     *\n     * @param string $url The URL from which to fetch the HTML content.\n     * @param Options|null $options Optional configuration options for the DOM loading process.\n     * @param ClientInterface|null $client Optional Guzzle HTTP client instance. If not provided, a default client is created.\n     * @param RequestInterface|null $request Optional Guzzle HTTP request instance. If not provided, a default GET request is created.\n     *\n     * @return Dom\n     *\n     * @throws GuzzleException\n     */\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        $options = $options ?? $this->options;\n        $client = $client ?? new HttpClient();\n        $request = $request ?? new HttpRequest('GET', $url);\n\n        $response = $client->send($request);\n\n        $this->loadHtml($response);\n\n        return $this;\n    }\n\n    private function loadHtml(ResponseInterface $response): void\n    {\n        $html = $response->getBody()->getContents();\n        $this->dom->loadHTML($html, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);\n        $this->xpath = new DOMXPath($this->dom);\n    }\n\n    public function getDom(): DOMDocument\n    {\n        return $this->dom;\n    }\n\n    public function getXpath(): DOMXPath\n    {\n        return $this->xpath;\n    }\n}",
      "<?php\n\nnamespace App\\Services;\n\nuse DOMDocument;\nuse DOMXPath;\nuse GuzzleHttp\\Client as HttpClient;\nuse GuzzleHttp\\ClientInterface;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Psr7\\Request as HttpRequest;\nuse GuzzleHttp\\Psr7\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass Dom\n{\n    private DOMDocument $dom;\n    private DOMXPath $xpath;\n\n    public function __construct()\n    {\n        $this->dom = new DOMDocument();\n    }\n\n    /**\n     * @throws GuzzleException\n     */\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        $client = $client ?? new HttpClient();\n        $request = $request ?? new HttpRequest('GET', $url);\n\n        $response = $client->send($request);\n\n        $this->loadHtmlFromResponse($response);\n\n        return $this;\n    }\n\n    private function loadHtmlFromResponse(ResponseInterface $response): void\n    {\n        $html = $response->getBody()->getContents();\n        $this->loadHtml($html);\n    }\n\n    private function loadHtml(string $html): void\n    {\n        libxml_use_internal_errors(true);\n        $this->dom->loadHTML($html);\n        $this->xpath = new DOMXPath($this->dom);\n    }\n\n    public function getDom(): DOMDocument\n    {\n        return $this->dom;\n    }\n\n    public function getXpath(): DOMXPath\n    {\n        return $this->xpath;\n    }\n}",
      "<?php\n\nnamespace App\\Services;\n\nuse DOMDocument;\nuse DOMXPath;\nuse GuzzleHttp\\Client as HttpClient;\nuse GuzzleHttp\\ClientInterface;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Psr7\\Request as HttpRequest;\nuse GuzzleHttp\\Psr7\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass Dom\n{\n    private DOMDocument $dom;\n    private DOMXPath $xpath;\n\n    public function __construct()\n    {\n        $this->dom = new DOMDocument();\n    }\n\n    /**\n     * @throws GuzzleException\n     */\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        $client = $client ?? new HttpClient();\n        $request = $request ?? new HttpRequest('GET', $url);\n\n        try {\n            $response = $client->send($request);\n            $this->loadFromResponse($response);\n        } catch (GuzzleException $e) {\n            // Handle exceptions appropriately, e.g., log, rethrow, etc.\n            throw $e; \n        }\n\n        return $this;\n    }\n\n    private function loadFromResponse(ResponseInterface $response): void\n    {\n        $html = $response->getBody()->getContents();\n        $this->dom->loadHTML($html);\n        $this->xpath = new DOMXPath($this->dom);\n    }\n\n    public function getDom(): DOMDocument\n    {\n        return $this->dom;\n    }\n\n    public function getXpath(): DOMXPath\n    {\n        return $this->xpath;\n    }\n}",
      "<?php\n\nnamespace App\\Util;\n\nuse DOMDocument;\nuse DOMXPath;\nuse GuzzleHttp\\Client as GuzzleClient;\nuse GuzzleHttp\\ClientInterface;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Psr7\\Request as GuzzleRequest;\nuse GuzzleHttp\\Psr7\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass Dom\n{\n    private DOMDocument $dom;\n    private DOMXPath $xpath;\n    private Options $options;\n\n    public function __construct(Options $options)\n    {\n        $this->options = $options;\n        $this->dom = new DOMDocument();\n    }\n\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        $options = $options ?? $this->options;\n        $client = $client ?? new GuzzleClient();\n        $request = $request ?? new GuzzleRequest('GET', $url);\n\n        try {\n            $response = $client->send($request);\n            $this->loadFromResponse($response, $options);\n        } catch (GuzzleException $e) {\n            throw new \\RuntimeException('Failed to fetch content from URL: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n        return $this;\n    }\n\n    private function loadFromResponse(ResponseInterface $response, Options $options): void\n    {\n        $content = $response->getBody()->getContents();\n        $this->loadFromString($content, $options);\n    }\n\n\n    private function loadFromString(string $content, Options $options): void\n    {\n        $libxml_previous_state = libxml_use_internal_errors(true);\n        $this->dom->loadHTML($content, $options->getLibxmlOptions());\n\n        $errors = libxml_get_errors();\n        libxml_clear_errors();\n        libxml_use_internal_errors($libxml_previous_state);\n\n        if (!empty($errors)) {\n            $errorMessages = array_map(function (\\LibXMLError $error) {\n                return $error->message;\n            }, $errors);\n            throw new \\RuntimeException('Failed to parse HTML: ' . implode(', ', $errorMessages));\n        }\n\n        $this->xpath = new DOMXPath($this->dom);\n    }\n\n    public function getXpath(): DOMXPath\n    {\n        return $this->xpath;\n    }\n\n    public function getDom(): DOMDocument\n    {\n        return $this->dom;\n    }\n}",
      "<?php\n\nnamespace App\\Util;\n\nuse DOMDocument;\nuse DOMXPath;\nuse GuzzleHttp\\Client as GuzzleClient;\nuse GuzzleHttp\\ClientInterface;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Psr7\\Request as GuzzleRequest;\nuse GuzzleHttp\\Psr7\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass Dom\n{\n    private DOMDocument $dom;\n    private DOMXPath $xpath;\n    private Options $options;\n\n    public function __construct(Options $options)\n    {\n        $this->options = $options;\n        $this->dom = new DOMDocument();\n    }\n\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        $options = $options ?: $this->options;\n        $client = $client ?: new GuzzleClient();\n        $request = $request ?: new GuzzleRequest('GET', $url);\n\n        try {\n            $response = $client->send($request);\n            $this->loadFromResponse($response, $options);\n        } catch (GuzzleException $e) {\n            throw new \\RuntimeException('Failed to fetch content from URL: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n        return $this;\n    }\n\n    private function loadFromResponse(ResponseInterface $response, Options $options): void\n    {\n        $content = $response->getBody()->getContents();\n        $this->loadFromString($content, $options);\n    }\n\n\n    private function loadFromString(string $content, Options $options): void\n    {\n        $libxml_previous_state = libxml_use_internal_errors(true);\n        $this->dom->loadHTML($content, $options->getLibxmlOptions());\n\n        // Restore the previous state of libxml errors, if needed\n        libxml_clear_errors();\n        libxml_use_internal_errors($libxml_previous_state);\n\n        $this->xpath = new DOMXPath($this->dom);\n    }\n\n    public function getDom(): DOMDocument\n    {\n        return $this->dom;\n    }\n\n    public function getXpath(): DOMXPath\n    {\n        return $this->xpath;\n    }\n}\n\nclass Options\n{\n    private int $libxmlOptions;\n\n    public function __construct(int $libxmlOptions = LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD | LIBXML_NOERROR | LIBXML_NOWARNING)\n    {\n        $this->libxmlOptions = $libxmlOptions;\n    }\n\n    public function getLibxmlOptions(): int\n    {\n        return $this->libxmlOptions;\n    }\n}",
      "<?php\n\nnamespace App\\Services;\n\nuse DOMDocument;\nuse DOMXPath;\nuse GuzzleHttp\\Client as HttpClient;\nuse GuzzleHttp\\ClientInterface;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Psr7\\Request as HttpRequest;\nuse GuzzleHttp\\Psr7\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass Dom\n{\n    private DOMDocument $dom;\n    private DOMXPath $xpath;\n\n    public function __construct()\n    {\n        $this->dom = new DOMDocument();\n    }\n\n    /**\n     * @throws GuzzleException\n     */\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        $client = $client ?? new HttpClient();\n        $request = $request ?? new HttpRequest('GET', $url);\n\n        $response = $client->send($request);\n\n        $this->loadFromResponse($response);\n\n        return $this;\n    }\n\n    /**\n     * @throws GuzzleException\n     */\n    private function loadFromResponse(ResponseInterface $response): void\n    {\n        $content = $response->getBody()->getContents();\n        $this->dom->loadHTML($content);\n        $this->xpath = new DOMXPath($this->dom);\n    }\n\n    public function getDom(): DOMDocument\n    {\n        return $this->dom;\n    }\n\n    public function getXpath(): DOMXPath\n    {\n        return $this->xpath;\n    }\n}",
      "<?php\n\nnamespace App\\Services;\n\nuse DOMDocument;\nuse DOMXPath;\nuse GuzzleHttp\\Client as HttpClient;\nuse GuzzleHttp\\ClientInterface;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Psr7\\Request as HttpRequest;\nuse GuzzleHttp\\Psr7\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass Dom\n{\n    private DOMDocument $dom;\n    private DOMXPath $xpath;\n\n    public function __construct()\n    {\n        $this->dom = new DOMDocument();\n    }\n\n    /**\n     * @throws GuzzleException\n     */\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        $client = $client ?? new HttpClient();\n        $request = $request ?? new HttpRequest('GET', $url);\n\n        $response = $client->send($request);\n\n        $this->loadFromResponse($response);\n\n        return $this;\n    }\n\n    /**\n     * @throws GuzzleException\n     */\n    private function loadFromResponse(ResponseInterface $response): void\n    {\n        $content = $response->getBody()->getContents();\n        $this->dom->loadHTML($content);\n        $this->xpath = new DOMXPath($this->dom);\n    }\n\n    public function getDom(): DOMDocument\n    {\n        return $this->dom;\n    }\n\n    public function getXpath(): DOMXPath\n    {\n        return $this->xpath;\n    }\n}"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client using cURL to send requests to a specified URL and handle the responses, including error checking and resource cleanup.\n\nClass Description: The SpotlightClient class provides functionality to send HTTP requests using PHP's cURL extension. It handles request initialization, option configuration, execution, error handling, and resource cleanup. The class is designed to work with custom Request and Response objects.\n\nMethods:\n\nMethod1: sendRequest(Request $request, string $url) -> Response - Sends an HTTP request to the specified URL using cURL. Initializes a cURL session, sets various options including URL, headers, timeout values, and request method, executes the request, and processes the response or errors. Returns a Response object containing the status code and any error messages.\n\nInput Parameters:\n- $request: Request - An object containing the request data to be sent\n- $url: string - The target URL for the HTTP request\n\nReturn Type: Response - An object containing the HTTP status code and any error messages\n\nThe method performs the following steps:\n1. Checks if cURL extension is loaded\n2. Validates request data\n3. Initializes cURL session\n4. Sets cURL options (URL, headers, timeouts, method, etc.)\n5. Executes the request\n6. Handles errors if they occur\n7. Closes cURL session\n8. Returns response with status code",
    "Canonical_solution": "namespace Sentry\\Spotlight;\n\nuse Sentry\\HttpClient\\Request;\nuse Sentry\\HttpClient\\Response;\n\nclass SpotlightClient\n{\n    public static function sendRequest(Request $request, string $url): Response\n    {\n        if (!\\extension_loaded('curl')) {\n            throw new \\RuntimeException('The cURL PHP extension must be enabled to use the SpotlightClient.');\n        }\n\n        $requestData = $request->getStringBody();\n        if ($requestData === null) {\n            throw new \\RuntimeException('The request data is empty.');\n        }\n\n        $curlHandle = curl_init();\n\n        curl_setopt($curlHandle, \\CURLOPT_URL, $url);\n        curl_setopt($curlHandle, \\CURLOPT_HTTPHEADER, [\n            'Content-Type: application/x-sentry-envelope',\n        ]);\n        curl_setopt($curlHandle, \\CURLOPT_TIMEOUT, 2.0);\n        curl_setopt($curlHandle, \\CURLOPT_CONNECTTIMEOUT, 1.0);\n        curl_setopt($curlHandle, \\CURLOPT_ENCODING, '');\n        curl_setopt($curlHandle, \\CURLOPT_POST, true);\n        curl_setopt($curlHandle, \\CURLOPT_POSTFIELDS, $requestData);\n        curl_setopt($curlHandle, \\CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curlHandle, \\CURLOPT_HTTP_VERSION, \\CURL_HTTP_VERSION_1_1);\n\n        $body = curl_exec($curlHandle);\n\n        if ($body === false) {\n            $errorCode = curl_errno($curlHandle);\n            $error = curl_error($curlHandle);\n            curl_close($curlHandle);\n\n            $message = 'cURL Error (' . $errorCode . ') ' . $error;\n\n            return new Response(0, [], $message);\n        }\n\n        $statusCode = curl_getinfo($curlHandle, \\CURLINFO_HTTP_CODE);\n\n        curl_close($curlHandle);\n\n        return new Response($statusCode, [], '');\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Request {\n    // Request properties (e.g., headers, body)\n}\n\nclass Response {\n    public $statusCode;\n    public $errorMessage;\n\n    public function __construct($statusCode, $errorMessage = null) {\n        $this->statusCode = $statusCode;\n        $this->errorMessage = $errorMessage;\n    }\n}\n\nclass SpotlightClient {\n    public function sendRequest(Request $request, string $url): Response {\n        if (!function_exists('curl_init')) {\n            return new Response(0, 'cURL extension not loaded.');\n        }\n\n        // Validate request data (implementation omitted for brevity)\n\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        // Set other cURL options (headers, timeouts, method, etc.)\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true); // Include headers in the response\n        // Example timeout settings\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10); // Connection timeout in seconds\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);        // Total transaction timeout in seconds\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $errorMessage = curl_error($ch);\n            curl_close($ch);\n            return new Response(0, $errorMessage);\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($httpCode);\n    }\n}\n\n?>",
      "<?php\n\nclass Request {\n    // Define properties and methods for Request object\n}\n\nclass Response {\n    public $statusCode;\n    public $errorMessage;\n\n    public function __construct($statusCode, $errorMessage = '') {\n        $this->statusCode = $statusCode;\n        $this->errorMessage = $errorMessage;\n    }\n}\n\nclass SpotlightClient {\n    public function sendRequest(Request $request, string $url): Response {\n        if (!function_exists('curl_init')) {\n            return new Response(0, 'cURL extension not loaded.');\n        }\n\n        // Validate request data (implementation not shown)\n\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        // Set other cURL options (headers, timeouts, method, etc.)\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true); // Include headers in the response\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $errorMessage = curl_error($ch);\n            curl_close($ch);\n            return new Response(0, $errorMessage);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        // Process headers and body to create a meaningful Response object\n        return new Response($statusCode);\n    }\n}\n\n?>",
      "<?php\n\nclass Request {\n    // Request properties (e.g., headers, body)\n}\n\nclass Response {\n    public $statusCode;\n    public $errorMessage;\n\n    public function __construct($statusCode, $errorMessage = null) {\n        $this->statusCode = $statusCode;\n        $this->errorMessage = $errorMessage;\n    }\n}\n\nclass SpotlightClient {\n    public function sendRequest(Request $request, string $url): Response {\n        if (!function_exists('curl_init')) {\n            return new Response(0, 'cURL extension not loaded.');\n        }\n\n        // Validate request data (implementation omitted for brevity)\n\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        // Set other cURL options (headers, timeouts, method, etc.)\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true); // Include headers in the response\n        // Example timeout settings\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10); // Connection timeout in seconds\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);        // Total transaction timeout in seconds\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $errorMessage = curl_error($ch);\n            curl_close($ch);\n            return new Response(0, $errorMessage);\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($httpCode);\n    }\n}\n\n?>",
      "<?php\n\nclass Request {\n    // Request properties (e.g., headers, body)\n}\n\nclass Response {\n    public $statusCode;\n    public $errorMessage;\n\n    public function __construct($statusCode, $errorMessage = null) {\n        $this->statusCode = $statusCode;\n        $this->errorMessage = $errorMessage;\n    }\n}\n\nclass SpotlightClient {\n    public function sendRequest(Request $request, string $url): Response {\n        if (!function_exists('curl_init')) {\n            return new Response(0, 'cURL extension not loaded.');\n        }\n\n        // Validate request data (implementation omitted for brevity)\n\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        // Set other cURL options (headers, timeouts, method, etc.)\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true); // Include headers in the response\n        // Example timeout settings\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10); // Connection timeout in seconds\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);        // Total transaction timeout in seconds\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $errorMessage = curl_error($ch);\n            curl_close($ch);\n            return new Response(0, $errorMessage);\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($httpCode);\n    }\n}\n\n?>",
      "<?php\n\nclass Request {\n    // Request properties (e.g., headers, body)\n}\n\nclass Response {\n    public $statusCode;\n    public $errorMessage;\n\n    public function __construct($statusCode, $errorMessage = null) {\n        $this->statusCode = $statusCode;\n        $this->errorMessage = $errorMessage;\n    }\n}\n\nclass SpotlightClient {\n    public function sendRequest(Request $request, string $url): Response {\n        if (!function_exists('curl_init')) {\n            return new Response(0, 'cURL extension not loaded.');\n        }\n\n        // Validate request data (implementation omitted for brevity)\n\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        // Set other cURL options (headers, timeouts, method, etc.)\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true); // Include headers in the response\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10); // Example timeout\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $errorMessage = curl_error($ch);\n            curl_close($ch);\n            return new Response(0, $errorMessage);\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($httpCode);\n    }\n}\n\n?>",
      "<?php\n\nclass Request {\n    // Request properties (e.g., headers, body)\n}\n\nclass Response {\n    public $statusCode;\n    public $errorMessage;\n\n    public function __construct($statusCode, $errorMessage = null) {\n        $this->statusCode = $statusCode;\n        $this->errorMessage = $errorMessage;\n    }\n}\n\nclass SpotlightClient {\n    public function sendRequest(Request $request, string $url): Response {\n        if (!function_exists('curl_init')) {\n            return new Response(0, 'cURL extension not loaded.');\n        }\n\n        // Validate request data (implementation omitted for brevity)\n\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        // Set other cURL options (headers, timeouts, method, etc.)\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true); // Include headers in the response\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10); // Example timeout\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $errorMessage = curl_error($ch);\n            curl_close($ch);\n            return new Response(0, $errorMessage);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($httpCode);\n    }\n}\n\n?>",
      "<?php\n\nclass Request {\n    // Request properties (e.g., headers, body)\n}\n\nclass Response {\n    public $statusCode;\n    public $errorMessage;\n\n    public function __construct($statusCode, $errorMessage = null) {\n        $this->statusCode = $statusCode;\n        $this->errorMessage = $errorMessage;\n    }\n}\n\nclass SpotlightClient {\n    public function sendRequest(Request $request, string $url): Response {\n        if (!function_exists('curl_init')) {\n            return new Response(0, 'cURL extension not loaded.');\n        }\n\n        // Validate request data (implementation omitted for brevity)\n\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        // Set other cURL options (headers, timeouts, method, etc.)\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true); // Include headers in the response\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $errorMessage = curl_error($ch);\n            curl_close($ch);\n            return new Response(0, $errorMessage);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($httpCode);\n    }\n}\n\n?>",
      "<?php\n\nclass Request {\n    // Request properties (e.g., headers, body)\n}\n\nclass Response {\n    public $statusCode;\n    public $errorMessage;\n\n    public function __construct($statusCode, $errorMessage = null) {\n        $this->statusCode = $statusCode;\n        $this->errorMessage = $errorMessage;\n    }\n}\n\nclass SpotlightClient {\n    public function sendRequest(Request $request, string $url): Response {\n        if (!function_exists('curl_init')) {\n            return new Response(0, 'cURL extension not loaded.');\n        }\n\n        // Validate request data (implementation omitted for brevity)\n\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        // Set other cURL options (headers, timeouts, method, etc.)\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true); // Include headers in the response\n        // Example timeout settings\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10); // Connection timeout in seconds\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);        // Total transaction timeout in seconds\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $errorMessage = curl_error($ch);\n            curl_close($ch);\n            return new Response(0, $errorMessage);\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($httpCode);\n    }\n}\n\n?>",
      "<?php\n\nclass Request {\n    // Request properties (e.g., headers, body)\n}\n\nclass Response {\n    public $statusCode;\n    public $errorMessage;\n\n    public function __construct($statusCode, $errorMessage = null) {\n        $this->statusCode = $statusCode;\n        $this->errorMessage = $errorMessage;\n    }\n}\n\nclass SpotlightClient {\n    public function sendRequest(Request $request, string $url): Response {\n        if (!function_exists('curl_init')) {\n            return new Response(0, 'cURL extension not loaded.');\n        }\n\n        // Validate request data (implementation omitted for brevity)\n\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        // Set other cURL options (headers, timeouts, method, etc.)\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HEADER, true); // Include headers in the response\n        // Example timeout settings\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10); // Connection timeout in seconds\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);        // Total transaction timeout in seconds\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $errorMessage = curl_error($ch);\n            curl_close($ch);\n            return new Response(0, $errorMessage);\n        }\n\n        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $header_size);\n        $body = substr($response, $header_size);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($httpCode);\n    }\n}\n\n?>",
      "<?php\n\nclass Request {\n    // Request properties (e.g., headers, body)\n}\n\nclass Response {\n    public $statusCode;\n    public $errorMessage;\n\n    public function __construct($statusCode, $errorMessage = null) {\n        $this->statusCode = $statusCode;\n        $this->errorMessage = $errorMessage;\n    }\n}\n\nclass SpotlightClient {\n    public function sendRequest(Request $request, string $url): Response {\n        if (!function_exists('curl_init')) {\n            return new Response(0, 'cURL extension not loaded.');\n        }\n\n        // Validate request data (implementation omitted for brevity)\n\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        // Set other cURL options (headers, timeouts, method, etc.)\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); // Return response as string\n        curl_setopt($ch, CURLOPT_HEADER, true);         // Include headers in response\n        // Example timeout settings\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10); // Connection timeout\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);        // Total request timeout\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            $errorMessage = curl_error($ch);\n            curl_close($ch);\n            return new Response(0, $errorMessage);\n        }\n\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headers = substr($response, 0, $headerSize);\n        $body = substr($response, $headerSize);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        curl_close($ch);\n\n        return new Response($httpCode);\n    }\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a PHP function that makes HTTP requests using cURL with support for various configurations including authentication, custom requests, and proxy settings.\n\nFunction Description: The function performs HTTP requests to a specified URL with configurable options. It supports basic authentication, Bearer token authentication, custom HTTP methods, POST requests with JSON payloads, and proxy configuration. The function handles response retrieval and error checking, returning the decoded JSON response.\n\nInput:\n- $url (string): The target URL for the HTTP request\n- $auth (bool, optional): Whether to use authentication (default: true)\n- $customRequest (string, optional): Custom HTTP method (e.g., 'PUT', 'DELETE')\n- $postFields (array, optional): Data to send in the request body (will be JSON encoded)\n\nOutput:\n- Returns the decoded JSON response from the server as a PHP object/array\n- Returns null if the response cannot be decoded as JSON",
    "Canonical_solution": "function request($url, $auth = true, $customRequest = null, $postFields = null)\n{\n    $user = Auth::user();\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 5.1; rv:31.0) Gecko/20100101 Firefox/31.0');\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_AUTOREFERER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n    if (env('PROXY_PORT')) {\n        curl_setopt($ch, CURLOPT_PROXYPORT, env('PROXY_PORT'));\n        curl_setopt($ch, CURLOPT_PROXYTYPE, env('PROXY_METHOD'));\n        curl_setopt($ch, CURLOPT_PROXY, env('PROXY_SERVER'));\n    }\n\n    if (env('PROXY_USER')) {\n        curl_setopt($ch, CURLOPT_PROXYUSERPWD, env('PROXY_USER').':'.env('PROXY_PASS'));\n    }\n\n    if (!is_null($postFields)) {\n        $postFields = json_encode($postFields);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postFields);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json',\n            'Content-Length: '.strlen($postFields), ]);\n    }\n\n    if (strtolower($user->provider) == 'bitbucket') {\n        curl_setopt($ch, CURLOPT_HTTPHEADER, ['Authorization: Bearer '.$user->token]);\n    }\n\n    if (!is_null($customRequest)) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $customRequest);\n    }\n\n    if ($auth && isset($user->username) && strtolower($user->provider) != 'bitbucket') {\n        curl_setopt($ch, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);\n        curl_setopt($ch, CURLOPT_USERPWD, $user->username.':'.$user->token);\n    }\n\n    $result = curl_exec($ch);\n    curl_close($ch);\n\n    return json_decode($result);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nfunction makeHttpRequest(string $url, bool $auth = true, string $customRequest = null, array $postFields = null) {\n    $ch = curl_init($url);\n\n    $headers = [\n        'Content-Type: application/json',\n    ];\n\n    if ($auth) {\n        $headers[] = 'Authorization: Bearer <your_bearer_token>'; // Replace with your actual bearer token\n        // Or for basic authentication:\n        // curl_setopt($ch, CURLOPT_USERPWD, '<username>:<password>');\n    }\n\n    if ($customRequest) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $customRequest);\n    }\n\n    if ($postFields) {\n        $jsonData = json_encode($postFields);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $jsonData);\n    }\n\n    // Proxy configuration (optional)\n    // curl_setopt($ch, CURLOPT_PROXY, 'your_proxy_host:your_proxy_port');\n    // curl_setopt($ch, CURLOPT_PROXYUSERPWD, 'your_proxy_username:your_proxy_password');\n\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return null; // Or handle the error as needed\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        error_log('HTTP Error: ' . $httpCode);\n        // Optionally, return the raw response for error handling\n        // return ['error' => $httpCode, 'response' => $response];\n        return null;\n    }\n\n    curl_close($ch);\n\n    $decodedResponse = json_decode($response);\n\n    if (json_last_error() !== JSON_ERROR_NONE) {\n        error_log('JSON Decode Error: ' . json_last_error_msg());\n        return null;\n    }\n\n    return $decodedResponse;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, bool $auth = true, string $customRequest = null, array $postFields = null) {\n    $ch = curl_init($url);\n\n    $headers = [\n        'Content-Type: application/json',\n    ];\n\n    if ($auth) {\n        $headers[] = 'Authorization: Bearer <your_bearer_token>'; // Replace with your actual bearer token\n        // Or for Basic Auth:\n        // $headers[] = 'Authorization: Basic ' . base64_encode('<username>:<password>');\n    }\n\n    if ($customRequest) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $customRequest);\n    }\n\n    if ($postFields) {\n        $jsonData = json_encode($postFields);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $jsonData);\n    }\n\n    // Proxy configuration (optional)\n    // curl_setopt($ch, CURLOPT_PROXY, 'your_proxy_host:your_proxy_port');\n    // curl_setopt($ch, CURLOPT_PROXYUSERPWD, 'your_proxy_username:your_proxy_password');\n\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return null; // Or handle the error as needed\n    }\n\n    curl_close($ch);\n\n    if ($httpCode >= 200 && $httpCode < 300) {\n        $decodedResponse = json_decode($response);\n\n        if (json_last_error() === JSON_ERROR_NONE) {\n            return $decodedResponse;\n        } else {\n            error_log('JSON decode error: ' . json_last_error_msg());\n            return null; // Or handle the JSON error as needed\n        }\n    } else {\n        error_log('HTTP Error: ' . $httpCode);\n        return null; // Or handle the HTTP error as needed\n    }\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, bool $auth = true, string $customRequest = null, array $postFields = null) {\n    $ch = curl_init($url);\n\n    $headers = [\n        'Content-Type: application/json',\n    ];\n\n    if ($auth) {\n        $headers[] = 'Authorization: Bearer <your_bearer_token>'; // Replace with your actual bearer token\n        // Or for basic authentication:\n        // curl_setopt($ch, CURLOPT_USERPWD, '<username>:<password>');\n    }\n\n    if ($customRequest) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $customRequest);\n    }\n\n    if ($postFields) {\n        $jsonData = json_encode($postFields);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $jsonData);\n    }\n\n    // Proxy configuration (optional)\n    // curl_setopt($ch, CURLOPT_PROXY, 'your_proxy_host:your_proxy_port');\n    // curl_setopt($ch, CURLOPT_PROXYUSERPWD, 'your_proxy_username:your_proxy_password');\n\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return null; // Or handle the error as needed\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        error_log('HTTP Error: ' . $httpCode);\n        // Optionally, return the raw response for error handling\n        // return ['error' => $httpCode, 'response' => $response];\n        return null;\n    }\n\n    curl_close($ch);\n\n    $decodedResponse = json_decode($response);\n\n    if (json_last_error() !== JSON_ERROR_NONE) {\n        error_log('JSON Decode Error: ' . json_last_error_msg());\n        return null;\n    }\n\n    return $decodedResponse;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, bool $auth = true, string $customRequest = null, array $postFields = null) {\n    $ch = curl_init($url);\n\n    $headers = [\n        'Content-Type: application/json',\n    ];\n\n    if ($auth) {\n        $headers[] = 'Authorization: Bearer <your_bearer_token>'; // Replace with your actual bearer token\n        // Or for Basic Auth:\n        // $headers[] = 'Authorization: Basic ' . base64_encode('<username>:<password>');\n    }\n\n    if ($customRequest) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $customRequest);\n    }\n\n    if ($postFields) {\n        $jsonData = json_encode($postFields);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $jsonData);\n    }\n\n    // Proxy configuration (optional)\n    // curl_setopt($ch, CURLOPT_PROXY, 'your_proxy_host:your_proxy_port');\n    // curl_setopt($ch, CURLOPT_PROXYUSERPWD, 'your_proxy_username:your_proxy_password');\n\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return null; // Or handle the error as needed\n    }\n\n    curl_close($ch);\n\n    if ($httpCode >= 200 && $httpCode < 300) {\n        $decodedResponse = json_decode($response);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            return $decodedResponse;\n        } else {\n            error_log('JSON decode error: ' . json_last_error_msg());\n            return null; // Or handle the JSON error as needed\n        }\n    } else {\n        error_log('HTTP Error: ' . $httpCode);\n        return null; // Or handle the HTTP error as needed\n    }\n}",
      "<?php\n\nfunction makeHttpRequest(string $url, bool $auth = true, string $customRequest = null, array $postFields = null) {\n    $ch = curl_init($url);\n\n    $headers = [\n        'Content-Type: application/json',\n    ];\n\n    if ($auth) {\n        $headers[] = 'Authorization: Bearer <your_bearer_token>'; // Replace with your actual bearer token\n        // Or for Basic Auth:\n        // $headers[] = 'Authorization: Basic ' . base64_encode('<username>:<password>');\n    }\n\n    if ($customRequest) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $customRequest);\n    }\n\n    if ($postFields) {\n        $jsonData = json_encode($postFields);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $jsonData);\n    }\n\n    // Proxy configuration (optional)\n    // curl_setopt($ch, CURLOPT_PROXY, 'your_proxy_host:your_proxy_port');\n    // curl_setopt($ch, CURLOPT_PROXYUSERPWD, 'your_proxy_username:your_proxy_password');\n\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return null; // Or handle the error as needed\n    }\n\n    curl_close($ch);\n\n    if ($httpCode >= 200 && $httpCode < 300) {\n        $decodedResponse = json_decode($response);\n\n        if (json_last_error() === JSON_ERROR_NONE) {\n            return $decodedResponse;\n        } else {\n            error_log('JSON decode error: ' . json_last_error_msg());\n            return null; // Or handle the JSON error as needed\n        }\n    } else {\n        error_log('HTTP Error: ' . $httpCode);\n        return null; // Or handle the HTTP error as needed\n    }\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, bool $auth = true, string $customRequest = null, array $postFields = null) {\n    $ch = curl_init($url);\n\n    $headers = [\n        'Content-Type: application/json',\n    ];\n\n    if ($auth) {\n        $headers[] = 'Authorization: Bearer <your_bearer_token>'; // Replace with your actual bearer token\n        // Or for Basic Auth:\n        // $headers[] = 'Authorization: Basic ' . base64_encode('<username>:<password>');\n    }\n\n    if ($customRequest) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $customRequest);\n    }\n\n    if ($postFields) {\n        $jsonData = json_encode($postFields);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $jsonData);\n    }\n\n    // Proxy configuration (optional)\n    // curl_setopt($ch, CURLOPT_PROXY, 'your_proxy_host:your_proxy_port');\n    // curl_setopt($ch, CURLOPT_PROXYUSERPWD, 'your_proxy_username:your_proxy_password');\n\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return null; // Or handle the error as needed\n    }\n\n    curl_close($ch);\n\n    if ($httpCode >= 200 && $httpCode < 300) {\n        $decodedResponse = json_decode($response);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            return $decodedResponse;\n        } else {\n            error_log('JSON decode error: ' . json_last_error_msg());\n            return null;\n        }\n    } else {\n        error_log('HTTP Error: ' . $httpCode);\n        return null; // Or handle the error as needed\n    }\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, bool $auth = true, string $customRequest = null, array $postFields = null) {\n    $ch = curl_init($url);\n\n    $headers = [\n        'Content-Type: application/json',\n    ];\n\n    if ($auth) {\n        $headers[] = 'Authorization: Bearer <your_bearer_token>'; // Replace with your actual bearer token\n        // Or for basic authentication:\n        // curl_setopt($ch, CURLOPT_USERPWD, '<username>:<password>');\n    }\n\n    if ($customRequest) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $customRequest);\n    }\n\n    if ($postFields) {\n        $jsonData = json_encode($postFields);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $jsonData);\n    }\n\n    // Proxy configuration (optional)\n    // curl_setopt($ch, CURLOPT_PROXY, 'your_proxy_host:your_proxy_port');\n    // curl_setopt($ch, CURLOPT_PROXYUSERPWD, 'your_proxy_username:your_proxy_password');\n\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return null; // Or handle the error as needed\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        error_log('HTTP Error: ' . $httpCode);\n        // Optionally handle different error codes\n        return null; // Or handle the error as needed\n    }\n\n    curl_close($ch);\n\n    $decodedResponse = json_decode($response);\n\n    if (json_last_error() !== JSON_ERROR_NONE) {\n        error_log('JSON Decode Error: ' . json_last_error_msg());\n        return null;\n    }\n\n    return $decodedResponse;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, bool $auth = true, string $customRequest = null, array $postFields = null) {\n    $ch = curl_init($url);\n\n    $headers = [\n        'Content-Type: application/json',\n    ];\n\n    if ($auth) {\n        $headers[] = 'Authorization: Bearer <your_bearer_token>'; // Replace with your actual bearer token\n        // Or for Basic Auth:\n        // $headers[] = 'Authorization: Basic ' . base64_encode('<username>:<password>');\n    }\n\n    if ($customRequest) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $customRequest);\n    }\n\n    if ($postFields) {\n        $jsonData = json_encode($postFields);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $jsonData);\n    }\n\n    // Proxy configuration (optional)\n    // curl_setopt($ch, CURLOPT_PROXY, 'your_proxy_host:your_proxy_port');\n    // curl_setopt($ch, CURLOPT_PROXYUSERPWD, 'your_proxy_username:your_proxy_password');\n\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return null; // Or handle the error as needed\n    }\n\n    curl_close($ch);\n\n    if ($httpCode >= 200 && $httpCode < 300) {\n        $decodedResponse = json_decode($response);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            return $decodedResponse;\n        } else {\n            error_log('JSON decode error: ' . json_last_error_msg());\n            return null;\n        }\n    } else {\n        error_log('HTTP Error: ' . $httpCode);\n        return null; // Or handle the HTTP error as needed\n    }\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, bool $auth = true, string $customRequest = null, array $postFields = null) {\n    $ch = curl_init($url);\n\n    $headers = [\n        'Content-Type: application/json',\n    ];\n\n    if ($auth) {\n        $headers[] = 'Authorization: Bearer <your_bearer_token>'; // Replace with your actual bearer token\n        // Or for basic authentication:\n        // curl_setopt($ch, CURLOPT_USERPWD, '<username>:<password>');\n    }\n\n    if ($customRequest) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $customRequest);\n    }\n\n    if ($postFields) {\n        $jsonData = json_encode($postFields);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $jsonData);\n    }\n\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    // Proxy configuration (optional)\n    // curl_setopt($ch, CURLOPT_PROXY, 'your_proxy_host:your_proxy_port');\n    // curl_setopt($ch, CURLOPT_PROXYUSERPWD, 'your_proxy_username:your_proxy_password');\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return null; // Or handle the error as needed\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        error_log('HTTP Error: ' . $httpCode);\n        // Optionally return the raw response for error handling\n        // return ['error' => $httpCode, 'response' => $response];\n        return null;\n    }\n\n    curl_close($ch);\n\n    $decodedResponse = json_decode($response);\n\n    if (json_last_error() !== JSON_ERROR_NONE) {\n        error_log('JSON Decode Error: ' . json_last_error_msg());\n        return null;\n    }\n\n    return $decodedResponse;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, bool $auth = true, string $customRequest = null, array $postFields = null) {\n    $ch = curl_init($url);\n\n    $headers = [\n        'Content-Type: application/json',\n    ];\n\n    if ($auth) {\n        $headers[] = 'Authorization: Bearer <your_bearer_token>'; // Replace with your actual bearer token\n        // Or for basic authentication:\n        // curl_setopt($ch, CURLOPT_USERPWD, '<username>:<password>');\n    }\n\n    if ($customRequest) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $customRequest);\n    }\n\n    if ($postFields) {\n        $jsonData = json_encode($postFields);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $jsonData);\n    }\n\n    // Proxy configuration (if needed)\n    // curl_setopt($ch, CURLOPT_PROXY, 'your_proxy_host:your_proxy_port');\n    // curl_setopt($ch, CURLOPT_PROXYUSERPWD, 'your_proxy_username:your_proxy_password');\n\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n    $response = curl_exec($ch);\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return null; // Or handle the error as needed\n    }\n\n    curl_close($ch);\n\n    if ($httpCode >= 200 && $httpCode < 300) {\n        $decodedResponse = json_decode($response);\n        if (json_last_error() === JSON_ERROR_NONE) {\n            return $decodedResponse;\n        } else {\n            error_log('JSON decode error: ' . json_last_error_msg());\n            return null;\n        }\n    } else {\n        error_log('HTTP Error: ' . $httpCode);\n        return null; // Or handle the error as needed\n    }\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a set of PHP functions for making HTTP requests using cURL, including GET, POST, and HEAD methods, with configurable headers and timeouts.\n\nFunction Description: The functions provide a simple interface for making HTTP requests with cURL in PHP. They handle session initialization, option configuration, execution, and cleanup, while supporting common HTTP methods and header customization.\n\nInput:\n- For get(): \n  - $url: string - The target URL for the GET request\n  - $header: array - An array of HTTP headers to include in the request\n- For post(): \n  - $url: string - The target URL for the POST request\n  - $data: mixed - The data to send in the POST request body\n  - $header: array - An array of HTTP headers to include in the request\n- For gethead(): \n  - $url: string - The target URL for the HEAD request\n  - $header: array - An array of HTTP headers to include in the request\n\nOutput:\n- For get(): string - The response body from the GET request\n- For post(): string - The response body from the POST request\n- For gethead(): string - The response headers from the HEAD request",
    "Canonical_solution": "function get(string $url, array $header) {\n    $ch = curl_init($url);\n    curl_setopt_array($ch, [\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => 0,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HTTPHEADER => $header,\n        CURLOPT_TIMEOUT => 8,\n    ]);\n    $result = curl_exec($ch);\n    curl_close($ch);\n    return $result;\n}\n\nfunction post(string $url, $data, array $header) {\n    $ch = curl_init($url);\n    curl_setopt_array($ch, [\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => 0,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HTTPHEADER => $header,\n        CURLOPT_TIMEOUT => 8,\n        CURLOPT_POST => true,\n        CURLOPT_POSTFIELDS => $data,\n    ]);\n    $result = curl_exec($ch);\n    curl_close($ch);\n    return $result;\n}\n\nfunction gethead($url, $header) {\n    $ch = curl_init($url);\n    curl_setopt_array($ch, [\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => 0,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_HTTPHEADER => $header,\n        CURLOPT_TIMEOUT => 8,\n        CURLOPT_HEADER => true,\n        CURLOPT_NOBODY => true,\n        CURLOPT_FOLLOWLOCATION => false,\n    ]);\n    $response = curl_exec($ch);\n    $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n    curl_close($ch);\n    return substr($response, 0, $headerSize);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nfunction get($url, $header = []) {\n  return curlRequest($url, 'GET', null, $header);\n}\n\nfunction post($url, $data, $header = []) {\n  return curlRequest($url, 'POST', $data, $header);\n}\n\nfunction gethead($url, $header = []) {\n  return curlRequest($url, 'HEAD', null, $header);\n}\n\nfunction curlRequest($url, $method, $data = null, $header = []) {\n  $ch = curl_init($url);\n\n  $options = [\n    CURLOPT_RETURNTRANSFER => true,\n    CURLOPT_FOLLOWLOCATION => true,\n    CURLOPT_MAXREDIRS => 10,\n    CURLOPT_TIMEOUT => 30,\n    CURLOPT_CUSTOMREQUEST => $method,\n    CURLOPT_HTTPHEADER => $header,\n  ];\n\n  if ($method === 'POST') {\n    $options[CURLOPT_POST] = true;\n    $options[CURLOPT_POSTFIELDS] = $data;\n  }\n\n  curl_setopt_array($ch, $options);\n\n  $response = curl_exec($ch);\n\n  if (curl_errno($ch)) {\n    error_log('cURL Error: ' . curl_error($ch));\n    return false; // Or throw an exception\n  }\n\n  curl_close($ch);\n\n  return $response;\n}\n\n?>",
      "<?php\n\nfunction get($url, $header = []) {\n    return curlRequest($url, 'GET', null, $header);\n}\n\nfunction post($url, $data, $header = []) {\n    return curlRequest($url, 'POST', $data, $header);\n}\n\nfunction gethead($url, $header = []) {\n    return curlRequest($url, 'HEAD', null, $header);\n}\n\nfunction curlRequest($url, $method, $data = null, $header = []) {\n    $ch = curl_init();\n\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); // Set timeout to 30 seconds\n\n    if (!empty($header)) {\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    }\n\n    switch ($method) {\n        case 'POST':\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            break;\n        case 'HEAD':\n            curl_setopt($ch, CURLOPT_NOBODY, true);\n            break;\n        default: // GET\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'GET');\n            break;\n    }\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return false; // Or handle the error as needed\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction get($url, $header = []) {\n  return curlRequest($url, 'GET', null, $header);\n}\n\nfunction post($url, $data, $header = []) {\n  return curlRequest($url, 'POST', $data, $header);\n}\n\nfunction gethead($url, $header = []) {\n  return curlRequest($url, 'HEAD', null, $header);\n}\n\nfunction curlRequest($url, $method, $data = null, $header = []) {\n  $ch = curl_init($url);\n\n  $options = [\n    CURLOPT_RETURNTRANSFER => true,\n    CURLOPT_FOLLOWLOCATION => true,\n    CURLOPT_MAXREDIRS => 10,\n    CURLOPT_TIMEOUT => 30,\n    CURLOPT_CUSTOMREQUEST => $method\n  ];\n\n  if ($method == 'POST') {\n    $options[CURLOPT_POST] = true;\n    $options[CURLOPT_POSTFIELDS] = $data;\n  }\n\n  if (!empty($header)) {\n    $options[CURLOPT_HTTPHEADER] = $header;\n  }\n\n  curl_setopt_array($ch, $options);\n\n  $response = curl_exec($ch);\n  $error = curl_error($ch);\n\n  curl_close($ch);\n\n  if ($error) {\n    return $error; // Or throw an exception\n  }\n\n  return $response;\n}\n\n?>",
      "<?php\n\nfunction get($url, $header = []) {\n  return curlRequest($url, 'GET', null, $header);\n}\n\nfunction post($url, $data, $header = []) {\n  return curlRequest($url, 'POST', $data, $header);\n}\n\nfunction gethead($url, $header = []) {\n  return curlRequest($url, 'HEAD', null, $header);\n}\n\nfunction curlRequest($url, $method, $data = null, $header = []) {\n  $ch = curl_init($url);\n\n  $options = [\n    CURLOPT_RETURNTRANSFER => true,\n    CURLOPT_FOLLOWLOCATION => true,\n    CURLOPT_MAXREDIRS => 10,\n    CURLOPT_TIMEOUT => 30,\n    CURLOPT_CUSTOMREQUEST => $method\n  ];\n\n  if ($method == 'POST') {\n    $options[CURLOPT_POST] = true;\n    $options[CURLOPT_POSTFIELDS] = $data;\n  }\n\n  if (!empty($header)) {\n    $options[CURLOPT_HTTPHEADER] = $header;\n  }\n\n  curl_setopt_array($ch, $options);\n\n  $response = curl_exec($ch);\n  $error = curl_error($ch);\n\n  curl_close($ch);\n\n  if ($error) {\n    return $error; // Or throw an exception\n  }\n\n  return $response;\n}\n\n?>",
      "<?php\n\nfunction get($url, $header = []) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10); // Setting a timeout of 10 seconds\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n\nfunction post($url, $data, $header = []) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10); // Setting a timeout of 10 seconds\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n\nfunction gethead($url, $header = []) {\n  $ch = curl_init($url);\n  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n  curl_setopt($ch, CURLOPT_NOBODY, true); // Important for HEAD requests\n  curl_setopt($ch, CURLOPT_HEADER, true);  // Ensure headers are returned\n  curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n  curl_setopt($ch, CURLOPT_TIMEOUT, 10); // Setting a timeout of 10 seconds\n  $response = curl_exec($ch);\n  curl_close($ch);\n  return $response;\n}\n\n?>",
      "<?php\n\nfunction get($url, $header = []) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10); // Setting a timeout of 10 seconds\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n\nfunction post($url, $data, $header = []) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10); // Setting a timeout of 10 seconds\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n\nfunction gethead($url, $header = []) {\n  $ch = curl_init($url);\n  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n  curl_setopt($ch, CURLOPT_NOBODY, true);\n  curl_setopt($ch, CURLOPT_HEADER, true);\n  curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n  curl_setopt($ch, CURLOPT_TIMEOUT, 10); // Setting a timeout of 10 seconds\n  $response = curl_exec($ch);\n  curl_close($ch);\n  return $response;\n}\n\n?>",
      "<?php\n\nfunction get($url, $header = []) {\n  return curlRequest($url, 'GET', null, $header);\n}\n\nfunction post($url, $data, $header = []) {\n  return curlRequest($url, 'POST', $data, $header);\n}\n\nfunction gethead($url, $header = []) {\n  return curlRequest($url, 'HEAD', null, $header);\n}\n\nfunction curlRequest($url, $method, $data = null, $header = []) {\n  $ch = curl_init();\n\n  curl_setopt($ch, CURLOPT_URL, $url);\n  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n  curl_setopt($ch, CURLOPT_TIMEOUT, 30); // Set timeout to 30 seconds\n\n  if (!empty($header)) {\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n  }\n\n  switch ($method) {\n    case 'POST':\n      curl_setopt($ch, CURLOPT_POST, true);\n      curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n      break;\n    case 'HEAD':\n      curl_setopt($ch, CURLOPT_NOBODY, true);\n      break;\n    default: // GET\n      curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'GET');\n      break;\n  }\n\n  $response = curl_exec($ch);\n  $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n\n  if ($method === 'HEAD') {\n    $response = substr($response, 0, $header_size); // Extract headers\n  }\n\n  curl_close($ch);\n\n  return $response;\n}\n\n?>",
      "<?php\n\nfunction get($url, $header = []) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10); // Set timeout to 10 seconds\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n\nfunction post($url, $data, $header = []) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_POST, true);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10); // Set timeout to 10 seconds\n    $response = curl_exec($ch);\n    curl_close($ch);\n    return $response;\n}\n\nfunction gethead($url, $header = []) {\n  $ch = curl_init($url);\n  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n  curl_setopt($ch, CURLOPT_NOBODY, true);\n  curl_setopt($ch, CURLOPT_HEADER, true);\n  curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n  curl_setopt($ch, CURLOPT_TIMEOUT, 10); // Set timeout to 10 seconds\n  $response = curl_exec($ch);\n  curl_close($ch);\n  return $response;  \n}\n\n?>",
      "<?php\n\nfunction get($url, $header = []) {\n  return curlRequest($url, 'GET', null, $header);\n}\n\nfunction post($url, $data, $header = []) {\n  return curlRequest($url, 'POST', $data, $header);\n}\n\nfunction gethead($url, $header = []) {\n  return curlRequest($url, 'HEAD', null, $header);\n}\n\nfunction curlRequest($url, $method, $data = null, $header = []) {\n  $ch = curl_init();\n\n  curl_setopt($ch, CURLOPT_URL, $url);\n  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n  curl_setopt($ch, CURLOPT_TIMEOUT, 30); // Set timeout to 30 seconds\n\n  if (!empty($header)) {\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\n  }\n\n  switch ($method) {\n    case 'POST':\n      curl_setopt($ch, CURLOPT_POST, true);\n      curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n      break;\n    case 'HEAD':\n      curl_setopt($ch, CURLOPT_NOBODY, true);\n      break;\n    default: // GET\n      curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'GET');\n      break;\n  }\n\n  $response = curl_exec($ch);\n\n  if (curl_errno($ch)) {\n    // Handle cURL errors appropriately, e.g., log the error or throw an exception\n    error_log('cURL error: ' . curl_error($ch));\n    return false; // Or throw an exception\n  }\n\n  curl_close($ch);\n\n  return $response;\n}\n\n?>",
      "<?php\n\nfunction get($url, $header = []) {\n  return curlRequest($url, 'GET', null, $header);\n}\n\nfunction post($url, $data, $header = []) {\n  return curlRequest($url, 'POST', $data, $header);\n}\n\nfunction gethead($url, $header = []) {\n  return curlRequest($url, 'HEAD', null, $header);\n}\n\nfunction curlRequest($url, $method, $data = null, $header = []) {\n  $ch = curl_init($url);\n\n  $options = [\n    CURLOPT_RETURNTRANSFER => true,\n    CURLOPT_FOLLOWLOCATION => true,\n    CURLOPT_MAXREDIRS => 10,\n    CURLOPT_TIMEOUT => 30,\n    CURLOPT_CUSTOMREQUEST => $method\n  ];\n\n  if ($method == 'POST') {\n    $options[CURLOPT_POST] = true;\n    $options[CURLOPT_POSTFIELDS] = $data;\n  }\n\n  if (!empty($header)) {\n    $options[CURLOPT_HTTPHEADER] = $header;\n  }\n\n  curl_setopt_array($ch, $options);\n\n  $response = curl_exec($ch);\n\n  if (curl_errno($ch)) {\n    error_log('cURL Error: ' . curl_error($ch));\n    return false; // Or throw an exception\n  }\n\n  if ($method == 'HEAD') {\n      $response = curl_getinfo($ch);\n  }\n\n  curl_close($ch);\n\n  return $response;\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a PHP function that makes an HTTP request using cURL with specific configurations, including custom headers and SSL verification settings.\n\nFunction Description: The function performs an HTTP GET request to a specified URL using PHP's cURL library. It includes timeout settings, custom user-agent header, disabled SSL verification (for development purposes), and follows redirects. The function returns the response content from the requested URL.\n\nInput: \n- $url (string): The target URL to which the HTTP request will be made\n\nOutput: \n- Returns the contents (string) of the HTTP response if successful\n- Returns false if the request fails (though error handling is minimal in this basic implementation)",
    "Canonical_solution": "function curl($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5000);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, array(\n        'User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4'\n    ));\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REDIR_PROTOCOLS, -1);\n    $contents = curl_exec($ch);\n    curl_close($ch);\n    return $contents;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nfunction make_http_request(string $url): string|false {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', // Custom User-Agent\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification (for development/testing)\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL verification (for development/testing)\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Basic error handling (could be improved)\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction make_http_request(string $url): string|false {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', // Custom User-Agent\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification (for development/testing)\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Basic error handling (could be improved)\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction make_http_request(string $url): string|false {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', // Custom User-Agent\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification (for development/testing)\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL host verification\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Basic error handling (could be improved)\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction make_http_request(string $url): string|false {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', // Custom User-Agent\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification (for development/testing)\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL verification (for development/testing)\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Basic error handling (more robust error handling should be implemented in production)\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction make_http_request(string $url): string|false {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', // Custom User-Agent\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification (for development/testing)\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL verification (for development/testing)\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Basic error handling (could be improved)\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction make_http_request(string $url): string|false {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', // Custom User-Agent\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification (for development/testing)\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL verification (for development/testing)\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Basic error handling (could be improved)\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction make_http_request(string $url): string|false {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_USERAGENT => 'Custom User Agent', // Set a custom user agent\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification (for development/testing)\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Basic error handling (you might want to improve this)\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction make_http_request(string $url): string|false {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_USERAGENT => 'Custom User Agent', // Set a custom user agent\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification (for development/testing)\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Basic error handling (you might want to improve this)\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction make_http_request(string $url): string|false {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_USERAGENT => 'Custom User Agent', // Set a custom user agent\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification (for development)\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Basic error handling (could be improved)\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction make_http_request(string $url): string|false {\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_USERAGENT => 'Custom User Agent', // Set a custom user agent\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification (for development/testing)\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL host verification\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Basic error handling (more robust error handling should be implemented in production)\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Implement an HTTP client class in PHP using cURL to handle HTTP requests and responses, including error handling and response parsing.\n\nClass Description: Qiniu_HttpClient is a PHP class that provides functionality to execute HTTP requests using cURL. It handles request configuration, execution, error checking, and response parsing. The class is designed to work with Qiniu's API services.\n\nAttributes: \n(None - This class doesn't have any persistent attributes)\n\nMethods:\n\nRoundTrip: RoundTrip($req) -> array - Executes an HTTP request and returns the response and error information. \nInput: \n- $req: An object containing request details (URL, headers, body, etc.)\nOutput: \n- Returns an array with two elements: \n  1. A Qiniu_Response object containing the HTTP response (status code, body, headers) \n  2. A Qiniu_Error object if an error occurred, otherwise null\n\ngetReqInfo: getReqInfo($headerContent) -> array - Helper function to extract request information from response headers.\nInput:\n- $headerContent: String containing raw HTTP response headers\nOutput:\n- Returns an array with two elements:\n  1. reqid: The X-Reqid header value\n  2. xLog: The X-Log header value",
    "Canonical_solution": "require_once(\"auth_digest.php\");\nrequire_once(\"conf.php\");\n\nclass Qiniu_HttpClient\n{\n    public function RoundTrip($req) // => ($resp, $error)\n    {\n        $ch = curl_init();\n        $url = $req->URL;\n        $options = array(\n            CURLOPT_USERAGENT => $req->UA,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_SSL_VERIFYPEER => false,\n            CURLOPT_SSL_VERIFYHOST => false,\n            CURLOPT_HEADER => true,\n            CURLOPT_NOBODY => false,\n            CURLOPT_CUSTOMREQUEST  => 'POST',\n            CURLOPT_URL => $url['path']\n        );\n        $httpHeader = $req->Header;\n        if (!empty($httpHeader))\n        {\n            $header = array();\n            foreach($httpHeader as $key => $parsedUrlValue) {\n                $header[] = \"$key: $parsedUrlValue\";\n            }\n            $options[CURLOPT_HTTPHEADER] = $header;\n        }\n        $body = $req->Body;\n        if (!empty($body)) {\n            $options[CURLOPT_POSTFIELDS] = $body;\n        } else {\n            $options[CURLOPT_POSTFIELDS] = \"\";\n        }\n        curl_setopt_array($ch, $options);\n        $result = curl_exec($ch);\n        $ret = curl_errno($ch);\n        if ($ret !== 0) {\n            $err = new Qiniu_Error(0, curl_error($ch));\n            curl_close($ch);\n            return array(null, $err);\n        }\n        $code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        $contentType = curl_getinfo($ch, CURLINFO_CONTENT_TYPE);\n        curl_close($ch);\n\n        $responseArray = explode(\"\\r\\n\\r\\n\", $result);\n        $responseArraySize = sizeof($responseArray);\n        $respHeader = $responseArray[$responseArraySize-2];\n        $respBody = $responseArray[$responseArraySize-1];\n\n        list($reqid, $xLog) = getReqInfo($respHeader);\n\n        $resp = new Qiniu_Response($code, $respBody);\n        $resp->Header['Content-Type'] = $contentType;\n        $resp->Header[\"X-Reqid\"] = $reqid;\n        return array($resp, null);\n    }\n}\n\nfunction getReqInfo($headerContent) {\n    $headers = explode(\"\\r\\n\", $headerContent);\n    $reqid = null;\n    $xLog = null;\n    foreach($headers as $header) {\n        $header = trim($header);\n        if(strpos($header, 'X-Reqid') !== false) {\n            list($k, $v) = explode(':', $header);\n            $reqid = trim($v);\n        } elseif(strpos($header, 'X-Log') !== false) {\n            list($k, $v) = explode(':', $header);\n            $xLog = trim($v);\n        }\n    }\n    return array($reqid, $xLog);\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass Qiniu_HttpClient\n{\n    public function RoundTrip($req)\n    {\n        $ch = curl_init();\n\n        // Set cURL options based on the request\n        curl_setopt($ch, CURLOPT_URL, $req->url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $req->method);\n        if ($req->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $req->body);\n        }\n\n        // Set headers\n        $headers = array();\n        foreach ($req->headers as $key => $value) {\n            $headers[] = \"$key: $value\";\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n        // Execute the request\n        $response = curl_exec($ch);\n\n        // Error handling\n        if ($error = curl_error($ch)) {\n            return array(null, new Qiniu_Error($error, curl_errno($ch)));\n        }\n\n        // Split response into headers and body\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headerContent = substr($response, 0, $headerSize);\n        $responseBody = substr($response, $headerSize);\n\n        // Close cURL resource\n        curl_close($ch);\n\n        list($reqid, $xLog) = $this->getReqInfo($headerContent);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        return array(new Qiniu_Response($statusCode, $responseBody, $reqid, $xLog), null);\n    }\n\n    public function getReqInfo($headerContent)\n    {\n        $headers = explode(\"\\r\\n\", $headerContent);\n        $reqid = null;\n        $xLog = null;\n        foreach ($headers as $header) {\n            if (strpos($header, 'X-Reqid:') === 0) {\n                $reqid = trim(substr($header, strlen('X-Reqid:')));\n            } elseif (strpos($header, 'X-Log:') === 0) {\n                $xLog = trim(substr($header, strlen('X-Log:')));\n            }\n        }\n        return array($reqid, $xLog);\n    }\n}\n\nclass Qiniu_Response {\n  public $statusCode;\n  public $body;\n  public $reqid;\n  public $xLog;\n\n  public function __construct($statusCode, $body, $reqid, $xLog) {\n    $this->statusCode = $statusCode;\n    $this->body = $body;\n    $this->reqid = $reqid;\n    $this->xLog = $xLog;\n  }\n}\n\nclass Qiniu_Error {\n    public $message;\n    public $code;\n\n    public function __construct($message, $code)\n    {\n        $this->message = $message;\n        $this->code = $code;\n    }\n}\n\n?>",
      "<?php\n\nclass Qiniu_HttpClient\n{\n    public function RoundTrip($req)\n    {\n        $ch = curl_init();\n\n        // Set cURL options based on the request\n        curl_setopt($ch, CURLOPT_URL, $req->url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $req->method);\n        if ($req->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $req->body);\n        }\n\n        // Set headers\n        $headers = [];\n        foreach ($req->headers as $key => $value) {\n            $headers[] = \"$key: $value\";\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n        // Execute the request\n        $response = curl_exec($ch);\n\n        // Error handling\n        if ($error = curl_error($ch)) {\n            return [null, new Qiniu_Error($error, curl_errno($ch))];\n        }\n\n        // Split response into headers and body\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headerContent = substr($response, 0, $headerSize);\n        $responseBody = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        // Close cURL resource\n        curl_close($ch);\n\n        list($reqid, $xLog) = $this->getReqInfo($headerContent);\n\n        $resp = new Qiniu_Response($statusCode, $responseBody, $reqid, $xLog);\n        return [$resp, null];\n    }\n\n    public function getReqInfo($headerContent)\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $headerContent) as $i => $line) {\n            if ($i === 0) {\n                continue;\n            }\n            list($key, $value) = explode(': ', $line);\n            if ($key) {\n                $headers[$key] = $value;\n            }\n        }\n\n        return [isset($headers['X-Reqid']) ? $headers['X-Reqid'] : '', isset($headers['X-Log']) ? $headers['X-Log'] : ''];\n    }\n}\n\nclass Qiniu_Response\n{\n    public $statusCode;\n    public $body;\n    public $reqid;\n    public $xLog;\n\n    public function __construct($statusCode, $body, $reqid, $xLog)\n    {\n        $this->statusCode = $statusCode;\n        $this->body = $body;\n        $this->reqid = $reqid;\n        $this->xLog = $xLog;\n    }\n}\n\nclass Qiniu_Error\n{\n    public $message;\n    public $code;\n\n    public function __construct($message, $code)\n    {\n        $this->message = $message;\n        $this->code = $code;\n    }\n}\n\n?>",
      "<?php\n\nclass Qiniu_HttpClient\n{\n    public function RoundTrip($req)\n    {\n        $ch = curl_init();\n\n        // Set cURL options based on the request\n        curl_setopt($ch, CURLOPT_URL, $req->url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $req->method);\n        if ($req->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $req->body);\n        }\n\n        // Set headers\n        $headers = array();\n        foreach ($req->headers as $key => $value) {\n            $headers[] = \"$key: $value\";\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n        // Execute the request\n        $response = curl_exec($ch);\n\n        // Error handling\n        if ($err = curl_error($ch)) {\n            return array(null, new Qiniu_Error($err, curl_errno($ch)));\n        }\n\n        // Split response into headers and body\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headerContent = substr($response, 0, $headerSize);\n        $responseBody = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        // Close cURL resource\n        curl_close($ch);\n\n        list($reqid, $xLog) = $this->getReqInfo($headerContent);\n        $resp = new Qiniu_Response($statusCode, $responseBody, $reqid, $xLog);\n        return array($resp, null);\n    }\n\n    public function getReqInfo($headerContent)\n    {\n        $headers = explode(\"\\r\\n\", $headerContent);\n        $reqid = null;\n        $xLog = null;\n        foreach ($headers as $header) {\n            if (strpos($header, 'X-Reqid:') === 0) {\n                $reqid = trim(substr($header, strlen('X-Reqid:')));\n            } elseif (strpos($header, 'X-Log:') === 0) {\n                $xLog = trim(substr($header, strlen('X-Log:')));\n            }\n        }\n        return array($reqid, $xLog);\n    }\n}\n\nclass Qiniu_Response {\n    public $statusCode;\n    public $body;\n    public $reqid;\n    public $xLog;\n\n    public function __construct($statusCode, $body, $reqid, $xLog) {\n        $this->statusCode = $statusCode;\n        $this->body = $body;\n        $this->reqid = $reqid;\n        $this->xLog = $xLog;\n    }\n}\n\nclass Qiniu_Error {\n    public $message;\n    public $code;\n\n    public function __construct($message, $code) {\n        $this->message = $message;\n        $this->code = $code;\n    }\n}\n\n?>",
      "<?php\n\nclass Qiniu_HttpClient\n{\n    public function RoundTrip($req)\n    {\n        $ch = curl_init();\n\n        // Set cURL options based on the request\n        curl_setopt($ch, CURLOPT_URL, $req->url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $req->method);\n        if ($req->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $req->body);\n        }\n\n        // Set headers\n        $headers = array();\n        foreach ($req->headers as $key => $value) {\n            $headers[] = \"$key: $value\";\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n        // Execute the request\n        $response = curl_exec($ch);\n\n        // Error handling\n        if ($error = curl_error($ch)) {\n            return array(null, new Qiniu_Error($error, curl_errno($ch)));\n        }\n\n        // Split response into headers and body\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headerContent = substr($response, 0, $headerSize);\n        $responseBody = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        // Parse headers\n        $responseHeaders = array();\n        $headerLines = explode(\"\\r\\n\", $headerContent);\n        array_shift($headerLines); // Remove the first line (HTTP/1.1 ...)\n        foreach ($headerLines as $headerLine) {\n            if (strpos($headerLine, ':') !== false) {\n                list($key, $value) = explode(':', $headerLine, 2);\n                $responseHeaders[trim($key)] = trim($value);\n            }\n        }\n\n        curl_close($ch);\n\n        list($reqid, $xLog) = $this->getReqInfo($headerContent);\n        return array(new Qiniu_Response($statusCode, $responseBody, $responseHeaders, $reqid, $xLog), null);\n    }\n\n    public function getReqInfo($headerContent)\n    {\n        $reqid = null;\n        $xLog = null;\n        if (preg_match('/X-Reqid: ([\\w-]+)/', $headerContent, $matches)) {\n            $reqid = $matches[1];\n        }\n        if (preg_match('/X-Log: (.+)/', $headerContent, $matches)) {\n            $xLog = $matches[1];\n        }\n        return array($reqid, $xLog);\n    }\n}\n\nclass Qiniu_Response {\n    public $statusCode;\n    public $body;\n    public $headers;\n    public $reqid;\n    public $xLog;\n\n    public function __construct($statusCode, $body, $headers, $reqid, $xLog) {\n        $this->statusCode = $statusCode;\n        $this->body = $body;\n        $this->headers = $headers;\n        $this->reqid = $reqid;\n        $this->xLog = $xLog;\n    }\n}\n\nclass Qiniu_Error\n{\n    public $message;\n    public $code;\n\n    public function __construct($message, $code)\n    {\n        $this->message = $message;\n        $this->code = $code;\n    }\n}\n\n?>",
      "<?php\n\nclass Qiniu_HttpClient\n{\n    public function RoundTrip($req)\n    {\n        $ch = curl_init();\n\n        // Set cURL options based on the request\n        curl_setopt($ch, CURLOPT_URL, $req->url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $req->method);\n        if ($req->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $req->body);\n        }\n\n        // Set headers\n        $headers = [];\n        foreach ($req->headers as $key => $value) {\n            $headers[] = \"$key: $value\";\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n        // Execute the request\n        $response = curl_exec($ch);\n\n        // Error handling\n        if ($err = curl_error($ch)) {\n            return [null, new Qiniu_Error($err, curl_errno($ch))];\n        }\n\n        // Close cURL resource\n        curl_close($ch);\n\n        // Split response into headers and body\n        list($headerContent, $body) = explode(\"\\r\\n\\r\\n\", $response, 2);\n\n        // Parse headers\n        $responseHeaders = [];\n        $headerLines = explode(\"\\r\\n\", $headerContent);\n        array_shift($headerLines); // Remove the status line\n        foreach ($headerLines as $headerLine) {\n            list($key, $value) = explode(\": \", $headerLine, 2);\n            $responseHeaders[$key] = $value;\n        }\n\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        // Create Qiniu_Response object\n        $resp = new Qiniu_Response($statusCode, $body, $responseHeaders);\n\n        // Extract request information from headers\n        list($reqid, $xLog) = $this->getReqInfo($headerContent);\n        $resp->reqid = $reqid;\n        $resp->xLog = $xLog;\n\n        return [$resp, null];\n    }\n\n    public function getReqInfo($headerContent)\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $headerContent) as $header) {\n            $parts = explode(': ', $header, 2);\n            if (count($parts) === 2) {\n                $headers[$parts[0]] = $parts[1];\n            }\n        }\n        return [isset($headers['X-Reqid']) ? $headers['X-Reqid'] : '', isset($headers['X-Log']) ? $headers['X-Log'] : ''];\n    }\n}\n\nclass Qiniu_Response {\n    public $statusCode;\n    public $body;\n    public $headers;\n    public $reqid;\n    public $xLog;\n\n    public function __construct($statusCode, $body, $headers) {\n        $this->statusCode = $statusCode;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n}\n\nclass Qiniu_Error\n{\n    public $message;\n    public $code;\n\n    public function __construct($message, $code)\n    {\n        $this->message = $message;\n        $this->code = $code;\n    }\n}\n\n?>",
      "<?php\n\nclass Qiniu_HttpClient\n{\n    public function RoundTrip($req)\n    {\n        $ch = curl_init();\n\n        // Set cURL options based on the request\n        curl_setopt($ch, CURLOPT_URL, $req->url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $req->method);\n\n        if ($req->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $req->body);\n        }\n\n        if ($req->headers) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $req->headers);\n        }\n\n        // Execute the request\n        $response = curl_exec($ch);\n\n        // Error handling\n        if ($err = curl_error($ch)) {\n            return [null, new Qiniu_Error($err, curl_errno($ch))];\n        }\n\n        // Split response into headers and body\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headerContent = substr($response, 0, $headerSize);\n        $responseBody = substr($response, $headerSize);\n\n        // Close cURL resource\n        curl_close($ch);\n\n        list($reqid, $xLog) = $this->getReqInfo($headerContent);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        // Create and return response object\n        $resp = new Qiniu_Response($statusCode, $responseBody, $reqid, $xLog);\n        return [$resp, null];\n    }\n\n    public function getReqInfo($headerContent)\n    {\n        $headers = [];\n        foreach (explode(\"\\r\\n\", $headerContent) as $i => $line) {\n            if ($i === 0) {\n                continue;\n            }\n            list($key, $value) = explode(': ', $line);\n            $headers[strtolower($key)] = $value;\n        }\n\n        return [\n            isset($headers['x-reqid']) ? $headers['x-reqid'] : '',\n            isset($headers['x-log']) ? $headers['x-log'] : '',\n        ];\n    }\n}\n\nclass Qiniu_Response\n{\n    public $statusCode;\n    public $body;\n    public $reqid;\n    public $xLog;\n\n    public function __construct($statusCode, $body, $reqid, $xLog)\n    {\n        $this->statusCode = $statusCode;\n        $this->body = $body;\n        $this->reqid = $reqid;\n        $this->xLog = $xLog;\n    }\n}\n\nclass Qiniu_Error\n{\n    public $message;\n    public $code;\n\n    public function __construct($message, $code)\n    {\n        $this->message = $message;\n        $this->code = $code;\n    }\n}",
      "<?php\n\nclass Qiniu_HttpClient\n{\n    public function RoundTrip($req)\n    {\n        $ch = curl_init();\n\n        // Set cURL options based on the request\n        curl_setopt($ch, CURLOPT_URL, $req->url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $req->method);\n        if ($req->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $req->body);\n        }\n\n        // Set headers\n        $headers = array();\n        foreach ($req->headers as $key => $value) {\n            $headers[] = \"$key: $value\";\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n        // Execute the request\n        $response = curl_exec($ch);\n\n        // Error handling\n        if ($response === false) {\n            $err = new Qiniu_Error(curl_error($ch), curl_errno($ch));\n            curl_close($ch);\n            return array(null, $err);\n        }\n\n        // Split response into headers and body\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headerContent = substr($response, 0, $headerSize);\n        $responseBody = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        // Parse headers\n        $responseHeaders = array();\n        $headerLines = explode(\"\\r\\n\", $headerContent);\n        array_shift($headerLines); // Remove the first line (HTTP/1.1 ...)\n        foreach ($headerLines as $headerLine) {\n            if (strpos($headerLine, ':') !== false) {\n                list($key, $value) = explode(':', $headerLine, 2);\n                $responseHeaders[trim($key)] = trim($value);\n            }\n        }\n\n        curl_close($ch);\n\n        $resp = new Qiniu_Response($statusCode, $responseBody, $responseHeaders);\n        return array($resp, null);\n    }\n\n    public function getReqInfo($headerContent)\n    {\n        list($reqid, $xLog) = explode(\"\\n\", $headerContent);\n        $reqid = trim(substr($reqid, strpos($reqid, ':') + 1));\n        $xLog = trim(substr($xLog, strpos($xLog, ':') + 1));\n        return array($reqid, $xLog);\n    }\n}\n\nclass Qiniu_Response {\n    public $statusCode;\n    public $body;\n    public $headers;\n\n    public function __construct($statusCode, $body, $headers) {\n        $this->statusCode = $statusCode;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n}\n\nclass Qiniu_Error {\n    public $message;\n    public $code;\n\n    public function __construct($message, $code) {\n        $this->message = $message;\n        $this->code = $code;\n    }\n}\n\n?>",
      "<?php\n\nclass Qiniu_HttpClient\n{\n    public function RoundTrip($req)\n    {\n        $ch = curl_init();\n\n        // Set cURL options based on the request\n        curl_setopt($ch, CURLOPT_URL, $req->url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $req->method);\n        if ($req->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $req->body);\n        }\n\n        // Set headers\n        $headers = array();\n        foreach ($req->headers as $key => $value) {\n            $headers[] = \"$key: $value\";\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n        // Execute the request\n        $response = curl_exec($ch);\n\n        // Error handling\n        if ($response === false) {\n            $err = new Qiniu_Error(curl_error($ch), curl_errno($ch));\n            curl_close($ch);\n            return array(null, $err);\n        }\n\n        // Split response into headers and body\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headerContent = substr($response, 0, $headerSize);\n        $responseBody = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        // Parse headers\n        $responseHeaders = array();\n        $headerLines = explode(\"\\r\\n\", $headerContent);\n        foreach ($headerLines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $responseHeaders[trim($key)] = trim($value);\n            }\n        }\n\n        curl_close($ch);\n\n        $resp = new Qiniu_Response($statusCode, $responseBody, $responseHeaders);\n        return array($resp, null);\n    }\n\n    public function getReqInfo($headerContent)\n    {\n        $headers = array();\n        $headerLines = explode(\"\\r\\n\", $headerContent);\n        foreach ($headerLines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return array(\n            'reqid' => isset($headers['X-Reqid']) ? $headers['X-Reqid'] : null,\n            'xLog' => isset($headers['X-Log']) ? $headers['X-Log'] : null,\n        );\n    }\n}\n\nclass Qiniu_Response {\n    public $statusCode;\n    public $body;\n    public $headers;\n\n    public function __construct($statusCode, $body, $headers) {\n        $this->statusCode = $statusCode;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n}\n\nclass Qiniu_Error {\n    public $message;\n    public $code;\n\n    public function __construct($message, $code) {\n        $this->message = $message;\n        $this->code = $code;\n    }\n}\n\n?>",
      "<?php\n\nclass Qiniu_HttpClient\n{\n    public function RoundTrip($req)\n    {\n        $ch = curl_init();\n\n        // Set cURL options based on the request\n        curl_setopt($ch, CURLOPT_URL, $req->url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $req->method);\n        if ($req->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $req->body);\n        }\n\n        // Set headers\n        $headers = array();\n        foreach ($req->headers as $key => $value) {\n            $headers[] = \"$key: $value\";\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n        // Execute the request\n        $response = curl_exec($ch);\n\n        // Error handling\n        if ($response === false) {\n            $err = new Qiniu_Error(curl_error($ch), curl_errno($ch));\n            curl_close($ch);\n            return array(null, $err);\n        }\n\n        // Split response into headers and body\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headerContent = substr($response, 0, $headerSize);\n        $responseBody = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        // Parse headers\n        $responseHeaders = array();\n        $headerLines = explode(\"\\r\\n\", $headerContent);\n        foreach ($headerLines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $responseHeaders[trim($key)] = trim($value);\n            }\n        }\n\n        curl_close($ch);\n\n        $resp = new Qiniu_Response($statusCode, $responseBody, $responseHeaders);\n        return array($resp, null);\n    }\n\n    public function getReqInfo($headerContent)\n    {\n        $headers = array();\n        $headerLines = explode(\"\\r\\n\", $headerContent);\n        foreach ($headerLines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n\n        $reqid = isset($headers['X-Reqid']) ? $headers['X-Reqid'] : '';\n        $xLog = isset($headers['X-Log']) ? $headers['X-Log'] : '';\n\n        return array($reqid, $xLog);\n    }\n}\n\nclass Qiniu_Response {\n    public $statusCode;\n    public $body;\n    public $headers;\n\n    public function __construct($statusCode, $body, $headers) {\n        $this->statusCode = $statusCode;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n}\n\nclass Qiniu_Error {\n    public $message;\n    public $code;\n\n    public function __construct($message, $code) {\n        $this->message = $message;\n        $this->code = $code;\n    }\n}\n\n?>",
      "<?php\n\nclass Qiniu_HttpClient\n{\n    public function RoundTrip($req)\n    {\n        $ch = curl_init();\n\n        // Set cURL options based on the request\n        curl_setopt($ch, CURLOPT_URL, $req->url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 1);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $req->method);\n        if ($req->body) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $req->body);\n        }\n\n        // Set headers\n        $headers = array();\n        foreach ($req->headers as $key => $value) {\n            $headers[] = \"$key: $value\";\n        }\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n        // Execute the request\n        $response = curl_exec($ch);\n\n        // Error handling\n        if ($response === false) {\n            $err = new Qiniu_Error(curl_error($ch), curl_errno($ch));\n            curl_close($ch);\n            return array(null, $err);\n        }\n\n        // Split response into headers and body\n        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);\n        $headerContent = substr($response, 0, $headerSize);\n        $responseBody = substr($response, $headerSize);\n        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        // Parse headers\n        $responseHeaders = array();\n        $headerLines = explode(\"\\r\\n\", $headerContent);\n        foreach ($headerLines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $responseHeaders[trim($key)] = trim($value);\n            }\n        }\n\n        curl_close($ch);\n\n        $resp = new Qiniu_Response($statusCode, $responseBody, $responseHeaders);\n        return array($resp, null);\n    }\n\n    public function getReqInfo($headerContent)\n    {\n        $headers = array();\n        $headerLines = explode(\"\\r\\n\", $headerContent);\n        foreach ($headerLines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return array(\n            'reqid' => isset($headers['X-Reqid']) ? $headers['X-Reqid'] : null,\n            'xLog' => isset($headers['X-Log']) ? $headers['X-Log'] : null,\n        );\n    }\n}\n\nclass Qiniu_Response {\n    public $statusCode;\n    public $body;\n    public $headers;\n\n    public function __construct($statusCode, $body, $headers) {\n        $this->statusCode = $statusCode;\n        $this->body = $body;\n        $this->headers = $headers;\n    }\n}\n\nclass Qiniu_Error {\n    public $message;\n    public $code;\n\n    public function __construct($message, $code) {\n        $this->message = $message;\n        $this->code = $code;\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a PHP function that extracts article information (title and cover image URL) from a WeChat public article URL using cURL and regular expressions.\n\nFunction Description: The function takes a WeChat article URL as input, fetches the HTML content using cURL, then extracts the article title and cover image URL using regular expressions. The cover image URL is processed through a third-party image service (weserv.nl) to get a standardized version. The function returns an associative array containing the extracted information and a success flag.\n\nInput: \n- $url (string): The URL of a WeChat public article (must contain 'mp.weixin.qq.com')\n\nOutput: \n- Returns an associative array with these keys:\n  - 'title' (string): Extracted article title (empty string if not found)\n  - 'cover' (string): Processed cover image URL (empty string if not found)\n  - 'success' (bool): True if both title and cover were successfully extracted",
    "Canonical_solution": "function get_wechat_article_info($url)\n{\n    $result = array(\n        'title' => '',\n        'cover' => '',\n        'success' => false\n    );\n\n    if (empty($url) || strpos($url, 'mp.weixin.qq.com') === false) {\n        return $result;\n    }\n\n    $ch = curl_init(htmlspecialchars_decode($url));\n    curl_setopt_array($ch, [\n        CURLOPT_VERBOSE => true,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko',\n    ]);\n    $response = curl_exec($ch);\n\n    preg_match('/var msg_title = \\'[\\S\\s]*?\\'.html\\\\(false\\\\);/', $response, $matches);\n    $result['title'] = empty($matches[0]) ? '' : htmlspecialchars_decode(str_replace(['var msg_title = \\'', '\\'.html(false);'], '', $matches[0]));\n    preg_match('/var msg_cdn_url = \"[\\S\\s]*?\";/', $response, $matches);\n    $result['cover'] = empty($matches[0]) ? '' : str_replace(['var msg_cdn_url = \"', '\";'], '', $matches[0]);\n    curl_close($ch);\n\n    if (!empty($result['cover'])) {\n        $result['cover'] = 'https://images.weserv.nl/?' . http_build_query([\n            'url' => $result['cover'],\n            'il' => '',\n            'we' => '',\n            'h' => 360,\n            'q' => 70,\n        ]);\n    }\n\n    $result['success'] = !empty($result['title']) && !empty($result['cover']);\n    return $result;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nfunction getWeChatArticleInfo(string $url): array\n{\n    $result = [\n        'title' => '',\n        'cover' => '',\n        'success' => false,\n    ];\n\n    if (strpos($url, 'mp.weixin.qq.com') === false) {\n        return $result;\n    }\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $html = curl_exec($ch);\n    curl_close($ch);\n\n    if ($html === false) {\n        return $result;\n    }\n\n    // Extract title\n    preg_match('/<title>(.*?)<\\/title>/', $html, $titleMatches);\n    if (!empty($titleMatches[1])) {\n        $result['title'] = trim($titleMatches[1]);\n    }\n\n    // Extract cover image\n    preg_match('/msg_cdn_url = \\\"(.*?)\\\"/', $html, $coverMatches);\n    if (!empty($coverMatches[1])) {\n        $coverUrl = $coverMatches[1];\n        $processedCoverUrl = 'https://images.weserv.nl/?url=' . urlencode($coverUrl);\n        $result['cover'] = $processedCoverUrl;\n    }\n\n    $result['success'] = !empty($result['title']) && !empty($result['cover']);\n\n    return $result;\n}\n\n?>",
      "<?php\n\nfunction getWeChatArticleInfo($url) {\n    if (strpos($url, 'mp.weixin.qq.com') === false) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $html = curl_exec($ch);\n    curl_close($ch);\n\n    if (!$html) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    preg_match('/<title>(.*?)<\\/title>/', $html, $titleMatches);\n    $title = isset($titleMatches[1]) ? trim($titleMatches[1]) : '';\n\n    preg_match('/msg_cdn_url = \\\"(.*?)\\\"/', $html, $coverMatches);\n    $cover = isset($coverMatches[1]) ? trim($coverMatches[1]) : '';\n\n    if ($cover) {\n        $cover = 'https://images.weserv.nl/?url=' . urlencode($cover);\n    }\n\n    return ['title' => $title, 'cover' => $cover, 'success' => !empty($title) && !empty($cover)];\n}\n\n?>",
      "<?php\n\nfunction getWeChatArticleInfo(string $url): array\n{\n    $result = [\n        'title' => '',\n        'cover' => '',\n        'success' => false,\n    ];\n\n    if (strpos($url, 'mp.weixin.qq.com') === false) {\n        return $result;\n    }\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $html = curl_exec($ch);\n    curl_close($ch);\n\n    if ($html === false) {\n        return $result;\n    }\n\n    // Extract title\n    preg_match('/<title>(.*?)<\\/title>/', $html, $titleMatches);\n    $result['title'] = $titleMatches[1] ?? '';\n\n    // Extract cover image\n    preg_match('/msg_cdn_url = \\\"(.*?)\\\"/', $html, $coverMatches);\n    $coverUrl = $coverMatches[1] ?? '';\n\n    if ($coverUrl) {\n        $result['cover'] = 'https://images.weserv.nl/?url=' . urlencode($coverUrl);\n    }\n\n    $result['success'] = !empty($result['title']) && !empty($result['cover']);\n\n    return $result;\n}\n\n?>",
      "<?php\n\nfunction getWeChatArticleInfo(string $url): array\n{\n    if (strpos($url, 'mp.weixin.qq.com') === false) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $html = curl_exec($ch);\n    curl_close($ch);\n\n    if (!$html) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    preg_match('/<title>(.*?)<\\/title>/', $html, $titleMatches);\n    $title = $titleMatches[1] ?? '';\n    $title = preg_replace('/\\s-\\s微信公众号文章/', '', $title);\n\n    preg_match('/msg_cdn_url = \\\"(.*?)\\\"/', $html, $coverMatches);\n    $cover = $coverMatches[1] ?? '';\n\n    if ($cover) {\n        $cover = 'https://images.weserv.nl/?url=' . urlencode($cover);\n    }\n\n    return [\n        'title' => $title,\n        'cover' => $cover,\n        'success' => !empty($title) && !empty($cover),\n    ];\n}",
      "<?php\n\nfunction getWeChatArticleInfo(string $url): array\n{\n    if (strpos($url, 'mp.weixin.qq.com') === false) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $html = curl_exec($ch);\n    curl_close($ch);\n\n    if (!$html) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    preg_match('/<title>(.*?)<\\/title>/', $html, $titleMatches);\n    $title = $titleMatches[1] ?? '';\n    $title = preg_replace('/\\s-\\s微信公众号文章/', '', $title);\n\n    preg_match('/msg_cdn_url = \\\"(.*?)\\\"/', $html, $coverMatches);\n    $cover = $coverMatches[1] ?? '';\n\n    if ($cover) {\n        $cover = 'https://images.weserv.nl/?url=' . urlencode($cover);\n    }\n\n    return [\n        'title' => $title,\n        'cover' => $cover,\n        'success' => !empty($title) && !empty($cover),\n    ];\n}\n\n?>",
      "<?php\n\nfunction getWeChatArticleInfo($url) {\n    if (strpos($url, 'mp.weixin.qq.com') === false) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $html = curl_exec($ch);\n    curl_close($ch);\n\n    if (!$html) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    preg_match('/<title>(.*?)<\\/title>/', $html, $titleMatches);\n    $title = isset($titleMatches[1]) ? trim($titleMatches[1]) : '';\n\n    preg_match('/msg_cdn_url = \\\"(.*?)\\\"/', $html, $coverMatches);\n    $cover = isset($coverMatches[1]) ? trim($coverMatches[1]) : '';\n\n    if ($cover) {\n        $cover = 'https://images.weserv.nl/?url=' . urlencode($cover);\n    }\n\n    return ['title' => $title, 'cover' => $cover, 'success' => !empty($title) && !empty($cover)];\n}\n\n?>",
      "<?php\n\nfunction getWeChatArticleInfo(string $url): array\n{\n    if (strpos($url, 'mp.weixin.qq.com') === false) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $html = curl_exec($ch);\n    curl_close($ch);\n\n    if (!$html) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    preg_match('/<title>(.*?)<\\/title>/', $html, $titleMatches);\n    $title = $titleMatches[1] ?? '';\n    $title = preg_replace('/\\s-\\s微信公众号文章/', '', $title);\n\n    preg_match('/msg_cdn_url = \\\"(.*?)\\\"/', $html, $coverMatches);\n    $cover = $coverMatches[1] ?? '';\n\n    if ($cover) {\n        $cover = 'https://images.weserv.nl/?url=' . urlencode($cover);\n    }\n\n    return [\n        'title' => $title,\n        'cover' => $cover,\n        'success' => !empty($title) && !empty($cover),\n    ];\n}",
      "<?php\n\nfunction getWeChatArticleInfo(string $url): array\n{\n    if (strpos($url, 'mp.weixin.qq.com') === false) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $html = curl_exec($ch);\n    curl_close($ch);\n\n    if (!$html) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    preg_match('/<title>(.*?)<\\/title>/', $html, $titleMatches);\n    $title = $titleMatches[1] ?? '';\n    $title = html_entity_decode($title, ENT_QUOTES | ENT_HTML5);\n\n    preg_match('/msg_cdn_url = \\\"(.*?)\\\"/', $html, $coverMatches);\n    $cover = $coverMatches[1] ?? '';\n\n    if ($cover) {\n        $cover = 'https://images.weserv.nl/?url=' . urlencode($cover);\n    }\n\n    return [\n        'title' => $title,\n        'cover' => $cover,\n        'success' => !empty($title) && !empty($cover),\n    ];\n}",
      "<?php\n\nfunction getWeChatArticleInfo($url) {\n    if (strpos($url, 'mp.weixin.qq.com') === false) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n    $html = curl_exec($ch);\n    curl_close($ch);\n\n    if (!$html) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    preg_match('/<title>(.*?)<\\/title>/', $html, $titleMatches);\n    $title = isset($titleMatches[1]) ? trim($titleMatches[1]) : '';\n\n    preg_match('/msg_cdn_url = \\\"(.*?)\\\"/', $html, $coverMatches);\n    $cover = isset($coverMatches[1]) ? trim($coverMatches[1]) : '';\n\n    if ($cover) {\n        $cover = 'https://images.weserv.nl/?url=' . urlencode($cover);\n    }\n\n    return ['title' => $title, 'cover' => $cover, 'success' => !empty($title) && !empty($cover)];\n}\n\n?>",
      "<?php\n\nfunction getWeChatArticleInfo(string $url): array\n{\n    if (strpos($url, 'mp.weixin.qq.com') === false) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $html = curl_exec($ch);\n    curl_close($ch);\n\n    if (!$html) {\n        return ['title' => '', 'cover' => '', 'success' => false];\n    }\n\n    preg_match('/<title>(.*?)<\\/title>/', $html, $titleMatches);\n    $title = $titleMatches[1] ?? '';\n    $title = preg_replace('/\\s-\\s微信公众号文章/', '', $title);\n\n    preg_match('/msg_cdn_url = \\\"(.*?)\\\"/', $html, $coverMatches);\n    $cover = $coverMatches[1] ?? '';\n\n    if ($cover) {\n        $cover = 'https://images.weserv.nl/?url=' . urlencode($cover);\n    }\n\n    return [\n        'title' => $title,\n        'cover' => $cover,\n        'success' => !empty($title) && !empty($cover),\n    ];\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a PHP class that handles HTTP requests to the OpenAI API using cURL, with support for different content types, streaming, and proxy configuration.\n\nClass Description: The OpenAi class is designed to interact with OpenAI's API by sending HTTP requests. It manages API keys, request headers, content types, and provides configuration options for timeouts, proxies, and custom URLs. The class supports both JSON and multipart/form-data content types and can handle streaming responses.\n\nAttributes:\n\nengine: [string] - Default engine for API requests (default: \"davinci\")\nmodel: [string] - Default model for text completions (default: \"text-davinci-002\")\nchatModel: [string] - Default model for chat completions (default: \"gpt-3.5-turbo\")\nheaders: [array] - Array of HTTP headers to be sent with requests\ncontentTypes: [array] - Mapping of content types to their header strings\ntimeout: [int] - Timeout for cURL requests in seconds (default: 0)\nstream_method: [object] - Callback method for handling streamed responses\ncustomUrl: [string] - Custom base URL to override the default API endpoint\nproxy: [string] - Proxy server address for requests\ncurlInfo: [array] - Information about the last cURL request\n\nMethods:\n\n__construct: [function]($OPENAI_API_KEY) -> [void] - Initializes the class with an API key and sets default headers\nsendRequest: [function](string $url, string $method, array $opts = []) -> [bool|string] - Sends an HTTP request to the specified URL with given method and options\nbaseUrl: [function](string &$url) -> [void] - Modifies the URL to use a custom base URL if configured",
    "Canonical_solution": "namespace Orhanerday\\OpenAi;\n\nuse Exception;\n\nclass OpenAi\n{\n    private string $engine = \"davinci\";\n    private string $model = \"text-davinci-002\";\n    private string $chatModel = \"gpt-3.5-turbo\";\n    private array $headers;\n    private array $contentTypes;\n    private int $timeout = 0;\n    private object $stream_method;\n    private string $customUrl = \"\";\n    private string $proxy = \"\";\n    private array $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY)\n    {\n        $this->contentTypes = [\n            \"application/json\"    => \"Content-Type: application/json\",\n            \"multipart/form-data\" => \"Content-Type: multipart/form-data\",\n        ];\n\n        $this->headers = [\n            $this->contentTypes[\"application/json\"],\n            \"Authorization: Bearer $OPENAI_API_KEY\",\n        ];\n    }\n\n    /**\n     * @param  string  $url\n     * @param  string  $method\n     * @param  array   $opts\n     * @return bool|string\n     */\n    private function sendRequest(string $url, string $method, array $opts = [])\n    {\n        $post_fields = json_encode($opts);\n\n        if (array_key_exists('file', $opts) || array_key_exists('image', $opts)) {\n            $this->headers[0] = $this->contentTypes[\"multipart/form-data\"];\n            $post_fields      = $opts;\n        } else {\n            $this->headers[0] = $this->contentTypes[\"application/json\"];\n        }\n        $curl_info = [\n            CURLOPT_URL            => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING       => '',\n            CURLOPT_MAXREDIRS      => 10,\n            CURLOPT_TIMEOUT        => $this->timeout,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_HTTP_VERSION   => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST  => $method,\n            CURLOPT_POSTFIELDS     => $post_fields,\n            CURLOPT_HTTPHEADER     => $this->headers,\n        ];\n\n        if ($opts == []) {\n            unset($curl_info[CURLOPT_POSTFIELDS]);\n        }\n\n        if (!empty($this->proxy)) {\n            $curl_info[CURLOPT_PROXY] = $this->proxy;\n        }\n\n        if (array_key_exists('stream', $opts) && $opts['stream']) {\n            $curl_info[CURLOPT_WRITEFUNCTION] = $this->stream_method;\n        }\n\n        $curl = curl_init();\n\n        curl_setopt_array($curl, $curl_info);\n        $response = curl_exec($curl);\n\n        $info           = curl_getinfo($curl);\n        $this->curlInfo = $info;\n\n        curl_close($curl);\n\n        return $response;\n    }\n\n    /**\n     * @param  string  $url\n     */\n    private function baseUrl(string &$url)\n    {\n        if ($this->customUrl != \"\") {\n            $url = str_replace(Url::ORIGIN, $this->customUrl, $url);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $headers = [];\n    public $contentTypes = [\n        \"application/json\" => \"application/json\",\n        \"multipart/form-data\" => \"multipart/form-data\"\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            \"Content-Type\" => \"application/json\",\n            \"Authorization\" => \"Bearer \" . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if (isset($opts['stream']) && $opts['stream'] === true && is_callable($this->stream_method)) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        if (!empty($this->proxy)) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        switch (strtoupper($method)) {\n            case \"POST\":\n                curl_setopt($ch, CURLOPT_POST, true);\n                curl_setopt($ch, CURLOPT_POSTFIELDS, isset($opts['body']) ? $opts['body'] : null);\n                break;\n            case \"GET\":\n                break;\n            default:\n                curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n                if (isset($opts['body'])) {\n                    curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n                }\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if ($response === false || $httpCode >= 400) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            return false;\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if (!empty($this->customUrl)) {\n            $url = $this->customUrl . substr($url, strlen(\"https://api.openai.com/\"));\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $headers = [];\n    public $contentTypes = [\n        \"application/json\" => \"application/json\",\n        \"multipart/form-data\" => \"multipart/form-data\"\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            \"Content-Type: application/json\",\n            \"Authorization: Bearer \" . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if (isset($opts['stream']) && $opts['stream'] === true) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        if ($method === \"POST\") {\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n\n            if (isset($opts['contentType']) && $opts['contentType'] === \"multipart/form-data\") {\n                $this->headers[0] = \"Content-Type: multipart/form-data\";\n                curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n            }\n        }\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if ($this->customUrl) {\n            $url = $this->customUrl . substr($url, strlen(\"https://api.openai.com/\"));\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $headers = [];\n    public $contentTypes = [\n        \"application/json\" => \"application/json\",\n        \"multipart/form-data\" => \"multipart/form-data\"\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            \"Content-Type: application/json\",\n            \"Authorization: Bearer \" . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n        $ch = curl_init($url);\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $this->headers,\n            CURLOPT_TIMEOUT => $this->timeout,\n            CURLOPT_CUSTOMREQUEST => $method\n        ]);\n\n        if (isset($opts['data'])) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['data']);\n        }\n\n        if (isset($opts['stream'])) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return $response;\n        } else {\n            return false;\n        }\n    }\n\n    public function baseUrl(string &$url) {\n        if ($this->customUrl) {\n            $url = $this->customUrl . substr($url, strlen(\"https://api.openai.com/\"));\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass OpenAi\n{\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $headers = [];\n    public $contentTypes = [\n        \"application/json\" => \"application/json\",\n        \"multipart/form-data\" => \"multipart/form-data\"\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY)\n    {\n        $this->headers = [\n            \"Content-Type: application/json\",\n            \"Authorization: Bearer \" . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = [])\n    {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if (isset($opts['stream']) && $opts['stream'] === true) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        if (!empty($this->proxy)) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        switch ($method) {\n            case \"POST\":\n                curl_setopt($ch, CURLOPT_POST, true);\n                curl_setopt($ch, CURLOPT_POSTFIELDS, isset($opts['body']) ? $opts['body'] : null);\n                break;\n            case \"GET\":\n                break;\n            default:\n                curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n                if (isset($opts['body'])) {\n                    curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n                }\n                break;\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error: ' . curl_error($ch));\n            return false;\n        }\n\n        curl_close($ch);\n\n        if ($httpCode >= 400) {\n            error_log('OpenAI API Error: HTTP Code ' . $httpCode . ', Response: ' . $response);\n            return false; // Or throw an exception\n        }\n\n        return $response;\n    }\n\n    public function baseUrl(string &$url)\n    {\n        if (!empty($this->customUrl)) {\n            $url = str_replace(\"https://api.openai.com/\", $this->customUrl, $url);\n        }\n    }\n}",
      "<?php\n\nclass OpenAi\n{\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $headers = [];\n    public $contentTypes = [\n        \"application/json\" => \"application/json\",\n        \"multipart/form-data\" => \"multipart/form-data\"\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY)\n    {\n        $this->headers = [\n            \"Content-Type: application/json\",\n            \"Authorization: Bearer \" . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = [])\n    {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n        \n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['stream']) && $opts['stream'] === true) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        switch ($method) {\n            case \"POST\":\n                curl_setopt($ch, CURLOPT_POST, true);\n                curl_setopt($ch, CURLOPT_POSTFIELDS, isset($opts['body']) ? $opts['body'] : null);\n                break;\n            case \"GET\":\n                break;\n            default:\n                curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n                break;\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            error_log('cURL Error: ' . curl_error($ch));\n            return false;\n        }\n\n        curl_close($ch);\n\n        if ($httpCode >= 400) {\n            error_log('OpenAI API Error: HTTP ' . $httpCode . ' - ' . $response);\n            return false; // Or throw an exception\n        }\n\n        return $response;\n    }\n\n    public function baseUrl(string &$url)\n    {\n        if ($this->customUrl) {\n            $url = $this->customUrl . substr($url, strlen(\"https://api.openai.com/\"));\n        }\n    }\n}",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $headers = [];\n    public $contentTypes = [\n        \"application/json\" => \"application/json\",\n        \"multipart/form-data\" => \"multipart/form-data\"\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            \"Content-Type: application/json\",\n            \"Authorization: Bearer \" . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if (isset($opts['stream']) && $opts['stream'] === true && is_callable($this->stream_method)) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        if (!empty($this->proxy)) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        switch (strtoupper($method)) {\n            case \"POST\":\n                curl_setopt($ch, CURLOPT_POST, true);\n                curl_setopt($ch, CURLOPT_POSTFIELDS, isset($opts['body']) ? $opts['body'] : null);\n                break;\n            case \"GET\":\n                break;\n            default:\n                curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n                if (isset($opts['body'])) {\n                    curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n                }\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            error_log('cURL error: ' . curl_error($ch));\n            return false; // Return false on cURL error\n        }\n\n        curl_close($ch);\n\n        if ($httpCode >= 400) {\n            error_log('OpenAI API error: HTTP ' . $httpCode . ' - ' . $response);\n            return false; // Return false on API error\n        }\n\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if (!empty($this->customUrl)) {\n            $url = str_replace(\"https://api.openai.com/\", $this->customUrl, $url);\n        }\n    }\n}",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $headers = [];\n    public $contentTypes = [\n        \"application/json\" => \"application/json\",\n        \"multipart/form-data\" => \"multipart/form-data\"\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            \"Content-Type: application/json\",\n            \"Authorization: Bearer \" . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if (isset($opts['stream']) && $opts['stream'] === true && is_callable($this->stream_method)) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        if (!empty($this->proxy)) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        switch (strtoupper($method)) {\n            case \"POST\":\n                curl_setopt($ch, CURLOPT_POST, true);\n                if (isset($opts['body'])) {\n                    curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n                    if (isset($opts['contentType']) && $opts['contentType'] === \"multipart/form-data\") {\n                        $this->headers = array_filter($this->headers, function ($header) {\n                            return strpos($header, \"Content-Type\") === false;\n                        });\n                    }\n                }\n                break;\n            case \"GET\":\n                break;\n            default:\n                curl_close($ch);\n                return false;\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if (!empty($this->customUrl)) {\n            $url = str_replace(\"https://api.openai.com/\", $this->customUrl, $url);\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $headers = [];\n    public $contentTypes = [\n        \"application/json\" => \"application/json\",\n        \"multipart/form-data\" => \"multipart/form-data\"\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo;\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            \"Content-Type: application/json\",\n            \"Authorization: Bearer \" . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n\n        if (isset($opts['stream']) && $opts['stream'] === true) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        if (isset($opts['contentType']) && isset($this->contentTypes[$opts['contentType']])) {\n            $this->headers[0] = \"Content-Type: \" . $this->contentTypes[$opts['contentType']];\n        }\n\n        if (!empty($opts['headers'])) {\n            $this->headers = array_merge($this->headers, $opts['headers']);\n        }\n\n        if ($method === \"POST\") {\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['body']);\n        }\n\n        if (!empty($this->proxy)) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if (!empty($this->customUrl)) {\n            $url = $this->customUrl . substr($url, strlen(\"https://api.openai.com/\"));\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $headers = [];\n    public $contentTypes = [\n        \"application/json\" => \"application/json\",\n        \"multipart/form-data\" => \"multipart/form-data\"\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            \"Content-Type: application/json\",\n            \"Authorization: Bearer \" . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['stream']) && $opts['stream'] === true) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        switch (strtoupper($method)) {\n            case \"POST\":\n                curl_setopt($ch, CURLOPT_POST, true);\n                if (isset($opts['data'])) {\n                    if (isset($opts['contentType']) && $opts['contentType'] === \"multipart/form-data\") {\n                        curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['data']);\n                        $this->headers = array_merge($this->headers, [\"Content-Type: multipart/form-data; boundary=\" . $opts['boundary']]);\n                    } else {\n                        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($opts['data']));\n                    }\n                }\n                break;\n            case \"GET\":\n                break;\n            default:\n                break;\n        }\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n        if (curl_errno($ch)) {\n            return false;\n        }\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if ($this->customUrl) {\n            $url = $this->customUrl . substr($url, strlen(\"https://api.openai.com/\"));\n        }\n    }\n}",
      "<?php\n\nclass OpenAi {\n    public $engine = \"davinci\";\n    public $model = \"text-davinci-002\";\n    public $chatModel = \"gpt-3.5-turbo\";\n    public $headers = [];\n    public $contentTypes = [\n        \"application/json\" => \"application/json\",\n        \"multipart/form-data\" => \"multipart/form-data\"\n    ];\n    public $timeout = 0;\n    public $stream_method;\n    public $customUrl;\n    public $proxy;\n    public $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            \"Content-Type: application/json\",\n            \"Authorization: Bearer \" . $OPENAI_API_KEY\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $this->baseUrl($url);\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n        if ($this->proxy) {\n            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        }\n\n        if (isset($opts['stream']) && $opts['stream'] === true && $this->stream_method) {\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, $this->stream_method);\n        }\n\n        switch (strtoupper($method)) {\n            case \"POST\":\n                curl_setopt($ch, CURLOPT_POST, true);\n                if (isset($opts['data'])) {\n                    if (isset($opts['contentType']) && $opts['contentType'] === \"multipart/form-data\") {\n                        curl_setopt($ch, CURLOPT_POSTFIELDS, $opts['data']);\n                        $this->headers = array_filter($this->headers, function ($header) {\n                            return strpos($header, 'Content-Type: application/json') === false;\n                        });\n                        $contentTypeHeader = \"Content-Type: \" . $this->contentTypes[$opts['contentType']];\n                        array_push($this->headers, $contentTypeHeader);\n                        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n                    } else {\n                        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($opts['data']));\n                    }\n                }\n                break;\n            case \"GET\":\n                break;\n            default:\n                break;\n        }\n        $response = curl_exec($ch);\n        $this->curlInfo = curl_getinfo($ch);\n        if (curl_errno($ch)) {\n            return false;\n        }\n        curl_close($ch);\n        return $response;\n    }\n\n    public function baseUrl(string &$url) {\n        if ($this->customUrl) {\n            $url = $this->customUrl . substr($url, strlen(\"https://api.openai.com/\"));\n        }\n    }\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a PHP function that makes an HTTP GET request to a specified URL using cURL, with custom headers and SSL verification disabled, and returns the response content.\n\nFunction Description: The function uses PHP's cURL library to perform an HTTP GET request to the Pipixia video detail API endpoint. It sets various cURL options including a custom user agent header, disables SSL verification for both peer and host, and configures connection timeout. The function returns the raw response content from the API.\n\nInput: \n- $id: string - The item ID to be appended to the API URL for fetching specific video details\n\nOutput: \n- string - The raw response content from the API call, or false if the request fails",
    "Canonical_solution": "function curl_pipiXia($id)\n{\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5000);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, array(\n        'User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4'\n    ));\n    curl_setopt($ch, CURLOPT_URL, \"https://h5.pipix.com/bds/webapi/item/detail/?item_id=\".$id);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_REDIR_PROTOCOLS, -1);\n    $contents = curl_exec($ch);\n    curl_close($ch);\n    return $contents;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nfunction getPipixiaVideoDetails($id) {\n    $url = \"https://h5.pipix.com/bds/webapi/item/detail/\";\n    $url .= $id . \"?app_id=1319\";\n\n    $ch = curl_init($url);\n\n    $headers = [\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n    ];\n\n    curl_setopt_array($ch, [\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_CONNECTTIMEOUT => 10\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        return false; // Or handle the error appropriately\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction getPipixiaVideoDetails($id) {\n    $url = \"https://h5.pipix.com/bds/webapi/item/detail/\";\n    $url .= $id . \"?app_id=1319\";\n\n    $ch = curl_init($url);\n\n    $headers = [\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n    ];\n\n    curl_setopt_array($ch, [\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_TIMEOUT => 30  //timeout in seconds\n    ]);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL error: ' . curl_error($ch));\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction getPipixiaVideoDetails($id) {\n    $url = \"https://h5.pipix.com/bds/webapi/item/detail/\";\n    $url .= $id . \"?app_id=1319\";\n\n    $ch = curl_init($url);\n\n    $headers = [\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n    ];\n\n    curl_setopt_array($ch, [\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_CONNECTTIMEOUT => 10\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        return false; // Or handle the error appropriately\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction getPipixiaVideoDetails($id) {\n    $url = \"https://h5.pipix.com/bds/webapi/item/detail/\";\n    $url .= $id . \"?app_id=1319\";\n\n    $ch = curl_init($url);\n\n    $headers = [\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n    ];\n\n    curl_setopt_array($ch, [\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_CONNECTTIMEOUT => 10\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction getPipixiaVideoDetails($id) {\n    $url = \"https://h5.pipix.com/bds/webapi/item/detail/\";\n    $url .= $id . \"?app_id=1319\";\n\n    $ch = curl_init($url);\n\n    $headers = [\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n    ];\n\n    curl_setopt_array($ch, [\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_CONNECTTIMEOUT => 10\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        return false; // Or handle the error appropriately\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction getPipixiaVideoDetails($id) {\n    $url = \"https://h5.pipix.com/bds/webapi/item/detail/\";\n    $url .= $id . \"?app_id=1319\";\n\n    $ch = curl_init($url);\n\n    $headers = [\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n    ];\n\n    curl_setopt_array($ch, [\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_CONNECTTIMEOUT => 10\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        return false; // Or handle the error appropriately\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction getPipixiaVideoDetails($id) {\n    $url = \"https://h5.pipix.com/bds/webapi/item/detail/\";\n    $url .= $id . \"?app_id=1319\";\n\n    $ch = curl_init($url);\n\n    $headers = [\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n    ];\n\n    curl_setopt_array($ch, [\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_CONNECTTIMEOUT => 10\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        return false; // Or handle the error appropriately\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction getPipixiaVideoDetails($id) {\n    $url = \"https://h5.pipix.com/bds/webapi/item/detail/\";\n    $url .= $id . \"?app_id=1319\";\n\n    $ch = curl_init($url);\n\n    $headers = [\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n    ];\n\n    curl_setopt_array($ch, [\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_TIMEOUT => 30 //timeout in seconds\n    ]);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('Curl error: ' . curl_error($ch));\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction getPipixiaVideoDetails($id) {\n    $url = \"https://h5.pipix.com/bds/webapi/item/detail/\";\n    $url .= $id . \"?app_id=1319\";\n\n    $ch = curl_init($url);\n\n    $headers = [\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n    ];\n\n    curl_setopt_array($ch, [\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_CONNECTTIMEOUT => 10\n    ]);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        return false;\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction getPipixiaVideoDetails($id) {\n    $url = \"https://h5.pipix.com/bds/webapi/item/detail/\";\n    $url .= $id . \"?app_id=1319\";\n\n    $ch = curl_init($url);\n\n    $headers = [\n        'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n    ];\n\n    curl_setopt_array($ch, [\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYHOST => false,\n        CURLOPT_SSL_VERIFYPEER => false,\n        CURLOPT_CONNECTTIMEOUT => 10\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        return false; // Or handle the error appropriately\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Create a PHP function that makes an HTTP request using cURL with specific configurations for web scraping purposes, including custom headers and SSL verification settings.\n\nFunction Description: The function `MCurl` performs an HTTP GET request to a specified URL using PHP's cURL library. It's designed for web scraping with a Baidu spider user agent, follows redirects, ignores SSL verification (for testing purposes), and returns the response body. This is particularly useful when you need to mimic a search engine crawler or bypass certain security restrictions during development.\n\nInput: \n- $url (string): The target URL to which the HTTP request will be made\n\nOutput: \n- Returns the response body (string) from the HTTP request if successful\n- Returns false if the request fails (though error handling should be added in production code)\n\nNote: The current implementation lacks proper error handling which should be added in a production environment. The SSL verification is disabled (CURLOPT_SSL_VERIFYPEER and CURLOPT_SSL_VERIFYHOST set to false) which is insecure for production use - this should only be used in development or with trusted connections.",
    "Canonical_solution": "use Typecho_Db;\nuse ReflectionClass;\n\nclass CatClaw_Action extends Widget_Abstract_Contents implements Widget_Interface_Do\n{\n    private function MCurl($url)\n    {\n        $headers[] = \"User-Agent: Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)\";\n        $curl = curl_init();\n        curl_setopt($curl, CURLOPT_URL, $url);\n        curl_setopt($curl, CURLOPT_HEADER, 0);\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n        $tmpInfo = curl_exec($curl);\n        curl_close($curl);\n        return $tmpInfo;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\nfunction MCurl($url) {\n    $curl = curl_init();\n    curl_setopt_array($curl, [\n        CURLOPT_URL => $url,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_ENCODING => \"\",\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n        CURLOPT_CUSTOMREQUEST => \"GET\",\n        CURLOPT_HTTPHEADER => [\n            \"User-Agent: Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)\",\n        ],\n        CURLOPT_SSL_VERIFYPEER => false, // Insecure - remove for production\n        CURLOPT_SSL_VERIFYHOST => false, // Insecure - remove for production\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($curl);\n    curl_close($curl);\n\n    return $response;\n}\n?>",
      "<?php\nfunction MCurl($url) {\n    $curl = curl_init();\n    curl_setopt_array($curl, [\n        CURLOPT_URL => $url,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_ENCODING => \"\",\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n        CURLOPT_CUSTOMREQUEST => \"GET\",\n        CURLOPT_HTTPHEADER => [\n            \"User-Agent: Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)\",\n        ],\n        CURLOPT_FOLLOWLOCATION => true, // Follow redirects\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL peer verification (INSECURE)\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL host verification (INSECURE)\n    ]);\n\n    $response = curl_exec($curl);\n    curl_close($curl);\n\n    return $response;\n}\n?>",
      "<?php\nfunction MCurl($url) {\n    $curl = curl_init();\n    curl_setopt_array($curl, [\n        CURLOPT_URL => $url,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_ENCODING => \"\",\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n        CURLOPT_CUSTOMREQUEST => \"GET\",\n        CURLOPT_HTTPHEADER => [\n            \"User-Agent: Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)\",\n        ],\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_SSL_VERIFYPEER => false, // Insecure, do not use in production\n        CURLOPT_SSL_VERIFYHOST => false, // Insecure, do not use in production\n    ]);\n\n    $response = curl_exec($curl);\n    curl_close($curl);\n\n    return $response;\n}\n?>",
      "<?php\n\nfunction MCurl($url) {\n    $curl = curl_init();\n    curl_setopt_array($curl, [\n        CURLOPT_URL => $url,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_ENCODING => \"\",\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n        CURLOPT_CUSTOMREQUEST => \"GET\",\n        CURLOPT_HTTPHEADER => [\n            \"User-Agent: Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)\",\n        ],\n        CURLOPT_FOLLOWLOCATION => true, // Follow redirects\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL peer verification (INSECURE - for testing only)\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL host verification (INSECURE - for testing only)\n    ]);\n\n    $response = curl_exec($curl);\n    curl_close($curl);\n\n    return $response;\n}\n\n?>",
      "<?php\nfunction MCurl($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)');\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    $result = curl_exec($ch);\n    curl_close($ch);\n    return $result;\n}\n?>",
      "<?php\nfunction MCurl($url) {\n    $curl = curl_init();\n    curl_setopt_array($curl, [\n        CURLOPT_URL => $url,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_ENCODING => \"\",\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n        CURLOPT_CUSTOMREQUEST => \"GET\",\n        CURLOPT_HTTPHEADER => [\n            \"User-Agent: Baiduspider\",\n            \"Accept: */*\",\n        ],\n        CURLOPT_SSL_VERIFYPEER => false, // Insecure, do not use in production\n        CURLOPT_SSL_VERIFYHOST => false, // Insecure, do not use in production\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($curl);\n    curl_close($curl);\n\n    return $response;\n}\n?>",
      "<?php\nfunction MCurl($url) {\n    $curl = curl_init();\n    curl_setopt_array($curl, [\n        CURLOPT_URL => $url,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_ENCODING => \"\",\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n        CURLOPT_CUSTOMREQUEST => \"GET\",\n        CURLOPT_HTTPHEADER => [\n            \"User-Agent: Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)\",\n        ],\n        CURLOPT_FOLLOWLOCATION => true, // Follow redirects\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL peer verification (INSECURE - for testing only)\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL host verification (INSECURE - for testing only)\n    ]);\n\n    $response = curl_exec($curl);\n    curl_close($curl);\n\n    return $response;\n}\n?>",
      "<?php\nfunction MCurl($url) {\n    $curl = curl_init();\n    curl_setopt_array($curl, [\n        CURLOPT_URL => $url,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_ENCODING => \"\",\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n        CURLOPT_CUSTOMREQUEST => \"GET\",\n        CURLOPT_HTTPHEADER => [\n            \"User-Agent: Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)\",\n        ],\n        CURLOPT_SSL_VERIFYPEER => false, // Insecure, do not use in production\n        CURLOPT_SSL_VERIFYHOST => false, // Insecure, do not use in production\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($curl);\n    curl_close($curl);\n\n    return $response;\n}\n?>",
      "<?php\n\nfunction MCurl($url) {\n    $curl = curl_init();\n    curl_setopt_array($curl, [\n        CURLOPT_URL => $url,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_ENCODING => \"\",\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n        CURLOPT_CUSTOMREQUEST => \"GET\",\n        CURLOPT_HTTPHEADER => [\n            \"User-Agent: Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)\",\n        ],\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_SSL_VERIFYPEER => false, // Insecure - remove for production\n        CURLOPT_SSL_VERIFYHOST => false, // Insecure - remove for production\n    ]);\n\n    $response = curl_exec($curl);\n    curl_close($curl);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction MCurl($url) {\n    $curl = curl_init();\n    curl_setopt_array($curl, [\n        CURLOPT_URL => $url,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_ENCODING => \"\",\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n        CURLOPT_CUSTOMREQUEST => \"GET\",\n        CURLOPT_HTTPHEADER => [\n            \"User-Agent: Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)\",\n        ],\n        CURLOPT_SSL_VERIFYPEER => false, // Insecure - remove for production\n        CURLOPT_SSL_VERIFYHOST => false, // Insecure - remove for production\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $response = curl_exec($curl);\n    curl_close($curl);\n\n    return $response;\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client using cURL for fetching remote resources with proper error handling and resource management.\n\nClass Description: The timthumb class provides functionality to download remote files using cURL with features like progress tracking, size limitations, and fallback to file_get_contents when cURL is unavailable. It handles various HTTP status codes and maintains error state.\n\nAttributes:\n- $curlFH: [resource|false] - File handle for writing downloaded data\n- $curlDataWritten: [int] - Tracks the amount of data written during download\n- $lastURLError: [mixed] - Stores the last error encountered during URL fetching\n\nMethods:\n- curlWrite($h, $d) -> [int] - Static callback function for cURL write operations that writes data to file and tracks bytes written. Returns bytes processed or 0 if size limit exceeded.\n  - $h: [resource] - cURL handle\n  - $d: [string] - Data chunk being written\n\n- getURL($url, $tempfile) -> [bool] - Main method to fetch a URL and save it to a temporary file. Returns true on success, false on failure.\n  - $url: [string] - URL to fetch\n  - $tempfile: [string] - Path to temporary file for storing downloaded content",
    "Canonical_solution": "Here's the extracted class-level code for the HTTP client using cURL in PHP:\n\n```php\nclass timthumb {\n    protected static $curlFH = false;\n    protected static $curlDataWritten = 0;\n    protected $lastURLError = false;\n\n    public static function curlWrite($h, $d){\n        fwrite(self::$curlFH, $d);\n        self::$curlDataWritten += strlen($d);\n        if(self::$curlDataWritten > MAX_FILE_SIZE){\n            return 0;\n        } else {\n            return strlen($d);\n        }\n    }\n\n    protected function getURL($url, $tempfile){\n        $this->lastURLError = false;\n        $url = preg_replace('/ /', '%20', $url);\n        if(function_exists('curl_init')){\n            $this->debug(3, \"Curl is installed so using it to fetch URL.\");\n            self::$curlFH = fopen($tempfile, 'w');\n            if(! self::$curlFH){\n                $this->error(\"Could not open $tempfile for writing.\");\n                return false;\n            }\n            self::$curlDataWritten = 0;\n            $this->debug(3, \"Fetching url with curl: $url\");\n            $curl = curl_init($url);\n            curl_setopt ($curl, CURLOPT_TIMEOUT, CURL_TIMEOUT);\n            curl_setopt ($curl, CURLOPT_USERAGENT, \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.122 Safari/534.30\");\n            curl_setopt ($curl, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt ($curl, CURLOPT_HEADER, 0);\n            curl_setopt ($curl, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt ($curl, CURLOPT_WRITEFUNCTION, 'timthumb::curlWrite');\n            @curl_setopt ($curl, CURLOPT_FOLLOWLOCATION, true);\n            @curl_setopt ($curl, CURLOPT_MAXREDIRS, 10);\n            \n            $curlResult = curl_exec($curl);\n            fclose(self::$curlFH);\n            $httpStatus = curl_getinfo($curl, CURLINFO_HTTP_CODE);\n            if($httpStatus == 404){\n                $this->set404();\n            }\n            if($httpStatus == 302){\n                $this->error(\"External Image is Redirecting. Try alternate image url\");\n                return false;\n            }\n            if($curlResult){\n                curl_close($curl);\n                return true;\n            } else {\n                $this->lastURLError = curl_error($curl);\n                curl_close($curl);\n                return false;\n            }\n        } else {\n            $img = @file_get_contents ($url);\n            if($img === false){\n                $err = error_get_last();\n                if(is_array($err) && $err['message']){\n                    $this->lastURLError = $err['message'];\n                } else {\n                    $this->lastURLError = $err;\n                }\n                if(preg_match('/404/', $this->lastURLError)){\n                    $this->set404();\n                }\n\n                return false;\n            }\n            if(! file_put_contents($tempfile, $img)){\n                $this->error(\"Could not write to $tempfile.\");\n                return false;\n            }\n            return true;\n        }\n    }\n}\n```",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    static function curlWrite($h, $d) {\n        $thiss = self::getInstance();\n        fwrite($thiss->curlFH, $d);\n        $written = strlen($d);\n        $thiss->curlDataWritten += $written;\n        if ($thiss->curlDataWritten > 10 * 1024 * 1024) {\n            return 0;\n        }\n        return $written;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file for writing.';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            $data = curl_exec($ch);\n            if (curl_errno($ch)) {\n                $this->lastURLError = curl_error($ch);\n                curl_close($ch);\n                fclose($this->curlFH);\n                return false;\n            }\n            $http_status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($http_status == 404) {\n                $this->lastURLError = '404 File not found.';\n            } else if ($http_status != 200 && $http_status != 304) {\n                $this->lastURLError = 'HTTP status ' . $http_status;\n            }\n            curl_close($ch);\n        } else {\n            $data = @file_get_contents($url);\n            if ($data === false) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL. Check if allow_url_fopen is enabled.';\n                fclose($this->curlFH);\n                return false;\n            }\n            fwrite($this->curlFH, $data);\n        }\n        fclose($this->curlFH);\n        return true;\n    }\n\n    private static $instance;\n\n    private function __construct() {}\n\n    public static function getInstance() {\n        if (!self::$instance) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n}\n\n?>",
      "<?php\n\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    static function curlWrite($h, $d) {\n        $fp = $h;\n        $data = $d;\n        fwrite($fp, $data);\n        $written = strlen($data);\n        $this->curlDataWritten += $written;\n        return $written;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file.';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                $this->lastURLError = 'Could not initialize cURL.';\n                fclose($this->curlFH);\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            $data = curl_exec($ch);\n\n            if (curl_errno($ch)) {\n                $this->lastURLError = curl_error($ch);\n                curl_close($ch);\n                fclose($this->curlFH);\n                return false;\n            }\n\n            $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($http_code != 200) {\n                $this->lastURLError = 'HTTP error ' . $http_code;\n                curl_close($ch);\n                fclose($this->curlFH);\n                return false;\n            }\n\n            curl_close($ch);\n            fclose($this->curlFH);\n            return true;\n        } else {\n            $this->lastURLError = 'cURL is not available. Falling back to file_get_contents.';\n            $contents = @file_get_contents($url);\n            if ($contents === false) {\n                $this->lastURLError = 'file_get_contents failed to fetch URL.';\n                fclose($this->curlFH);\n                return false;\n            }\n            fwrite($this->curlFH, $contents);\n            fclose($this->curlFH);\n            return true;\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    static function curlWrite($h, $d) {\n        $fp = $h;\n        $bytes = fwrite($fp, $d);\n        if ($bytes) {\n            $this->curlDataWritten += $bytes;\n        }\n\n        // Abort if we've exceeded the max size\n        if ($this->curlDataWritten > 10 * 1024 * 1024) {\n            return 0;\n        }\n\n        return $bytes;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch) {\n                curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n                curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n                curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n                curl_setopt($ch, CURLOPT_HEADER, false);\n                curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n                curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n                curl_exec($ch);\n\n                if (curl_errno($ch)) {\n                    $this->lastURLError = curl_error($ch);\n                    curl_close($ch);\n                    fclose($this->curlFH);\n                    return false;\n                }\n\n                $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n                if ($statusCode != 200 && $statusCode != 304) {\n                    $this->lastURLError = 'Error fetching URL: ' . $statusCode;\n                    curl_close($ch);\n                    fclose($this->curlFH);\n                    return false;\n                }\n\n                curl_close($ch);\n            }\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'Could not fetch image using file_get_contents';\n                fclose($this->curlFH);\n                return false;\n            }\n            fwrite($this->curlFH, $img);\n        }\n\n        fclose($this->curlFH);\n        return true;\n    }\n}\n\n?>",
      "<?php\n\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    static function curlWrite($h, $d) {\n        $thiss = self::getInstance();\n        fwrite($thiss->curlFH, $d);\n        $written = strlen($d);\n        $thiss->curlDataWritten += $written;\n        // 10MB max size\n        if ($thiss->curlDataWritten > (1024 * 1024 * 10)) {\n            return 0;\n        }\n        return $written;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                $this->lastURLError = 'Could not initialize cURL';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n            curl_setopt($ch, CURLOPT_HEADER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FAILONERROR, true);\n            $result = curl_exec($ch);\n            if ($result === false) {\n                $this->lastURLError = curl_error($ch);\n            }\n            curl_close($ch);\n        } else {\n            $result = file_get_contents($url);\n            if ($result === false) {\n                $this->lastURLError = 'file_get_contents failed';\n            } else {\n                fwrite($this->curlFH, $result);\n            }\n        }\n\n        fclose($this->curlFH);\n        return $result !== false;\n    }\n\n    private static $instance;\n\n    private function __construct() {}\n\n    public static function getInstance() {\n        if (!self::$instance) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n}\n\n?>",
      "<?php\n\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError;\n\n    static function curlWrite($h, $d) {\n        $thiss = $GLOBALS['_timthumb_curl_write_static_var'];\n        $limit = 10 * 1024 * 1024;\n        if ($thiss->curlDataWritten > $limit) {\n            return 0;\n        }\n        fwrite($thiss->curlFH, $d);\n        $thiss->curlDataWritten += strlen($d);\n        return strlen($d);\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file for writing.';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                $this->lastURLError = 'Could not initialize cURL.';\n                fclose($this->curlFH);\n                return false;\n            }\n            $GLOBALS['_timthumb_curl_write_static_var'] = $this;\n            curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            $data = curl_exec($ch);\n\n            if (curl_errno($ch)) {\n                $this->lastURLError = curl_error($ch);\n                fclose($this->curlFH);\n                return false;\n            }\n            $http_response_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n            if ($http_response_code != 200) {\n                $this->lastURLError = 'HTTP response code: ' . $http_response_code;\n                fclose($this->curlFH);\n                return false;\n            }\n            curl_close($ch);\n            fclose($this->curlFH);\n            return true;\n        } else {\n            $img = @file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL. Check if allow_url_fopen is enabled.';\n                fclose($this->curlFH);\n                return false;\n            }\n            fwrite($this->curlFH, $img);\n            fclose($this->curlFH);\n            return true;\n        }\n    }\n}\n\n?>",
      "<?php\n\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    static function curlWrite($h, $d) {\n        $thiss = self::getInstance();\n        fwrite($thiss->curlFH, $d);\n        $bytesWritten = strlen($d);\n        $thiss->curlDataWritten += $bytesWritten;\n        // Size limit check\n        if ($thiss->curlDataWritten > 10 * 1024 * 1024) {\n            return 0;\n        }\n        return $bytesWritten;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                $this->lastURLError = 'Could not initialize cURL';\n                fclose($this->curlFH);\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n            $result = curl_exec($ch);\n            if ($result === false) {\n                $this->lastURLError = curl_error($ch);\n            }\n            curl_close($ch);\n        } else {\n            $result = file_get_contents($url);\n            if ($result === false) {\n                $this->lastURLError = 'file_get_contents failed';\n            } else {\n                fwrite($this->curlFH, $result);\n            }\n        }\n\n        fclose($this->curlFH);\n        return ($result !== false);\n    }\n\n    private static $instance;\n\n    private function __construct() {}\n\n    public static function getInstance() {\n        if (!self::$instance) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n}\n\n?>",
      "<?php\n\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    static function curlWrite($h, $d) {\n        $fp = $h;\n        $bytes = fwrite($fp, $d);\n        if ($bytes) {\n            $this->curlDataWritten += $bytes;\n        }\n        // Abort if we go over the max allowed file size\n        if ($this->curlDataWritten > 10485760) { // 10 MB\n            return 0;\n        }\n        return $bytes;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch) {\n                curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n                curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n                curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n                curl_setopt($ch, CURLOPT_HEADER, false);\n                curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($ch, CURLOPT_FILE, $this->curlFH);\n                curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n                curl_exec($ch);\n                if (curl_errno($ch)) {\n                    $this->lastURLError = curl_error($ch);\n                    curl_close($ch);\n                    fclose($this->curlFH);\n                    return false;\n                }\n                curl_close($ch);\n            }\n        } else if (ini_get('allow_url_fopen')) {\n            // Fallback to file_get_contents()\n            $data = @file_get_contents($url);\n            if ($data === false) {\n                $this->lastURLError = 'file_get_contents could not retrieve URL';\n                fclose($this->curlFH);\n                return false;\n            }\n            fwrite($this->curlFH, $data);\n        } else {\n            $this->lastURLError = 'cURL or allow_url_fopen is required';\n            fclose($this->curlFH);\n            return false;\n        }\n\n        fclose($this->curlFH);\n        return true;\n    }\n}\n\n?>",
      "<?php\n\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    static function curlWrite($h, $d) {\n        $thiss = self::getInstance();\n        fwrite($thiss->curlFH, $d);\n        $written = strlen($d);\n        $thiss->curlDataWritten += $written;\n        if ($thiss->curlDataWritten > 10 * 1024 * 1024) {\n            return 0;\n        }\n        return $written;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                $this->lastURLError = 'Could not initialize cURL';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt($ch, CURLOPT_MAXREDIRS, 3);\n            curl_setopt($ch, CURLOPT_FAILONERROR, true);\n            $data = curl_exec($ch);\n            if ($data === false) {\n                $this->lastURLError = curl_error($ch);\n            }\n            curl_close($ch);\n        } else {\n            $data = @file_get_contents($url);\n            if ($data === false) {\n                $this->lastURLError = 'file_get_contents failed';\n            } else {\n                fwrite($this->curlFH, $data);\n            }\n        }\n\n        fclose($this->curlFH);\n        return ($data !== false);\n    }\n\n    private static $instance;\n\n    private function __construct() {}\n\n    public static function getInstance() {\n        if (!self::$instance) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n}\n\n?>",
      "<?php\n\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    static function curlWrite($h, $d) {\n        $thiss = self::getInstance();\n        fwrite($thiss->curlFH, $d);\n        $written = strlen($d);\n        $thiss->curlDataWritten += $written;\n        return $written;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file.';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            if ($ch === false) {\n                $this->lastURLError = 'Could not initialize cURL.';\n                return false;\n            }\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);\n            curl_setopt($ch, CURLOPT_HEADER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));\n            curl_setopt($ch, CURLOPT_FAILONERROR, true);\n            $result = curl_exec($ch);\n\n            if ($result === false) {\n                $this->lastURLError = curl_error($ch);\n            }\n            curl_close($ch);\n        } else {\n            $result = file_put_contents($tempfile, file_get_contents($url));\n            if ($result === false) {\n                $this->lastURLError = 'file_get_contents failed.';\n            }\n        }\n\n        fclose($this->curlFH);\n        return $result !== false;\n    }\n\n    private static $instance;\n\n    private function __construct() {}\n\n    public static function getInstance() {\n        if (self::$instance === null) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n}\n\n?>",
      "<?php\n\nclass timthumb {\n    public $curlFH;\n    public $curlDataWritten = 0;\n    public $lastURLError = false;\n\n    static function curlWrite($h, $d) {\n        $thiss = self::getInstance();\n        fwrite($thiss->curlFH, $d);\n        $written = strlen($d);\n        $thiss->curlDataWritten += $written;\n        if ($thiss->curlDataWritten > 10 * 1024 * 1024) {\n            return 0;\n        }\n        return $written;\n    }\n\n    static function getInstance() {\n        static $instance;\n        if (!isset($instance)) {\n            $instance = new timthumb();\n        }\n        return $instance;\n    }\n\n    public function getURL($url, $tempfile) {\n        $this->curlFH = fopen($tempfile, 'w');\n        if (!$this->curlFH) {\n            $this->lastURLError = 'Could not open temporary file for writing.';\n            return false;\n        }\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($url);\n            curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n            curl_setopt($ch, CURLOPT_WRITEFUNCTION, array('timthumb', 'curlWrite'));\n            curl_setopt($ch, CURLOPT_HEADER, 0);\n            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt($ch, CURLOPT_MAXREDIRS, 3);\n            curl_setopt($ch, CURLOPT_FAILONERROR, true);\n            if (curl_exec($ch)) {\n                $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n                if ($http_code == 200 || $http_code == 301 || $http_code == 302) {\n                    fclose($this->curlFH);\n                    curl_close($ch);\n                    return true;\n                }\n            }\n            if ($err = curl_error($ch)) {\n                $this->lastURLError = $err;\n            }\n            curl_close($ch);\n        } else {\n            $this->lastURLError = 'cURL not available. Using file_get_contents.';\n            $img = @file_get_contents($url);\n            if ($img === false) {\n                $this->lastURLError = 'file_get_contents could not retrieve the image.';\n                return false;\n            }\n            fwrite($this->curlFH, $img);\n        }\n        fclose($this->curlFH);\n        return true;\n    }\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a PHP class that handles webhook triggering using Guzzle HTTP client, including formatting headers and payload data, and processing responses or errors.\n\nClass Description: The WebhookService class provides functionality to trigger webhooks by sending HTTP requests to specified endpoints. It handles request configuration, response processing, and error handling.\n\nAttributes:\n- client: [Client] - Guzzle HTTP client instance used for making requests\n\nMethods:\n- __construct() -> [void] - Initializes the Guzzle HTTP client instance\n- triggerWebhook(mixed $data) -> [array] - Sends an HTTP request to the specified endpoint with formatted headers and payload\n  Parameters:\n    - $data: [mixed] - Contains request details including method, endpoint, headers, and payload\n  Returns:\n    - [array] - Response status ('success' or 'error') and content or error message\n- formatHeaders(array $headers) -> [array] - Formats headers array into key-value pairs\n  Parameters:\n    - $headers: [array] - Raw headers array to be formatted\n  Returns:\n    - [array] - Formatted headers as key-value pairs\n- formatPayload($payload) -> [array|string] - Formats payload data into key-value pairs\n  Parameters:\n    - $payload: [mixed] - Raw payload data to be formatted\n  Returns:\n    - [array|string] - Formatted payload as key-value pairs or original string if not array",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse GuzzleHttp\\Psr7\\Message;\n\nclass WebhookService\n{\n    protected Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client;\n    }\n\n    public function triggerWebhook(mixed $data): array\n    {\n        $options = [\n            'headers'     => $this->formatHeaders(json_decode($data['headers'], true)),\n            'form_params' => $this->formatPayload(json_decode($data['payload'], true)),\n        ];\n\n        try {\n            $response = $this->client->request(\n                $data['method'],\n                $data['end_point'],\n                $options,\n            );\n\n            return [\n                'status'   => 'success',\n                'response' => $response->getBody()->getContents(),\n            ];\n        } catch (RequestException $e) {\n            return [\n                'status'   => 'error',\n                'response' => $e->hasResponse() ? Message::toString($e->getResponse()) : $e->getMessage(),\n            ];\n        }\n    }\n\n    protected function formatHeaders(array $headers): array\n    {\n        $formattedHeaders = [];\n\n        foreach ($headers as $header) {\n            $formattedHeaders[$header['key']] = $header['value'];\n        }\n\n        return $formattedHeaders;\n    }\n\n    private function formatPayload($payload): array|string\n    {\n        if (! is_array($payload)) {\n            $payload = json_decode($payload, true);\n        }\n\n        $formattedPayload = [];\n\n        if (\n            isset($payload['key'])\n            && isset($payload['value'])\n        ) {\n            $formattedPayload[$payload['key']] = $payload['value'];\n        } else {\n            foreach ($payload as $item) {\n                $formattedPayload[$item['key']] = $item['value'];\n            }\n        }\n\n        return $formattedPayload;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "matched_results": [
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass WebhookService\n{\n    private $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function triggerWebhook($data)\n    {\n        try {\n            $method = $data['method'] ?? 'POST';\n            $endpoint = $data['endpoint'];\n            $headers = $this->formatHeaders($data['headers'] ?? []);\n            $payload = $this->formatPayload($data['payload'] ?? []);\n\n            $response = $this->client->request($method, $endpoint, [\n                'headers' => $headers,\n                ($method == 'GET' ? 'query' : 'json') => $payload,\n            ]);\n\n            return [\n                'status' => 'success',\n                'content' => json_decode($response->getBody(), true),\n            ];\n        } catch (\\Exception $e) {\n            return [\n                'status' => 'error',\n                'message' => $e->getMessage(),\n            ];\n        }\n    }\n\n    private function formatHeaders(array $headers)\n    {\n        return $headers;\n    }\n\n    private function formatPayload($payload)\n    {\n        return is_array($payload) ? $payload : $payload;\n    }\n}",
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass WebhookService\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function triggerWebhook(mixed $data): array\n    {\n        try {\n            $method = $data['method'] ?? 'POST';\n            $endpoint = $data['endpoint'];\n            $headers = $this->formatHeaders($data['headers'] ?? []);\n            $payload = $this->formatPayload($data['payload'] ?? []);\n\n            $response = $this->client->request($method, $endpoint, [\n                'headers' => $headers,\n                ($method == 'GET' ? 'query' : 'json') => $payload,\n            ]);\n\n            return [\n                'status' => 'success',\n                'content' => json_decode($response->getBody(), true),\n            ];\n        } catch (\\Exception $e) {\n            return [\n                'status' => 'error',\n                'message' => $e->getMessage(),\n            ];\n        }\n    }\n\n    private function formatHeaders(array $headers): array\n    {\n        return $headers;\n    }\n\n    private function formatPayload(mixed $payload): array|string\n    {\n        return is_array($payload) ? $payload : $payload;\n    }\n}",
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass WebhookService\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function triggerWebhook(mixed $data): array\n    {\n        try {\n            $method = $data['method'] ?? 'POST';\n            $endpoint = $data['endpoint'];\n            $headers = $this->formatHeaders($data['headers'] ?? []);\n            $payload = $this->formatPayload($data['payload'] ?? []);\n\n            $response = $this->client->request($method, $endpoint, [\n                'headers' => $headers,\n                ($method == 'GET' ? 'query' : 'json') => $payload,\n            ]);\n\n            return [\n                'status' => 'success',\n                'content' => json_decode($response->getBody(), true),\n            ];\n        } catch (\\Exception $e) {\n            return [\n                'status' => 'error',\n                'message' => $e->getMessage(),\n            ];\n        }\n    }\n\n    private function formatHeaders(array $headers): array\n    {\n        return $headers;\n    }\n\n    private function formatPayload(mixed $payload): mixed\n    {\n        return $payload;\n    }\n}",
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass WebhookService\n{\n    private $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function triggerWebhook($data)\n    {\n        try {\n            $method = $data['method'] ?? 'POST';\n            $endpoint = $data['endpoint'];\n            $headers = $this->formatHeaders($data['headers'] ?? []);\n            $payload = $this->formatPayload($data['payload'] ?? []);\n\n            $response = $this->client->request($method, $endpoint, [\n                'headers' => $headers,\n                ($method == 'GET' ? 'query' : 'json') => $payload,\n            ]);\n\n            return [\n                'status' => 'success',\n                'content' => json_decode($response->getBody(), true),\n            ];\n        } catch (\\Exception $e) {\n            return [\n                'status' => 'error',\n                'message' => $e->getMessage(),\n            ];\n        }\n    }\n\n    private function formatHeaders(array $headers)\n    {\n        return $headers;\n    }\n\n    private function formatPayload($payload)\n    {\n        return is_array($payload) ? $payload : $payload;\n    }\n}",
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass WebhookService\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function triggerWebhook(mixed $data): array\n    {\n        try {\n            $method = $data['method'] ?? 'POST';\n            $endpoint = $data['endpoint'];\n            $headers = $this->formatHeaders($data['headers'] ?? []);\n            $payload = $this->formatPayload($data['payload'] ?? []);\n\n            $response = $this->client->request($method, $endpoint, [\n                'headers' => $headers,\n                ($method == 'GET' ? 'query' : 'json') => $payload,\n            ]);\n\n            return [\n                'status' => 'success',\n                'content' => json_decode($response->getBody(), true),\n            ];\n        } catch (\\Exception $e) {\n            return [\n                'status' => 'error',\n                'message' => $e->getMessage(),\n            ];\n        }\n    }\n\n    private function formatHeaders(array $headers): array\n    {\n        return $headers;\n    }\n\n    private function formatPayload(mixed $payload): array|string\n    {\n        return is_array($payload) ? $payload : $payload;\n    }\n}",
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass WebhookService\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function triggerWebhook(mixed $data): array\n    {\n        try {\n            $method = $data['method'] ?? 'POST';\n            $endpoint = $data['endpoint'];\n            $headers = $this->formatHeaders($data['headers'] ?? []);\n            $payload = $this->formatPayload($data['payload'] ?? []);\n\n            $response = $this->client->request($method, $endpoint, [\n                'headers' => $headers,\n                ($method == 'GET' ? 'query' : 'json') => $payload,\n            ]);\n\n            return [\n                'status' => 'success',\n                'content' => json_decode($response->getBody(), true),\n            ];\n        } catch (\\Exception $e) {\n            return [\n                'status' => 'error',\n                'message' => $e->getMessage(),\n            ];\n        }\n    }\n\n    private function formatHeaders(array $headers): array\n    {\n        return $headers;\n    }\n\n    private function formatPayload(mixed $payload): mixed\n    {\n        return $payload;\n    }\n}",
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass WebhookService\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function triggerWebhook(mixed $data): array\n    {\n        try {\n            $method = $data['method'] ?? 'POST';\n            $endpoint = $data['endpoint'];\n            $headers = $this->formatHeaders($data['headers'] ?? []);\n            $payload = $this->formatPayload($data['payload'] ?? []);\n\n            $response = $this->client->request($method, $endpoint, [\n                'headers' => $headers,\n                ($method == 'GET' ? 'query' : 'json') => $payload,\n            ]);\n\n            return [\n                'status' => 'success',\n                'content' => json_decode($response->getBody(), true),\n            ];\n        } catch (\\Exception $e) {\n            return [\n                'status' => 'error',\n                'message' => $e->getMessage(),\n            ];\n        }\n    }\n\n    private function formatHeaders(array $headers): array\n    {\n        return $headers;\n    }\n\n    private function formatPayload(mixed $payload): mixed\n    {\n        return $payload;\n    }\n}",
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass WebhookService\n{\n    private $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function triggerWebhook($data)\n    {\n        try {\n            $method = $data['method'] ?? 'POST';\n            $endpoint = $data['endpoint'];\n            $headers = $this->formatHeaders($data['headers'] ?? []);\n            $payload = $this->formatPayload($data['payload'] ?? []);\n\n            $response = $this->client->request($method, $endpoint, [\n                'headers' => $headers,\n                ($method == 'GET' ? 'query' : 'json') => $payload,\n            ]);\n\n            return [\n                'status' => 'success',\n                'content' => json_decode($response->getBody(), true),\n            ];\n        } catch (\\Exception $e) {\n            return [\n                'status' => 'error',\n                'message' => $e->getMessage(),\n            ];\n        }\n    }\n\n    private function formatHeaders(array $headers)\n    {\n        return $headers;\n    }\n\n    private function formatPayload($payload)\n    {\n        return is_array($payload) ? $payload : $payload;\n    }\n}",
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass WebhookService\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function triggerWebhook(mixed $data): array\n    {\n        try {\n            $method = $data['method'] ?? 'POST';\n            $endpoint = $data['endpoint'];\n            $headers = $this->formatHeaders($data['headers'] ?? []);\n            $payload = $this->formatPayload($data['payload'] ?? []);\n\n            $response = $this->client->request($method, $endpoint, [\n                'headers' => $headers,\n                ($method == 'GET' ? 'query' : 'json') => $payload,\n            ]);\n\n            return [\n                'status' => 'success',\n                'content' => json_decode($response->getBody(), true),\n            ];\n        } catch (\\Exception $e) {\n            return [\n                'status' => 'error',\n                'message' => $e->getMessage(),\n            ];\n        }\n    }\n\n    private function formatHeaders(array $headers): array\n    {\n        return $headers;\n    }\n\n    private function formatPayload(mixed $payload): array|string\n    {\n        return is_array($payload) ? $payload : $payload;\n    }\n}",
      "<?php\n\nuse GuzzleHttp\\Client;\n\nclass WebhookService\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function triggerWebhook(mixed $data): array\n    {\n        try {\n            $method = $data['method'] ?? 'POST';\n            $endpoint = $data['endpoint'];\n            $headers = $this->formatHeaders($data['headers'] ?? []);\n            $payload = $this->formatPayload($data['payload'] ?? []);\n\n            $response = $this->client->request($method, $endpoint, [\n                'headers' => $headers,\n                ($method == 'GET' ? 'query' : 'json') => $payload,\n            ]);\n\n            return [\n                'status' => 'success',\n                'content' => json_decode($response->getBody(), true),\n            ];\n        } catch (\\Exception $e) {\n            return [\n                'status' => 'error',\n                'message' => $e->getMessage(),\n            ];\n        }\n    }\n\n    private function formatHeaders(array $headers): array\n    {\n        return $headers;\n    }\n\n    private function formatPayload(mixed $payload): array|string\n    {\n        return is_array($payload) ? $payload : $data['payload'];\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create a PHP function that retrieves a website's favicon.ico file from a given URL, caches it locally with a specified expiration time, and falls back to a default icon if retrieval fails or the file is not an image.\n\nFunction Description: The function attempts to fetch a favicon.ico file from a website URL, saves it to a local cache directory, and serves it with proper caching headers. If the remote favicon cannot be retrieved (invalid response, non-image content, or timeout), it falls back to a default icon. The function handles all HTTP operations via cURL and includes proper error checking and resource cleanup.\n\nInput:\n- $url: (string) The base URL of the website from which to fetch the favicon\n- $cache_time: (int) Duration in seconds for which the cached favicon should be considered valid\n- $default_ico: (string) Path to the default favicon file to use when retrieval fails\n- $basename: (string, optional) Name of the favicon file to look for (default: \"favicon.ico\")\n\nOutput:\n- The function outputs the favicon contents directly to the browser with appropriate headers\n- No explicit return value (void function)\n- Side effects: Creates/updates cache files in the designated cache directory",
    "Canonical_solution": "function pk_get_website_favicon_ico($url, $cache_time, $default_ico, $basename = \"favicon.ico\")\n{\n    $cache_filename = 'icon-'.md5($url) . '.ico';\n    $cache_file = dirname(__FILE__) . '/../cache/' . $cache_filename;\n    if (is_file($cache_file)) {\n        if (time() - filemtime($cache_file) <= $cache_time) {\n            pk_favicon_get_ico_contents($cache_file, $cache_filename);\n            return;\n        }\n    }\n    $ch = curl_init($url . '/' . $basename);\n    $ico_file = fopen($cache_file, 'w');\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 2);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FAILONERROR, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_FILE, $ico_file);\n    curl_exec($ch);\n    fclose($ico_file);\n    if (curl_getinfo($ch, CURLINFO_HTTP_CODE) != 200) {\n        curl_close($ch);\n        @unlink($cache_file);\n        pk_favicon_put_default_and_output($cache_file, $cache_filename, $default_ico);\n        return;\n    }\n    $mimeArray = explode('/', curl_getinfo($ch, CURLINFO_CONTENT_TYPE));\n    curl_close($ch);\n    if (count($mimeArray) == 0 || $mimeArray[0] != 'image') {\n        @unlink($cache_file);\n        pk_favicon_put_default_and_output($cache_file, $cache_filename, $default_ico);\n        return;\n    }\n    pk_favicon_get_ico_contents($cache_file, $cache_filename);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nfunction get_favicon($url, $cache_time, $default_ico, $basename = 'favicon.ico') {\n    $cache_dir = 'cache_favicons'; // Local cache directory\n    $cache_file = $cache_dir . '/' . md5($url) . '.ico';\n\n    if (!is_dir($cache_dir)) {\n        mkdir($cache_dir, 0755, true);\n    }\n\n    if (file_exists($cache_file) && (time() - filemtime($cache_file)) < $cache_time) {\n        // Serve from cache\n        serve_favicon($cache_file);\n    } else {\n        $favicon_url = parse_url($url, PHP_URL_SCHEME) . '://' . parse_url($url, PHP_URL_HOST) . '/' . $basename;\n        $ch = curl_init($favicon_url);\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => 5, // Timeout after 5 seconds\n            CURLOPT_FOLLOWLOCATION => true,\n        ]);\n        $favicon_data = curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($favicon_data && $http_code == 200 && getimagesizefromstring($favicon_data)) {\n            file_put_contents($cache_file, $favicon_data);\n            serve_favicon($cache_file);\n        } else {\n            // Fallback to default icon\n            serve_favicon($default_ico);\n        }\n    }\n}\n\nfunction serve_favicon($file) {\n    if (file_exists($file)) {\n        header('Content-Type: image/x-icon');\n        header('Cache-Control: public, max-age=3600'); // Cache for 1 hour\n        readfile($file);\n    } else {\n        header('HTTP/1.1 404 Not Found');\n    }\n    exit; // Terminate script after serving favicon\n}\n\n?>",
      "<?php\n\nfunction get_favicon($url, $cache_time, $default_ico, $basename = 'favicon.ico') {\n    $cache_dir = 'cache_favicons'; // Directory to store cached favicons\n    $cache_file = $cache_dir . '/' . md5($url . $basename);\n\n    if (!is_dir($cache_dir)) {\n        mkdir($cache_dir, 0755, true);\n    }\n\n    if (file_exists($cache_file) && (time() - filemtime($cache_file)) < $cache_time) {\n        // Serve from cache\n        $favicon = file_get_contents($cache_file);\n    } else {\n        $favicon_url = $url . '/' . $basename; // Construct favicon URL\n        $ch = curl_init($favicon_url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 5); // Set timeout to prevent long waits\n        $favicon = curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($http_code == 200 && @imagecreatefromstring($favicon)) { // Check if it's a valid image\n            file_put_contents($cache_file, $favicon);\n        } else {\n            $favicon = file_get_contents($default_ico);\n        }\n    }\n\n    header('Content-type: image/x-icon');\n    header('Cache-Control: public, max-age=' . $cache_time);\n    header('Expires: ' . gmdate('D, d M Y H:i:s', time() + $cache_time) . ' GMT');\n    echo $favicon;\n}\n\n?>",
      "<?php\n\nfunction get_favicon($url, $cache_time, $default_ico, $basename = 'favicon.ico') {\n    $cache_dir = 'cache_favicons'; // Directory to store cached favicons\n    $cache_file = $cache_dir . '/' . md5($url . $basename);\n\n    if (!is_dir($cache_dir)) {\n        mkdir($cache_dir, 0755, true);\n    }\n\n    if (file_exists($cache_file) && (time() - filemtime($cache_file)) < $cache_time) {\n        // Serve from cache\n        header('Content-Type: image/x-icon');\n        header('Cache-Control: public, max-age=' . $cache_time);\n        readfile($cache_file);\n        exit;\n    }\n\n    $favicon_url = $url . '/' . $basename; // Construct favicon URL\n    $ch = curl_init($favicon_url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 5, // Set timeout to 5 seconds\n        CURLOPT_FOLLOWLOCATION => true // Follow redirects\n    ]);\n\n    $favicon_data = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n\n    if ($favicon_data && $http_code == 200 && @imagecreatefromstring($favicon_data)) { // Check if valid image data\n        // Cache the favicon\n        file_put_contents($cache_file, $favicon_data);\n\n        // Serve the favicon\n        header('Content-Type: image/x-icon');\n        header('Cache-Control: public, max-age=' . $cache_time);\n        echo $favicon_data;\n        exit;\n    } else { // Use default icon if retrieval fails\n        header('Content-Type: image/x-icon');\n        header('Cache-Control: public, max-age=' . $cache_time);\n        readfile($default_ico);\n        exit;\n    }\n}\n\n?>",
      "<?php\n\nfunction get_favicon($url, $cache_time, $default_ico, $basename = 'favicon.ico') {\n    $cache_dir = 'cache_favicons'; // Directory to store cached favicons\n    $cache_file = $cache_dir . '/' . md5($url . $basename);\n\n    if (!is_dir($cache_dir)) {\n        mkdir($cache_dir, 0755, true);\n    }\n\n    if (file_exists($cache_file) && (time() - filemtime($cache_file)) < $cache_time) {\n        // Serve from cache\n        header('Content-Type: image/x-icon');\n        header('Cache-Control: public, max-age=' . $cache_time);\n        readfile($cache_file);\n        exit;\n    }\n\n    $favicon_url = $url . '/' . $basename;\n    $ch = curl_init($favicon_url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 5, // Timeout after 5 seconds\n        CURLOPT_FOLLOWLOCATION => true\n    ]);\n\n    $favicon_data = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n\n    if ($favicon_data && $http_code == 200 && @imagecreatefromstring($favicon_data)) { // Check if it's a valid image\n        file_put_contents($cache_file, $favicon_data);\n        header('Content-Type: image/x-icon');\n        header('Cache-Control: public, max-age=' . $cache_time);\n        echo $favicon_data;\n        exit;\n    } else {\n        // Fallback to default icon\n        if (file_exists($default_ico)) {\n            header('Content-Type: image/x-icon');\n            readfile($default_ico);\n            exit;\n        } else {\n            header('HTTP/1.1 404 Not Found');\n            exit;\n        }\n    }\n}\n\n?>",
      "<?php\n\nfunction get_favicon($url, $cache_time, $default_ico, $basename = 'favicon.ico') {\n    $cache_dir = 'cache_favicons'; // Directory to store cached favicons\n    $cache_file = $cache_dir . '/' . md5($url . $basename);\n\n    if (!is_dir($cache_dir)) {\n        mkdir($cache_dir, 0755, true);\n    }\n\n    if (file_exists($cache_file) && (time() - filemtime($cache_file)) < $cache_time) {\n        // Serve from cache\n        serve_favicon($cache_file);\n    } else {\n        $favicon_url = parse_url($url, PHP_URL_SCHEME) . '://' . parse_url($url, PHP_URL_HOST) . '/' . $basename;\n        $ch = curl_init($favicon_url);\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => 5, // Timeout after 5 seconds\n            CURLOPT_FOLLOWLOCATION => true,\n        ]);\n        $favicon_data = curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($favicon_data && $http_code == 200 && getimagesizefromstring($favicon_data)) {\n            // Save to cache and serve\n            file_put_contents($cache_file, $favicon_data);\n            serve_favicon($cache_file);\n        } else {\n            // Fallback to default icon\n            serve_favicon($default_ico);\n        }\n    }\n}\n\nfunction serve_favicon($file) {\n    header('Content-Type: image/x-icon');\n    header('Cache-Control: public, max-age=3600'); // Cache for 1 hour\n    readfile($file);\n    exit;\n}\n\n?>",
      "<?php\n\nfunction get_favicon($url, $cache_time, $default_ico, $basename = 'favicon.ico') {\n    $cache_dir = 'cache'; // Local cache directory\n    $cache_file = $cache_dir . '/' . md5($url) . '.ico';\n\n    if (file_exists($cache_file) && (time() - filemtime($cache_file)) < $cache_time) {\n        // Serve from cache\n        serve_favicon($cache_file);\n        return;\n    }\n\n    $favicon_url = parse_url($url, PHP_URL_SCHEME) . '://' . parse_url($url, PHP_URL_HOST) . '/' . $basename;\n    $ch = curl_init($favicon_url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 5, // Timeout after 5 seconds\n        CURLOPT_FOLLOWLOCATION => true,\n    ]);\n\n    $favicon_data = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($favicon_data === false || $http_code >= 400 || !is_image($favicon_data)) {\n        // Use default favicon if retrieval fails or content is not an image\n        serve_favicon($default_ico);\n    } else {\n        // Cache the favicon and serve it\n        if (!is_dir($cache_dir)) {\n            mkdir($cache_dir, 0755, true);\n        }\n        file_put_contents($cache_file, $favicon_data);\n        serve_favicon($cache_file);\n    }\n\n    curl_close($ch);\n}\n\nfunction is_image($data) {\n    $first_bytes = substr($data, 0, 4);\n    return ($first_bytes === '\\x89PNG' || $first_bytes === 'GIF8' || $first_bytes === '\\xff\\xd8');\n}\n\nfunction serve_favicon($file) {\n    header('Content-Type: image/x-icon');\n    header('Cache-Control: public, max-age=3600'); // Cache for 1 hour\n    readfile($file);\n}\n\n?>",
      "<?php\n\nfunction get_favicon($url, $cache_time, $default_ico, $basename = 'favicon.ico') {\n    $cache_dir = 'cache_favicons'; // Directory to store cached favicons\n    $cache_file = $cache_dir . '/' . md5($url . $basename);\n\n    if (!is_dir($cache_dir)) {\n        mkdir($cache_dir, 0755, true);\n    }\n\n    if (file_exists($cache_file) && (time() - filemtime($cache_file)) < $cache_time) {\n        // Serve from cache\n        header('Content-Type: image/x-icon');\n        header('Cache-Control: public, max-age=' . $cache_time);\n        readfile($cache_file);\n        exit;\n    }\n\n    $favicon_url = $url . '/' . $basename;\n    $ch = curl_init($favicon_url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 5, // Timeout after 5 seconds\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'\n    ]);\n\n    $favicon_data = curl_exec($ch);\n    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    curl_close($ch);\n\n    if ($favicon_data && $http_code == 200 && @imagecreatefromstring($favicon_data)) { // Check if it's a valid image\n        file_put_contents($cache_file, $favicon_data);\n        header('Content-Type: image/x-icon');\n        header('Cache-Control: public, max-age=' . $cache_time);\n        echo $favicon_data;\n        exit;\n    } else { // Fallback to default icon\n        header('Content-Type: image/x-icon');\n        header('Cache-Control: public, max-age=' . $cache_time);\n        readfile($default_ico);\n        exit;\n    }\n}\n\n?>",
      "<?php\n\nfunction get_favicon($url, $cache_time, $default_ico, $basename = 'favicon.ico') {\n    $cache_dir = 'cache_favicons'; // Directory to store cached favicons\n    $cache_file = $cache_dir . '/' . md5($url . $basename);\n\n    if (!is_dir($cache_dir)) {\n        mkdir($cache_dir, 0755, true);\n    }\n\n    if (file_exists($cache_file) && (time() - filemtime($cache_file)) < $cache_time) {\n        // Serve from cache\n        serve_favicon($cache_file);\n    } else {\n        $favicon_url = parse_url($url, PHP_URL_SCHEME) . '://' . parse_url($url, PHP_URL_HOST) . '/' . $basename;\n        $ch = curl_init($favicon_url);\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => 5, // Set a timeout\n            CURLOPT_FOLLOWLOCATION => true // Follow redirects\n        ]);\n        $favicon_data = curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($favicon_data && $http_code == 200 && getimagesizefromstring($favicon_data)) { // Check if it's a valid image\n            file_put_contents($cache_file, $favicon_data);\n            serve_favicon($cache_file);\n        } else {\n            // Fallback to default icon\n            serve_favicon($default_ico);\n        }\n    }\n}\n\nfunction serve_favicon($file) {\n    if (file_exists($file)) {\n        $file_info = finfo_open(FILEINFO_MIME_TYPE);\n        $mime_type = finfo_file($file_info, $file);\n        finfo_close($file_info);\n\n        header('Content-Type: ' . $mime_type);\n        header('Cache-Control: public, max-age=3600'); // Cache for 1 hour\n        readfile($file);\n    } else {\n        header('HTTP/1.1 404 Not Found');\n    }\n    exit; // Important: Stop further execution after serving the favicon\n}\n\n// Example usage (replace with your actual values):\nget_favicon('https://www.example.com', 86400, 'default.ico'); // Cache for 1 day\n\n?>",
      "<?php\n\nfunction get_favicon($url, $cache_time, $default_ico, $basename = 'favicon.ico') {\n    $cache_dir = 'cache_favicons'; // Directory to store cached favicons\n    $cache_file = $cache_dir . '/' . md5($url . $basename);\n\n    if (!is_dir($cache_dir)) {\n        mkdir($cache_dir, 0755, true);\n    }\n\n    if (file_exists($cache_file) && (time() - filemtime($cache_file)) < $cache_time) {\n        // Serve from cache\n        serve_favicon($cache_file);\n    } else {\n        $favicon_url = parse_url($url, PHP_URL_SCHEME) . '://' . parse_url($url, PHP_URL_HOST) . '/' . $basename;\n        $ch = curl_init($favicon_url);\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => 5, // Set timeout to 5 seconds\n            CURLOPT_FOLLOWLOCATION => true,\n        ]);\n        $favicon_data = curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($favicon_data && $http_code == 200 && getimagesizefromstring($favicon_data)) {\n            file_put_contents($cache_file, $favicon_data);\n            serve_favicon($cache_file);\n        } else {\n            // Fallback to default icon\n            serve_favicon($default_ico);\n        }\n    }\n}\n\nfunction serve_favicon($file) {\n    $mime_type = mime_content_type($file);\n    header('Content-Type: ' . $mime_type);\n    header('Cache-Control: public, max-age=3600'); // Cache for 1 hour\n    readfile($file);\n    exit;\n}\n\n?>",
      "<?php\n\nfunction get_favicon($url, $cache_time, $default_ico, $basename = 'favicon.ico') {\n    $cache_dir = 'cache_favicons'; // Directory to store cached favicons\n    $cache_file = $cache_dir . '/' . md5($url . $basename);\n\n    if (!is_dir($cache_dir)) {\n        mkdir($cache_dir, 0755, true);\n    }\n\n    if (file_exists($cache_file) && (time() - filemtime($cache_file)) < $cache_time) {\n        // Serve from cache\n        serve_favicon($cache_file);\n    } else {\n        $favicon_url = parse_url($url, PHP_URL_SCHEME) . '://' . parse_url($url, PHP_URL_HOST) . '/' . $basename;\n        $ch = curl_init($favicon_url);\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_TIMEOUT => 5, // Timeout after 5 seconds\n            CURLOPT_FOLLOWLOCATION => true,\n        ]);\n        $favicon_data = curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n\n        if ($favicon_data && $http_code == 200 && getimagesizefromstring($favicon_data)) {\n            file_put_contents($cache_file, $favicon_data);\n            serve_favicon($cache_file);\n        } else {\n            // Fallback to default icon\n            serve_favicon($default_ico);\n        }\n    }\n}\n\nfunction serve_favicon($file) {\n    if (file_exists($file)) {\n        $file_info = finfo_open(FILEINFO_MIME_TYPE);\n        $mime_type = finfo_file($file_info, $file);\n        finfo_close($file_info);\n\n        header('Content-Type: ' . $mime_type);\n        header('Cache-Control: public, max-age=3600'); // Cache for 1 hour\n        readfile($file);\n    } else {\n        header('HTTP/1.1 404 Not Found');\n    }\n    exit; // Terminate script after serving favicon\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Create a PHP class that provides HTTP client functionality using cURL for making GET requests and downloading files from URLs.\n\nClass Description: The HttpClient class encapsulates cURL functionality to perform HTTP GET requests and file downloads. It provides static methods for simple URL fetching and file downloading with proper error handling and resource management.\n\nAttributes: (This class doesn't have any attributes as it only contains static methods)\n\nMethods:\n\nMethod1: urlGet(string $url, bool $follow_location = true, int $timeout = 10) -> string|bool - Performs a GET request to the specified URL. Follows redirects by default and allows setting a timeout. Returns the response content or throws an exception on error.\n\nMethod2: fileGet(string $url, string $target) -> string|bool - Downloads a file from the specified URL and saves it to the target location. Returns the output or throws an exception on error. Uses a longer default timeout for file downloads.",
    "Canonical_solution": "namespace Froxlor\\Http;\n\nuse Exception;\nuse Froxlor\\Froxlor;\n\nclass HttpClient\n{\n    /**\n     * Executes simple GET request\n     *\n     * @param string $url\n     * @param bool $follow_location\n     * @param int $timeout\n     *\n     * @return bool|string\n     * @throws Exception\n     */\n    public static function urlGet(string $url, bool $follow_location = true, int $timeout = 10)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_USERAGENT, 'Froxlor/' . Froxlor::getVersion());\n        if ($follow_location) {\n            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        }\n        curl_setopt($ch, CURLOPT_TIMEOUT, (int)$timeout);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        $output = curl_exec($ch);\n        if ($output === false) {\n            $e = curl_error($ch);\n            curl_close($ch);\n            throw new Exception(\"Curl error: \" . $e);\n        }\n        curl_close($ch);\n        return $output;\n    }\n\n    /**\n     * Downloads and stores a file from an url\n     *\n     * @param string $url\n     * @param string $target\n     *\n     * @return bool|string\n     * @throws Exception\n     */\n    public static function fileGet(string $url, string $target)\n    {\n        $fh = fopen($target, 'w');\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_USERAGENT, 'Froxlor/' . Froxlor::getVersion());\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 50);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_FILE, $fh);\n        $output = curl_exec($ch);\n        if ($output === false) {\n            $e = curl_error($ch);\n            curl_close($ch);\n            throw new Exception(\"Curl error: \" . $e);\n        }\n        curl_close($ch);\n        return $output;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass HttpClient\n{\n    public static function urlGet(string $url, bool $follow_location = true, int $timeout = 10): string|bool\n    {\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, $follow_location);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            throw new Exception('cURL error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            throw new Exception('HTTP error: ' . $httpCode);\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function fileGet(string $url, string $target): string|bool\n    {\n        $fp = fopen($target, 'w');\n\n        if ($fp === false) {\n            throw new Exception('Failed to open file for writing: ' . $target);\n        }\n\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Longer timeout for downloads\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            throw new Exception('cURL download error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            fclose($fp);\n            throw new Exception('HTTP download error: ' . $httpCode);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return $result;\n    }\n}",
      "<?php\n\nclass HttpClient\n{\n    public static function urlGet(string $url, bool $follow_location = true, int $timeout = 10): string|bool\n    {\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, $follow_location);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            throw new Exception('cURL error: ' . curl_error($ch));\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function fileGet(string $url, string $target): string|bool\n    {\n        $fp = fopen($target, 'w');\n\n        if ($fp === false) {\n            throw new Exception('Failed to open file for writing: ' . $target);\n        }\n\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Longer timeout for downloads\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            throw new Exception('cURL download error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {            \n            fclose($fp);\n            throw new Exception(\"HTTP error $httpCode downloading file.\");\n        }\n\n        curl_close($ch);\n        fclose($fp);\n\n        return $result;\n    }\n}\n\n?>",
      "<?php\n\nclass HttpClient\n{\n    public static function urlGet(string $url, bool $follow_location = true, int $timeout = 10): string|bool\n    {\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, $follow_location);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            throw new Exception('cURL error: ' . curl_error($ch));\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function fileGet(string $url, string $target): string|bool\n    {\n        $fp = fopen($target, 'w');\n\n        if ($fp === false) {\n            throw new Exception('Failed to open file for writing: ' . $target);\n        }\n\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Longer timeout for downloads\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            throw new Exception('cURL download error: ' . curl_error($ch));\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return $result;\n    }\n}",
      "<?php\n\nclass HttpClient\n{\n    public static function urlGet(string $url, bool $follow_location = true, int $timeout = 10): string|bool\n    {\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, $follow_location);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            throw new Exception('cURL error: ' . curl_error($ch));\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function fileGet(string $url, string $target): string|bool\n    {\n        $fp = fopen($target, 'w');\n\n        if ($fp === false) {\n            throw new Exception('Failed to open file for writing: ' . $target);\n        }\n\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Longer timeout for downloads\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            throw new Exception('cURL download error: ' . curl_error($ch));\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return $result;\n    }\n}",
      "<?php\n\nclass HttpClient\n{\n    public static function urlGet(string $url, bool $follow_location = true, int $timeout = 10): string|bool\n    {\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, $follow_location);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            throw new Exception('cURL error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            throw new Exception('HTTP error: ' . $httpCode);\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function fileGet(string $url, string $target): string|bool\n    {\n        $fp = fopen($target, 'w');\n\n        if ($fp === false) {\n            throw new Exception('Failed to open file for writing: ' . $target);\n        }\n\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Longer timeout for downloads\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            throw new Exception('cURL download error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            fclose($fp);\n            throw new Exception('HTTP download error: ' . $httpCode);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return $result;\n    }\n}",
      "<?php\n\nclass HttpClient\n{\n    public static function urlGet(string $url, bool $follow_location = true, int $timeout = 10): string|bool\n    {\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, $follow_location);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            throw new Exception('cURL error: ' . curl_error($ch));\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function fileGet(string $url, string $target): string|bool\n    {\n        $fp = fopen($target, 'w');\n\n        if ($fp === false) {\n            throw new Exception('Failed to open file for writing: ' . $target);\n        }\n\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Longer timeout for downloads\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            throw new Exception('cURL download error: ' . curl_error($ch));\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return $result;\n    }\n}",
      "<?php\n\nclass HttpClient\n{\n    public static function urlGet(string $url, bool $follow_location = true, int $timeout = 10): string|bool\n    {\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, $follow_location);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            throw new Exception('cURL error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            throw new Exception('HTTP error: ' . $httpCode);\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function fileGet(string $url, string $target): string|bool\n    {\n        $fp = fopen($target, 'w');\n\n        if ($fp === false) {\n            throw new Exception('Failed to open file for writing: ' . $target);\n        }\n\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Longer timeout for downloads\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            throw new Exception('cURL download error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            fclose($fp);\n            throw new Exception('HTTP download error: ' . $httpCode);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return $result;\n    }\n}",
      "<?php\n\nclass HttpClient\n{\n    public static function urlGet(string $url, bool $follow_location = true, int $timeout = 10): string|bool\n    {\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, $follow_location);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            throw new Exception('cURL error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            throw new Exception('HTTP error: ' . $httpCode);\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function fileGet(string $url, string $target): string|bool\n    {\n        $fp = fopen($target, 'w');\n\n        if ($fp === false) {\n            throw new Exception('Failed to open file for writing: ' . $target);\n        }\n\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Longer timeout for downloads\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            throw new Exception('cURL download error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            fclose($fp);\n            throw new Exception('HTTP download error: ' . $httpCode);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return $result;\n    }\n}",
      "<?php\n\nclass HttpClient\n{\n    public static function urlGet(string $url, bool $follow_location = true, int $timeout = 10): string|bool\n    {\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, $follow_location);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            throw new Exception('cURL error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            throw new Exception('HTTP error: ' . $httpCode);\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public static function fileGet(string $url, string $target): string|bool\n    {\n        $fp = fopen($target, 'w');\n\n        if ($fp === false) {\n            throw new Exception('Failed to open file for writing: ' . $target);\n        }\n\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Longer timeout for downloads\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            throw new Exception('cURL download error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            fclose($fp);\n            throw new Exception('HTTP download error: ' . $httpCode);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return $result;\n    }\n}",
      "<?php\n\nclass HttpClient\n{\n    public static function urlGet(string $url, bool $follow_location = true, int $timeout = 10): string|bool\n    {\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, $follow_location);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n\n        $response = curl_exec($ch);\n\n        if ($response === false) {\n            throw new Exception('cURL error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            throw new Exception('HTTP error: ' . $httpCode);\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function fileGet(string $url, string $target): string|bool\n    {\n        $fp = fopen($target, 'w');\n\n        if ($fp === false) {\n            throw new Exception('Failed to open file for writing: ' . $target);\n        }\n\n        $ch = curl_init($url);\n\n        curl_setopt($ch, CURLOPT_FILE, $fp);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Longer timeout for downloads\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $result = curl_exec($ch);\n\n        if ($result === false) {\n            fclose($fp);\n            throw new Exception('cURL download error: ' . curl_error($ch));\n        }\n\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($httpCode >= 400) {\n            fclose($fp);\n            throw new Exception('HTTP download error: ' . $httpCode);\n        }\n\n        fclose($fp);\n        curl_close($ch);\n\n        return $result;\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create a PHP class that handles communication with a backend service through HTTP requests using cURL, supporting operations for task management.\n\nClass Description: The BackendService class provides methods to interact with a backend API for task management operations. It handles HTTP communication using cURL with proper error handling and response processing.\n\nAttributes:\n- None (Uses environment variables for configuration)\n\nMethods:\n- addTask(string $id) -> array - Sends a request to add a task with the given ID to the backend service. Returns an array with status and message.\n- restartTask(string $id) -> array - Sends a request to restart a task with the given ID on the backend service. Returns an array with status and message.\n- removeTask(string $id) -> array - Sends a request to remove a task with the given ID from the backend service. Returns an array with status and message.\n- setCurl(string $backendUrl, string $backendToken, string $operation, string $id) -> array - Internal method that handles the cURL request setup, execution, and response processing. Returns an array with status and message.",
    "Canonical_solution": "use Exception;\n\nclass BackendService\n{\n    public function addTask($id): array\n    {\n        $backendUrl = env('backend.api_url');\n        $backendToken = env('backend.token');\n        return $this->setCurl($backendUrl, $backendToken, \"addTask\", $id);\n    }\n\n    public function setCurl(string $backendUrl, string $backendToken, $operation, $id): array\n    {\n        if (!env('backend.enable_api')) return [\"status\" => true, \"msg\" => \"后端接口未启用\"];\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $backendUrl . \"/$operation\");\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, [\"token: $backendToken\"]);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, [\"id\" => $id]);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 5);\n        $result = curl_exec($ch);\n        $error = curl_error($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        if (!$result || $error || $httpCode != 200)\n            return [\"status\" => false, \"msg\" => \"后端接口异常\"];\n        else {\n            try {\n                $result = json_decode($result, true);\n                if (!$result[\"status\"])\n                    return [\"status\" => false, \"msg\" => $result[\"msg\"]];\n                else\n                    return [\"status\" => true, \"msg\" => $result[\"msg\"]];\n            } catch (Exception $e) {\n                return [\"status\" => false, \"msg\" => \"后端接口异常\"];\n            }\n        }\n    }\n\n    public function restartTask($id): array\n    {\n        $backendUrl = env('backend.api_url');\n        $backendToken = env('backend.token');\n        return $this->setCurl($backendUrl, $backendToken, \"restartTask\", $id);\n    }\n\n    public function removeTask($id): array\n    {\n        $backendUrl = env('backend.api_url');\n        $backendToken = env('backend.token');\n        return $this->setCurl($backendUrl, $backendToken, \"removeTask\", $id);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass BackendService {\n\n    private function setCurl(string $backendUrl, string $backendToken, string $operation, string $id): array {\n        $ch = curl_init();\n        $url = \"{$backendUrl}/{$operation}/{$id}\";\n\n        $headers = [\n            'Content-Type: application/json',\n            \"Authorization: Bearer {$backendToken}\",\n        ];\n\n        curl_setopt_array($ch, [\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => $headers,\n            CURLOPT_CUSTOMREQUEST => 'POST',\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            return ['status' => 'error', 'message' => 'cURL Error: ' . curl_error($ch)];\n        }\n        curl_close($ch);\n\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return ['status' => 'success', 'message' => $response];\n        } else {\n            return ['status' => 'error', 'message' => \"Backend API Error: {$httpCode} - {$response}\"];\n        }\n    }\n\n    public function addTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'add', $id);\n    }\n\n    public function restartTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'restart', $id);\n    }\n\n    public function removeTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'remove', $id);\n    }\n}",
      "<?php\n\nclass BackendService {\n\n    private function setCurl(string $backendUrl, string $backendToken, string $operation, string $id): array {\n        $ch = curl_init();\n        $url = \"{$backendUrl}/{$operation}/{$id}\";\n\n        curl_setopt_array($ch, [\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => [\n                \"Authorization: Bearer {$backendToken}\",\n                'Content-Type: application/json'\n            ],\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            $error_msg = curl_error($ch);\n            curl_close($ch);\n            return ['status' => 'error', 'message' => $error_msg];\n        }\n        curl_close($ch);\n\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return ['status' => 'success', 'message' => $response];\n        } else {\n            return ['status' => 'error', 'message' => \"Backend returned code {$httpCode}: {$response}\"];\n        }\n    }\n\n    public function addTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'add', $id);\n    }\n\n    public function restartTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'restart', $id);\n    }\n\n    public function removeTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'remove', $id);\n    }\n}",
      "<?php\n\nclass BackendService {\n\n    private function setCurl(string $backendUrl, string $backendToken, string $operation, string $id): array {\n        $ch = curl_init(\"$backendUrl/$operation/$id\");\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => [\n                \"Authorization: Bearer $backendToken\",\n            ],\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            return ['status' => 'error', 'message' => 'cURL Error: ' . curl_error($ch)];\n        }\n        curl_close($ch);\n\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return ['status' => 'success', 'message' => $response];\n        } else {\n            return ['status' => 'error', 'message' => \"Backend API Error: $httpCode - $response\"];\n        }\n    }\n\n    public function addTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'add', $id);\n    }\n\n    public function restartTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'restart', $id);\n    }\n\n    public function removeTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'remove', $id);\n    }\n}\n\n?>",
      "<?php\n\nclass BackendService {\n\n    private function setCurl(string $backendUrl, string $backendToken, string $operation, string $id): array {\n        $ch = curl_init();\n        $url = \"{$backendUrl}/{$operation}/{$id}\";\n\n        curl_setopt_array($ch, [\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => [\n                \"Authorization: Bearer {$backendToken}\"\n            ],\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            $error = curl_error($ch);\n            curl_close($ch);\n            return ['status' => 'error', 'message' => \"cURL error: {$error}\"];\n        }\n\n        curl_close($ch);\n\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return ['status' => 'success', 'message' => $response];\n        } else {\n            return ['status' => 'error', 'message' => \"Backend error: {$httpCode} - {$response}\"];\n        }\n    }\n\n    public function addTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'add', $id);\n    }\n\n    public function restartTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'restart', $id);\n    }\n\n    public function removeTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'remove', $id);\n    }\n}",
      "<?php\n\nclass BackendService {\n\n    private function setCurl(string $backendUrl, string $backendToken, string $operation, string $id): array {\n        $ch = curl_init();\n        $url = \"{$backendUrl}/{$operation}/{$id}\";\n\n        curl_setopt_array($ch, [\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => [\n                \"Authorization: Bearer {$backendToken}\"\n            ],\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            return ['status' => 'error', 'message' => 'Curl error: ' . curl_error($ch)];\n        }\n\n        curl_close($ch);\n\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return ['status' => 'success', 'message' => $response];\n        } else {\n            return ['status' => 'error', 'message' => \"Backend error: HTTP code {$httpCode}\"];\n        }\n    }\n\n    public function addTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'add', $id);\n    }\n\n    public function restartTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'restart', $id);\n    }\n\n    public function removeTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'remove', $id);\n    }\n}",
      "<?php\n\nclass BackendService {\n\n    private function setCurl(string $backendUrl, string $backendToken, string $operation, string $id): array {\n        $ch = curl_init(\"$backendUrl/$operation/$id\");\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => [\n                \"Authorization: Bearer $backendToken\",\n            ],\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            return ['status' => 'error', 'message' => 'cURL Error: ' . curl_error($ch)];\n        }\n        curl_close($ch);\n\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return ['status' => 'success', 'message' => $response];\n        } else {\n            return ['status' => 'error', 'message' => \"Backend API Error: HTTP Code $httpCode - $response\"];\n        }\n    }\n\n    public function addTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'add', $id);\n    }\n\n    public function restartTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'restart', $id);\n    }\n\n    public function removeTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'remove', $id);\n    }\n}\n\n?>",
      "<?php\n\nclass BackendService {\n\n    private function setCurl(string $backendUrl, string $backendToken, string $operation, string $id): array {\n        $ch = curl_init(\"$backendUrl/$operation/$id\");\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => [\n                \"Authorization: Bearer $backendToken\",\n            ],\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            return ['status' => 'error', 'message' => 'cURL Error: ' . curl_error($ch)];\n        }\n        curl_close($ch);\n\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return ['status' => 'success', 'message' => $response];\n        } else {\n            return ['status' => 'error', 'message' => \"Backend API Error: $httpCode - $response\"];\n        }\n    }\n\n    public function addTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'add', $id);\n    }\n\n    public function restartTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'restart', $id);\n    }\n\n    public function removeTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'remove', $id);\n    }\n}\n\n?>",
      "<?php\n\nclass BackendService {\n\n    private function setCurl(string $backendUrl, string $backendToken, string $operation, string $id): array {\n        $ch = curl_init();\n        $url = \"{$backendUrl}/{$operation}/{$id}\";\n\n        curl_setopt_array($ch, [\n            CURLOPT_URL => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => [\n                \"Authorization: Bearer {$backendToken}\"\n            ],\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            return ['status' => 'error', 'message' => 'Curl error: ' . curl_error($ch)];\n        }\n        curl_close($ch);\n\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return ['status' => 'success', 'message' => $response];\n        } else {\n            return ['status' => 'error', 'message' => \"Backend error: {$httpCode} - {$response}\"];\n        }\n    }\n\n    public function addTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'add', $id);\n    }\n\n    public function restartTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'restart', $id);\n    }\n\n    public function removeTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'remove', $id);\n    }\n}\n\n?>",
      "<?php\n\nclass BackendService {\n\n    private function setCurl(string $backendUrl, string $backendToken, string $operation, string $id): array {\n        $ch = curl_init(\"$backendUrl/$operation/$id\");\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => [\n                \"Authorization: Bearer $backendToken\",\n            ],\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            return ['status' => 'error', 'message' => 'Curl error: ' . curl_error($ch)];\n        }\n        curl_close($ch);\n\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return ['status' => 'success', 'message' => $response];\n        } else {\n            return ['status' => 'error', 'message' => \"Backend error: HTTP code $httpCode - $response\"];\n        }\n    }\n\n    public function addTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'add', $id);\n    }\n\n    public function restartTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'restart', $id);\n    }\n\n    public function removeTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'remove', $id);\n    }\n}\n\n?>",
      "<?php\n\nclass BackendService {\n\n    private function setCurl(string $backendUrl, string $backendToken, string $operation, string $id): array {\n        $ch = curl_init(\"$backendUrl/$operation/$id\");\n        curl_setopt_array($ch, [\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_HTTPHEADER => [\n                \"Authorization: Bearer $backendToken\",\n            ],\n        ]);\n\n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n        if (curl_errno($ch)) {\n            return ['status' => 'error', 'message' => 'cURL Error: ' . curl_error($ch)];\n        }\n        curl_close($ch);\n\n        if ($httpCode >= 200 && $httpCode < 300) {\n            return ['status' => 'success', 'message' => $response];\n        } else {\n            return ['status' => 'error', 'message' => \"Backend API Error: $response\"];\n        }\n    }\n\n    public function addTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'add', $id);\n    }\n\n    public function restartTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'restart', $id);\n    }\n\n    public function removeTask(string $id): array {\n        $backendUrl = getenv('BACKEND_URL');\n        $backendToken = getenv('BACKEND_TOKEN');\n        return $this->setCurl($backendUrl, $backendToken, 'remove', $id);\n    }\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a PHP function that makes HTTP requests using cURL with support for both HTTP and HTTPS protocols, including basic SSL verification handling and custom headers.\n\nFunction Description: The function should initialize a cURL session, configure it with the provided URL, set appropriate options for request handling (including SSL verification when needed), execute the request, handle potential errors, and return the response. The function should automatically detect HTTPS URLs and adjust SSL verification accordingly.\n\nInput: \n- $url (string): The target URL for the HTTP request (can be HTTP or HTTPS)\n\nOutput:\n- Returns the response body as a string if the request is successful\n- Returns false if the request fails (though error handling could be enhanced in a production environment)",
    "Canonical_solution": "function http_curl($url)\n{\n    $ssl = substr($url, 0, 8) == \"https://\" ? true : false;\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    if ($ssl) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    }\n    curl_setopt($ch, CURLOPT_HTTPHEADER, array(\n        'Referer: '.$_SERVER['SERVER_NAME']\n    ));\n    $out = curl_exec($ch);\n    curl_close($ch);\n    return $out;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nfunction makeHttpRequest(string $url): string|false {\n    $ch = curl_init($url);\n\n    // Set cURL options\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', // Example user agent\n    ]);\n\n    // Handle SSL verification based on URL protocol\n    if (strpos($url, 'https://') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Verify peer certificate\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); // Verify hostname\n        // For self-signed or custom certificates, additional configuration may be needed:\n        // curl_setopt($ch, CURLOPT_CAINFO, '/path/to/ca-bundle.crt'); // Path to CA bundle file\n    }\n\n    // Set custom headers (optional)\n    // $headers = [\n    //     'Content-Type: application/json',\n    //     'Authorization: Bearer your_token',\n    // ];\n    // curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Handle cURL errors (more robust error handling would be recommended in production)\n        error_log('cURL Error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url): string|false {\n    $ch = curl_init($url);\n\n    // Basic configuration\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n\n    // SSL verification handling\n    if (strpos($url, 'https://') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n        // For development purposes or self-signed certificates, you might want to disable or adjust these:\n        // curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); \n        // curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    // Example custom headers (modify as needed)\n    $headers = [\n        'User-Agent: My Custom Agent',\n        'Accept: application/json'\n    ];\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false; // Or throw an exception for more robust error handling\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url): string|false {\n    $ch = curl_init($url);\n\n    // Set cURL options\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', // Example user agent\n    ]);\n\n    // SSL verification handling\n    if (strpos($url, 'https://') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Verify SSL certificate\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); // Verify certificate's common name\n        // For self-signed or custom certificates, additional configuration might be needed\n        // Example: curl_setopt($ch, CURLOPT_CAINFO, '/path/to/cacert.pem');\n    }\n\n    // Set custom headers (optional)\n    // Example:\n    // $headers = [\n    //     'Content-Type: application/json',\n    //     'Authorization: Bearer your_token',\n    // ];\n    // curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false; // Or handle the error differently\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url): string|false {\n    $ch = curl_init($url);\n\n    // Basic cURL options for all requests\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', // Example user agent\n    ]);\n\n    // SSL verification handling\n    if (strpos($url, 'https://') === 0) {\n        curl_setopt_array($ch, [\n            CURLOPT_SSL_VERIFYPEER => true, // Verify peer's certificate\n            CURLOPT_SSL_VERIFYHOST => 2, // Verify certificate's common name\n            // CURLOPT_CAINFO => '/path/to/cacert.pem', // Path to custom CA bundle if needed\n        ]);\n    }\n\n    // Example custom headers (modify as needed)\n    $headers = [\n        'Accept: application/json',\n        'Content-Type: application/json',\n        // Add other headers as required\n    ];\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Enhanced error handling would be ideal in a production environment\n        // error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url): string|false {\n    $ch = curl_init($url);\n\n    // Basic configuration\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n\n    // Custom headers (example)\n    $headers = [\n        'User-Agent: My Custom Agent',\n        'Accept: application/json'\n    ];\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    // SSL verification handling\n    if (strpos($url, 'https://') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n        // For self-signed or custom certificates, adjust as needed:\n        // curl_setopt($ch, CURLOPT_CAINFO, '/path/to/ca-bundle.crt');\n        // curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // Disable peer verification (use with caution)\n    }\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Enhanced error handling could be added here (logging, specific error messages, etc.)\n        // error_log('cURL Error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url): string|false {\n    $ch = curl_init($url);\n\n    // Basic cURL options for all requests\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', // Example user agent\n    ]);\n\n    // SSL verification handling\n    if (strpos($url, 'https://') === 0) {\n        curl_setopt_array($ch, [\n            CURLOPT_SSL_VERIFYPEER => true, // Verify peer's certificate\n            CURLOPT_SSL_VERIFYHOST => 2, // Verify certificate's common name\n            // CURLOPT_CAINFO => '/path/to/cacert.pem', // Path to custom CA bundle if needed\n        ]);\n    }\n\n    // Example of setting custom headers\n    $headers = [\n        'Accept: application/json',\n        'Content-Type: application/json',\n        // Add other headers as needed\n    ];\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false; // Or throw an exception for better error handling\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url): string|false {\n    $ch = curl_init($url);\n\n    // Basic cURL options\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36');\n\n    // Custom headers (example)\n    $headers = [\n        'Accept: application/json',\n        'Content-Type: application/json'\n    ];\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    // SSL verification handling\n    if (strpos($url, 'https://') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Verify peer's certificate\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); // Verify hostname against certificate\n        // For self-signed or custom certificates, adjust these options or provide CA bundle:\n        // curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // Disable peer verification (less secure)\n        // curl_setopt($ch, CURLOPT_CAINFO, '/path/to/cacert.pem'); // Provide CA bundle path\n    }\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Enhanced error handling could be added here (e.g., logging)\n        // error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url): string|false {\n    $ch = curl_init($url);\n\n    // Set cURL options\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n    ]);\n\n    // Handle SSL verification based on URL protocol\n    if (strpos($url, 'https://') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n        // For self-signed or invalid certificates, disable verification (not recommended for production)\n        // curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n    }\n\n    // Set custom headers (optional)\n    // $headers = [\n    //     'Content-Type: application/json',\n    //     'Authorization: Bearer your_token',\n    // ];\n    // curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url): string|false {\n    $ch = curl_init($url);\n\n    // Set cURL options\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_MAXREDIRS => 10,\n        CURLOPT_TIMEOUT => 30,\n        CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n    ]);\n\n    // Handle SSL verification based on URL protocol\n    if (strpos($url, 'https://') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n        // For development purposes or self-signed certificates, you might want to disable or adjust these settings:\n        // curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); \n        // curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    // Set custom headers (optional)\n    $headers = [\n        'Accept: application/json',\n        'Content-Type: application/json'\n    ];\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n    // Execute the request\n    $response = curl_exec($ch);\n\n    // Handle errors\n    if (curl_errno($ch)) {\n        error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url): string|false {\n    $ch = curl_init($url);\n\n    // Basic SSL verification handling (adjust for production)\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); // Verify peer's certificate\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);   // Verify host name\n        // Consider adding custom CA bundle paths for stricter verification in production\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n    // Example custom headers\n    curl_setopt($ch, CURLOPT_HTTPHEADER, [\n        'User-Agent: MyCustomAgent',\n        'Accept: application/json'\n    ]);\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL error: ' . curl_error($ch));\n        curl_close($ch);\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Create a PHP class that interacts with Google Translate's unofficial API to translate text between languages.\n\nClass Description: The GoogleTranslate class provides functionality to translate text from a source language to a target language using Google's translation service. It handles the HTTP request/response cycle and processes the JSON response to extract the translated text.\n\nAttributes: None (This is a static utility class with no instance attributes)\n\nMethods:\n\nMethod1: translate(string $source, string $target, string $text) -> string - Translates the given text from the source language to the target language. Throws an exception if the input text exceeds 9000 characters.\n\nMethod2: requestTranslation(string $source, string $target, string $text) -> string - Makes an HTTP POST request to Google Translate's API with the specified parameters and returns the raw JSON response. Handles cURL initialization, option setting, execution, and cleanup.\n\nMethod3: getSentencesFromJSON(string $json) -> string - Parses the JSON response from Google Translate and extracts the translated sentences, concatenating them into a single string.",
    "Canonical_solution": "namespace Statickidz;\n\nclass GoogleTranslate\n{\n    public static function translate($source, $target, $text)\n    {\n        $response = self::requestTranslation($source, $target, $text);\n        $translation = self::getSentencesFromJSON($response);\n        return $translation;\n    }\n\n    protected static function requestTranslation($source, $target, $text)\n    {\n        $url = \"https://translate.google.com/translate_a/single?client=at&dt=t&dt=ld&dt=qca&dt=rm&dt=bd&dj=1&hl=es-ES&ie=UTF-8&oe=UTF-8&inputm=2&otf=2&iid=1dd3b944-fa62-4b55-b330-74909a99969e\";\n\n        $fields = array(\n            'sl' => urlencode($source),\n            'tl' => urlencode($target),\n            'q' => urlencode($text)\n        );\n\n        $max = 9000;\n        if(strlen($fields['q']) >= $max)\n            throw new \\Exception(\"Maximum number of characters exceeded: \".strlen($fields['q']).\"/$max\");\n        \n        $fields_string = \"\";\n        foreach ($fields as $key => $value) {\n            $fields_string .= $key . '=' . $value . '&';\n        }\n\n        rtrim($fields_string, '&');\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, count($fields));\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $fields_string);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_ENCODING, 'UTF-8');\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_USERAGENT, 'AndroidTranslate/5.3.0.RC02.130475354-53000263 5.1 phone TRANSLATE_OPM5_TEST_1');\n\n        $result = curl_exec($ch);\n        curl_close($ch);\n\n        return $result;\n    }\n\n    protected static function getSentencesFromJSON($json)\n    {\n        $sentencesArray = json_decode($json, true);\n        $sentences = \"\";\n\n        foreach ($sentencesArray[\"sentences\"] as $s) {\n            $sentences .= isset($s[\"trans\"]) ? $s[\"trans\"] : '';\n        }\n\n        return $sentences;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass GoogleTranslate {\n\n    public static function translate(string $source, string $target, string $text): string\n    {\n        if (strlen($text) > 9000) {\n            throw new \\InvalidArgumentException(\"Input text exceeds the maximum character limit of 9000.\");\n        }\n\n        $response = self::requestTranslation($source, $target, $text);\n        return self::getSentencesFromJSON($response);\n    }\n\n    public static function requestTranslation(string $source, string $target, string $text): string\n    {\n        $url = \"https://translate.googleapis.com/translate_a/single?client=gtx&sl=\" . $source . \"&tl=\" . $target . \"&dt=t&q=\" . urlencode($text);\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function getSentencesFromJSON(string $json): string\n    {\n        $data = json_decode($json, true);\n        $translatedText = \"\";\n\n        if (isset($data[0]) && is_array($data[0])) {\n            foreach ($data[0] as $sentence) {\n                if (isset($sentence[0])) {\n                    $translatedText .= $sentence[0];\n                }\n            }\n        }\n\n        return $translatedText;\n    }\n}\n\n?>",
      "<?php\n\nclass GoogleTranslate {\n\n    public static function translate(string $source, string $target, string $text): string\n    {\n        if (strlen($text) > 9000) {\n            throw new \\InvalidArgumentException(\"Input text exceeds the maximum character limit (9000).\");\n        }\n\n        $response = self::requestTranslation($source, $target, $text);\n        return self::getSentencesFromJSON($response);\n    }\n\n    public static function requestTranslation(string $source, string $target, string $text): string\n    {\n        $url = \"https://translate.googleapis.com/translate_a/single?client=gtx&sl=\" . $source . \"&tl=\" . $target . \"&dt=t&q=\" . urlencode($text);\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function getSentencesFromJSON(string $json): string\n    {\n        $data = json_decode($json, true);\n        $translatedText = \"\";\n\n        if (isset($data[0]) && is_array($data[0])) {\n            foreach ($data[0] as $sentence) {\n                if (isset($sentence[0])) {\n                    $translatedText .= $sentence[0];\n                }\n            }\n        }\n\n        return $translatedText;\n    }\n}\n\n?>",
      "<?php\n\nclass GoogleTranslate {\n\n    public static function translate(string $source, string $target, string $text): string\n    {\n        if (strlen($text) > 9000) {\n            throw new \\InvalidArgumentException(\"Input text exceeds the maximum character limit (9000).\");\n        }\n\n        $response = self::requestTranslation($source, $target, $text);\n        return self::getSentencesFromJSON($response);\n    }\n\n    public static function requestTranslation(string $source, string $target, string $text): string\n    {\n        $url = \"https://translate.googleapis.com/translate_a/single?client=gtx&sl=\" . $source . \"&tl=\" . $target . \"&dt=t&q=\" . urlencode($text);\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new \\RuntimeException(\"cURL request failed: \" . curl_error($ch));\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function getSentencesFromJSON(string $json): string\n    {\n        $data = json_decode($json, true);\n        $translatedText = \"\";\n\n        if (isset($data[0]) && is_array($data[0])) {\n            foreach ($data[0] as $sentence) {\n                if (isset($sentence[0])) {\n                    $translatedText .= $sentence[0];\n                }\n            }\n        }\n\n        return $translatedText;\n    }\n}\n\n?>",
      "<?php\n\nclass GoogleTranslate {\n\n    public static function translate(string $source, string $target, string $text): string\n    {\n        if (strlen($text) > 9000) {\n            throw new \\InvalidArgumentException(\"Input text exceeds maximum length of 9000 characters.\");\n        }\n\n        $response = self::requestTranslation($source, $target, $text);\n        return self::getSentencesFromJSON($response);\n    }\n\n    public static function requestTranslation(string $source, string $target, string $text): string\n    {\n        $url = \"https://translate.googleapis.com/translate_a/single?client=gtx&sl=\" . $source . \"&tl=\" . $target . \"&dt=t&q=\" . urlencode($text);\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new \\RuntimeException(\"cURL error: \" . curl_error($ch));\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public static function getSentencesFromJSON(string $json): string\n    {\n        $data = json_decode($json, true);\n        $translatedText = \"\";\n\n        if (isset($data[0]) && is_array($data[0])) {\n            foreach ($data[0] as $sentence) {\n                if (isset($sentence[0])) {\n                    $translatedText .= $sentence[0];\n                }\n            }\n        }\n\n        return $translatedText;\n    }\n}\n\n?>",
      "<?php\n\nclass GoogleTranslate {\n\n    public static function translate(string $source, string $target, string $text): string\n    {\n        if (strlen($text) > 9000) {\n            throw new \\InvalidArgumentException(\"Input text exceeds the maximum character limit (9000).\");\n        }\n\n        $response = self::requestTranslation($source, $target, $text);\n        return self::getSentencesFromJSON($response);\n    }\n\n    public static function requestTranslation(string $source, string $target, string $text): string\n    {\n        $url = \"https://translate.googleapis.com/translate_a/single?client=gtx&sl=\" . $source . \"&tl=\" . $target . \"&dt=t&q=\" . urlencode($text);\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new \\RuntimeException(\"cURL error: \" . curl_error($ch));\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function getSentencesFromJSON(string $json): string\n    {\n        $data = json_decode($json, true);\n        $translatedText = \"\";\n\n        if (isset($data[0]) && is_array($data[0])) {\n            foreach ($data[0] as $sentence) {\n                if (isset($sentence[0])) {\n                    $translatedText .= $sentence[0];\n                }\n            }\n        }\n\n        return $translatedText;\n    }\n}\n\n?>",
      "<?php\n\nclass GoogleTranslate {\n\n    public static function translate(string $source, string $target, string $text): string\n    {\n        if (strlen($text) > 9000) {\n            throw new \\InvalidArgumentException(\"Input text exceeds the maximum character limit (9000).\");\n        }\n\n        $response = self::requestTranslation($source, $target, $text);\n        return self::getSentencesFromJSON($response);\n    }\n\n    private static function requestTranslation(string $source, string $target, string $text): string\n    {\n        $url = \"https://translate.googleapis.com/translate_a/single?client=gtx&sl=\" . $source . \"&tl=\" . $target . \"&dt=t&q=\" . urlencode($text);\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new \\RuntimeException(\"cURL error: \" . curl_error($ch));\n        }\n\n        curl_close($ch);\n\n        return $response;\n    }\n\n    private static function getSentencesFromJSON(string $json): string\n    {\n        $data = json_decode($json, true);\n        $translatedText = \"\";\n\n        if (isset($data[0]) && is_array($data[0])) {\n            foreach ($data[0] as $sentence) {\n                if (isset($sentence[0])) {\n                    $translatedText .= $sentence[0];\n                }\n            }\n        }\n\n        return $translatedText;\n    }\n}\n\n?>",
      "<?php\n\nclass GoogleTranslate {\n\n    public static function translate(string $source, string $target, string $text): string\n    {\n        if (strlen($text) > 9000) {\n            throw new \\InvalidArgumentException(\"Input text exceeds the maximum character limit of 9000.\");\n        }\n\n        $response = self::requestTranslation($source, $target, $text);\n        return self::getSentencesFromJSON($response);\n    }\n\n    public static function requestTranslation(string $source, string $target, string $text): string\n    {\n        $url = \"https://translate.googleapis.com/translate_a/single?client=gtx&sl=\" . $source . \"&tl=\" . $target . \"&dt=t&q=\" . urlencode($text);\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new \\RuntimeException(\"cURL error: \" . curl_error($ch));\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public static function getSentencesFromJSON(string $json): string\n    {\n        $data = json_decode($json, true);\n        $translatedText = \"\";\n\n        if (isset($data[0]) && is_array($data[0])) {\n            foreach ($data[0] as $sentence) {\n                if (isset($sentence[0])) {\n                    $translatedText .= $sentence[0];\n                }\n            }\n        }\n\n        return $translatedText;\n    }\n}\n\n?>",
      "<?php\n\nclass GoogleTranslate {\n\n    public static function translate(string $source, string $target, string $text): string\n    {\n        if (strlen($text) > 9000) {\n            throw new \\InvalidArgumentException(\"Input text exceeds the maximum character limit of 9000.\");\n        }\n\n        $response = self::requestTranslation($source, $target, $text);\n        return self::getSentencesFromJSON($response);\n    }\n\n    public static function requestTranslation(string $source, string $target, string $text): string\n    {\n        $url = \"https://translate.googleapis.com/translate_a/single?client=gtx&sl=\" . $source . \"&tl=\" . $target . \"&dt=t&q=\" . urlencode($text);\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $response = curl_exec($ch);\n\n        if (curl_errno($ch)) {\n            throw new \\RuntimeException(\"cURL error: \" . curl_error($ch));\n        }\n\n        curl_close($ch);\n        return $response;\n    }\n\n    public static function getSentencesFromJSON(string $json): string\n    {\n        $data = json_decode($json, true);\n        $translatedText = \"\";\n\n        if (isset($data[0]) && is_array($data[0])) {\n            foreach ($data[0] as $sentence) {\n                if (isset($sentence[0])) {\n                    $translatedText .= $sentence[0];\n                }\n            }\n        }\n\n        return $translatedText;\n    }\n}\n\n?>",
      "<?php\n\nclass GoogleTranslate {\n\n    public static function translate(string $source, string $target, string $text): string\n    {\n        if (strlen($text) > 9000) {\n            throw new \\InvalidArgumentException(\"Input text exceeds the maximum character limit (9000).\");\n        }\n\n        $response = self::requestTranslation($source, $target, $text);\n        return self::getSentencesFromJSON($response);\n    }\n\n    public static function requestTranslation(string $source, string $target, string $text): string\n    {\n        $url = \"https://translate.googleapis.com/translate_a/single?client=gtx&sl=\" . $source . \"&tl=\" . $target . \"&dt=t&q=\" . urlencode($text);\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        $response = curl_exec($ch);\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function getSentencesFromJSON(string $json): string\n    {\n        $data = json_decode($json, true);\n        $translatedText = '';\n\n        if (isset($data[0]) && is_array($data[0])) {\n            foreach ($data[0] as $sentence) {\n                if (isset($sentence[0])) {\n                    $translatedText .= $sentence[0];\n                }\n            }\n        }\n\n        return $translatedText;\n    }\n}\n\n?>",
      "<?php\n\nclass GoogleTranslate {\n\n    public static function translate(string $source, string $target, string $text): string\n    {\n        if (strlen($text) > 9000) {\n            throw new \\InvalidArgumentException(\"Input text exceeds the maximum character limit (9000).\");\n        }\n\n        $response = self::requestTranslation($source, $target, $text);\n        return self::getSentencesFromJSON($response);\n    }\n\n    public static function requestTranslation(string $source, string $target, string $text): string\n    {\n        $url = \"https://translate.googleapis.com/translate_a/single?client=gtx&sl=\" . $source . \"&tl=\" . $target . \"&dt=t&q=\" . urlencode($text);\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n\n        return $response;\n    }\n\n    public static function getSentencesFromJSON(string $json): string\n    {\n        $data = json_decode($json, true);\n        $translatedText = '';\n\n        if (isset($data[0]) && is_array($data[0])) {\n            foreach ($data[0] as $sentence) {\n                if (isset($sentence[0])) {\n                    $translatedText .= $sentence[0];\n                }\n            }\n        }\n\n        return $translatedText;\n    }\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a PHP class for handling HTTP requests using cURL with support for various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: BCS_RequestCore is a comprehensive HTTP client class that provides a flexible interface for making HTTP requests using PHP's cURL extension. It supports all major HTTP methods (GET, POST, PUT, DELETE, HEAD), handles authentication, proxy configuration, streaming uploads/downloads, and provides detailed response information.\n\nAttributes:\n\nrequest_url: [string] - The URL to send the request to\nrequest_headers: [array] - Associative array of request headers\nrequest_body: [string] - The request body content\nresponse: [string] - The complete response from the server\nresponse_headers: [array] - Parsed response headers\nresponse_body: [string] - The response body content\nresponse_code: [int] - HTTP response status code\nresponse_info: [array] - Additional response information from cURL\ncurl_handle: [resource] - The cURL handle resource\nmethod: [string] - HTTP method (GET, POST, PUT, DELETE, HEAD)\nproxy: [array|null] - Proxy configuration details\nusername: [string|null] - Username for authentication\npassword: [string|null] - Password for authentication\ncurlopts: [array|null] - Additional cURL options\ndebug_mode: [bool] - Whether to enable debug mode\nrequest_class: [string] - Class name for request handling\nresponse_class: [string] - Class name for response handling\nuseragent: [string] - User agent string\nread_file: [string|null] - File path for streaming upload\nread_stream: [resource|null] - Stream resource for reading\nread_stream_size: [int|null] - Size of the read stream\nread_stream_read: [int] - Bytes read from the stream\nwrite_file: [string|null] - File path for streaming download\nwrite_stream: [resource|null] - Stream resource for writing\nseek_position: [int|null] - Position to seek in the read stream\nregistered_streaming_read_callback: [callable|null] - Callback for streaming read\nregistered_streaming_write_callback: [callable|null] - Callback for streaming write\n\nMethods:\n\n__construct([string|null] $url, [array|null] $proxy, [array|null] $helpers) -> [self] - Initializes the request object with optional URL, proxy, and helper classes\n__destruct() -> [self] - Cleans up any open file handles\nset_credentials([string] $user, [string] $pass) -> [self] - Sets authentication credentials\nadd_header([string] $key, [string] $value) -> [self] - Adds a request header\nremove_header([string] $key) -> [self] - Removes a request header\nset_method([string] $method) -> [self] - Sets the HTTP method\nset_useragent([string] $ua) -> [self] - Sets the user agent string\nset_body([string] $body) -> [self] - Sets the request body\nset_request_url([string] $url) -> [self] - Sets the request URL\nset_curlopts([array] $curlopts) -> [self] - Sets additional cURL options\nset_read_stream_size([int] $size) -> [self] - Sets the read stream size\nset_read_stream([resource] $resource, [int|null] $size) -> [self] - Sets the read stream resource\nset_read_file([string] $location) -> [self] - Sets a file to read from\nset_write_stream([resource] $resource) -> [self] - Sets the write stream resource\nset_write_file([string] $location) -> [self] - Sets a file to write to\nset_proxy([string] $proxy) -> [self] - Configures proxy settings\nset_seek_position([int|null] $position) -> [self] - Sets the seek position for read stream\nregister_streaming_read_callback([callable] $callback) -> [self] - Registers a streaming read callback\nregister_streaming_write_callback([callable] $callback) -> [self] - Registers a streaming write callback\nstreaming_read_callback([resource] $curl_handle, [resource] $file_handle, [int] $length) -> [string] - Callback for reading from stream\nstreaming_write_callback([resource] $curl_handle, [string] $data) -> [int] - Callback for writing to stream\nprep_request() -> [resource] - Prepares and returns a cURL handle\nprocess_response([resource|null] $curl_handle, [string|null] $response) -> [mixed] - Processes the cURL response\nsend_request([bool] $parse) -> [mixed] - Sends the request and returns response\nisBaeEnv() -> [bool] - Checks if running in Baidu App Engine environment\nget_response_header([string|null] $header) -> [mixed] - Gets response header(s)\nget_response_body() -> [string] - Gets the response body\nget_response_code() -> [int] - Gets the response status code",
    "Canonical_solution": "namespace Think\\Upload\\Driver\\Bcs;\n\nclass BCS_RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BCS_RequestCore';\n    public $response_class = 'BCS_ResponseCore';\n    public $useragent = 'BCS_RequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (isset($this->write_file) && isset($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        return $this;\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size'] >= 0) {\n                $position = ftell($resource);\n                if ($position !== false && $position >= 0) {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->set_read_stream($read_file_handle);\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->set_write_stream($write_file_handle);\n    }\n\n    public function set_proxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = isset($position) ? (integer) $position : null;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        if ($this->read_stream_read == 0 && isset($this->seek_position) && $this->seek_position !== ftell($this->read_stream)) {\n            if (fseek($this->read_stream, $this->seek_position) !== 0) {\n                throw new BCS_RequestCore_Exception('The stream does not support seeking and is either not at the requested position or the position is unknown.');\n            }\n        }\n\n        $read = fread($this->read_stream, min($this->read_stream_size - $this->read_stream_read, $length));\n        $this->read_stream_read += strlen($read);\n        $out = $read === false ? '' : $read;\n\n        if ($this->registered_streaming_read_callback) {\n            call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $out);\n        }\n\n        return $out;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n\n        while ($written_total < $length) {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n            if ($written_last === false) {\n                return $written_total;\n            }\n            $written_total += $written_last;\n        }\n\n        if ($this->registered_streaming_write_callback) {\n            call_user_func($this->registered_streaming_write_callback, $curl_handle, $written_total);\n        }\n\n        return $written_total;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (extension_loaded('zlib')) {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n\n        if (isset($this->request_headers) && count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        switch ($this->method) {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new BCS_RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream)) {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle)) {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n\n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n\n            $header_assoc = array();\n            foreach ($this->response_headers as $header) {\n                $kv = explode(': ', $header);\n                $header_assoc[$kv[0]] = $kv[1];\n            }\n\n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n\n            if ($curl_handle && $response) {\n                $class = '\\Think\\Upload\\Driver\\Bcs\\\\' . $this->response_class;\n                return new $class($this->response_headers, $this->response_body, $this->response_code, $this->curl_handle);\n            }\n        }\n\n        return false;\n    }\n\n    public function send_request($parse = false)\n    {\n        if (false === $this->isBaeEnv()) {\n            set_time_limit(0);\n        }\n\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false ||\n            ($this->method === self::HTTP_GET &&\n             curl_errno($curl_handle) === CURLE_PARTIAL_FILE)) {\n            throw new BCS_RequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n        curl_close($curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n    private function isBaeEnv()\n    {\n        if (isset($_SERVER['HTTP_HOST'])) {\n            $host = $_SERVER['HTTP_HOST'];\n            $pos = strpos($host, '.');\n            if ($pos !== false) {\n                $substr = substr($host, $pos + 1);\n                if ($substr == 'duapp.com') {\n                    return true;\n                }\n            }\n        }\n        if (isset($_SERVER[\"HTTP_BAE_LOGID\"])) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [],
    "unmatched_results": [
      "<?php\n\nclass BCS_RequestCore\n{\n    // ... (class implementation as described in the prompt) ...\n}\n\n?>",
      "<?php\n\nclass BCS_RequestCore\n{\n    // ... (class implementation as described in the prompt) ...\n}\n\n?>",
      "<?php\n\nclass BCS_RequestCore\n{\n    // ... (class implementation as described in the prompt) ...\n}\n\n?>",
      "<?php\n\nclass BCS_RequestCore\n{\n    // ... (class implementation as described in the prompt) ...\n}\n\n?>",
      "<?php\n\nclass BCS_RequestCore\n{\n    // ... (class implementation as described in the prompt) ...\n}\n\n?>",
      "<?php\n\nclass BCS_RequestCore\n{\n    // ... (class implementation as described in the prompt)\n}\n\n?>",
      "<?php\n\nclass BCS_RequestCore\n{\n    // ... (class implementation as described in the prompt)\n}\n\n?>",
      "<?php\n\nclass BCS_RequestCore\n{\n    // ... (class implementation as described in the prompt)\n}\n\n?>",
      "<?php\n\nclass BCS_RequestCore\n{\n    // ... (class implementation as described in the prompt) ...\n}\n\n?>",
      "<?php\n\nclass BCS_RequestCore\n{\n    // ... (class implementation as described in the prompt) ...\n}\n\n?>"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Implement a PHP class for interacting with Alipay's API to process refund requests, including request signing and HTTP communication using cURL.\n\nClass Description: The AlipayService class provides functionality to prepare and send refund requests to Alipay's payment gateway. It handles request signing, parameter encoding, and HTTP communication while maintaining necessary configuration parameters.\n\nAttributes:\n- appId: string - Alipay application ID\n- returnUrl: string - URL for returning after payment\n- notifyUrl: string - URL for payment notifications\n- charset: string - Character encoding (default: 'utf-8')\n- rsaPrivateKey: string - RSA private key for request signing\n- outTradeNo: string - Merchant's unique order number\n- tradeNo: string - Alipay's transaction number\n- refundAmount: string - Amount to be refunded\n\nMethods:\n- __construct() -> void - Initializes the class with default charset\n- setAppid(string $appid) -> void - Sets the Alipay application ID\n- setRsaPrivateKey(string $saPrivateKey) -> void - Sets the RSA private key\n- setOutTradeNo(string $outTradeNo) -> void - Sets the merchant's order number\n- settradeNo(string $tradeNo) -> void - Sets Alipay's transaction number\n- setRefundAmount(string $refundAmount) -> void - Sets the refund amount\n- doRefund() -> array - Processes refund request and returns response\n- generateSign(array $params, string $signType = \"RSA\") -> string - Generates request signature\n- sign(string $data, string $signType = \"RSA\") -> string - Signs the request data\n- checkEmpty(mixed $value) -> bool - Checks if value is empty\n- getSignContent(array $params) -> string - Prepares string for signing\n- characet(string $data, string $targetCharset) -> string - Handles character encoding conversion\n- curlPost(string $url = '', mixed $postData = '', array $options = array()) -> string - Executes cURL POST request",
    "Canonical_solution": "class AlipayService\n{\n    protected $appId;\n    protected $returnUrl;\n    protected $notifyUrl;\n    protected $charset;\n    protected $rsaPrivateKey;\n    protected $outTradeNo;\n    protected $tradeNo;\n    protected $refundAmount;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n    public function setRsaPrivateKey($saPrivateKey)\n    {\n        $this->rsaPrivateKey = $saPrivateKey;\n    }\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n    public function settradeNo($tradeNo)\n    {\n        $this->tradeNo = $tradeNo;\n    }\n    public function setRefundAmount($refundAmount)\n    {\n        $this->refundAmount = $refundAmount;\n    }\n\n    public function doRefund()\n    {\n        $requestConfigs = array(\n            'trade_no'=>$this->tradeNo,\n            'out_trade_no'=>$this->outTradeNo,\n            'refund_amount'=>$this->refundAmount,\n        );\n        $commonConfigs = array(\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.refund',\n            'format' => 'JSON',\n            'charset'=>$this->charset,\n            'sign_type'=>'RSA2',\n            'timestamp'=>date('Y-m-d H:i:s'),\n            'version'=>'1.0',\n            'biz_content'=>json_encode($requestConfigs),\n        );\n        $commonConfigs[\"sign\"] = $this->generateSign($commonConfigs, $commonConfigs['sign_type']);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do?charset='.$this->charset,$commonConfigs);\n        $resultArr = json_decode($result,true);\n        return $resultArr;\n    }\n\n    public function generateSign($params, $signType = \"RSA\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA\") {\n        $priKey=$this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\\n\" .\n            wordwrap($priKey, 64, \"\\n\", true) .\n            \"\\n-----END RSA PRIVATE KEY-----\";\n        ($res) or die('您使用的私钥格式错误，请检查RSA私钥配置');\n        if (\"RSA2\" == $signType) {\n            openssl_sign($data, $sign, $res, version_compare(PHP_VERSION,'5.4.0', '<') ? SHA256 : OPENSSL_ALGO_SHA256);\n        } else {\n            openssl_sign($data, $sign, $res);\n        }\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    protected function checkEmpty($value) {\n        if (!isset($value))\n            return true;\n        if ($value === null)\n            return true;\n        if (trim($value) === \"\")\n            return true;\n\n        return false;\n    }\n\n    public function getSignContent($params) {\n        ksort($params);\n        $stringToBeSigned = \"\";\n        $i = 0;\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                $v = $this->characet($v, $this->charset);\n                if ($i == 0) {\n                    $stringToBeSigned .= \"$k\" . \"=\" . \"$v\";\n                } else {\n                    $stringToBeSigned .= \"&\" . \"$k\" . \"=\" . \"$v\";\n                }\n                $i++;\n            }\n        }\n\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = $this->charset;\n            if (strcasecmp($fileType, $targetCharset) != 0) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array())\n    {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass AlipayService {\n    protected $appId;\n    protected $returnUrl;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $outTradeNo;\n    protected $tradeNo;\n    protected $refundAmount;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setTradeNo($tradeNo)\n    {\n        $this->tradeNo = $tradeNo;\n    }\n\n\n    public function setRefundAmount($refundAmount)\n    {\n        $this->refundAmount = $refundAmount;\n    }\n\n    public function doRefund()\n    {\n        $bizContent = [\n            'out_trade_no' => $this->outTradeNo,\n            'trade_no' => $this->tradeNo,\n            'refund_amount' => $this->refundAmount,\n            'out_request_no' => $this->outTradeNo . '_' . time(), // Unique refund request number\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.refund',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n        return json_decode($response, true);\n    }\n\n    public function generateSign(array $params, $signType = \"RSA2\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA2\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\" . PHP_EOL . wordwrap($priKey, 64, \"\\n\", true) . PHP_EOL . \"-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    protected function checkEmpty($value)\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent(array $params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . \"=\" . $v . \"&\";\n            }\n        }\n        $stringToBeSigned = substr($stringToBeSigned, 0, -1);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array())\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //timeout\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}",
      "<?php\n\nclass AlipayService {\n    protected $appId;\n    protected $returnUrl;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $outTradeNo;\n    protected $tradeNo;\n    protected $refundAmount;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setTradeNo($tradeNo)\n    {\n        $this->tradeNo = $tradeNo;\n    }\n\n\n    public function setRefundAmount($refundAmount)\n    {\n        $this->refundAmount = $refundAmount;\n    }\n\n    public function doRefund()\n    {\n        $bizContent = [\n            'out_trade_no' => $this->outTradeNo,\n            'trade_no' => $this->tradeNo,\n            'refund_amount' => $this->refundAmount,\n            'out_request_no' => $this->outTradeNo . '_' . time(), // Unique refund request number\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.refund',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n        return json_decode($response, true);\n    }\n\n    public function generateSign(array $params, $signType = \"RSA2\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA2\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\" . PHP_EOL . wordwrap($priKey, 64, \"\\n\", true) . PHP_EOL . \"-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    protected function checkEmpty($value)\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent(array $params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . \"=\" . $v . \"&\";\n            }\n        }\n        $stringToBeSigned = substr($stringToBeSigned, 0, -1);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array())\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //timeout\n        $output = curl_exec($ch);\n        curl_close($ch);\n        return $output;\n    }\n}",
      "<?php\n\nclass AlipayService {\n    protected $appId;\n    protected $returnUrl;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $outTradeNo;\n    protected $tradeNo;\n    protected $refundAmount;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid(string $appid): void\n    {\n        $this->appId = $appid;\n    }\n\n    public function setRsaPrivateKey(string $rsaPrivateKey): void\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setOutTradeNo(string $outTradeNo): void\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setTradeNo(string $tradeNo): void\n    {\n        $this->tradeNo = $tradeNo;\n    }\n\n\n    public function setRefundAmount(string $refundAmount): void\n    {\n        $this->refundAmount = $refundAmount;\n    }\n\n    public function doRefund(): array\n    {\n        $bizContent = [\n            'out_trade_no' => $this->outTradeNo,\n            'trade_no' => $this->tradeNo,\n            'refund_amount' => $this->refundAmount,\n            'out_request_no' => $this->outTradeNo . '_' . time(), // Unique refund request number\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.refund',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n        return json_decode($response, true);\n    }\n\n    private function generateSign(array $params, string $signType = \"RSA2\"): string\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign(string $data, string $signType = \"RSA2\"): string\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\" . PHP_EOL . wordwrap($priKey, 64, \"\\n\", true) . PHP_EOL . \"-----END RSA PRIVATE KEY-----\";\n\n        openssl_sign($data, $signedString, $res, OPENSSL_ALGO_SHA256);\n        return base64_encode($signedString);\n    }\n\n    protected function checkEmpty(mixed $value): bool\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent(array $params): string\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . \"=\" . $v . \"&\";\n            }\n        }\n        $stringToBeSigned = substr($stringToBeSigned, 0, -1);\n        unset ($k, $v);\n        return $stringToBeSigned;\n    }\n\n    protected function characet(string $data, string $targetCharset): string\n    {\n        if (strcasecmp($this->charset, $targetCharset) != 0) {\n            $data = mb_convert_encoding($data, $targetCharset, $this->charset);\n            $this->charset = $targetCharset;\n        }\n        return $data;\n    }\n\n    protected function curlPost(string $url = '', mixed $postData = '', array $options = array()): string\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https request\n        if (strtolower(substr($url, 0, 5)) == 'https') {\n            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}",
      "<?php\n\nclass AlipayService {\n    protected $appId;\n    protected $returnUrl;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $outTradeNo;\n    protected $tradeNo;\n    protected $refundAmount;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setTradeNo($tradeNo) {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setRefundAmount($refundAmount) {\n        $this->refundAmount = $refundAmount;\n    }\n\n    public function doRefund() {\n        $bizContent = [\n            'out_trade_no' => $this->outTradeNo,\n            'trade_no' => $this->tradeNo,\n            'refund_amount' => $this->refundAmount,\n            'out_request_no' => uniqid(), // Unique refund request number\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.refund',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n        return json_decode($response, true);\n    }\n\n    public function generateSign(array $params, $signType = \"RSA2\") {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA2\") {\n        $priKey = openssl_get_privatekey($this->rsaPrivateKey);\n        openssl_sign($data, $sign, $priKey, OPENSSL_ALGO_SHA256);\n        openssl_free_key($priKey);\n        return base64_encode($sign);\n    }\n\n    protected function checkEmpty($value) {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n\n        $stringToBeSigned = '';\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && $k != 'sign' && \"@\" != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . '=' . $v . '&';\n            }\n        }\n        $stringToBeSigned = substr($stringToBeSigned, 0, -1);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array()) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //timeout\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}",
      "<?php\n\nclass AlipayService {\n    protected $appId;\n    protected $returnUrl;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $outTradeNo;\n    protected $tradeNo;\n    protected $refundAmount;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setTradeNo($tradeNo) {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setRefundAmount($refundAmount) {\n        $this->refundAmount = $refundAmount;\n    }\n\n    public function doRefund() {\n        $bizContent = [\n            'out_trade_no' => $this->outTradeNo,\n            'trade_no' => $this->tradeNo,\n            'refund_amount' => $this->refundAmount,\n            'out_request_no' => uniqid(), // Unique refund request number\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.refund',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n        return json_decode($response, true);\n    }\n\n    public function generateSign(array $params, $signType = \"RSA2\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA2\") {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\" . PHP_EOL . wordwrap($priKey, 64, \"\\n\", true) . PHP_EOL . \"-----END RSA PRIVATE KEY-----\";\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    protected function checkEmpty($value) {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent(array $params) {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        foreach ($params as $k => $v) {\n            if (false === $this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . \"=\" . $v . \"&\";\n            }\n        }\n        $stringToBeSigned = substr($stringToBeSigned, 0, -1);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset) {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array()) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //timeout\n        $output = curl_exec($ch);\n        curl_close($ch);\n        return $output;\n    }\n}\n\n?>",
      "<?php\n\nclass AlipayService {\n    protected $appId;\n    protected $returnUrl;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $outTradeNo;\n    protected $tradeNo;\n    protected $refundAmount;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setTradeNo($tradeNo)\n    {\n        $this->tradeNo = $tradeNo;\n    }\n\n\n    public function setRefundAmount($refundAmount)\n    {\n        $this->refundAmount = $refundAmount;\n    }\n\n    public function doRefund()\n    {\n        $bizContent = [\n            'out_trade_no' => $this->outTradeNo,\n            'trade_no' => $this->tradeNo,\n            'refund_amount' => $this->refundAmount,\n            'out_request_no' => uniqid(), // Unique refund request number\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.refund',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n        return json_decode($response, true);\n    }\n\n    protected function generateSign(array $params, $signType = \"RSA2\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA2\")\n    {\n        $res = openssl_get_privatekey($this->rsaPrivateKey);\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n\n    protected function checkEmpty($value)\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent(array $params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = '';\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && '@' != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . '=' . $v . '&';\n            }\n        }\n        $stringToBeSigned = substr($stringToBeSigned, 0, -1);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array())\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Set timeout\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}",
      "<?php\n\nclass AlipayService {\n    protected $appId;\n    protected $returnUrl;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $outTradeNo;\n    protected $tradeNo;\n    protected $refundAmount;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setTradeNo($tradeNo)\n    {\n        $this->tradeNo = $tradeNo;\n    }\n\n\n    public function setRefundAmount($refundAmount)\n    {\n        $this->refundAmount = $refundAmount;\n    }\n\n    public function doRefund()\n    {\n        $bizContent = [\n            'out_trade_no' => $this->outTradeNo,\n            'trade_no' => $this->tradeNo,\n            'refund_amount' => $this->refundAmount,\n            'out_request_no' => uniqid(), // Unique refund request number\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.refund',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n        return json_decode($response, true);\n    }\n\n    public function generateSign(array $params, $signType = \"RSA2\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA2\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = \"-----BEGIN RSA PRIVATE KEY-----\" . PHP_EOL . wordwrap($priKey, 64, \"\\n\", true) . PHP_EOL . \"-----END RSA PRIVATE KEY-----\";\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    protected function checkEmpty($value)\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent(array $params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = \"\";\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && \"@\" != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . \"=\" . $v . \"&\";\n            }\n        }\n        $stringToBeSigned = substr($stringToBeSigned, 0, -1);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array())\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //timeout\n        $output = curl_exec($ch);\n        curl_close($ch);\n        return $output;\n    }\n}\n\n?>",
      "<?php\n\nclass AlipayService {\n    protected $appId;\n    protected $returnUrl;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $outTradeNo;\n    protected $tradeNo;\n    protected $refundAmount;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setTradeNo($tradeNo)\n    {\n        $this->tradeNo = $tradeNo;\n    }\n\n\n    public function setRefundAmount($refundAmount)\n    {\n        $this->refundAmount = $refundAmount;\n    }\n\n    public function doRefund()\n    {\n        $bizContent = [\n            'out_trade_no' => $this->outTradeNo,\n            'trade_no' => $this->tradeNo,\n            'refund_amount' => $this->refundAmount,\n            'out_request_no' => uniqid(), // Unique refund request number\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.refund',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n        return json_decode($response, true);\n    }\n\n    public function generateSign(array $params, $signType = \"RSA2\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA2\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = openssl_get_privatekey($priKey);\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        openssl_free_key($res);\n        $sign = base64_encode($sign);\n        return $sign;\n    }\n\n    public function checkEmpty($value)\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    public function getSignContent($params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = '';\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && '@' != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . '=' . $v . '&';\n            }\n        }\n        $stringToBeSigned = substr($stringToBeSigned, 0, strlen($stringToBeSigned) - 1);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array())\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // Set timeout\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n}",
      "<?php\n\nclass AlipayService {\n    protected $appId;\n    protected $returnUrl;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $outTradeNo;\n    protected $tradeNo;\n    protected $refundAmount;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setTradeNo($tradeNo)\n    {\n        $this->tradeNo = $tradeNo;\n    }\n\n\n    public function setRefundAmount($refundAmount)\n    {\n        $this->refundAmount = $refundAmount;\n    }\n\n    public function doRefund()\n    {\n        $bizContent = [\n            'out_trade_no' => $this->outTradeNo,\n            'trade_no' => $this->tradeNo,\n            'refund_amount' => $this->refundAmount,\n        ];\n\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.refund',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n\n        $params['sign'] = $this->generateSign($params);\n\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $response = $this->curlPost($url, $params);\n        return json_decode($response, true);\n    }\n\n    public function generateSign(array $params, $signType = \"RSA2\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA2\")\n    {\n        $priKey = $this->rsaPrivateKey;\n        $res = openssl_get_privatekey($priKey);\n        openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA256);\n        openssl_free_key($res);\n        return base64_encode($sign);\n    }\n\n    protected function checkEmpty($value)\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    public function getSignContent($params)\n    {\n        ksort($params);\n\n        $stringToBeSigned = '';\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && '@' != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . '=' . $v . '&';\n            }\n        }\n        $stringToBeSigned = substr($stringToBeSigned, 0, -1);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array())\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 60); // 设置cURL允许执行的最长秒数\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https请求 不验证证书和host\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}",
      "<?php\n\nclass AlipayService {\n    protected $appId;\n    protected $returnUrl;\n    protected $notifyUrl;\n    protected $charset = 'utf-8';\n    protected $rsaPrivateKey;\n    protected $outTradeNo;\n    protected $tradeNo;\n    protected $refundAmount;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setTradeNo($tradeNo)\n    {\n        $this->tradeNo = $tradeNo;\n    }\n\n    public function setRefundAmount($refundAmount)\n    {\n        $this->refundAmount = $refundAmount;\n    }\n\n    public function doRefund()\n    {\n        $bizContent = [\n            'out_trade_no' => $this->outTradeNo,\n            'trade_no' => $this->tradeNo,\n            'refund_amount' => $this->refundAmount,\n        ];\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.refund',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'biz_content' => json_encode($bizContent),\n        ];\n        $params['sign'] = $this->generateSign($params);\n        return $this->curlPost('https://openapi.alipay.com/gateway.do', $params);\n    }\n\n    public function generateSign(array $params, $signType = \"RSA2\")\n    {\n        return $this->sign($this->getSignContent($params), $signType);\n    }\n\n    protected function sign($data, $signType = \"RSA2\")\n    {\n        openssl_sign($data, $signature, $this->rsaPrivateKey, OPENSSL_ALGO_SHA256);\n        return base64_encode($signature);\n    }\n\n    protected function checkEmpty($value)\n    {\n        return $value === null || trim($value) === '';\n    }\n\n    protected function getSignContent(array $params)\n    {\n        ksort($params);\n        $stringToBeSigned = '';\n        foreach ($params as $k => $v) {\n            if (!$this->checkEmpty($v) && $k != 'sign' && \"@\" != substr($v, 0, 1)) {\n                $stringToBeSigned .= $k . '=' . $v . '&';\n            }\n        }\n        $stringToBeSigned = substr($stringToBeSigned, 0, -1);\n        return $stringToBeSigned;\n    }\n\n    protected function characet($data, $targetCharset)\n    {\n        if (!empty($data)) {\n            $fileType = mb_detect_encoding($data, 'UTF-8, ISO-8859-1, GBK');\n            if ($fileType != $targetCharset) {\n                $data = mb_convert_encoding($data, $targetCharset, $fileType);\n            }\n        }\n        return $data;\n    }\n\n    protected function curlPost($url = '', $postData = '', $options = array())\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30); //设置cURL允许执行的最长秒数\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        //https请求 不验证证书和host\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Create a PHP function that performs HTTP requests using cURL, supporting both GET and POST methods, with optional SSL verification and file upload safety checks.\n\nFunction Description: The function makes HTTP requests to a specified URL, with optional POST data. It handles SSL verification automatically based on the URL scheme (https/http) and includes safety checks for file uploads. The function returns the raw response from the server.\n\nInput:\n- $url: string - The target URL for the HTTP request\n- $data: mixed (optional) - Data to be sent with POST request (default: empty string)\n\nOutput:\n- string - The raw response data from the server\n- false - If the cURL request fails (though error handling is minimal in this implementation)",
    "Canonical_solution": "function curl($url, $data = '')\n{\n    $ch = curl_init();\n    if (class_exists('\\CURLFile')) {\n        curl_setopt($ch, CURLOPT_SAFE_UPLOAD, true);\n    } else {\n        if (defined('CURLOPT_SAFE_UPLOAD')) {\n            curl_setopt($ch, CURLOPT_SAFE_UPLOAD, false);\n        }\n    }\n    \n    preg_match('/https:\\/\\//', $url) ? $ssl = TRUE : $ssl = FALSE;\n    if ($ssl) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    }\n    \n    curl_setopt($ch, CURLOPT_URL, $url);\n    if (!empty($data)) {\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, \"POST\");\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n    \n    curl_setopt($ch, CURLOPT_HEADER, false);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $d = curl_exec($ch);\n    curl_close($ch);\n    return $d;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nfunction makeHttpRequest(string $url, mixed $data = ''): string|false {\n    $ch = curl_init($url);\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    } else {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    if (!empty($data)) {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if (is_array($data) && count(array_filter($data, 'is_file')) > 0) {\n            // If $data contains files, use the @ prefix for file uploads\n            foreach ($data as $key => $value) {\n                if (is_file($value)) {\n                    $data[$key] = new CURLFile($value);\n                }\n            }\n        }\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Minimal error handling\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, mixed $data = ''): string|false {\n    $ch = curl_init($url);\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    } else {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    if (!empty($data)) {\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n\n        // Basic safety check for file uploads\n        if (is_array($data)) {\n            foreach ($data as $key => $value) {\n                if (is_string($value) && strpos($value, '@') === 0) {\n                    if (!file_exists(substr($value, 1))) {\n                        return false; // Or throw an exception\n                    }\n                }\n            }\n        }\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        return false; // Minimal error handling\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, mixed $data = ''): string|false {\n    $ch = curl_init($url);\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    } else {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    if (!empty($data)) {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if (is_array($data) && count(array_filter($data, 'is_file')) > 0) {\n            // Handle file uploads safely\n            foreach ($data as $key => $value) {\n                if (is_file($value)) {\n                    $data[$key] = curl_file_create(realpath($value), mime_content_type($value), basename($value));\n                }\n            }\n        }\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Minimal error handling\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, mixed $data = ''): string|false {\n    $ch = curl_init($url);\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    } else {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    if (!empty($data)) {\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n\n        // Safety check for file uploads\n        if (is_array($data)) {\n            foreach ($data as $key => $value) {\n                if (is_string($value) && strpos($value, '@') === 0) {\n                    // Check if file exists to prevent path traversal attacks\n                    if (!file_exists(substr($value, 1))) {\n                        return false; // Or throw an exception\n                    }\n                    $data[$key] = curl_file_create(substr($value, 1));\n                }\n            }\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        }\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Minimal error handling\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, $data = ''): string|false {\n    $ch = curl_init($url);\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    } else {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    if (!empty($data)) {\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n\n        // Safety checks for file uploads\n        if (is_array($data)) {\n            foreach ($data as $key => $value) {\n                if (is_string($value) && strpos($value, '@') === 0) {\n                    // Check if file exists\n                    $filename = substr($value, 1);\n                    if (!file_exists($filename)) {\n                        return false; // Or throw an exception\n                    }\n                }\n            }\n        }\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Minimal error handling\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, $data = ''): string|false {\n    $ch = curl_init($url);\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    } else {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    if (!empty($data)) {\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n\n        // Safety check for file uploads\n        if (is_array($data)) {\n            foreach ($data as $key => $value) {\n                if (is_string($value) && strpos($value, '@') === 0) {\n                    // Check if file exists to prevent path traversal attacks\n                    if (!file_exists(substr($value, 1))) {\n                        return false; // Or throw an exception\n                    }\n                }\n            }\n        }\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Minimal error handling\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, $data = \"\") {\n    $ch = curl_init($url);\n\n    // Set cURL options\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n\n    // Check if it's a POST request and handle data accordingly\n    if (!empty($data)) {\n        curl_setopt($ch, CURLOPT_POST, true);\n\n        // Safety check for file uploads\n        if (is_array($data) && isset($data[array_key_first($data)]['tmp_name'])) {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n        } else {\n            curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data));\n        }\n    }\n\n    // SSL verification based on URL scheme\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    } else {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        return false; // Minimal error handling\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, mixed $data = ''): string|false {\n    $ch = curl_init($url);\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    } else {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    if (!empty($data)) {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if (is_array($data) && count(array_filter($data, 'is_file')) > 0) {\n            // If $data contains files, use the @ prefix for file uploads\n            foreach ($data as $key => $value) {\n                if (is_file($value)) {\n                    $data[$key] = new CURLFile($value);\n                }\n            }\n        }\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        // Minimal error handling\n        return false;\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, $data = ''): string|false {\n    $ch = curl_init($url);\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    } else {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    if (!empty($data)) {\n        curl_setopt($ch, CURLOPT_POST, true);\n        if (is_array($data) && count(array_filter($data, 'is_file')) > 0) {\n            // If $data contains files, use the @ syntax for uploads\n            foreach ($data as $key => $value) {\n                if (is_file($value)) {\n                    $data[$key] = new CURLFile($value);\n                }\n            }\n        }\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        return false; // Minimal error handling\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction makeHttpRequest(string $url, $data = ''): string|false {\n    $ch = curl_init($url);\n\n    if (strpos($url, 'https') === 0) {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n    } else {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);\n    }\n\n    if (!empty($data)) {\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n\n        // Safety checks for file uploads\n        if (is_array($data)) {\n            foreach ($data as $key => $value) {\n                if (is_string($value) && strpos($value, '@') === 0) {\n                    // Check if file exists\n                    if (!file_exists(substr($value, 1))) {\n                        return false; // Or throw an exception\n                    }\n                }\n            }\n        }\n    }\n\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        return false; // Minimal error handling\n    }\n\n    curl_close($ch);\n    return $response;\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 98,
    "Instruction": "Task Description: Implement a PHP class for interacting with Alipay's payment gateway, specifically for processing bar code payments. The class should handle request configuration, signature generation, and HTTP communication with Alipay's API.\n\nClass Description: The AlipayService class provides methods to configure and execute payments through Alipay's payment gateway. It handles parameter setting, request signing, and communication with Alipay's API endpoint.\n\nAttributes:\n- appId: [string] - The application ID provided by Alipay\n- charset: [string] - Character encoding (default: 'utf-8')\n- notifyUrl: [string] - URL for payment notifications\n- rsaPrivateKey: [string] - RSA private key for signing requests\n- totalFee: [string] - Total payment amount\n- outTradeNo: [string] - Merchant's unique order number\n- orderName: [string] - Description of the order\n- authCode: [string] - Customer's payment authorization code\n\nMethods:\n- __construct() -> [void] - Initializes the class with default charset\n- setAppid($appid) -> [void] - Sets the Alipay application ID\n- setNotifyUrl($notifyUrl) -> [void] - Sets the notification URL\n- setRsaPrivateKey($rsaPrivateKey) -> [void] - Sets the RSA private key\n- setTotalFee($payAmount) -> [void] - Sets the payment amount\n- setOutTradeNo($outTradeNo) -> [void] - Sets the merchant order number\n- setOrderName($orderName) -> [void] - Sets the order description\n- setAuthCode($authCode) -> [void] - Sets the customer's payment auth code\n- doPay() -> [array] - Executes the payment request and returns the response\n- curlPost($url, $postData, $options) -> [string] - Sends a POST request to the specified URL (private method)\n- generateSign($params, $signType) -> [string] - Generates the request signature (private method, implementation not shown)",
    "Canonical_solution": "class AlipayService\n{\n    protected $appId;\n    protected $charset;\n    protected $notifyUrl;\n    protected $rsaPrivateKey;\n    protected $totalFee;\n    protected $outTradeNo;\n    protected $orderName;\n    protected $authCode;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid)\n    {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl)\n    {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey)\n    {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($payAmount)\n    {\n        $this->totalFee = $payAmount;\n    }\n\n    public function setOutTradeNo($outTradeNo)\n    {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName)\n    {\n        $this->orderName = $orderName;\n    }\n\n    public function setAuthCode($authCode)\n    {\n        $this->authCode = $authCode;\n    }\n\n    public function doPay()\n    {\n        $requestConfigs = array(\n            'out_trade_no'=>$this->outTradeNo,\n            'scene'=>'bar_code',\n            'auth_code'=>$this->authCode,\n            'total_amount'=>$this->totalFee,\n            'subject'=>$this->orderName,\n            'store_id'=>'DEDEMAO_001',\n            'timeout_express'=>'2m',\n        );\n        $commonConfigs = array(\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.pay',\n            'format' => 'JSON',\n            'charset'=>$this->charset,\n            'sign_type'=>'RSA2',\n            'timestamp'=>date('Y-m-d H:i:s'),\n            'version'=>'1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content'=>json_encode($requestConfigs),\n        );\n        $commonConfigs[\"sign\"] = $this->generateSign($commonConfigs, $commonConfigs['sign_type']);\n        $result = $this->curlPost('https://openapi.alipay.com/gateway.do?charset='.$this->charset,$commonConfigs);\n        return json_decode($result,true);\n    }\n\n    public function curlPost($url = '', $postData = '', $options = array())\n    {\n        if (is_array($postData)) {\n            $postData = http_build_query($postData);\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $data = curl_exec($ch);\n        curl_close($ch);\n        return $data;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nclass AlipayService {\n    private $appId;\n    private $charset = 'utf-8';\n    private $notifyUrl;\n    private $rsaPrivateKey;\n    private $totalFee;\n    private $outTradeNo;\n    private $orderName;\n    private $authCode;\n\n    public function __construct() {}\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function setAuthCode($authCode) {\n        $this->authCode = $authCode;\n    }\n\n    public function doPay() {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_trade_no' => $this->outTradeNo,\n                'total_amount' => $this->totalFee,\n                'subject' => $this->orderName,\n                'scene' => 'bar_code',\n                'auth_code' => $this->authCode,\n                'product_code' => 'FACE_TO_FACE_PAYMENT'\n            ])\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, http_build_query($params));\n        return json_decode($result, true);\n    }\n\n    private function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    private function generateSign($params, $signType) {\n        // Implementation for generating signature (not provided in prompt)\n        return ''; // Placeholder\n    }\n}\n\n?>",
      "<?php\n\nclass AlipayService {\n    private $appId;\n    private $charset = 'utf-8';\n    private $notifyUrl;\n    private $rsaPrivateKey;\n    private $totalFee;\n    private $outTradeNo;\n    private $orderName;\n    private $authCode;\n\n    public function __construct()\n    {\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function setAuthCode($authCode) {\n        $this->authCode = $authCode;\n    }\n\n    public function doPay() {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_trade_no' => $this->outTradeNo,\n                'total_amount' => $this->totalFee,\n                'subject' => $this->orderName,\n                'scene' => 'bar_code',\n                'auth_code' => $this->authCode,\n                'product_code' => 'FACE_TO_FACE_PAYMENT'\n            ])\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, http_build_query($params));\n        return json_decode($result, true);\n    }\n\n    private function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    private function generateSign($params, $signType) {\n        // Implementation for generating signature (not provided in prompt)\n        return ''; // Placeholder\n    }\n}",
      "<?php\n\nclass AlipayService {\n    private $appId;\n    private $charset = 'utf-8';\n    private $notifyUrl;\n    private $rsaPrivateKey;\n    private $totalFee;\n    private $outTradeNo;\n    private $orderName;\n    private $authCode;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function setAuthCode($authCode) {\n        $this->authCode = $authCode;\n    }\n\n    public function doPay() {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_trade_no' => $this->outTradeNo,\n                'total_amount' => $this->totalFee,\n                'subject' => $this->orderName,\n                'scene' => 'bar_code',\n                'auth_code' => $this->authCode,\n                'product_code' => 'FACE_TO_FACE_PAYMENT'\n            ])\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, http_build_query($params));\n        return json_decode($result, true);\n    }\n\n    private function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    private function generateSign($params, $signType) {\n        // Implementation for generating signature (not provided in prompt)\n        return ''; // Placeholder\n    }\n}",
      "<?php\n\nclass AlipayService {\n    private $appId;\n    private $charset = 'utf-8';\n    private $notifyUrl;\n    private $rsaPrivateKey;\n    private $totalFee;\n    private $outTradeNo;\n    private $orderName;\n    private $authCode;\n\n    public function __construct()\n    {\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function setAuthCode($authCode) {\n        $this->authCode = $authCode;\n    }\n\n    public function doPay() {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_trade_no' => $this->outTradeNo,\n                'total_amount' => $this->totalFee,\n                'subject' => $this->orderName,\n                'scene' => 'bar_code',\n                'auth_code' => $this->authCode,\n                'product_code' => 'FACE_TO_FACE_PAYMENT'\n            ])\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, http_build_query($params));\n        return json_decode($result, true);\n    }\n\n    private function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    private function generateSign($params, $signType) {\n        // Implementation for generating signature (not provided in the prompt)\n        return ''; // Placeholder\n    }\n}",
      "<?php\n\nclass AlipayService {\n    private $appId;\n    private $charset = 'utf-8';\n    private $notifyUrl;\n    private $rsaPrivateKey;\n    private $totalFee;\n    private $outTradeNo;\n    private $orderName;\n    private $authCode;\n\n    public function __construct()\n    {\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function setAuthCode($authCode) {\n        $this->authCode = $authCode;\n    }\n\n    public function doPay() {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_trade_no' => $this->outTradeNo,\n                'total_amount' => $this->totalFee,\n                'subject' => $this->orderName,\n                'scene' => 'bar_code',\n                'auth_code' => $this->authCode,\n                'product_code' => 'FACE_TO_FACE_PAYMENT'\n            ])\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, http_build_query($params));\n        return json_decode($result, true);\n    }\n\n    private function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    private function generateSign($params, $signType) {\n        // Implementation for generating signature (not provided in prompt)\n        return ''; // Placeholder\n    }\n}",
      "<?php\n\nclass AlipayService {\n    private $appId;\n    private $charset = 'utf-8';\n    private $notifyUrl;\n    private $rsaPrivateKey;\n    private $totalFee;\n    private $outTradeNo;\n    private $orderName;\n    private $authCode;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function setAuthCode($authCode) {\n        $this->authCode = $authCode;\n    }\n\n    public function doPay() {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_trade_no' => $this->outTradeNo,\n                'total_amount' => $this->totalFee,\n                'subject' => $this->orderName,\n                'scene' => 'bar_code',\n                'auth_code' => $this->authCode,\n                'product_code' => 'FACE_TO_FACE_PAYMENT'\n            ])\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, http_build_query($params));\n        return json_decode($result, true);\n    }\n\n    private function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    private function generateSign($params, $signType) {\n        // Implementation for generating signature (not shown here)\n        return ''; // Placeholder\n    }\n}",
      "<?php\n\nclass AlipayService {\n    private $appId;\n    private $charset = 'utf-8';\n    private $notifyUrl;\n    private $rsaPrivateKey;\n    private $totalFee;\n    private $outTradeNo;\n    private $orderName;\n    private $authCode;\n\n    public function __construct()\n    {\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function setAuthCode($authCode) {\n        $this->authCode = $authCode;\n    }\n\n    public function doPay() {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_trade_no' => $this->outTradeNo,\n                'total_amount' => $this->totalFee,\n                'subject' => $this->orderName,\n                'scene' => 'bar_code',\n                'auth_code' => $this->authCode,\n                'product_code' => 'FACE_TO_FACE_PAYMENT'\n            ])\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, http_build_query($params));\n        return json_decode($result, true);\n    }\n\n    private function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    private function generateSign($params, $signType) {\n        // Implementation for generating signature (not provided in prompt)\n        return ''; // Placeholder\n    }\n}",
      "<?php\n\nclass AlipayService {\n    private $appId;\n    private $charset = 'utf-8';\n    private $notifyUrl;\n    private $rsaPrivateKey;\n    private $totalFee;\n    private $outTradeNo;\n    private $orderName;\n    private $authCode;\n\n    public function __construct()\n    {\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function setAuthCode($authCode) {\n        $this->authCode = $authCode;\n    }\n\n    public function doPay() {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_trade_no' => $this->outTradeNo,\n                'total_amount' => $this->totalFee,\n                'subject' => $this->orderName,\n                'scene' => 'bar_code',\n                'auth_code' => $this->authCode,\n                'product_code' => 'FACE_TO_FACE_PAYMENT'\n            ])\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, http_build_query($params));\n        return json_decode($result, true);\n    }\n\n    private function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    private function generateSign($params, $signType) {\n        // Implementation for generating signature (not provided in prompt)\n        return ''; // Placeholder\n    }\n}",
      "<?php\n\nclass AlipayService {\n    private $appId;\n    private $charset = 'utf-8';\n    private $notifyUrl;\n    private $rsaPrivateKey;\n    private $totalFee;\n    private $outTradeNo;\n    private $orderName;\n    private $authCode;\n\n    public function __construct()\n    {\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function setAuthCode($authCode) {\n        $this->authCode = $authCode;\n    }\n\n    public function doPay() {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_trade_no' => $this->outTradeNo,\n                'total_amount' => $this->totalFee,\n                'subject' => $this->orderName,\n                'scene' => 'bar_code',\n                'auth_code' => $this->authCode,\n                'product_code' => 'FACE_TO_FACE_PAYMENT'\n            ])\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, http_build_query($params));\n        return json_decode($result, true);\n    }\n\n    private function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n\n        if (!empty($options)) {\n            curl_setopt_array($ch, $options);\n        }\n\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    private function generateSign($params, $signType) {\n        // Implementation for generating signature (not provided in prompt)\n        return ''; // Placeholder\n    }\n}",
      "<?php\n\nclass AlipayService {\n    private $appId;\n    private $charset = 'utf-8';\n    private $notifyUrl;\n    private $rsaPrivateKey;\n    private $totalFee;\n    private $outTradeNo;\n    private $orderName;\n    private $authCode;\n\n    public function __construct()\n    {\n        $this->charset = 'utf-8';\n    }\n\n    public function setAppid($appid) {\n        $this->appId = $appid;\n    }\n\n    public function setNotifyUrl($notifyUrl) {\n        $this->notifyUrl = $notifyUrl;\n    }\n\n    public function setRsaPrivateKey($rsaPrivateKey) {\n        $this->rsaPrivateKey = $rsaPrivateKey;\n    }\n\n    public function setTotalFee($totalFee) {\n        $this->totalFee = $totalFee;\n    }\n\n    public function setOutTradeNo($outTradeNo) {\n        $this->outTradeNo = $outTradeNo;\n    }\n\n    public function setOrderName($orderName) {\n        $this->orderName = $orderName;\n    }\n\n    public function setAuthCode($authCode) {\n        $this->authCode = $authCode;\n    }\n\n    public function doPay() {\n        $params = [\n            'app_id' => $this->appId,\n            'method' => 'alipay.trade.pay',\n            'charset' => $this->charset,\n            'sign_type' => 'RSA2',\n            'timestamp' => date('Y-m-d H:i:s'),\n            'version' => '1.0',\n            'notify_url' => $this->notifyUrl,\n            'biz_content' => json_encode([\n                'out_trade_no' => $this->outTradeNo,\n                'total_amount' => $this->totalFee,\n                'subject' => $this->orderName,\n                'scene' => 'bar_code',\n                'auth_code' => $this->authCode,\n                'product_code' => 'FACE_TO_FACE_PAYMENT'\n            ])\n        ];\n\n        $params['sign'] = $this->generateSign($params, 'RSA2');\n        $url = 'https://openapi.alipay.com/gateway.do';\n        $result = $this->curlPost($url, http_build_query($params));\n        return json_decode($result, true);\n    }\n\n    private function curlPost($url, $postData, $options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POST, 1);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        $response = curl_exec($ch);\n        curl_close($ch);\n        return $response;\n    }\n\n    private function generateSign($params, $signType) {\n        // Implementation for generating signature (not provided in prompt)\n        return ''; // Placeholder\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a PHP function that makes an HTTP POST request to the OpenAI API's image generation endpoint using cURL, with proper headers, timeout settings, and error handling.\n\nFunction Description: The function sends a POST request to the OpenAI API to generate images based on the provided input data. It sets up necessary headers including authentication, configures cURL options for secure communication (with SSL verification disabled for testing purposes), handles redirects, and manages timeout settings. The function returns the raw API response.\n\nInput:\n- $postData: [string] - JSON-encoded string containing the image generation parameters\n- $OPENAI_API_KEY: [string] - The API key for authenticating with OpenAI's service\n\nOutput:\n- [string] - The raw response data from the API call, which should be a JSON string containing either the generated image information or an error message",
    "Canonical_solution": "function call_openai_api($postData, $OPENAI_API_KEY)\n{\n    $headers = [\n        'Accept: application/json',\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    ];\n\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\n    curl_setopt($ch, CURLOPT_URL, 'https://api.openai.com/v1/images/generations');\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 120);\n    curl_setopt($ch, CURLOPT_MAXREDIRS, 3);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_AUTOREFERER, true);\n\n    $responsedata = curl_exec($ch);\n    curl_close($ch);\n\n    return $responsedata;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 132,
    "matched_results": [
      "<?php\n\nfunction generateImageOpenAI($postData, $OPENAI_API_KEY) {\n    $url = 'https://api.openai.com/v1/images/generations';\n\n    $headers = [\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    ];\n\n    $ch = curl_init($url);\n\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // Disable SSL verification for testing. Consider enabling in production.\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); // Follow redirects\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); // Set timeout to 30 seconds\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return false; // Or handle the error as needed\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction generateImageFromOpenAI(string $postData, string $OPENAI_API_KEY): string\n{\n    $url = 'https://api.openai.com/v1/images/generations';\n\n    $headers = [\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    ];\n\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_POST => true,\n        CURLOPT_POSTFIELDS => $postData,\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification for testing.  In production, set to true and ensure appropriate certificates are installed.\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL verification for testing. In production, set to true and ensure appropriate certificates are installed.\n        CURLOPT_FOLLOWLOCATION => true, // Follow redirects\n        CURLOPT_TIMEOUT => 30, // Set timeout in seconds\n        CURLOPT_CONNECTTIMEOUT => 10 // Set connection timeout in seconds\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        curl_close($ch);\n        throw new Exception(\"cURL error: \" . $error);\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        curl_close($ch);\n        throw new Exception(\"HTTP error: \" . $httpCode . \": \" . $response);\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction generateImageFromOpenAI(string $postData, string $OPENAI_API_KEY): string\n{\n    $url = 'https://api.openai.com/v1/images/generations';\n\n    $headers = [\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    ];\n\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_POST => true,\n        CURLOPT_POSTFIELDS => $postData,\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification for testing. In production, set to true.\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL verification for testing. In production, set to true.\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_TIMEOUT => 60, // Set timeout to 60 seconds\n        CURLOPT_CONNECTTIMEOUT => 10 // Set connection timeout to 10 seconds\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        curl_close($ch);\n        throw new Exception(\"cURL error: \" . $error);\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        curl_close($ch);\n        throw new Exception(\"HTTP error: \" . $httpCode . \": \" . $response);\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction generateImageFromOpenAI(string $postData, string $OPENAI_API_KEY): string\n{\n    $url = 'https://api.openai.com/v1/images/generations';\n\n    $headers = [\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    ];\n\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_POST => true,\n        CURLOPT_POSTFIELDS => $postData,\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification for testing. Consider enabling in production.\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL verification for testing. Consider enabling in production.\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_TIMEOUT => 60, // Set timeout to 60 seconds\n        CURLOPT_CONNECTTIMEOUT => 10 // Set connection timeout to 10 seconds\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        curl_close($ch);\n        throw new Exception(\"cURL error: \" . $error);\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        curl_close($ch);\n        throw new Exception(\"HTTP error: \" . $httpCode . ' - ' . $response);\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction generateImageFromOpenAI(string $postData, string $OPENAI_API_KEY): string\n{\n    $url = 'https://api.openai.com/v1/images/generations';\n\n    $headers = [\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    ];\n\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_POST => true,\n        CURLOPT_POSTFIELDS => $postData,\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification for testing.  In production, set to true and ensure appropriate certificates are installed.\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL verification for testing. In production, set to true and ensure appropriate certificates are installed.\n        CURLOPT_FOLLOWLOCATION => true, // Follow redirects\n        CURLOPT_TIMEOUT => 30, // Set timeout in seconds\n        CURLOPT_CONNECTTIMEOUT => 10 // Set connection timeout in seconds\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        curl_close($ch);\n        throw new Exception(\"cURL error: \" . $error);\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        curl_close($ch);\n        throw new Exception(\"HTTP error: \" . $httpCode . \", Response: \" . $response);\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction generateImageFromOpenAI(string $postData, string $OPENAI_API_KEY): string\n{\n    $url = 'https://api.openai.com/v1/images/generations';\n\n    $headers = [\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY,\n    ];\n\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_POST => true,\n        CURLOPT_POSTFIELDS => $postData,\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification for testing. In production, set to true.\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL verification for testing. In production, set to true.\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_CONNECTTIMEOUT => 10, // Set connection timeout to 10 seconds\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        curl_close($ch);\n        throw new Exception(\"cURL error: \" . $error);\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        curl_close($ch);\n        throw new Exception(\"HTTP error: \" . $httpCode . \", Response: \" . $response);\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction generateImageOpenAI($postData, $OPENAI_API_KEY) {\n    $url = 'https://api.openai.com/v1/images/generations';\n\n    $headers = [\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    ];\n\n    $ch = curl_init($url);\n\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // Disable SSL verification for testing only!\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); // Set timeout to 30 seconds\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10); // Set connection timeout to 10 seconds\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return false; // Or handle the error as needed\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) { // Check for HTTP errors\n        error_log('HTTP Error: ' . $httpCode);\n        // Optionally parse the JSON response for more detailed error information\n        $error = json_decode($response, true);\n        if (isset($error['error'])) {\n            error_log('OpenAI Error: ' . json_encode($error['error']));\n        }\n        return false; // Or handle the error as needed\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction generateImageOpenAI($postData, $OPENAI_API_KEY) {\n    $url = 'https://api.openai.com/v1/images/generations';\n\n    $headers = [\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    ];\n\n    $ch = curl_init($url);\n\n    curl_setopt($ch, CURLOPT_POST, 1);\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // Disable SSL verification for testing only!\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 30); // Set timeout to 30 seconds\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10); // Set connection timeout to 10 seconds\n\n    $response = curl_exec($ch);\n\n    if (curl_errno($ch)) {\n        error_log('cURL Error: ' . curl_error($ch));\n        return false; // Or handle the error as needed\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        error_log('API Error: HTTP Code ' . $httpCode . ', Response: ' . $response);\n        return false; // Or handle the error as needed\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction generateImageFromOpenAI(string $postData, string $OPENAI_API_KEY): string\n{\n    $url = 'https://api.openai.com/v1/images/generations';\n\n    $headers = [\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY\n    ];\n\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_POST => true,\n        CURLOPT_POSTFIELDS => $postData,\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification for testing. In production, set to true.\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL verification for testing. In production, set to true.\n        CURLOPT_FOLLOWLOCATION => true,\n        CURLOPT_TIMEOUT => 30, // Set timeout to 30 seconds\n        CURLOPT_CONNECTTIMEOUT => 10 // Set connection timeout to 10 seconds\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        curl_close($ch);\n        throw new Exception(\"cURL error: \" . $error);\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        curl_close($ch);\n        throw new Exception(\"HTTP error: \" . $httpCode . \": \" . $response);\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>",
      "<?php\n\nfunction generateImageFromOpenAI(string $postData, string $OPENAI_API_KEY): string\n{\n    $url = 'https://api.openai.com/v1/images/generations';\n\n    $headers = [\n        'Content-Type: application/json',\n        'Authorization: Bearer ' . $OPENAI_API_KEY,\n    ];\n\n    $ch = curl_init($url);\n\n    curl_setopt_array($ch, [\n        CURLOPT_POST => true,\n        CURLOPT_POSTFIELDS => $postData,\n        CURLOPT_HTTPHEADER => $headers,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_SSL_VERIFYPEER => false, // Disable SSL verification for testing. In production, set to true.\n        CURLOPT_SSL_VERIFYHOST => false, // Disable SSL verification for testing. In production, set to true.\n        CURLOPT_FOLLOWLOCATION => true, // Follow redirects\n        CURLOPT_TIMEOUT => 30, // Set timeout in seconds\n    ]);\n\n    $response = curl_exec($ch);\n\n    if ($response === false) {\n        $error = curl_error($ch);\n        curl_close($ch);\n        throw new Exception(\"cURL error: \" . $error);\n    }\n\n    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n\n    if ($httpCode >= 400) {\n        curl_close($ch);\n        throw new Exception(\"API error: \" . $response . \", HTTP Code: \" . $httpCode);\n    }\n\n    curl_close($ch);\n\n    return $response;\n}\n\n?>"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  }
]