[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a PHP class that interacts with an Ollama API to generate responses using HTTP requests through the Guzzle HTTP client.\n\nClass Description: The Ollama class is designed to communicate with an Ollama API endpoint to generate responses based on provided prompts. It handles the configuration of the API request and processes the response.\n\nAttributes:\n- model: string - The name of the AI model to be used for generating responses.\n- prompt: string - The input text prompt to be sent to the AI model.\n- temperature: float - Controls the randomness of the output (higher values make output more random).\n- stream: bool - Determines whether the response should be streamed.\n- raw: bool - Specifies whether to use raw mode for the prompt processing.\n\nMethods:\n- __construct(string $model, string $prompt, float $temperature, bool $stream, bool $raw) -> void - Initializes the Ollama instance with the specified parameters for model interaction.\n- ask() -> string - Sends a POST request to the Ollama API with the configured parameters and returns the generated response from the AI model.",
    "Canonical_solution": "use GuzzleHttp\\Client;\n\nclass Ollama\n{\n    /**\n     * New service instance.\n     */\n    public function __construct(\n        protected string $model,\n        protected string $prompt,\n        protected float $temperature,\n        protected bool $stream,\n        protected bool $raw,\n    ) {}\n\n    /**\n     * Set LLM prompt text.\n     */\n    public function ask(): string\n    {\n        $httpClient = new Client;\n\n        $endpoint = core()->getConfigData('general.magic_ai.settings.api_domain').'/api/generate';\n\n        $result = $httpClient->request('POST', $endpoint, [\n            'headers' => [\n                'Accept' => 'application/json',\n            ],\n            'json'    => [\n                'model'  => $this->model,\n                'prompt' => $this->prompt,\n                'raw'    => $this->raw,\n                'stream' => $this->stream,\n            ],\n        ]);\n\n        $result = json_decode($result->getBody()->getContents(), true);\n\n        return $result['response'];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nrequire 'vendor/autoload.php';\n\nuse GuzzleHttp\\Client;\n\nclass Ollama {\n    private $model;\n    private $prompt;\n    private $temperature;\n    private $stream;\n    private $raw;\n    private $client;\n\n    public function __construct(string $model, string $prompt, float $temperature, bool $stream, bool $raw) {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n        $this->client = new Client();\n    }\n\n    public function ask(): string {\n        $response = $this->client->post('https://api.ollama.com/generate', [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw\n            ]\n        ]);\n\n        return $response->getBody()->getContents();\n    }\n}\n\n?>\n```"
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client for sending payment requests to an e-payment API using Guzzle.\n\nClass Description: The EpayHttpClient class is designed to handle HTTP communication with an e-payment API. It encapsulates the functionality for sending payment requests and processing the responses. The class uses Guzzle HTTP client for making requests and handles potential exceptions that may occur during the process.\n\nAttributes:\n- epay: array - Stores the configuration for the e-payment API\n- client: Client - The Guzzle HTTP client instance used for making requests\n\nMethods:\n- __construct(array $epayConfig) -> void - Initializes the class with e-payment configuration and creates a new Guzzle Client instance\n- sendPaymentRequest(array $data) -> array - Sends a payment request to the API endpoint and processes the response. Returns an array indicating success/failure and containing either the payment URL or an error message",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    protected array $epay;\n    protected Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $res = $this->client->request('POST', $this->epay['apiurl'] . 'mapi.php', ['form_params' => $data]);\n\n            if ($res->getStatusCode() !== 200) {\n                throw new Exception();\n            }\n\n            $resData = json_decode($res->getBody()->__toString(), true);\n\n            if ($resData['code'] !== 1 || !isset($resData['payurl'])) {\n                throw new Exception();\n            }\n\n            return [\n                'success' => true,\n                'payurl' => $resData['payurl']\n            ];\n        } catch (Exception|GuzzleException) {\n            return [\n                'success' => false,\n                'error' => '\u8bf7\u6c42\u652f\u4ed8\u5931\u8d25'\n            ];\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    private $epay;\n    private $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client([\n            'base_uri' => $this->epay['base_uri'],\n            'timeout'  => $this->epay['timeout'] ?? 10,\n        ]);\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['endpoint'], [\n                'json' => $data,\n                'headers' => [\n                    'Authorization' => 'Bearer ' . $this->epay['api_key'],\n                    'Content-Type' => 'application/json',\n                ],\n            ]);\n\n            $body = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200 && isset($body['payment_url'])) {\n                return [\n                    'success' => true,\n                    'payment_url' => $body['payment_url'],\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => 'Invalid response from API',\n                ];\n            }\n        } catch (GuzzleException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage(),\n            ];\n        }\n    }\n}\n\n?>\n```"
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a PHP function that fetches content from a specified HTTP URL using fsockopen for low-level HTTP communication, with support for proxies and basic authentication.\n\nFunction Description: The function establishes a TCP connection to an HTTP server (or proxy), sends an HTTP GET request, reads the response, and returns the response body. It handles URL parsing, proxy configuration, timeout settings, and basic authentication. The function can either return the content directly or assign it to a template variable.\n\nInput:\n- $params: An associative array containing:\n  - 'file': (string, required) The HTTP URL to fetch\n  - 'assign': (string, optional) Template variable name to assign content to\n  - 'proxy_host': (string, optional) Proxy server hostname\n  - 'proxy_port': (int, optional) Proxy server port\n  - 'timeout': (int, optional) Connection timeout in seconds (default: 30)\n- $template: (object) The template object for assigning content (when 'assign' parameter is used)\n\nOutput:\n- Returns the fetched content as a string if 'assign' parameter is not provided\n- Assigns content to the specified template variable and returns nothing if 'assign' parameter is provided\n- Returns nothing and triggers notice on error conditions (invalid URL, connection failure)",
    "Canonical_solution": "function smarty_function_fetch($params, $template)\n{\n    if (empty($params['file'])) {\n        trigger_error(\"[plugin] fetch parameter 'file' cannot be empty\", E_USER_NOTICE);\n        return;\n    }\n\n    $content = '';\n    if (preg_match('!^http://!i', $params['file'])) {\n        if ($uri_parts = parse_url($params['file'])) {\n            $host = $server_name = $uri_parts['host'];\n            $timeout = 30;\n            $port = empty($uri_parts['port']) ? 80 : $uri_parts['port'];\n            $user = empty($uri_parts['user']) ? null : $uri_parts['user'];\n            $pass = empty($uri_parts['pass']) ? null : $uri_parts['pass'];\n            $uri = !empty($uri_parts['path']) ? $uri_parts['path'] : '/';\n            $uri .= !empty($uri_parts['query']) ? '?' . $uri_parts['query'] : '';\n            \n            $_is_proxy = false;\n            foreach ($params as $param_key => $param_value) {\n                switch ($param_key) {\n                    case \"proxy_host\":\n                        $proxy_host = $param_value;\n                        break;\n                    case \"proxy_port\":\n                        $proxy_port = (int)$param_value;\n                        break;\n                    case \"timeout\":\n                        $timeout = (int)$param_value;\n                        break;\n                }\n            }\n\n            if (!empty($proxy_host) && !empty($proxy_port)) {\n                $_is_proxy = true;\n                $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, $timeout);\n            } else {\n                $fp = fsockopen($server_name, $port, $errno, $errstr, $timeout);\n            }\n\n            if (!$fp) {\n                trigger_error(\"[plugin] unable to fetch: $errstr ($errno)\", E_USER_NOTICE);\n                return;\n            }\n\n            if ($_is_proxy) {\n                fputs($fp, 'GET ' . $params['file'] . \" HTTP/1.0\\r\\n\");\n            } else {\n                fputs($fp, \"GET $uri HTTP/1.0\\r\\n\");\n            }\n            fputs($fp, \"Host: $host\\r\\n\");\n            if (!empty($user) && !empty($pass)) {\n                fputs($fp, \"Authorization: BASIC \" . base64_encode(\"$user:$pass\") . \"\\r\\n\");\n            }\n            fputs($fp, \"\\r\\n\");\n\n            while (!feof($fp)) {\n                $content .= fgets($fp, 4096);\n            }\n            fclose($fp);\n\n            $csplit = preg_split(\"!\\r\\n\\r\\n!\", $content, 2);\n            $content = $csplit[1];\n        }\n    }\n\n    if (!empty($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 131,
    "wrong_result": "```php\nfunction fetchHttpContent($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!$url) {\n        trigger_error('Invalid URL', E_USER_NOTICE);\n        return;\n    }\n\n    $host = $url['host'];\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    $query = isset($url['query']) ? '?' . $url['query'] : '';\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n\n    $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : '';\n    $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : '';\n\n    if ($proxy_host) {\n        $host = $proxy_host;\n        $port = $proxy_port;\n        $request = \"GET http://{$url['host']}{$path}{$query} HTTP/1.0\\r\\n\";\n    } else {\n        $request = \"GET {$path}{$query} HTTP/1.0\\r\\n\";\n    }\n\n    $request .= \"Host: {$url['host']}\\r\\n\";\n    if (isset($url['user']) && isset($url['pass'])) {\n        $request .= \"Authorization: Basic \" . base64_encode(\"{$url['user']}:{$url['pass']}\") . \"\\r\\n\";\n    }\n    $request .= \"Connection: Close\\r\\n\\r\\n\";\n\n    $fp = @fsockopen($host, $port, $errno, $errstr, $timeout);\n    if (!$fp) {\n        trigger_error(\"Connection failed: $errstr ($errno)\", E_USER_NOTICE);\n        return;\n    }\n\n    fwrite($fp, $request);\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 128);\n    }\n    fclose($fp);\n\n    $body = substr($response, strpos($response, \"\\r\\n\\r\\n\") + 4);\n\n    if (isset($params['assign'])) {\n        $template->{$params['assign']} = $body;\n    } else {\n        return $body;\n    }\n}\n```"
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Implement a class that handles HTTP POST requests to Google's reCAPTCHA verification service using low-level socket operations in PHP.\n\nClass Description: ReCaptchaSocketPostRequestMethod is a class that implements reCAPTCHA verification by establishing a direct socket connection to Google's servers, sending an HTTP POST request, and processing the response. It provides an alternative to higher-level HTTP clients.\n\nAttributes:\n- socket: [ReCaptchaSocket] - The socket connection handler used for HTTP communication\n- RECAPTCHA_HOST: [string] - Constant storing Google's reCAPTCHA hostname ('www.google.com')\n- SITE_VERIFY_PATH: [string] - Constant storing the reCAPTCHA verification endpoint path ('/recaptcha/api/siteverify')\n- BAD_REQUEST: [string] - Constant JSON response for failed requests\n- BAD_RESPONSE: [string] - Constant JSON response for invalid server responses\n\nMethods:\n- __construct([ReCaptchaSocket $socket = null]) -> [void] - Initializes the class with an optional socket dependency injection\n- submit(ReCaptchaRequestParameters $params) -> [string] - Performs the reCAPTCHA verification by:\n  1. Opening an SSL socket connection to Google's server\n  2. Formatting and sending an HTTP POST request with verification parameters\n  3. Reading and parsing the server response\n  4. Returning the verification result as JSON string\n  Returns either the server response or error JSON if the request/response fails",
    "Canonical_solution": "class ReCaptchaSocketPostRequestMethod implements ReCaptchaRequestMethod\n{\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"invalid-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n    private $socket;\n\n    public function __construct(ReCaptchaSocket $socket = null)\n    {\n        if (!is_null($socket)) {\n            $this->socket = $socket;\n        } else {\n            $this->socket = new ReCaptchaSocket();\n        }\n    }\n\n    public function submit(ReCaptchaRequestParameters $params)\n    {\n        $errno = 0;\n        $errstr = '';\n\n        if (false === $this->socket->fsockopen('ssl://' . self::RECAPTCHA_HOST, 443, $errno, $errstr, 30)) {\n            return self::BAD_REQUEST;\n        }\n\n        $content = $params->toQueryString();\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-length: \" . strlen($content) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $content . \"\\r\\n\\r\\n\";\n\n        $this->socket->fwrite($request);\n        $response = '';\n\n        while (!$this->socket->feof()) {\n            $response .= $this->socket->fgets(4096);\n        }\n\n        $this->socket->fclose();\n\n        if (0 !== strpos($response, 'HTTP/1.1 200 OK')) {\n            return self::BAD_RESPONSE;\n        }\n\n        $parts = preg_split(\"#\\n\\s*\\n#Uis\", $response);\n\n        return $parts[1];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 131,
    "wrong_result": "class ReCaptchaSocketPostRequestMethod {\n    private $socket;\n    private const RECAPTCHA_HOST = 'www.google.com';\n    private const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    private const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"bad-request\"]}';\n    private const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"bad-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null) {\n        $this->socket = $socket ?? new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params): string {\n        $host = self::RECAPTCHA_HOST;\n        $path = self::SITE_VERIFY_PATH;\n        $query = http_build_query($params->toArray());\n        $request = \"POST $path HTTP/1.1\\r\\n\";\n        $request .= \"Host: $host\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-Length: \" . strlen($query) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $query;\n\n        $socket = fsockopen('ssl://' . $host, 443, $errno, $errstr, 30);\n        if (!$socket) {\n            return self::BAD_REQUEST;\n        }\n\n        fwrite($socket, $request);\n        $response = '';\n        while (!feof($socket)) {\n            $response .= fgets($socket, 4096);\n        }\n        fclose($socket);\n\n        $parts = explode(\"\\r\\n\\r\\n\", $response, 2);\n        if (count($parts) < 2) {\n            return self::BAD_RESPONSE;\n        }\n\n        return $parts[1];\n    }\n}\n\nclass ReCaptchaSocket {\n    public function __construct() {\n        // Socket initialization logic if needed\n    }\n}\n\nclass ReCaptchaRequestParameters {\n    private $secret;\n    private $response;\n    private $remoteip;\n\n    public function __construct($secret, $response, $remoteip = null) {\n        $this->secret = $secret;\n        $this->response = $response;\n        $this->remoteip = $remoteip;\n    }\n\n    public function toArray(): array {\n        $params = [\n            'secret' => $this->secret,\n            'response' => $this->response\n        ];\n        if ($this->remoteip !== null) {\n            $params['remoteip'] = $this->remoteip;\n        }\n        return $params;\n    }\n}"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a PHP class that handles file uploads to a specified host using HTTP PUT requests with Guzzle HTTP client, including CRC32 checksum verification.\n\nClass Description: ImageX is a class that extends V4Curl and provides functionality to upload files to a remote server. It handles file validation, CRC32 checksum generation, and HTTP communication using Guzzle's HTTP client.\n\nAttributes: (No explicit attributes in this class - it inherits from V4Curl)\n\nMethods:\nupload: [upload](string $uploadHost, array $storeInfo, string $filePath) -> int - Uploads a file to the specified host using HTTP PUT request. Validates file existence, calculates CRC32 checksum, and sends the file with appropriate headers. Returns 0 on success, -1 if file doesn't exist, or -2 if upload fails.\n\nParameters:\n- $uploadHost: string - The host address to upload to\n- $storeInfo: array - Contains 'StoreUri' for upload endpoint and 'Auth' for authorization\n- $filePath: string - Local path to the file to be uploaded\n\nReturn:\n- int: 0 for success, -1 for file not found, -2 for upload failure",
    "Canonical_solution": "use Volc\\Base\\V4Curl;\nuse GuzzleHttp\\Client;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, $storeInfo, string $filePath)\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n        $content = file_get_contents($filePath);\n        $crc32 = sprintf(\"%08x\", crc32($content));\n\n        $body = fopen($filePath, \"r\");\n        $tosClient = new Client([\n            'base_uri' => \"https://\" . $uploadHost,\n            'timeout' => 5.0,\n        ]);\n\n        $response = $tosClient->request('PUT', $storeInfo[\"StoreUri\"], [\"body\" => $body, \"headers\" => ['Authorization' => $storeInfo[\"Auth\"], 'Content-CRC32' => $crc32]]);\n        $uploadResponse = json_decode((string) $response->getBody(), true);\n        if (!isset($uploadResponse[\"success\"]) || $uploadResponse[\"success\"] != 0) {\n            return -2;\n        }\n        return 0;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nrequire 'vendor/autoload.php';\n\nuse GuzzleHttp\\Client;\n\nclass V4Curl {\n    // Base class methods and properties\n}\n\nclass ImageX extends V4Curl {\n    public function upload(string $uploadHost, array $storeInfo, string $filePath): int {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $fileContent = file_get_contents($filePath);\n        $crc32Checksum = hash('crc32b', $fileContent);\n\n        $client = new Client();\n        try {\n            $response = $client->put($uploadHost . $storeInfo['StoreUri'], [\n                'body' => $fileContent,\n                'headers' => [\n                    'Authorization' => $storeInfo['Auth'],\n                    'Content-CRC32' => $crc32Checksum\n                ]\n            ]);\n\n            if ($response->getStatusCode() == 200) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (\\Exception $e) {\n            return -2;\n        }\n    }\n}\n\n?>\n```"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client using low-level socket operations (fsockopen) to send HTTP requests and handle responses, with logging capabilities.\n\nClass Description: SocketHttpClient is a PSR-compatible HTTP client that establishes direct socket connections to HTTP servers, sends requests, and processes responses. It implements both a custom HTTP client interface and PSR-18's ClientInterface, while also supporting PSR-3 logging.\n\nAttributes:\n- logger: [LoggerInterface] - PSR-3 logger instance for tracking connection attempts, errors, and debug information\n\nMethods:\n- __construct([LoggerInterface $logger]) -> [void] - Initializes the client with a PSR-3 logger instance\n- sendRequest([RequestInterface $request]) -> [ResponseInterface] - Sends an HTTP request and returns the response. Handles both HTTP and HTTPS connections, processes headers and body, and manages socket lifecycle. Returns a PSR-7 response object.",
    "Canonical_solution": "use Mpdf\\Log\\Context as LogContext;\nuse Mpdf\\PsrHttpMessageShim\\Response;\nuse Mpdf\\PsrHttpMessageShim\\Stream;\nuse Mpdf\\PsrLogAwareTrait\\PsrLogAwareTrait;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass SocketHttpClient implements \\Mpdf\\Http\\ClientInterface, \\Psr\\Log\\LoggerAwareInterface\n{\n    use PsrLogAwareTrait;\n\n    public function __construct(LoggerInterface $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function sendRequest(RequestInterface $request)\n    {\n        if (null === $request->getUri()) {\n            return (new Response());\n        }\n\n        $url = $request->getUri();\n\n        if (is_string($url)) {\n            $url = new Uri($url);\n        }\n\n        $timeout = 1;\n\n        $file = $url->getPath() ?: '/';\n        $scheme = $url->getScheme();\n        $port = $url->getPort() ?: 80;\n        $prefix = '';\n\n        if ($scheme === 'https') {\n            $prefix = 'ssl://';\n            $port = $url->getPort() ?: 443;\n        }\n\n        $query = $url->getQuery();\n        if ($query) {\n            $file .= '?' . $query;\n        }\n\n        $socketPath = $prefix . $url->getHost();\n\n        $this->logger->debug(sprintf('Opening socket on %s:%s of URL \"%s\"', $socketPath, $port, $request->getUri()), ['context' => LogContext::REMOTE_CONTENT]);\n\n        $response = new Response();\n\n        if (!($fh = @fsockopen($socketPath, $port, $errno, $errstr, $timeout))) {\n            $this->logger->error(sprintf('Socket error \"%s\": \"%s\"', $errno, $errstr), ['context' => LogContext::REMOTE_CONTENT]);\n            return $response;\n        }\n\n        $getRequest = 'GET ' . $file . ' HTTP/1.1' . \"\\r\\n\" .\n            'Host: ' . $url->getHost() . \" \\r\\n\" .\n            'Connection: close' . \"\\r\\n\\r\\n\";\n\n        fwrite($fh, $getRequest);\n\n        $httpHeader = fgets($fh, 1024);\n        if (!$httpHeader) {\n            return $response;\n        }\n\n        preg_match('@HTTP/(?P<protocolVersion>[\\d\\.]+) (?P<httpStatusCode>[\\d]+) .*@', $httpHeader, $parsedHeader);\n\n        if (!$parsedHeader) {\n            return $response;\n        }\n\n        $response = $response->withStatus($parsedHeader['httpStatusCode']);\n\n        while (!feof($fh)) {\n            $s = fgets($fh, 1024);\n            if ($s === \"\\r\\n\") {\n                break;\n            }\n            preg_match('/^(?P<headerName>.*?): ?(?P<headerValue>.*)$/', $s, $parsedHeader);\n            if (!$parsedHeader) {\n                continue;\n            }\n            $response = $response->withHeader($parsedHeader['headerName'], trim($parsedHeader['headerValue']));\n        }\n\n        $body = '';\n\n        while (!feof($fh)) {\n            $line = fgets($fh, 1024);\n            $body .= $line;\n        }\n\n        fclose($fh);\n\n        $stream = Stream::create($body);\n        $stream->rewind();\n\n        return $response\n            ->withBody($stream);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 131,
    "wrong_result": "<?php\n\nnamespace MyNamespace;\n\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\LogLevel;\n\nclass SocketHttpClient implements ClientInterface\n{\n    private $logger;\n\n    public function __construct(LoggerInterface $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $scheme = $uri->getScheme();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($scheme === 'https' ? 443 : 80);\n        $path = $uri->getPath();\n        $query = $uri->getQuery();\n        $method = $request->getMethod();\n        $headers = $request->getHeaders();\n        $body = $request->getBody()->getContents();\n\n        $this->logger->info(\"Sending request to {$host}{$path}\");\n\n        $fp = fsockopen(($scheme === 'https' ? 'ssl://' : '') . $host, $port, $errno, $errstr, 30);\n        if (!$fp) {\n            $this->logger->error(\"Unable to connect to {$host}: {$errstr} ({$errno})\");\n            throw new \\Exception(\"Unable to connect to server: {$errstr} ({$errno})\");\n        }\n\n        $requestHeaders = \"{$method} {$path}\" . ($query ? \"?{$query}\" : '') . \" HTTP/1.1\\r\\n\";\n        $requestHeaders .= \"Host: {$host}\\r\\n\";\n        foreach ($headers as $name => $values) {\n            foreach ($values as $value) {\n                $requestHeaders .= \"{$name}: {$value}\\r\\n\";\n            }\n        }\n        $requestHeaders .= \"Content-Length: \" . strlen($body) . \"\\r\\n\";\n        $requestHeaders .= \"Connection: close\\r\\n\\r\\n\";\n        $requestHeaders .= $body;\n\n        fwrite($fp, $requestHeaders);\n\n        $responseHeaders = '';\n        $responseBody = '';\n        while (!feof($fp)) {\n            $line = fgets($fp, 4096);\n            if ($line === \"\\r\\n\") {\n                break;\n            }\n            $responseHeaders .= $line;\n        }\n        while (!feof($fp)) {\n            $responseBody .= fgets($fp, 4096);\n        }\n        fclose($fp);\n\n        $this->logger->info(\"Received response from {$host}{$path}\");\n\n        $response = $this->createResponse($responseHeaders, $responseBody);\n\n        return $response;\n    }\n\n    private function createResponse($headers, $body): ResponseInterface\n    {\n        $response = new \\GuzzleHttp\\Psr7\\Response();\n        $headerLines = explode(\"\\r\\n\", $headers);\n        $statusLine = array_shift($headerLines);\n        list($protocol, $statusCode, $reasonPhrase) = explode(' ', $statusLine, 3);\n        $response = $response->withStatus((int)$statusCode, $reasonPhrase);\n\n        foreach ($headerLines as $headerLine) {\n            list($name, $value) = explode(':', $headerLine, 2);\n            $response = $response->withAddedHeader(trim($name), trim($value));\n        }\n\n        $response->getBody()->write($body);\n\n        return $response;\n    }\n}\n\nnamespace Psr\\Log;\n\ninterface LoggerInterface\n{\n    public function emergency($message, array $context = []);\n    public function alert($message, array $context = []);\n    public function critical($message, array $context = []);\n    public function error($message, array $context = []);\n    public function warning($message, array $context = []);\n    public function notice($message, array $context = []);\n    public function info($message, array $context = []);\n    public function debug($message, array $context = []);\n    public function log($level, $message, array $context = []);\n}\n\nnamespace Psr\\Http\\Message;\n\ninterface RequestInterface\n{\n    public function getMethod();\n    public function getUri();\n    public function getHeaders();\n    public function getBody();\n}\n\ninterface ResponseInterface\n{\n    public function withStatus($code, $reasonPhrase = '');\n    public function withAddedHeader($name, $value);\n    public function getBody();\n}\n\nnamespace GuzzleHttp\\Psr7;\n\nclass Response implements ResponseInterface\n{\n    // Implementation of ResponseInterface methods\n}\n?>\n"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement a CAPTCHA validation class that verifies user-submitted CAPTCHA responses using Google's reCAPTCHA API.\n\nClass Description: The Captcha class implements Laravel's Rule interface to provide CAPTCHA validation functionality. It sends the user's CAPTCHA response to Google's verification endpoint and checks the success status in the response.\n\nAttributes: (This class has no explicit attributes as it uses configuration values directly)\n\nMethods:\n1: passes(string $attribute, mixed $value) -> bool - Validates the CAPTCHA response by sending it to Google's verification API along with the secret key and client IP. Returns true if verification succeeds.\n   - $attribute: The name of the attribute being validated\n   - $value: The CAPTCHA response token to be validated\n\n2: message() -> string - Returns the validation error message to be displayed when CAPTCHA validation fails. The message is localized using Laravel's translation system.",
    "Canonical_solution": "use GuzzleHttp\\Client;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        if (empty($value)) {\n            return false;\n        }\n\n        $response = json_decode((new Client([\n            'timeout' => config('boilerplate.access.captcha.configs.options.timeout'),\n        ]))->post('https://www.google.com/recaptcha/api/siteverify', [\n            'form_params' => [\n                'secret' => config('boilerplate.access.captcha.configs.secret_key'),\n                'remoteip' => request()->getClientIp(),\n                'response' => $value,\n            ],\n        ])->getBody(), true);\n\n        return isset($response['success']) && $response['success'] === true;\n    }\n\n    public function message()\n    {\n        return __('The captcha was invalid.');\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        $secretKey = config('services.recaptcha.secret');\n        $clientIp = request()->ip();\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => $secretKey,\n            'response' => $value,\n            'remoteip' => $clientIp,\n        ]);\n\n        $body = $response->json();\n\n        return $body['success'] ?? false;\n    }\n\n    public function message()\n    {\n        return trans('validation.captcha');\n    }\n}\n```"
  },
  {
    "Task_id": 128,
    "Instruction": "Task Description: Create a PHP class that implements a Redis client connection using TCP sockets and the phpiredis extension for efficient communication with a Redis server.\n\nClass Description: PhpiredisSocketConnection is a Redis client connection class that handles TCP socket communication with a Redis server. It manages socket creation, connection, data transmission, and response parsing using the phpiredis extension for optimal performance.\n\nAttributes:\n- reader: [resource] - The phpiredis reader resource used for parsing Redis protocol responses\n- parameters: [ParametersInterface] - Connection parameters including host, port, timeout, etc.\n\nMethods:\n- __construct(ParametersInterface $parameters) -> [void] - Initializes the connection and verifies required extensions\n- __destruct() -> [void] - Cleans up resources when the object is destroyed\n- assertExtensions() -> [void] - Verifies required PHP extensions are loaded\n- createReader() -> [resource] - Creates and configures a phpiredis reader resource\n- getStatusHandler() -> [callable] - Returns the handler for status responses\n- getErrorHandler() -> [callable] - Returns the handler for error responses\n- createResource() -> [resource] - Creates and connects the socket resource\n- connectWithTimeout(resource $socket, string $address, ParametersInterface $parameters) -> [void] - Establishes connection with timeout handling\n- write(string $buffer) -> [void] - Writes data to the socket connection\n- read() -> [mixed] - Reads and parses response from the server\n- writeRequest(CommandInterface $command) -> [void] - Formats and writes a Redis command to the server",
    "Canonical_solution": "use Predis\\Command\\CommandInterface;\nuse Predis\\NotSupportedException;\nuse Predis\\Response\\Error as ErrorResponse;\nuse Predis\\Response\\ErrorInterface as ErrorResponseInterface;\nuse Predis\\Response\\Status as StatusResponse;\n\nclass PhpiredisSocketConnection extends AbstractConnection\n{\n    private $reader;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        parent::__construct($parameters);\n        $this->reader = $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        parent::__destruct();\n        phpiredis_reader_destroy($this->reader);\n    }\n\n    protected function assertExtensions()\n    {\n        if (!extension_loaded('sockets')) {\n            throw new NotSupportedException(\n                'The \"sockets\" extension is required by this connection backend.'\n            );\n        }\n\n        if (!extension_loaded('phpiredis')) {\n            throw new NotSupportedException(\n                'The \"phpiredis\" extension is required by this connection backend.'\n            );\n        }\n    }\n\n    private function createReader()\n    {\n        $reader = phpiredis_reader_create();\n        phpiredis_reader_set_status_handler($reader, $this->getStatusHandler());\n        phpiredis_reader_set_error_handler($reader, $this->getErrorHandler());\n        return $reader;\n    }\n\n    protected function getStatusHandler()\n    {\n        static $statusHandler;\n\n        if (!$statusHandler) {\n            $statusHandler = function ($payload) {\n                return StatusResponse::get($payload);\n            };\n        }\n\n        return $statusHandler;\n    }\n\n    protected function getErrorHandler()\n    {\n        static $errorHandler;\n\n        if (!$errorHandler) {\n            $errorHandler = function ($errorMessage) {\n                return new ErrorResponse($errorMessage);\n            };\n        }\n\n        return $errorHandler;\n    }\n\n    protected function createResource()\n    {\n        $parameters = $this->parameters;\n\n        if ($parameters->scheme === 'unix') {\n            $address = $parameters->path;\n            $domain = AF_UNIX;\n            $protocol = 0;\n        } else {\n            if (false === $address = self::getAddress($parameters)) {\n                $this->onConnectionError(\"Cannot resolve the address of '$parameters->host'.\");\n            }\n\n            $domain = filter_var($address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) ? AF_INET6 : AF_INET;\n            $protocol = SOL_TCP;\n        }\n\n        if (false === $socket = @socket_create($domain, SOCK_STREAM, $protocol)) {\n            $this->emitSocketError();\n        }\n\n        $this->setSocketOptions($socket, $parameters);\n        $this->connectWithTimeout($socket, $address, $parameters);\n\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        socket_set_nonblock($socket);\n\n        if (@socket_connect($socket, $address, (int) $parameters->port) === false) {\n            $error = socket_last_error();\n            if ($error != SOCKET_EINPROGRESS && $error != SOCKET_EALREADY) {\n                $this->emitSocketError();\n            }\n        }\n\n        socket_set_block($socket);\n\n        $null = null;\n        $selectable = array($socket);\n\n        $timeout = (isset($parameters->timeout) ? (float) $parameters->timeout : 5.0);\n        $timeoutSecs = floor($timeout);\n        $timeoutUSecs = ($timeout - $timeoutSecs) * 1000000;\n\n        $selected = socket_select($selectable, $selectable, $null, $timeoutSecs, $timeoutUSecs);\n\n        if ($selected === 2) {\n            $this->onConnectionError('Connection refused.', SOCKET_ECONNREFUSED);\n        }\n\n        if ($selected === 0) {\n            $this->onConnectionError('Connection timed out.', SOCKET_ETIMEDOUT);\n        }\n\n        if ($selected === false) {\n            $this->emitSocketError();\n        }\n    }\n\n    protected function write($buffer)\n    {\n        $socket = $this->getResource();\n\n        while (($length = strlen($buffer)) > 0) {\n            $written = socket_write($socket, $buffer, $length);\n\n            if ($length === $written) {\n                return;\n            }\n\n            if ($written === false) {\n                $this->onConnectionError('Error while writing bytes to the server.');\n            }\n\n            $buffer = substr($buffer, $written);\n        }\n    }\n\n    public function read()\n    {\n        $socket = $this->getResource();\n        $reader = $this->reader;\n\n        while (PHPIREDIS_READER_STATE_INCOMPLETE === $state = phpiredis_reader_get_state($reader)) {\n            if (@socket_recv($socket, $buffer, 4096, 0) === false || $buffer === '' || $buffer === null) {\n                $this->emitSocketError();\n            }\n\n            phpiredis_reader_feed($reader, $buffer);\n        }\n\n        if ($state === PHPIREDIS_READER_STATE_COMPLETE) {\n            return phpiredis_reader_get_reply($reader);\n        } else {\n            $this->onProtocolError(phpiredis_reader_get_error($reader));\n            return;\n        }\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getId());\n        $this->write(phpiredis_format_command($arguments));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 137,
    "wrong_result": "```php\n<?php\n\ninterface ParametersInterface {\n    public function getHost();\n    public function getPort();\n    public function getTimeout();\n}\n\ninterface CommandInterface {\n    public function getCommand();\n}\n\nclass PhpiredisSocketConnection {\n    private $reader;\n    private $parameters;\n    private $socket;\n\n    public function __construct(ParametersInterface $parameters) {\n        $this->parameters = $parameters;\n        $this->assertExtensions();\n        $this->socket = $this->createResource();\n        $this->reader = $this->createReader();\n    }\n\n    public function __destruct() {\n        if (is_resource($this->socket)) {\n            fclose($this->socket);\n        }\n    }\n\n    private function assertExtensions(): void {\n        if (!extension_loaded('phpiredis')) {\n            throw new Exception('phpiredis extension is not loaded');\n        }\n    }\n\n    private function createReader(): resource {\n        return phpiredis_reader_create();\n    }\n\n    private function getStatusHandler(): callable {\n        return function ($response) {\n            return $response === 'OK';\n        };\n    }\n\n    private function getErrorHandler(): callable {\n        return function ($response) {\n            throw new Exception(\"Redis error: {$response}\");\n        };\n    }\n\n    private function createResource(): resource {\n        $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n        $this->connectWithTimeout($socket, $this->parameters->getHost() . ':' . $this->parameters->getPort(), $this->parameters);\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, string $address, ParametersInterface $parameters): void {\n        $timeout = $parameters->getTimeout();\n        socket_set_option($socket, SOL_SOCKET, SO_RCVTIMEO, ['sec' => $timeout, 'usec' => 0]);\n        socket_set_option($socket, SOL_SOCKET, SO_SNDTIMEO, ['sec' => $timeout, 'usec' => 0]);\n        if (!socket_connect($socket, $address)) {\n            throw new Exception('Failed to connect to Redis server');\n        }\n    }\n\n    public function write(string $buffer): void {\n        if (false === fwrite($this->socket, $buffer)) {\n            throw new Exception('Failed to write to socket');\n        }\n    }\n\n    public function read() {\n        $response = '';\n        while (($chunk = fgets($this->socket)) !== false) {\n            $response .= $chunk;\n            if (phpiredis_reader_feed($this->reader, $chunk) === PHPIREDIS_READER_STATE_COMPLETE) {\n                break;\n            }\n        }\n        return phpiredis_reader_get_reply($this->reader);\n    }\n\n    public function writeRequest(CommandInterface $command): void {\n        $cmdString = '*' . count($command->getCommand()) . \"\\r\\n\";\n        foreach ($command->getCommand() as $arg) {\n            $cmdString .= '$' . strlen($arg) . \"\\r\\n\" . $arg . \"\\r\\n\";\n        }\n        $this->write($cmdString);\n    }\n}\n```"
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Implement a Radius class in PHP that handles RADIUS protocol communication for authentication and accounting purposes using UDP sockets.\n\nClass Description: The Radius class provides functionality to communicate with a RADIUS server for authentication (Access-Request) and accounting operations. It handles packet construction, socket communication, and response parsing according to RADIUS protocol standards.\n\nAttributes:\n\n_ip_radius_server: [string] - IP address of the RADIUS server\n_shared_secret: [string] - Shared secret for communication with RADIUS server\n_radius_suffix: [string] - Suffix to append to usernames\n_udp_timeout: [int] - Timeout for UDP operations in seconds\n_authentication_port: [int] - Port for authentication requests (default 1812)\n_accounting_port: [int] - Port for accounting requests (default 1813)\n_nas_ip_address: [string] - NAS IP address to send in requests\n_nas_port: [int] - NAS port to send in requests\n_encrypted_password: [string] - Encrypted password for authentication\n_user_ip_address: [string] - User's IP address\n_request_authenticator: [string] - Request authenticator value\n_response_authenticator: [string] - Response authenticator value\n_username: [string] - Username for authentication\n_password: [string] - Password for authentication\n_identifier_to_send: [int] - Packet identifier to send\n_identifier_received: [int] - Received packet identifier\n_radius_packet_to_send: [int] - RADIUS packet code to send\n_radius_packet_received: [int] - Received RADIUS packet code\n_attributes_to_send: [array] - Attributes to include in outgoing packets\n_attributes_received: [array] - Attributes received from server\n_socket_to_server: [resource] - Socket connection to server\n_debug_mode: [bool] - Debug mode flag\ndebug_text: [array] - Debug messages\n_attributes_info: [array] - RADIUS attribute information\n_radius_packet_info: [array] - RADIUS packet type information\n_last_error_code: [int] - Last error code\n_last_error_message: [string] - Last error message\n\nMethods:\n\n__construct: [function]($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813) -> [void] - Initializes the Radius object with server details and default values\n\nAccessRequest: [function]($username = '', $password = '', $udp_timeout = 0, $state = NULL) -> [bool] - Sends an Access-Request to the RADIUS server and returns true if authentication is successful (Access-Accept received)\n\nSetIpRadiusServer: [function]($ip_radius_server) -> [void] - Sets the RADIUS server IP address\n\nSetSharedSecret: [function]($shared_secret) -> [void] - Sets the shared secret for RADIUS communication\n\nSetAuthenticationPort: [function]($authentication_port) -> [void] - Sets the authentication port\n\nSetAccountingPort: [function]($accounting_port) -> [void] - Sets the accounting port\n\nSetRadiusSuffix: [function]($radius_suffix) -> [void] - Sets the username suffix\n\nSetUdpTimeout: [function]($udp_timeout) -> [void] - Sets the UDP timeout value\n\nSetUsername: [function]($username = '') -> [void] - Sets the username for authentication\n\nSetPassword: [function]($password = '') -> [void] - Sets the password for authentication\n\nSetNasIpAddress: [function]($nas_ip_address = '') -> [void] - Sets the NAS IP address\n\nSetNasPort: [function]($nas_port = 0) -> [void] - Sets the NAS port\n\nSetPacketCodeToSend: [function]($packet_code) -> [void] - Sets the RADIUS packet code to send\n\nSetAttribute: [function]($attribute_type, $attribute_value) -> [void] - Adds an attribute to the outgoing packet\n\nGetNextIdentifier: [function]() -> [int] - Returns the next packet identifier\n\nGenerateRequestAuthenticator: [function]() -> [void] - Generates a new request authenticator\n\nDecodeAttribute: [function]($attribute_raw_value, $attribute_type) -> [mixed] - Decodes a received attribute value\n\nClearLastError: [function]() -> [void] - Clears the last error information\n\nClearDataToSend: [function]() -> [void] - Clears all data to be sent\n\nClearDataReceived: [function]() -> [void] - Clears all received data",
    "Canonical_solution": "class Radius\n{\n    var $_ip_radius_server;\n    var $_shared_secret;\n    var $_radius_suffix;\n    var $_udp_timeout;\n    var $_authentication_port;\n    var $_accounting_port;\n    var $_nas_ip_address;\n    var $_nas_port;\n    var $_encrypted_password;\n    var $_user_ip_address;\n    var $_request_authenticator;\n    var $_response_authenticator;\n    var $_username;\n    var $_password;\n    var $_identifier_to_send;\n    var $_identifier_received;\n    var $_radius_packet_to_send;\n    var $_radius_packet_received;\n    var $_attributes_to_send;\n    var $_attributes_received;\n    var $_socket_to_server;\n    var $_debug_mode;\n    var $debug_text = [];\n    var $_attributes_info;\n    var $_radius_packet_info;\n    var $_last_error_code;\n    var $_last_error_message;\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_radius_packet_info[1] = 'Access-Request';\n        $this->_radius_packet_info[2] = 'Access-Accept';\n        $this->_radius_packet_info[3] = 'Access-Reject';\n        $this->_radius_packet_info[4] = 'Accounting-Request';\n        $this->_radius_packet_info[5] = 'Accounting-Response';\n        $this->_radius_packet_info[11] = 'Access-Challenge';\n        $this->_radius_packet_info[12] = 'Status-Server (experimental)';\n        $this->_radius_packet_info[13] = 'Status-Client (experimental)';\n        $this->_radius_packet_info[255] = 'Reserved';\n\n        $this->_identifier_to_send = 0;\n        $this->_user_ip_address = (isset($_SERVER['REMOTE_ADDR']) ? $_SERVER['REMOTE_ADDR'] : '0.0.0.0');\n\n        $this->GenerateRequestAuthenticator();\n        $this->SetIpRadiusServer($ip_radius_server);\n        $this->SetSharedSecret($shared_secret);\n        $this->SetAuthenticationPort($authentication_port);\n        $this->SetAccountingPort($accounting_port);\n        $this->SetRadiusSuffix($radius_suffix);\n        $this->SetUdpTimeout($udp_timeout);\n        $this->SetUsername();\n        $this->SetPassword();\n        $this->SetNasIpAddress();\n        $this->SetNasPort();\n\n        $this->ClearLastError();\n        $this->ClearDataToSend();\n        $this->ClearDataReceived();\n    }\n\n    function AccessRequest($username = '', $password = '', $udp_timeout = 0, $state = NULL)\n    {\n        $this->ClearDataReceived();\n        $this->ClearLastError();\n\n        $this->SetPacketCodeToSend(1);\n\n        if (0 < strlen($username))\n        {\n            $this->SetUsername($username);\n        }\n\n        if (0 < strlen($password))\n        {\n            $this->SetPassword($password);\n        }\n\n        if ($state !== NULL)\n        {\n            $this->SetAttribute(24, $state);\n        }\n        else\n        {\n            $this->SetAttribute(6, 1);\n        }\n\n        if (intval($udp_timeout) > 0)\n        {\n            $this->SetUdpTimeout($udp_timeout);\n        }\n\n        $attributes_content = '';\n        $attribute_count1 = count((array)$this->_attributes_to_send);\n        for ($attributes_loop = 0; $attributes_loop < $attribute_count1; $attributes_loop++)\n        {\n            $attributes_content .= $this->_attributes_to_send[$attributes_loop];\n        }\n\n        $packet_length  = 4;\n        $packet_length += strlen($this->_request_authenticator);\n        $packet_length += strlen($attributes_content);\n\n        $packet_data  = chr($this->_radius_packet_to_send);\n        $packet_data .= chr($this->GetNextIdentifier());\n        $packet_data .= chr(intval($packet_length / 256));\n        $packet_data .= chr(intval($packet_length % 256));\n        $packet_data .= $this->_request_authenticator;\n        $packet_data .= $attributes_content;\n\n        $_socket_to_server = socket_create(AF_INET, SOCK_DGRAM, 17);\n\n        if ($_socket_to_server === FALSE)\n        {\n            $this->_last_error_code    = socket_last_error();\n            $this->_last_error_message = socket_strerror($this->_last_error_code);\n        }\n        elseif (FALSE === socket_connect($_socket_to_server, $this->_ip_radius_server, $this->_authentication_port))\n        {\n            $this->_last_error_code    = socket_last_error();\n            $this->_last_error_message = socket_strerror($this->_last_error_code);\n        }\n        elseif (FALSE === socket_write($_socket_to_server, $packet_data, $packet_length))\n        {\n            $this->_last_error_code    = socket_last_error();\n            $this->_last_error_message = socket_strerror($this->_last_error_code);\n        }\n        else\n        {\n            $read_socket_array   = array($_socket_to_server);\n            $write_socket_array  = NULL;\n            $except_socket_array = NULL;\n\n            $received_packet = chr(0);\n\n            if (!(FALSE === socket_select($read_socket_array, $write_socket_array, $except_socket_array, $this->_udp_timeout)))\n            {\n                if (in_array($_socket_to_server, $read_socket_array))\n                {\n                    if (FALSE === ($received_packet = @socket_read($_socket_to_server, 1024)))\n                    {\n                        $received_packet = chr(0);\n                        $this->_last_error_code    = socket_last_error();\n                        $this->_last_error_message = socket_strerror($this->_last_error_code);\n                    }\n                    else\n                    {\n                        socket_close($_socket_to_server);\n                    }\n                }\n            }\n            else\n            {\n                socket_close($_socket_to_server);\n            }\n        }\n\n        $this->_radius_packet_received = intval(ord(substr($received_packet, 0, 1)));\n\n        if ($this->_radius_packet_received > 0)\n        {\n            $this->_identifier_received = intval(ord(substr($received_packet, 1, 1)));\n            $packet_length = (intval(ord(substr($received_packet, 2, 1))) * 256) + (intval(ord(substr($received_packet, 3, 1)));\n            $this->_response_authenticator = substr($received_packet, 4, 16);\n            $attributes_content = substr($received_packet, 20, ($packet_length - 4 - 16));\n            while (strlen($attributes_content) > 2)\n            {\n                $attribute_type = intval(ord(substr($attributes_content, 0, 1)));\n                $attribute_length = intval(ord(substr($attributes_content, 1, 1)));\n                $attribute_raw_value = substr($attributes_content, 2, $attribute_length - 2);\n                $attributes_content = substr($attributes_content, $attribute_length);\n\n                $attribute_value = $this->DecodeAttribute($attribute_raw_value, $attribute_type);\n\n                $this->_attributes_received[] = array($attribute_type, $attribute_value);\n            }\n        }\n\n        return (2 == ($this->_radius_packet_received));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 137,
    "wrong_result": "class Radius {\n    private $_ip_radius_server;\n    private $_shared_secret;\n    private $_radius_suffix;\n    private $_udp_timeout;\n    private $_authentication_port;\n    private $_accounting_port;\n    private $_nas_ip_address;\n    private $_nas_port;\n    private $_encrypted_password;\n    private $_user_ip_address;\n    private $_request_authenticator;\n    private $_response_authenticator;\n    private $_username;\n    private $_password;\n    private $_identifier_to_send;\n    private $_identifier_received;\n    private $_radius_packet_to_send;\n    private $_radius_packet_received;\n    private $_attributes_to_send;\n    private $_attributes_received;\n    private $_socket_to_server;\n    private $_debug_mode;\n    private $debug_text;\n    private $_attributes_info;\n    private $_radius_packet_info;\n    private $_last_error_code;\n    private $_last_error_message;\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813) {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n        $this->_attributes_to_send = [];\n        $this->_attributes_received = [];\n        $this->_debug_mode = false;\n        $this->debug_text = [];\n        $this->_attributes_info = [];\n        $this->_radius_packet_info = [];\n        $this->_last_error_code = 0;\n        $this->_last_error_message = '';\n    }\n\n    public function AccessRequest($username = '', $password = '', $udp_timeout = 0, $state = NULL) {\n        // Implementation of Access-Request method\n    }\n\n    public function SetIpRadiusServer($ip_radius_server) {\n        $this->_ip_radius_server = $ip_radius_server;\n    }\n\n    public function SetSharedSecret($shared_secret) {\n        $this->_shared_secret = $shared_secret;\n    }\n\n    public function SetAuthenticationPort($authentication_port) {\n        $this->_authentication_port = $authentication_port;\n    }\n\n    public function SetAccountingPort($accounting_port) {\n        $this->_accounting_port = $accounting_port;\n    }\n\n    public function SetRadiusSuffix($radius_suffix) {\n        $this->_radius_suffix = $radius_suffix;\n    }\n\n    public function SetUdpTimeout($udp_timeout) {\n        $this->_udp_timeout = $udp_timeout;\n    }\n\n    public function SetUsername($username = '') {\n        $this->_username = $username;\n    }\n\n    public function SetPassword($password = '') {\n        $this->_password = $password;\n    }\n\n    public function SetNasIpAddress($nas_ip_address = '') {\n        $this->_nas_ip_address = $nas_ip_address;\n    }\n\n    public function SetNasPort($nas_port = 0) {\n        $this->_nas_port = $nas_port;\n    }\n\n    public function SetPacketCodeToSend($packet_code) {\n        $this->_radius_packet_to_send = $packet_code;\n    }\n\n    public function SetAttribute($attribute_type, $attribute_value) {\n        $this->_attributes_to_send[$attribute_type] = $attribute_value;\n    }\n\n    public function GetNextIdentifier() {\n        return ++$this->_identifier_to_send;\n    }\n\n    public function GenerateRequestAuthenticator() {\n        $this->_request_authenticator = md5(random_bytes(16));\n    }\n\n    public function DecodeAttribute($attribute_raw_value, $attribute_type) {\n        // Implementation of attribute decoding\n    }\n\n    public function ClearLastError() {\n        $this->_last_error_code = 0;\n        $this->_last_error_message = '';\n    }\n\n    public function ClearDataToSend() {\n        $this->_attributes_to_send = [];\n    }\n\n    public function ClearDataReceived() {\n        $this->_attributes_received = [];\n    }\n}"
  },
  {
    "Task_id": 130,
    "Instruction": "Task Description: Implement a UDP scraper class for interacting with BitTorrent trackers to scrape torrent statistics using UDP protocol.\n\nClass Description: UdpScraper is a class that handles communication with BitTorrent trackers via UDP protocol to retrieve scrape information (seeders, leechers, downloads) for given torrent info hashes. It manages socket connections, transaction IDs, and packet formatting according to the UDP tracker protocol.\n\nAttributes:\n- currentConnectionId: [string] - The connection ID received from the tracker after initial connection\n- transactionId: [int] - The current transaction ID used for request/response tracking\n- socket: [resource|null] - The UDP socket resource for communication\n- timeout: [int] - Socket timeout in seconds for send/receive operations\n\nMethods:\n- scrape([Tracker $tracker, array $hashes]) -> [array] - Main method to scrape multiple torrent hashes by splitting them into chunks\n- scrapeChunk([Tracker $tracker, array $hashes]) -> [array] - Scrapes a chunk of torrent hashes (max 74 at a time)\n- initSocket() -> [resource] - Initializes and returns a UDP socket\n- connect([string $domain, int $port]) -> [void] - Connects the socket to the tracker\n- generateTransactionId() -> [void] - Generates a random transaction ID\n- startTransaction() -> [void] - Initiates connection with the tracker and establishes connection ID\n- scrapeHashes([array $hashes]) -> [array] - Sends scrape request for given hashes and processes response\n- request([string $packet, int $readLength]) -> [string] - Sends packet and reads response with timeout\n- closeSocket() -> [void] - Closes the socket and resets connection state\n- checkError([string $response]) -> [void] - Checks for and handles error responses from tracker",
    "Canonical_solution": "namespace common\\modules\\torrent_scraper\\models;\n\nuse common\\models\\ScraperException;\n\nclass UdpScraper extends BaseScraper\n{\n    const ACTION_CONNECT = 0;\n    const ACTION_ANNOUNCE = 1;\n    const ACTION_SCRAPE = 2;\n    const ACTION_ERROR = 3;\n\n    const CONNECTION_ID = \"\\x00\\x00\\x04\\x17\\x27\\x10\\x19\\x80\";\n\n    protected $currentConnectionId = null;\n    protected $transactionId = null;\n    protected $socket = null;\n    protected $timeout = 15;\n\n    public function scrape(Tracker $tracker, array $hashes)\n    {\n        $chunks = array_chunk($hashes, 74);\n        $result = [];\n        foreach ($chunks as $chunk) {\n            $result = array_merge($result, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $result;\n    }\n\n    public function scrapeChunk(Tracker $tracker, $hashes)\n    {\n        $this->initSocket();\n        $this->connect($tracker->host, $tracker->port);\n        $this->startTransaction();\n        $torrents = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $torrents;\n    }\n\n    protected function initSocket()\n    {\n        if ($this->socket === null) {\n            $socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n            if ($socket === false) {\n                throw new UdpScraperException(socket_strerror(socket_last_error()));\n            }\n            $this->socket = $socket;\n        }\n        return $this->socket;\n    }\n\n    protected function connect($domain, $port)\n    {\n        if (socket_connect($this->socket, $domain, $port) === false) {\n            throw new UdpScraperException(socket_strerror(socket_last_error($this->socket)));\n        }\n    }\n\n    protected function generateTransactionId()\n    {\n        $this->transactionId = mt_rand(0, 65535);\n    }\n\n    protected function startTransaction()\n    {\n        $this->generateTransactionId();\n        $packet = static::CONNECTION_ID . pack('N', static::ACTION_CONNECT) . pack('N', $this->transactionId);\n        $res = $this->request($packet, 16);\n        if (strlen($res) < 1) {\n            throw new UdpScraperException('No connection response.');\n        }\n        if (strlen($res) < 16) {\n            throw new UdpScraperException('Too short connection response.');\n        }\n        $resUnpacked = unpack(\"Naction/Ntransid\", $res);\n\n        if ($resUnpacked['action'] != static::ACTION_CONNECT || $resUnpacked['transid'] != $this->transactionId) {\n            throw new UdpScraperException('Invalid connection response.');\n        }\n\n        $this->currentConnectionId = substr($res, 8, 8);\n    }\n\n    protected function scrapeHashes($hashes)\n    {\n        $hashString = '';\n        foreach ($hashes as $hash) {\n            $hashString .= pack('H*', $hash);\n        }\n\n        $packet = $this->currentConnectionId . pack(\"N\", static::ACTION_SCRAPE) . pack(\"N\", $this->transactionId) . $hashString;\n\n        $readLength = 8 + (12 * count($hashes));\n\n        $res = $this->request($packet, $readLength);\n\n        if (strlen($res) < 1) {\n            throw new UdpScraperException('No scrape response.');\n        }\n        if (strlen($res) < 8) {\n            throw new UdpScraperException('Too short scrape response.');\n        }\n\n        $resUnpacked = unpack(\"Naction/Ntransid\", $res);\n\n        if ($resUnpacked['action'] == static::ACTION_ERROR) {\n            $this->checkError($res);\n        }\n\n        if (strlen($res) < $readLength) {\n            throw new UdpScraperException('Too short scrape response.');\n        }\n\n        $torrents = [];\n        $index = 8;\n        foreach ($hashes as $hash) {\n            $resUnpacked = unpack(\"Ncomplete/Ndownloaded/Nincomplete\", substr($res, $index, 12));\n            $torrents[$hash] = $resUnpacked;\n            $index = $index + 12;\n        }\n        return $torrents;\n    }\n\n    protected function request($packet, $readLength)\n    {\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n        socket_set_option($this->socket, SOL_SOCKET, SO_SNDTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n\n        if (socket_write($this->socket, $packet, strlen($packet)) === false) {\n            throw new UdpScraperException(socket_strerror(socket_last_error($this->socket)));\n        }\n\n        $res = socket_read($this->socket, $readLength, PHP_BINARY_READ);\n        return $res;\n    }\n\n    protected function closeSocket()\n    {\n        if ($this->socket) {\n            socket_close($this->socket);\n            $this->socket = null;\n            $this->transactionId = null;\n            $this->currentConnectionId = null;\n        }\n    }\n\n    protected function checkError($response)\n    {\n        $unpacked = unpack(\"Naction/Ntransid/H*error\", $response);\n        throw new UdpScraperException($unpacked['error']);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 137,
    "wrong_result": "```php\nclass UdpScraper {\n    private $currentConnectionId;\n    private $transactionId;\n    private $socket;\n    private $timeout = 5;\n\n    public function scrape(Tracker $tracker, array $hashes): array {\n        $results = [];\n        $chunks = array_chunk($hashes, 74);\n        foreach ($chunks as $chunk) {\n            $results = array_merge($results, $this->scrapeChunk($tracker, $chunk));\n        }\n        return $results;\n    }\n\n    private function scrapeChunk(Tracker $tracker, array $hashes): array {\n        $this->initSocket();\n        $this->connect($tracker->getDomain(), $tracker->getPort());\n        $this->startTransaction();\n        $result = $this->scrapeHashes($hashes);\n        $this->closeSocket();\n        return $result;\n    }\n\n    private function initSocket(): resource {\n        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n        socket_set_option($this->socket, SOL_SOCKET, SO_RCVTIMEO, ['sec' => $this->timeout, 'usec' => 0]);\n        return $this->socket;\n    }\n\n    private function connect(string $domain, int $port): void {\n        socket_connect($this->socket, $domain, $port);\n    }\n\n    private function generateTransactionId(): void {\n        $this->transactionId = rand(0, 65535);\n    }\n\n    private function startTransaction(): void {\n        $this->generateTransactionId();\n        $connectionRequest = pack('Nn', 0x417, 0x2710) . pack('N', $this->transactionId);\n        $response = $this->request($connectionRequest, 16);\n        $unpack = unpack('Naction/NtransactionId/NconnectionId', $response);\n        if ($unpack['action'] === 0) {\n            $this->currentConnectionId = $unpack['connectionId'];\n        } else {\n            $this->checkError($response);\n        }\n    }\n\n    private function scrapeHashes(array $hashes): array {\n        $packet = pack('N', $this->currentConnectionId) . pack('N', 2) . pack('N', $this->transactionId);\n        foreach ($hashes as $hash) {\n            $packet .= pack('H*', $hash);\n        }\n        $response = $this->request($packet, 8 + count($hashes) * 12);\n        $result = [];\n        $unpack = unpack('Naction/NtransactionId', $response);\n        if ($unpack['action'] === 2) {\n            $offset = 8;\n            foreach ($hashes as $hash) {\n                $data = unpack('Nseeders/Ncompleted/Nleechers', substr($response, $offset, 12));\n                $result[$hash] = $data;\n                $offset += 12;\n            }\n        } else {\n            $this->checkError($response);\n        }\n        return $result;\n    }\n\n    private function request(string $packet, int $readLength): string {\n        socket_send($this->socket, $packet, strlen($packet), 0);\n        socket_recv($this->socket, $response, $readLength, 0);\n        return $response;\n    }\n\n    private function closeSocket(): void {\n        socket_close($this->socket);\n        $this->socket = null;\n        $this->currentConnectionId = null;\n    }\n\n    private function checkError(string $response): void {\n        $unpack = unpack('Naction/NtransactionId', $response);\n        if ($unpack['action'] === 3) {\n            throw new Exception(\"Tracker error: \" . substr($response, 8));\n        }\n    }\n}\n\nclass Tracker {\n    private $domain;\n    private $port;\n\n    public function __construct(string $domain, int $port) {\n        $this->domain = $domain;\n        $this->port = $port;\n    }\n\n    public function getDomain(): string {\n        return $this->domain;\n    }\n\n    public function getPort(): int {\n        return $this->port;\n    }\n}\n```"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a MySQL proxy class that handles communication between a client and MySQL server using Swoole's coroutine client for TCP/UDP communication, implementing authentication and packet handling.\n\nClass Description: MysqlProxy - A class that manages MySQL protocol communication between client and server, handling connection establishment, authentication, packet processing, and error handling.\n\nAttributes:\n\nisDuplex: [bool] - Indicates whether duplex communication is supported by Swoole version\nserver: [swoole_server] - Swoole server instance\nserverFd: [int] - File descriptor of the server connection\ncharset: [string] - Character set for MySQL communication\naccount: [array] - MySQL account credentials\nauth: [bool] - Authentication status flag\nchan: [Swoole\\Coroutine\\Channel] - Coroutine channel for communication\nserverPublicKey: [string] - Server's public key for authentication\nsalt: [array] - Salt used for password encryption\nconnected: [bool] - Connection status flag\ntimeout: [float] - Connection timeout value\nmysqlClient: [Swoole\\Coroutine\\Channel] - Channel for MySQL client communication\nmysqlServer: [HandshakePacket] - Server handshake information\nclient: [Swoole\\Coroutine\\Client] - Coroutine client instance\n\nMethods:\n\n__construct: [function](swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan) -> [void] - Initializes the proxy with server, file descriptor and channel\nconnect: [function](string $host, int $port, float $timeout = 0.1, int $tryStep = 0) -> [Client|bool] - Establishes connection to MySQL server with retry logic\nonClientReceive: [function](Swoole\\Coroutine\\Client $cli, string $data) -> [void] - Handles incoming data from MySQL server\nprocessAuth: [function](string $pluginName) -> [array] - Processes authentication based on plugin type\nsend: [function](...$data) -> [bool] - Sends data to MySQL server\nrecv: [function](&$remain) -> [mixed] - Receives data from MySQL server\nonClientClose: [function](Swoole\\Coroutine\\Client $cli) -> [void] - Handles client connection closure\nonClientError: [function](Swoole\\Coroutine\\Client $cli) -> [void] - Handles client errors",
    "Canonical_solution": "use Swoole\\Coroutine\\Client;\nuse SMProxy\\MysqlPacket\\AuthPacket;\nuse SMProxy\\MysqlPacket\\BinaryPacket;\nuse SMProxy\\MysqlPacket\\ErrorPacket;\nuse SMProxy\\MysqlPacket\\HandshakePacket;\nuse SMProxy\\MysqlPacket\\MySQLMessage;\nuse SMProxy\\MysqlPacket\\OkPacket;\nuse SMProxy\\MysqlPacket\\Util\\Capabilities;\nuse SMProxy\\MysqlPacket\\Util\\CharsetUtil;\nuse SMProxy\\MysqlPacket\\Util\\SecurityUtil;\nuse SMProxy\\MysqlPool\\MySQLException;\nuse SMProxy\\MysqlPool\\MySQLPool;\n\nclass MysqlProxy\n{\n    private $isDuplex;\n    public $server;\n    public $serverFd;\n    public $charset;\n    public $account;\n    public $auth = false;\n    public $chan;\n    public $serverPublicKey;\n    public $salt;\n    public $connected = false;\n    public $timeout = 0.1;\n    public $mysqlClient;\n    public $mysqlServer;\n    public $client;\n\n    public function __construct(\\swoole_server $server, int $fd, \\Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n        $this->client = new Client(CONFIG['server']['swoole_client_sock_setting']['sock_type'] ?? SWOOLE_SOCK_TCP);\n        $this->client->set(CONFIG['server']['swoole_client_setting'] ?? []);\n        $this->client->set(packageLengthSetting());\n        $this->isDuplex = version_compare(SWOOLE_VERSION, '4.2.13', '>=');\n        if (!$this->isDuplex) {\n            $this->mysqlClient = new Channel(1);\n        }\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3) {\n                $this->client->close();\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            } else {\n                $this->onClientError($this->client);\n                return false;\n            }\n        } else {\n            if (!$this->isDuplex) {\n                $this->mysqlClient->push($this->client);\n            }\n            self::go(function () {\n                $remain = '';\n                while (true) {\n                    $data = $this->recv($remain);\n                    if ($data === '' || $data === false) {\n                        break;\n                    }\n                }\n            });\n            return $this->client;\n        }\n    }\n\n    public function onClientReceive(\\Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        self::go(function () use ($cli, $data) {\n            $fd = $this->serverFd;\n            $binaryPacket = new BinaryPacket();\n            $binaryPacket->data = getBytes($data);\n            $binaryPacket->packetLength = $binaryPacket->calcPacketSize();\n            if (isset($binaryPacket->data[4])) {\n                $send = true;\n                if ($binaryPacket->data[4] == ErrorPacket::$FIELD_COUNT) {\n                    $errorPacket = new ErrorPacket();\n                    $errorPacket->read($binaryPacket);\n                    $data = getString($errorPacket->write());\n                } elseif (!$this->connected) {\n                    if ($binaryPacket->data[4] == OkPacket::$FIELD_COUNT) {\n                        $send = false;\n                        $this->connected = true;\n                        $this->chan->push($this);\n                    } elseif ($binaryPacket->data[4] == 0x01) {\n                        if ($binaryPacket->packetLength == 6) {\n                            if ($binaryPacket->data[$binaryPacket->packetLength - 1] == 4) {\n                                $data = getString(array_merge(getMysqlPackSize(1), [3, 2]));\n                                $this->send($data);\n                            }\n                        } else {\n                            $this->serverPublicKey = substr($data, 5, strlen($data) - 2);\n                            $encryptData = SecurityUtil::sha2RsaEncrypt($this->account['password'], $this->salt, $this->serverPublicKey);\n                            $data = getString(array_merge(getMysqlPackSize(strlen($encryptData)), [5])) . $encryptData;\n                            $this->send($data);\n                        }\n                        $send = false;\n                    } elseif ($binaryPacket->data[4] == 0xfe) {\n                        $mm = new MySQLMessage($binaryPacket->data);\n                        $mm->move(5);\n                        $pluginName = $mm->readStringWithNull();\n                        $this->salt = $mm->readBytesWithNull();\n                        $password = $this->processAuth($pluginName ?: 'mysql_native_password');\n                        $this->send(getString(array_merge(getMysqlPackSize(count($password)), [3], $password)));\n                        $send = false;\n                    } elseif (!$this->auth) {\n                        $handshakePacket = (new HandshakePacket())->read($binaryPacket);\n                        $this->mysqlServer = $handshakePacket;\n                        $this->salt = array_merge($handshakePacket->seed, $handshakePacket->restOfScrambleBuff);\n                        $password = $this->processAuth($handshakePacket->pluginName);\n                        $clientFlag = Capabilities::CLIENT_CAPABILITIES;\n                        $authPacket = new AuthPacket();\n                        $authPacket->pluginName = $handshakePacket->pluginName;\n                        $authPacket->packetId = 1;\n                        if (isset($this->database) && $this->database) {\n                            $authPacket->database = $this->database;\n                        } else {\n                            $authPacket->database = 0;\n                        }\n                        if ($authPacket->database) {\n                            $clientFlag |= Capabilities::CLIENT_CONNECT_WITH_DB;\n                        }\n                        if (version_compare($handshakePacket->serverVersion, '5.0', '>=')) {\n                            $clientFlag |= Capabilities::CLIENT_MULTI_RESULTS;\n                        }\n                        $authPacket->clientFlags = $clientFlag;\n                        $authPacket->serverCapabilities = $handshakePacket->serverCapabilities;\n                        $authPacket->maxPacketSize =\n                            CONFIG['server']['swoole_client_setting']['package_max_length'] ?? 16777215;\n                        $authPacket->charsetIndex = CharsetUtil::getIndex($this->charset ?? 'utf8mb4');\n                        $authPacket->user = $this->account['user'];\n                        $authPacket->password = $password;\n                        $this->auth = true;\n                        $this->send(getString($authPacket->write()));\n                        $send = false;\n                    }\n                }\n                if ($send && $this->server->exist($fd)) {\n                    $this->server->send($fd, $data);\n                }\n            }\n        });\n    }\n\n    public function processAuth(string $pluginName)\n    {\n        switch ($pluginName) {\n            case 'mysql_native_password':\n                $password = SecurityUtil::scramble411($this->account['password'], $this->salt);\n                break;\n            case 'caching_sha2_password':\n                $password = SecurityUtil::scrambleSha256($this->account['password'], $this->salt);\n                break;\n            case 'sha256_password':\n                throw new MySQLException('Sha256_password plugin is not supported yet');\n                break;\n            case 'mysql_old_password':\n                throw new MySQLException('mysql_old_password plugin is not supported yet');\n                break;\n            case 'mysql_clear_password':\n                $password = array_merge(getBytes($this->account['password']), [0]);\n                break;\n            default:\n                $password = SecurityUtil::scramble411($this->account['password'], $this->salt);\n                break;\n        }\n        return $password;\n    }\n\n    public function send(...$data)\n    {\n        if ($this->isDuplex) {\n            if ($this->client->isConnected()) {\n                return $this->client->send(...$data);\n            } else {\n                return false;\n            }\n        } else {\n            $client = self::coPop($this->mysqlClient);\n            if ($client === false) {\n                return false;\n            }\n            if ($client->isConnected()) {\n                $result = $client->send(...$data);\n                $this->mysqlClient->push($client);\n                return $result;\n            }\n            return false;\n        }\n    }\n\n    public function recv(&$remain)\n    {\n        if ($this->isDuplex) {\n            $client = $this->client;\n            $data = $client->recv(-1);\n        } else {\n            $client = self::coPop($this->mysqlClient, $this->timeout);\n            if ($client === false) {\n                return false;\n            }\n            if ($client->isConnected()) {\n                $data = $client->recv($this->timeout / 500);\n            } else {\n                $data = '';\n            }\n            $this->mysqlClient->push($client);\n            if ($data === false && $client->errCode == 110) {\n                $data = true;\n            }\n            if ($data === '' || $data === false) {\n                $this->mysqlClient->close();\n            }\n        }\n        if ($data === '' || $data === false) {\n            $this->onClientClose($client);\n        } elseif (is_string($data)) {\n            $this->onClientReceive($client, $data);\n        }\n        return $data;\n    }\n\n    public function onClientClose(\\Swoole\\Coroutine\\Client $cli)\n    {\n        MySQLPool::destruct($cli, $this->connName);\n    }\n\n    public function onClientError(\\Swoole\\Coroutine\\Client $cli)\n    {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 139,
    "wrong_result": "```php\n<?php\n\nclass MysqlProxy\n{\n    public $isDuplex;\n    public $server;\n    public $serverFd;\n    public $charset;\n    public $account;\n    public $auth;\n    public $chan;\n    public $serverPublicKey;\n    public $salt;\n    public $connected;\n    public $timeout;\n    public $mysqlClient;\n    public $mysqlServer;\n    public $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n        $this->auth = false;\n        $this->connected = false;\n        $this->timeout = 0.1;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->client = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $this->client->set([\n            'timeout' => $timeout,\n            'connect_timeout' => $timeout\n        ]);\n\n        for ($i = 0; $i <= $tryStep; $i++) {\n            if ($this->client->connect($host, $port)) {\n                $this->connected = true;\n                return $this->client;\n            }\n            if ($i < $tryStep) {\n                Swoole\\Coroutine::sleep(0.1);\n            }\n        }\n\n        return false;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        if ($this->auth) {\n            $this->chan->push($data);\n        } else {\n            $this->processAuth($data);\n        }\n    }\n\n    public function processAuth(string $pluginName)\n    {\n        // Placeholder for authentication logic\n        return [];\n    }\n\n    public function send(...$data)\n    {\n        if ($this->connected && $this->client->isConnected()) {\n            foreach ($data as $packet) {\n                if (!$this->client->send($packet)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    public function recv(&$remain)\n    {\n        if ($this->connected && $this->client->isConnected()) {\n            $data = $this->client->recv();\n            if ($data === false || $data === '') {\n                $this->connected = false;\n                return false;\n            }\n            $remain = $data;\n            return $data;\n        }\n        return false;\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->server->close($this->serverFd);\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli)\n    {\n        $this->connected = false;\n        $this->server->close($this->serverFd);\n    }\n}\n```"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a PHP class that manages a subprocess using proc_open, providing methods to initialize, communicate with, and terminate the process, while handling errors and resource cleanup.\n\nClass Description: The ProcessStream class manages a subprocess execution through pipes for stdin, stdout, and stderr communication. It handles process initialization, error checking, and proper resource cleanup.\n\nAttributes:\n- command: string - The command to be executed in the subprocess\n- stream: resource - The process resource created by proc_open\n- in: resource - The stdin pipe for writing to the subprocess\n- out: resource - The stdout pipe for reading from the subprocess\n\nMethods:\n- setCommand(string $command) -> void - Sets the command to be executed by the subprocess\n- initialize() -> void - Starts the subprocess, sets up communication pipes, and checks for startup errors\n- terminate() -> void - Closes all pipes and terminates the subprocess\n- getReadConnectionDescription() -> string - Returns a description of the process connection (for logging/debugging)",
    "Canonical_solution": "namespace Symfony\\Component\\Mailer\\Transport\\Smtp\\Stream;\n\nuse Symfony\\Component\\Mailer\\Exception\\TransportException;\n\nfinal class ProcessStream extends AbstractStream\n{\n    private string $command;\n\n    public function setCommand(string $command)\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorSpec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n        $pipes = [];\n        $this->stream = proc_open($this->command, $descriptorSpec, $pipes);\n        stream_set_blocking($pipes[2], false);\n        if ($err = stream_get_contents($pipes[2])) {\n            throw new TransportException('Process could not be started: '.$err);\n        }\n        $this->in = &$pipes[0];\n        $this->out = &$pipes[1];\n    }\n\n    public function terminate(): void\n    {\n        if (null !== $this->stream) {\n            fclose($this->in);\n            fclose($this->out);\n            proc_close($this->stream);\n        }\n\n        parent::terminate();\n    }\n\n    protected function getReadConnectionDescription(): string\n    {\n        return 'process '.$this->command;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "wrong_result": "```php\n<?php\n\nclass ProcessStream {\n    private $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand($command) {\n        $this->command = $command;\n    }\n\n    public function initialize() {\n        $descriptorSpec = [\n            0 => [\"pipe\", \"r\"], // stdin\n            1 => [\"pipe\", \"w\"], // stdout\n            2 => [\"pipe\", \"w\"]  // stderr\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorSpec, $pipes);\n        if (!is_resource($this->stream)) {\n            throw new Exception(\"Failed to start subprocess\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        stream_set_blocking($this->out, false);\n    }\n\n    public function terminate() {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription() {\n        return \"Process ID: \" . proc_get_status($this->stream)['pid'];\n    }\n}\n\n?>\n```"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using Symfony's HTTP client components to handle HTTP requests and responses.\n\nClass Description: The `HttpClientKernel` class is a Symfony HTTP client implementation that handles HTTP requests by sending them to a server and processing the responses. It supports various request methods, headers, cookies, and body content (including form data and file uploads).\n\nAttributes:\n- client: [HttpClientInterface] - The Symfony HTTP client instance used to send requests\n\nMethods:\n- __construct([HttpClientInterface $client = null]) -> [void] - Initializes the HTTP client. If no client is provided, creates a new instance. Requires Symfony HTTP client component.\n- handle([Request $request], [int $type = HttpKernelInterface::MAIN_REQUEST], [bool $catch = true]) -> [Response] - Processes an HTTP request, sends it using the client, and returns the response. Handles headers, cookies, and request body.\n- getBody([Request $request]) -> [AbstractPart|null] - Prepares the request body content. Returns null for GET/HEAD requests, TextPart for raw content, or FormDataPart for form data including files.\n- getHeaders([Request $request]) -> [array] - Prepares request headers including cookies from the request object. Returns an array of headers.",
    "Canonical_solution": "use Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        if (null === $client && !class_exists(HttpClient::class)) {\n            throw new \\LogicException(sprintf('You cannot use \"%s\" as the HttpClient component is not installed. Try running \"composer require symfony/http-client\".', __CLASS__));\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = HttpKernelInterface::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $headers = $this->getHeaders($request);\n        $body = '';\n        if (null !== $part = $this->getBody($request)) {\n            $headers = array_merge($headers, $part->getPreparedHeaders()->toArray());\n            $body = $part->bodyToIterable();\n        }\n        $response = $this->client->request($request->getMethod(), $request->getUri(), [\n            'headers' => $headers,\n            'body' => $body,\n        ] + $request->attributes->get('http_client_options', []));\n\n        $response = new Response($response->getContent(!$catch), $response->getStatusCode(), $response->getHeaders(!$catch));\n\n        $response->headers->remove('X-Body-File');\n        $response->headers->remove('X-Body-Eval');\n        $response->headers->remove('X-Content-Digest');\n\n        $response->headers = new class($response->headers->all()) extends ResponseHeaderBag {\n            protected function computeCacheControlValue(): string\n            {\n                return $this->getCacheControlHeader();\n            }\n        };\n\n        return $response;\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (\\in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        if (!class_exists(AbstractPart::class)) {\n            throw new \\LogicException('You cannot pass non-empty bodies as the Mime component is not installed. Try running \"composer require symfony/mime\".');\n        }\n\n        if ($content = $request->getContent()) {\n            return new TextPart($content, 'utf-8', 'plain', '8bit');\n        }\n\n        $fields = $request->request->all();\n        foreach ($request->files->all() as $name => $file) {\n            $fields[$name] = DataPart::fromPath($file->getPathname(), $file->getClientOriginalName(), $file->getClientMimeType());\n        }\n\n        return new FormDataPart($fields);\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers as $key => $value) {\n            $headers[$key] = $value;\n        }\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name.'='.$value;\n        }\n        if ($cookies) {\n            $headers['cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 134,
    "wrong_result": "```php\n<?php\n\nnamespace App\\Http;\n\nuse Symfony\\Component\\HttpClient\\HttpClientInterface;\nuse Symfony\\Component\\HttpClient\\NativeHttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\FormDataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? new NativeHttpClient();\n    }\n\n    public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $method = $request->getMethod();\n        $url = $request->getUri();\n        $options = [\n            'headers' => $this->getHeaders($request),\n            'body' => $this->getBody($request),\n        ];\n\n        $response = $this->client->request($method, $url, $options);\n\n        return new Response($response->getContent(), $response->getStatusCode(), $response->getHeaders());\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        $content = $request->getContent();\n        if ($request->headers->get('Content-Type') === 'application/x-www-form-urlencoded') {\n            parse_str($content, $data);\n            return new FormDataPart($data);\n        }\n\n        return new TextPart($content);\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers->all() as $name => $values) {\n            $headers[$name] = implode(', ', $values);\n        }\n\n        if ($request->cookies->count() > 0) {\n            $headers['Cookie'] = http_build_query($request->cookies->all(), '', '; ');\n        }\n\n        return $headers;\n    }\n}\n```"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a PHP class that handles process execution and communication using pipes, specifically designed for logging purposes. The class should manage subprocess creation, input/output streams, and error handling.\n\nClass Description: ProcessHandler is a logging handler that executes a subprocess and communicates with it through pipes (stdin, stdout, stderr). It ensures proper process management, handles startup errors, and provides methods for writing input and reading errors.\n\nAttributes:\n- process: [resource|null] - The subprocess resource handle\n- command: [string] - The command to execute as a subprocess\n- cwd: [string|null] - The working directory for the subprocess\n- pipes: [array] - Array of file pointers for process pipes (stdin, stdout, stderr)\n\nMethods:\n- __construct(string $command, int|string|Level $level = Level::Debug, bool $bubble = true, ?string $cwd = null) -> [void] - Initializes the handler with command, log level, and working directory\n- write(LogRecord $record) -> [void] - Writes formatted log record to the process stdin\n- close() -> [void] - Closes all pipes and terminates the process\n- ensureProcessIsStarted() -> [void] - Ensures the subprocess is running (starts if not)\n- startProcess() -> [void] - Starts the subprocess using proc_open\n- handleStartupErrors() -> [void] - Checks for and handles any startup errors\n- selectErrorStream() -> [int|false] - Monitors the stderr pipe for activity\n- readProcessErrors() -> [string] - Reads and returns error output from stderr\n- writeProcessInput(string $string) -> [void] - Writes data to the process stdin",
    "Canonical_solution": "use Monolog\\Level;\nuse Monolog\\LogRecord;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private string $command;\n    private ?string $cwd;\n    private array $pipes = [];\n    protected const DESCRIPTOR_SPEC = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    public function __construct(string $command, int|string|Level $level = Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        if ($command === '') {\n            throw new \\InvalidArgumentException('The command argument must be a non-empty string.');\n        }\n        if ($cwd === '') {\n            throw new \\InvalidArgumentException('The optional CWD argument must be a non-empty string or null.');\n        }\n\n        parent::__construct($level, $bubble);\n\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    protected function write(LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n\n        $errors = $this->readProcessErrors();\n        if ($errors !== '') {\n            throw new \\UnexpectedValueException(sprintf('Errors while writing to process: %s', $errors));\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (is_resource($this->process) === false) {\n            $this->startProcess();\n            $this->handleStartupErrors();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $this->process = proc_open($this->command, static::DESCRIPTOR_SPEC, $this->pipes, $this->cwd);\n        foreach ($this->pipes as $pipe) {\n            stream_set_blocking($pipe, false);\n        }\n    }\n\n    private function handleStartupErrors(): void\n    {\n        $selected = $this->selectErrorStream();\n        if (false === $selected) {\n            throw new \\UnexpectedValueException('Something went wrong while selecting a stream.');\n        }\n\n        $errors = $this->readProcessErrors();\n        if (is_resource($this->process) === false || $errors !== '') {\n            throw new \\UnexpectedValueException(\n                sprintf('The process \"%s\" could not be opened: ' . $errors, $this->command)\n            );\n        }\n    }\n\n    protected function selectErrorStream()\n    {\n        $empty = [];\n        $errorPipes = [$this->pipes[2]];\n        return stream_select($errorPipes, $empty, $empty, 1);\n    }\n\n    protected function readProcessErrors(): string\n    {\n        return (string) stream_get_contents($this->pipes[2]);\n    }\n\n    protected function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n\n    public function close(): void\n    {\n        if (is_resource($this->process)) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "wrong_result": "```php\n<?php\n\nclass ProcessHandler\n{\n    private $process = null;\n    private $command;\n    private $cwd = null;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        $this->command = $command;\n        $this->cwd = $cwd;\n        $this->ensureProcessIsStarted();\n    }\n\n    public function write(LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $formattedRecord = $this->formatRecord($record);\n        $this->writeProcessInput($formattedRecord);\n    }\n\n    public function close(): void\n    {\n        if (is_resource($this->process)) {\n            fclose($this->pipes[0]);\n            fclose($this->pipes[1]);\n            fclose($this->pipes[2]);\n            proc_close($this->process);\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!is_resource($this->process)) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"]\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException(\"Failed to start process.\");\n        }\n\n        $this->handleStartupErrors();\n    }\n\n    private function handleStartupErrors(): void\n    {\n        $status = proc_get_status($this->process);\n        if (!$status['running']) {\n            throw new \\RuntimeException(\"Process started but is not running.\");\n        }\n    }\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        $tvSec = 0;\n        return stream_select($read, $write, $except, $tvSec);\n    }\n\n    private function readProcessErrors(): string\n    {\n        $errors = '';\n        if ($this->selectErrorStream()) {\n            $errors = fread($this->pipes[2], 8192);\n        }\n        return $errors;\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n        fflush($this->pipes[0]);\n    }\n\n    private function formatRecord(LogRecord $record): string\n    {\n        // Placeholder for formatting logic\n        return $record->getMessage() . PHP_EOL;\n    }\n}\n\nenum Level: int\n{\n    case Debug = 100;\n    case Info = 200;\n    case Notice = 250;\n    case Warning = 300;\n    case Error = 400;\n    case Critical = 500;\n    case Alert = 550;\n    case Emergency = 600;\n}\n\nclass LogRecord\n{\n    private $message;\n    private $level;\n\n    public function __construct(string $message, Level $level)\n    {\n        $this->message = $message;\n        $this->level = $level;\n    }\n\n    public function getMessage(): string\n    {\n        return $this->message;\n    }\n\n    public function getLevel(): Level\n    {\n        return $this->level;\n    }\n}\n```"
  },
  {
    "Task_id": 144,
    "Instruction": "Task Description: Create a function that retrieves Git tag information from a specified directory using subprocess communication via pipes.\n\nFunction Description: The function checks if a given directory is a Git repository (by checking for .git folder) and then executes the 'git describe --tags' command to get the latest tag information. It handles subprocess communication using pipes for stdout and stderr, properly manages resources, and returns the tag information or false if unsuccessful.\n\nInput: \n- $path (string): The filesystem path to check for Git repository and execute Git command\n\nOutput:\n- Returns (string|bool): The trimmed output from 'git describe --tags' command as string if successful, false if:\n  - The path is not a Git repository\n  - The subprocess cannot be created\n  - The Git command returns a non-zero exit code",
    "Canonical_solution": "function getGitInformation(string $path)\n{\n    if (!\\is_dir($path . DIRECTORY_SEPARATOR . '.git')) {\n        return false;\n    }\n\n    $process = \\proc_open(\n        'git describe --tags',\n        [\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ],\n        $pipes,\n        $path\n    );\n\n    if (!\\is_resource($process)) {\n        return false;\n    }\n\n    $result = \\trim(\\stream_get_contents($pipes[1]));\n\n    \\fclose($pipes[1]);\n    \\fclose($pipes[2]);\n\n    $returnCode = \\proc_close($process);\n\n    if ($returnCode !== 0) {\n        return false;\n    }\n\n    return $result;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 145,
    "wrong_result": "```python\nimport os\nimport subprocess\n\ndef get_git_tag(path):\n    git_dir = os.path.join(path, '.git')\n    if not os.path.isdir(git_dir):\n        return False\n\n    try:\n        process = subprocess.Popen(\n            ['git', 'describe', '--tags'],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            cwd=path\n        )\n        stdout, stderr = process.communicate()\n        if process.returncode != 0:\n            return False\n        return stdout.decode().strip()\n    except Exception:\n        return False\n```"
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a PHP class that manages a subprocess using proc_open, handling input/output streams and proper cleanup.\n\nClass Description: ProcessStream is a class that manages the lifecycle of a subprocess, including initialization, stream handling, and termination. It provides access to the subprocess's standard input and output streams while properly handling errors and resource cleanup.\n\nAttributes:\n- command: string - The command to be executed in the subprocess\n- stream: resource - The process resource created by proc_open\n- in: resource - The input stream (stdin) of the subprocess\n- out: resource - The output stream (stdout) of the subprocess\n\nMethods:\n- setCommand(string $command): void - Sets the command to be executed by the subprocess\n- initialize(): void - Starts the subprocess, sets up streams, and checks for startup errors\n- terminate(): void - Closes all streams and terminates the subprocess\n- getReadConnectionDescription(): string - Returns a description of the process connection",
    "Canonical_solution": "namespace Symfony\\Component\\Mailer\\Transport\\Smtp\\Stream;\n\nuse Symfony\\Component\\Mailer\\Exception\\TransportException;\n\nfinal class ProcessStream extends AbstractStream\n{\n    private string $command;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorSpec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', '\\\\' === \\DIRECTORY_SEPARATOR ? 'a' : 'w'],\n        ];\n        $pipes = [];\n        $this->stream = proc_open($this->command, $descriptorSpec, $pipes);\n        stream_set_blocking($pipes[2], false);\n        if ($err = stream_get_contents($pipes[2])) {\n            throw new TransportException('Process could not be started: '.$err);\n        }\n        $this->in = &$pipes[0];\n        $this->out = &$pipes[1];\n    }\n\n    public function terminate(): void\n    {\n        if (null !== $this->stream) {\n            fclose($this->in);\n            fclose($this->out);\n            proc_close($this->stream);\n        }\n\n        parent::terminate();\n    }\n\n    protected function getReadConnectionDescription(): string\n    {\n        return 'process '.$this->command;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "wrong_result": "```php\n<?php\n\nclass ProcessStream {\n    private $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void {\n        $this->command = $command;\n    }\n\n    public function initialize(): void {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],  // stdin\n            1 => [\"pipe\", \"w\"],  // stdout\n            2 => [\"pipe\", \"w\"]   // stderr\n        ];\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n        if (!is_resource($this->stream)) {\n            throw new Exception(\"Failed to start subprocess\");\n        }\n\n        $this->in = $pipes[0];\n        $this->out = $pipes[1];\n        stream_set_blocking($this->out, false);\n    }\n\n    public function terminate(): void {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string {\n        $status = proc_get_status($this->stream);\n        return \"PID: {$status['pid']}, Running: \" . ($status['running'] ? 'Yes' : 'No');\n    }\n}\n\n?>\n```"
  },
  {
    "Task_id": 151,
    "Instruction": "Task Description: Create a PHP class that handles inter-process communication (IPC) using proc_open to execute external commands, manage input/output streams, and handle errors.\n\nClass Description: The ProcessHandler class manages subprocess execution via proc_open, providing methods to write input to the process, read output/errors, and properly clean up resources. It extends Monolog's AbstractProcessingHandler for logging integration.\n\nAttributes:\n- process: [resource|null] - The subprocess resource handle or null if not running\n- command: [string] - The command to execute in the subprocess\n- cwd: [string|null] - The working directory for the subprocess or null for default\n- pipes: [array] - Array of file pointers for process pipes (stdin, stdout, stderr)\n\nMethods:\n- __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null) -> [void] - Initializes the handler with command and optional working directory\n- write(array $record) -> [void] - Writes formatted log record to process stdin (inherited from AbstractProcessingHandler)\n- close() -> [void] - Closes all pipes and terminates the process\n- ensureProcessIsStarted() -> [void] - Starts the process if not already running\n- startProcess() -> [void] - Executes proc_open to start the subprocess\n- handleStartupErrors() -> [void] - Checks for and handles any startup errors\n- selectErrorStream() -> [int|false] - Monitors stderr for error output\n- readProcessErrors() -> [string] - Reads and returns content from stderr\n- writeProcessInput(string $string) -> [void] - Writes data to process stdin",
    "Canonical_solution": "use Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n    protected const DESCRIPTOR_SPEC = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        if ($command === '') {\n            throw new \\InvalidArgumentException('The command argument must be a non-empty string.');\n        }\n        if ($cwd === '') {\n            throw new \\InvalidArgumentException('The optional CWD argument must be a non-empty string or null.');\n        }\n\n        parent::__construct($level, $bubble);\n\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    protected function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record['formatted']);\n        $errors = $this->readProcessErrors();\n        if (empty($errors) === false) {\n            throw new \\UnexpectedValueException(sprintf('Errors while writing to process: %s', $errors));\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (is_resource($this->process) === false) {\n            $this->startProcess();\n            $this->handleStartupErrors();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $this->process = proc_open($this->command, static::DESCRIPTOR_SPEC, $this->pipes, $this->cwd);\n        foreach ($this->pipes as $pipe) {\n            stream_set_blocking($pipe, false);\n        }\n    }\n\n    private function handleStartupErrors(): void\n    {\n        $selected = $this->selectErrorStream();\n        if (false === $selected) {\n            throw new \\UnexpectedValueException('Something went wrong while selecting a stream.');\n        }\n\n        $errors = $this->readProcessErrors();\n        if (is_resource($this->process) === false || empty($errors) === false) {\n            throw new \\UnexpectedValueException(\n                sprintf('The process \"%s\" could not be opened: ' . $errors, $this->command)\n            );\n        }\n    }\n\n    protected function selectErrorStream()\n    {\n        $empty = [];\n        $errorPipes = [$this->pipes[2]];\n        return stream_select($errorPipes, $empty, $empty, 1);\n    }\n\n    protected function readProcessErrors(): string\n    {\n        return (string) stream_get_contents($this->pipes[2]);\n    }\n\n    protected function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n\n    public function close(): void\n    {\n        if (is_resource($this->process)) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "wrong_result": "```php\n<?php\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\AbstractProcessingHandler;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process = null;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    protected function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        fwrite($this->pipes[0], (string) $record['formatted']);\n    }\n\n    public function close(): void\n    {\n        if (is_resource($this->process)) {\n            fclose($this->pipes[0]);\n            fclose($this->pipes[1]);\n            fclose($this->pipes[2]);\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!is_resource($this->process)) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => [\"pipe\", \"r\"],\n            1 => [\"pipe\", \"w\"],\n            2 => [\"pipe\", \"w\"]\n        ];\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n        $this->handleStartupErrors();\n    }\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException(\"Failed to start process.\");\n        }\n    }\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]];\n        $write = null;\n        $except = null;\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        $errors = '';\n        if ($this->selectErrorStream() > 0) {\n            $errors = stream_get_contents($this->pipes[2]);\n        }\n        return $errors;\n    }\n\n    public function writeProcessInput(string $string): void\n    {\n        $this->ensureProcessIsStarted();\n        fwrite($this->pipes[0], $string);\n    }\n}\n```"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using Guzzle library to download files and fetch GitHub release information.\n\nClass Description: The HttpClient class provides methods for downloading remote files via HTTP and retrieving GitHub release information (both stable and pre-release) using the Guzzle HTTP client library.\n\nAttributes:\n- client: [Client] - Guzzle HTTP client instance used for making requests\n\nMethods:\n- __construct() -> [void] - Initializes the Guzzle HTTP client instance\n- getSourceFile(string $fileName, string $savePath, string $url) -> [bool] - Downloads a file from the specified URL and saves it to the given path\n- getLatestReleaseTagName(string $repo) -> [string] - Gets the latest stable release tag name from a GitHub repository\n- getLatestPreReleaseTagName(string $repo) -> [string] - Gets the latest pre-release tag name from a GitHub repository",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    /**\n     * Download remote file via HTTP\n     *\n     * @param string $fileName\n     * @param string $savePath\n     * @param string $url\n     * @return bool\n     */\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            if (! file_exists($savePath)) {\n                echo '\u76ee\u6807\u6587\u4ef6\u5939 ' . $savePath . ' \u4e0d\u5b58\u5728\uff0c\u4e0b\u8f09\u5931\u8d25\u3002' . PHP_EOL;\n                return false;\n            }\n\n            echo '- \u5f00\u59cb\u4e0b\u8f7d ' . $fileName . '...' . PHP_EOL;\n            $request = $this->client->get($url);\n            echo '- \u4e0b\u8f7d ' . $fileName . ' \u6210\u529f\uff0c\u6b63\u5728\u4fdd\u5b58...' . PHP_EOL;\n            $result = file_put_contents($savePath . $fileName, $request->getBody()->getContents());\n\n            if (! $result) {\n                echo '- \u4fdd\u5b58 ' . $fileName . ' \u81f3 ' . $savePath . ' \u5931\u8d25\u3002' . PHP_EOL;\n            } else {\n                echo '- \u4fdd\u5b58 ' . $fileName . ' \u81f3 ' . $savePath . ' \u6210\u529f\u3002' . PHP_EOL;\n            }\n\n            return true;\n        } catch (GuzzleException $e) {\n            echo '- \u4e0b\u8f7d ' . $fileName . ' \u5931\u8d25...' . PHP_EOL;\n            echo $e->getMessage() . PHP_EOL;\n\n            return false;\n        }\n    }\n\n    /**\n     * Get latest GitHub release tag\n     *\n     * @param string $repo\n     * @return string\n     * @throws GuzzleException\n     */\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        $url = 'https://api.github.com/repos/' . $repo . '/releases/latest' .\n            ($_ENV['github_access_token'] !== '' ? '?access_token=' . $_ENV['github_access_token'] : '');\n        $request = $this->client->get($url);\n\n        return json_decode(\n            $request->getBody()->getContents(),\n            true\n        )['tag_name'];\n    }\n\n    /**\n     * Get latest GitHub pre-release tag\n     *\n     * @param string $repo\n     * @return string\n     * @throws GuzzleException\n     */\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        $url = 'https://api.github.com/repos/' . $repo . '/releases' .\n            ($_ENV['github_access_token'] !== '' ? '?access_token=' . $_ENV['github_access_token'] : '');\n        $request = $this->client->get($url);\n        $latest = json_decode(\n            $request->getBody()->getContents(),\n            true\n        )[0];\n\n        return $latest['tag_name'];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nrequire 'vendor/autoload.php';\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url, ['sink' => $savePath . DIRECTORY_SEPARATOR . $fileName]);\n            return $response->getStatusCode() === 200;\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        try {\n            $url = \"https://api.github.com/repos/{$repo}/releases/latest\";\n            $response = $this->client->get($url);\n            $data = json_decode($response->getBody(), true);\n            return $data['tag_name'] ?? '';\n        } catch (GuzzleException $e) {\n            return '';\n        }\n    }\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        try {\n            $url = \"https://api.github.com/repos/{$repo}/releases\";\n            $response = $this->client->get($url);\n            $releases = json_decode($response->getBody(), true);\n            foreach ($releases as $release) {\n                if ($release['prerelease']) {\n                    return $release['tag_name'] ?? '';\n                }\n            }\n            return '';\n        } catch (GuzzleException $e) {\n            return '';\n        }\n    }\n}\n\n?>\n```"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a PHP class for making HTTP requests using cURL with support for various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: The RequestCore class provides a comprehensive wrapper around PHP's cURL functions to simplify HTTP requests. It supports GET, POST, PUT, DELETE, and HEAD methods, handles authentication, manages request/response headers and bodies, supports streaming for large files, and includes proxy configuration.\n\nAttributes:\n- request_url: string - The URL to send the request to\n- request_headers: array - Associative array of request headers\n- request_body: string - The request body content\n- response: string - The complete response from the server\n- response_headers: array - Parsed response headers\n- response_body: string - The response body content\n- response_code: int - HTTP response status code\n- response_info: array - Additional cURL response information\n- curl_handle: resource - The cURL handle resource\n- method: string - HTTP method (GET, POST, PUT, DELETE, HEAD)\n- proxy: array|null - Proxy configuration details\n- username: string|null - Authentication username\n- password: string|null - Authentication password\n- curlopts: array|null - Additional cURL options\n- debug_mode: bool - Whether to enable debug mode\n- request_class: string - Class name for request objects\n- response_class: string - Class name for response objects\n- useragent: string - User agent string\n- read_file: string|null - File path for reading data\n- read_stream: resource|null - Stream resource for reading data\n- read_stream_size: int|null - Size of read stream\n- read_stream_read: int - Bytes read from stream\n- write_file: string|null - File path for writing data\n- write_stream: resource|null - Stream resource for writing data\n- seek_position: int|null - Position to seek in read stream\n- cacert_location: mixed - CA certificate location\n- ssl_verification: bool - Whether to verify SSL\n- registered_streaming_read_callback: callable|null - Callback for streaming read\n- registered_streaming_write_callback: callable|null - Callback for streaming write\n\nMethods:\n- __construct(string|null $url, array|null $proxy, array|null $helpers) -> self - Initialize the request object\n- __destruct() -> self - Clean up resources\n- set_credentials(string $user, string $pass) -> self - Set authentication credentials\n- add_header(string $key, string $value) -> self - Add a request header\n- remove_header(string $key) -> self - Remove a request header\n- set_method(string $method) -> self - Set the HTTP method\n- set_useragent(string $ua) -> self - Set the user agent\n- set_body(string $body) -> self - Set the request body\n- set_request_url(string $url) -> self - Set the request URL\n- set_curlopts(array $curlopts) -> self - Set additional cURL options\n- set_read_stream_size(int $size) -> self - Set read stream size\n- set_read_stream(resource $resource, int|null $size) -> self - Set read stream resource\n- set_read_file(string $location) -> self - Set read file location\n- set_write_stream(resource $resource) -> self - Set write stream resource\n- set_write_file(string $location) -> self - Set write file location\n- set_proxy(string $proxy) -> self - Configure proxy settings\n- set_seek_position(int|null $position) -> self - Set seek position for read stream\n- register_streaming_read_callback(callable $callback) -> self - Register read callback\n- register_streaming_write_callback(callable $callback) -> self - Register write callback\n- streaming_read_callback(resource $curl_handle, resource $file_handle, int $length) -> string - Handle streaming read\n- streaming_write_callback(resource $curl_handle, string $data) -> int - Handle streaming write\n- prep_request() -> resource - Prepare and return cURL handle\n- process_response(resource|null $curl_handle, string|null $response) -> mixed - Process the response\n- send_request(bool $parse = false) -> mixed - Send the request and get response\n- get_response_header(string|null $header) -> mixed - Get response header(s)\n- get_response_body() -> string - Get response body\n- get_response_code() -> int - Get response status code",
    "Canonical_solution": "class RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'RequestCore';\n    public $response_class = 'ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request']))\n        {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response']))\n        {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy)\n        {\n            $this->set_proxy($proxy);\n        }\n\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream))\n        {\n            fclose($this->read_stream);\n        }\n\n        if (isset($this->write_file) && isset($this->write_stream))\n        {\n            fclose($this->write_stream);\n        }\n\n        return $this;\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key]))\n        {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0)\n        {\n            $stats = fstat($resource);\n\n            if ($stats && $stats['size'] >= 0)\n            {\n                $position = ftell($resource);\n\n                if ($position !== false && $position >= 0)\n                {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->set_read_stream($read_file_handle);\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->set_write_stream($write_file_handle);\n    }\n\n    public function set_proxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = isset($position) ? (integer) $position : null;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size)\n        {\n            return '';\n        }\n\n        if ($this->read_stream_read == 0 && isset($this->seek_position) && $this->seek_position !== ftell($this->read_stream))\n        {\n            if (fseek($this->read_stream, $this->seek_position) !== 0)\n            {\n                throw new RequestCore_Exception('The stream does not support seeking and is either not at the requested position or the position is unknown.');\n            }\n        }\n\n        $read = fread($this->read_stream, min($this->read_stream_size - $this->read_stream_read, $length));\n        $this->read_stream_read += strlen($read);\n\n        $out = $read === false ? '' : $read;\n\n        if ($this->registered_streaming_read_callback)\n        {\n            call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $out);\n        }\n\n        return $out;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n\n        while ($written_total < $length)\n        {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n\n            if ($written_last === false)\n            {\n                return $written_total;\n            }\n\n            $written_total += $written_last;\n        }\n\n        if ($this->registered_streaming_write_callback)\n        {\n            call_user_func($this->registered_streaming_write_callback, $curl_handle, $written_total);\n        }\n\n        return $written_total;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->ssl_verification)\n        {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);\n        }\n        else\n        {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        if ($this->cacert_location === true)\n        {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, dirname(__FILE__) . '/cacert.pem');\n        }\n        elseif (is_string($this->cacert_location))\n        {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->debug_mode)\n        {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if (!ini_get('safe_mode') && !ini_get('open_basedir'))\n        {\n            curl_setopt($curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        if ($this->proxy)\n        {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n\n            if (isset($this->proxy['user']) && isset($this->proxy['pass']))\n            {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password)\n        {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (extension_loaded('zlib'))\n        {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n\n        if (isset($this->request_headers) && count($this->request_headers))\n        {\n            $temp_headers = array();\n\n            foreach ($this->request_headers as $k => $v)\n            {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        switch ($this->method)\n        {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream))\n                {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0)\n                    {\n                        throw new RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                }\n                else\n                {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream))\n                {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                }\n                else\n                {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0)\n        {\n            foreach ($this->curlopts as $k => $v)\n            {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response)\n        {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle))\n        {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n\n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n\n            $header_assoc = array();\n            foreach ($this->response_headers as $header)\n            {\n                $kv = explode(': ', $header);\n                $header_assoc[strtolower($kv[0])] = isset($kv[1])?$kv[1]:'';\n            }\n\n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n\n            if ($curl_handle && $response)\n            {\n                return new $this->response_class($this->response_headers, $this->response_body, $this->response_code, $this->curl_handle);\n            }\n        }\n\n        return false;\n    }\n\n    public function send_request($parse = false)\n    {\n        set_time_limit(0);\n\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false)\n        {\n            throw new RequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n\n        curl_close($curl_handle);\n\n        if ($parse)\n        {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n    public function get_response_header($header = null)\n    {\n        if ($header)\n        {\n            return $this->response_headers[strtolower($header)];\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\nclass RequestCore {\n    private $request_url;\n    private $request_headers = [];\n    private $request_body;\n    private $response;\n    private $response_headers = [];\n    private $response_body;\n    private $response_code;\n    private $response_info;\n    private $curl_handle;\n    private $method = 'GET';\n    private $proxy = null;\n    private $username = null;\n    private $password = null;\n    private $curlopts = null;\n    private $debug_mode = false;\n    private $request_class = 'RequestCore';\n    private $response_class = 'ResponseCore';\n    private $useragent = 'RequestCore/1.0';\n    private $read_file = null;\n    private $read_stream = null;\n    private $read_stream_size = null;\n    private $read_stream_read = 0;\n    private $write_file = null;\n    private $write_stream = null;\n    private $seek_position = null;\n    private $cacert_location = null;\n    private $ssl_verification = true;\n    private $registered_streaming_read_callback = null;\n    private $registered_streaming_write_callback = null;\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if ($helpers) {\n            $this->request_class = $helpers['request_class'] ?? $this->request_class;\n            $this->response_class = $helpers['response_class'] ?? $this->response_class;\n        }\n    }\n\n    public function __destruct() {\n        if (is_resource($this->curl_handle)) {\n            curl_close($this->curl_handle);\n        }\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    private function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->registered_streaming_read_callback) {\n            return call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $length);\n        }\n        return fread($file_handle, $length);\n    }\n\n    private function streaming_write_callback($curl_handle, $data) {\n        if ($this->registered_streaming_write_callback) {\n            return call_user_func($this->registered_streaming_write_callback, $curl_handle, $data);\n        }\n        return fwrite($this->write_stream, $data);\n    }\n\n    private function prep_request() {\n        $this->curl_handle = curl_init();\n        curl_setopt($this->curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($this->curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n\n        if ($this->request_headers) {\n            $headers = [];\n            foreach ($this->request_headers as $key => $value) {\n                $headers[] = \"$key: $value\";\n            }\n            curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        if ($this->request_body) {\n            curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($this->curl_handle, CURLOPT_USERPWD, \"{$this->username}:{$this->password}\");\n        }\n\n        if ($this->proxy) {\n            curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            curl_setopt($this->curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, \"{$this->proxy['user']}:{$this->proxy['pass']}\");\n            }\n        }\n\n        if ($this->read_stream) {\n            curl_setopt($this->curl_handle, CURLOPT_READFUNCTION, [$this, 'streaming_read_callback']);\n            curl_setopt($this->curl_handle, CURLOPT_UPLOAD, true);\n            if ($this->seek_position !== null) {\n                fseek($this->read_stream, $this->seek_position);\n            }\n        }\n\n        if ($this->write_stream || $this->write_file) {\n            curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, [$this, 'streaming_write_callback']);\n        }\n\n        if ($this->cacert_location) {\n            curl_setopt($this->curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYPEER, $this->ssl_verification);\n\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $opt => $value) {\n                curl_setopt($this->curl_handle, $opt, $value);\n            }\n        }\n\n        return $this->curl_handle;\n    }\n\n    private function process_response($curl_handle, $response) {\n        $this->response = $response;\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n\n        $header_size = $this->response_info['header_size'];\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n\n        return $this->response;\n    }\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $response = curl_exec($curl_handle);\n        if ($parse) {\n            return $this->process_response($curl_handle, $response);\n        }\n        return $response;\n    }\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            $headers = explode(\"\\r\\n\", $this->response_headers);\n            foreach ($headers as $h) {\n                if (strpos($h, $header) !== false) {\n                    return trim(substr($h, strpos($h, ':') + 1));\n                }\n            }\n            return null;\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n}\n```"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Implement a class for interacting with a pretreatment API service that handles task processing and querying, using HTTP requests with Guzzle client in PHP.\n\nClass Description: The Pretreat class provides functionality to submit tasks for processing and query their status through an API service. It handles request signing, parameter preparation, and response processing.\n\nAttributes:\n\nAttribute1: Config $config - Configuration object containing service settings like timeout, service name, and endpoint URLs\n\nMethods:\n\nMethod1: __construct(Config $config) -> void - Initializes the Pretreat instance with configuration. Throws an exception if processNotifyUrl is not configured.\n\nMethod2: process(array $tasks, array $optionalParams = []) -> array - Submits tasks for processing. Takes an array of tasks and optional parameters, returns the API response as an associative array.\n\nMethod3: query(array $taskIds, string $path) -> array|bool - Queries the status of tasks by their IDs. Returns an array of tasks if successful, or false on failure.",
    "Canonical_solution": "namespace Upyun\\Api;\n\nuse GuzzleHttp\\Client;\nuse Upyun\\Config;\nuse Upyun\\Signature;\nuse Upyun\\Util;\n\nclass Pretreat\n{\n    protected $config;\n\n    public function __construct(Config $config)\n    {\n        if (!$config->processNotifyUrl) {\n            throw new \\Exception(\"should config prosessNotifyUrl first.\");\n        }\n        $this->config = $config;\n    }\n\n    public function process($tasks, $optionalParams = array())\n    {\n        $encodedTasks = Util::base64Json($tasks);\n\n        $client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n\n        $params = array(\n            'service' => $this->config->serviceName,\n            'notify_url' => $this->config->processNotifyUrl,\n            'tasks' => $encodedTasks,\n        );\n\n        $params = array_merge($params, $optionalParams);\n\n        $path = '/pretreatment/';\n        $method = 'POST';\n        $signedHeaders = Signature::getHeaderSign($this->config, $method, $path);\n\n        $url = $this->config->getPretreatEndPoint() . $path;\n        $response = $client->request($method, $url, [\n            'headers' => $signedHeaders,\n            'form_params' => $params\n        ]);\n\n        $body = $response->getBody()->getContents();\n        return json_decode($body, true);\n    }\n\n    public function query($taskIds, $path)\n    {\n        $client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n\n        $params = array(\n            'service' => $this->config->serviceName,\n            'task_ids' => implode(',', $taskIds)\n        );\n        $path = $path . '?' . http_build_query($params);\n\n        $method = 'GET';\n        $url = $this->config->getPretreatEndPoint() . $path;\n        $signedHeaders = Signature::getHeaderSign($this->config, $method, $path);\n        $response = $client->request($method, $url, [\n            'headers' => $signedHeaders\n        ]);\n\n        if ($response->getStatusCode() === 200) {\n            $body = $response->getBody()->getContents();\n            $result = json_decode($body, true);\n            if (is_array($result)) {\n                return $result['tasks'];\n            }\n        }\n        return false;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass Pretreat\n{\n    private Config $config;\n    private Client $client;\n\n    public function __construct(Config $config)\n    {\n        if (!isset($config->processNotifyUrl)) {\n            throw new Exception('Process notify URL is not configured.');\n        }\n        $this->config = $config;\n        $this->client = new Client([\n            'base_uri' => $config->endpoint,\n            'timeout' => $config->timeout,\n        ]);\n    }\n\n    public function process(array $tasks, array $optionalParams = []): array\n    {\n        $body = array_merge(['tasks' => $tasks], $optionalParams);\n        try {\n            $response = $this->client->post('/process', [\n                'json' => $body,\n                'headers' => $this->getHeaders(),\n            ]);\n            return json_decode($response->getBody(), true);\n        } catch (GuzzleException $e) {\n            return ['error' => $e->getMessage()];\n        }\n    }\n\n    public function query(array $taskIds, string $path): array|bool\n    {\n        try {\n            $response = $this->client->get($path, [\n                'query' => ['task_ids' => implode(',', $taskIds)],\n                'headers' => $this->getHeaders(),\n            ]);\n            return json_decode($response->getBody(), true);\n        } catch (GuzzleException $e) {\n            return false;\n        }\n    }\n\n    private function getHeaders(): array\n    {\n        return [\n            'Authorization' => 'Bearer ' . $this->config->apiKey,\n            'Content-Type' => 'application/json',\n        ];\n    }\n}\n\nclass Config\n{\n    public string $endpoint;\n    public int $timeout;\n    public string $processNotifyUrl;\n    public string $apiKey;\n\n    public function __construct(string $endpoint, int $timeout, string $processNotifyUrl, string $apiKey)\n    {\n        $this->endpoint = $endpoint;\n        $this->timeout = $timeout;\n        $this->processNotifyUrl = $processNotifyUrl;\n        $this->apiKey = $apiKey;\n    }\n}\n```"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a PHP class that fetches currency conversion rates from an external API and stores them in a repository.\n\nClass Description: The FetchConversionRate class is responsible for retrieving currency conversion rates between a base currency and all other available currencies. It uses Guzzle HTTP client to make requests to an external currency API and stores the results in a conversion rate repository.\n\nAttributes:\n- baseCurrencyId: int - The ID of the base currency for which conversion rates will be fetched\n- currencyRepository: CurrencyRepository - Repository for accessing currency data\n- conversionRateRepository: ConversionRateRepository - Repository for storing conversion rates\n\nMethods:\n- __construct(int $baseCurrencyId) -> void - Constructor that initializes the base currency ID\n- handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository) -> void - Main method that executes the conversion rate fetching process:\n  - Retrieves all currencies from the repository\n  - For each target currency, makes an API request to get the conversion rate\n  - Stores or updates the conversion rate in the repository\n  - Skips invalid currencies and handles API request failures gracefully",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse Exception;\n\nclass FetchConversionRate\n{\n    protected $baseCurrencyId;\n    private $currencyRepository;\n    private $conversionRateRepository;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(\n        CurrencyRepository $currencyRepository,\n        ConversionRateRepository $conversionRateRepository\n    ): void {\n        $this->currencyRepository = $currencyRepository;\n        $this->conversionRateRepository = $conversionRateRepository;\n\n        $baseCurrency = $this->currencyRepository->getById($this->baseCurrencyId);\n\n        if (!$baseCurrency || !$baseCurrency->iso) {\n            return;\n        }\n\n        $client = new Client();\n\n        foreach ($this->currencyRepository->getAll() as $targetCurrency) {\n            if (!$targetCurrency->iso || $baseCurrency->iso === $targetCurrency->iso) {\n                continue;\n            }\n\n            $url = sprintf(\n                'https://cdn.jsdelivr.net/npm/@fawazahmed0/currency-api@latest/v1/currencies/%s.json',\n                $baseCurrency->iso_lowercased,\n            );\n\n            try {\n                $response = $client->request('GET', $url);\n                $decoded_response = json_decode($response->getBody(), true);\n                $rate = $decoded_response[$baseCurrency->iso_lowercased][$targetCurrency->iso_lowercased];\n            } catch (Exception) {\n                continue;\n            }\n\n            $this->conversionRateRepository->createOrUpdate(\n                $baseCurrency->id,\n                $targetCurrency->id,\n                $rate\n            );\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nclass FetchConversionRate\n{\n    private $baseCurrencyId;\n    private $currencyRepository;\n    private $conversionRateRepository;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $this->currencyRepository = $currencyRepository;\n        $this->conversionRateRepository = $conversionRateRepository;\n\n        $currencies = $this->currencyRepository->getAllCurrencies();\n        $client = new \\GuzzleHttp\\Client();\n\n        foreach ($currencies as $currency) {\n            try {\n                $response = $client->request('GET', 'https://api.example.com/convert', [\n                    'query' => [\n                        'from' => $this->baseCurrencyId,\n                        'to' => $currency->getId()\n                    ]\n                ]);\n\n                $data = json_decode($response->getBody(), true);\n                if (isset($data['rate'])) {\n                    $this->conversionRateRepository->storeOrUpdateRate(\n                        $this->baseCurrencyId,\n                        $currency->getId(),\n                        $data['rate']\n                    );\n                }\n            } catch (\\Exception $e) {\n                // Handle exception gracefully\n                continue;\n            }\n        }\n    }\n}\n\ninterface CurrencyRepository\n{\n    public function getAllCurrencies(): array;\n}\n\ninterface ConversionRateRepository\n{\n    public function storeOrUpdateRate(int $baseCurrencyId, int $targetCurrencyId, float $rate): void;\n}\n\n?>\n```"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a PHP class that provides HTTP client functionality using cURL, supporting various HTTP methods, headers, cookies, proxies, and file uploads.\n\nClass Description: The `requests` class is a static HTTP client implementation that handles HTTP requests through cURL. It supports GET, POST, and other HTTP methods, manages cookies, headers, user agents, proxies, and file uploads. The class maintains connection settings and request history.\n\nAttributes:\n\nVERSION: [string] - The version number of the requests class\nch: [resource|null] - The cURL handle resource\ntimeout: [int|array] - Timeout settings for the connection\nencoding: [string|null] - Request encoding\noutput_encoding: [string|null] - Response encoding\ncookies: [array] - Global cookies to be sent with requests\nrawheaders: [array] - Request headers\ndomain_cookies: [array] - Domain-specific cookies\nheaders: [array] - Response headers\nuseragents: [array] - List of user agent strings\nclient_ips: [array] - List of client IP addresses for spoofing\nproxies: [array] - List of proxy servers\nraw: [string] - Raw response including headers\nhead: [string] - Response headers\ncontent: [string] - Response body\ntext: [string] - Processed response text\ninfo: [array] - cURL request information\nhistory: [int] - HTTP redirect history status code\nstatus_code: [int] - HTTP response status code\nerror: [string] - Error message if request fails\n\nMethods:\n\ninit(): [void] -> [resource] - Initializes the cURL session with default settings\nrequest($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) -> [string|bool] - Executes an HTTP request to the specified URL with given parameters\n_is_url($url) -> [bool] - Validates if the input string is a valid URL\nget_cookies($domain = '') -> [array] - Retrieves cookies for a specific domain\nget_response_headers($header) -> [array] - Parses response headers\nget_response_cookies($header, $domain) -> [void] - Extracts cookies from response headers\nsplit_header_body() -> [array] - Splits response into headers and body\nget_history($header) -> [int] - Gets redirect history from response headers\nget_mimetype($filepath) -> [string] - Gets MIME type of a file",
    "Canonical_solution": "namespace phpspider\\core;\n\nclass requests\n{\n    const VERSION = '2.0.1';\n    protected static $ch = null;\n\n    public static $timeout = 15;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\"requests/2.0.0\");\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = \"\";\n    public static $head = \"\";\n    public static $content = \"\";\n    public static $text = \"\";\n    public static $info = array();\n    public static $history = 302;\n    public static $status_code = 0;\n    public static $error = \"\";\n\n    public static function init()\n    {\n        if (!is_resource(self::$ch))\n        {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, false);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, \"phpspider-requests/\".self::VERSION);\n            if (is_array(self::$timeout))\n            {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n            }\n            else\n            {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, ceil(self::$timeout / 2));\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n            }\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 5);\n            curl_setopt(self::$ch, CURLOPT_NOSIGNAL, true);\n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL)\n    {\n        $method = strtoupper($method);\n        if(!self::_is_url($url))\n        {\n            self::$error = \"You have requested URL ({$url}) is not a valid HTTP address\";\n            return false;\n        }\n\n        if ($method == 'GET' && !empty($fields))\n        {\n            $url = $url.(strpos($url, '?') === false ? '?' : '&').http_build_query($fields);\n        }\n\n        $parse_url = parse_url($url);\n        if (empty($parse_url) || empty($parse_url['host']) || !in_array($parse_url['scheme'], array('http', 'https')))\n        {\n            self::$error = \"No connection adapters were found for '{$url}'\";\n            return false;\n        }\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n\n        if ($method != 'GET')\n        {\n            if ($method == 'POST')\n            {\n                $tmpheaders = array_change_key_case(self::$rawheaders, CASE_LOWER);\n                if (isset($tmpheaders['content-type']) && $tmpheaders['content-type'] == 'application/json')\n                {\n                    curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n                }\n                else\n                {\n                    curl_setopt(self::$ch, CURLOPT_POST, true);\n                }\n\n                $file_fields = array();\n                if (!empty($files))\n                {\n                    foreach ($files as $postname => $file)\n                    {\n                        $filepath = realpath($file);\n                        if (!file_exists($filepath))\n                        {\n                            continue;\n                        }\n                        $filename = basename($filepath);\n                        $type = self::get_mimetype($filepath);\n                        $file_fields[$postname] = curl_file_create($filepath, $type, $filename);\n                    }\n                }\n\n                if (empty($file_fields))\n                {\n                    if (is_array($fields))\n                    {\n                        $fields = http_build_query($fields);\n                    }\n                }\n                else\n                {\n                    if (is_array($fields) && !empty($fields))\n                    {\n                        $fields = array_merge($fields, $file_fields);\n                    }\n                    else\n                    {\n                        $fields = $file_fields;\n                    }\n                }\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n            }\n            else\n            {\n                self::$rawheaders['X-HTTP-Method-Override'] = $method;\n                curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n            }\n        }\n\n        $cookies = self::get_cookies();\n        $domain_cookies = self::get_cookies($parse_url['host']);\n        $cookies = array_merge($cookies, $domain_cookies);\n        if (!empty($cookies))\n        {\n            foreach ($cookies as $key=>$value)\n            {\n                $cookie_arr[] = $key.'='.$value;\n            }\n            $cookies = implode('; ', $cookie_arr);\n            curl_setopt(self::$ch, CURLOPT_COOKIE, $cookies);\n        }\n\n        if (!empty(self::$useragents))\n        {\n            $key = rand(0, count(self::$useragents) - 1);\n            self::$rawheaders['User-Agent'] = self::$useragents[$key];\n        }\n\n        if (!empty(self::$client_ips))\n        {\n            $key = rand(0, count(self::$client_ips) - 1);\n            self::$rawheaders['CLIENT-IP'] = self::$client_ips[$key];\n            self::$rawheaders['X-FORWARDED-FOR'] = self::$client_ips[$key];\n        }\n\n        if (self::$rawheaders)\n        {\n            $http_headers = array();\n            foreach (self::$rawheaders as $k=>$v)\n            {\n                $http_headers[] = $k.': '.$v;\n            }\n            curl_setopt(self::$ch, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        curl_setopt(self::$ch, CURLOPT_ENCODING, 'gzip');\n\n        if ($parse_url['scheme'] == 'https')\n        {\n            curl_setopt(self::$ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt(self::$ch, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        if (self::$proxies)\n        {\n            $key = rand(0, count(self::$proxies) - 1);\n            $proxy = self::$proxies[$key];\n            curl_setopt(self::$ch, CURLOPT_PROXY, $proxy);\n        }\n\n        curl_setopt(self::$ch, CURLOPT_HEADER, true);\n        if ($allow_redirects)\n        {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n        if (self::$raw === false)\n        {\n            self::$error = 'Curl error: ' . curl_error(self::$ch);\n        }\n\n        curl_close(self::$ch);\n\n        list($header, $text) = self::split_header_body();\n        self::$history = self::get_history($header);\n        self::$headers = self::get_response_headers($header);\n        self::get_response_cookies($header, $parse_url['host']);\n        return $text;\n    }\n\n    private static function _is_url($url)\n    {\n        $pattern = \"/\\b(([\\w-]+:\\/\\/?|www[.])[^\\s()<>]+(?:\\([\\w\\d]+\\)|([^[:punct:]\\s]|\\/)))/\";\n        return preg_match($pattern, $url) ? true : false;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\n<?php\n\nclass requests {\n    const VERSION = '1.0.0';\n    private static $ch = null;\n    private static $timeout = 30;\n    private static $encoding = null;\n    private static $output_encoding = null;\n    private static $cookies = [];\n    private static $rawheaders = [];\n    private static $domain_cookies = [];\n    private static $headers = [];\n    private static $useragents = [];\n    private static $client_ips = [];\n    private static $proxies = [];\n    private static $raw = '';\n    private static $head = '';\n    private static $content = '';\n    private static $text = '';\n    private static $info = [];\n    private static $history = 0;\n    private static $status_code = 0;\n    private static $error = '';\n\n    public static function init() {\n        self::$ch = curl_init();\n        curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n        if (!empty(self::$proxies)) {\n            curl_setopt(self::$ch, CURLOPT_PROXY, self::$proxies[array_rand(self::$proxies)]);\n        }\n        if (!empty(self::$useragents)) {\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, self::$useragents[array_rand(self::$useragents)]);\n        }\n        if (!empty(self::$client_ips)) {\n            curl_setopt(self::$ch, CURLOPT_INTERFACE, self::$client_ips[array_rand(self::$client_ips)]);\n        }\n    }\n\n    public static function request($url, $method = 'GET', $fields = [], $files = [], $allow_redirects = true, $cert = null) {\n        if (!self::_is_url($url)) {\n            return false;\n        }\n        self::init();\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n        curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n        if ($method === 'POST' || $method === 'PUT') {\n            $data = $fields;\n            if (!empty($files)) {\n                foreach ($files as $key => $file) {\n                    $data[$key] = new CURLFile($file['path'], self::get_mimetype($file['path']), $file['name']);\n                }\n            }\n            curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $data);\n        }\n        if (!empty(self::$cookies)) {\n            $cookieString = '';\n            foreach (self::$cookies as $key => $value) {\n                $cookieString .= \"$key=$value; \";\n            }\n            curl_setopt(self::$ch, CURLOPT_COOKIE, trim($cookieString));\n        }\n        if (!empty(self::$rawheaders)) {\n            curl_setopt(self::$ch, CURLOPT_HTTPHEADER, self::$rawheaders);\n        }\n        if ($cert !== null) {\n            curl_setopt(self::$ch, CURLOPT_SSLCERT, $cert);\n        }\n        curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, $allow_redirects);\n        self::$raw = curl_exec(self::$ch);\n        if (curl_errno(self::$ch)) {\n            self::$error = curl_error(self::$ch);\n            return false;\n        }\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n        list(self::$head, self::$content) = self::split_header_body();\n        self::$headers = self::get_response_headers(self::$head);\n        self::get_response_cookies(self::$head, parse_url($url, PHP_URL_HOST));\n        self::$text = self::$content;\n        if (self::$output_encoding !== null) {\n            self::$text = mb_convert_encoding(self::$text, self::$output_encoding, self::$encoding);\n        }\n        return self::$text;\n    }\n\n    private static function _is_url($url) {\n        return filter_var($url, FILTER_VALIDATE_URL) !== false;\n    }\n\n    public static function get_cookies($domain = '') {\n        if ($domain) {\n            return isset(self::$domain_cookies[$domain]) ? self::$domain_cookies[$domain] : [];\n        }\n        return self::$cookies;\n    }\n\n    private static function get_response_headers($header) {\n        $headers = [];\n        $lines = explode(\"\\r\\n\", $header);\n        foreach ($lines as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $headers[trim($key)] = trim($value);\n            }\n        }\n        return $headers;\n    }\n\n    private static function get_response_cookies($header, $domain) {\n        preg_match_all('/^Set-Cookie:\\s*([^;]*)/mi', $header, $matches);\n        foreach ($matches[1] as $item) {\n            parse_str($item, $cookie);\n            foreach ($cookie as $key => $value) {\n                self::$domain_cookies[$domain][$key] = $value;\n            }\n        }\n    }\n\n    private static function split_header_body() {\n        $parts = explode(\"\\r\\n\\r\\n\", self::$raw, 2);\n        return $parts + ['', ''];\n    }\n\n    private static function get_history($header) {\n        preg_match('/^Location:\\s*(.*)/mi', $header, $matches);\n        return !empty($matches[1]) ? 301 : 0;\n    }\n\n    private static function get_mimetype($filepath) {\n        $finfo = finfo_open(FILEINFO_MIME_TYPE);\n        $mimetype = finfo_file($finfo, $filepath);\n        finfo_close($finfo);\n        return $mimetype;\n    }\n}\n\n?>\n```"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a PHP class for handling HTTP requests using cURL with support for various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: The BcsRequestcore class provides a comprehensive wrapper around PHP's cURL functions to handle HTTP requests. It supports GET, POST, PUT, DELETE, and HEAD methods, with features for request customization, streaming uploads/downloads, authentication, and proxy support. The class manages the entire request lifecycle including preparation, execution, and response processing.\n\nAttributes:\n\nrequest_url: [string] - The URL to send the request to\nrequest_headers: [array] - Associative array of request headers\nrequest_body: [string] - The request body content\nresponse: [mixed] - The raw response from the server\nresponse_headers: [array] - Parsed response headers\nresponse_body: [string] - The response body content\nresponse_code: [int] - HTTP response status code\nresponse_info: [array] - Additional response information\ncurl_handle: [resource] - The cURL handle resource\nmethod: [string] - HTTP method (GET, POST, PUT, DELETE, HEAD)\nproxy: [array|null] - Proxy configuration details\nusername: [string|null] - Authentication username\npassword: [string|null] - Authentication password\ncurlopts: [array|null] - Additional cURL options\ndebug_mode: [bool] - Flag for debug mode\nrequest_class: [string] - Class name for request handling\nresponse_class: [string] - Class name for response handling\nuseragent: [string] - User agent string\nread_file: [string|null] - File path for streaming read\nread_stream: [resource|null] - Stream resource for reading\nread_stream_size: [int|null] - Size of read stream\nread_stream_read: [int] - Bytes read from stream\nwrite_file: [string|null] - File path for streaming write\nwrite_stream: [resource|null] - Stream resource for writing\nseek_position: [int|null] - Seek position for streams\nregistered_streaming_read_callback: [callable|null] - Callback for streaming read\nregistered_streaming_write_callback: [callable|null] - Callback for streaming write\n\nMethods:\n\n__construct([string|null $url], [array|null $proxy], [array|null $helpers]) -> [self] - Initializes the request object with optional URL, proxy, and helper classes\n__destruct() -> [self] - Cleans up any open file handles\nsetCredentials([string $user], [string $pass]) -> [self] - Sets basic authentication credentials\naddHeader([string $key], [string $value]) -> [self] - Adds a request header\nremoveHeader([string $key]) -> [self] - Removes a request header\nsetMethod([string $method]) -> [self] - Sets the HTTP method\nsetUseragent([string $ua]) -> [self] - Sets the user agent string\nsetBody([string $body]) -> [self] - Sets the request body\nsetRequestUrl([string $url]) -> [self] - Sets the request URL\nsetCurlopts([array $curlopts]) -> [self] - Sets additional cURL options\nsetReadStreamSize([int $size]) -> [self] - Sets the read stream size\nsetReadStream([resource $resource], [int|null $size]) -> [self] - Sets a stream resource for reading\nsetReadFile([string $location]) -> [self] - Sets a file for streaming read\nsetWriteStream([resource $resource]) -> [self] - Sets a stream resource for writing\nsetWriteFile([string $location]) -> [self] - Sets a file for streaming write\nsetProxy([string $proxy]) -> [self] - Configures proxy settings\nsetSeekPosition([int|null $position]) -> [self] - Sets the seek position for streams\nregisterStreamingReadCallback([callable $callback]) -> [self] - Registers a streaming read callback\nregisterStreamingWriteCallback([callable $callback]) -> [self] - Registers a streaming write callback\nprepRequest() -> [resource] - Prepares and returns a cURL handle with configured options\nsendRequest([bool $parse = false]) -> [mixed] - Executes the request and returns response\nprocessResponse([resource|null $curl_handle], [mixed|null $response]) -> [mixed] - Processes the response into headers and body\nisBaeEnv() -> [bool] - Checks if running in Baidu App Engine environment\ngetResponseHeader([string|null $header]) -> [mixed] - Gets specific or all response headers\ngetResponseBody() -> [string] - Gets the response body\ngetResponseCode() -> [int] - Gets the HTTP response code",
    "Canonical_solution": "use Think\\Upload\\Driver\\Bcs\\BCS_RequestCore_Exception as BCS_RequestCore_Exception;\n\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BCS_RequestCore';\n    public $response_class = 'BCS_ResponseCore';\n    public $useragent = 'BCS_RequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->setProxy($proxy);\n        }\n\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (isset($this->write_file) && isset($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        return $this;\n    }\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size'] >= 0) {\n                $position = ftell($resource);\n                if (false !== $position && $position >= 0) {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n        $this->read_stream = $resource;\n        return $this->setReadStreamSize($size);\n    }\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->setReadStream($read_file_handle);\n    }\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->setWriteStream($write_file_handle);\n    }\n\n    public function setProxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = isset($position) ? (integer) $position : null;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (extension_loaded('zlib')) {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n\n        if (isset($this->request_headers) && count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        switch ($this->method) {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new BCS_RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream)) {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function sendRequest($parse = false)\n    {\n        if (false === $this->isBaeEnv()) {\n            set_time_limit(0);\n        }\n\n        $curl_handle = $this->prepRequest();\n        $this->response = curl_exec($curl_handle);\n\n        if (false === $this->response ||\n            (self::HTTP_GET === $this->method &&\n                curl_errno($curl_handle) === CURLE_PARTIAL_FILE)) {\n            throw new BCS_RequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->processResponse($curl_handle, $this->response);\n        curl_close($curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle)) {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n\n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n\n            $header_assoc = array();\n            foreach ($this->response_headers as $header) {\n                $kv = explode(': ', $header);\n                $header_assoc[$kv[0]] = $kv[1];\n            }\n\n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n\n            if ($curl_handle && $response) {\n                $class = '\\Think\\Upload\\Driver\\Bcs\\\\' . $this->response_class;\n                return new $class($this->response_headers, $this->response_body, $this->response_code, $this->curl_handle);\n            }\n        }\n\n        return false;\n    }\n\n    private function isBaeEnv()\n    {\n        if (isset($_SERVER['HTTP_HOST'])) {\n            $host = $_SERVER['HTTP_HOST'];\n            $pos = strpos($host, '.');\n            if (false !== $pos) {\n                $substr = substr($host, $pos + 1);\n                if ('duapp.com' == $substr) {\n                    return true;\n                }\n            }\n        }\n        if (isset($_SERVER[\"HTTP_BAE_LOGID\"])) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\nclass BcsRequestcore {\n    private $request_url;\n    private $request_headers = [];\n    private $request_body;\n    private $response;\n    private $response_headers = [];\n    private $response_body;\n    private $response_code;\n    private $response_info;\n    private $curl_handle;\n    private $method = 'GET';\n    private $proxy = null;\n    private $username = null;\n    private $password = null;\n    private $curlopts = null;\n    private $debug_mode = false;\n    private $request_class = 'BcsRequestcore';\n    private $response_class = 'BcsRequestcore';\n    private $useragent = 'BcsRequestcore/1.0';\n    private $read_file = null;\n    private $read_stream = null;\n    private $read_stream_size = null;\n    private $read_stream_read = 0;\n    private $write_file = null;\n    private $write_stream = null;\n    private $seek_position = null;\n    private $registered_streaming_read_callback = null;\n    private $registered_streaming_write_callback = null;\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (isset($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n    public function __destruct() {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        if (is_resource($this->curl_handle)) {\n            curl_close($this->curl_handle);\n        }\n    }\n\n    public function setCredentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function setMethod($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null) {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadFile($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function setWriteStream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function setProxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    private function prepRequest() {\n        $this->curl_handle = curl_init();\n        curl_setopt($this->curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        if ($this->username && $this->password) {\n            curl_setopt($this->curl_handle, CURLOPT_USERPWD, \"{$this->username}:{$this->password}\");\n        }\n        if ($this->proxy) {\n            curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($this->curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, \"{$this->proxy['user']}:{$this->proxy['pass']}\");\n            }\n        }\n        if ($this->request_headers) {\n            $headers = [];\n            foreach ($this->request_headers as $key => $value) {\n                $headers[] = \"{$key}: {$value}\";\n            }\n            curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n        switch ($this->method) {\n            case 'POST':\n                curl_setopt($this->curl_handle, CURLOPT_POST, true);\n                curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($this->curl_handle, CURLOPT_PUT, true);\n                if ($this->read_stream) {\n                    curl_setopt($this->curl_handle, CURLOPT_INFILE, $this->read_stream);\n                    curl_setopt($this->curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                }\n                break;\n            case 'DELETE':\n                curl_setopt($this->curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($this->curl_handle, CURLOPT_NOBODY, true);\n                break;\n        }\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $key => $value) {\n                curl_setopt($this->curl_handle, $key, $value);\n            }\n        }\n        return $this->curl_handle;\n    }\n\n    public function sendRequest($parse = false) {\n        $this->prepRequest();\n        $this->response = curl_exec($this->curl_handle);\n        $this->response_info = curl_getinfo($this->curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n        if ($parse) {\n            $this->processResponse($this->curl_handle, $this->response);\n        }\n        return $this->response;\n    }\n\n    private function processResponse($curl_handle, $response) {\n        $header_size = curl_getinfo($curl_handle, CURLINFO_HEADER_SIZE);\n        $this->response_headers = $this->parseHeaders(substr($response, 0, $header_size));\n        $this->response_body = substr($response, $header_size);\n        return $this->response;\n    }\n\n    private function parseHeaders($headers) {\n        $parsed = [];\n        foreach (explode(\"\\n\", $headers) as $line) {\n            if (strpos($line, ':') !== false) {\n                list($key, $value) = explode(':', $line, 2);\n                $parsed[trim($key)] = trim($value);\n            }\n        }\n        return $parsed;\n    }\n\n    public function isBaeEnv() {\n        return function_exists('get_instance') && get_instance() instanceof BaeInstance;\n    }\n\n    public function getResponseHeader($header = null) {\n        if ($header) {\n            return isset($this->response_headers[$header]) ? $this->response_headers[$header] : null;\n        }\n        return $this->response_headers;\n    }\n\n    public function getResponseBody() {\n        return $this->response_body;\n    }\n\n    public function getResponseCode() {\n        return $this->response_code;\n    }\n}\n```"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a PHP class that utilizes the Guzzle HTTP client to synchronize video processing tasks with a remote API endpoint, handling request signing and response parsing.\n\nClass Description: The SyncVideo class provides functionality to send video processing requests to a remote API endpoint using HTTP POST requests. It handles request signing, timeout configuration, and response parsing.\n\nAttributes:\n- config: [Upyun\\Config] - Configuration object containing service credentials, timeout settings, and endpoint information\n\nMethods:\n- __construct(Config $config) -> [void] - Initializes the class with the provided configuration object\n- process(array $params, string $path) -> [array] - Sends a synchronized video processing request to the specified path with the given parameters, returns the parsed JSON response",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse Upyun\\Config;\nuse Upyun\\Signature;\n\nclass SyncVideo {\n    protected $config;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n    }\n\n    public function process($params, $path) {\n        $client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n\n        $path = '/' . $this->config->serviceName . $path;\n        $method = 'POST';\n        $signedHeaders = Signature::getHeaderSign($this->config, $method, $path);\n\n        $url = $this->config->getSyncVideoEndPoint() . $path;\n        $response = $client->request($method, $url, [\n            'headers' => $signedHeaders,\n            'json' => $params\n        ]);\n\n        $body = $response->getBody()->getContents();\n        return json_decode($body, true);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nnamespace Upyun;\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass SyncVideo\n{\n    private $config;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $client = new Client([\n            'base_uri' => $this->config->getEndpoint(),\n            'timeout' => $this->config->getTimeout(),\n        ]);\n\n        $headers = [\n            'Authorization' => $this->config->getAuthorizationHeader(),\n            'Content-Type' => 'application/json',\n        ];\n\n        try {\n            $response = $client->post($path, [\n                'json' => $params,\n                'headers' => $headers,\n            ]);\n\n            $data = json_decode($response->getBody(), true);\n            return $data;\n        } catch (GuzzleException $e) {\n            return ['error' => $e->getMessage()];\n        }\n    }\n}\n\n?>\n```"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a PHP class for making HTTP requests using cURL with support for various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: The `baiduRequestCore` class provides a comprehensive wrapper around PHP's cURL functions to simplify HTTP requests. It supports GET, POST, PUT, DELETE, and HEAD methods, handles authentication, manages request/response headers and bodies, and includes streaming capabilities for both uploads and downloads.\n\nAttributes:\n\nrequest_url: [string] - The URL to send the request to\nrequest_headers: [array] - Associative array of request headers\nrequest_body: [string] - The request body content\nresponse: [string] - The complete response from the server\nresponse_headers: [array] - Associative array of response headers\nresponse_body: [string] - The response body content\nresponse_code: [int] - The HTTP response status code\nresponse_info: [array] - Additional cURL response information\ncurl_handle: [resource] - The cURL handle resource\nmethod: [string] - The HTTP method to use (GET, POST, etc.)\nproxy: [array|null] - Proxy configuration details\nusername: [string|null] - Username for authentication\npassword: [string|null] - Password for authentication\ncurlopts: [array|null] - Additional cURL options\ndebug_mode: [bool] - Whether to enable debug mode\nrequest_class: [string] - Class name for request handling\nresponse_class: [string] - Class name for response handling\nuseragent: [string] - User agent string\nread_file: [string|null] - File path for reading data\nread_stream: [resource|null] - Stream resource for reading data\nread_stream_size: [int|null] - Size of the read stream\nread_stream_read: [int] - Bytes read from the stream\nwrite_file: [string|null] - File path for writing data\nwrite_stream: [resource|null] - Stream resource for writing data\nseek_position: [int|null] - Position to seek in the read stream\nregistered_streaming_read_callback: [callable|null] - Callback for streaming reads\nregistered_streaming_write_callback: [callable|null] - Callback for streaming writes\n\nMethods:\n\n__construct: [function]([string|null $url, array|null $proxy, array|null $helpers]) -> [self] - Initializes the request object with optional URL, proxy, and helper classes\n__destruct: [function]() -> [self] - Cleans up any open file handles\nset_credentials: [function]([string $user, string $pass]) -> [self] - Sets authentication credentials\nadd_header: [function]([string $key, string $value]) -> [self] - Adds a request header\nremove_header: [function]([string $key]) -> [self] - Removes a request header\nset_method: [function]([string $method]) -> [self] - Sets the HTTP method\nset_useragent: [function]([string $ua]) -> [self] - Sets the user agent string\nset_body: [function]([string $body]) -> [self] - Sets the request body\nset_request_url: [function]([string $url]) -> [self] - Sets the request URL\nset_curlopts: [function]([array $curlopts]) -> [self] - Sets additional cURL options\nset_read_stream_size: [function]([int $size]) -> [self] - Sets the read stream size\nset_read_stream: [function]([resource $resource, int|null $size]) -> [self] - Sets the read stream resource\nset_read_file: [function]([string $location]) -> [self] - Sets a file to read from\nset_write_stream: [function]([resource $resource]) -> [self] - Sets the write stream resource\nset_write_file: [function]([string $location]) -> [self] - Sets a file to write to\nset_proxy: [function]([string $proxy]) -> [self] - Configures proxy settings\nset_seek_position: [function]([int|null $position]) -> [self] - Sets the seek position for the read stream\nregister_streaming_read_callback: [function]([callable $callback]) -> [self] - Registers a streaming read callback\nregister_streaming_write_callback: [function]([callable $callback]) -> [self] - Registers a streaming write callback\nstreaming_read_callback: [function]([resource $curl_handle, resource $file_handle, int $length]) -> [string] - Callback for streaming reads\nstreaming_write_callback: [function]([resource $curl_handle, string $data]) -> [int] - Callback for streaming writes\nprep_request: [function]() -> [resource] - Prepares and returns a cURL handle with configured options\nprocess_response: [function]([resource|null $curl_handle, string|null $response]) -> [mixed] - Processes the cURL response\nsend_request: [function]([bool $parse]) -> [mixed] - Sends the request and returns the response\nget_response_header: [function]([string|null $header]) -> [mixed] - Gets a specific response header or all headers\nget_response_body: [function]() -> [string] - Gets the response body\nget_response_code: [function]() -> [int] - Gets the response status code",
    "Canonical_solution": "class baiduRequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'baiduRequestCore';\n    public $response_class = 'baiduResponseCore';\n    public $useragent = 'baiduRequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n        \n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (isset($this->write_file) && isset($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        return $this;\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size'] >= 0) {\n                $position = ftell($resource);\n                if ($position !== false && $position >= 0) {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->set_read_stream($read_file_handle);\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->set_write_stream($write_file_handle);\n    }\n\n    public function set_proxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = isset($position) ? (integer) $position : null;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n        if ($this->read_stream_read == 0 && isset($this->seek_position) && $this->seek_position !== ftell($this->read_stream)) {\n            if (fseek($this->read_stream, $this->seek_position) !== 0) {\n                throw new baiduRequestCore_Exception('The stream does not support seeking and is either not at the requested position or the position is unknown.');\n            }\n        }\n        $read = fread($this->read_stream, min($this->read_stream_size - $this->read_stream_read, $length));\n        $this->read_stream_read += strlen($read);\n        $out = $read === false ? '' : $read;\n        if ($this->registered_streaming_read_callback) {\n            call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $out);\n        }\n        return $out;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n        while ($written_total < $length) {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n            if ($written_last === false) {\n                return $written_total;\n            }\n            $written_total += $written_last;\n        }\n        if ($this->registered_streaming_write_callback) {\n            call_user_func($this->registered_streaming_write_callback, $curl_handle, $written_total);\n        }\n        return $written_total;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n        \n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n        \n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n        \n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n        \n        if (extension_loaded('zlib')) {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n        \n        if (isset($this->request_headers) && count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n        \n        switch ($this->method) {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new baiduRequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream)) {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n        \n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n        \n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n        \n        if (is_resource($this->curl_handle)) {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n            \n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n            \n            $header_assoc = array();\n            foreach ($this->response_headers as $header) {\n                $kv = explode(': ', $header);\n                $header_assoc[$kv[0]] = $kv[1];\n            }\n            \n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n            \n            if ($curl_handle && $response) {\n                return new $this->response_class($this->response_headers, $this->response_body, $this->response_code, $this->curl_handle);\n            }\n        }\n        \n        return false;\n    }\n\n    public function send_request($parse = false)\n    {\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n        \n        if ($this->response === false) {\n            throw new baiduRequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n        \n        $parsed_response = $this->process_response($curl_handle, $this->response);\n        curl_close($curl_handle);\n        \n        if ($parse) {\n            return $parsed_response;\n        }\n        \n        return $this->response;\n    }\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\nclass baiduRequestCore {\n    public $request_url;\n    public $request_headers = [];\n    public $request_body;\n    public $response;\n    public $response_headers = [];\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    private $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts;\n    public $debug_mode;\n    public $request_class;\n    public $response_class;\n    public $useragent;\n    public $read_file;\n    public $read_stream;\n    public $read_stream_size;\n    public $read_stream_read;\n    public $write_file;\n    public $write_stream;\n    public $seek_position;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if (is_array($helpers)) {\n            $this->request_class = $helpers['request_class'] ?? 'baiduRequestCore';\n            $this->response_class = $helpers['response_class'] ?? 'baiduResponseCore';\n        }\n    }\n\n    public function __destruct() {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        if (is_resource($this->curl_handle)) {\n            curl_close($this->curl_handle);\n        }\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        $data = fread($file_handle, $length);\n        $this->read_stream_read += strlen($data);\n        return $data;\n    }\n\n    public function streaming_write_callback($curl_handle, $data) {\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    private function prep_request() {\n        $this->curl_handle = curl_init();\n        curl_setopt($this->curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_HEADER, false);\n        if ($this->useragent) {\n            curl_setopt($this->curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        }\n        if ($this->username && $this->password) {\n            curl_setopt($this->curl_handle, CURLOPT_USERPWD, \"{$this->username}:{$this->password}\");\n        }\n        if ($this->proxy) {\n            curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($this->curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, \"{$this->proxy['user']}:{$this->proxy['pass']}\");\n            }\n        }\n        if ($this->request_headers) {\n            $headers = [];\n            foreach ($this->request_headers as $key => $value) {\n                $headers[] = \"$key: $value\";\n            }\n            curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n        switch ($this->method) {\n            case 'POST':\n                curl_setopt($this->curl_handle, CURLOPT_POST, true);\n                curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($this->curl_handle, CURLOPT_PUT, true);\n                if ($this->read_stream) {\n                    curl_setopt($this->curl_handle, CURLOPT_INFILE, $this->read_stream);\n                    curl_setopt($this->curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                }\n                break;\n            case 'DELETE':\n                curl_setopt($this->curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($this->curl_handle, CURLOPT_NOBODY, true);\n                break;\n            default:\n                curl_setopt($this->curl_handle, CURLOPT_HTTPGET, true);\n                break;\n        }\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $option => $value) {\n                curl_setopt($this->curl_handle, $option, $value);\n            }\n        }\n        if ($this->registered_streaming_read_callback) {\n            curl_setopt($this->curl_handle, CURLOPT_READFUNCTION, $this->registered_streaming_read_callback);\n        }\n        if ($this->registered_streaming_write_callback) {\n            curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, $this->registered_streaming_write_callback);\n        }\n        return $this->curl_handle;\n    }\n\n    private function process_response($curl_handle, $response) {\n        $this->response = $response;\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n        $header_size = $this->response_info['header_size'];\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        return $this->response;\n    }\n\n    public function send_request($parse = true) {\n        $curl_handle = $this->prep_request();\n        $response = curl_exec($curl_handle);\n        if ($parse) {\n            $response = $this->process_response($curl_handle, $response);\n        }\n        return $response;\n    }\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            $headers = explode(\"\\r\\n\", $this->response_headers);\n            foreach ($headers as $h) {\n                if (stripos($h, $header) !== false) {\n                    list($key, $value) = explode(':', $h, 2);\n                    return trim($value);\n                }\n            }\n            return null;\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n}\n```"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a PHP class that utilizes the Guzzle HTTP client to fetch content from a URL and load it into a DOM object.\n\nClass Description: The `Dom` class provides functionality to load HTML content from a URL using the Guzzle HTTP client. It allows for optional customization of the HTTP client and request objects, and handles the response to extract the content for DOM processing.\n\nMethods:\n\nMethod1: `loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null)` -> `Dom` - Loads HTML content from the specified URL using the provided or default Guzzle HTTP client and request objects. The content is then loaded into a DOM object. Throws various exceptions for error handling.\n\nInput Parameters:\n- `$url`: string - The URL from which to fetch the HTML content.\n- `$options`: ?Options - Optional configuration options for the DOM loading process.\n- `$client`: ?ClientInterface - Optional Guzzle HTTP client instance. If not provided, a default client is created.\n- `$request`: ?RequestInterface - Optional Guzzle HTTP request instance. If not provided, a default GET request is created.\n\nOutput:\n- Returns an instance of `Dom` with the loaded HTML content.",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7\\Request;\nuse Psr\\Http\\Client\\ClientExceptionInterface;\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\n\nclass Dom implements DomInterface\n{\n    /**\n     * Use a curl interface implementation to attempt to load\n     * the content from a url.\n     *\n     * @throws ChildNotFoundException\n     * @throws CircularException\n     * @throws Exceptions\\ContentLengthException\n     * @throws LogicalException\n     * @throws StrictException\n     * @throws ClientExceptionInterface\n     */\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        if ($client === null) {\n            $client = new Client();\n        }\n        if ($request === null) {\n            $request = new Request('GET', $url);\n        }\n\n        $response = $client->sendRequest($request);\n        $content = $response->getBody()->getContents();\n\n        return $this->loadStr($content, $options);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nnamespace MyNamespace;\n\nuse GuzzleHttp\\ClientInterface;\nuse GuzzleHttp\\RequestInterface;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse DOMDocument;\n\nclass Dom\n{\n    private $domDocument;\n\n    public function __construct()\n    {\n        $this->domDocument = new DOMDocument();\n    }\n\n    public function loadFromUrl(string $url, ?Options $options = null, ?ClientInterface $client = null, ?RequestInterface $request = null): Dom\n    {\n        if ($client === null) {\n            $client = new \\GuzzleHttp\\Client();\n        }\n\n        if ($request === null) {\n            $request = new \\GuzzleHttp\\Psr7\\Request('GET', $url);\n        }\n\n        try {\n            $response = $client->send($request);\n            $htmlContent = $response->getBody()->getContents();\n            @$this->domDocument->loadHTML($htmlContent, $options ? $options->getLibxmlOptions() : 0);\n        } catch (GuzzleException $e) {\n            throw new \\Exception('Failed to fetch content from URL: ' . $e->getMessage(), $e->getCode(), $e);\n        }\n\n        return $this;\n    }\n\n    public function getDomDocument(): DOMDocument\n    {\n        return $this->domDocument;\n    }\n}\n\nclass Options\n{\n    private $libxmlOptions;\n\n    public function __construct(int $libxmlOptions = 0)\n    {\n        $this->libxmlOptions = $libxmlOptions;\n    }\n\n    public function getLibxmlOptions(): int\n    {\n        return $this->libxmlOptions;\n    }\n}\n```"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a PHP class for handling HTTP requests using cURL with support for various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: BCS_RequestCore is a comprehensive HTTP client class that provides a flexible interface for making HTTP requests using PHP's cURL extension. It supports all major HTTP methods (GET, POST, PUT, DELETE, HEAD), handles authentication, proxy configuration, streaming uploads/downloads, and provides detailed response information.\n\nAttributes:\n\nrequest_url: [string] - The URL to send the request to\nrequest_headers: [array] - Associative array of request headers\nrequest_body: [string] - The request body content\nresponse: [string] - The complete response from the server\nresponse_headers: [array] - Parsed response headers\nresponse_body: [string] - The response body content\nresponse_code: [int] - HTTP response status code\nresponse_info: [array] - Additional response information from cURL\ncurl_handle: [resource] - The cURL handle resource\nmethod: [string] - HTTP method (GET, POST, PUT, DELETE, HEAD)\nproxy: [array|null] - Proxy configuration details\nusername: [string|null] - Username for authentication\npassword: [string|null] - Password for authentication\ncurlopts: [array|null] - Additional cURL options\ndebug_mode: [bool] - Whether to enable debug mode\nrequest_class: [string] - Class name for request handling\nresponse_class: [string] - Class name for response handling\nuseragent: [string] - User agent string\nread_file: [string|null] - File path for streaming upload\nread_stream: [resource|null] - Stream resource for reading\nread_stream_size: [int|null] - Size of the read stream\nread_stream_read: [int] - Bytes read from the stream\nwrite_file: [string|null] - File path for streaming download\nwrite_stream: [resource|null] - Stream resource for writing\nseek_position: [int|null] - Position to seek in the read stream\nregistered_streaming_read_callback: [callable|null] - Callback for streaming read\nregistered_streaming_write_callback: [callable|null] - Callback for streaming write\n\nMethods:\n\n__construct([string|null] $url, [array|null] $proxy, [array|null] $helpers) -> [self] - Initializes the request object with optional URL, proxy, and helper classes\n__destruct() -> [self] - Cleans up any open file handles\nset_credentials([string] $user, [string] $pass) -> [self] - Sets authentication credentials\nadd_header([string] $key, [string] $value) -> [self] - Adds a request header\nremove_header([string] $key) -> [self] - Removes a request header\nset_method([string] $method) -> [self] - Sets the HTTP method\nset_useragent([string] $ua) -> [self] - Sets the user agent string\nset_body([string] $body) -> [self] - Sets the request body\nset_request_url([string] $url) -> [self] - Sets the request URL\nset_curlopts([array] $curlopts) -> [self] - Sets additional cURL options\nset_read_stream_size([int] $size) -> [self] - Sets the read stream size\nset_read_stream([resource] $resource, [int|null] $size) -> [self] - Sets the read stream resource\nset_read_file([string] $location) -> [self] - Sets a file to read from\nset_write_stream([resource] $resource) -> [self] - Sets the write stream resource\nset_write_file([string] $location) -> [self] - Sets a file to write to\nset_proxy([string] $proxy) -> [self] - Configures proxy settings\nset_seek_position([int|null] $position) -> [self] - Sets the seek position for read stream\nregister_streaming_read_callback([callable] $callback) -> [self] - Registers a streaming read callback\nregister_streaming_write_callback([callable] $callback) -> [self] - Registers a streaming write callback\nstreaming_read_callback([resource] $curl_handle, [resource] $file_handle, [int] $length) -> [string] - Callback for reading from stream\nstreaming_write_callback([resource] $curl_handle, [string] $data) -> [int] - Callback for writing to stream\nprep_request() -> [resource] - Prepares and returns a cURL handle\nprocess_response([resource|null] $curl_handle, [string|null] $response) -> [mixed] - Processes the cURL response\nsend_request([bool] $parse) -> [mixed] - Sends the request and returns response\nisBaeEnv() -> [bool] - Checks if running in Baidu App Engine environment\nget_response_header([string|null] $header) -> [mixed] - Gets response header(s)\nget_response_body() -> [string] - Gets the response body\nget_response_code() -> [int] - Gets the response status code",
    "Canonical_solution": "namespace Think\\Upload\\Driver\\Bcs;\n\nclass BCS_RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BCS_RequestCore';\n    public $response_class = 'BCS_ResponseCore';\n    public $useragent = 'BCS_RequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (isset($this->write_file) && isset($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        return $this;\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size'] >= 0) {\n                $position = ftell($resource);\n                if ($position !== false && $position >= 0) {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->set_read_stream($read_file_handle);\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->set_write_stream($write_file_handle);\n    }\n\n    public function set_proxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = isset($position) ? (integer) $position : null;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        if ($this->read_stream_read == 0 && isset($this->seek_position) && $this->seek_position !== ftell($this->read_stream)) {\n            if (fseek($this->read_stream, $this->seek_position) !== 0) {\n                throw new BCS_RequestCore_Exception('The stream does not support seeking and is either not at the requested position or the position is unknown.');\n            }\n        }\n\n        $read = fread($this->read_stream, min($this->read_stream_size - $this->read_stream_read, $length));\n        $this->read_stream_read += strlen($read);\n        $out = $read === false ? '' : $read;\n\n        if ($this->registered_streaming_read_callback) {\n            call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $out);\n        }\n\n        return $out;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n\n        while ($written_total < $length) {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n            if ($written_last === false) {\n                return $written_total;\n            }\n            $written_total += $written_last;\n        }\n\n        if ($this->registered_streaming_write_callback) {\n            call_user_func($this->registered_streaming_write_callback, $curl_handle, $written_total);\n        }\n\n        return $written_total;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (extension_loaded('zlib')) {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n\n        if (isset($this->request_headers) && count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        switch ($this->method) {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new BCS_RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream)) {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle)) {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n\n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n\n            $header_assoc = array();\n            foreach ($this->response_headers as $header) {\n                $kv = explode(': ', $header);\n                $header_assoc[$kv[0]] = $kv[1];\n            }\n\n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n\n            if ($curl_handle && $response) {\n                $class = '\\Think\\Upload\\Driver\\Bcs\\\\' . $this->response_class;\n                return new $class($this->response_headers, $this->response_body, $this->response_code, $this->curl_handle);\n            }\n        }\n\n        return false;\n    }\n\n    public function send_request($parse = false)\n    {\n        if (false === $this->isBaeEnv()) {\n            set_time_limit(0);\n        }\n\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false ||\n            ($this->method === self::HTTP_GET &&\n             curl_errno($curl_handle) === CURLE_PARTIAL_FILE)) {\n            throw new BCS_RequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n        curl_close($curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n    private function isBaeEnv()\n    {\n        if (isset($_SERVER['HTTP_HOST'])) {\n            $host = $_SERVER['HTTP_HOST'];\n            $pos = strpos($host, '.');\n            if ($pos !== false) {\n                $substr = substr($host, $pos + 1);\n                if ($substr == 'duapp.com') {\n                    return true;\n                }\n            }\n        }\n        if (isset($_SERVER[\"HTTP_BAE_LOGID\"])) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\nclass BCS_RequestCore {\n    public $request_url;\n    public $request_headers = array();\n    public $request_body;\n    public $response;\n    public $response_headers = array();\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy;\n    public $username;\n    public $password;\n    public $curlopts;\n    public $debug_mode = false;\n    public $request_class;\n    public $response_class;\n    public $useragent = 'BCS_RequestCore/1.0';\n    public $read_file;\n    public $read_stream;\n    public $read_stream_size;\n    public $read_stream_read = 0;\n    public $write_file;\n    public $write_stream;\n    public $seek_position;\n    public $registered_streaming_read_callback;\n    public $registered_streaming_write_callback;\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->proxy = $proxy;\n        if ($helpers) {\n            $this->request_class = $helpers['request'];\n            $this->response_class = $helpers['response'];\n        }\n    }\n\n    public function __destruct() {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        if (is_resource($this->curl_handle)) {\n            curl_close($this->curl_handle);\n        }\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->registered_streaming_read_callback) {\n            return call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $length);\n        }\n        $data = fread($this->read_stream, $length);\n        $this->read_stream_read += strlen($data);\n        return $data;\n    }\n\n    public function streaming_write_callback($curl_handle, $data) {\n        if ($this->registered_streaming_write_callback) {\n            return call_user_func($this->registered_streaming_write_callback, $curl_handle, $data);\n        }\n        $length = fwrite($this->write_stream, $data);\n        return $length;\n    }\n\n    public function prep_request() {\n        $this->curl_handle = curl_init();\n        curl_setopt($this->curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        if ($this->username && $this->password) {\n            curl_setopt($this->curl_handle, CURLOPT_USERPWD, \"{$this->username}:{$this->password}\");\n        }\n        if ($this->proxy) {\n            curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy['host']);\n            if (isset($this->proxy['port'])) {\n                curl_setopt($this->curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n            }\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, \"{$this->proxy['user']}:{$this->proxy['pass']}\");\n            }\n        }\n        if ($this->request_headers) {\n            $headers = array();\n            foreach ($this->request_headers as $key => $value) {\n                $headers[] = \"{$key}: {$value}\";\n            }\n            curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $headers);\n        }\n        switch ($this->method) {\n            case 'POST':\n                curl_setopt($this->curl_handle, CURLOPT_POST, true);\n                curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case 'PUT':\n                curl_setopt($this->curl_handle, CURLOPT_PUT, true);\n                if ($this->read_stream) {\n                    curl_setopt($this->curl_handle, CURLOPT_INFILE, $this->read_stream);\n                    curl_setopt($this->curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                }\n                break;\n            case 'DELETE':\n                curl_setopt($this->curl_handle, CURLOPT_CUSTOMREQUEST, 'DELETE');\n                break;\n            case 'HEAD':\n                curl_setopt($this->curl_handle, CURLOPT_NOBODY, true);\n                break;\n            default:\n                curl_setopt($this->curl_handle, CURLOPT_HTTPGET, true);\n                break;\n        }\n        if ($this->curlopts) {\n            foreach ($this->curlopts as $option => $value) {\n                curl_setopt($this->curl_handle, $option, $value);\n            }\n        }\n        return $this->curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null) {\n        if ($curl_handle === null) {\n            $curl_handle = $this->curl_handle;\n        }\n        if ($response === null) {\n            $response = curl_exec($curl_handle);\n        }\n        $this->response = $response;\n        $this->response_info = curl_getinfo($curl_handle);\n        $this->response_code = $this->response_info['http_code'];\n        $header_size = $this->response_info['header_size'];\n        $this->response_headers = substr($response, 0, $header_size);\n        $this->response_body = substr($response, $header_size);\n        return $this->response;\n    }\n\n    public function send_request($parse = false) {\n        $curl_handle = $this->prep_request();\n        $response = curl_exec($curl_handle);\n        if ($parse) {\n            return $this->process_response($curl_handle, $response);\n        }\n        return $response;\n    }\n\n    public function isBaeEnv() {\n        return function_exists('baeFetchUrl');\n    }\n\n    public function get_response_header($header = null) {\n        if ($header) {\n            $headers = explode(\"\\r\\n\", $this->response_headers);\n            foreach ($headers as $h) {\n                if (stripos($h, $header) !== false) {\n                    list($key, $value) = explode(':', $h, 2);\n                    return trim($value);\n                }\n            }\n            return null;\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body() {\n        return $this->response_body;\n    }\n\n    public function get_response_code() {\n        return $this->response_code;\n    }\n}\n```"
  }
]