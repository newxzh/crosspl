[
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a Java HTTP client class that handles various types of HTTP requests, including multipart form data uploads, with support for proxy configuration and connection retries.\n\nClass Description: The HttpClient class provides functionality to make HTTP requests with configurable methods, headers, and request bodies. It supports both simple requests and multipart form data uploads, handles connection retries through a retry handler, and allows proxy configuration.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart requests (default \"--\")\n- boundary: String - Unique boundary string for multipart requests\n- handler: HttpConnectionRetryHandler - Handler for connection retry logic\n- proxyHost: String - Proxy host address\n- proxyPort: String - Proxy port number\n- me: HttpClient - Singleton instance reference\n\nMethods:\n- getInstance() -> HttpClient - Returns the singleton instance of HttpClient\n- connect(String method, Properties props) -> void - Establishes HTTP connection with given method and properties (throws HttpClientException)\n- doConnection(String method, Properties props) -> void - Internal method to create and configure HTTP connection (throws IOException)\n- downloadImage(String imgName) -> byte[] - Downloads an image by name and returns as byte array\n- connectForMultipart() -> void - Prepares connection for multipart form data upload (throws Exception)\n- addFormPart(String paramName, String value) -> void - Adds a form part to multipart request (throws Exception)\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file part to multipart request (throws Exception)\n- finishMultipart() -> void - Finalizes multipart request (throws Exception)\n- getResponse() -> String - Reads and returns server response (throws Exception)\n- writeParamData(String paramName, String value) -> void - Internal method to write form parameter data (throws Exception)\n- setUrl(String url) -> void - Sets the target URL\n- setProxy(String host, String port) -> void - Configures proxy settings",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n    \n    private HttpConnectionRetryHandler handler;\n    \n    private String proxyHost;\n    private String proxyPort;\n    \n    private static HttpClient me;\n    \n    public static HttpClient getInstance() {\n        if (me == null)\n            me = new HttpClient();\n        \n        return me;\n    }\n\n    private HttpClient() { }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        boolean status  = true;\n        int attemptNumber = 0;\n        while (status) {\n            try {\n                attemptNumber++;\n                doConnection(method, props);\n                status = false;\n            }\n            catch(Throwable t) {\n                if (handler != null) {\n                    status = handler.shouldRetry(t, attemptNumber);\n                    if (!status)\n                        throw new HttpClientException(t);\n                }\n                else {                    \n                    throw new HttpClientException(t);\n                }\n            }\n        }\n    }\n    \n    private void doConnection(String method, Properties props) throws IOException {\n        if (proxyPort != null && proxyHost != null) {\n            Proxy p = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) ( new URL(url)).openConnection(p);\n        }\n        else\n            con = (HttpURLConnection) ( new URL(url)).openConnection();\n        \n        con.setRequestMethod(method);\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setConnectTimeout(5 * 1000);\n        \n        if (props != null) {\n            Enumeration keys = props.keys();\n            while (keys.hasMoreElements()) {\n                String key = (String) keys.nextElement();\n                String val = props.getProperty(key);\n                con.setRequestProperty(key, val);\n            }\n        }\n        \n        con.connect();\n    }\n\n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connect(\"Post\", null);\n            con.getOutputStream().write((\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while (is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        Properties props = new Properties();\n        props.setProperty(\"Connection\", \"Keep-Alive\");\n        props.setProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n        connect(\"POST\", props);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\").getBytes());\n        os.write((\"Content-Transfer-Encoding: binary\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n\n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while (is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n    \n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.Properties;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter = \"--\";\n    private String boundary = \"===\" + System.currentTimeMillis() + \"===\";\n    private HttpConnectionRetryHandler handler;\n    private String proxyHost;\n    private int proxyPort;\n    private static HttpClient me;\n\n    private HttpClient() {\n        handler = new HttpConnectionRetryHandler();\n    }\n\n    public static HttpClient getInstance() {\n        if (me == null) {\n            me = new HttpClient();\n        }\n        return me;\n    }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        try {\n            doConnection(method, props);\n        } catch (IOException e) {\n            throw new HttpClientException(\"Connection failed: \" + e.getMessage(), e);\n        }\n    }\n\n    private void doConnection(String method, Properties props) throws IOException {\n        URL obj = new URL(url);\n        Proxy proxy = (proxyHost != null) ? new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort)) : Proxy.NO_PROXY;\n        con = (HttpURLConnection) obj.openConnection(proxy);\n        con.setRequestMethod(method);\n        con.setUseCaches(false);\n        con.setReadTimeout(10000);\n        con.setConnectTimeout(15000);\n\n        for (Object key : props.keySet()) {\n            con.setRequestProperty((String) key, props.getProperty((String) key));\n        }\n\n        con.setDoOutput(true);\n        os = con.getOutputStream();\n    }\n\n    public byte[] downloadImage(String imgName) throws IOException {\n        URL imageUrl = new URL(url + \"/\" + imgName);\n        HttpURLConnection connection = (HttpURLConnection) imageUrl.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n\n        ByteArrayOutputStream output = new ByteArrayOutputStream();\n        InputStream input = connection.getInputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n\n        while ((bytesRead = input.read(buffer)) != -1) {\n            output.write(buffer, 0, bytesRead);\n        }\n\n        input.close();\n        return output.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.setUseCaches(false);\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setChunkedStreamingMode(0);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\\r\\n\").getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n\n        reader.close();\n        return response.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\\r\\n\").getBytes());\n        os.write(value.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = Integer.parseInt(port);\n    }\n\n    public static class HttpConnectionRetryHandler {\n        public boolean shouldRetry(int retryCount, Exception exception) {\n            return retryCount < 3 && (exception instanceof IOException || exception instanceof SocketTimeoutException);\n        }\n    }\n\n    public static class HttpClientException extends Exception {\n        public HttpClientException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch and process JSON data from a given URL.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests and processing JSON responses. The main functionality is implemented through an AsyncTask subclass to avoid blocking the main thread during network operations.\n\nAttributes: \n(None - This is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, retrieves data, and processes the response.\n\nMethod2: onProgressUpdate(String... progress) -> void - A callback method that processes the received JSON data during the task's execution. It parses the JSON array and extracts individual JSON objects.\n\nMethod3: onPostExecute(String result2) -> void - A callback method that handles post-execution tasks after the background operation completes.\n\nMethod4: ConvertInputToStringNoChange(InputStream inputStream) -> String - A helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONArray json = new JSONArray(progress[0]);\n                for (int i = 0; i < json.length(); i++) {\n                    JSONObject user = json.getJSONObject(i);\n                    // Handle the parsed JSON data here\n                }\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {\n            // Handle post-execution tasks here\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTask extends AsyncTask<String, String, String> {\n\n        @Override\n        protected String doInBackground(String... params) {\n            HttpURLConnection connection = null;\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(params[0]);\n                connection = (HttpURLConnection) url.openConnection();\n                connection.connect();\n\n                InputStream stream = connection.getInputStream();\n                reader = new BufferedReader(new InputStreamReader(stream));\n                StringBuilder buffer = new StringBuilder();\n                String line;\n\n                while ((line = reader.readLine()) != null) {\n                    buffer.append(line).append(\"\\n\");\n                }\n\n                return buffer.toString();\n            } catch (Exception e) {\n                e.printStackTrace();\n                return null;\n            } finally {\n                if (connection != null) {\n                    connection.disconnect();\n                }\n                try {\n                    if (reader != null) {\n                        reader.close();\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            super.onProgressUpdate(progress);\n            try {\n                JSONArray jsonArray = new JSONArray(progress[0]);\n                for (int i = 0; i < jsonArray.length(); i++) {\n                    JSONObject object = jsonArray.getJSONObject(i);\n                    // Process each JSON object as needed\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            super.onPostExecute(result);\n            // Handle post-execution tasks here\n        }\n\n        public String ConvertInputToStringNoChange(InputStream inputStream) throws Exception {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                result.append(line);\n            }\n            reader.close();\n            return result.toString();\n        }\n    }\n}"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a utility class for handling various HTTP operations including GET, POST requests, file downloads, and form submissions.\n\nClass Description: WebUtils is a utility class that provides static methods for performing common HTTP operations. It handles connection management, request configuration, and response processing.\n\nMethods:\n\nMethod1: getBody(String reqURL) -> String - Performs a GET request to the specified URL and returns the response body as a string.\nMethod2: getJson(String reqURL) -> JsonNode - Performs a GET request to the specified URL and parses the JSON response into a JsonNode object.\nMethod3: downloadFile(String reqURL, String fileLocation) -> void - Downloads a file from the specified URL and saves it to the given file location.\nMethod4: post(String reqURL, String postContent) -> String - Performs a POST request with plain text content to the specified URL and returns the response body.\nMethod5: postForm(String reqURL, Map<String, String> fields) -> String - Performs a form submission (application/x-www-form-urlencoded) to the specified URL with the given form fields and returns the response body.\nMethod6: getLineStream(String reqURL) -> Stream<String> - Performs a GET request to the specified URL and returns the response as a stream of lines.\nMethod7: getUserAgent() -> String - Returns a formatted User-Agent string for HTTP requests.\nMethod8: connectionToString(HttpURLConnection con) -> String - Helper method that reads the response from an HttpURLConnection and converts it to a string.",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\npublic class WebUtils {\n\n    public static String getBody(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con);\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setConnectTimeout(10000);\n        con.setReadTimeout(10000);\n        return GeyserImpl.JSON_MAPPER.readTree(con.getInputStream());\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            InputStream in = con.getInputStream();\n            Files.copy(in, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to download and save file: \" + fileLocation + \" (\" + reqURL + \")\", e);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        OutputStream out = con.getOutputStream();\n        out.write(postContent.getBytes(StandardCharsets.UTF_8));\n        out.close();\n\n        return connectionToString(con);\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        con.getResponseCode();\n\n        InputStream inputStream = con.getErrorStream();\n        if (inputStream == null) {\n            inputStream = con.getInputStream();\n        }\n\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream))) {\n            String inputLine;\n\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n                content.append(\"\\n\");\n            }\n\n            con.disconnect();\n        }\n\n        return content.toString();\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        try (OutputStream out = con.getOutputStream()) {\n            for (Map.Entry<String, String> field : fields.entrySet()) {\n                out.write((field.getKey() + \"=\" + URLEncoder.encode(field.getValue(), StandardCharsets.UTF_8) + \"&\").getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con).lines();\n        } catch (Exception e) {\n            GeyserImpl.getInstance().getLogger().error(\"Error while trying to get a stream from \" + reqURL, e);\n            return Stream.empty();\n        }\n    }\n\n    public static String getUserAgent() {\n        return \"Geyser-\" + GeyserImpl.getInstance().getPlatformType().platformName() + \"/\" + GeyserImpl.VERSION;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.*;\nimport java.net.*;\nimport java.nio.file.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class WebUtils {\n\n    private static final String USER_AGENT = \"WebUtils/1.0 (Java)\";\n    private static final ObjectMapper objectMapper = new ObjectMapper();\n\n    public static String getBody(String reqURL) throws IOException {\n        HttpURLConnection con = createConnection(reqURL, \"GET\");\n        return connectionToString(con);\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        return objectMapper.readTree(getBody(reqURL));\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) throws IOException {\n        URL url = new URL(reqURL);\n        try (InputStream in = url.openStream()) {\n            Files.copy(in, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        HttpURLConnection con = createConnection(reqURL, \"POST\");\n        con.setDoOutput(true);\n        try (OutputStream os = con.getOutputStream()) {\n            byte[] input = postContent.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n        return connectionToString(con);\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        HttpURLConnection con = createConnection(reqURL, \"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setDoOutput(true);\n\n        StringBuilder formData = new StringBuilder();\n        for (Map.Entry<String, String> field : fields.entrySet()) {\n            if (formData.length() > 0) formData.append(\"&\");\n            formData.append(URLEncoder.encode(field.getKey(), \"UTF-8\"));\n            formData.append(\"=\");\n            formData.append(URLEncoder.encode(field.getValue(), \"UTF-8\"));\n        }\n\n        try (OutputStream os = con.getOutputStream()) {\n            byte[] input = formData.toString().getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) throws IOException {\n        URL url = new URL(reqURL);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        return reader.lines();\n    }\n\n    public static String getUserAgent() {\n        return USER_AGENT;\n    }\n\n    public static String connectionToString(HttpURLConnection con) throws IOException {\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line).append(\"\\n\");\n            }\n        }\n        return response.toString();\n    }\n\n    private static HttpURLConnection createConnection(String reqURL, String method) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(method);\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        return con;\n    }\n}"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable timeouts and headers.\n\nClass Description: The RealRequest class provides functionality to make HTTP GET and POST requests with configurable connection settings. It handles request creation, header management, response processing, and error handling.\n\nAttributes:\n- sRequestURL: String - Static field storing the last requested URL\n- httpConfig: HttpConfig - Configuration object for connection settings (timeouts, etc.)\n- TAG: String - Constant for logging purposes (value: \"SA.HttpRequest\")\n\nMethods:\n- getData(String requestURL, Map<String, String> headerMap) -> RealResponse - Performs a GET request to the specified URL with optional headers\n- postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) -> RealResponse - Performs a POST request with request body, content type, and optional headers\n- getHttpURLConnection(String requestURL, String requestMethod) -> HttpURLConnection - Creates and configures an HttpURLConnection instance\n- setHeader(HttpURLConnection conn, Map<String, String> headerMap) -> void - Applies headers to the connection\n- getRealResponse(HttpURLConnection conn) -> RealResponse - Processes the HTTP response into a standardized format\n- getExceptionResponse(Exception e) -> RealResponse - Creates an error response from an exception\n- setHttpConfig(HttpConfig httpConfig) -> RealRequest - Sets the HTTP configuration (builder pattern)",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.sensorsdata.analytics.android.sdk.SAConfigOptions;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport javax.net.ssl.HttpsURLConnection;\nimport static com.sensorsdata.analytics.android.sdk.util.Base64Coder.CHARSET_UTF8;\n\nclass RealRequest {\n    private static final String TAG = \"SA.HttpRequest\";\n    private static String sRequestURL;\n    private HttpConfig httpConfig = new HttpConfig();\n\n    RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        try {\n            SALog.i(TAG, String.format(\"url:%s,\\nmethod:GET\", requestURL));\n            sRequestURL = requestURL;\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        BufferedWriter writer = null;\n        try {\n            HttpURLConnection conn;\n            sRequestURL = requestURL;\n            SALog.i(TAG, String.format(\"url:%s\\nparams:%s\\nmethod:POST\", requestURL, body));\n            conn = getHttpURLConnection(requestURL, \"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            if (!TextUtils.isEmpty(bodyType)) {\n                conn.setRequestProperty(\"Content-Type\", bodyType);\n            }\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            if (!TextUtils.isEmpty(body)) {\n                writer = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream(), CHARSET_UTF8));\n                writer.write(body);\n                writer.flush();\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    SALog.printStackTrace(e);\n                }\n            }\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setUseCaches(false);\n        conn.setConnectTimeout(httpConfig.getConnectionTimeout());\n        conn.setReadTimeout(httpConfig.getReadTimeout());\n        if (requestMethod.equals(\"POST\")) {\n            conn.setDoOutput(true);\n        }\n        SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n        if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                && conn instanceof HttpsURLConnection) {\n            ((HttpsURLConnection) conn).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (String key : headerMap.keySet()) {\n                conn.setRequestProperty(key, headerMap.get(key));\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        RealResponse response = new RealResponse();\n        try {\n            response.code = conn.getResponseCode();\n            if (HttpUtils.needRedirects(response.code)) {\n                response.location = HttpUtils.getLocation(conn, sRequestURL);\n            }\n            response.contentLength = conn.getContentLength();\n            if (response.code < HttpURLConnection.HTTP_BAD_REQUEST) {\n                response.result = HttpUtils.getRetString(conn.getInputStream());\n            } else {\n                response.errorMsg = HttpUtils.getRetString(conn.getErrorStream());\n            }\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        RealResponse response = new RealResponse();\n        response.exception = e;\n        response.errorMsg = e.getMessage();\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        if(httpConfig == null) {\n            return this;\n        }\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport javax.net.ssl.*;\n\npublic class RealRequest {\n    private static String sRequestURL;\n    private HttpConfig httpConfig;\n    private final String TAG = \"SA.HttpRequest\";\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        this.httpConfig = httpConfig;\n        return this;\n    }\n\n    public RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        try {\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    public RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        try {\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"POST\");\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", bodyType);\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(body);\n            writer.flush();\n            writer.close();\n            os.close();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setConnectTimeout(httpConfig != null ? httpConfig.getConnectTimeout() : 15000);\n        conn.setReadTimeout(httpConfig != null ? httpConfig.getReadTimeout() : 15000);\n        conn.setInstanceFollowRedirects(false);\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        for (Map.Entry<String, String> entry : headerMap.entrySet()) {\n            conn.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) throws IOException {\n        int responseCode = conn.getResponseCode();\n        Map<String, String> headers = new HashMap<>();\n        for (Map.Entry<String, List<String>> entry : conn.getHeaderFields().entrySet()) {\n            if (entry.getKey() != null && !entry.getValue().isEmpty()) {\n                headers.put(entry.getKey(), entry.getValue().get(0));\n            }\n        }\n        InputStream inputStream;\n        if (responseCode >= 400) {\n            inputStream = conn.getErrorStream();\n        } else {\n            inputStream = conn.getInputStream();\n        }\n        StringBuilder response = new StringBuilder();\n        if (inputStream != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n        }\n        return new RealResponse(responseCode, headers, response.toString());\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        return new RealResponse(-1, Collections.emptyMap(), e.getMessage());\n    }\n\n    public static class HttpConfig {\n        private int connectTimeout = 15000;\n        private int readTimeout = 15000;\n\n        public int getConnectTimeout() {\n            return connectTimeout;\n        }\n\n        public int getReadTimeout() {\n            return readTimeout;\n        }\n\n        public static class Builder {\n            private HttpConfig httpConfig = new HttpConfig();\n\n            public Builder setConnectTimeout(int timeout) {\n                httpConfig.connectTimeout = timeout;\n                return this;\n            }\n\n            public Builder setReadTimeout(int timeout) {\n                httpConfig.readTimeout = timeout;\n                return this;\n            }\n\n            public HttpConfig build() {\n                return httpConfig;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a Java class that reads and processes OSM (OpenStreetMap) PBF (Protocolbuffer Binary Format) files using Java NIO's FileChannel for efficient file operations, with support for lazy reading of file blocks.\n\nClass Description: The OsmInputFile class provides functionality to read and process OSM PBF files. It supports both eager and lazy reading modes, where lazy reading defers the actual decoding of data blocks until needed. The class uses FileChannel for efficient file operations and includes methods for reading headers, blocks, and validating file contents.\n\nAttributes:\n- path: [Path] - The file path to the OSM PBF file to be processed\n- lazy: [boolean] - Flag indicating whether to use lazy reading mode for file blocks\n\nMethods:\n- readInt: [readInt]([FileChannel channel]) -> [int] - Reads a 4-byte integer from the specified FileChannel\n- readBytes: [readBytes]([FileChannel channel, int length]) -> [byte[]] - Reads a specified number of bytes from the current position in the FileChannel\n- readBytes: [readBytes]([FileChannel channel, long offset, int length]) -> [byte[]] - Reads a specified number of bytes from a specific offset in the FileChannel\n- readBlobHeader: [readBlobHeader]([FileChannel channel]) -> [BlobHeader] - Reads and parses a BlobHeader from the FileChannel\n- openChannel: [openChannel]() -> [FileChannel] - Opens and returns a FileChannel for reading the input file\n- LazyReader (inner class): [LazyReader]() -> [OsmBlockSource] - Implements lazy reading functionality for OSM blocks\n  - forEachBlock: [forEachBlock]([Consumer<Block> consumer]) -> [void] - Processes each block in the file using the provided consumer\n  - close: [close]() -> [void] - Closes the lazy reading channel\n  - LazyBlock (inner record): [LazyBlock]([long offset, int length, FileChannel channel]) -> [Block] - Represents a lazily-read block\n    - decodeElements: [decodeElements]() -> [Iterable<OsmElement>] - Decodes the block's elements when accessed",
    "Canonical_solution": "import com.onthegomap.planetiler.reader.FileFormatException;\nimport com.onthegomap.planetiler.util.ByteBufferUtil;\nimport crosby.binary.Fileformat.BlobHeader;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OsmInputFile {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(OsmInputFile.class);\n\n  private final Path path;\n  private final boolean lazy;\n\n  public OsmInputFile(Path path, boolean lazyReads) {\n    this.path = path;\n    lazy = lazyReads;\n  }\n\n  private static int readInt(FileChannel channel) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(4);\n    int read = channel.read(buf);\n    if (read != 4) {\n      throw new IOException(\"Tried to read 4 bytes but only got \" + read);\n    }\n    return buf.flip().getInt();\n  }\n\n  private static byte[] readBytes(FileChannel channel, int length) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(length);\n    int read = channel.read(buf);\n    if (read != length) {\n      throw new IOException(\"Tried to read \" + length + \" bytes but only got \" + read);\n    }\n    return buf.flip().array();\n  }\n\n  private static byte[] readBytes(FileChannel channel, long offset, int length) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(length);\n    int read = channel.read(buf, offset);\n    if (read != length) {\n      throw new IOException(\"Tried to read \" + length + \" bytes at \" + offset + \" but only got \" + read);\n    }\n    return buf.flip().array();\n  }\n\n  private static BlobHeader readBlobHeader(FileChannel channel) throws IOException {\n    int headerSize = readInt(channel);\n    if (headerSize > 64 * 1024) {\n      throw new IllegalArgumentException(\"Header longer than 64 KiB\");\n    }\n    byte[] headerBytes = readBytes(channel, headerSize);\n    return BlobHeader.parseFrom(headerBytes);\n  }\n\n  private FileChannel openChannel() {\n    try {\n      return FileChannel.open(path, StandardOpenOption.READ);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  private class LazyReader implements OsmBlockSource {\n\n    final FileChannel lazyReadChannel = openChannel();\n\n    @Override\n    public void forEachBlock(Consumer<Block> consumer) {\n      try (FileChannel channel = openChannel()) {\n        final long size = channel.size();\n        while (channel.position() < size) {\n          BlobHeader header = readBlobHeader(channel);\n          int blockSize = header.getDatasize();\n          String headerType = header.getType();\n          long blockStartPosition = channel.position();\n          if (\"OSMData\".equals(headerType)) {\n            consumer.accept(new LazyBlock(blockStartPosition, blockSize, lazyReadChannel));\n          } else if (\"OSMHeader\".equals(headerType)) {\n            validateHeader(readBytes(channel, blockStartPosition, blockSize));\n          } else {\n            LOGGER.warn(\"Unrecognized OSM PBF blob header type: {}\", headerType);\n          }\n          channel.position(blockStartPosition + blockSize);\n        }\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n    }\n\n    @Override\n    public void close() {\n      try {\n        lazyReadChannel.close();\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n    }\n\n    private record LazyBlock(long offset, int length, FileChannel channel) implements Block {\n\n      public Iterable<OsmElement> decodeElements() {\n        try {\n          var buffer = channel.map(FileChannel.MapMode.READ_ONLY, offset, length);\n          var result = PbfDecoder.decode(buffer);\n          ByteBufferUtil.free(buffer);\n          return result;\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.*;\nimport java.util.*;\nimport java.util.function.Consumer;\n\npublic class OsmInputFile {\n    private final Path path;\n    private final boolean lazy;\n\n    public OsmInputFile(Path path, boolean lazy) {\n        this.path = path;\n        this.lazy = lazy;\n    }\n\n    public int readInt(FileChannel channel) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(4);\n        channel.read(buffer);\n        buffer.flip();\n        return buffer.getInt();\n    }\n\n    public byte[] readBytes(FileChannel channel, int length) throws IOException {\n        return readBytes(channel, channel.position(), length);\n    }\n\n    public byte[] readBytes(FileChannel channel, long offset, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        channel.read(buffer, offset);\n        return buffer.array();\n    }\n\n    public BlobHeader readBlobHeader(FileChannel channel) throws IOException {\n        int headerSize = readInt(channel);\n        byte[] headerData = readBytes(channel, headerSize);\n        // Simulated parsing logic for BlobHeader\n        return new BlobHeader(\"OSMData\", headerData.length);\n    }\n\n    public FileChannel openChannel() throws IOException {\n        return FileChannel.open(path, StandardOpenOption.READ);\n    }\n\n    public OsmBlockSource LazyReader() {\n        return new LazyReader();\n    }\n\n    public static record BlobHeader(String type, int dataSize) {}\n\n    public interface OsmBlockSource extends AutoCloseable {\n        void forEachBlock(Consumer<Block> consumer) throws IOException;\n    }\n\n    public class LazyReader implements OsmBlockSource {\n        private FileChannel channel;\n\n        public LazyReader() throws IOException {\n            this.channel = openChannel();\n        }\n\n        @Override\n        public void forEachBlock(Consumer<Block> consumer) throws IOException {\n            while (channel.position() < channel.size()) {\n                BlobHeader header = readBlobHeader(channel);\n                long offset = channel.position();\n                int length = header.dataSize;\n                Block block = new LazyBlock(offset, length, channel);\n                consumer.accept(block);\n                channel.position(offset + length);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (channel != null && channel.isOpen()) {\n                channel.close();\n            }\n        }\n\n        public record LazyBlock(long offset, int length, FileChannel channel) implements Block {\n            @Override\n            public Iterable<OsmElement> decodeElements() {\n                try {\n                    byte[] data = readBytes(channel, offset, length);\n                    // Simulate decoding into elements\n                    List<OsmElement> elements = new ArrayList<>();\n                    // Dummy element creation for demonstration\n                    elements.add(new OsmElement(\"node\", 1234));\n                    return elements;\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n        }\n    }\n\n    public interface Block {\n        Iterable<OsmElement> decodeElements();\n    }\n\n    public static class OsmElement {\n        private final String type;\n        private final long id;\n\n        public OsmElement(String type, long id) {\n            this.type = type;\n            this.id = id;\n        }\n\n        @Override\n        public String toString() {\n            return type + \" id=\" + id;\n        }\n    }\n\n    public static class UncheckedIOException extends RuntimeException {\n        public UncheckedIOException(IOException cause) {\n            super(cause);\n        }\n    }\n}"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a Java utility class for making HTTPS requests using HttpURLConnection with custom SSL socket factory configuration.\n\nClass Description: HttpClientUtil is a utility class that provides methods for making HTTPS requests with custom SSL/TLS configuration. It handles both GET and POST methods, manages connection settings, and includes proper error handling and resource cleanup.\n\nAttributes: (None - this is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String method, String outputStr) -> HttpResponse - Makes an HTTPS request to the specified URL using the given HTTP method. Handles request body for POST methods and returns the server response.\n\nMethod2: httpsRequest2(String requestUrl, String method, String outputStr) -> HttpResponse - Alternative implementation that uses a different URL constructor with protocol handler, otherwise similar to httpsRequest.\n\nMethod3: createSSLSocketFactory() -> SSLSocketFactory - Private helper method that creates and configures an SSLSocketFactory with custom TrustManager for SSL/TLS connections. Throws IOException if SSL context creation fails.\n\nInput Parameters:\n- requestUrl: String - The HTTPS URL to connect to\n- method: String - HTTP method (GET/POST)\n- outputStr: String - Request body content (for POST requests)\n\nOutput:\n- Returns HttpResponse object containing the server response\n- Throws IOException for connection or SSL configuration errors",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\n\npublic class HttpClientUtil {\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(requestUrl);\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(null, requestUrl, new sun.net.www.protocol.https.Handler());\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            TrustManager[] tm = { new MyX509TrustManager() };\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n            sslContext.init(null, tm, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n            throw new IOException(\"\u5b9e\u4f8b\u5316SSLContext\u5931\u8d25\", e);\n        } catch (KeyManagementException e) {\n            throw new IOException(\"\u521d\u59cb\u5316SSLContext\u5931\u8d25\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.*;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.X509Certificate;\n\npublic class HttpClientUtil {\n\n    public static class HttpResponse {\n        private final int responseCode;\n        private final String responseMessage;\n        private final String content;\n\n        public HttpResponse(int responseCode, String responseMessage, String content) {\n            this.responseCode = responseCode;\n            this.responseMessage = responseMessage;\n            this.content = content;\n        }\n\n        public int getResponseCode() { return responseCode; }\n        public String getResponseMessage() { return responseMessage; }\n        public String getContent() { return content; }\n    }\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        SSLSocketFactory sslSocketFactory = createSSLSocketFactory();\n        URL url = new URL(requestUrl);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        try {\n            configureConnection(connection, method, sslSocketFactory);\n            if (\"POST\".equalsIgnoreCase(method) && outputStr != null) {\n                try (OutputStream os = connection.getOutputStream()) {\n                    os.write(outputStr.getBytes(\"UTF-8\"));\n                    os.flush();\n                }\n            }\n            return getHttpResponse(connection);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        SSLSocketFactory sslSocketFactory = createSSLSocketFactory();\n        URL url = new URL(null, requestUrl, new sun.net.www.protocol.https.Handler());\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        try {\n            configureConnection(connection, method, sslSocketFactory);\n            if (\"POST\".equalsIgnoreCase(method) && outputStr != null) {\n                try (OutputStream os = connection.getOutputStream()) {\n                    os.write(outputStr.getBytes(\"UTF-8\"));\n                    os.flush();\n                }\n            }\n            return getHttpResponse(connection);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private static void configureConnection(HttpsURLConnection connection, String method, SSLSocketFactory sslSocketFactory) throws IOException {\n        connection.setSSLSocketFactory(sslSocketFactory);\n        connection.setRequestMethod(method);\n        connection.setDoInput(true);\n        connection.setDoOutput(\"POST\".equalsIgnoreCase(method));\n        connection.setConnectTimeout(10000);\n        connection.setReadTimeout(10000);\n        connection.setRequestProperty(\"Content-Type\", \"application/json;charset=UTF-8\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        connection.connect();\n    }\n\n    private static HttpResponse getHttpResponse(HttpsURLConnection connection) throws IOException {\n        int responseCode = connection.getResponseCode();\n        String responseMessage = connection.getResponseMessage();\n        StringBuilder content = new StringBuilder();\n        try (InputStream is = (responseCode >= 400) ? connection.getErrorStream() : connection.getInputStream()) {\n            if (is != null) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    content.append(line);\n                }\n                reader.close();\n            }\n        }\n        return new HttpResponse(responseCode, responseMessage, content.toString());\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() {\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, new TrustManager[]{new X509TrustManager() {\n                public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n                public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n                public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }\n            }}, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw new IOException(\"Failed to create SSL socket factory\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Java class that provides functionality for interacting with files using Java NIO's FileChannel and memory-mapped file operations. The class should support opening files, mapping files to memory, accessing mapped buffers, forcing writes to disk, and properly closing resources.\n\nClass Description: The FileChannelInteractor class encapsulates operations for file channel interaction and memory-mapped file operations using Java NIO. It provides methods to open files, map file regions to memory, access mapped buffers, ensure data persistence, and clean up resources.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedBuffer: MappedByteBuffer - The buffer representing the memory-mapped file region\n\nMethods:\nopenFileChannel: openFileChannel(String filePath) -> void - Opens a FileChannel for reading the specified file. Throws IOException if the file cannot be opened.\nmapFileToMemory: mapFileToMemory(long position, long size) -> void - Maps a region of the file into memory for read-only access. Throws IOException if mapping fails.\ngetMappedBuffer: getMappedBuffer() -> MappedByteBuffer - Returns the currently mapped byte buffer.\ncloseChannel: closeChannel() -> void - Closes the FileChannel and releases associated resources. Throws IOException if closing fails.\nforceWriteToDisk: forceWriteToDisk() -> void - Forces any changes made to the mapped buffer to be written to disk (though in this implementation the buffer is read-only).",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.MappedByteBuffer;\nimport java.nio.file.Path;\n\npublic class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        Path path = Paths.get(filePath);\n        this.fileChannel = FileChannel.open(path, StandardOpenOption.READ);\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        this.mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, size);\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return this.mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (this.fileChannel != null) {\n            this.fileChannel.close();\n        }\n    }\n\n    public void forceWriteToDisk() {\n        if (this.mappedBuffer != null) {\n            this.mappedBuffer.force();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        RandomAccessFile file = new RandomAccessFile(filePath, \"r\");\n        this.fileChannel = file.getChannel();\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        if (fileChannel != null && fileChannel.isOpen()) {\n            this.mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, size);\n        } else {\n            throw new IOException(\"FileChannel is not open.\");\n        }\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null && fileChannel.isOpen()) {\n            fileChannel.close();\n        }\n    }\n\n    public void forceWriteToDisk() {\n        if (mappedBuffer != null) {\n            // Even though buffer is read-only, this call has no effect but included for completeness\n            mappedBuffer.force();\n        }\n    }\n}"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Implement a Netty-based RPC client in Java that handles remote procedure calls, manages connections, and processes responses asynchronously.\n\nClass Description: NettyRpcClient is a final class that implements RpcRequestTransport interface. It provides functionality for establishing TCP connections using Netty framework, sending RPC requests, and managing client-side communication with a remote server. The class handles connection pooling, request tracking, and graceful shutdown.\n\nAttributes:\n- serviceDiscovery: [ServiceDiscovery] - Handles service lookup to find the appropriate server address\n- unprocessedRequests: [UnprocessedRequests] - Tracks outstanding RPC requests and their corresponding futures\n- channelProvider: [ChannelProvider] - Manages and provides channels for communication\n- bootstrap: [Bootstrap] - Netty's client bootstrap configuration\n- eventLoopGroup: [EventLoopGroup] - Manages client-side I/O threads\n\nMethods:\n- NettyRpcClient() -> [void] - Constructor that initializes the Netty client configuration, including event loop group, bootstrap, and pipeline handlers\n- doConnect(InetSocketAddress inetSocketAddress) -> [Channel] - Establishes a connection to the specified remote address and returns the channel\n- sendRpcRequest(RpcRequest rpcRequest) -> [Object] - Sends an RPC request to the server and returns a CompletableFuture containing the response\n- getChannel(InetSocketAddress inetSocketAddress) -> [Channel] - Retrieves or creates a channel for the specified address\n- close() -> [void] - Shuts down the client gracefully and releases resources",
    "Canonical_solution": "import github.javaguide.enums.CompressTypeEnum;\nimport github.javaguide.enums.SerializationTypeEnum;\nimport github.javaguide.enums.ServiceDiscoveryEnum;\nimport github.javaguide.extension.ExtensionLoader;\nimport github.javaguide.factory.SingletonFactory;\nimport github.javaguide.registry.ServiceDiscovery;\nimport github.javaguide.remoting.constants.RpcConstants;\nimport github.javaguide.remoting.dto.RpcMessage;\nimport github.javaguide.remoting.dto.RpcRequest;\nimport github.javaguide.remoting.dto.RpcResponse;\nimport github.javaguide.remoting.transport.RpcRequestTransport;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageDecoder;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageEncoder;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic final class NettyRpcClient implements RpcRequestTransport {\n    private final ServiceDiscovery serviceDiscovery;\n    private final UnprocessedRequests unprocessedRequests;\n    private final ChannelProvider channelProvider;\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup eventLoopGroup;\n\n    public NettyRpcClient() {\n        eventLoopGroup = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        p.addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS));\n                        p.addLast(new RpcMessageEncoder());\n                        p.addLast(new RpcMessageDecoder());\n                        p.addLast(new NettyRpcClientHandler());\n                    }\n                });\n        this.serviceDiscovery = ExtensionLoader.getExtensionLoader(ServiceDiscovery.class).getExtension(ServiceDiscoveryEnum.ZK.getName());\n        this.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);\n        this.channelProvider = SingletonFactory.getInstance(ChannelProvider.class);\n    }\n\n    public Channel doConnect(InetSocketAddress inetSocketAddress) {\n        CompletableFuture<Channel> completableFuture = new CompletableFuture<>();\n        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                completableFuture.complete(future.channel());\n            } else {\n                throw new IllegalStateException();\n            }\n        });\n        return completableFuture.get();\n    }\n\n    @Override\n    public Object sendRpcRequest(RpcRequest rpcRequest) {\n        CompletableFuture<RpcResponse<Object>> resultFuture = new CompletableFuture<>();\n        InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest);\n        Channel channel = getChannel(inetSocketAddress);\n        if (channel.isActive()) {\n            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);\n            RpcMessage rpcMessage = RpcMessage.builder().data(rpcRequest)\n                    .codec(SerializationTypeEnum.HESSIAN.getCode())\n                    .compress(CompressTypeEnum.GZIP.getCode())\n                    .messageType(RpcConstants.REQUEST_TYPE).build();\n            channel.writeAndFlush(rpcMessage).addListener((ChannelFutureListener) future -> {\n                if (future.isSuccess()) {\n                } else {\n                    future.channel().close();\n                    resultFuture.completeExceptionally(future.cause());\n                }\n            });\n        } else {\n            throw new IllegalStateException();\n        }\n        return resultFuture;\n    }\n\n    public Channel getChannel(InetSocketAddress inetSocketAddress) {\n        Channel channel = channelProvider.get(inetSocketAddress);\n        if (channel == null) {\n            channel = doConnect(inetSocketAddress);\n            channelProvider.set(inetSocketAddress, channel);\n        }\n        return channel;\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic final class NettyRpcClient implements RpcRequestTransport {\n\n    private final ServiceDiscovery serviceDiscovery;\n    private final UnprocessedRequests unprocessedRequests;\n    private final ChannelProvider channelProvider;\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup eventLoopGroup;\n\n    public NettyRpcClient(ServiceDiscovery serviceDiscovery, ChannelProvider channelProvider, Bootstrap bootstrap, EventLoopGroup eventLoopGroup, UnprocessedRequests unprocessedRequests) {\n        this.serviceDiscovery = serviceDiscovery;\n        this.channelProvider = channelProvider;\n        this.bootstrap = bootstrap;\n        this.eventLoopGroup = eventLoopGroup;\n        this.unprocessedRequests = unprocessedRequests;\n    }\n\n    private Channel doConnect(InetSocketAddress inetSocketAddress) {\n        try {\n            return bootstrap.connect(inetSocketAddress).sync().channel();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Failed to connect to \" + inetSocketAddress, e);\n        }\n    }\n\n    public Object sendRpcRequest(RpcRequest rpcRequest) {\n        InetSocketAddress address = serviceDiscovery.lookupService(rpcRequest.getServiceName());\n        Channel channel = getChannel(address);\n\n        CompletableFuture<Object> responseFuture = new CompletableFuture<>();\n        unprocessedRequests.addRequest(rpcRequest.getRequestId(), responseFuture);\n\n        channel.writeAndFlush(rpcRequest);\n\n        try {\n            return responseFuture.get();\n        } catch (InterruptedException | ExecutionException e) {\n            throw new RuntimeException(\"Error waiting for RPC response\", e);\n        }\n    }\n\n    private Channel getChannel(InetSocketAddress inetSocketAddress) {\n        Channel channel = channelProvider.getChannel(inetSocketAddress);\n        if (channel == null || !channel.isActive()) {\n            channel = doConnect(inetSocketAddress);\n            channelProvider.addChannel(inetSocketAddress, channel);\n        }\n        return channel;\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n        channelProvider.closeAllChannels();\n    }\n}"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for HTTP communication, supporting SSL/TLS encryption, chunked content transfer, and asynchronous request/response handling.\n\nClass Description: The NettyClient class establishes and manages TCP connections to a remote server using Netty's asynchronous I/O framework. It handles HTTP requests and responses, supports SSL/TLS encryption, and provides callback mechanisms for asynchronous processing.\n\nAttributes:\n- hostname: String - The target server hostname\n- port: int - The target server port\n- group: EventLoopGroup - Manages client-side I/O threads\n- b: Bootstrap - Configures Netty client behavior\n- responseParts: Queue<HttpObject> - Stores received HTTP response parts\n- callbackInvoked: AtomicBoolean - Tracks callback invocation status\n- communicationHandler: CommunicationHandler - Processes incoming HTTP messages\n- isOpen: AtomicBoolean - Tracks client connection state\n- request: HttpRequest - Current HTTP request being sent\n- content: ChunkedInput<HttpContent> - Optional request content\n- responseFuture: FutureResult<ResponseParts> - Future for response handling\n- callback: Callback<ResponseParts> - Callback for response handling\n- channelConnectFuture: ChannelFuture - Future for channel connection\n- exception: Exception - Stores any encountered exceptions\n- isKeepAlive: boolean - Tracks HTTP keep-alive status\n\nMethods:\n- NettyClient(String, int, SSLFactory) -> void - Constructor that initializes the client with hostname, port, and optional SSL factory\n- sendRequest(HttpRequest, ChunkedInput<HttpContent>, Callback<ResponseParts>) -> Future<ResponseParts> - Sends an HTTP request with optional content and registers a callback\n- close() -> void - Gracefully shuts down the client and releases resources\n- resetState() -> void - Resets internal state for new requests\n- createChannel() -> void - Creates a new channel connection to the server\n- invokeFutureAndCallback(String) -> void - Invokes the response future and callback with results\n- CommunicationHandler (inner class) - Handles incoming HTTP messages and exceptions\n\nInner Classes:\n- CommunicationHandler: SimpleChannelInboundHandler<HttpObject> - Processes HTTP responses and exceptions\n- ResponseParts: static class - Wrapper for HTTP response parts and completion context",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.commons.Callback;\nimport com.github.ambry.router.FutureResult;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.Closeable;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient implements Closeable {\n  private final String hostname;\n  private final int port;\n  private final EventLoopGroup group = new NioEventLoopGroup();\n  private final Bootstrap b = new Bootstrap();\n  private final Queue<HttpObject> responseParts = new LinkedList<HttpObject>();\n  private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n  private final CommunicationHandler communicationHandler = new CommunicationHandler();\n  private final AtomicBoolean isOpen = new AtomicBoolean(true);\n\n  private HttpRequest request;\n  private ChunkedInput<HttpContent> content;\n  private FutureResult<ResponseParts> responseFuture;\n  private Callback<ResponseParts> callback;\n  private volatile ChannelFuture channelConnectFuture;\n  private volatile Exception exception = null;\n  private volatile boolean isKeepAlive = false;\n\n  public NettyClient(final String hostname, final int port, final SSLFactory sslFactory) throws InterruptedException {\n    this.hostname = hostname;\n    this.port = port;\n    b.group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n      @Override\n      public void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (sslFactory != null) {\n          pipeline.addLast(\"sslHandler\",\n              new SslHandler(sslFactory.createSSLEngine(hostname, port, SSLFactory.Mode.CLIENT)));\n        }\n        pipeline.addLast(new HttpClientCodec()).addLast(new ChunkedWriteHandler()).addLast(communicationHandler);\n      }\n    });\n    createChannel();\n  }\n\n  public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content,\n      Callback<ResponseParts> callback) {\n    this.request = request;\n    this.content = content;\n    this.callback = callback;\n    resetState();\n    channelConnectFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) {\n        if (future.isSuccess()) {\n          future.channel().write(request).addListener(new GenericFutureListener<ChannelFuture>() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n              if (!future.isSuccess()) {\n                exception = (Exception) future.cause();\n                invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n              }\n            }\n          });\n          if (content != null) {\n            future.channel().write(content).addListener(new GenericFutureListener<ChannelFuture>() {\n              @Override\n              public void operationComplete(ChannelFuture future) {\n                if (!future.isSuccess()) {\n                  exception = (Exception) future.cause();\n                  invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n                }\n              }\n            });\n          }\n          future.channel().flush();\n        } else {\n          exception = (Exception) future.cause();\n          invokeFutureAndCallback(\"RequestSender::operationComplete\");\n        }\n      }\n    });\n    return responseFuture;\n  }\n\n  @Override\n  public void close() {\n    if (isOpen.compareAndSet(true, false) {\n      group.shutdownGracefully();\n    }\n  }\n\n  private void resetState() {\n    responseFuture = new FutureResult<>();\n    responseParts.clear();\n    exception = null;\n    callbackInvoked.set(false);\n  }\n\n  private void createChannel() throws InterruptedException {\n    channelConnectFuture = b.connect(hostname, port);\n    channelConnectFuture.channel().closeFuture().addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) throws InterruptedException {\n        if (isOpen.get()) {\n          createChannel();\n        }\n        invokeFutureAndCallback(\"ChannelCloseListener::operationComplete\");\n      }\n    });\n  }\n\n  private void invokeFutureAndCallback(String completionContext) {\n    if (callbackInvoked.compareAndSet(false, true)) {\n      responseFuture.done(new ResponseParts(responseParts, completionContext), exception);\n      if (callback != null) {\n        callback.onCompletion(new ResponseParts(responseParts, completionContext), exception);\n      }\n    }\n  }\n\n  @ChannelHandler.Sharable\n  private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject in) {\n      responseParts.offer(ReferenceCountUtil.retain(in));\n      if (in instanceof HttpResponse && in.decoderResult().isSuccess()) {\n        isKeepAlive = HttpUtil.isKeepAlive((HttpResponse) in);\n      } else if (in.decoderResult().isFailure()) {\n        Throwable cause = in.decoderResult().cause();\n        if (cause instanceof Exception) {\n          exception = (Exception) cause;\n        } else {\n          exception =\n              new Exception(\"Encountered Throwable when trying to decode response. Message: \" + cause.getMessage());\n        }\n        invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - decoder failure\");\n      }\n      if (in instanceof LastHttpContent) {\n        if (isKeepAlive) {\n          invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - last content\");\n        } else {\n          ctx.close();\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n      if (cause instanceof Exception) {\n        exception = (Exception) cause;\n        ctx.close();\n      } else {\n        ctx.fireExceptionCaught(cause);\n      }\n    }\n  }\n\n  public static class ResponseParts {\n    public final Queue<HttpObject> queue;\n    public final String completionContext;\n\n    private ResponseParts(Queue<HttpObject> queue, String completionContext) {\n      this.queue = queue;\n      this.completionContext = completionContext;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\nimport javax.net.ssl.SSLException;\nimport java.net.URI;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Consumer;\n\npublic class NettyClient {\n    private final String hostname;\n    private final int port;\n    private final EventLoopGroup group = new NioEventLoopGroup();\n    private final Bootstrap b = new Bootstrap();\n    private final Queue<HttpObject> responseParts = new ConcurrentLinkedQueue<>();\n    private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n    private CommunicationHandler communicationHandler;\n    private final AtomicBoolean isOpen = new AtomicBoolean(true);\n    private HttpRequest request;\n    private ChunkedInput<HttpContent> content;\n    private FutureResult<ResponseParts> responseFuture;\n    private Callback<ResponseParts> callback;\n    private ChannelFuture channelConnectFuture;\n    private Exception exception;\n    private boolean isKeepAlive;\n\n    public NettyClient(String hostname, int port, SSLFactory sslFactory) {\n        this.hostname = hostname;\n        this.port = port;\n        try {\n            SslContext sslCtx = null;\n            if (sslFactory != null) {\n                sslCtx = SslContextBuilder.forClient()\n                        .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                        .build();\n            }\n            communicationHandler = new CommunicationHandler();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc(), hostname, port));\n                     }\n                     p.addLast(new HttpClientCodec());\n                     p.addLast(new HttpObjectAggregator(1048576));\n                     p.addLast(new ChunkedWriteHandler());\n                     p.addLast(communicationHandler);\n                 }\n             });\n        } catch (SSLException e) {\n            throw new RuntimeException(\"Failed to initialize SSL context\", e);\n        }\n    }\n\n    public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content, Callback<ResponseParts> callback) {\n        this.request = request;\n        this.content = content;\n        this.callback = callback;\n        responseFuture = new FutureResult<>();\n        resetState();\n        createChannel();\n        return responseFuture;\n    }\n\n    public void close() {\n        isOpen.set(false);\n        group.shutdownGracefully();\n        if (channelConnectFuture != null) {\n            channelConnectFuture.channel().close();\n        }\n    }\n\n    private void resetState() {\n        responseParts.clear();\n        callbackInvoked.set(false);\n        exception = null;\n        isKeepAlive = false;\n    }\n\n    private void createChannel() {\n        channelConnectFuture = b.connect(hostname, port);\n        channelConnectFuture.addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                Channel channel = future.channel();\n                URI uri = new URI(request.uri());\n                FullHttpRequest nettyRequest = new DefaultFullHttpRequest(\n                        HttpVersion.HTTP_1_1,\n                        request.method(),\n                        uri.getRawPath(),\n                        Unpooled.EMPTY_BUFFER\n                );\n                nettyRequest.headers().set(HttpHeaderNames.HOST, hostname);\n                nettyRequest.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n                nettyRequest.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n\n                channel.writeAndFlush(nettyRequest);\n                if (content != null) {\n                    channel.writeAndFlush(new HttpContentChunkTransfer(content));\n                }\n            } else {\n                invokeFutureAndCallback(\"Connection failed\");\n            }\n        });\n    }\n\n    private void invokeFutureAndCallback(String result) {\n        ResponseParts response = new ResponseParts(responseParts, result, isKeepAlive);\n        if (callbackInvoked.compareAndSet(false, true)) {\n            if (exception != null) {\n                responseFuture.completeExceptionally(exception);\n                if (callback != null) {\n                    callback.onError(exception);\n                }\n            } else {\n                responseFuture.complete(response);\n                if (callback != null) {\n                    callback.onSuccess(response);\n                }\n            }\n        }\n    }\n\n    private class HttpContentChunkTransfer extends ChunkedWriteHandler {\n        private final ChunkedInput<HttpContent> input;\n\n        public HttpContentChunkTransfer(ChunkedInput<HttpContent> input) {\n            this.input = input;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            // Send the initial HTTP request with chunked transfer encoding\n            FullHttpRequest request = new DefaultFullHttpRequest(\n                    HttpVersion.HTTP_1_1, HttpMethod.POST, \"/\");\n            request.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n            ctx.writeAndFlush(request);\n        }\n\n        @Override\n        public void handlerRemoved(ChannelHandlerContext ctx) {\n            // Clean up\n        }\n    }\n\n    public static class ResponseParts {\n        private final Queue<HttpObject> parts;\n        private final String result;\n        private final boolean keepAlive;\n\n        public ResponseParts(Queue<HttpObject> parts, String result, boolean keepAlive) {\n            this.parts = parts;\n            this.result = result;\n            this.keepAlive = keepAlive;\n        }\n\n        public Queue<HttpObject> getParts() {\n            return parts;\n        }\n\n        public String getResult() {\n            return result;\n        }\n\n        public boolean isKeepAlive() {\n            return keepAlive;\n        }\n    }\n\n    public interface Callback<T> {\n        void onSuccess(T result);\n        void onError(Exception e);\n    }\n\n    public static class FutureResult<T> implements Future<T> {\n        private final AtomicReference<T> result = new AtomicReference<>();\n        private final AtomicReference<Exception> error = new AtomicReference<>();\n        private final Consumer<Runnable> notifyListeners = runnable -> {};\n\n        public void complete(T value) {\n            result.set(value);\n            notifyListeners.accept(() -> {});\n        }\n\n        public void completeExceptionally(Exception ex) {\n            error.set(ex);\n            notifyListeners.accept(() -> {});\n        }\n\n        @Override\n        public boolean cancel(boolean mayInterruptIfRunning) {\n            return false;\n        }\n\n        @Override\n        public boolean isCancelled() {\n            return false;\n        }\n\n        @Override\n        public boolean isDone() {\n            return result.get() != null || error.get() != null;\n        }\n\n        @Override\n        public T get() {\n            while (!isDone()) {\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(e);\n                }\n            }\n            if (error.get() != null) {\n                throw new RuntimeException(error.get());\n            }\n            return result.get();\n        }\n\n        @Override\n        public T get(long timeout, java.util.concurrent.TimeUnit unit) {\n            long endTime = System.currentTimeMillis() + unit.toMillis(timeout);\n            while (System.currentTimeMillis() < endTime && !isDone()) {\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(e);\n                }\n            }\n            if (!isDone()) {\n                throw new RuntimeException(\"Timeout waiting for result\");\n            }\n            if (error.get() != null) {\n                throw new RuntimeException(error.get());\n            }\n            return result.get();\n        }\n\n        @Override\n        public int hashCode() {\n            return super.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return super.equals(obj);\n        }\n\n        @Override\n        public String toString() {\n            return super.toString();\n        }\n\n        @Override\n        public void addListener(Runnable listener) {\n            notifyListeners.accept(listener);\n        }\n\n        @Override\n        public void await() {\n            while (!isDone()) {\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        @Override\n        public boolean await(long timeout, java.util.concurrent.TimeUnit unit) {\n            long endTime = System.currentTimeMillis() + unit.toMillis(timeout);\n            while (System.currentTimeMillis() < endTime && !isDone()) {\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(e);\n                }\n            }\n            return isDone();\n        }\n    }\n\n    public class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n            responseParts.add(msg);\n            if (msg instanceof LastHttpContent) {\n                LastHttpContent lastContent = (LastHttpContent) msg;\n                isKeepAlive = HttpHeaders.isKeepAlive(lastContent);\n                invokeFutureAndCallback(\"Response completed\");\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            exception = new Exception(cause);\n            invokeFutureAndCallback(\"Exception caught\");\n            ctx.close();\n        }\n    }\n\n    public static class SSLFactory {\n        // Placeholder for SSL configuration logic\n    }\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a Java class that implements a transactional log writer for Elasticsearch, handling file operations using Java NIO's FileChannel for efficient I/O operations. The class should manage writing operations, buffer management, and resource cleanup.\n\nClass Description: TranslogWriter is a transactional log writer that extends BaseTranslogReader and implements Closeable. It provides functionality to write operations to a log file using FileChannel, manage buffers, and handle synchronization. The class includes mechanisms for checkpointing, thread-safe operations, and resource management.\n\nAttributes:\n- channel: [FileChannel] - The main file channel for writing transaction log entries\n- checkpointChannel: [FileChannel] - File channel for writing checkpoint information\n- checkpointPath: [Path] - Path to the checkpoint file\n- bigArrays: [BigArrays] - Helper for managing large arrays\n- totalOffset: [long] - Current offset in the log file\n- closed: [AtomicBoolean] - Flag indicating whether the writer is closed\n- writeLock: [ReleasableLock] - Lock for thread-safe write operations\n- syncLock: [Object] - Synchronization lock object\n- buffer: [ReleasableBytesStreamOutput] - Buffer for holding data before writing\n- globalCheckpointSupplier: [LongSupplier] - Supplier for global checkpoint information\n- minTranslogGenerationSupplier: [LongSupplier] - Supplier for minimum translog generation\n- persistedSequenceNumberConsumer: [LongConsumer] - Consumer for persisted sequence numbers\n\nMethods:\n- TranslogWriter([ShardId, Checkpoint, FileChannel, FileChannel, Path, Path, ByteSizeValue, LongSupplier, LongSupplier, TranslogHeader, TragicExceptionHolder, LongConsumer, BigArrays]) -> [void] - Constructor that initializes the translog writer with all required components\n- writeAndReleaseOps([ReleasableBytesReference]) -> [void] - Writes the given bytes reference to the file and releases it\n- writeToFile([ByteBuffer]) -> [void] - Helper method that writes buffer contents to the file channel\n- readBytes([ByteBuffer, long]) -> [void] - Reads bytes from the specified position into the target buffer\n- writeCheckpoint([FileChannel, Path, Checkpoint]) -> [void] - Static helper method to write checkpoint information\n- close() -> [void] - Closes all resources and marks the writer as closed",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongSupplier;\n\nimport org.apache.lucene.store.AlreadyClosedException;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.BytesRefIterator;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.BytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.io.Channels;\nimport org.elasticsearch.common.io.DiskIoBufferPool;\nimport org.elasticsearch.common.lease.Releasables;\nimport org.elasticsearch.common.unit.ByteSizeValue;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.common.util.concurrent.ReleasableLock;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\nimport org.elasticsearch.index.shard.ShardId;\n\nimport io.crate.common.SuppressForbidden;\nimport io.crate.common.io.IOUtils;\n\npublic class TranslogWriter extends BaseTranslogReader implements Closeable {\n\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private volatile long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock = new ReleasableLock(new ReentrantLock());\n    private final Object syncLock = new Object();\n    private ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(\n        final ShardId shardId,\n        final Checkpoint initialCheckpoint,\n        final FileChannel channel,\n        final FileChannel checkpointChannel,\n        final Path path,\n        final Path checkpointPath,\n        final ByteSizeValue bufferSize,\n        final LongSupplier globalCheckpointSupplier,\n        LongSupplier minTranslogGenerationSupplier,\n        TranslogHeader header,\n        final TragicExceptionHolder tragedy,\n        final LongConsumer persistedSequenceNumberConsumer,\n        final BigArrays bigArrays) throws IOException {\n        super(initialCheckpoint.generation, channel, path, header);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.totalOffset = initialCheckpoint.offset;\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n    }\n\n    private void writeAndReleaseOps(ReleasableBytesReference toWrite) throws IOException {\n        try (ReleasableBytesReference toClose = toWrite) {\n            assert writeLock.isHeldByCurrentThread();\n            ByteBuffer ioBuffer = DiskIoBufferPool.getIoBuffer();\n\n            BytesRefIterator iterator = toWrite.iterator();\n            BytesRef current;\n            while ((current = iterator.next()) != null) {\n                int currentBytesConsumed = 0;\n                while (currentBytesConsumed != current.length) {\n                    int nBytesToWrite = Math.min(current.length - currentBytesConsumed, ioBuffer.remaining());\n                    ioBuffer.put(current.bytes, current.offset + currentBytesConsumed, nBytesToWrite);\n                    currentBytesConsumed += nBytesToWrite;\n                    if (ioBuffer.hasRemaining() == false) {\n                        ioBuffer.flip();\n                        writeToFile(ioBuffer);\n                        ioBuffer.clear();\n                    }\n                }\n            }\n            ioBuffer.flip();\n            writeToFile(ioBuffer);\n        }\n    }\n\n    @SuppressForbidden(reason = \"Channel#write\")\n    private void writeToFile(ByteBuffer ioBuffer) throws IOException {\n        while (ioBuffer.remaining() > 0) {\n            channel.write(ioBuffer);\n        }\n    }\n\n    @Override\n    protected void readBytes(ByteBuffer targetBuffer, long position) throws IOException {\n        try {\n            if (position + targetBuffer.remaining() > getWrittenOffset()) {\n                writeBufferedOps(position + targetBuffer.remaining(), true);\n            }\n        } catch (final Exception ex) {\n            closeWithTragicEvent(ex);\n            throw ex;\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, targetBuffer);\n    }\n\n    private static void writeCheckpoint(\n        final FileChannel fileChannel,\n        final Path checkpointFile,\n        final Checkpoint checkpoint) throws IOException {\n        Checkpoint.write(fileChannel, checkpointFile, checkpoint);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            synchronized (this) {\n                Releasables.closeIgnoringException(buffer);\n                buffer = null;\n            }\n            IOUtils.close(checkpointChannel, channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport org.elasticsearch.common.unit.ByteSizeValue;\nimport org.elasticsearch.index.shard.ShardId;\nimport org.elasticsearch.common.io.stream.ReleasableBytesStreamOutput;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.index.translog.TranslogHeader;\nimport org.elasticsearch.index.translog.Checkpoint;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongSupplier;\n\npublic class TranslogWriter extends BaseTranslogReader implements Closeable {\n\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock;\n    private final Object syncLock = new Object();\n    private final ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(ShardId shardId, Checkpoint checkpoint, FileChannel channel, FileChannel checkpointChannel,\n                          Path path, Path checkpointPath, ByteSizeValue bufferSize, LongSupplier globalCheckpointSupplier,\n                          LongSupplier minTranslogGenerationSupplier, TranslogHeader header, TragicExceptionHolder tragicExceptionHolder,\n                          LongConsumer persistedSequenceNumberConsumer, BigArrays bigArrays) {\n        super(shardId, checkpoint, path, header, tragicExceptionHolder);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.buffer = new ReleasableBytesStreamOutput(bigArrays);\n        this.totalOffset = checkpoint.offset;\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n        this.writeLock = new ReleasableLock();\n    }\n\n    public void writeAndReleaseOps(ReleasableBytesReference content) throws IOException {\n        try (ReleasableLock lock = writeLock.acquire()) {\n            buffer.writeBytes(content);\n            if (buffer.size() >= buffer.capacity()) {\n                writeToFile(buffer.buffer());\n            }\n        } finally {\n            content.release();\n        }\n    }\n\n    private void writeToFile(ByteBuffer buffer) throws IOException {\n        int written = channel.write(buffer);\n        totalOffset += written;\n    }\n\n    @Override\n    public void readBytes(ByteBuffer target, long position) throws IOException {\n        channel.read(target, position);\n    }\n\n    public static void writeCheckpoint(FileChannel channel, Path path, Checkpoint checkpoint) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(Checkpoint.FORMAT.length() + Checkpoint.VERSION_LENGTH + Checkpoint.BYTES.length);\n        buffer.putLong(checkpoint.generation);\n        buffer.putLong(checkpoint.offset);\n        buffer.putInt(checkpoint.version);\n        buffer.flip();\n        channel.write(buffer);\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            try {\n                if (buffer != null) {\n                    buffer.close();\n                }\n                if (channel != null && channel.isOpen()) {\n                    channel.force(true);\n                    channel.close();\n                }\n                if (checkpointChannel != null && checkpointChannel.isOpen()) {\n                    checkpointChannel.close();\n                }\n            } catch (IOException e) {\n                throw e;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Implement a Java class that processes large files efficiently using memory-mapped file operations (FileChannel and MappedByteBuffer) to calculate statistics (min, max, sum, count) for numeric values associated with named fields in the file.\n\nClass Description: FileChannelProcessor is a utility class that processes large files in chunks using memory-mapped buffers, calculating statistics for named numeric values in a thread-safe manner using concurrent data structures.\n\nAttributes:\n- mins: ConcurrentHashMap<ByteBuffer, Integer> - Stores minimum values for each named field\n- maxs: ConcurrentHashMap<ByteBuffer, Integer> - Stores maximum values for each named field\n- sums: ConcurrentHashMap<ByteBuffer, Integer> - Stores sum of values for each named field\n- counts: ConcurrentHashMap<ByteBuffer, Integer> - Stores count of values for each named field\n\nMethods:\n- processChunk(MappedByteBuffer chunk, long chunkSize) -> void - Processes a memory-mapped file chunk to calculate statistics for named numeric values\n  - Input Parameters:\n    - chunk: MappedByteBuffer - Memory-mapped buffer containing file data\n    - chunkSize: long - Size of the chunk to process\n- processFile(Path filePath) -> void - Processes the entire file by dividing it into chunks and calculating statistics\n  - Input Parameters:\n    - filePath: Path - Path to the file to be processed\n  - Throws: IOException - If there are file I/O errors",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.IntSummaryStatistics;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n\n    private static final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public static void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        chunk.load();\n        HashMap<ByteBuffer, IntSummaryStatistics> values = new HashMap<>();\n\n        long end = chunk.position() + chunkSize;\n        int value = 0;\n        byte b = 0;\n        boolean negate = false;\n        long nameStart = 0;\n        long nameEnd = 0;\n        int nameLength = 0;\n        while (chunk.position() < end) {\n            nameStart = chunk.position();\n            b = chunk.get();\n            while (b != ';') {\n                b = chunk.get();\n            }\n            nameEnd = chunk.position() - 1;\n            nameLength = (int) (nameEnd - nameStart);\n            ByteBuffer nameBuffer = ByteBuffer.allocate(nameLength);\n            chunk.get(chunk.position() - nameLength - 1, nameBuffer.array(), 0, nameLength);\n\n            value = 0;\n            b = chunk.get();\n            negate = false;\n            while (b != '\\n') {\n                if (b == '.') {\n                    b = chunk.get();\n                    continue;\n                }\n                else if (b == '-') {\n                    negate = true;\n                    b = chunk.get();\n                    continue;\n                }\n                value = value * 10 + (b - '0');\n                b = chunk.get();\n            }\n            if (negate) {\n                value = -value;\n            }\n\n            if (values.containsKey(nameBuffer)) {\n                values.get(nameBuffer).accept(value);\n            }\n            else {\n                IntSummaryStatistics stats = new IntSummaryStatistics();\n                stats.accept(value);\n                values.put(nameBuffer, stats);\n            }\n        }\n\n        for (ByteBuffer nameBfr : values.keySet()) {\n            IntSummaryStatistics stats = values.get(nameBfr);\n            mins.compute(nameBfr, (k, v) -> v == null ? stats.getMin() : Math.min(v, stats.getMin()));\n            maxs.compute(nameBfr, (k, v) -> v == null ? stats.getMax() : Math.max(v, stats.getMax()));\n            sums.compute(nameBfr, (k, v) -> v == null ? (int) stats.getSum() : (v + (int) stats.getSum()));\n            counts.compute(nameBfr, (k, v) -> v == null ? (int) stats.getCount() : (v + (int) stats.getCount()));\n        }\n    }\n\n    public static void processFile(Path filePath) throws IOException {\n        FileChannel fc = FileChannel.open(filePath);\n        long fileSize = fc.size();\n        int numProcessors = Runtime.getRuntime().availableProcessors();\n        int numChunks = numProcessors * 2000;\n        long chunkLimit = fileSize / numChunks;\n        long chunkStart = 0;\n        long chunkEnd = chunkLimit;\n        ByteBuffer bb = ByteBuffer.allocateDirect(128);\n\n        while (chunkEnd < fileSize) {\n            fc.position(chunkEnd);\n            bb.clear();\n            fc.read(bb);\n            bb.flip();\n            while (bb.get() != '\\n' && bb.position() < bb.limit()) {\n            }\n            chunkEnd = chunkEnd + bb.position();\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n\n            long chunkSize = chunkEnd - chunkStart;\n            if (chunkSize < 1) {\n                break;\n            }\n\n            MappedByteBuffer chunk = fc.map(FileChannel.MapMode.READ_ONLY, chunkStart, chunkSize);\n            processChunk(chunk, chunkSize);\n            chunkStart = chunkEnd;\n            chunkEnd = chunkEnd + chunkLimit;\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n        }\n        fc.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.nio.ByteBuffer;\n\npublic class FileChannelProcessor {\n    private ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        int position = chunk.position();\n        int limit = chunk.limit();\n        chunk.position(0);\n        chunk.limit((int) chunkSize);\n\n        while (chunk.hasRemaining()) {\n            byte b = chunk.get();\n            if (b == '=') {\n                int startPos = chunk.position() - 1;\n                while (startPos > 0 && chunk.get(startPos - 1) != '\\n') {\n                    startPos--;\n                }\n\n                ByteBuffer fieldName = ByteBuffer.allocate(chunk.position() - startPos);\n                for (int i = startPos; i < chunk.position() - 1; i++) {\n                    fieldName.put(chunk.get(i));\n                }\n                fieldName.flip();\n\n                int value = 0;\n                boolean negative = false;\n                b = chunk.get();\n                if (b == '-') {\n                    negative = true;\n                    b = chunk.get();\n                }\n                while (Character.isDigit(b)) {\n                    value = value * 10 + (b - '0');\n                    if (chunk.hasRemaining()) {\n                        b = chunk.get();\n                    } else {\n                        break;\n                    }\n                }\n                if (negative) value = -value;\n\n                mins.compute(fieldName, (k, v) -> v == null ? value : Math.min(v, value));\n                maxs.compute(fieldName, (k, v) -> v == null ? value : Math.max(v, value));\n                sums.compute(fieldName, (k, v) -> v == null ? value : v + value);\n                counts.compute(fieldName, (k, v) -> v == null ? 1 : v + 1);\n            }\n        }\n\n        chunk.position(position);\n        chunk.limit(limit);\n    }\n\n    public void processFile(Path filePath) throws IOException {\n        try (FileChannel fileChannel = FileChannel.open(filePath, StandardOpenOption.READ)) {\n            long fileSize = fileChannel.size();\n            long chunkSize = 1024 * 1024 * 128L;\n            long offset = 0;\n\n            while (offset < fileSize) {\n                long remaining = fileSize - offset;\n                MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, Math.min(chunkSize, remaining));\n                processChunk(buffer, remaining);\n                offset += chunkSize;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 192,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process protocol messages.\n\nClass Description: ProtocolServer is a Netty-based TCP server implementation that listens on a specified port, handles incoming connections, and processes protocol messages using custom channel handlers. It manages server resources including event loop groups and provides graceful shutdown capabilities.\n\nAttributes:\n- acceptorEventLoopGroup: [EventLoopGroup] - Handles accepting new connections (boss group)\n- networkEventLoopGroup: [EventLoopGroup] - Handles network I/O operations (worker group)\n- eventExecutorGroup: [EventExecutorGroup] - Executes business logic handlers\n- config: [Config] - Server configuration including port number\n- applicationContext: [ApplicationContext] - Spring application context for dependency injection\n\nMethods:\n- ProtocolServer([Config] config, [ApplicationContext] applicationContext) -> [void] - Constructor that initializes event loop groups with specified configurations\n- start() -> [ChannelFuture] - Starts the server, binds to the configured port, and returns a ChannelFuture that can be used to wait for server shutdown",
    "Canonical_solution": "import com.codingapi.txlcn.protocol.config.Config;\nimport com.codingapi.txlcn.protocol.handler.ProtocolChannelHandler;\nimport com.codingapi.txlcn.protocol.handler.ProtocolChannelInitializer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.util.concurrent.EventExecutorGroup;\nimport org.springframework.context.ApplicationContext;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtocolServer {\n\n    private final EventLoopGroup acceptorEventLoopGroup;\n    private final EventLoopGroup networkEventLoopGroup;\n    private final EventExecutorGroup eventExecutorGroup;\n    private final Config config;\n    private final ApplicationContext applicationContext;\n\n    public ProtocolServer(Config config, ApplicationContext applicationContext) {\n        this.config = config;\n        this.applicationContext = applicationContext;\n        this.acceptorEventLoopGroup = new NioEventLoopGroup(1);\n        this.networkEventLoopGroup = new NioEventLoopGroup(6);\n        this.eventExecutorGroup = new NioEventLoopGroup(10);\n    }\n\n    public ChannelFuture start() throws InterruptedException {\n        int portToBind = config.getPort();\n        ProtocolChannelHandler protocolChannelHandler = new ProtocolChannelHandler(new Protocoler(config), applicationContext, config);\n        ProtocolChannelInitializer protocolChannelInitializer = new ProtocolChannelInitializer(config, protocolChannelHandler, eventExecutorGroup);\n\n        final ServerBootstrap peerBootstrap = new ServerBootstrap();\n        peerBootstrap.group(acceptorEventLoopGroup, networkEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(protocolChannelInitializer);\n\n        final ChannelFuture bindFuture = peerBootstrap.bind(portToBind).sync();\n        if (bindFuture.isSuccess()) {\n            final Channel serverChannel = bindFuture.channel();\n            return serverChannel.closeFuture();\n        } else {\n            throw new RuntimeException(\"Server could not bind to \" + portToBind, bindFuture.cause());\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.springframework.context.ApplicationContext;\n\npublic class ProtocolServer {\n\n    private final EventLoopGroup acceptorEventLoopGroup;\n    private final EventLoopGroup networkEventLoopGroup;\n    private final EventExecutorGroup eventExecutorGroup;\n    private final Config config;\n    private final ApplicationContext applicationContext;\n\n    public ProtocolServer(Config config, ApplicationContext applicationContext) {\n        this.config = config;\n        this.applicationContext = applicationContext;\n        this.acceptorEventLoopGroup = new NioEventLoopGroup(config.getAcceptorThreads());\n        this.networkEventLoopGroup = new NioEventLoopGroup(config.getNetworkThreads());\n        this.eventExecutorGroup = new DefaultEventExecutorGroup(config.getBusinessThreads());\n    }\n\n    public ChannelFuture start() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(acceptorEventLoopGroup, networkEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childHandler(new ProtocolServerInitializer(applicationContext, eventExecutorGroup));\n\n        return bootstrap.bind(config.getPort());\n    }\n\n    // Graceful shutdown can be added here if needed\n}"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a Netty-based TCP server acceptor class that handles MQTT protocol communication, including server initialization, configuration, and graceful shutdown.\n\nClass Description: NettyAcceptor is a server acceptor implementation that uses Netty framework to create a TCP server for MQTT protocol communication. It manages server resources, handles incoming connections, and processes MQTT messages through configured handlers.\n\nAttributes:\n- m_bossGroup: [NioEventLoopGroup] - The parent event loop group that accepts incoming connections\n- m_workerGroup: [NioEventLoopGroup] - The child event loop group that handles the traffic of accepted connections\n- channelClass: [Class<? extends ServerSocketChannel>] - The channel class implementation (NIO in this case)\n- nettySoBacklog: [int] - Maximum queue length for incoming connection indications\n- nettySoReuseaddr: [boolean] - Whether to reuse local address and port\n- nettyTcpNodelay: [boolean] - Whether to enable TCP_NODELAY (disable Nagle's algorithm)\n- nettySoKeepalive: [boolean] - Whether to enable SO_KEEPALIVE\n- nettyChannelTimeoutSeconds: [int] - Channel idle timeout in seconds\n\nMethods:\n- initialize([ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator]) -> [void] - Initializes the acceptor with MQTT processor, configuration properties, and SSL context creator\n- initializePlainTCPTransport([NettyMQTTHandler handler, IConfig props]) -> [void] - Configures and starts the plain TCP transport with MQTT-specific handlers\n- close() -> [void] - Shuts down the acceptor gracefully, releasing all resources",
    "Canonical_solution": "import io.moquette.server.ServerAcceptor;\nimport io.moquette.server.config.IConfig;\nimport io.moquette.spi.impl.ProtocolProcessor;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.mqtt.MqttDecoder;\nimport io.netty.handler.codec.mqtt.MqttEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.Future;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyAcceptor implements ServerAcceptor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyAcceptor.class);\n\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass;\n    private int nettySoBacklog;\n    private boolean nettySoReuseaddr;\n    private boolean nettyTcpNodelay;\n    private boolean nettySoKeepalive;\n    private int nettyChannelTimeoutSeconds;\n\n    @Override\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) throws IOException {\n        LOG.info(\"Initializing Netty acceptor...\");\n\n        nettySoBacklog = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME, \"128\"));\n        nettySoReuseaddr = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME, \"true\"));\n        nettyTcpNodelay = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME, \"true\"));\n        nettySoKeepalive = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME, \"true\"));\n        nettyChannelTimeoutSeconds = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME, \"10\"));\n\n        LOG.info(\"Netty is using NIO\");\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        channelClass = NioServerSocketChannel.class;\n\n        final NettyMQTTHandler mqttHandler = new NettyMQTTHandler(processor);\n        initializePlainTCPTransport(mqttHandler, props);\n    }\n\n    private void initializePlainTCPTransport(final NettyMQTTHandler handler, IConfig props) throws IOException {\n        LOG.info(\"Configuring TCP MQTT transport\");\n        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME, \"0.0.0.0\");\n        String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n        if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n            LOG.info(\"TCP MQTT will be disabled\");\n            return;\n        }\n        int port = Integer.parseInt(tcpPortProp);\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(m_bossGroup, m_workerGroup)\n            .channel(channelClass)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                    pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n                    pipeline.addLast(\"decoder\", new MqttDecoder());\n                    pipeline.addLast(\"encoder\", MqttEncoder.INSTANCE);\n                    pipeline.addLast(\"handler\", handler);\n                }\n            })\n            .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n            .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n            .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n            .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n\n        try {\n            LOG.info(\"Binding server. host={}, port={}\", host, port);\n            ChannelFuture f = b.bind(host, port);\n            LOG.info(\"Server has been bound. host={}, port={}\", host, port);\n            f.sync();\n        } catch (InterruptedException ex) {\n            LOG.error(\"An interruptedException was caught while initializing server\", ex);\n        }\n    }\n\n    public void close() {\n        LOG.info(\"Closing Netty acceptor...\");\n        if (m_workerGroup == null || m_bossGroup == null) {\n            throw new IllegalStateException(\"Invoked close on an Acceptor that wasn't initialized\");\n        }\n        Future<?> workerWaiter = m_workerGroup.shutdownGracefully();\n        Future<?> bossWaiter = m_bossGroup.shutdownGracefully();\n\n        try {\n            workerWaiter.await(10, TimeUnit.SECONDS);\n            bossWaiter.await(10, TimeUnit.SECONDS);\n        } catch (InterruptedException iex) {\n            LOG.warn(\"An InterruptedException was caught while waiting for event loops to terminate...\");\n        }\n\n        if (!m_workerGroup.isTerminated()) {\n            m_workerGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n\n        if (!m_bossGroup.isTerminated()) {\n            m_bossGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.mqtt.MqttDecoder;\nimport io.netty.handler.codec.mqtt.MqttEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\n\npublic class NettyAcceptor {\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass = NioServerSocketChannel.class;\n    private int nettySoBacklog = 128;\n    private boolean nettySoReuseaddr = true;\n    private boolean nettyTcpNodelay = true;\n    private boolean nettySoKeepalive = false;\n    private int nettyChannelTimeoutSeconds = 60;\n\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) {\n        m_bossGroup = new NioEventLoopGroup();\n        m_workerGroup = new NioEventLoopGroup();\n\n        NettyMQTTHandler handler = new NettyMQTTHandler(processor);\n\n        if (sslCtxCreator != null && props.isSSLEnabled()) {\n            // SSL initialization would be here if needed\n        } else {\n            initializePlainTCPTransport(handler, props);\n        }\n    }\n\n    public void initializePlainTCPTransport(NettyMQTTHandler handler, IConfig props) {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(m_bossGroup, m_workerGroup)\n                .channel(channelClass)\n                .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n                .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n                .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n                .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n\n        bootstrap.childHandler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) throws Exception {\n                ChannelPipeline pipeline = ch.pipeline();\n                pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, nettyChannelTimeoutSeconds));\n                pipeline.addLast(\"mqttEncoder\", MqttEncoder.INSTANCE);\n                pipeline.addLast(\"mqttDecoder\", new MqttDecoder());\n                pipeline.addLast(\"mqttHandler\", handler);\n            }\n        });\n\n        try {\n            ChannelFuture future = bootstrap.bind(props.getPort()).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            // Handle exception\n        }\n    }\n\n    public void close() {\n        if (m_bossGroup != null) {\n            m_bossGroup.shutdownGracefully();\n        }\n        if (m_workerGroup != null) {\n            m_workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Implement a Java class that consumes messages from an ActiveMQ broker, supporting both queue and topic message consumption patterns. The class should handle connection management and provide clean resource cleanup.\n\nClass Description: JmsConsumer is a Java class that connects to an ActiveMQ message broker to consume messages from either a queue or a topic. It manages the entire JMS connection lifecycle including connection establishment, session creation, message consumption, and resource cleanup.\n\nAttributes:\n- USERNAME: [String] - Default username for ActiveMQ connection\n- PASSWORD: [String] - Default password for ActiveMQ connection\n- BROKEURL: [String] - Default broker URL for ActiveMQ connection\n- connectionFactory: [ConnectionFactory] - Factory for creating JMS connections\n- connection: [Connection] - Active connection to the message broker\n- session: [Session] - JMS session for message processing\n- destination: [Destination] - Target queue or topic for message consumption\n- messageConsumer: [MessageConsumer] - Consumer instance for receiving messages\n\nMethods:\n- consumeQueueMessages() -> [void] - Consumes messages from a specified queue (\"SAMPLE_MQ_QUEUE\") and prints them to console. Runs indefinitely until no messages are received for the timeout period.\n- consumeTopicMessages() -> [void] - Consumes messages from a specified topic (\"SAMPLE_MQ_TOPIC\") and prints them to console. Runs indefinitely until no messages are received for the timeout period.\n- closeConnection() -> [void] - Closes the JMS connection and releases all resources. Should be called when message consumption is complete.",
    "Canonical_solution": "import javax.jms.Connection;\nimport javax.jms.ConnectionFactory;\nimport javax.jms.Destination;\nimport javax.jms.JMSException;\nimport javax.jms.MessageConsumer;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport org.apache.activemq.ActiveMQConnection;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class JmsConsumer {\n\n    private static final String USERNAME = ActiveMQConnection.DEFAULT_USER;\n    private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;\n    private static final String BROKEURL = ActiveMQConnection.DEFAULT_BROKER_URL;\n\n    private ConnectionFactory connectionFactory;\n    private Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageConsumer messageConsumer;\n\n    public void consumeQueueMessages() throws JMSException {\n        connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKEURL);\n        connection = connectionFactory.createConnection();\n        connection.start();\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = session.createQueue(\"SAMPLE_MQ_QUEUE\");\n        messageConsumer = session.createConsumer(destination);\n        \n        while (true) {\n            TextMessage textMessage = (TextMessage) messageConsumer.receive(100000);\n            if (textMessage != null) {\n                System.out.println(\"QUEUE\\t\u6536\u5230\u7684\u6d88\u606f:\" + textMessage.getText());\n            } else {\n                break;\n            }\n        }\n    }\n\n    public void consumeTopicMessages() throws JMSException {\n        destination = session.createTopic(\"SAMPLE_MQ_TOPIC\");\n        messageConsumer = session.createConsumer(destination);\n        \n        while (true) {\n            TextMessage textMessage = (TextMessage) messageConsumer.receive(100000);\n            if (textMessage != null) {\n                System.out.println(\"TOPIC\\t\u6536\u5230\u7684\u6d88\u606f:\" + textMessage.getText());\n            } else {\n                break;\n            }\n        }\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            try {\n                connection.close();\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 39,
    "wrong_result": "import javax.jms.*;\n\npublic class JmsConsumer {\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"admin\";\n    private static final String BROKERURL = \"tcp://localhost:61616\";\n\n    private ConnectionFactory connectionFactory;\n    private Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageConsumer messageConsumer;\n\n    public JmsConsumer() throws JMSException {\n        connectionFactory = new org.apache.activemq.ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKERURL);\n        connection = connectionFactory.createConnection();\n        connection.start();\n    }\n\n    public void consumeQueueMessages() throws JMSException {\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = session.createQueue(\"SAMPLE_MQ_QUEUE\");\n        messageConsumer = session.createConsumer(destination);\n\n        while (true) {\n            Message message = messageConsumer.receive(5000);\n            if (message == null) break;\n            if (message instanceof TextMessage) {\n                try {\n                    System.out.println(\"Received from queue: \" + ((TextMessage) message).getText());\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void consumeTopicMessages() throws JMSException {\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = session.createTopic(\"SAMPLE_MQ_TOPIC\");\n        messageConsumer = session.createConsumer(destination);\n\n        while (true) {\n            Message message = messageConsumer.receive(5000);\n            if (message == null) break;\n            if (message instanceof TextMessage) {\n                try {\n                    System.out.println(\"Received from topic: \" + ((TextMessage) message).getText());\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void closeConnection() throws JMSException {\n        if (messageConsumer != null) messageConsumer.close();\n        if (session != null) session.close();\n        if (connection != null) connection.close();\n    }\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a class that provides anonymous memory allocation capabilities using memory-mapped files, with a fallback to direct byte buffers if memory-mapped files cannot be unlinked.\n\nClass Description: The `AnonAllocator` class is designed to allocate anonymous memory blocks that are not backed by visible files in the filesystem. It attempts to use memory-mapped files that are immediately unlinked (deleted) from the filesystem while remaining accessible through the mapping. If this technique is not supported by the system, it falls back to using direct byte buffers.\n\nAttributes:\n- MAP_AND_UNLINK_SUPPORTED: boolean - A static final flag indicating whether the system supports memory mapping with immediate file unlinking. This is determined during class initialization by testing the capability.\n\nMethods:\n- allocate(int size) -> ByteBuffer - Allocates an anonymous memory block of the specified size. If memory-mapped files with unlinking are supported, it creates a temporary file, maps it into memory, and immediately deletes the file. Otherwise, it falls back to a direct byte buffer allocation. The method returns the allocated ByteBuffer.\n  - Input: size (int) - The size of the memory block to allocate in bytes.\n  - Output: ByteBuffer - The allocated memory block, either as a memory-mapped buffer or a direct byte buffer.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n\n    static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        Path p = null;\n        boolean result = false;\n        try {\n            ByteBuffer mapped;\n            p = Files.createTempFile(\"unlink-test\", \".tmp\");\n            FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            chan.write(ByteBuffer.allocate(4*1024));\n            mapped = chan.map(MapMode.READ_WRITE, 0, 4*1024);\n            chan.close();\n            Files.delete(p);\n            result = mapped.get() == 0;\n        } catch (IOException e) {\n            if(p != null) {\n                Path toDelete = p;\n                Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                    try {\n                        Files.deleteIfExists(toDelete);\n                    } catch (IOException e1) {\n                        System.err.println(\"could not delete tempfile \"  + toDelete + \", most likely cause: garbage collector did not free the memory mapping keeping it open ; \" + e1.getMessage());\n                    }\n                }));\n            }\n        }\n        MAP_AND_UNLINK_SUPPORTED = result;\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if(MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                Path p = Files.createTempFile(\"anon-mapping\", \".tmp\");\n                ByteBuffer mapped;\n                FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n                chan.position(size);\n                chan.write(ByteBuffer.allocate(1));\n                mapped = chan.map(MapMode.READ_WRITE, 0, size);\n                chan.close();\n                Files.delete(p);\n                return mapped;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return ByteBuffer.allocateDirect(size);\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.File;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class AnonAllocator {\n    private static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        boolean supported = false;\n        try {\n            File tempFile = File.createTempFile(\"anon\", \".tmp\");\n            tempFile.deleteOnExit();\n            RandomAccessFile raf = new RandomAccessFile(tempFile, \"rw\");\n            FileChannel channel = raf.getChannel();\n            ByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 1);\n            channel.close();\n            raf.close();\n            if (tempFile.delete()) {\n                supported = true;\n            }\n        } catch (Throwable ignored) {\n        }\n        MAP_AND_UNLINK_SUPPORTED = supported;\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if (MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                File tempFile = File.createTempFile(\"anon\", \".tmp\");\n                RandomAccessFile raf = new RandomAccessFile(tempFile, \"rw\");\n                raf.setLength(size);\n                FileChannel channel = raf.getChannel();\n                ByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                channel.close();\n                raf.close();\n                tempFile.delete();\n                return buffer;\n            } catch (Exception e) {\n                return ByteBuffer.allocateDirect(size);\n            }\n        } else {\n            return ByteBuffer.allocateDirect(size);\n        }\n    }\n}"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Create a Java abstract class that handles file transfer operations using FileChannel for reading files and DataStreamOutput for writing data, with support for synchronization points during transfer.\n\nClass Description: TransferType is an abstract class that provides a framework for transferring file data in chunks using NIO FileChannel for reading and a DataStreamOutput for writing. It manages buffer sizes, synchronization points, and tracks transfer progress.\n\nAttributes:\n- path: String - The file path to be transferred\n- file: File - The File object representing the file to transfer\n- fileSize: long - The total size of the file in bytes\n- bufferSize: int - The size of the transfer buffer in bytes\n- syncSize: long - The interval size at which to perform synchronization\n- syncPosition: long - The current position for synchronization tracking\n\nMethods:\n- TransferType(String path, DataStream cli) - Constructor - Initializes the transfer with file path and configuration from DataStream client\n- getFile() -> File - Returns the File object being transferred\n- getBufferSize() -> int - Returns the buffer size for transfers\n- getPacketSize(long offset) -> long - Calculates the next packet size based on current offset\n- isSync(long position) -> boolean - Determines if current position requires synchronization\n- transfer(FileStoreClient client, RoutingTable routingTable) -> List<CompletableFuture<DataStreamReply>> - Performs the complete file transfer operation\n- write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) -> long - Abstract method to be implemented by subclasses for writing data\n- toString() -> String - Returns a string representation of the transfer object",
    "Canonical_solution": "import org.apache.ratis.examples.filestore.FileStoreClient;\nimport org.apache.ratis.io.StandardWriteOption;\nimport org.apache.ratis.protocol.DataStreamReply;\nimport org.apache.ratis.protocol.RoutingTable;\nimport org.apache.ratis.thirdparty.io.netty.buffer.ByteBuf;\nimport org.apache.ratis.thirdparty.io.netty.buffer.PooledByteBufAllocator;\nimport org.apache.ratis.util.FileUtils;\nimport org.apache.ratis.util.JavaUtils;\nimport org.apache.ratis.util.Preconditions;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nabstract static class TransferType {\n    private final String path;\n    private final File file;\n    private final long fileSize;\n    private final int bufferSize;\n    private final long syncSize;\n    private long syncPosition = 0;\n\n    TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = cli.getFileSizeInBytes();\n        this.bufferSize = cli.getBufferSizeInBytes();\n        this.syncSize = cli.getSyncSize();\n\n        final long actualSize = file.length();\n        Preconditions.assertTrue(actualSize == fileSize, () -> \"Unexpected file size: expected size is \"\n                + fileSize + \" but actual size is \" + actualSize + \", path=\" + path);\n    }\n\n    File getFile() {\n        return file;\n    }\n\n    int getBufferSize() {\n        return bufferSize;\n    }\n\n    long getPacketSize(long offset) {\n        return Math.min(bufferSize, fileSize - offset);\n    }\n\n    boolean isSync(long position) {\n        if (syncSize > 0) {\n            if (position >= fileSize || position - syncPosition >= syncSize) {\n                syncPosition = position;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    List<CompletableFuture<DataStreamReply>> transfer(\n            FileStoreClient client, RoutingTable routingTable) throws IOException {\n        if (fileSize <= 0) {\n            return Collections.emptyList();\n        }\n\n        final List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        final DataStreamOutput out = client.getStreamOutput(file.getName(), fileSize, routingTable);\n        try (FileChannel in = FileUtils.newFileChannel(file, StandardOpenOption.READ)) {\n            for (long offset = 0L; offset < fileSize; ) {\n                offset += write(in, out, offset, futures);\n            }\n        } catch (Throwable e) {\n            throw new IOException(\"Failed to transfer \" + path);\n        } finally {\n            futures.add(out.closeAsync());\n        }\n        return futures;\n    }\n\n    abstract long write(FileChannel in, DataStreamOutput out, long offset,\n                       List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    @Override\n    public String toString() {\n        return JavaUtils.getClassSimpleName(getClass()) + \"{\" + path + \", size=\" + fileSize + \"}\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic abstract class TransferType {\n    protected String path;\n    protected File file;\n    protected long fileSize;\n    protected int bufferSize;\n    protected long syncSize;\n    protected long syncPosition;\n\n    public TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = this.file.length();\n        this.bufferSize = cli.getBufferSize();\n        this.syncSize = cli.getSyncSize();\n        this.syncPosition = 0;\n    }\n\n    public File getFile() {\n        return file;\n    }\n\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    public long getPacketSize(long offset) {\n        long remaining = fileSize - offset;\n        return Math.min(remaining, bufferSize);\n    }\n\n    public boolean isSync(long position) {\n        if (position >= syncPosition + syncSize) {\n            syncPosition = position;\n            return true;\n        }\n        return false;\n    }\n\n    public abstract long write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    public List<CompletableFuture<DataStreamReply>> transfer(FileStoreClient client, RoutingTable routingTable) {\n        List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        try (FileChannel in = new RandomAccessFile(file, \"r\").getChannel()) {\n            long offset = 0;\n            while (offset < fileSize) {\n                long packetSize = getPacketSize(offset);\n                ByteBuffer buffer = ByteBuffer.allocate((int) packetSize);\n                in.read(buffer);\n                buffer.flip();\n\n                DataStreamOutput out = client.getOutputStream(routingTable.getNextNode());\n                long finalOffset = offset;\n                CompletableFuture<DataStreamReply> future = CompletableFuture.supplyAsync(() -> {\n                    try {\n                        write(in, out, finalOffset, futures);\n                        return new DataStreamReply(true, \"Transfer successful\");\n                    } catch (IOException e) {\n                        return new DataStreamReply(false, \"Transfer failed: \" + e.getMessage());\n                    }\n                });\n                futures.add(future);\n                offset += packetSize;\n                if (isSync(offset)) {\n                    sync();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return futures;\n    }\n\n    private void sync() {\n        // Implement synchronization logic if needed\n    }\n\n    @Override\n    public String toString() {\n        return \"TransferType{\" +\n                \"path='\" + path + '\\'' +\n                \", file=\" + file +\n                \", fileSize=\" + fileSize +\n                \", bufferSize=\" + bufferSize +\n                \", syncSize=\" + syncSize +\n                '}';\n    }\n}"
  },
  {
    "Task_id": 225,
    "Instruction": "Task Description: Implement a WebSocket proxy server using Java Netty framework to handle WebSocket connections and manage client-server communication.\n\nClass Description: WebsocketProxy is a class that implements a Proxy interface and provides functionality to start a WebSocket server on a specified port. It handles WebSocket protocol upgrades, HTTP requests, and manages client connections with proper resource cleanup.\n\nAttributes:\n- None (All variables are local to methods)\n\nMethods:\n- start(int port) -> void - Starts the WebSocket server on the specified port. Initializes event loop groups, configures server bootstrap with appropriate channel and handlers, binds to the port, and manages server lifecycle including graceful shutdown. Throws InterruptedException if the thread is interrupted during server operation.\n\nInput:\n- port: int - The port number on which the WebSocket server should listen for incoming connections\n\nOutput:\n- None (Void method, but it will start a server that listens on the specified port and handles WebSocket connections)\n\nNote: The implementation should include proper error handling, resource management, and support for both NIO and Epoll transport mechanisms based on system availability. The server should handle WebSocket protocol upgrades, HTTP codecs, chunked writes, and idle connection management.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.print.SimplePrinter;\nimport org.nico.ratel.landlords.robot.RobotDecisionMakers;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.TimeUnit;\n\npublic class WebsocketProxy implements Proxy {\n\n    @Override\n    public void start(int port) throws InterruptedException {\n        EventLoopGroup parentGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        EventLoopGroup childGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap()\n                    .group(parentGroup, childGroup)\n                    .channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(port))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                    .addLast(new IdleStateHandler(60 * 30, 0, 0, TimeUnit.SECONDS))\n                                    .addLast(new HttpServerCodec())\n                                    .addLast(new ChunkedWriteHandler())\n                                    .addLast(new HttpObjectAggregator(8192))\n                                    .addLast(\"ws\", new WebSocketServerProtocolHandler(\"/ratel\"))\n                                    .addLast(new WebsocketTransferHandler());\n                        }\n                    });\n\n            ChannelFuture f = bootstrap.bind().sync();\n\n            SimplePrinter.serverLog(\"The websocket server was successfully started on port \" + port);\n            RobotDecisionMakers.init();\n            f.channel().closeFuture().sync();\n        } finally {\n            parentGroup.shutdownGracefully();\n            childGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.ServerSocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class WebsocketProxy implements Proxy {\n\n    @Override\n    public void start(int port) throws InterruptedException {\n        boolean useEpoll = Epoll.isAvailable();\n        Class<? extends ServerSocketChannel> channelClass;\n        EventLoopGroup bossGroup;\n        EventLoopGroup workerGroup;\n\n        if (useEpoll) {\n            channelClass = EpollServerSocketChannel.class;\n            bossGroup = new EpollEventLoopGroup(1);\n            workerGroup = new EpollEventLoopGroup();\n        } else {\n            channelClass = NioServerSocketChannel.class;\n            bossGroup = new NioEventLoopGroup(1);\n            workerGroup = new NioEventLoopGroup();\n        }\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(channelClass)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<Channel>() {\n                        @Override\n                        protected void initChannel(Channel ch) {\n                            ch.pipeline().addLast(\n                                    new HttpServerCodec(),\n                                    new ChunkedWriteHandler(),\n                                    new HttpObjectAggregator(65536),\n                                    new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS),\n                                    new WebSocketServerProtocolHandler(\"/ws\"),\n                                    new SimpleChannelInboundHandler<Object>() {\n                                        @Override\n                                        protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n                                            // Handle incoming messages if needed\n                                        }\n\n                                        @Override\n                                        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                                            cause.printStackTrace();\n                                            ctx.close();\n                                        }\n                                    }\n                            );\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a utility class for retrieving Discord guild widget information using HTTP requests.\n\nClass Description: WidgetUtil is a utility class that provides functionality to fetch Discord guild widget data through REST API calls. It handles HTTP communication, response processing, and error handling for widget retrieval operations.\n\nAttributes:\nWIDGET_URL: [String] - The URL template for accessing Discord guild widget JSON data, using the default REST API base URL.\n\nMethods:\ngetWidget: [getWidget]([long guildId]) -> [Widget] - Retrieves the widget information for a specified Discord guild ID. Handles various HTTP response codes including success (200), not found (404), forbidden (403), and rate limiting (429). Throws RateLimitedException when rate limited and UncheckedIOException for IO errors. Returns null if the widget doesn't exist or is inaccessible.",
    "Canonical_solution": "import net.dv8tion.jda.api.entities.Widget;\nimport net.dv8tion.jda.api.exceptions.RateLimitedException;\nimport net.dv8tion.jda.api.requests.RestConfig;\nimport net.dv8tion.jda.api.utils.data.DataObject;\nimport net.dv8tion.jda.internal.entities.WidgetImpl;\nimport net.dv8tion.jda.internal.utils.Checks;\nimport net.dv8tion.jda.internal.utils.IOUtil;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\n\npublic class WidgetUtil \n{\n    public static final String WIDGET_URL = RestConfig.DEFAULT_BASE_URL + \"guilds/%s/widget.json\";\n\n    @Nullable\n    public static Widget getWidget(long guildId) throws RateLimitedException\n    {\n        Checks.notNull(guildId, \"GuildId\");\n\n        OkHttpClient client = new OkHttpClient.Builder().build();\n        Request request = new Request.Builder()\n                    .url(String.format(WIDGET_URL, guildId))\n                    .method(\"GET\", null)\n                    .header(\"user-agent\", RestConfig.USER_AGENT)\n                    .header(\"accept-encoding\", \"gzip\")\n                    .build();\n\n        try (Response response = client.newCall(request).execute())\n        {\n            final int code = response.code();\n            InputStream data = IOUtil.getBody(response);\n\n            switch (code)\n            {\n                case 200:\n                    try (InputStream stream = data)\n                    {\n                        return new WidgetImpl(DataObject.fromJson(stream));\n                    }\n                    catch (IOException e)\n                    {\n                        throw new UncheckedIOException(e);\n                    }\n                case 400:\n                case 404:\n                    return null;\n                case 403:\n                    return new WidgetImpl(guildId);\n                case 429:\n                    long retryAfter;\n                    try (InputStream stream = data)\n                    {\n                        retryAfter = DataObject.fromJson(stream).getLong(\"retry_after\");\n                    }\n                    catch (Exception e)\n                    {\n                        retryAfter = 0;\n                    }\n                    throw new RateLimitedException(WIDGET_URL, retryAfter);\n                default:\n                    throw new IllegalStateException(\"An unknown status was returned: \" + code + \" \" + response.message());\n            }\n        }\n        catch (IOException e)\n        {\n            throw new UncheckedIOException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpTimeoutException;\n\npublic class WidgetUtil {\n\n    private static final String WIDGET_URL = \"https://discord.com/api/guilds/%d/widget.json\";\n    private static final HttpClient httpClient = HttpClient.newBuilder().build();\n\n    public static Widget getWidget(long guildId) {\n        try {\n            URI uri = URI.create(String.format(WIDGET_URL, guildId));\n            HttpRequest request = HttpRequest.newBuilder(uri).GET().build();\n            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            int statusCode = response.statusCode();\n            if (statusCode == 200) {\n                // Deserialize JSON string to Widget object\n                return deserialize(response.body());\n            } else if (statusCode == 404 || statusCode == 403) {\n                return null;\n            } else if (statusCode == 429) {\n                throw new RateLimitedException(\"Rate limit exceeded while fetching widget.\");\n            } else {\n                throw new UncheckedIOException(new java.io.IOException(\"Unexpected HTTP status code: \" + statusCode));\n            }\n        } catch (HttpTimeoutException e) {\n            throw new UncheckedIOException(new java.io.IOException(\"HTTP request timed out.\", e));\n        } catch (Exception e) {\n            throw new UncheckedIOException(new java.io.IOException(\"Error fetching widget data.\", e));\n        }\n    }\n\n    private static Widget deserialize(String json) {\n        // Implement or use a library like Gson/Jackson for deserialization\n        // Placeholder implementation\n        return new Widget(); // Replace with actual parsing logic\n    }\n\n    public static class Widget {\n        // Define fields as per Discord's widget schema\n    }\n\n    public static class RateLimitedException extends Exception {\n        public RateLimitedException(String message) {\n            super(message);\n        }\n    }\n}"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using OkHttp library, supporting both regular and DNS-over-HTTPS (DoH) connections, with caching capabilities and custom DNS fallback mechanisms.\n\nClass Description: The HttpClient class provides static methods for performing HTTP GET and POST requests with configurable caching and DNS options. It maintains four different client configurations (regular/DoH with/without cache) and handles response processing with error checking.\n\nAttributes:\n- httpClient: [OkHttpClient] - Standard HTTP client without cache\n- httpClientDoH: [OkHttpClient] - HTTP client with DNS-over-HTTPS support\n- httpClientWithCache: [OkHttpClient] - HTTP client with caching enabled\n- httpClientWithCacheDoH: [OkHttpClient] - HTTP client with both caching and DoH\n- fallbackDNS: [FallBackDNS] - Custom DNS resolver with fallback functionality\n- doh: [boolean] - Flag indicating whether DoH is enabled\n\nMethods:\n- getHttpClient() -> [OkHttpClient] - Returns appropriate HTTP client based on DoH setting\n- getHttpClientWithCache() -> [OkHttpClient] - Returns cached HTTP client based on DoH setting\n- doHttpGet(String url, boolean allowCache) -> [byte[]] - Performs HTTP GET request and returns response body as bytes\n- doHttpPost(String url, String data, boolean allowCache) -> [byte[]] - Performs HTTP POST request with JSON payload and returns response body as bytes\n- followRedirects(OkHttpClient.Builder builder, boolean followRedirects) -> [OkHttpClient.Builder] - Configures redirect following behavior for client builder\n- checkNeedCaptchaAndroidacy(String url, int errorCode) -> [void] - Checks if Androidacy URL requires captcha\n- JsonRequestBody: [static inner class] - Custom RequestBody implementation for JSON data\n\nStatic Initialization Block:\n- Initializes all HTTP client configurations with timeout settings, proxy configuration, and DNS setup (including DoH fallback)",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.Looper;\n\nimport com.fox2code.mmm.MainApplication;\nimport com.fox2code.mmm.R;\nimport com.fox2code.mmm.androidacy.AndroidacyUtil;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.net.ssl.SSLException;\n\nimport okhttp3.Cache;\nimport okhttp3.Dns;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport okhttp3.dnsoverhttps.DnsOverHttps;\nimport okhttp3.logging.HttpLoggingInterceptor;\nimport okio.BufferedSink;\nimport timber.log.Timber;\n\npublic class HttpClient {\n    private static final OkHttpClient httpClient;\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS;\n    private static boolean doh;\n\n    static {\n        MainApplication mainApplication = MainApplication.getINSTANCE();\n        OkHttpClient.Builder httpclientBuilder = new OkHttpClient.Builder();\n        httpclientBuilder.connectTimeout(5, TimeUnit.SECONDS);\n        httpclientBuilder.writeTimeout(10, TimeUnit.SECONDS);\n        httpclientBuilder.readTimeout(15, TimeUnit.SECONDS);\n        httpclientBuilder.proxy(Proxy.NO_PROXY);\n        Dns dns = Dns.SYSTEM;\n        try {\n            InetAddress[] cloudflareBootstrap = new InetAddress[]{InetAddress.getByName(\"162.159.36.1\"), InetAddress.getByName(\"162.159.46.1\"), InetAddress.getByName(\"1.1.1.1\"), InetAddress.getByName(\"1.0.0.1\"), InetAddress.getByName(\"162.159.132.53\"), InetAddress.getByName(\"2606:4700:4700::1111\"), InetAddress.getByName(\"2606:4700:4700::1001\"), InetAddress.getByName(\"2606:4700:4700::0064\"), InetAddress.getByName(\"2606:4700:4700::6400\")};\n            dns = s -> {\n                if (\"cloudflare-dns.com\".equals(s)) {\n                    return Arrays.asList(cloudflareBootstrap);\n                }\n                return Dns.SYSTEM.lookup(s);\n            };\n            httpclientBuilder.dns(dns);\n            dns = new DnsOverHttps.Builder().client(httpclientBuilder.build()).url(Objects.requireNonNull(HttpUrl.parse(\"https://cloudflare-dns.com/dns-query\"))).bootstrapDnsHosts(cloudflareBootstrap).resolvePrivateAddresses(true).build();\n        } catch (UnknownHostException | RuntimeException e) {\n            Timber.e(e, \"Failed to init DoH\");\n        }\n        fallbackDNS = new FallBackDNS(mainApplication, dns, \"github.com\", \"api.github.com\", \"raw.githubusercontent.com\", \"camo.githubusercontent.com\", \"user-images.githubusercontent.com\", \"cdn.jsdelivr.net\", \"img.shields.io\", \"magisk-modules-repo.github.io\", \"www.androidacy.com\", \"api.androidacy.com\", \"production-api.androidacy.com\");\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClient = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientDoH = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.cache(new Cache(new File(mainApplication.getCacheDir(), \"http_cache\"), 16L * 1024L * 1024L));\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClientWithCache = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientWithCacheDoH = followRedirects(httpclientBuilder, true).build();\n        doh = MainApplication.isDohEnabled();\n    }\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    @SuppressLint(\"RestrictedApi\")\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).get().build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            if (response.code() == 401 && AndroidacyUtil.isAndroidacyLink(url)) {\n                throw new HttpException(\"Androidacy token is invalid\", 401);\n            }\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).post(JsonRequestBody.from(data)).header(\"Content-Type\", \"application/json\").build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    private static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (errorCode == 403 && AndroidacyUtil.isAndroidacyLink(url)) {\n            needCaptchaAndroidacyHost = Uri.parse(url).getHost();\n        }\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json\");\n        private static final JsonRequestBody EMPTY = new JsonRequestBody(new byte[0]);\n        final byte[] data;\n\n        private JsonRequestBody(byte[] data) {\n            this.data = data;\n        }\n\n        static JsonRequestBody from(String data) {\n            if (data == null || data.length() == 0) {\n                return EMPTY;\n            }\n            return new JsonRequestBody(data.getBytes(StandardCharsets.UTF_8));\n        }\n\n        @Override\n        public MediaType contentType() {\n            return JSON_MEDIA_TYPE;\n        }\n\n        @Override\n        public long contentLength() {\n            return this.data.length;\n        }\n\n        @Override\n        public void writeTo(@NonNull BufferedSink bufferedSink) throws IOException {\n            bufferedSink.write(this.data);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport okhttp3.Cache;\nimport okhttp3.internal.Util;\nimport okio.Buffer;\nimport okio.BufferedSink;\nimport okio.Okio;\nimport okio.Source;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.TimeUnit;\nimport javax.net.ssl.*;\n\npublic class HttpClient {\n    private static OkHttpClient httpClient;\n    private static OkHttpClient httpClientDoH;\n    private static OkHttpClient httpClientWithCache;\n    private static OkHttpClient httpClientWithCacheDoH;\n    private static FallBackDNS fallbackDNS = new FallBackDNS();\n    private static boolean doh = false;\n\n    static {\n        try {\n            // Trust all certificates for simplicity (not recommended in production)\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, new X509TrustManager[]{new AllCertificatesTrustManager()}, new SecureRandom());\n            \n            Cache cache = new Cache(new File(System.getProperty(\"java.io.tmpdir\"), \"http_cache\"), 10 * 1024 * 1024);\n\n            OkHttpClient.Builder baseBuilder = new OkHttpClient.Builder()\n                    .connectTimeout(30, TimeUnit.SECONDS)\n                    .readTimeout(30, TimeUnit.SECONDS)\n                    .writeTimeout(30, TimeUnit.SECONDS)\n                    .sslSocketFactory(sslContext.getSocketFactory(), new AllCertificatesTrustManager())\n                    .hostnameVerifier((hostname, session) -> true);\n\n            // Regular HTTP client\n            httpClient = baseBuilder.build();\n\n            // DoH HTTP client\n            httpClientDoH = baseBuilder\n                    .dns(fallbackDNS.dohEnabled(true))\n                    .build();\n\n            // Cached HTTP client\n            httpClientWithCache = baseBuilder\n                    .cache(cache)\n                    .build();\n\n            // Cached DoH HTTP client\n            httpClientWithCacheDoH = baseBuilder\n                    .dns(fallbackDNS.dohEnabled(true))\n                    .cache(cache)\n                    .build();\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        Request request = new Request.Builder().url(url).build();\n        Response response = client.newCall(request).execute();\n        if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n        checkNeedCaptchaAndroidacy(url, response.code());\n\n        ResponseBody body = response.body();\n        if (body == null) throw new IOException(\"Empty response body\");\n\n        return body.bytes();\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        RequestBody body = new JsonRequestBody(data);\n        Request request = new Request.Builder().url(url).post(body).build();\n        Response response = client.newCall(request).execute();\n        if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n        checkNeedCaptchaAndroidacy(url, response.code());\n\n        ResponseBody responseBody = response.body();\n        if (responseBody == null) throw new IOException(\"Empty response body\");\n\n        return responseBody.bytes();\n    }\n\n    public static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (errorCode == 403 && url.contains(\"androidacy\")) {\n            System.out.println(\"CAPTCHA required for Androidacy URL: \" + url);\n        }\n    }\n\n    static class JsonRequestBody extends RequestBody {\n        private final String json;\n        private final MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n\n        public JsonRequestBody(String json) {\n            this.json = json;\n        }\n\n        @Override public MediaType contentType() {\n            return JSON;\n        }\n\n        @Override public void writeTo(BufferedSink sink) throws IOException {\n            try (Source source = new Buffer().writeUtf8(json)) {\n                sink.writeAll(source);\n            }\n        }\n    }\n\n    static class FallBackDNS implements DNS {\n        private boolean useDoH = false;\n\n        public DNS dohEnabled(boolean enable) {\n            this.useDoH = enable;\n            return this;\n        }\n\n        @Override\n        public List<InetAddress> lookup(String hostname) throws UnknownHostException {\n            if (useDoH) {\n                // Simulated DoH lookup\n                try {\n                    return Dns.SYSTEM.lookup(hostname);\n                } catch (UnknownHostException e) {\n                    // Fallback to alternate DoH server\n                    System.out.println(\"Falling back to Cloudflare DNS for \" + hostname);\n                    return InetAddress.getAllByName(\"1.1.1.1\"); // Simplified example\n                }\n            } else {\n                return Dns.SYSTEM.lookup(hostname);\n            }\n        }\n    }\n\n    static class AllCertificatesTrustManager implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}\n\n        @Override\n        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}\n\n        @Override\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return new java.security.cert.X509Certificate[0];\n        }\n    }\n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a VaultClient class that interacts with a Vault server's transit engine to perform key wrapping and unwrapping operations for cryptographic purposes, using HTTP REST API calls.\n\nClass Description: The VaultClient class implements the KmsClient interface and provides functionality to encrypt (wrap) and decrypt (unwrap) keys using a Vault server's transit engine. It handles HTTP communication, request building, response processing, and error handling.\n\nAttributes:\n- LOG: Logger - Used for logging information and errors\n- JSON_MEDIA_TYPE: MediaType - Constant for JSON content type\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- kmsToken: String - Authentication token for Vault server\n- hadoopConfiguration: Configuration - Hadoop configuration object\n- endPointPrefix: String - Base URL prefix for Vault API endpoints\n- httpClient: OkHttpClient - HTTP client for making requests\n\nMethods:\n- getContentFromTransitEngine(String, String, String) -> String - Sends a POST request to Vault's transit engine endpoint with the given payload and master key identifier\n- executeAndGetResponse(String, Request) -> String - Executes HTTP request and handles response, including error cases\n- buildPayload(Map<String, String>) -> String - Converts a parameter map to JSON string\n- wrapKey(byte[], String) -> String - Encrypts/wraps a key using the specified master key\n- unwrapKey(String, String) -> byte[] - Decrypts/unwraps a key using the specified master key\n- parseReturn(String, String) -> String - Parses the response from Vault to extract the required value\n- refreshToken() -> void - Refreshes the authentication token (implementation not shown in reference code)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport okhttp3.ConnectionSpec;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.parquet.crypto.KeyAccessDeniedException;\nimport org.apache.parquet.crypto.ParquetCryptoRuntimeException;\nimport org.apache.parquet.crypto.keytools.KeyToolkit;\nimport org.apache.parquet.crypto.keytools.KmsClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n  private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n  private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n  private static final ObjectMapper objectMapper = new ObjectMapper();\n\n  private String kmsToken;\n  private Configuration hadoopConfiguration;\n  private String endPointPrefix;\n  private OkHttpClient httpClient = new OkHttpClient.Builder()\n      .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))\n      .build();\n\n  private String getContentFromTransitEngine(String endPoint, String jPayload, String masterKeyIdentifier) {\n    LOG.info(\"masterKeyIdentifier: \" + masterKeyIdentifier);\n\n    final RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jPayload);\n    Request request = new Request.Builder()\n        .url(endPoint + masterKeyIdentifier)\n        .header(\"X-Vault-Token\", kmsToken)\n        .post(requestBody)\n        .build();\n\n    return executeAndGetResponse(endPoint, request);\n  }\n\n  private String executeAndGetResponse(String endPoint, Request request) {\n    Response response = null;\n    try {\n      response = httpClient.newCall(request).execute();\n      final String responseBody = response.body().string();\n      if (response.isSuccessful()) {\n        return responseBody;\n      } else {\n        if ((401 == response.code()) || (403 == response.code())) {\n          throw new KeyAccessDeniedException(responseBody);\n        }\n        throw new IOException(\"Vault call [\" + endPoint + \"] didn't succeed: \" + responseBody);\n      }\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Vault call [\" + request.url().toString() + endPoint + \"] didn't succeed\", e);\n    } finally {\n      if (null != response) {\n        response.close();\n      }\n    }\n  }\n\n  private String buildPayload(Map<String, String> paramMap) {\n    String jsonValue;\n    try {\n      jsonValue = objectMapper.writeValueAsString(paramMap);\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\"Failed to build payload\", e);\n    }\n    return jsonValue;\n  }\n\n  @Override\n  public String wrapKey(byte[] keyBytes, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    final String dataKeyStr = Base64.getEncoder().encodeToString(keyBytes);\n    writeKeyMap.put(\"plaintext\", dataKeyStr);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"encrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    return parseReturn(response, \"ciphertext\");\n  }\n\n  @Override\n  public byte[] unwrapKey(String wrappedKey, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    writeKeyMap.put(\"ciphertext\", wrappedKey);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"decrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    String plaintext = parseReturn(response, \"plaintext\");\n    return Base64.getDecoder().decode(plaintext);\n  }\n\n  private static String parseReturn(String response, String searchKey) {\n    String matchingValue;\n    try {\n      matchingValue = objectMapper.readTree(response).findValue(searchKey).textValue();\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to parse vault response. \" + searchKey + \" not found.\" + response, e);\n    }\n\n    if (null == matchingValue) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to match vault response. \" + searchKey + \" not found.\" + response);\n    }\n    return matchingValue;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import java.io.IOException;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.apache.hadoop.conf.Configuration;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n    private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n    private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n    private final ObjectMapper objectMapper = new ObjectMapper();\n    private String kmsToken;\n    private final Configuration hadoopConfiguration;\n    private final String endPointPrefix;\n    private final OkHttpClient httpClient;\n\n    public VaultClient(Configuration config, OkHttpClient client) {\n        this.hadoopConfiguration = config;\n        this.httpClient = client;\n        this.endPointPrefix = \"https://vault.example.com/v1/transit\";\n        refreshToken();\n    }\n\n    private String getContentFromTransitEngine(String operationPath, String masterKeyId, String payloadJson) throws IOException {\n        String url = String.format(\"%s/%s/%s\", endPointPrefix, operationPath, masterKeyId);\n        Request request = new Request.Builder()\n                .url(url)\n                .addHeader(\"X-Vault-Token\", kmsToken)\n                .post(RequestBody.create(payloadJson, JSON_MEDIA_TYPE))\n                .build();\n        return executeAndGetResponse(url, request);\n    }\n\n    private String executeAndGetResponse(String url, Request request) throws IOException {\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Unexpected code \" + response + \" when calling \" + url);\n            }\n            return response.body().string();\n        }\n    }\n\n    private String buildPayload(Map<String, String> parameters) {\n        try {\n            return objectMapper.writeValueAsString(parameters);\n        } catch (Exception e) {\n            LOG.error(\"Failed to serialize payload\", e);\n            throw new RuntimeException(\"Failed to serialize payload\", e);\n        }\n    }\n\n    @Override\n    public String wrapKey(byte[] keyBytes, String masterKeyId) throws IOException {\n        Map<String, String> parameters = new HashMap<>();\n        parameters.put(\"plaintext\", Base64.getEncoder().encodeToString(keyBytes));\n        String payload = buildPayload(parameters);\n        String responseJson = getContentFromTransitEngine(\"encrypt\", masterKeyId, payload);\n        return parseReturn(responseJson, \"ciphertext\");\n    }\n\n    @Override\n    public byte[] unwrapKey(String wrappedKey, String masterKeyId) throws IOException {\n        Map<String, String> parameters = new HashMap<>();\n        parameters.put(\"ciphertext\", wrappedKey);\n        String payload = buildPayload(parameters);\n        String responseJson = getContentFromTransitEngine(\"decrypt\", masterKeyId, payload);\n        String plaintext = parseReturn(responseJson, \"plaintext\");\n        return Base64.getDecoder().decode(plaintext);\n    }\n\n    private String parseReturn(String responseJson, String field) throws IOException {\n        try {\n            Map<String, Object> responseMap = objectMapper.readValue(responseJson, Map.class);\n            Map<String, Object> dataMap = (Map<String, Object>) responseMap.get(\"data\");\n            return (String) dataMap.get(field);\n        } catch (Exception e) {\n            LOG.error(\"Error parsing Vault response: {}\", responseJson, e);\n            throw new IOException(\"Error parsing Vault response\", e);\n        }\n    }\n\n    private void refreshToken() {\n        // Implementation not shown\n    }\n}"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Java class that implements geocoding functionality using the GraphHopper API, allowing both forward and reverse geocoding operations through HTTP requests.\n\nClass Description: The GraphHopperGeocoding class provides methods to perform geocoding operations by communicating with the GraphHopper API service. It handles HTTP client configuration, request building, response processing, and error handling.\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- downloader: OkHttpClient - HTTP client for making requests\n- routeServiceUrl: String - Base URL for the GraphHopper geocoding API\n- key: String - API key for authentication\n- DEFAULT_TIMEOUT: long - Default timeout value for HTTP requests (5000ms)\n\nMethods:\n- GraphHopperGeocoding() -> Constructor - Initializes with default GraphHopper API URL\n- GraphHopperGeocoding(String serviceUrl) -> Constructor - Initializes with custom service URL\n- geocode(GHGeocodingRequest request) -> GHGeocodingResponse - Performs geocoding operation based on request parameters\n- setDownloader(OkHttpClient downloader) -> GraphHopperGeocoding - Sets custom HTTP client\n- setKey(String key) -> void - Sets API key for authentication\n- getDownloader() -> OkHttpClient - Returns current HTTP client instance\n- getClientForRequest(GHGeocodingRequest request) -> OkHttpClient - Returns configured HTTP client with appropriate timeout\n- buildUrl(GHGeocodingRequest request) -> String - Constructs API request URL with proper parameters\n- encodeURL(String str) -> String - URL-encodes string parameters (private helper method)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.graphhopper.api.model.GHGeocodingRequest;\nimport com.graphhopper.api.model.GHGeocodingResponse;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GraphHopperGeocoding {\n\n    private final ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key = \"\";\n    private final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1/geocode\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        downloader = new OkHttpClient.Builder().\n                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                build();\n        objectMapper = new ObjectMapper();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) {\n        String url = buildUrl(request);\n        try {\n            Request okRequest = new Request.Builder().url(url)\n                    .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                    .build();\n            Response rsp = getClientForRequest(request).newCall(okRequest).execute();\n            ResponseBody rspBody = rsp.body();\n            if (!rsp.isSuccessful())\n                throw new RuntimeException(rspBody.string());\n            GHGeocodingResponse geoRsp = objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);\n            return geoRsp;\n        } catch (IOException ex) {\n            throw new RuntimeException(\"IO problem for geocoding URL \" + url + \": \" + ex.getMessage(), ex);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = this.downloader;\n        if (request.hasTimeout()) {\n            long timeout = request.getTimeout();\n            client = client.newBuilder()\n                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .readTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .build();\n        }\n        return client;\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        String url = routeServiceUrl + \"?\";\n        if (request.isReverse()) {\n            if (!request.getPoint().isValid())\n                throw new IllegalArgumentException(\"For reverse geocoding you have to pass valid lat and long values\");\n            url += \"reverse=true\";\n        } else {\n            if (request.getQuery() == null)\n                throw new IllegalArgumentException(\"For forward geocoding you have to a string for the query\");\n            url += \"reverse=false\";\n            url += \"&q=\" + encodeURL(request.getQuery());\n        }\n\n        if (request.getPoint().isValid())\n            url += \"&point=\" + request.getPoint().getLat() + \",\" + request.getPoint().getLon();\n\n        url += \"&limit=\" + request.getLimit();\n        url += \"&locale=\" + encodeURL(request.getLocale());\n        url += \"&provider=\" + encodeURL(request.getProvider());\n\n        if (!key.isEmpty()) {\n            url += \"&key=\" + encodeURL(key);\n        }\n        return url;\n    }\n\n    private static String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport okhttp3.HttpUrl;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class GraphHopperGeocoding {\n    private ObjectMapper objectMapper = new ObjectMapper();\n    private OkHttpClient downloader;\n    private String routeServiceUrl = \"https://graphhopper.com/api/1/geocode\";\n    private String key;\n    private static final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this.downloader = new OkHttpClient.Builder()\n                .connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .writeTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .build();\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this();\n        this.routeServiceUrl = serviceUrl;\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) throws IOException {\n        OkHttpClient client = getClientForRequest(request);\n        String url = buildUrl(request);\n\n        Request httpRequest = new Request.Builder()\n                .url(url)\n                .build();\n\n        try (Response response = client.newCall(httpRequest).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            return objectMapper.readValue(response.body().string(), GHGeocodingResponse.class);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = request.getTimeout() > 0 ?\n                new OkHttpClient.Builder()\n                        .connectTimeout(request.getTimeout(), TimeUnit.MILLISECONDS)\n                        .readTimeout(request.getTimeout(), TimeUnit.MILLISECONDS)\n                        .writeTimeout(request.getTimeout(), TimeUnit.MILLISECONDS)\n                        .build() :\n                this.downloader;\n\n        return client;\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        HttpUrl.Builder urlBuilder = HttpUrl.parse(routeServiceUrl).newBuilder();\n\n        if (request.isReverse()) {\n            urlBuilder.addQueryParameter(\"point\", request.getLatitude() + \",\" + request.getLongitude());\n            urlBuilder.addQueryParameter(\"reverse\", \"true\");\n        } else {\n            urlBuilder.addQueryParameter(\"q\", encodeURL(request.getQuery()));\n        }\n\n        if (request.getLocale() != null) {\n            urlBuilder.addQueryParameter(\"locale\", request.getLocale());\n        }\n\n        if (key != null && !key.isEmpty()) {\n            urlBuilder.addQueryParameter(\"key\", key);\n        }\n\n        return urlBuilder.build().toString();\n    }\n\n    private String encodeURL(String str) {\n        return java.net.URLEncoder.encode(str).replace(\"+\", \"%20\");\n    }\n}"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Java class that interacts with the Danbooru API to fetch and process image posts, including retrieving pages of posts, extracting image URLs, and parsing tags from URLs.\n\nClass Description: The DanbooruApiClient class provides functionality to interact with the Danbooru image board API. It handles HTTP requests to fetch posts, processes JSON responses, and extracts relevant information from URLs.\n\nAttributes:\n- DOMAIN: [String] - The domain name of the Danbooru service\n- client: [OkHttpClient] - HTTP client instance for making requests\n- gidPattern: [Pattern] - Regular expression pattern for parsing tags from URLs\n- currentPageNum: [int] - Tracks the current page number for pagination\n\nMethods:\n- Constructor: DanbooruApiClient() -> [void] - Initializes the HTTP client with timeout settings\n- getPage: [int pageNum] -> [JSONObject] - Fetches a page of posts from Danbooru API with the specified page number, returns posts as JSON object\n- extractUrlsFromJson: [JSONObject json] -> [List<String>] - Extracts image URLs from the JSON response and returns them as a list\n- getTagFromUrl: [URL url] -> [String] - Parses and returns the tag component from a Danbooru URL, throws MalformedURLException if URL format is invalid",
    "Canonical_solution": "import com.rarchives.ripme.utils.Utils;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private Pattern gidPattern = null;\n    private int currentPageNum = 1;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .readTimeout(60, TimeUnit.SECONDS)\n                .writeTimeout(60, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public JSONObject getPage(int pageNum) throws MalformedURLException {\n        Request request = new Request.Builder()\n                .url(\"https://\" + DOMAIN + \"/posts.json?page=\" + pageNum)\n                .header(\"User-Agent\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1\")\n                .header(\"Accept\", \"application/json,text/javascript,*/*;q=0.01\")\n                .header(\"Accept-Language\", \"en-US,en;q=0.9\")\n                .header(\"Sec-Fetch-Dest\", \"empty\")\n                .header(\"Sec-Fetch-Mode\", \"cors\")\n                .header(\"Sec-Fetch-Site\", \"same-origin\")\n                .header(\"Referer\", \"https://danbooru.donmai.us/\")\n                .header(\"X-Requested-With\", \"XMLHttpRequest\")\n                .header(\"Connection\", \"keep-alive\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseData = response.body().string();\n            JSONArray jsonArray = new JSONArray(responseData);\n            if (!jsonArray.isEmpty()) {\n                return new JSONObject(\"{ \\\"resources\\\":\" + jsonArray + \" }\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> res = new ArrayList<>(100);\n        JSONArray jsonArray = json.getJSONArray(\"resources\");\n        for (int i = 0; i < jsonArray.length(); i++) {\n            if (jsonArray.getJSONObject(i).has(\"file_url\")) {\n                res.add(jsonArray.getJSONObject(i).getString(\"file_url\"));\n            }\n        }\n        return res;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        gidPattern = Pattern.compile(\"https?://danbooru.donmai.us/(posts)?.*([?&]tags=([^&]*)(?:&z=([0-9]+))?$)\");\n        Matcher m = gidPattern.matcher(url.toExternalForm());\n\n        if (m.matches()) {\n            return m.group(3);\n        }\n\n        throw new MalformedURLException(\"Expected danbooru URL format: \" + DOMAIN + \"/posts?tags=searchterm - got \" + url + \" instead\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.OkHttpClient;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.concurrent.TimeUnit;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"https://danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private final Pattern gidPattern;\n    private int currentPageNum;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .build();\n        this.gidPattern = Pattern.compile(\"/posts/(\\\\d+)\");\n        this.currentPageNum = 1;\n    }\n\n    public JSONObject getPage(int pageNum) throws IOException {\n        String url = DOMAIN + \"/posts.json?page=\" + pageNum;\n        okhttp3.Request request = new okhttp3.Request.Builder()\n                .url(url)\n                .header(\"User-Agent\", \"Java HTTP Client\")\n                .build();\n\n        okhttp3.Response response = client.newCall(request).execute();\n        if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n        return new JSONObject(response.body().string());\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> imageUrls = new ArrayList<>();\n        JSONArray postsArray = json.getJSONArray(\"posts\");\n\n        for (int i = 0; i < postsArray.length(); i++) {\n            JSONObject post = postsArray.getJSONObject(i);\n            String imageUrl = post.getString(\"file_url\");\n            imageUrls.add(imageUrl);\n        }\n\n        return imageUrls;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        Matcher matcher = gidPattern.matcher(url.getPath());\n        if (matcher.find()) {\n            String idStr = matcher.group(1);\n            return \"post_id_\" + idStr;\n        }\n        throw new MalformedURLException(\"URL does not contain a valid post ID: \" + url.toString());\n    }\n}"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for expanding medical terminology value sets using the OkHttp library.\n\nClass Description: The TerminologyServiceClient class provides functionality to interact with a FHIR terminology service to expand value sets. It handles HTTP requests and responses, URL validation, and error handling.\n\nAttributes:\n- client: OkHttpClient - A shared HTTP client instance for making requests\n- urlValidator: UrlValidator - A validator for checking URL formats with support for double slashes\n- expandBaseUrl: String - The base URL for the value set expansion endpoint\n\nMethods:\n- setBaseUrl(String url) -> void - Sets the base URL for the terminology service by appending the value set expansion endpoint path\n- expandValueSet(String valueSetUri) -> Response - Makes a GET request to expand a value set, validates the input URI, and returns the HTTP response",
    "Canonical_solution": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private static OkHttpClient client = new OkHttpClient();\n    private static UrlValidator urlValidator = new UrlValidator(UrlValidator.ALLOW_2_SLASHES);\n    private static String expandBaseUrl;\n\n    public static void setBaseUrl(String url) {\n        expandBaseUrl = url + \"/ValueSet/$expand?url=\";\n    }\n\n    public static Response expandValueSet(String valueSetUri) {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid ValueSet URI\");\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + valueSetUri)\n                .header(\"Accept\", \"application/json\")\n                .build();\n\n        try {\n            Response response = client.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (body == null) {\n                throw new RuntimeException(\"Value Set Expansion contained no body\");\n            }\n            return response;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Issue when expanding the value set\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class TerminologyServiceClient {\n    private OkHttpClient client;\n    private UrlValidator urlValidator;\n    private String expandBaseUrl;\n\n    public TerminologyServiceClient() {\n        this.client = new OkHttpClient();\n        this.urlValidator = new UrlValidator();\n    }\n\n    public void setBaseUrl(String url) {\n        if (url != null && !url.isEmpty()) {\n            if (!url.endsWith(\"/\")) {\n                url += \"/\";\n            }\n            this.expandBaseUrl = url + \"ValueSet/$expand\";\n        } else {\n            this.expandBaseUrl = null;\n        }\n    }\n\n    public Response expandValueSet(String valueSetUri) throws IOException {\n        if (valueSetUri == null || valueSetUri.isEmpty()) {\n            throw new IllegalArgumentException(\"ValueSet URI must not be null or empty\");\n        }\n\n        if (expandBaseUrl == null || expandBaseUrl.isEmpty()) {\n            throw new IllegalStateException(\"Base URL has not been set\");\n        }\n\n        if (!urlValidator.isValid(expandBaseUrl)) {\n            throw new MalformedURLException(\"Invalid base URL: \" + expandBaseUrl);\n        }\n\n        String requestUrl = expandBaseUrl + \"?url=\" + valueSetUri;\n\n        Request request = new Request.Builder()\n                .url(requestUrl)\n                .get()\n                .build();\n\n        return client.newCall(request).execute();\n    }\n\n    static class UrlValidator {\n        private static final String URL_REGEX = \"^(https?|ftp):\\\\/\\\\/([^:\\\\/\\\\s]+)(:\\\\d+)?(\\\\/[^\\\\s]*)?$\";\n        private Pattern pattern = Pattern.compile(URL_REGEX);\n\n        public boolean isValid(String url) {\n            if (url == null || url.isEmpty()) {\n                return false;\n            }\n\n            Matcher matcher = pattern.matcher(url);\n            return matcher.matches();\n        }\n    }\n}"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for interacting with GitHub Copilot and CoCoPilot services, including token retrieval and request execution capabilities.\n\nClass Description: The ApiClient class provides functionality to interact with GitHub Copilot and CoCoPilot APIs. It handles HTTP requests, manages headers, and processes responses. The class maintains a reusable HTTP client with configurable timeouts and generates unique identifiers for tracking requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used for making requests\n- machineId: String - A unique identifier generated for the machine (static final)\n\nMethods:\n- ApiClient() -> None - Constructor that initializes the HTTP client with timeout configurations\n- generateMachineId() -> String - Generates a unique machine identifier using UUID (private static)\n- getCopilotToken(String apiKey) -> String - Retrieves a Copilot token using the provided API key\n- getCoCoToken(String apiKey) -> String - Retrieves a CoCoPilot token using the provided API key\n- executeRequest(String url, String method, String body, Map<String, String> headers) -> Response - Executes a generic HTTP request with specified parameters\n- createHeaders(String chatToken) -> Map<String, String> - Creates a standard set of headers for API requests using the provided chat token",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport okhttp3.*;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class ApiClient {\n    private final OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(3, TimeUnit.MINUTES)\n                .readTimeout(5, TimeUnit.MINUTES)\n                .writeTimeout(5, TimeUnit.MINUTES)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.github.com\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.cocopilot.org/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.cocopilot.org\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n        RequestBody requestBody = RequestBody.create(body, JSON);\n        \n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url);\n        \n        if (\"POST\".equalsIgnoreCase(method)) {\n            requestBuilder.post(requestBody);\n        } else if (\"GET\".equalsIgnoreCase(method)) {\n            requestBuilder.get();\n        }\n        \n        headers.forEach(requestBuilder::addHeader);\n        Request request = requestBuilder.build();\n        \n        return client.newCall(request).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headersMap = new HashMap<>();\n        headersMap.put(\"Host\", \"api.githubcopilot.com\");\n        headersMap.put(\"Accept-Encoding\", \"gzip, deflate, br\");\n        headersMap.put(\"Accept\", \"*/*\");\n        headersMap.put(\"Authorization\", \"Bearer \" + chatToken);\n        headersMap.put(\"X-Request-Id\", UUID.randomUUID().toString());\n        headersMap.put(\"X-Github-Api-Version\", \"2023-07-07\");\n        headersMap.put(\"Vscode-Sessionid\", UUID.randomUUID().toString() + System.currentTimeMillis());\n        headersMap.put(\"vscode-machineid\", machineId);\n        headersMap.put(\"Editor-Version\", \"vscode/1.85.0\");\n        headersMap.put(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\");\n        headersMap.put(\"Openai-Organization\", \"github-copilot\");\n        headersMap.put(\"Copilot-Integration-Id\", \"vscode-chat\");\n        headersMap.put(\"Openai-Intent\", \"conversation-panel\");\n        headersMap.put(\"User-Agent\", \"GitHubCopilotChat/0.11.1\");\n        return headersMap;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport okio.Buffer;\nimport java.io.IOException;\nimport java.util.*;\n\npublic class ApiClient {\n    private OkHttpClient client;\n    private static final String MACHINE_ID = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(30, java.util.concurrent.TimeUnit.SECONDS)\n                .readTimeout(30, java.util.concurrent.TimeUnit.SECONDS)\n                .writeTimeout(30, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        String url = \"https://api.github.com/copilot/token\";\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Authorization\", \"Bearer \" + apiKey);\n        headers.put(\"X-Machine-Id\", MACHINE_ID);\n\n        Response response = executeRequest(url, \"GET\", null, headers);\n        if (response.isSuccessful()) {\n            ResponseBody body = response.body();\n            return body != null ? body.string() : null;\n        }\n        throw new IOException(\"Failed to get Copilot token: \" + response.code());\n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        String url = \"https://api.cocopilot.com/v1/auth/token\";\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Authorization\", \"Bearer \" + apiKey);\n        headers.put(\"X-Device-Id\", MACHINE_ID);\n\n        Response response = executeRequest(url, \"POST\", \"\", headers);\n        if (response.isSuccessful()) {\n            ResponseBody body = response.body();\n            return body != null ? body.string() : null;\n        }\n        throw new IOException(\"Failed to get CoCo token: \" + response.code());\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n\n        // Add headers\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                requestBuilder.addHeader(entry.getKey(), entry.getValue());\n            }\n        }\n\n        // Set request body and method\n        if (body != null && !method.equals(\"GET\")) {\n            MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n            RequestBody requestBody = RequestBody.create(body, JSON);\n            requestBuilder.method(method, requestBody);\n        } else {\n            requestBuilder.method(method, null);\n        }\n\n        return client.newCall(requestBuilder.build()).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Authorization\", \"Bearer \" + chatToken);\n        headers.put(\"Content-Type\", \"application/json\");\n        headers.put(\"X-Client-Id\", MACHINE_ID);\n        return headers;\n    }\n}"
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests to a RESTful API using the OkHttp client library, with support for both GET and POST methods, including timeout configuration and proper resource cleanup.\n\nClass Description: GHMatrixBatchRequester is a utility class designed to make HTTP requests to a GraphHopper matrix API. It provides methods for sending GET and POST requests, handles response processing, and includes timeout configurations for network operations.\n\nAttributes:\n- logger: Logger - Used for logging debug and error information\n- client: OkHttpClient - The HTTP client instance used to make requests\n\nMethods:\n- Constructor: GHMatrixBatchRequester() -> void - Initializes the HTTP client with default timeout settings (5 seconds for connect and read)\n- Constructor: GHMatrixBatchRequester(OkHttpClient) -> void - Allows injection of a custom configured OkHttpClient instance\n- getJson: getJson(String url) -> JsonResult - Sends a GET request to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers\n- postJson: postJson(String url, JsonNode requestJson) -> JsonResult - Sends a POST request with JSON payload to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GHMatrixBatchRequester {\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.client = client;\n    }\n\n    protected JsonResult getJson(String url) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n\n    protected JsonResult postJson(String url, JsonNode requestJson) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .post(createRequestBody(requestJson))\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class GHMatrixBatchRequester {\n    private static final Logger logger = LoggerFactory.getLogger(GHMatrixBatchRequester.class);\n    private final OkHttpClient client;\n    private static final ObjectMapper objectMapper = new ObjectMapper();\n\n    public GHMatrixBatchRequester() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient customClient) {\n        this.client = customClient;\n    }\n\n    public JsonResult getJson(String url) throws IOException {\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        return executeRequest(request);\n    }\n\n    public JsonResult postJson(String url, JsonNode requestJson) throws IOException {\n        RequestBody body = RequestBody.create(\n                requestJson.toString(),\n                MediaType.get(\"application/json\")\n        );\n\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .build();\n\n        return executeRequest(request);\n    }\n\n    private JsonResult executeRequest(Request request) throws IOException {\n        try (Response response = client.newCall(request).execute()) {\n            ResponseBody responseBody = response.body();\n            String responseBodyString = responseBody != null ? responseBody.string() : null;\n            int code = response.code();\n            boolean success = response.isSuccessful();\n            Headers headers = response.headers();\n\n            JsonNode jsonNode = null;\n            if (responseBodyString != null && !responseBodyString.isEmpty()) {\n                try {\n                    jsonNode = objectMapper.readTree(responseBodyString);\n                } catch (Exception e) {\n                    logger.warn(\"Failed to parse JSON response: {}\", e.getMessage());\n                }\n            }\n\n            return new JsonResult(jsonNode, responseBodyString, code, success, headers);\n        }\n    }\n\n    public static class JsonResult {\n        private final JsonNode json;\n        private final String rawResponse;\n        private final int statusCode;\n        private final boolean success;\n        private final Headers headers;\n\n        public JsonResult(JsonNode json, String rawResponse, int statusCode, boolean success, Headers headers) {\n            this.json = json;\n            this.rawResponse = rawResponse;\n            this.statusCode = statusCode;\n            this.success = success;\n            this.headers = headers;\n        }\n\n        public JsonNode getJson() {\n            return json;\n        }\n\n        public String getRawResponse() {\n            return rawResponse;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public boolean isSuccess() {\n            return success;\n        }\n\n        public Headers getHeaders() {\n            return headers;\n        }\n    }\n}"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Create a Kafka consumer class that reads messages from specified Kafka topic partitions and integrates with Spring Batch for state management and offset tracking.\n\nClass Description: KafkaItemReader is a Spring Batch ItemReader implementation that consumes messages from Kafka topics. It maintains partition offsets, supports state persistence between batches, and provides configurable polling behavior.\n\nAttributes:\n- TOPIC_PARTITION_OFFSETS: [String] - Key for storing partition offsets in execution context\n- DEFAULT_POLL_TIMEOUT: [long] - Default timeout duration for consumer polling (30 seconds)\n- topicPartitions: [List<TopicPartition>] - List of topic partitions to consume from\n- partitionOffsets: [Map<TopicPartition, Long>] - Current offsets for each partition\n- kafkaConsumer: [KafkaConsumer<K, V>] - Kafka consumer instance\n- consumerProperties: [Properties] - Configuration properties for Kafka consumer\n- consumerRecords: [Iterator<ConsumerRecord<K, V>>] - Iterator for currently polled records\n- pollTimeout: [Duration] - Timeout duration for polling messages\n- saveState: [boolean] - Flag indicating whether to save consumer state\n\nMethods:\n- KafkaItemReader(Properties, String, Integer...) -> [Constructor] - Creates reader with properties, topic name, and partition array\n- KafkaItemReader(Properties, String, List<Integer>) -> [Constructor] - Creates reader with properties, topic name, and partition list\n- open(ExecutionContext) -> [void] - Initializes Kafka consumer, restores offsets if available, and seeks to appropriate positions\n- read() -> [V] - Reads next message from Kafka, returns message value or null if no messages available\n- update(ExecutionContext) -> [void] - Saves current partition offsets to execution context and commits offsets to Kafka\n- close() -> [void] - Closes the Kafka consumer when reader is no longer needed",
    "Canonical_solution": "import org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.support.AbstractItemStreamItemReader;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class KafkaItemReader<K, V> extends AbstractItemStreamItemReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30L;\n\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private final Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n    private boolean saveState = true;\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this(consumerProperties, topicName, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        Assert.notNull(consumerProperties, \"Consumer properties must not be null\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG),\n                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.GROUP_ID_CONFIG),\n                ConsumerConfig.GROUP_ID_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        this.consumerProperties = consumerProperties;\n        Assert.hasLength(topicName, \"Topic name must not be null or empty\");\n        Assert.isTrue(!partitions.isEmpty(), \"At least one partition must be provided\");\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topicName, partition));\n        }\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        this.kafkaConsumer = new KafkaConsumer<>(this.consumerProperties);\n        if (this.partitionOffsets == null) {\n            this.partitionOffsets = new HashMap<>();\n            for (TopicPartition topicPartition : this.topicPartitions) {\n                this.partitionOffsets.put(topicPartition, 0L);\n            }\n        }\n        if (this.saveState && executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            Map<TopicPartition, Long> offsets = (Map<TopicPartition, Long>) executionContext\n                    .get(TOPIC_PARTITION_OFFSETS);\n            for (Map.Entry<TopicPartition, Long> entry : offsets.entrySet()) {\n                this.partitionOffsets.put(entry.getKey(), entry.getValue() == 0 ? 0 : entry.getValue() + 1);\n            }\n        }\n        this.kafkaConsumer.assign(this.topicPartitions);\n        this.partitionOffsets.forEach(this.kafkaConsumer::seek);\n    }\n\n    @Nullable\n    @Override\n    public V read() {\n        if (this.consumerRecords == null || !this.consumerRecords.hasNext()) {\n            this.consumerRecords = this.kafkaConsumer.poll(this.pollTimeout).iterator();\n        }\n        if (this.consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = this.consumerRecords.next();\n            this.partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset());\n            return record.value();\n        }\n        else {\n            return null;\n        }\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (this.saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, new HashMap<>(this.partitionOffsets));\n        }\n        this.kafkaConsumer.commitSync();\n    }\n\n    @Override\n    public void close() {\n        if (this.kafkaConsumer != null) {\n            this.kafkaConsumer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "import org.apache.kafka.clients.consumer.*;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.serialization.Deserializer;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.ItemReader;\nimport org.springframework.batch.item.ParseException;\nimport org.springframework.batch.item.UnexpectedInputException;\n\nimport java.time.Duration;\nimport java.util.*;\n\npublic class KafkaItemReader<K, V> implements ItemReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topicPartitionOffsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30000; // 30 seconds\n\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private final Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private final Duration pollTimeout;\n    private final boolean saveState;\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this(consumerProperties, topicName, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        this.consumerProperties = consumerProperties;\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topicName, partition));\n        }\n        this.pollTimeout = Duration.ofMillis(DEFAULT_POLL_TIMEOUT);\n        this.saveState = true;\n        this.partitionOffsets = new HashMap<>();\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) throws Exception {\n        Deserializer<K> keyDeserializer = (Deserializer<K>) Class.forName(consumerProperties.getProperty(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)).getDeclaredConstructor().newInstance();\n        Deserializer<V> valueDeserializer = (Deserializer<V>) Class.forName(consumerProperties.getProperty(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)).getDeclaredConstructor().newInstance();\n        this.kafkaConsumer = new KafkaConsumer<>(consumerProperties, keyDeserializer, valueDeserializer);\n\n        if (saveState && executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            @SuppressWarnings(\"unchecked\")\n            Map<TopicPartition, Long> savedOffsets = (Map<TopicPartition, Long>) executionContext.get(TOPIC_PARTITION_OFFSETS);\n            this.partitionOffsets.putAll(savedOffsets);\n        }\n\n        kafkaConsumer.assign(topicPartitions);\n\n        for (TopicPartition tp : topicPartitions) {\n            if (partitionOffsets.containsKey(tp)) {\n                kafkaConsumer.seek(tp, partitionOffsets.get(tp));\n            } else {\n                kafkaConsumer.seekToBeginning(Collections.singletonList(tp));\n                partitionOffsets.put(tp, kafkaConsumer.position(tp));\n            }\n        }\n\n        pollForRecords();\n    }\n\n    private void pollForRecords() {\n        ConsumerRecords<K, V> records = kafkaConsumer.poll(pollTimeout);\n        this.consumerRecords = records.iterator();\n    }\n\n    @Override\n    public V read() throws Exception, UnexpectedInputException, ParseException {\n        if (!consumerRecords.hasNext()) {\n            pollForRecords();\n            if (!consumerRecords.hasNext()) {\n                return null;\n            }\n        }\n\n        ConsumerRecord<K, V> record = consumerRecords.next();\n        TopicPartition tp = new TopicPartition(record.topic(), record.partition());\n        partitionOffsets.put(tp, record.offset() + 1);\n\n        return record.value();\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, partitionOffsets);\n        }\n\n        Map<TopicPartition, OffsetAndMetadata> offsets = new HashMap<>();\n        for (Map.Entry<TopicPartition, Long> entry : partitionOffsets.entrySet()) {\n            offsets.put(entry.getKey(), new OffsetAndMetadata(entry.getValue()));\n        }\n\n        kafkaConsumer.commitSync(offsets);\n    }\n\n    @Override\n    public void close() throws Exception {\n        if (kafkaConsumer != null) {\n            kafkaConsumer.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Create a Java class that implements a Kafka consumer thread for reading and processing messages from a Kafka topic, with support for message validation and local store updates.\n\nClass Description: KafkaStoreReaderThread is a thread-based Kafka consumer that reads messages from a specified topic, validates them using a handler, and updates a local store accordingly. It maintains offset tracking and provides shutdown capabilities.\n\nAttributes:\n- topic: String - The Kafka topic to consume messages from\n- topicPartition: TopicPartition - The topic partition being consumed\n- groupId: String - The consumer group ID\n- storeUpdateHandler: StoreUpdateHandler<K, V> - Handler for message validation\n- serializer: Serializer<K, V> - Serializer for message keys and values\n- localStore: Store<K, V> - Local storage for processed messages\n- offsetUpdateLock: ReentrantLock - Lock for thread-safe offset updates\n- offsetReachedThreshold: Condition - Condition for offset tracking\n- consumer: Consumer<byte[], byte[]> - Kafka consumer instance\n- offsetInSchemasTopic: long - Current offset in the topic\n- consumerProps: Properties - Configuration properties for the Kafka consumer\n\nMethods:\n- KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) -> void - Constructor that initializes the consumer with configuration and dependencies\n- doWork() -> void - Main work method that polls for messages, processes them, and updates the local store\n- shutdown() -> void - Gracefully shuts down the consumer thread",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.StoreUpdateHandler.ValidationStatus;\nimport io.confluent.kafka.schemaregistry.utils.ShutdownableThread;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.errors.WakeupException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends ShutdownableThread {\n\n  private static final Logger log = LoggerFactory.getLogger(KafkaStoreReaderThread.class);\n\n  private final String topic;\n  private final TopicPartition topicPartition;\n  private final String groupId;\n  private final StoreUpdateHandler<K, V> storeUpdateHandler;\n  private final Serializer<K, V> serializer;\n  private final Store<K, V> localStore;\n  private final ReentrantLock offsetUpdateLock;\n  private final Condition offsetReachedThreshold;\n  private Consumer<byte[], byte[]> consumer;\n  private long offsetInSchemasTopic = -1L;\n  private Properties consumerProps = new Properties();\n\n  public KafkaStoreReaderThread(String bootstrapBrokers,\n                              String topic,\n                              String groupId,\n                              StoreUpdateHandler<K, V> storeUpdateHandler,\n                              Serializer<K, V> serializer,\n                              Store<K, V> localStore) {\n    super(\"kafka-store-reader-thread-\" + topic, false);\n    offsetUpdateLock = new ReentrantLock();\n    offsetReachedThreshold = offsetUpdateLock.newCondition();\n    this.topic = topic;\n    this.groupId = groupId;\n    this.storeUpdateHandler = storeUpdateHandler;\n    this.serializer = serializer;\n    this.localStore = localStore;\n\n    consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, this.groupId);\n    consumerProps.put(ConsumerConfig.CLIENT_ID_CONFIG, \"KafkaStore-reader-\" + this.topic);\n    consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n    consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n    consumerProps.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n    consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n    consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n\n    this.consumer = new KafkaConsumer<>(consumerProps);\n    this.topicPartition = new TopicPartition(topic, 0);\n    List<TopicPartition> topicPartitions = Arrays.asList(this.topicPartition);\n    this.consumer.assign(topicPartitions);\n    consumer.seekToBeginning(topicPartitions);\n  }\n\n  @Override\n  public void doWork() {\n    try {\n      ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(Long.MAX_VALUE));\n      for (ConsumerRecord<byte[], byte[]> record : records) {\n        K messageKey = this.serializer.deserializeKey(record.key());\n        V message = record.value() == null ? null : serializer.deserializeValue(messageKey, record.value());\n        \n        TopicPartition tp = new TopicPartition(record.topic(), record.partition());\n        long offset = record.offset();\n        long timestamp = record.timestamp();\n        ValidationStatus status = this.storeUpdateHandler.validateUpdate(\n                messageKey, message, tp, offset, timestamp);\n        \n        if (status == ValidationStatus.SUCCESS) {\n          if (message == null) {\n            localStore.delete(messageKey);\n          } else {\n            localStore.put(messageKey, message);\n          }\n        }\n\n        try {\n          offsetUpdateLock.lock();\n          offsetInSchemasTopic = record.offset();\n          offsetReachedThreshold.signalAll();\n        } finally {\n          offsetUpdateLock.unlock();\n        }\n      }\n    } catch (WakeupException we) {\n      // Thread is closing\n    } catch (RecordTooLargeException rtle) {\n      throw new IllegalStateException(\"Consumer threw RecordTooLargeException\", rtle);\n    } catch (RuntimeException e) {\n      log.error(\"KafkaStoreReader thread has died\", e);\n      throw e;\n    }\n  }\n\n  @Override\n  public void shutdown() {\n    super.initiateShutdown();\n    if (consumer != null) {\n      consumer.wakeup();\n    }\n    super.awaitShutdown();\n    if (consumer != null) {\n      consumer.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "import org.apache.kafka.clients.consumer.*;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.serialization.Deserializer;\nimport org.apache.kafka.common.serialization.Serializer;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends Thread {\n    private final String topic;\n    private TopicPartition topicPartition;\n    private final String groupId;\n    private final StoreUpdateHandler<K, V> storeUpdateHandler;\n    private final Serializer<K, V> serializer;\n    private final Store<K, V> localStore;\n    private final ReentrantLock offsetUpdateLock = new ReentrantLock();\n    private final Condition offsetReachedThreshold = offsetUpdateLock.newCondition();\n    private Consumer<byte[], byte[]> consumer;\n    private long offsetInSchemasTopic = 0L;\n    private final Properties consumerProps;\n    private final AtomicBoolean running = new AtomicBoolean(true);\n\n    public KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) {\n        this.topic = topic;\n        this.groupId = groupId;\n        this.storeUpdateHandler = storeUpdateHandler;\n        this.serializer = serializer;\n        this.localStore = localStore;\n\n        consumerProps = new Properties();\n        consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n        consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);\n        consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, Deserializer.class.getName());\n        consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, Deserializer.class.getName());\n        consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n        consumerProps.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n\n        this.consumer = new KafkaConsumer<>(consumerProps, new Deserializer<byte[]>() {\n            @Override\n            public void configure(Map<String, ?> configs, boolean isKey) {}\n\n            @Override\n            public byte[] deserialize(String topic, byte[] data) {\n                return data;\n            }\n\n            @Override\n            public void close() {}\n        }, new Deserializer<byte[]>() {\n            @Override\n            public void configure(Map<String, ?> configs, boolean isKey) {}\n\n            @Override\n            public byte[] deserialize(String topic, byte[] data) {\n                return data;\n            }\n\n            @Override\n            public void close() {}\n        });\n        consumer.subscribe(Collections.singletonList(topic));\n        initializePartitionAssignment();\n    }\n\n    private void initializePartitionAssignment() {\n        consumer.poll(0); // Trigger assignment\n        Set<TopicPartition> partitions = consumer.assignment();\n        if (!partitions.isEmpty()) {\n            topicPartition = partitions.iterator().next();\n            offsetInSchemasTopic = consumer.position(topicPartition);\n        }\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (running.get()) {\n                doWork();\n            }\n        } catch (Exception e) {\n            // Handle exception\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void doWork() {\n        ConsumerRecords<byte[], byte[]> records = consumer.poll(1000);\n        for (ConsumerRecord<byte[], byte[]> record : records) {\n            K key = serializer.deserializeKey(record.key());\n            V value = serializer.deserializeValue(record.value());\n\n            if (storeUpdateHandler.isValid(key, value)) {\n                localStore.update(key, value);\n                offsetInSchemasTopic = record.offset() + 1;\n                offsetUpdateLock.lock();\n                try {\n                    offsetReachedThreshold.signalAll();\n                } finally {\n                    offsetUpdateLock.unlock();\n                }\n            }\n            consumer.commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(offsetInSchemasTopic)));\n        }\n    }\n\n    public void shutdown() {\n        running.set(false);\n        consumer.wakeup();\n        try {\n            join(5000);\n        } catch (InterruptedException e) {\n            interrupt();\n        } finally {\n            consumer.close();\n        }\n    }\n}\n\ninterface StoreUpdateHandler<K, V> {\n    boolean isValid(K key, V value);\n}\n\ninterface Store<K, V> {\n    void update(K key, V value);\n}\n\ninterface Serializer<K, V> {\n    K deserializeKey(byte[] keyData);\n    V deserializeValue(byte[] valueData);\n}"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Create a Kafka producer class that handles message serialization and sending to a Kafka topic with configurable properties and error handling.\n\nClass Description: The KafkaStoreProducer class is a generic Kafka producer that serializes and sends key-value pairs to a specified Kafka topic. It provides configurable timeout settings and handles various Kafka-related exceptions.\n\nAttributes:\n- producer: KafkaProducer<byte[], byte[]> - The underlying Kafka producer instance\n- topic: String - The Kafka topic to which messages will be sent\n- serializer: Serializer<K, V> - The serializer for key-value pairs\n- timeout: int - The maximum time to wait for message acknowledgment in milliseconds\n\nMethods:\n- Constructor: KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) -> void - Initializes the Kafka producer with configuration properties including bootstrap servers, topic, serializer, timeout, and additional custom properties\n- put: put(K key, V value) -> V - Serializes and sends a key-value pair to the Kafka topic, returning the value if successful. Throws StoreTimeoutException if the operation times out or StoreException for other errors\n- close: close() -> void - Closes the Kafka producer and releases all resources",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.exceptions.StoreException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.StoreTimeoutException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.SerializationException;\nimport io.confluent.kafka.schemaregistry.storage.serialization.Serializer;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaStoreProducer<K, V> {\n\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, \n                            Serializer<K, V> serializer, int timeout,\n                            Properties configProps) {\n        Properties props = new Properties();\n        props.putAll(configProps);\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n        props.put(ProducerConfig.ACKS_CONFIG, \"-1\");\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);\n\n        this.producer = new KafkaProducer<>(props);\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n    }\n\n    public V put(K key, V value) throws StoreTimeoutException, StoreException {\n        if (key == null) {\n            throw new StoreException(\"Key should not be null\");\n        }\n\n        ProducerRecord<byte[], byte[]> producerRecord;\n        try {\n            producerRecord = new ProducerRecord<>(\n                topic, \n                0, \n                this.serializer.serializeKey(key),\n                value == null ? null : this.serializer.serializeValue(value)\n            );\n        } catch (SerializationException e) {\n            throw new StoreException(\"Error serializing schema while creating the Kafka produce record\", e);\n        }\n\n        try {\n            Future<RecordMetadata> ack = producer.send(producerRecord);\n            RecordMetadata recordMetadata = ack.get(timeout, TimeUnit.MILLISECONDS);\n            return value;\n        } catch (InterruptedException e) {\n            throw new StoreException(\"Put operation interrupted while waiting for an ack from Kafka\", e);\n        } catch (ExecutionException e) {\n            if (e.getCause() instanceof RecordTooLargeException) {\n                throw new StoreException(\"Put operation failed because entry is too large\");\n            } else {\n                throw new StoreException(\"Put operation failed while waiting for an ack from Kafka\", e);\n            }\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\n                \"Put operation timed out while waiting for an ack from Kafka\", e);\n        } catch (KafkaException ke) {\n            throw new StoreException(\"Put operation to Kafka failed\", ke);\n        }\n    }\n\n    public void close() {\n        producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.common.serialization.Serializer;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\n\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaStoreProducer<K, V> {\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapBrokers);\n        props.putAll(configProps);\n        this.producer = new KafkaProducer<>(props);\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n    }\n\n    public V put(K key, V value) throws StoreTimeoutException, StoreException {\n        try {\n            byte[] serializedKey = serializer.serializeKey(key);\n            byte[] serializedValue = serializer.serializeValue(value);\n            ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(topic, serializedKey, serializedValue);\n            RecordMetadata metadata = producer.send(record).get(timeout, TimeUnit.MILLISECONDS);\n            return value;\n        } catch (InterruptedException | ExecutionException e) {\n            Thread.currentThread().interrupt();\n            throw new StoreException(\"Failed to send message to Kafka: \" + e.getMessage(), e);\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\"Kafka send operation timed out after \" + timeout + \"ms\", e);\n        }\n    }\n\n    public void close() {\n        producer.close();\n    }\n}\n\nclass StoreException extends Exception {\n    public StoreException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\nclass StoreTimeoutException extends Exception {\n    public StoreTimeoutException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a Kafka sink class that writes data to a Kafka topic, with configuration parameters for the Kafka producer and topic name.\n\nClass Description: The KafkaSink class is a self-documenting sink that takes data from an observable stream, encodes it, and writes it to a specified Kafka topic. It handles Kafka producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- encoder: [Func1<T, byte[]>] - Function to encode the input data into byte arrays\n- registry: [Registry] - Metrics registry for monitoring\n- kafkaProducerAtomicRef: [AtomicReference<KafkaProducer<byte[], byte[]>>] - Thread-safe reference to the Kafka producer instance\n- subscription: [Subscription] - Subscription to the observable data stream\n\nMethods:\n- call: [call(Context context, PortRequest ignore, Observable<T> dataO)] -> [void] - Initializes the Kafka producer if needed and subscribes to the input observable to send data to Kafka\n- getParameters: [getParameters()] -> [List<ParameterDefinition<?>>] - Returns the list of parameter definitions for Kafka configuration and topic name\n- metadata: [metadata()] -> [Metadata] - Provides metadata about the sink including name and description\n- close: [close()] -> [void] - Cleans up resources by unsubscribing from the observable stream",
    "Canonical_solution": "import com.netflix.spectator.api.Registry;\nimport io.mantisrx.runtime.Context;\nimport io.mantisrx.runtime.Metadata;\nimport io.mantisrx.runtime.PortRequest;\nimport io.mantisrx.runtime.parameter.ParameterDefinition;\nimport io.mantisrx.runtime.parameter.Parameters;\nimport io.mantisrx.runtime.parameter.type.StringParameter;\nimport io.mantisrx.runtime.parameter.validator.Validators;\nimport io.mantisrx.runtime.sink.SelfDocumentingSink;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\n\npublic class KafkaSink<T> implements SelfDocumentingSink<T> {\n    private static final Logger logger = LoggerFactory.getLogger(KafkaSink.class);\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>(null);\n    private Subscription subscription;\n\n    KafkaSink(Registry registry, Func1<T, byte[]> encoder) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    @Override\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            MantisKafkaProducerConfig mantisKafkaProducerConfig = new MantisKafkaProducerConfig(context);\n            Map<String, Object> producerProperties = mantisKafkaProducerConfig.getProducerProperties();\n            KafkaProducer<byte[], byte[]> kafkaProducer = new KafkaProducer<>(producerProperties);\n            kafkaProducerAtomicRef.compareAndSet(null, kafkaProducer);\n            logger.info(\"Kafka Producer initialized\");\n        }\n        KafkaProducer<byte[], byte[]> kafkaProducer = kafkaProducerAtomicRef.get();\n        Parameters parameters = context.getParameters();\n        String topic = (String)parameters.get(KafkaSinkJobParameters.TOPIC);\n\n        subscription = dataO.map(encoder::call)\n            .flatMap((dataBytes) ->\n                         Observable.from(kafkaProducer.send(new ProducerRecord<>(topic, dataBytes)))\n                             .subscribeOn(Schedulers.io()))\n            .subscribe();\n    }\n\n    @Override\n    public List<ParameterDefinition<?>> getParameters() {\n        final List<ParameterDefinition<?>> params = new ArrayList<>();\n        params.add(new StringParameter()\n                       .name(KafkaSinkJobParameters.TOPIC)\n                       .description(\"Kafka topic to write to\")\n                       .validator(Validators.notNullOrEmpty())\n                       .required()\n                       .build());\n        params.addAll(MantisKafkaProducerConfig.getJobParameterDefinitions());\n        return params;\n    }\n\n    @Override\n    public Metadata metadata() {\n        StringBuilder description = new StringBuilder();\n        description.append(\"Writes the output of the job into the configured Kafka topic\");\n\n        return new Metadata.Builder()\n            .name(\"Mantis Kafka Sink\")\n            .description(description.toString())\n            .build();\n    }\n\n    @Override\n    public void close() {\n        subscription.unsubscribe();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport rx.Observable;\nimport rx.Subscription;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\n\npublic class KafkaSink<T> {\n    private final Function<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>();\n    private Subscription subscription;\n\n    public KafkaSink(Function<T, byte[]> encoder, Registry registry) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            Properties props = new Properties();\n            props.put(\"bootstrap.servers\", context.getParameter(\"bootstrap.servers\"));\n            props.put(\"key.serializer\", ByteArraySerializer.class.getName());\n            props.put(\"value.serializer\", ByteArraySerializer.class.getName());\n            String topic = context.getParameter(\"topic.name\");\n            KafkaProducer<byte[], byte[]> producer = new KafkaProducer<>(props);\n            kafkaProducerAtomicRef.set(producer);\n\n            subscription = dataO.subscribe(data -> {\n                byte[] encodedData = encoder.apply(data);\n                producer.send(new ProducerRecord<>(context.getParameter(\"topic.name\"), encodedData));\n                registry.counter(\"messages.sent\").inc();\n            });\n        }\n    }\n\n    public List<ParameterDefinition<?>> getParameters() {\n        return List.of(\n            new ParameterDefinition<>(\"bootstrap.servers\", \"Kafka bootstrap servers\", String.class),\n            new ParameterDefinition<>(\"topic.name\", \"Name of the Kafka topic to write to\", String.class)\n        );\n    }\n\n    public Metadata metadata() {\n        return new Metadata(\"KafkaSink\", \"Writes data to a Kafka topic with configurable parameters.\");\n    }\n\n    public void close() {\n        Subscription sub = subscription;\n        if (sub != null) {\n            sub.unsubscribe();\n        }\n        KafkaProducer<byte[], byte[]> producer = kafkaProducerAtomicRef.getAndSet(null);\n        if (producer != null) {\n            producer.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Create a Java class that implements a Kafka producer for sending partition metric samples to a Kafka topic, with configurable producer properties and error handling.\n\nClass Description: KafkaSampleProducer is a class that provides functionality to create and manage a Kafka producer for sending partition metric samples. It handles producer configuration, message sending, and proper resource cleanup.\n\nAttributes:\n- PRODUCER_CLOSE_TIMEOUT: [Duration] - The maximum time to wait for the producer to close gracefully\n- _shutdown: [boolean] - Flag indicating whether the producer should be shut down\n- _producer: [Producer<byte[], byte[]>] - The Kafka producer instance\n\nMethods:\n- createProducer: [void]([Map<String, ?> config, String producerClientId]) -> [void] - Configures and creates a Kafka producer instance with the given configuration and client ID\n- storePartitionMetricSamples: [AtomicInteger]([MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log]) -> [AtomicInteger] - Sends partition metric samples to the specified Kafka topic and returns the count of successfully sent samples\n- close: [void]([]) -> [void] - Gracefully shuts down the Kafka producer with a timeout",
    "Canonical_solution": "import com.linkedin.kafka.cruisecontrol.monitor.sampling.holder.PartitionMetricSample;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\n\nimport static com.linkedin.kafka.cruisecontrol.monitor.sampling.SamplingUtils.bootstrapServers;\n\npublic class KafkaSampleProducer {\n    protected static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofMinutes(3);\n    protected volatile boolean _shutdown = false;\n    protected Producer<byte[], byte[]> _producer;\n\n    protected void createProducer(Map<String, ?> config, String producerClientId) {\n        Properties producerProps = new Properties();\n        producerProps.putAll(config);\n        producerProps.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers(config));\n        producerProps.setProperty(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        producerProps.setProperty(ProducerConfig.LINGER_MS_CONFIG, \"30000\");\n        producerProps.setProperty(ProducerConfig.BATCH_SIZE_CONFIG, \"500000\");\n        producerProps.setProperty(ProducerConfig.BUFFER_MEMORY_CONFIG, \"67108864\");\n        producerProps.setProperty(ProducerConfig.RETRIES_CONFIG, \"5\");\n        producerProps.setProperty(ProducerConfig.COMPRESSION_TYPE_CONFIG, \"gzip\");\n        producerProps.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, config.get(\"reconnect.backoff.ms\").toString());\n        _producer = new KafkaProducer<>(producerProps);\n    }\n\n    static AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer,\n                                                   String partitionMetricSampleStoreTopic, Logger log) {\n        final AtomicInteger metricSampleCount = new AtomicInteger(0);\n        for (PartitionMetricSample sample : samples.partitionMetricSamples()) {\n            producer.send(new ProducerRecord<>(partitionMetricSampleStoreTopic, null, sample.sampleTime(), null, sample.toBytes()),\n                        (recordMetadata, e) -> {\n                            if (e == null) {\n                                metricSampleCount.incrementAndGet();\n                            } else {\n                                log.error(\"Failed to produce partition metric sample for {} of timestamp {} due to exception\",\n                                          sample.entity().tp(), sample.sampleTime(), e);\n                            }\n                        });\n        }\n        return metricSampleCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        _producer.close(PRODUCER_CLOSE_TIMEOUT);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class KafkaSampleProducer {\n\n    private static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofSeconds(30);\n    private boolean _shutdown = false;\n    private Producer<byte[], byte[]> _producer;\n\n    public void createProducer(Map<String, ?> config, String producerClientId) {\n        if (_producer != null && !_shutdown) {\n            throw new IllegalStateException(\"Producer is already created and not shutdown.\");\n        }\n        _shutdown = false;\n        ProducerConfig producerConfig = new ProducerConfig(config);\n        _producer = new KafkaProducer<>(producerConfig, new ByteArraySerializer(), new ByteArraySerializer());\n    }\n\n    public AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log) {\n        AtomicInteger successCount = new AtomicInteger(0);\n        samples.forEach(sample -> {\n            try {\n                ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(partitionMetricSampleStoreTopic, sample.getKey(), sample.getValue());\n                producer.send(record, (metadata, exception) -> {\n                    if (exception == null) {\n                        successCount.incrementAndGet();\n                    } else {\n                        log.error(\"Failed to send metric sample to Kafka\", exception);\n                    }\n                });\n            } catch (Exception e) {\n                log.error(\"Error preparing or sending metric sample\", e);\n            }\n        });\n        return successCount;\n    }\n\n    public void close() {\n        if (_producer != null && !_shutdown) {\n            try {\n                _producer.close(PRODUCER_CLOSE_TIMEOUT);\n            } finally {\n                _shutdown = true;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Create a KafkaTemplate class that provides a high-level abstraction for sending messages to Kafka topics, handling both transactional and non-transactional producers, and managing producer lifecycle.\n\nClass Description: The KafkaTemplate class is a Spring Kafka helper class that simplifies the process of sending messages to Kafka topics. It wraps a ProducerFactory and provides various methods for sending messages with different parameters. The class handles producer creation, message sending, and resource cleanup automatically.\n\nAttributes:\n- producerFactory: [ProducerFactory<K, V>] - The factory used to create Kafka producers\n- autoFlush: [boolean] - Flag indicating whether to automatically flush the producer after sending\n- transactional: [boolean] - Flag indicating whether the producer factory is transactional\n\nMethods:\n- send(String topic, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data to the specified topic without a key\n- send(String topic, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with a key to the specified topic\n- send(String topic, Integer partition, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with key and partition to the specified topic\n- send(ProducerRecord<K, V> record) -> [CompletableFuture<SendResult<K, V>>] - Sends a complete ProducerRecord\n- doSend(ProducerRecord<K, V> producerRecord) -> [CompletableFuture<SendResult<K, V>>] - Internal method that handles the actual sending logic\n- partitionsFor(String topic) -> [List<PartitionInfo>] - Returns partition information for the given topic\n- metrics() -> [Map<MetricName, ? extends Metric>] - Returns the producer metrics\n- closeProducer(Producer<K, V> producer, boolean inTx) -> [void] - Closes the producer unless in a transaction\n- getTheProducer() -> [Producer<K, V>] - Gets a producer instance (non-topic specific)\n- getTheProducer(String topic) -> [Producer<K, V>] - Gets a producer instance (optionally topic-specific)\n- inTransaction() -> [boolean] - Checks if currently in a transaction",
    "Canonical_solution": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.util.Assert;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Future;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this(producerFactory, false);\n    }\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush) {\n        Assert.notNull(producerFactory, \"'producerFactory' cannot be null\");\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = this.producerFactory.transactionCapable();\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, partition, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        Assert.notNull(record, \"'record' cannot be null\");\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(final ProducerRecord<K, V> producerRecord) {\n        final Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        final CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        Future<RecordMetadata> sendFuture = producer.send(producerRecord, (metadata, exception) -> {\n            if (exception == null) {\n                future.complete(new SendResult<>(producerRecord, metadata));\n            }\n            else {\n                future.completeExceptionally(\n                        new KafkaProducerException(producerRecord, \"Failed to send\", exception));\n            }\n            closeProducer(producer, this.transactional);\n        });\n        if (sendFuture.isDone()) {\n            try {\n                sendFuture.get();\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted\", e);\n            }\n            catch (ExecutionException e) {\n                throw new KafkaException(\"Send failed\", e.getCause());\n            }\n        }\n        if (this.autoFlush) {\n            producer.flush();\n        }\n        return future;\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.partitionsFor(topic);\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.metrics();\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    protected Producer<K, V> getTheProducer(@Nullable String topic) {\n        if (this.transactional) {\n            Assert.state(inTransaction(),\n                    \"No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation\");\n            return this.producerFactory.createProducer();\n        }\n        else {\n            return this.producerFactory.createProducer();\n        }\n    }\n\n    public boolean inTransaction() {\n        return this.transactional && TransactionSynchronizationManager.getResource(this.producerFactory) != null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.*;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.util.concurrent.ListenableFuture;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private boolean autoFlush = false;\n    private boolean transactional = false;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this.producerFactory = producerFactory;\n        this.transactional = producerFactory.isTransactional();\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, V data) {\n        return send(new ProducerRecord<>(topic, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, V data) {\n        return send(new ProducerRecord<>(topic, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, V data) {\n        return send(new ProducerRecord<>(topic, partition, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(ProducerRecord<K, V> producerRecord) {\n        Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        ListenableFuture<SendResult<K, V>> future = producer.send(producerRecord);\n        if (autoFlush) {\n            producer.flush();\n        }\n        return future.completable();\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer(topic);\n        List<PartitionInfo> infoList = producer.partitionsFor(topic);\n        closeProducer(producer, inTransaction());\n        return infoList;\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        Map<MetricName, ? extends Metric> metricsMap = producer.metrics();\n        closeProducer(producer, inTransaction());\n        return metricsMap;\n    }\n\n    public void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx && !transactional) {\n            producer.close();\n        }\n    }\n\n    public Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    public Producer<K, V> getTheProducer(String topic) {\n        return producerFactory.createProducer();\n    }\n\n    public boolean inTransaction() {\n        return transactional && TransactionSynchronizationManager.isActualTransactionActive();\n    }\n\n    public boolean isAutoFlush() {\n        return autoFlush;\n    }\n\n    public void setAutoFlush(boolean autoFlush) {\n        this.autoFlush = autoFlush;\n    }\n}"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a Java class that manages job prefix files with thread-safe file operations, including creation, locking, and cleanup.\n\nClass Description: JobPrefixFile is a thread-safe utility class that manages temporary files with unique prefixes. It provides file locking mechanisms to prevent concurrent access issues and handles proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- prefix: String - The unique prefix used for the file name\n- file: Path - The path to the managed file\n- channel: FileChannel - The file channel for file operations\n- lock: FileLock - The lock object for thread-safe file access\n\nMethods:\n- create(Path directory) -> JobPrefixFile - Static factory method to create a new instance with default prefix in specified directory\n- create(String prefix, Path directory) -> JobPrefixFile - Static factory method to create a new instance with custom prefix in specified directory\n- tryFromExistingFile(Path file) -> JobPrefixFile - Static method to create an instance from an existing file if it can be locked\n- delete() -> void - Deletes the managed file and releases resources\n- prefix() -> String - Returns the file prefix\n- release() -> void - Releases the file lock and closes the channel\n- close() -> void - Calls release() to implement AutoCloseable interface\n- deleteIfExists(Path file) -> void - Helper method to safely delete a file if it exists\n- close(AutoCloseable closeable) -> void - Static helper method to safely close closeable resources",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass JobPrefixFile implements AutoCloseable {\n\n  private static final Logger log = LoggerFactory.getLogger(JobPrefixFile.class);\n\n  private final String prefix;\n  private final Path file;\n\n  private FileChannel channel;\n  private FileLock lock;\n\n  public static JobPrefixFile create(Path directory) throws IOException {\n    return create(null, directory);\n  }\n\n  public static JobPrefixFile create(final String prefix, final Path directory)\n      throws IOException {\n    return new JobPrefixFile(prefix, directory);\n  }\n\n  public static JobPrefixFile tryFromExistingFile(final Path file) throws IOException {\n    Preconditions.checkNotNull(file);\n    final FileChannel channel = FileChannel.open(file, WRITE);\n    final FileLock lock;\n\n    try {\n      lock = channel.tryLock();\n    } catch (OverlappingFileLockException e) {\n      close(channel);\n      return null;\n    } catch (Exception e) {\n      close(channel);\n      throw e;\n    }\n\n    if (lock == null) {\n      close(channel);\n      return null;\n    }\n\n    return new JobPrefixFile(file, channel, lock);\n  }\n\n  private JobPrefixFile(final String prefix, final Path directory) throws IOException {\n    Preconditions.checkNotNull(directory);\n    this.prefix = prefix == null\n                  ? \"tmp-\" + new SimpleDateFormat(\"yyyyMMdd\").format(new Date()) + \"-\"\n                    + toHexString(ThreadLocalRandom.current().nextInt())\n                  : prefix;\n\n    Files.createDirectories(directory);\n    file = directory.resolve(this.prefix);\n    final Path tmp = directory.resolve(this.prefix + \".tmp\");\n    try {\n      this.channel = FileChannel.open(tmp, CREATE_NEW, WRITE);\n      this.lock = channel.lock();\n      Files.move(tmp, file);\n    } catch (Exception e) {\n      deleteIfExists(tmp);\n      deleteIfExists(file);\n      close(this.channel);\n      throw new RuntimeException(\"Failed to create job prefix file \" + file, e);\n    }\n  }\n\n  private JobPrefixFile(final Path file, final FileChannel channel, final FileLock lock)\n      throws IOException, IllegalStateException {\n    this.file = Preconditions.checkNotNull(file, \"file\");\n    this.channel = Preconditions.checkNotNull(channel, \"channel\");\n    this.lock = Preconditions.checkNotNull(lock, \"lock\");\n    this.prefix = file.getFileName().toString();\n  }\n\n  public void delete() {\n    release();\n    deleteIfExists(file);\n  }\n\n  private void deleteIfExists(Path file) {\n    if (file != null) {\n      try {\n        Files.deleteIfExists(file);\n      } catch (Exception e) {\n        log.warn(\"Failed to delete file {}\", file, e);\n      }\n    }\n  }\n\n  public String prefix() {\n    return prefix;\n  }\n\n  public void release() {\n    close(lock);\n    lock = null;\n    close(channel);\n    channel = null;\n  }\n\n  @Override\n  public void close() {\n    release();\n  }\n\n  private static void close(final AutoCloseable closeable) {\n    if (closeable != null) {\n      try {\n        closeable.close();\n      } catch (Exception e) {\n        log.debug(\"Failed to close {}\", closeable.getClass().getSimpleName(), e);\n      }\n    }\n  }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.channels.*;\nimport java.nio.file.*;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class JobPrefixFile implements AutoCloseable {\n    private static final ReentrantLock globalLock = new ReentrantLock();\n    private final String prefix;\n    private final Path file;\n    private final FileChannel channel;\n    private final FileLock lock;\n\n    private JobPrefixFile(String prefix, Path file, FileChannel channel, FileLock lock) {\n        this.prefix = prefix;\n        this.file = file;\n        this.channel = channel;\n        this.lock = lock;\n    }\n\n    public static JobPrefixFile create(Path directory) throws IOException {\n        return create(\"job_\", directory);\n    }\n\n    public static JobPrefixFile create(String prefix, Path directory) throws IOException {\n        globalLock.lock();\n        try {\n            Path tempFile = Files.createTempFile(directory, prefix, \".tmp\");\n            FileChannel channel = FileChannel.open(tempFile, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            FileLock lock = channel.lock();\n            return new JobPrefixFile(prefix, tempFile, channel, lock);\n        } finally {\n            globalLock.unlock();\n        }\n    }\n\n    public static JobPrefixFile tryFromExistingFile(Path file) throws IOException {\n        if (!Files.exists(file)) {\n            throw new IllegalArgumentException(\"File does not exist: \" + file);\n        }\n        globalLock.lock();\n        try {\n            FileChannel channel = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            FileLock lock = channel.tryLock();\n            if (lock == null) {\n                channel.close();\n                throw new IOException(\"Could not acquire lock on file: \" + file);\n            }\n            String prefix = file.getFileName().toString().split(\"\\\\.\")[0];\n            return new JobPrefixFile(prefix, file, channel, lock);\n        } catch (IOException e) {\n            throw new IOException(\"Error initializing existing file: \" + file, e);\n        }\n    }\n\n    public void delete() throws IOException {\n        release();\n        Files.deleteIfExists(file);\n    }\n\n    public String prefix() {\n        return prefix;\n    }\n\n    public void release() throws IOException {\n        if (lock != null && lock.isValid()) {\n            lock.release();\n        }\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        release();\n    }\n\n    public static void deleteIfExists(Path file) throws IOException {\n        try {\n            if (file != null && Files.exists(file)) {\n                Files.delete(file);\n            }\n        } catch (IOException e) {\n            throw new IOException(\"Error deleting file: \" + file, e);\n        }\n    }\n\n    public static void close(AutoCloseable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (Exception e) {\n                // Ignore exceptions during close\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Create a wrapper class for Kafka Producer to simplify message sending operations and resource management.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for interacting with a Kafka Producer, handling message sending, flushing, and proper resource cleanup. It encapsulates a KafkaProducer instance and delegates operations to it.\n\nAttributes:\n- producer: Producer<K, V> - The underlying Kafka Producer instance that handles actual message production\n\nMethods:\n- Constructor: KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) -> void - Initializes the wrapper with Kafka configuration, key serializer, and value serializer\n- send: send(ProducerRecord<K, V> record) -> Future<RecordMetadata> - Sends a message to Kafka without a callback\n- send: send(ProducerRecord<K, V> record, Callback callback) -> Future<RecordMetadata> - Sends a message to Kafka with a callback\n- flush: flush() -> void - Flushes any buffered messages\n- close: close() -> void - Closes the producer immediately\n- close: close(Duration timeout) -> void - Closes the producer with a specified timeout",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.serialization.Serializer;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, \n                              Serializer<K> keySerializer, \n                              Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.common.serialization.Serializer;\nimport org.apache.kafka.clients.producer.*;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> implements Producer<K, V> {\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    @Override\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    @Override\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    @Override\n    public void flush() {\n        producer.flush();\n    }\n\n    @Override\n    public void close() {\n        producer.close();\n    }\n\n    @Override\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n\n    @Override\n    public void initTransactions() {\n        producer.initTransactions();\n    }\n\n    @Override\n    public void beginTransaction() throws ProducerFencedException {\n        producer.beginTransaction();\n    }\n\n    @Override\n    public void sendOffsetsToTransaction(Map<TopicPartition, OffsetAndMetadata> offsets, String consumerGroupId) throws ProducerFencedException {\n        producer.sendOffsetsToTransaction(offsets, consumerGroupId);\n    }\n\n    @Override\n    public void commitTransaction() throws ProducerFencedException {\n        producer.commitTransaction();\n    }\n\n    @Override\n    public void abortTransaction() throws ProducerFencedException {\n        producer.abortTransaction();\n    }\n\n    @Override\n    public ProducerMetrics metrics() {\n        return producer.metrics();\n    }\n\n    @Override\n    public List<PartitionInfo> partitionsFor(String topic) {\n        return producer.partitionsFor(topic);\n    }\n\n    @Override\n    public Map<MetricName, ? extends Metric> metrics(Map<NamedThreadFactory.MetricName, NamedThreadFactory.Metric> metricNames) {\n        return producer.metrics(metricNames);\n    }\n}"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a Java class that implements an RPC server using Netty framework for handling network communication, managing connections, and processing RPC requests.\n\nClass Description: RpcServer is an abstract remoting server implementation that provides RPC functionality using Netty. It handles server initialization, startup, shutdown, and connection management while supporting various network configurations and user-defined processors.\n\nAttributes:\n- logger: Logger - Logger instance for server operations\n- bootstrap: ServerBootstrap - Netty server bootstrap configuration\n- channelFuture: ChannelFuture - Future representing server channel binding\n- userProcessors: ConcurrentHashMap<String, UserProcessor<?>> - Map of registered user processors\n- bossGroup: EventLoopGroup - Event loop group for accepting connections\n- workerGroup: EventLoopGroup - Event loop group for handling connections\n- addressParser: RemotingAddressParser - Parser for remote addresses\n- connectionManager: DefaultServerConnectionManager - Manager for server connections\n- rpcRemoting: RpcRemoting - RPC communication handler\n- codec: Codec - Protocol codec for encoding/decoding messages\n\nMethods:\n- RpcServer(int port, boolean manageConnection) -> void - Constructor that initializes server with port and connection management flag\n- doInit() -> void - Initializes server components including bootstrap configuration and pipeline setup\n- doStart() -> boolean - Starts the server and binds to specified port\n- doStop() -> boolean - Stops the server and releases resources\n- registerUserProcessor(UserProcessor<?> processor) -> void - Registers a user-defined processor for handling requests\n- invokeSync(Connection conn, Object request, int timeoutMillis) -> Object - Synchronously invokes RPC call with specified timeout",
    "Canonical_solution": "import com.alipay.remoting.*;\nimport com.alipay.remoting.config.BoltGenericOption;\nimport com.alipay.remoting.config.BoltServerOption;\nimport com.alipay.remoting.rpc.protocol.UserProcessor;\nimport com.alipay.remoting.util.NettyEventLoopUtil;\nimport com.alipay.remoting.util.RemotingUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.buffer.UnpooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.flush.FlushConsolidationHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\n\npublic class RpcServer extends AbstractRemotingServer {\n\n    private static final Logger logger = LoggerFactory.getLogger(\"RpcRemoting\");\n    private ServerBootstrap bootstrap;\n    private ChannelFuture channelFuture;\n    private ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>(4);\n    private final EventLoopGroup bossGroup = NettyEventLoopUtil.newEventLoopGroup(1, new NamedThreadFactory(\"Rpc-netty-server-boss\", false));\n    private static final EventLoopGroup workerGroup = NettyEventLoopUtil.newEventLoopGroup(Runtime.getRuntime().availableProcessors() * 2, new NamedThreadFactory(\"Rpc-netty-server-worker\", true));\n    private RemotingAddressParser addressParser;\n    private DefaultServerConnectionManager connectionManager;\n    protected RpcRemoting rpcRemoting;\n    private Codec codec = new RpcCodec();\n\n    public RpcServer(int port, boolean manageConnection) {\n        super(port);\n        if (manageConnection) {\n            option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH, true);\n        }\n    }\n\n    @Override\n    protected void doInit() {\n        if (this.addressParser == null) {\n            this.addressParser = new RpcAddressParser();\n        }\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH)) {\n            this.connectionManager = new DefaultServerConnectionManager(new RandomSelectStrategy(this));\n            this.connectionManager.startup();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n        this.bootstrap.group(bossGroup, workerGroup)\n            .channel(NettyEventLoopUtil.getServerSocketChannelClass())\n            .option(ChannelOption.SO_BACKLOG, ConfigManager.tcp_so_backlog())\n            .option(ChannelOption.SO_REUSEADDR, ConfigManager.tcp_so_reuseaddr())\n            .childOption(ChannelOption.TCP_NODELAY, ConfigManager.tcp_nodelay())\n            .childOption(ChannelOption.SO_KEEPALIVE, ConfigManager.tcp_so_keepalive());\n\n        if (ConfigManager.netty_buffer_pooled()) {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n        } else {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT);\n        }\n\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel channel) {\n                ChannelPipeline pipeline = channel.pipeline();\n                pipeline.addLast(\"decoder\", codec.newDecoder());\n                pipeline.addLast(\"encoder\", codec.newEncoder());\n                if (ConfigManager.tcp_idle_switch()) {\n                    pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, ConfigManager.tcp_server_idle(), TimeUnit.MILLISECONDS));\n                }\n                if (option(BoltServerOption.NETTY_FLUSH_CONSOLIDATION)) {\n                    pipeline.addLast(\"flushConsolidationHandler\", new FlushConsolidationHandler(1024, true));\n                }\n                pipeline.addLast(\"handler\", new RpcHandler(true, userProcessors));\n            }\n        });\n    }\n\n    @Override\n    protected boolean doStart() throws InterruptedException {\n        this.channelFuture = this.bootstrap.bind(new InetSocketAddress(ip(), port())).sync();\n        if (port() == 0 && channelFuture.isSuccess()) {\n            setLocalBindingPort(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n        }\n        return this.channelFuture.isSuccess();\n    }\n\n    @Override\n    protected boolean doStop() {\n        if (null != this.channelFuture) {\n            this.channelFuture.channel().close();\n        }\n        this.bossGroup.shutdownGracefully();\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH) && null != this.connectionManager) {\n            this.connectionManager.shutdown();\n        }\n        return true;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        UserProcessorRegisterHelper.registerUserProcessor(processor, this.userProcessors);\n    }\n\n    public Object invokeSync(final Connection conn, final Object request, final int timeoutMillis) throws RemotingException, InterruptedException {\n        return this.rpcRemoting.invokeSync(conn, request, null, timeoutMillis);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic abstract class RpcServer {\n    protected final Logger logger = LoggerFactory.getLogger(getClass());\n    protected ServerBootstrap bootstrap;\n    protected ChannelFuture channelFuture;\n    protected final ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>();\n    protected EventLoopGroup bossGroup;\n    protected EventLoopGroup workerGroup;\n    protected RemotingAddressParser addressParser;\n    protected DefaultServerConnectionManager connectionManager;\n    protected RpcRemoting rpcRemoting;\n    protected Codec codec;\n    private final int port;\n    private final boolean manageConnection;\n\n    public RpcServer(int port, boolean manageConnection) {\n        this.port = port;\n        this.manageConnection = manageConnection;\n    }\n\n    protected void doInit() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new RpcServerInitializer(userProcessors, codec, rpcRemoting, connectionManager, addressParser));\n\n        if (manageConnection) {\n            connectionManager = new DefaultServerConnectionManager();\n        }\n    }\n\n    protected boolean doStart() {\n        try {\n            channelFuture = bootstrap.bind(port).sync();\n            logger.info(\"RPC server started on port {}\", port);\n            return true;\n        } catch (InterruptedException e) {\n            logger.error(\"Failed to start RPC server\", e);\n            return false;\n        }\n    }\n\n    protected boolean doStop() {\n        boolean success = true;\n        if (channelFuture != null && channelFuture.channel().isActive()) {\n            try {\n                channelFuture.channel().closeFuture().sync();\n            } catch (InterruptedException e) {\n                logger.warn(\"Interrupted while waiting for channel to close\", e);\n                success = false;\n            }\n        }\n\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n\n        if (connectionManager != null) {\n            connectionManager.shutdown();\n        }\n\n        logger.info(\"RPC server stopped\");\n        return success;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        if (processor == null || processor.getProcessorName() == null) {\n            throw new IllegalArgumentException(\"Invalid processor\");\n        }\n        userProcessors.put(processor.getProcessorName(), processor);\n    }\n\n    public Object invokeSync(Connection conn, Object request, int timeoutMillis) throws Exception {\n        return rpcRemoting.invokeSync(conn.getChannel(), request, timeoutMillis);\n    }\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a function that deobfuscates a Java stack trace by processing it through an external retrace tool, handling both success and failure cases appropriately.\n\nFunction Description: The function takes a Throwable object, converts its stack trace to a string, and attempts to deobfuscate it using an external retrace script (either .bat for Windows or .sh for other systems). The function handles temporary file creation for input, process execution, and output processing, with proper error handling and fallback to the original stack trace if deobfuscation fails.\n\nInput: \n- t: Throwable - The exception/throwable whose stack trace needs to be deobfuscated\n\nOutput: \n- String - The deobfuscated stack trace if successful, or the original stack trace if deobfuscation fails or isn't possible\n\nNote: The function relies on an environment variable XPIPE_MAPPING for the mapping file path and uses system-specific retrace scripts (retrace.bat or retrace.sh). It also includes a canDeobfuscate() check (implementation not shown) to determine if deobfuscation should be attempted.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\npublic static String deobfuscateToString(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    String stackTrace = sw.toString();\n    stackTrace = stackTrace.replaceAll(\"at .+/(.+)\", \"at $1\");\n\n    try {\n        if (!canDeobfuscate()) {\n            return stackTrace;\n        }\n\n        var file = Files.createTempFile(\"xpipe_stracktrace\", null);\n        Files.writeString(file, stackTrace);\n        var proc = new ProcessBuilder(\n                        \"retrace.\" + (OsType.getLocal().equals(OsType.WINDOWS) ? \"bat\" : \"sh\"),\n                        System.getenv(\"XPIPE_MAPPING\"),\n                        file.toString())\n                .redirectErrorStream(true);\n        var active = proc.start();\n        var out = new String(active.getInputStream().readAllBytes())\n                .replaceAll(\"\\r\\n\", NewLine.LF.getNewLineString());\n        var code = active.waitFor();\n        if (code == 0) {\n            return out;\n        } else {\n            System.err.println(\"Deobfuscation failed: \" + out);\n        }\n    } catch (Exception ex) {\n        System.err.println(\"Deobfuscation failed\");\n        return stackTrace;\n    }\n\n    return stackTrace;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.nio.file.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class Deobfuscator {\n\n    private static final String XPIPE_MAPPING = System.getenv(\"XPIPE_MAPPING\");\n    private static final boolean CAN_DEOBFUSCATE = canDeobfuscate();\n\n    private static boolean canDeobfuscate() {\n        return XPIPE_MAPPING != null && Files.exists(Paths.get(XPIPE_MAPPING));\n    }\n\n    public static String deobfuscateStackTrace(Throwable t) {\n        if (t == null || !CAN_DEOBFUSCATE) {\n            return getStackTraceAsString(t);\n        }\n\n        String originalTrace = getStackTraceAsString(t);\n\n        try {\n            Path input = createTempFileWithContent(originalTrace);\n            Path output = Files.createTempFile(\"deobf-\", \".out\");\n\n            ProcessBuilder pb;\n            if (System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) {\n                pb = new ProcessBuilder(\"cmd.exe\", \"/c\", \"retrace.bat\", XPIPE_MAPPING, input.toString());\n            } else {\n                pb = new ProcessBuilder(\"./retrace.sh\", XPIPE_MAPPING, input.toString());\n            }\n            pb.redirectOutput(output.toFile());\n\n            Process process = pb.start();\n            boolean completed = process.waitFor(10, TimeUnit.SECONDS);\n\n            if (!completed || process.exitValue() != 0) {\n                return originalTrace;\n            }\n\n            String deobfuscatedTrace = new String(Files.readAllBytes(output));\n            return deobfuscatedTrace.isEmpty() ? originalTrace : deobfuscatedTrace;\n\n        } catch (Exception e) {\n            return originalTrace;\n        }\n    }\n\n    private static String getStackTraceAsString(Throwable t) {\n        if (t == null) return \"\";\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        t.printStackTrace(pw);\n        return sw.toString();\n    }\n\n    private static Path createTempFileWithContent(String content) throws IOException {\n        Path tempFile = Files.createTempFile(\"stack-\", \".txt\");\n        Files.write(tempFile, content.getBytes(), StandardOpenOption.WRITE);\n        return tempFile;\n    }\n}"
  },
  {
    "Task_id": 273,
    "Instruction": "Task Description: Create a Java class that extends the Reader abstract class to read files, with fallback to using system commands when direct file access fails (e.g., when running with restricted permissions).\n\nClass Description: FileReader is a Reader implementation that first attempts to read files directly, and if that fails (due to permission issues), it falls back to executing system commands (via su and cat/toolbox cat) to read the file contents. The class handles process creation, stream management, and proper cleanup.\n\nAttributes:\nmStream: InputStreamReader - The underlying input stream used for reading file contents, either from direct file access or process output\n\nMethods:\nFileReader: [Constructor](Shell shell, String file) -> [void] - Initializes the reader by attempting direct file access first, falling back to process-based reading if needed. Throws FileNotFoundException if neither method succeeds.\n- shell: Shell - Optional shell helper object to locate system commands\n- file: String - Path to the file to be read\n\nclose: close() -> [void] - Closes the underlying input stream. Throws IOException if the stream cannot be closed.\n\nread: read(char[] buffer, int offset, int count) -> [int] - Reads characters into a portion of an array from the underlying stream. Returns the number of characters read or -1 if end of stream is reached.\n- buffer: char[] - Destination buffer\n- offset: int - Offset at which to start storing characters\n- count: int - Maximum number of characters to read",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.nio.CharBuffer;\n\npublic class FileReader extends Reader {\n    protected InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        String filePath = new File(file).getAbsolutePath();\n\n        try {\n            mStream = new InputStreamReader(new FileInputStream(filePath));\n\n        } catch (FileNotFoundException e) {\n            String binary = shell != null ? shell.findCommand(\"cat\") : \"toolbox cat\";\n\n            try {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                Process process = builder.start();\n                mStream = new InputStreamReader(process.getInputStream());\n\n                DataOutputStream stdIn = new DataOutputStream(process.getOutputStream());\n                stdIn.write( (binary + \" '\" + filePath + \"'\\n\").getBytes() );\n                stdIn.write( (\"exit $?\\n\").getBytes() );\n                stdIn.flush();\n                stdIn.close();\n\n                Integer resultCode = process.waitFor();\n\n                if (!resultCode.equals(0)) {\n                    throw new FileNotFoundException(e.getMessage());\n                }\n\n            } catch (Throwable te) {\n                throw new FileNotFoundException(te.getMessage());\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        mStream.close();\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\n\npublic class FileReader extends Reader {\n    private InputStreamReader mStream;\n    private Process process;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        try {\n            mStream = new InputStreamReader(new FileInputStream(file), \"UTF-8\");\n        } catch (Exception e) {\n            try {\n                String command = \"su -c cat \" + file;\n                if (shell != null) {\n                    command = shell.getCatCommand(file);\n                }\n                process = Runtime.getRuntime().exec(command);\n                mStream = new InputStreamReader(process.getInputStream(), \"UTF-8\");\n            } catch (Exception ex) {\n                throw new FileNotFoundException(\"Cannot open file: \" + file);\n            }\n        }\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (mStream != null) {\n            mStream.close();\n        }\n        if (process != null) {\n            process.destroy();\n        }\n    }\n\n    public static class Shell {\n        public String getCatCommand(String file) {\n            return \"toolbox cat \" + file;\n        }\n    }\n}"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a Java class that implements shell command execution functionality, allowing for command input, output reading, and process management.\n\nClass Description: ProcessShell is a class that provides an interface for executing shell commands, managing the process lifecycle, and handling input/output streams. It extends AbstractShell and supports both regular and root command execution.\n\nAttributes:\n- mProcess: Process - The running process instance\n- mCommandOutputStream: DataOutputStream - Stream for writing commands to the process\n- mSucceedReader: BufferedReader - Reader for standard output stream\n- mErrorReader: BufferedReader - Reader for error output stream\n- mSucceedOutput: StringBuilder - Buffer for storing standard output\n- mErrorOutput: StringBuilder - Buffer for storing error output\n\nMethods:\n- init(String initialCommand) -> void - Initializes the shell process with the given command\n- exec(String command) -> void - Executes the given command in the shell\n- exit() -> void - Terminates the process and cleans up resources\n- exitAndWaitFor() -> void - Sends exit command, waits for process completion, then exits\n- waitFor() -> int - Waits for the process to complete and returns exit code\n- readAll() -> ProcessShell - Reads all available output (both standard and error)\n- readSucceedOutput() -> ProcessShell - Reads standard output\n- readErrorOutput() -> ProcessShell - Reads error output\n- getSucceedOutput() -> StringBuilder - Returns the standard output buffer\n- getErrorOutput() -> StringBuilder - Returns the error output buffer\n- getProcess() -> Process - Returns the process instance\n- getSucceedReader() -> BufferedReader - Returns the standard output reader\n- getErrorReader() -> BufferedReader - Returns the error output reader",
    "Canonical_solution": "import android.util.Log;\nimport com.stardust.autojs.runtime.api.AbstractShell;\nimport com.stardust.autojs.runtime.exception.ScriptInterruptedException;\nimport com.stardust.autojs.util.ProcessUtils;\nimport com.stardust.pio.UncheckedIOException;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ProcessShell extends AbstractShell {\n\n    private static final String TAG = \"ProcessShell\";\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput = new StringBuilder();\n    private StringBuilder mErrorOutput = new StringBuilder();\n\n    public ProcessShell() {\n    }\n\n    public ProcessShell(boolean root) {\n        super(root);\n    }\n\n    @Override\n    protected void init(String initialCommand) {\n        try {\n            mProcess = new ProcessBuilder(initialCommand).redirectErrorStream(true).start();\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Override\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command);\n            if (!command.endsWith(COMMAND_LINE_END)) {\n                mCommandOutputStream.writeBytes(COMMAND_LINE_END);\n            }\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void exit() {\n        if (mProcess != null) {\n            Log.d(TAG, \"exit: pid = \" + ProcessUtils.getProcessPid(mProcess));\n            mProcess.destroy();\n            mProcess = null;\n        }\n        if (mSucceedReader != null) {\n            try {\n                mSucceedReader.close();\n            } catch (IOException ignored) {\n            }\n            mSucceedReader = null;\n        }\n        if (mErrorReader != null) {\n            try {\n                mErrorReader.close();\n            } catch (IOException ignored) {\n            }\n            mErrorReader = null;\n        }\n    }\n\n    @Override\n    public void exitAndWaitFor() {\n        exec(COMMAND_EXIT);\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public ProcessShell readAll() {\n        return readSucceedOutput().readErrorOutput();\n    }\n\n    public ProcessShell readSucceedOutput() {\n        read(mSucceedReader, mSucceedOutput);\n        return this;\n    }\n\n    private void read(BufferedReader reader, StringBuilder sb) {\n        try {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public ProcessShell readErrorOutput() {\n        read(mErrorReader, mErrorOutput);\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\n\npublic class ProcessShell extends AbstractShell {\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput;\n    private StringBuilder mErrorOutput;\n\n    public ProcessShell() {\n        mSucceedOutput = new StringBuilder();\n        mErrorOutput = new StringBuilder();\n    }\n\n    public void init(String initialCommand) throws IOException {\n        mProcess = Runtime.getRuntime().exec(initialCommand);\n        setupStreams();\n    }\n\n    private void setupStreams() {\n        mCommandOutputStream = new DataOutputStream(new BufferedOutputStream(mProcess.getOutputStream()));\n        mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n        mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n    }\n\n    public void exec(String command) throws IOException {\n        if (mCommandOutputStream != null) {\n            mCommandOutputStream.writeBytes(command + \"\\n\");\n            mCommandOutputStream.flush();\n        }\n    }\n\n    public void exit() {\n        try {\n            if (mCommandOutputStream != null) {\n                mCommandOutputStream.close();\n            }\n            if (mSucceedReader != null) {\n                mSucceedReader.close();\n            }\n            if (mErrorReader != null) {\n                mErrorReader.close();\n            }\n            if (mProcess != null) {\n                mProcess.destroy();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exitAndWaitFor() {\n        try {\n            exec(\"exit\");\n            waitFor();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            exit();\n        }\n    }\n\n    public int waitFor() throws InterruptedException {\n        return mProcess != null ? mProcess.waitFor() : -1;\n    }\n\n    public ProcessShell readAll() {\n        readSucceedOutput();\n        readErrorOutput();\n        return this;\n    }\n\n    public ProcessShell readSucceedOutput() {\n        String line;\n        try {\n            while ((line = mSucceedReader.readLine()) != null) {\n                mSucceedOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public ProcessShell readErrorOutput() {\n        String line;\n        try {\n            while ((line = mErrorReader.readLine()) != null) {\n                mErrorOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}"
  },
  {
    "Task_id": 279,
    "Instruction": "Task Description: Create a Java class that facilitates interaction with external processes through command execution, providing methods for writing input, executing commands, and retrieving results, with support for timeout handling and resource cleanup.\n\nClass Description: The Command class encapsulates functionality for executing and interacting with external processes. It handles process creation, input/output stream management, command execution, and result collection, with features for line-based input, process termination, and timeout control.\n\nAttributes:\n\nprocess: [Process] - The running external process instance\nstdIn: [OutputStream] - Stream for writing input to the process\nstdOut: [File] - Temporary file storing the process's standard output\nstdErr: [File] - Temporary file storing the process's error output\nnextLine: [String] - Line separator string for command input\nexit: [String] - Command string to terminate the process\ncharset: [Charset] - Character encoding for input/output\nstartTime: [LocalDateTime] - Timestamp when the process was started\n\nMethods:\n\nof: [of(String init)] -> [Command] - Creates a Command instance with default settings\nof: [of(String init, Charset charset)] -> [Command] - Creates a Command instance with specified charset\nof: [of(String init, String nextLine, String exit, Charset charset)] -> [Command] - Creates a Command instance with custom settings\nwrite: [write(String str)] -> [Command] - Writes a string to the process's input stream\nline: [line()] -> [Command] - Writes a line separator to the process's input stream\nexit: [exit()] -> [Command] - Sends the exit command to terminate the process\nexec: [exec(String str)] -> [Command] - Executes a command string (writes input and adds line separator)\nresult: [result()] -> [CommandResult] - Waits for process completion and returns results\nresult: [result(long millis)] -> [CommandResult] - Waits with timeout for process completion\nclose: [close()] -> [void] - Terminates the process and releases resources",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.time.LocalDateTime;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\n\npublic final class Command {\n\n    public static final String NEXT_LINE = SystemUtils.lineSeparator();\n    public static final String EXIT_COMMAND = \"exit\";\n\n    private final Process process;\n    private final OutputStream stdIn;\n    private final File stdOut;\n    private final File stdErr;\n    private final String nextLine;\n    private final String exit;\n    private final Charset charset;\n    private final LocalDateTime startTime;\n\n    private Command(String init, String nextLine, String exit, Charset charset) throws IOException {\n        if (!StringUtils.hasText(init)) {\n            throw new IllegalArgumentException(\"Empty init\");\n        }\n        StringTokenizer st = new StringTokenizer(init);\n        String[] cmdArray = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++) {\n            cmdArray[i] = st.nextToken();\n        }\n\n        this.stdOut = FileUtils.createTemp();\n        this.stdErr = FileUtils.createTemp();\n\n        ProcessBuilder builder = new ProcessBuilder(cmdArray).redirectError(this.stdErr).redirectOutput(this.stdOut);\n        this.process = builder.start();\n        this.stdIn = this.process.getOutputStream();\n        this.nextLine = nextLine;\n        this.exit = exit;\n        this.charset = charset;\n        this.startTime = LocalDateTime.now();\n    }\n\n    public static Command of(String init) throws IOException {\n        return of(init, SystemUtils.charset());\n    }\n\n    public static Command of(String init, Charset charset) throws IOException {\n        return of(init, NEXT_LINE, EXIT_COMMAND, charset);\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) throws IOException {\n        return new Command(init, nextLine, exit, charset);\n    }\n\n    public Command write(String str) throws IOException {\n        this.stdIn.write(str.getBytes(this.charset));\n        this.stdIn.flush();\n        return this;\n    }\n\n    public Command line() throws IOException {\n        return write(this.nextLine);\n    }\n\n    public Command exit() throws IOException {\n        write(this.exit);\n        return line();\n    }\n\n    public Command exec(String str) throws IOException {\n        write(str);\n        return line();\n    }\n\n    public CommandResult result() throws InterruptedException {\n        this.process.waitFor();\n        return CommandResult.of(this.stdOut, this.stdErr, this.startTime, LocalDateTime.now(), this.charset);\n    }\n\n    public CommandResult result(long millis) throws InterruptedException, CommandTimeoutException {\n        if (this.process.waitFor(millis, TimeUnit.MILLISECONDS)) {\n            return result();\n        }\n        this.process.destroyForcibly();\n        throw new CommandTimeoutException();\n    }\n\n    public void close() {\n        this.process.destroy();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.nio.charset.Charset;\nimport java.nio.file.*;\nimport java.time.LocalDateTime;\nimport java.util.concurrent.*;\nimport java.util.function.Consumer;\n\npublic class Command {\n    private Process process;\n    private OutputStream stdIn;\n    private File stdOut;\n    private File stdErr;\n    private String nextLine;\n    private String exit;\n    private Charset charset;\n    private LocalDateTime startTime;\n\n    private Command(Process process, String nextLine, String exit, Charset charset) {\n        this.process = process;\n        this.stdIn = process.getOutputStream();\n        this.nextLine = nextLine;\n        this.exit = exit;\n        this.charset = charset;\n        this.startTime = LocalDateTime.now();\n\n        try {\n            this.stdOut = File.createTempFile(\"stdout\", \".log\");\n            this.stdErr = File.createTempFile(\"stderr\", \".log\");\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static Command of(String init) {\n        return of(init, Charset.defaultCharset());\n    }\n\n    public static Command of(String init, Charset charset) {\n        try {\n            Process process = Runtime.getRuntime().exec(init);\n            return new Command(process, \"\\n\", \"exit\\n\", charset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) {\n        try {\n            Process process = Runtime.getRuntime().exec(init);\n            return new Command(process, nextLine, exit, charset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public Command write(String str) {\n        try {\n            stdIn.write(str.getBytes(charset));\n            stdIn.flush();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        return this;\n    }\n\n    public Command line() {\n        return write(nextLine);\n    }\n\n    public Command exit() {\n        return write(exit).line();\n    }\n\n    public Command exec(String str) {\n        return write(str).line();\n    }\n\n    public CommandResult result() {\n        return result(0);\n    }\n\n    public CommandResult result(long millis) {\n        try {\n            boolean completed = process.waitFor(millis, TimeUnit.MILLISECONDS);\n            if (!completed) {\n                process.destroyForcibly();\n            }\n\n            String stdout = Files.readString(stdOut.toPath(), charset);\n            String stderr = Files.readString(stdErr.toPath(), charset);\n\n            int exitCode = process.exitValue();\n            return new CommandResult(stdout, stderr, exitCode, !completed);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            close();\n        }\n    }\n\n    public void close() {\n        process.destroy();\n        stdOut.delete();\n        stdErr.delete();\n    }\n\n    public static class CommandResult {\n        private final String stdout;\n        private final String stderr;\n        private final int exitCode;\n        private final boolean timedOut;\n\n        public CommandResult(String stdout, String stderr, int exitCode, boolean timedOut) {\n            this.stdout = stdout;\n            this.stderr = stderr;\n            this.exitCode = exitCode;\n            this.timedOut = timedOut;\n        }\n\n        public String getStdout() {\n            return stdout;\n        }\n\n        public String getStderr() {\n            return stderr;\n        }\n\n        public int getExitCode() {\n            return exitCode;\n        }\n\n        public boolean isTimedOut() {\n            return timedOut;\n        }\n    }\n}"
  },
  {
    "Task_id": 285,
    "Instruction": "Task Description: Create a function that retrieves the version of the Java compiler installed on the system by executing the 'javac -version' command and capturing its output.\n\nFunction Description: The function uses Java's ProcessBuilder to launch an external process running the 'javac -version' command. It captures the command's output (which is redirected from stderr to stdout), reads the first line of output, and returns it as the version string. If any errors occur during this process, the function returns \"unknown\".\n\nInput: None (The function takes no input parameters)\n\nOutput: String - Returns the version string output by the 'javac -version' command (e.g., \"javac 1.8.0_291\"), or \"unknown\" if an error occurs during execution.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.lang.ProcessBuilder;\n\nprivate String getJavaCompilerVersion() {\n    ProcessBuilder pb = new ProcessBuilder(\"javac\", \"-version\");\n    pb.redirectErrorStream(true);\n\n    BufferedReader in = null;\n    try {\n        Process process = pb.start();\n        in = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String buffer = in.readLine();\n        process.waitFor();\n        return buffer;\n    } catch (Exception e) {\n        return \"unknown\";\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class JavaCompilerVersion {\n\n    public static String getJavaCompilerVersion() {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"javac\", \"-version\");\n            processBuilder.redirectErrorStream(true); // Merge stderr and stdout\n            Process process = processBuilder.start();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String versionLine = reader.readLine();\n\n            if (versionLine != null && !versionLine.trim().isEmpty()) {\n                return versionLine;\n            }\n        } catch (IOException e) {\n            // Intentionally left blank; fall through to return \"unknown\"\n        }\n        return \"unknown\";\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getJavaCompilerVersion());\n    }\n}"
  },
  {
    "Task_id": 286,
    "Instruction": "Task Description: Create a Java class that manages an interactive shell process (either regular or root) with proper stream handling, command execution, and event notification capabilities.\n\nClass Description: The ShellStream class provides an interface to execute commands in a shell process (sh or su) while managing input/output streams and notifying listeners about process events. It handles command execution synchronization, stream monitoring, and process lifecycle management.\n\nAttributes:\n- mConnection: Process - The running shell process instance\n- mStdInput: DataOutputStream - Stream for writing commands to the process\n- mStdOutput: BufferedReader - Stream for reading process output\n- mStdOutputWorker: Thread - Worker thread for monitoring output stream\n- mListener: OnStreamListener - Callback interface for process events\n- mCounter: Counter - Thread-safe counter for active commands\n- mLock: Object - Synchronization lock object\n- mIsActive: Boolean - Flag indicating if the process is active\n- mIsRoot: Boolean - Flag indicating if using root shell (su)\n- mCommandEnd: String - Unique marker for command termination\n\nMethods:\n- ShellStream(Boolean requestRoot, OnStreamListener listener) -> void - Constructor that initializes the shell process (root or regular) and sets up stream handlers\n- execute(String command) -> void - Executes a shell command asynchronously and tracks its completion\n- waitFor() -> Boolean - Waits indefinitely for all commands to complete\n- waitFor(Integer timeout) -> Boolean - Waits with timeout for all commands to complete\n- waitFor(Integer timeout, Integer index) -> Boolean - Internal wait method with timeout and counter adjustment\n- isActive() -> Boolean - Returns if the shell process is active\n- isRunning() -> Boolean - Returns if any commands are currently executing\n- isRoot() -> Boolean - Returns if using root shell\n- destroy() -> void - Cleanly terminates the shell process and releases resources\n\nNested Interfaces:\n- OnStreamListener: Interface for process event callbacks\n  - onStreamStart(): Notifies when command execution starts\n  - onStreamInput(String): Provides process output lines\n  - onStreamStop(Integer): Notifies when command completes with exit code\n  - onStreamDied(): Notifies when process terminates unexpectedly\n\nNested Classes:\n- Counter: Thread-safe counter implementation\n  - size() -> Integer: Gets current count\n  - encrease() -> Integer: Increments counter\n  - decrease() -> Integer: Decrements counter\n  - reset() -> void: Resets counter to zero",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport android.util.Log;\n\npublic class ShellStream {\n    public static final String TAG = Common.TAG + \".ShellStream\";\n    \n    protected Process mConnection;\n    protected DataOutputStream mStdInput;\n    protected BufferedReader mStdOutput;\n    protected Thread mStdOutputWorker;\n    protected OnStreamListener mListener;\n    protected final Counter mCounter = new Counter();\n    protected final Object mLock = new Object();\n    protected Boolean mIsActive = false;\n    protected Boolean mIsRoot = false;\n    protected String mCommandEnd = \"EOL:a00c38d8:EOL\";\n    \n    protected static class Counter {\n        private volatile Integer mCount = 0;\n        private volatile Object mLock = new Object();\n        \n        public Integer size() {\n            synchronized(mLock) {\n                return mCount;\n            }\n        }\n        \n        public Integer encrease() {\n            synchronized(mLock) {\n                return (mCount += 1);\n            }\n        }\n        \n        public Integer decrease() {\n            synchronized(mLock) {\n                return mCount > 0 ? (mCount -= 1) : (mCount = 0);\n            }\n        }\n        \n        public void reset() {\n            synchronized(mLock) {\n                mCount = 0;\n            }\n        }\n    }\n    \n    public static interface OnStreamListener {\n        public void onStreamStart();\n        public void onStreamInput(String outputLine);\n        public void onStreamStop(Integer resultCode);\n        public void onStreamDied();\n    }\n    \n    public ShellStream(Boolean requestRoot, OnStreamListener listener) {\n        try {\n            if(Common.DEBUG)Log.d(TAG, \"Construct: Establishing a new shell stream\");\n            \n            ProcessBuilder builder = new ProcessBuilder(requestRoot ? \"su\" : \"sh\");\n            builder.redirectErrorStream(true);\n            \n            mIsRoot = requestRoot;\n            mIsActive = true;\n            mListener = listener;\n            mConnection = builder.start();\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            \n            mStdOutputWorker = new Thread() {\n                @Override\n                public void run() {\n                    String output = null;\n                    \n                    try {\n                        while (mIsActive && (output = mStdOutput.readLine()) != null) {\n                            if (mListener != null && mCounter.size() > 0) {\n                                if (output.contains(mCommandEnd)) {\n                                    Integer result = 0;\n                                    \n                                    try {\n                                        if (output.startsWith(mCommandEnd)) {\n                                            result = Integer.parseInt(output.substring(mCommandEnd.length()+1));\n                                            \n                                        } else {\n                                            result = 1;\n                                        }\n                                        \n                                    } catch (Throwable e) {\n                                        Log.w(TAG, e.getMessage(), e);\n                                    }\n                                    \n                                    mListener.onStreamStop(result);\n                                    mCounter.decrease();\n                                    \n                                    synchronized(mLock) {\n                                        mLock.notifyAll();\n                                    }\n                                    \n                                } else {\n                                    mListener.onStreamInput(output);\n                                }\n                            }\n                        }\n                        \n                    } catch (IOException e) {\n                        Log.w(TAG, e.getMessage(), e); output = null;\n                    }\n                    \n                    if (output == null) {\n                        ShellStream.this.destroy();\n                    }\n                }\n            };\n            \n            mStdOutputWorker.start();\n            \n        } catch (IOException e) {\n            Log.w(TAG, e.getMessage(), e); mIsActive = false;\n        }\n    }\n    \n    public synchronized void execute(final String command) {\n        final Object lock = new Object();\n        \n        new Thread() {\n            @Override\n            public void run() {\n                mCounter.encrease();\n                \n                synchronized(lock) {\n                    lock.notifyAll();\n                }\n                \n                synchronized(mLock) {\n                    if (waitFor(0, -1)) {\n                        mListener.onStreamStart();\n                        \n                        String input = command + \"\\n\";\n                        input += \"    echo \" + mCommandEnd + \" $?\\n\";\n                        \n                        try {\n                            mStdInput.write( input.getBytes() );\n                            \n                            if (mStdInput != null) {\n                                mStdInput.flush();\n                            }\n                            \n                        } catch (IOException e) {\n                            Log.w(TAG, e.getMessage(), e);\n                        }\n                    }\n                }\n            }\n            \n        }.start();\n        \n        synchronized (lock) {\n            try {\n                lock.wait();\n                \n            } catch (InterruptedException e) {}\n        }\n    }\n    \n    public Boolean waitFor() {\n        return waitFor(0, 0);\n    }\n    \n    public Boolean waitFor(Integer timeout) {\n        return waitFor(timeout, 0);\n    }\n    \n    protected Boolean waitFor(Integer timeout, Integer index) {\n        Integer counter = mCounter.size()+index;\n        \n        if (counter > 0) {\n            Long timeoutMilis = timeout > 0 ? System.currentTimeMillis() + timeout : 0L;\n            \n            synchronized(mLock) {\n                while (mCounter.size() > 0 && mIsActive) {\n                    try {\n                        counter -= 1;\n                        \n                        mLock.wait(timeout.longValue());\n                        \n                        if (timeout > 0 && System.currentTimeMillis() >= timeoutMilis) {\n                            return mCounter.size() == 0 && mIsActive;\n                            \n                        } else if (counter <= 0) {\n                            return mIsActive;\n                        }\n                        \n                    } catch (InterruptedException e) {\n                        Log.w(TAG, e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        \n        return mIsActive;\n    }\n    \n    public Boolean isActive() {\n        return mIsActive;\n    }\n    \n    public Boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n    \n    public Boolean isRoot() {\n        return mIsRoot;\n    }\n    \n    public synchronized void destroy() {\n        if (mStdInput != null) {\n            mIsActive = false;\n            \n            mCounter.reset();\n            \n            try {\n                mStdInput.close();\n                mStdInput = null;\n                \n            } catch (IOException e) {}\n            \n            mStdOutputWorker.interrupt();\n            mStdOutputWorker = null;\n            \n            synchronized (mLock) {\n                mLock.notifyAll();\n            }\n            \n            mListener.onStreamDied();\n            mListener = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ShellStream {\n    private Process mConnection;\n    private DataOutputStream mStdInput;\n    private BufferedReader mStdOutput;\n    private Thread mStdOutputWorker;\n    private OnStreamListener mListener;\n    private Counter mCounter;\n    private final Object mLock = new Object();\n    private boolean mIsActive;\n    private final boolean mIsRoot;\n    private final String mCommandEnd = \"CMD_END_\" + System.currentTimeMillis() + \"_\";\n\n    public ShellStream(boolean requestRoot, OnStreamListener listener) {\n        this.mIsRoot = requestRoot;\n        this.mListener = listener;\n        this.mCounter = new Counter();\n        String shell = requestRoot ? \"su\" : \"sh\";\n        try {\n            mConnection = Runtime.getRuntime().exec(shell);\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            mIsActive = true;\n            if (mListener != null) mListener.onStreamStart();\n\n            mStdOutputWorker = new Thread(() -> {\n                String line;\n                try {\n                    while ((line = mStdOutput.readLine()) != null) {\n                        if (line.contains(mCommandEnd)) {\n                            mCounter.decrease();\n                        } else {\n                            if (mListener != null) mListener.onStreamInput(line);\n                        }\n                    }\n                } catch (IOException e) {\n                    if (mListener != null) mListener.onStreamDied();\n                }\n            });\n            mStdOutputWorker.start();\n        } catch (IOException e) {\n            mIsActive = false;\n            if (mListener != null) mListener.onStreamDied();\n        }\n    }\n\n    public void execute(String command) {\n        synchronized (mLock) {\n            if (!mIsActive) return;\n            mCounter.encrease();\n            try {\n                mStdInput.writeBytes(command + \"\\necho \" + mCommandEnd + \"\\n\");\n                mStdInput.flush();\n            } catch (IOException e) {\n                mIsActive = false;\n                if (mListener != null) mListener.onStreamDied();\n            }\n        }\n    }\n\n    public boolean waitFor() {\n        return waitFor(-1);\n    }\n\n    public boolean waitFor(Integer timeout) {\n        int count = timeout == -1 ? Integer.MAX_VALUE : timeout / 10;\n        for (int i = 0; i < count; i++) {\n            if (mCounter.size() == 0) return true;\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException ignored) {\n                return false;\n            }\n        }\n        return mCounter.size() == 0;\n    }\n\n    private boolean waitFor(Integer timeout, Integer index) {\n        long startTime = System.currentTimeMillis();\n        while (mCounter.size() > index) {\n            if (timeout != -1 && System.currentTimeMillis() - startTime > timeout) {\n                return false;\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException ignored) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean isActive() {\n        return mIsActive;\n    }\n\n    public boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n\n    public boolean isRoot() {\n        return mIsRoot;\n    }\n\n    public void destroy() {\n        synchronized (mLock) {\n            mIsActive = false;\n            try {\n                if (mStdInput != null) {\n                    mStdInput.writeBytes(\"exit\\n\");\n                    mStdInput.flush();\n                }\n            } catch (IOException ignored) {}\n            if (mConnection != null) mConnection.destroy();\n            if (mListener != null) mListener.onStreamStop(mConnection.exitValue());\n        }\n    }\n\n    public interface OnStreamListener {\n        void onStreamStart();\n        void onStreamInput(String output);\n        void onStreamStop(int exitCode);\n        void onStreamDied();\n    }\n\n    public static class Counter {\n        private AtomicInteger count = new AtomicInteger(0);\n\n        public int size() {\n            return count.get();\n        }\n\n        public int encrease() {\n            return count.incrementAndGet();\n        }\n\n        public int decrease() {\n            return count.decrementAndGet();\n        }\n\n        public void reset() {\n            count.set(0);\n        }\n    }\n}"
  },
  {
    "Task_id": 287,
    "Instruction": "Task Description: The task involves creating a Java utility class that manages environment variables for a Java Runtime Environment (JRE) and handles log redirection from an external process. The class should provide methods to configure the JRE environment and redirect logs from the Android `logcat` command to a custom logger.\n\nClass Description: This utility class is designed to set up the JRE environment by configuring various system environment variables and redirecting logs from an external process (`logcat`) to a custom logger. It is particularly useful for Android applications that need to manage JRE environments and log outputs dynamically.\n\nAttributes:\n\n- `NATIVE_LIB_DIR`: String - The directory path for native libraries.\n- `LD_LIBRARY_PATH`: String - The library path for dynamic linking.\n- `LOCAL_RENDERER`: String - The renderer type for graphics (e.g., \"opengles3_desktopgl_angle_vulkan\").\n- `jvmLibraryPath`: String - The path to the JVM library (e.g., \"server/libjvm.so\" or \"client/libjvm.so\").\n- `logcatPb`: ProcessBuilder - A ProcessBuilder instance for executing the `logcat` command.\n- `failTime`: int - A counter to track the number of failed attempts to start the `logcat` process.\n\nMethods:\n\n- `redirectAndPrintJRELog()`: void - Starts a new thread to redirect and print JRE logs from the `logcat` command. The method configures the `logcat` command to filter specific log tags and redirects the output to a custom logger. If the process fails, it retries up to 10 times.\n- `setJavaEnvironment(Activity activity, String jreHome)`: void - Configures the JRE environment by setting various system environment variables. The method reads additional environment variables from a custom file (`custom_env.txt`) and applies them. It also sets the `LD_LIBRARY_PATH` and `PATH` variables to include the JRE binaries and native libraries.\n  - Input:\n    - `activity`: Activity - The Android activity context.\n    - `jreHome`: String - The home directory of the JRE.\n  - Output: None (void).\n- `setLdLibraryPath(String path)`: void - Sets the `LD_LIBRARY_PATH` environment variable to the specified path.\n  - Input:\n    - `path`: String - The new library path.\n  - Output: None (void).\n\nNote: The class assumes the presence of helper classes like `Logger`, `Tools`, `LauncherPreferences`, and `ExtraCore` for logging, file operations, and preference management. These dependencies should be handled appropriately in the implementation.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport android.system.Os;\nimport android.system.ErrnoException;\n\npublic static void redirectAndPrintJRELog() {\n    new Thread(new Runnable(){\n        int failTime = 0;\n        ProcessBuilder logcatPb;\n        @Override\n        public void run() {\n            try {\n                if (logcatPb == null) {\n                    logcatPb = new ProcessBuilder().command(\"logcat\", \"-v\", \"brief\", \"-s\", \"jrelog:I\", \"LIBGL:I\", \"NativeInput\").redirectErrorStream(true);\n                }\n\n                new ProcessBuilder().command(\"logcat\", \"-c\").redirectErrorStream(true).start();\n                java.lang.Process p = logcatPb.start();\n\n                byte[] buf = new byte[1024];\n                int len;\n                while ((len = p.getInputStream().read(buf)) != -1) {\n                    String currStr = new String(buf, 0, len);\n                    Logger.appendToLog(currStr);\n                }\n\n                if (p.waitFor() != 0) {\n                    failTime++;\n                    if (failTime <= 10) {\n                        run();\n                    } else {\n                        Logger.appendToLog(\"ERROR: Unable to get more log.\");\n                    }\n                }\n            } catch (Throwable e) {\n                Logger.appendToLog(\"Exception on logging thread:\\n\" + Log.getStackTraceString(e));\n            }\n        }\n    }).start();\n}\n\npublic static void setJavaEnvironment(Activity activity, String jreHome) throws Throwable {\n    Map<String, String> envMap = new ArrayMap<>();\n    envMap.put(\"POJAV_NATIVEDIR\", NATIVE_LIB_DIR);\n    envMap.put(\"JAVA_HOME\", jreHome);\n    envMap.put(\"HOME\", Tools.DIR_GAME_HOME);\n    envMap.put(\"TMPDIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"LIBGL_MIPMAP\", \"3\");\n    envMap.put(\"LIBGL_NOERROR\", \"1\");\n    envMap.put(\"LIBGL_NOINTOVLHACK\", \"1\");\n    envMap.put(\"LIBGL_NORMALIZE\", \"1\");\n\n    if(PREF_DUMP_SHADERS)\n        envMap.put(\"LIBGL_VGPU_DUMP\", \"1\");\n    if(PREF_ZINK_PREFER_SYSTEM_DRIVER)\n        envMap.put(\"POJAV_ZINK_PREFER_SYSTEM_DRIVER\", \"1\");\n    if(PREF_VSYNC_IN_ZINK)\n        envMap.put(\"POJAV_VSYNC_IN_ZINK\", \"1\");\n    if(Tools.deviceHasHangingLinker())\n        envMap.put(\"POJAV_EMUI_ITERATOR_MITIGATE\", \"1\");\n\n    envMap.put(\"LIBGL_ES\", (String) ExtraCore.getValue(ExtraConstants.OPEN_GL_VERSION));\n    envMap.put(\"FORCE_VSYNC\", String.valueOf(LauncherPreferences.PREF_FORCE_VSYNC));\n    envMap.put(\"MESA_GLSL_CACHE_DIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"force_glsl_extensions_warn\", \"true\");\n    envMap.put(\"allow_higher_compat_version\", \"true\");\n    envMap.put(\"allow_glsl_extension_directive_midshader\", \"true\");\n    envMap.put(\"MESA_LOADER_DRIVER_OVERRIDE\", \"zink\");\n    envMap.put(\"VTEST_SOCKET_NAME\", new File(Tools.DIR_CACHE, \".virgl_test\").getAbsolutePath());\n\n    envMap.put(\"LD_LIBRARY_PATH\", LD_LIBRARY_PATH);\n    envMap.put(\"PATH\", jreHome + \"/bin:\" + Os.getenv(\"PATH\"));\n    if(FFmpegPlugin.isAvailable) {\n        envMap.put(\"PATH\", FFmpegPlugin.libraryPath+\":\"+envMap.get(\"PATH\"));\n    }\n\n    if(LOCAL_RENDERER != null) {\n        envMap.put(\"POJAV_RENDERER\", LOCAL_RENDERER);\n        if(LOCAL_RENDERER.equals(\"opengles3_desktopgl_angle_vulkan\")) {\n            envMap.put(\"LIBGL_ES\", \"3\");\n            envMap.put(\"POJAVEXEC_EGL\",\"libEGL_angle.so\");\n        }\n    }\n\n    File customEnvFile = new File(Tools.DIR_GAME_HOME, \"custom_env.txt\");\n    if (customEnvFile.exists() && customEnvFile.isFile()) {\n        BufferedReader reader = new BufferedReader(new FileReader(customEnvFile));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            int index = line.indexOf(\"=\");\n            envMap.put(line.substring(0, index), line.substring(index + 1));\n        }\n        reader.close();\n    }\n\n    for (Map.Entry<String, String> env : envMap.entrySet()) {\n        try {\n            Os.setenv(env.getKey(), env.getValue(), true);\n        }catch (NullPointerException exception){\n            Log.e(\"JREUtils\", exception.toString());\n        }\n    }\n\n    File serverFile = new File(jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/server/libjvm.so\");\n    jvmLibraryPath = jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/\" + (serverFile.exists() ? \"server\" : \"client\");\n    setLdLibraryPath(jvmLibraryPath+\":\"+LD_LIBRARY_PATH);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import android.app.Activity;\nimport android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class JREEnvironmentManager {\n\n    private static final String TAG = \"JREEnvironmentManager\";\n    private static String NATIVE_LIB_DIR;\n    private static String LD_LIBRARY_PATH;\n    private static String LOCAL_RENDERER = \"opengles3_desktopgl_angle_vulkan\";\n    private static String jvmLibraryPath;\n    private static ProcessBuilder logcatPb;\n    private static int failTime = 0;\n\n    public static void redirectAndPrintJRELog() {\n        new Thread(() -> {\n            while (failTime < 10) {\n                try {\n                    logcatPb = new ProcessBuilder(\"logcat\", \"-s\", \"JVM*,JRE*:I\");\n                    Process logcatProcess = logcatPb.start();\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(logcatProcess.getInputStream()));\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        Logger.d(TAG, \"Logcat: \" + line);\n                    }\n                    break;\n                } catch (IOException e) {\n                    failTime++;\n                    Logger.e(TAG, \"Failed to start logcat, retrying... Attempt: \" + failTime, e);\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException ie) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n            if (failTime >= 10) {\n                Logger.e(TAG, \"Failed to start logcat after 10 attempts.\");\n            }\n        }).start();\n    }\n\n    public static void setJavaEnvironment(Activity activity, String jreHome) {\n        NATIVE_LIB_DIR = jreHome + File.separator + \"lib\" + File.separator + \"native\";\n        jvmLibraryPath = jreHome + File.separator + \"lib\" + File.separator + \"server\" + File.separator + \"libjvm.so\";\n\n        Map<String, String> env = System.getenv();\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            System.setProperty(entry.getKey(), entry.getValue());\n        }\n\n        String customEnvPath = activity.getFilesDir().getParent() + File.separator + \"custom_env.txt\";\n        try (BufferedReader reader = new BufferedReader(new FileReader(customEnvPath))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = line.split(\"=\", 2);\n                if (parts.length == 2) {\n                    System.setProperty(parts[0], parts[1]);\n                }\n            }\n        } catch (IOException e) {\n            Logger.e(TAG, \"Error reading custom_env.txt\", e);\n        }\n\n        String newPath = jreHome + File.separator + \"bin\" + File.pathSeparator + NATIVE_LIB_DIR;\n        System.setProperty(\"java.library.path\", newPath);\n        System.setProperty(\"LD_LIBRARY_PATH\", LD_LIBRARY_PATH);\n\n        LauncherPreferences.setJREHome(jreHome);\n        ExtraCore.initJNIRuntime(jreHome);\n    }\n\n    public static void setLdLibraryPath(String path) {\n        LD_LIBRARY_PATH = path;\n    }\n}"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of shell commands from within an Android application, providing methods to start, monitor, and interact with the external process, including reading its output and checking its exit status.\n\nClass Description: The ShellCommand class encapsulates functionality for executing shell commands, handling process I/O streams, and managing process lifecycle. It's designed for Android environments (evidenced by android.util.Log usage) and provides both synchronous and asynchronous operation modes.\n\nAttributes:\nrt: [Runtime] - Reference to Java Runtime environment for process execution\ncommand: [String[]] - Array containing the shell command and its arguments\ntag: [String] - Identifier for logging purposes\nprocess: [Process] - Reference to the running process instance\nstdout: [BufferedReader] - Reader for process output stream\nerror: [String] - Stores any error message encountered during execution\nexitval: [int] - Exit value of the completed process (-1 if not terminated)\n\nMethods:\nShellCommand: [constructor](String[] command) -> [void] - Initializes with command to execute\nShellCommand: [constructor](String[] command, String tag) -> [void] - Initializes with command and logging tag\nstart: [void](boolean waitForExit) -> [void] - Starts the process, optionally waiting for completion\nwaitForExit: [void]() -> [void] - Blocks until process completes while reading output\nfinish: [void]() -> [void] - Cleans up process resources\ncheckForExit: [boolean]() -> [boolean] - Checks if process has terminated\nstdoutAvailable: [boolean]() -> [boolean] - Checks if output is ready to read\nreadStdoutBlocking: [String]() -> [String] - Reads a line of output (blocks until available)\nreadStdout: [String]() -> [String] - Reads a line of output if available (non-blocking)",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    Runtime rt;\n    String[] command;\n    String tag = \"\";\n    Process process;\n    BufferedReader stdout;\n    public String error;\n    public int exitval;\n\n    public ShellCommand(String[] command, String tag) {\n        this(command);\n        this.tag = tag;\n    }\n\n    public ShellCommand(String[] command) {\n        this.command = command;\n        rt = Runtime.getRuntime();\n    }\n\n    public void start(boolean waitForExit) {\n        exitval = -1;\n        error = null;\n\n        try {\n            process = new ProcessBuilder().command(command).redirectErrorStream(true).start();\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        } catch (Exception e) {\n            error = e.getCause().getMessage();\n            return;\n        }\n\n        if (waitForExit) {\n            waitForExit();\n        }\n    }\n\n    public void waitForExit() {\n        while (!checkForExit()) {\n            if (stdoutAvailable()) {\n                Log.d(\"AFWALL\", \"ShellCommand waitForExit [\" + tag\n                        + \"] discarding read: \" + readStdout());\n            } else {\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    Log.d(\"AFWall\", \"waitForExit\", e);\n                }\n            }\n        }\n    }\n\n    public void finish() {\n        try {\n            if (stdout != null) {\n                stdout.close();\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"Exception finishing [\" + tag + \"]\", e);\n        }\n\n        if(process !=null) {\n            process.destroy();\n        }\n        process = null;\n    }\n\n    public boolean checkForExit() {\n        try {\n            if(process != null) {\n                exitval = process.exitValue();\n            } else {\n                finish();\n            }\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n\n        finish();\n        return true;\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (java.io.IOException e) {\n            Log.e(\"AFWall\", \"stdoutAvailable error\", e);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        String line;\n        if (stdout == null) {\n            return null;\n        }\n        try {\n            line = stdout.readLine();\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdoutBlocking error\", e);\n            return null;\n        }\n        if (line == null) {\n            return null;\n        } else {\n            return line + \"\\n\";\n        }\n    }\n\n    public String readStdout() {\n        if (stdout == null) {\n            return null;\n        }\n\n        try {\n            if (stdout.ready()) {\n                String line = stdout.readLine();\n                if (line == null) {\n                    return null;\n                } else {\n                    return line + \"\\n\";\n                }\n            } else {\n                return \"\";\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdout error\", e);\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport android.util.Log;\n\npublic class ShellCommand {\n    private Runtime rt;\n    private String[] command;\n    private String tag;\n    private Process process;\n    private BufferedReader stdout;\n    private String error = \"\";\n    private int exitval = -1;\n\n    public ShellCommand(String[] command) {\n        this(command, \"ShellCommand\");\n    }\n\n    public ShellCommand(String[] command, String tag) {\n        this.rt = Runtime.getRuntime();\n        this.command = command;\n        this.tag = tag;\n    }\n\n    public void start(boolean waitForExit) {\n        try {\n            process = rt.exec(command);\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            if (waitForExit) {\n                waitForExit();\n            }\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Error executing command: \", e);\n        }\n    }\n\n    public void waitForExit() {\n        try {\n            while (true) {\n                String line = readStdoutBlocking();\n                if (line == null) break;\n                Log.d(tag, line);\n            }\n            exitval = process.waitFor();\n        } catch (InterruptedException | IOException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Error waiting for process exit: \", e);\n        }\n    }\n\n    public void finish() {\n        if (process != null) {\n            process.destroy();\n        }\n        try {\n            if (stdout != null) {\n                stdout.close();\n            }\n        } catch (IOException e) {\n            Log.e(tag, \"Error closing streams: \", e);\n        }\n    }\n\n    public boolean checkForExit() {\n        try {\n            exitval = process.exitValue();\n            return true;\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n    }\n\n    public boolean stdoutAvailable() throws IOException {\n        return stdout.ready();\n    }\n\n    public String readStdoutBlocking() throws IOException {\n        return stdout.readLine();\n    }\n\n    public String readStdout() throws IOException {\n        if (stdout.ready()) {\n            return stdout.readLine();\n        }\n        return null;\n    }\n}"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Implement a utility class that provides methods to retrieve system information, specifically the hostname, in a cross-platform manner (supporting both Linux and Windows operating systems).\n\nClass Description: The SystemInfoUtil class contains static methods for obtaining system information. It handles platform-specific differences internally and provides a consistent interface for retrieving the hostname.\n\nMethods:\n\nMethod1: getHostName() -> String - Retrieves the hostname of the current system. On Linux systems, it uses the 'uname -n' command, while on Windows it first tries the COMPUTERNAME environment variable and falls back to the 'hostname' command if needed. Returns an empty string if the hostname cannot be determined.\n\nMethod2: getUname(String param) -> String - A helper method that executes the 'uname' command with the specified parameter and returns its output. Primarily used internally by getHostName() for Linux systems. Returns an empty string if the command fails or times out.\n\nInput Parameters:\n- param (String): The parameter to pass to the uname command (e.g., \"-n\" for nodename)\n\nOutput:\n- String: The requested system information (hostname or uname output), or empty string if retrieval fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getHostName()\n{\n    String hostname = \"\";\n\n    if (Platform.isLinux())\n    {\n        hostname = getUname(\"-n\");\n    }\n    else if (Platform.isWindows())\n    {\n        hostname = System.getenv().get(\"COMPUTERNAME\");\n        try\n        {\n            Process process = new ProcessBuilder(\"hostname\").start();\n            process.waitFor(1, TimeUnit.SECONDS);\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            hostname = br.readLine().trim();\n        }\n        catch (IOException | InterruptedException ignored)\n        {\n        }\n    }\n    return hostname;\n}\n\npublic static String getUname(String param)\n{\n    String uname = \"\";\n    try\n    {\n        Process process = new ProcessBuilder(\"uname\", param).start();\n        process.waitFor(1, TimeUnit.SECONDS);\n        BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        uname = br.readLine().trim();\n    }\n    catch (IOException | InterruptedException ignored)\n    {\n    }\n    return uname;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SystemInfoUtil {\n\n    public static String getHostName() {\n        String os = System.getProperty(\"os.name\").toLowerCase();\n        if (os.contains(\"win\")) {\n            String computerName = System.getenv(\"COMPUTERNAME\");\n            if (computerName != null && !computerName.isEmpty()) {\n                return computerName;\n            }\n            String result = executeCommand(\"hostname\");\n            if (!result.isEmpty()) {\n                return result;\n            }\n        } else {\n            String result = getUname(\"-n\");\n            if (!result.isEmpty()) {\n                return result;\n            }\n        }\n        return \"\";\n    }\n\n    public static String getUname(String param) {\n        return executeCommand(\"uname \" + param);\n    }\n\n    private static String executeCommand(String command) {\n        StringBuilder output = new StringBuilder();\n        Process process;\n        try {\n            process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            process.waitFor(500, java.util.concurrent.TimeUnit.MILLISECONDS);\n            process.destroy();\n        } catch (IOException | InterruptedException e) {\n            return \"\";\n        }\n        if (output.length() > 0 && output.charAt(output.length() - 1) == '\\n') {\n            output.deleteCharAt(output.length() - 1);\n        }\n        return output.toString();\n    }\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a class for managing temporary port allocations using file locks to ensure exclusive access to ports during testing or other temporary usage scenarios.\n\nClass Description: The TemporaryPorts class provides a mechanism to acquire and manage temporary port allocations using file-based locks. It creates lock files in a specified directory to represent port allocations and ensures exclusive access through FileChannel locks.\n\nAttributes:\n- DEFAULT_LOCK_DIRECTORY: [Path] - Default directory path for storing port lock files (\"/tmp/helios-test/ports/\")\n- lockDirectory: [Path] - Custom directory path for storing port lock files\n- ports: [List<AllocatedPort>] - List of currently allocated ports\n\nMethods:\n- TemporaryPorts([Path lockDirectory]) -> [void] - Constructor that initializes the lock directory and creates it if it doesn't exist\n- tryAcquire([String name, int port]) -> [AllocatedPort] - Attempts to acquire a port lock, returns AllocatedPort if successful or null if port is already locked\n- lock([int port, String name]) -> [AllocatedPort] - Internal method that performs the actual port locking operation using FileChannel\n- AllocatedPort([int port, Path path, FileChannel file, FileLock lock]) -> [void] - Nested class constructor representing an allocated port\n- port() -> [int] - Returns the allocated port number\n- release() -> [void] - Releases the port lock, closes the file channel, and deletes the lock file",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.lang.String.format;\n\npublic class TemporaryPorts {\n\n  private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n  private final Path lockDirectory;\n  private final List<AllocatedPort> ports = Lists.newArrayList();\n\n  public TemporaryPorts(final Path lockDirectory) {\n    this.lockDirectory = lockDirectory;\n    try {\n      Files.createDirectories(lockDirectory);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public AllocatedPort tryAcquire(final String name, final int port) {\n    final AllocatedPort allocatedPort = lock(port, name);\n    if (allocatedPort == null) {\n      return null;\n    }\n    ports.add(allocatedPort);\n    return allocatedPort;\n  }\n\n  private AllocatedPort lock(final int port, final String name) {\n    final Path path = lockDirectory.resolve(String.valueOf(port));\n    try {\n      final FileChannel file = FileChannel.open(path, CREATE, WRITE);\n      final FileLock lock = file.tryLock();\n      if (lock == null) {\n        return null;\n      }\n      file.write(ByteBuffer.wrap(format(\"%d %s%n\", port, name).getBytes(UTF_8)));\n      file.force(true);\n      return new AllocatedPort(port, path, file, lock);\n    } catch (OverlappingFileLockException e) {\n      return null;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static class AllocatedPort {\n    private final int port;\n    private final Path path;\n    private final FileChannel file;\n    private final FileLock lock;\n\n    private AllocatedPort(final int port, final Path path, FileChannel file, FileLock lock) {\n      this.port = port;\n      this.path = path;\n      this.file = file;\n      this.lock = lock;\n    }\n\n    public int port() {\n      return port;\n    }\n\n    public void release() {\n      try {\n        if (lock.isValid()) {\n          lock.release();\n        }\n        file.close();\n        Files.deleteIfExists(path);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.*;\nimport java.nio.channels.*;\nimport java.nio.file.*;\nimport java.util.*;\n\npublic class TemporaryPorts {\n    private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n    private final Path lockDirectory;\n    private final List<AllocatedPort> ports = new ArrayList<>();\n\n    public TemporaryPorts(Path lockDirectory) {\n        this.lockDirectory = lockDirectory;\n        try {\n            Files.createDirectories(lockDirectory);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to create lock directory: \" + lockDirectory, e);\n        }\n    }\n\n    public TemporaryPorts() {\n        this(DEFAULT_LOCK_DIRECTORY);\n    }\n\n    public AllocatedPort tryAcquire(String name, int port) {\n        Path lockFile = lockDirectory.resolve(port + \".lock\");\n        try {\n            return lock(port, name, lockFile);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    private AllocatedPort lock(int port, String name, Path lockFile) throws IOException {\n        FileChannel fileChannel = FileChannel.open(lockFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        FileLock lock = fileChannel.tryLock();\n        if (lock == null) {\n            fileChannel.close();\n            return null;\n        }\n        AllocatedPort allocatedPort = new AllocatedPort(port, lockFile, fileChannel, lock);\n        ports.add(allocatedPort);\n        return allocatedPort;\n    }\n\n    public static class AllocatedPort {\n        private final int port;\n        private final Path path;\n        private final FileChannel file;\n        private final FileLock lock;\n\n        public AllocatedPort(int port, Path path, FileChannel file, FileLock lock) {\n            this.port = port;\n            this.path = path;\n            this.file = file;\n            this.lock = lock;\n        }\n\n        public int port() {\n            return port;\n        }\n\n        public void release() {\n            try {\n                lock.release();\n                file.close();\n                Files.deleteIfExists(path);\n            } catch (IOException e) {\n                // Ignore or log\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 291,
    "Instruction": "Task Description: Verify and ensure the Java Virtual Machine (JVM) is running on the first thread on macOS, relaunching the process if necessary with the correct arguments.\n\nFunction Description: This function checks if the JVM is running on the first thread on macOS, which is required for proper execution of certain applications. If not, it attempts to relaunch the process with the \"-XstartOnFirstThread\" argument. The function handles process creation, stream redirection, and output/error handling during the relaunch.\n\nInput: \n- args: String[] - Command-line arguments to be passed to the relaunched process (if needed)\n\nOutput: \n- boolean - Returns true if the JVM is already in a valid state (either not on macOS or already running on first thread), or false if a relaunch was attempted (the original process should exit in this case)",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.lang.management.ManagementFactory;\n\npublic static boolean verifyValidJVMState(String[] args){\n    if (SharedLibraryLoader.isMac){\n        if (\"1\".equals(System.getenv(\"JAVA_STARTED_ON_FIRST_THREAD_\" +\n                ManagementFactory.getRuntimeMXBean().getName().split(\"@\")[0]))) {\n            return true;\n        }\n\n        if (\"true\".equals(System.getProperty(\"shpdRelaunched\"))){\n            System.err.println(\"Error: Could not verify new process is running on the first thread. Trying to run the game anyway...\");\n            return true;\n        }\n\n        String sep = System.getProperty(\"file.separator\");\n\n        ArrayList<String> jvmArgs = new ArrayList<>();\n        jvmArgs.add(System.getProperty(\"java.home\") + sep + \"bin\" + sep + \"java\");\n        jvmArgs.add(\"-XstartOnFirstThread\");\n        jvmArgs.add(\"-DshpdRelaunched=true\");\n        jvmArgs.addAll(ManagementFactory.getRuntimeMXBean().getInputArguments());\n        jvmArgs.add(\"-cp\");\n        jvmArgs.add(System.getProperty(\"java.class.path\"));\n        jvmArgs.add(DesktopLauncher.class.getName());\n\n        System.err.println(\"Error: ShatteredPD must start on the first thread in order to work on macOS.\");\n        System.err.println(\"  To avoid this error, run the game with the \\\"-XstartOnFirstThread\\\" argument\");\n        System.err.println(\"  Now attempting to relaunch the game on the first thread automatically:\\n\");\n\n        try {\n            Process process = new ProcessBuilder(jvmArgs).redirectErrorStream(true).start();\n            BufferedReader out = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n\n            while ((line = out.readLine()) != null) {\n                if (line.toLowerCase().startsWith(\"error\")){\n                    System.err.println(line);\n                } else {\n                    System.out.println(line);\n                }\n            }\n\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n    return true;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.IOException;\n\npublic class JVMFirstThreadChecker {\n\n    public static boolean checkAndRelaunchIfNecessary(String[] args) {\n        String osName = System.getProperty(\"os.name\").toLowerCase();\n        if (!osName.contains(\"mac\")) {\n            return true;\n        }\n\n        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n        if (stackTrace.length > 0 && stackTrace[0].getMethodName().equals(\"main\")) {\n            for (StackTraceElement element : stackTrace) {\n                if (element.getClassName().contains(\"AppMain\") || element.getClassName().contains(\"com.apple.\")) {\n                    return true;\n                }\n            }\n        }\n\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(buildRelaunchCommand(args));\n            processBuilder.redirectErrorStream(true);\n            processBuilder.redirectOutput(ProcessBuilder.Redirect.INHERIT);\n            processBuilder.redirectError(ProcessBuilder.Redirect.INHERIT);\n\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n            System.exit(exitCode);\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n    private static String[] buildRelaunchCommand(String[] args) {\n        String javaHome = System.getProperty(\"java.home\");\n        String javaExecutable = javaHome + \"/bin/java\";\n        String className = JVMFirstThreadChecker.class.getName();\n\n        int additionalArgsCount = 2; // -XstartOnFirstThread and className\n        String[] command = new String[args.length + additionalArgsCount + 1];\n        command[0] = javaExecutable;\n        command[1] = \"-XstartOnFirstThread\";\n        System.arraycopy(args, 0, command, 2, args.length);\n        command[command.length - 1] = className;\n\n        return command;\n    }\n}"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes and manages their input/output streams, including support for piping data between multiple processes.\n\nClass Description: The ProcessRunner class provides functionality to execute external processes and handle their input/output streams efficiently. It supports both simple process execution and complex piping between multiple processes. The class uses ProcessBuilder for process creation and AsyncPipe threads for non-blocking stream handling.\n\nAttributes:\n- processRoot: File - The working directory for executed processes\n\nMethods:\n- execute(ProcessBuilder pb) -> void - Executes a single process with its output and error streams redirected to System.out and System.err respectively. Throws IOException and InterruptedException.\n- pipe(InputStream is, OutputStream os, ProcessBuilder... builders) -> void - Executes multiple processes in sequence, piping the output of one process to the input of the next. Uses temporary files for intermediate storage. Throws IOException and InterruptedException.\n- AsyncPipe(InputStream is, OutputStream os) - Constructor for AsyncPipe thread that handles stream copying and closes streams when done.\n- AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) - Constructor for AsyncPipe thread with option to control stream closing behavior.\n- run() -> void - (AsyncPipe method) The thread's main execution method that copies data between streams.",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders)\n      throws IOException, InterruptedException {\n    int i = 0;\n    File tempin;\n    File tempout = File.createTempFile(\"pipe\", \"txt\");\n    OutputStream tos;\n    for (ProcessBuilder builder : builders) {\n      if (i == 0) {\n      } else {\n        tempin = tempout;\n        is = new FileInputStream(tempin);\n      }\n      if (i == builders.length - 1) {\n        if (os == null) {\n          tos = System.out;\n        } else {\n          tos = os;\n        }\n      } else {\n        tempout = File.createTempFile(\"pipe\", \"txt\");\n        tos = new FileOutputStream(tempout);\n      }\n      Process process = builder.redirectErrorStream(true).directory(processRoot).start();\n      new AsyncPipe(process.getErrorStream(), System.err, false).start();\n      new AsyncPipe(process.getInputStream(), tos).start();\n      if (is != null) {\n        new AsyncPipe(is, process.getOutputStream()).start();\n      }\n      i++;\n      process.waitFor();\n    }\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class ProcessRunner {\n    private File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n        pb.directory(processRoot);\n        Process process = pb.start();\n        AsyncPipe outPipe = new AsyncPipe(process.getInputStream(), System.out);\n        AsyncPipe errPipe = new AsyncPipe(process.getErrorStream(), System.err);\n        outPipe.start();\n        errPipe.start();\n        int exitCode = process.waitFor();\n        outPipe.join();\n        errPipe.join();\n        if (exitCode != 0) {\n            throw new IOException(\"Process exited with code \" + exitCode);\n        }\n    }\n\n    public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders) throws IOException, InterruptedException {\n        if (builders.length == 0) return;\n\n        File tempDir = processRoot;\n        AsyncPipe inputPipe = null;\n        AsyncPipe outputPipe = null;\n        InputStream currentInput = is;\n\n        for (int i = 0; i < builders.length; i++) {\n            ProcessBuilder pb = builders[i];\n            pb.directory(tempDir);\n\n            boolean isLast = (i == builders.length - 1);\n            boolean isFirst = (i == 0);\n\n            File stdinFile = null;\n            File stdoutFile = null;\n\n            try {\n                if (isFirst) {\n                    stdinFile = File.createTempFile(\"pr_\", \".tmp\", tempDir);\n                    stdinFile.deleteOnExit();\n                    try (OutputStream stdinOut = new FileOutputStream(stdinFile)) {\n                        byte[] buffer = new byte[8192];\n                        int len;\n                        while ((len = currentInput.read(buffer)) > 0) {\n                            stdinOut.write(buffer, 0, len);\n                        }\n                    }\n                    pb.redirectInput(stdinFile);\n                }\n\n                if (!isLast) {\n                    stdoutFile = File.createTempFile(\"pr_\", \".tmp\", tempDir);\n                    stdoutFile.deleteOnExit();\n                    pb.redirectOutput(stdoutFile);\n                } else {\n                    outputPipe = new AsyncPipe(currentInput, os);\n                    outputPipe.start();\n                }\n\n                Process process = pb.start();\n\n                if (isFirst) {\n                    inputPipe = new AsyncPipe(process.getErrorStream(), System.err);\n                    inputPipe.start();\n                }\n\n                if (!isLast) {\n                    try (InputStream nextInput = new FileInputStream(stdoutFile)) {\n                        currentInput = nextInput;\n                    }\n                }\n\n                int exitCode = process.waitFor();\n                if (inputPipe != null) inputPipe.join();\n                if (exitCode != 0) {\n                    throw new IOException(\"Process exited with code \" + exitCode);\n                }\n            } finally {\n                if (stdinFile != null) stdinFile.delete();\n                if (stdoutFile != null) stdoutFile.delete();\n            }\n        }\n\n        if (outputPipe != null) outputPipe.join();\n    }\n\n    public static class AsyncPipe extends Thread {\n        private final InputStream is;\n        private final OutputStream os;\n        private final boolean closeStreams;\n        private final AtomicBoolean started = new AtomicBoolean(false);\n        private final AtomicBoolean finished = new AtomicBoolean(false);\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            if (!started.compareAndSet(false, true)) {\n                return;\n            }\n            try {\n                byte[] buffer = new byte[8192];\n                int len;\n                while ((len = is.read(buffer)) > 0) {\n                    os.write(buffer, 0, len);\n                }\n                os.flush();\n            } catch (IOException e) {\n                // Handle exception or log if needed\n            } finally {\n                try {\n                    if (closeStreams) {\n                        is.close();\n                        os.close();\n                    }\n                } catch (IOException e) {\n                    // Ignore\n                }\n                finished.set(true);\n            }\n        }\n\n        public boolean isFinished() {\n            return finished.get();\n        }\n    }\n}"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a thread-safe registry class for managing daemon processes using memory-mapped files for persistent storage. The class should handle concurrent access, automatic file resizing, and data recovery from corrupted states.\n\nClass Description: DaemonRegistry is a thread-safe class that maintains a registry of daemon processes in a memory-mapped file. It provides methods to read, update, and manage daemon information with proper file locking and automatic buffer resizing when needed. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- LOGGER: Logger - Logger instance for logging operations\n- MAX_LENGTH: int - Maximum initial size for the memory-mapped buffer (32KB)\n- LOCK_TIMEOUT_MS: long - Timeout duration for acquiring file locks (20 seconds)\n- locks: Map<Path, Object> - Static concurrent map for maintaining file-level locks\n- registryFile: Path - Path to the registry file\n- lck: Object - Instance-specific lock object\n- channel: FileChannel - File channel for the registry file\n- buffer: MappedByteBuffer - Memory-mapped byte buffer for the file\n- size: long - Current size of the memory-mapped buffer\n- infosMap: Map<String, DaemonInfo> - Map storing daemon information\n\nMethods:\n- DaemonRegistry(Path registryFile) -> void - Constructor that initializes the registry by creating or opening the specified file and setting up the memory-mapped buffer\n- close() -> void - Closes the file channel and releases system resources\n- getAll() -> List<DaemonInfo> - Returns a list of all registered daemon information\n- read() -> void - Reads all daemon information from the memory-mapped file into the internal map\n- doUpdate(Runnable updater) -> void - Performs a read or update operation with file locking, handles buffer resizing and data recovery\n- tryLock() -> FileLock - Attempts to acquire an exclusive lock on the file\n- reset() -> void - Clears the internal map and resets the buffer\n- readString() -> String - Reads a UTF-8 encoded string from the buffer\n- writeString(String str) -> void - Writes a UTF-8 encoded string to the buffer\n- nextPowerOf2(long a, long min) -> long - Helper method to calculate the next power of 2 greater than or equal to input values",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.BufferOverflowException;\nimport java.nio.BufferUnderflowException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DaemonRegistry implements AutoCloseable {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DaemonRegistry.class);\n    private static final int MAX_LENGTH = 32768;\n    private static final long LOCK_TIMEOUT_MS = 1000 * 20;\n    private static final Map<Path, Object> locks = new ConcurrentHashMap<>();\n\n    private final Path registryFile;\n    private final Object lck;\n    private final FileChannel channel;\n    private MappedByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new HashMap<>();\n\n    public DaemonRegistry(Path registryFile) {\n        final Path absPath = registryFile.toAbsolutePath().normalize();\n        this.lck = locks.computeIfAbsent(absPath, p -> new Object());\n        this.registryFile = absPath;\n        try {\n            if (!Files.isRegularFile(absPath)) {\n                if (!Files.isDirectory(absPath.getParent())) {\n                    Files.createDirectories(absPath.getParent());\n                }\n            }\n            channel = FileChannel.open(\n                    absPath, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            size = nextPowerOf2(channel.size(), MAX_LENGTH);\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n        } catch (IOException e) {\n            throw new DaemonException(e);\n        }\n    }\n\n    public void close() {\n        try {\n            channel.close();\n        } catch (IOException e) {\n            throw new DaemonException(\"Error closing registry\", e);\n        }\n    }\n\n    public List<DaemonInfo> getAll() {\n        read();\n        return new ArrayList<>(infosMap.values());\n    }\n\n    private void read() {\n        doUpdate(null);\n    }\n\n    private void doUpdate(Runnable updater) {\n        if (!Files.isReadable(registryFile)) {\n            throw new DaemonException(\"Registry became unaccessible\");\n        }\n\n        synchronized (lck) {\n            final long deadline = System.currentTimeMillis() + LOCK_TIMEOUT_MS;\n            while (System.currentTimeMillis() < deadline) {\n                try (FileLock l = tryLock()) {\n                    BufferCaster.cast(buffer).position(0);\n                    infosMap.clear();\n                    int nb = buffer.getInt();\n                    for (int i = 0; i < nb; i++) {\n                        String daemonId = readString();\n                        String javaHome = readString();\n                        String mavenHome = readString();\n                        int pid = buffer.getInt();\n                        String address = readString();\n\n                        byte[] token = new byte[DaemonInfo.TOKEN_SIZE];\n                        buffer.get(token);\n\n                        String locale = readString();\n                        List<String> opts = new ArrayList<>();\n                        int nbOpts = buffer.getInt();\n                        for (int j = 0; j < nbOpts; j++) {\n                            opts.add(readString());\n                        }\n                        DaemonState state = DaemonState.values()[buffer.get()];\n                        long lastIdle = buffer.getLong();\n                        long lastBusy = buffer.getLong();\n                        DaemonInfo di = new DaemonInfo(\n                                daemonId, javaHome, mavenHome, pid, address, token, locale, opts, state, lastIdle,\n                                lastBusy);\n                        infosMap.putIfAbsent(di.getId(), di);\n                    }\n\n                    if (updater != null) {\n                        updater.run();\n                        BufferCaster.cast(buffer).position((int) 0);\n                        buffer.putInt(infosMap.size());\n                        for (DaemonInfo di : infosMap.values()) {\n                            writeString(di.getId());\n                            writeString(di.getJavaHome());\n                            writeString(di.getMvndHome());\n                            buffer.putInt(di.getPid());\n                            writeString(di.getAddress());\n                            buffer.put(di.getToken());\n                            writeString(di.getLocale());\n                            buffer.putInt(di.getOptions().size());\n                            for (String opt : di.getOptions()) {\n                                writeString(opt);\n                            }\n                            buffer.put((byte) di.getState().ordinal());\n                            buffer.putLong(di.getLastIdle());\n                            buffer.putLong(di.getLastBusy());\n                        }\n                    }\n                    return;\n                } catch (BufferOverflowException e) {\n                    size <<= 1;\n                    LOGGER.info(\"Resizing registry to {} kb due to buffer overflow\", (size / 1024));\n                    try {\n                        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                    } catch (IOException ex) {\n                        ex.addSuppressed(e);\n                        throw new DaemonException(\"Could not resize registry \" + registryFile, ex);\n                    }\n                } catch (IOException e) {\n                    throw new DaemonException(\n                            \"Exception while \" + (updater != null ? \"updating \" : \"reading \") + registryFile, e);\n                } catch (IllegalStateException | ArrayIndexOutOfBoundsException | BufferUnderflowException e) {\n                    String absPath = registryFile.toAbsolutePath().normalize().toString();\n                    LOGGER.warn(\n                            \"Invalid daemon registry info, trying to recover from this issue. \"\n                                    + \"If you keep getting this warning, try deleting the `registry.bin` file at [{}]\",\n                            absPath,\n                            e);\n                    this.reset();\n                    return;\n                }\n            }\n            throw new RuntimeException(\"Could not lock \" + registryFile + \" within \" + LOCK_TIMEOUT_MS + \" ms\");\n        }\n    }\n\n    private FileLock tryLock() {\n        try {\n            return channel.tryLock(0, size, false);\n        } catch (IOException e) {\n            throw new DaemonException(\"Could not lock \" + registryFile, e);\n        }\n    }\n\n    private void reset() {\n        infosMap.clear();\n        BufferCaster.cast(buffer).clear();\n        buffer.putInt(0);\n    }\n\n    protected String readString() {\n        int sz = buffer.getShort();\n        if (sz == -1) {\n            return null;\n        }\n        if (sz < -1 || sz > 1024) {\n            throw new IllegalStateException(\"Bad string size: \" + sz);\n        }\n        byte[] buf = new byte[sz];\n        buffer.get(buf);\n        return new String(buf, StandardCharsets.UTF_8);\n    }\n\n    protected void writeString(String str) {\n        if (str == null) {\n            buffer.putShort((short) -1);\n            return;\n        }\n        byte[] buf = str.getBytes(StandardCharsets.UTF_8);\n        if (buf.length > 1024) {\n            LOGGER.warn(\"Attempting to write string longer than 1024 bytes: '{}'. Please raise an issue.\", str);\n            str = str.substring(0, 1033);\n            while (buf.length > 1024) {\n                str = str.substring(0, str.length() - 12) + \"\u2026\";\n                buf = str.getBytes(StandardCharsets.UTF_8);\n            }\n        }\n        buffer.putShort((short) buf.length);\n        buffer.put(buf);\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        long b = min;\n        while (b < a) {\n            b = b << 1;\n        }\n        return b;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport java.nio.file.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.locks.*;\nimport java.util.logging.*;\nimport java.util.stream.*;\n\npublic class DaemonRegistry implements AutoCloseable {\n    private static final Logger LOGGER = Logger.getLogger(DaemonRegistry.class.getName());\n    private static final int MAX_LENGTH = 32 * 1024;\n    private static final long LOCK_TIMEOUT_MS = 20_000;\n    private static final Map<Path, Object> locks = new ConcurrentHashMap<>();\n\n    private final Path registryFile;\n    private final Object lck = new Object();\n    private FileChannel channel;\n    private MappedByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new HashMap<>();\n\n    public DaemonRegistry(Path registryFile) throws IOException {\n        this.registryFile = registryFile;\n        synchronized (lck) {\n            Object existingLock = locks.putIfAbsent(registryFile, lck);\n            if (existingLock != null) {\n                throw new IllegalStateException(\"Registry file already in use: \" + registryFile);\n            }\n        }\n\n        try {\n            channel = FileChannel.open(registryFile, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n            size = channel.size();\n            if (size == 0) {\n                size = MAX_LENGTH;\n                channel.truncate(size);\n            }\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n            read();\n        } catch (IOException e) {\n            locks.remove(registryFile);\n            throw e;\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        synchronized (lck) {\n            try {\n                if (channel != null && channel.isOpen()) {\n                    channel.close();\n                }\n            } finally {\n                locks.remove(registryFile);\n            }\n        }\n    }\n\n    public List<DaemonInfo> getAll() {\n        synchronized (lck) {\n            return new ArrayList<>(infosMap.values());\n        }\n    }\n\n    public void read() {\n        synchronized (lck) {\n            buffer.rewind();\n            infosMap.clear();\n\n            while (buffer.hasRemaining()) {\n                try {\n                    String name = readString();\n                    String pid = readString();\n                    long lastSeen = buffer.getLong();\n                    infosMap.put(name, new DaemonInfo(name, pid, lastSeen));\n                } catch (BufferUnderflowException | IllegalArgumentException e) {\n                    break;\n                }\n            }\n        }\n    }\n\n    public void doUpdate(Runnable updater) {\n        FileLock lock = null;\n        try {\n            lock = tryLock();\n            if (lock == null) {\n                throw new RuntimeException(\"Failed to acquire lock for update\");\n            }\n\n            synchronized (lck) {\n                buffer.rewind();\n                buffer.limit((int) size);\n\n                // Try reading existing data\n                Map<String, DaemonInfo> tempMap = new HashMap<>();\n                try {\n                    while (buffer.hasRemaining()) {\n                        String name = readString();\n                        String pid = readString();\n                        long lastSeen = buffer.getLong();\n                        tempMap.put(name, new DaemonInfo(name, pid, lastSeen));\n                    }\n                } catch (Exception e) {\n                    LOGGER.warning(\"Corrupted data detected, resetting registry\");\n                    reset();\n                }\n\n                infosMap.clear();\n                infosMap.putAll(tempMap);\n\n                // Run the update operation\n                updater.run();\n\n                // Calculate required size\n                int requiredSize = 0;\n                for (DaemonInfo info : infosMap.values()) {\n                    requiredSize += 2 * (2 + info.name.length() + 2 + info.pid.length()) + 8;\n                }\n\n                // Resize if needed\n                if (requiredSize > buffer.capacity()) {\n                    long newSize = nextPowerOf2(requiredSize, MAX_LENGTH);\n                    MappedByteBuffer newBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, newSize);\n                    buffer.rewind();\n                    newBuffer.put(buffer);\n                    buffer = newBuffer;\n                    size = newSize;\n                    channel.truncate(size);\n                }\n\n                // Write updated data\n                buffer.rewind();\n                for (DaemonInfo info : infosMap.values()) {\n                    writeString(info.name);\n                    writeString(info.pid);\n                    buffer.putLong(info.lastSeen);\n                }\n\n                buffer.flip();\n                buffer.limit(buffer.position());\n                buffer.position(0);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to update daemon registry\", e);\n        } finally {\n            try {\n                if (lock != null) {\n                    lock.release();\n                }\n            } catch (IOException e) {\n                LOGGER.log(Level.SEVERE, \"Failed to release file lock\", e);\n            }\n        }\n    }\n\n    private FileLock tryLock() throws IOException {\n        long startTime = System.currentTimeMillis();\n        while (System.currentTimeMillis() - startTime < LOCK_TIMEOUT_MS) {\n            try {\n                FileLock lock = channel.tryLock();\n                if (lock != null) {\n                    return lock;\n                }\n            } catch (OverlappingFileLockException ignored) {\n                // Continue trying\n            }\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new IOException(\"Interrupted while waiting for file lock\");\n            }\n        }\n        return null;\n    }\n\n    public void reset() {\n        synchronized (lck) {\n            infosMap.clear();\n            buffer.rewind();\n            buffer.limit(0);\n        }\n    }\n\n    private String readString() {\n        int length = buffer.getShort() & 0xFFFF;\n        byte[] bytes = new byte[length];\n        buffer.get(bytes);\n        return new String(bytes, StandardCharsets.UTF_8);\n    }\n\n    private void writeString(String str) {\n        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n        buffer.putShort((short) bytes.length);\n        buffer.put(bytes);\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        long n = Math.max(min, a - 1);\n        n |= n >> 1;\n        n |= n >> 2;\n        n |= n >> 4;\n        n |= n >> 8;\n        n |= n >> 16;\n        n |= n >> 32;\n        return n + 1;\n    }\n\n    public static class DaemonInfo {\n        public final String name;\n        public final String pid;\n        public final long lastSeen;\n\n        public DaemonInfo(String name, String pid, long lastSeen) {\n            this.name = name;\n            this.pid = pid;\n            this.lastSeen = lastSeen;\n        }\n    }\n}"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a function that executes an external process, captures its output and error streams, and handles the results appropriately, including error cases and output printing.\n\nFunction Description: The function `doFork` executes an external process specified by a command string, redirects its standard output and error streams to files, and optionally prints them. It waits for the process to complete, checks the exit code, and handles any exceptions or errors that occur during execution. The function also interacts with a `BinaryLinkServer` to retrieve results or exceptions from the forked process.\n\nInput:\n- `reader`: BinaryLinkServer - An object that reads results from the forked process and may contain exceptions.\n- `commandString`: List<String> - The command and arguments to execute the external process.\n- `stdOut`: File - The file to which the standard output of the process will be redirected.\n- `stdErr`: File - The file to which the standard error of the process will be redirected.\n- `printOut`: boolean - If true, the standard output will be printed to the console.\n- `printErr`: boolean - If true, the standard error will be printed to the console.\n\nOutput:\n- Returns `List<IterationResult>` - A list of results from the forked process if execution is successful.\n- Throws `BenchmarkException` - If the process fails (non-zero exit code), an IOException occurs, or the thread is interrupted.",
    "Canonical_solution": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\nprivate List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString,\n                                    File stdOut, File stdErr, boolean printOut, boolean printErr) {\n    try (FileOutputStream fosErr = new FileOutputStream(stdErr);\n         FileOutputStream fosOut = new FileOutputStream(stdOut)) {\n        ProcessBuilder pb = new ProcessBuilder(commandString);\n        Process p = pb.start();\n\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), fosErr);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), fosOut);\n\n        if (printErr) {\n            errDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        if (printOut) {\n            outDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int ecode = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        reader.waitFinish();\n\n        if (ecode != 0) {\n            out.println(\"<forked VM failed with exit code \" + ecode + \">\");\n            out.println(\"<stdout last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdOut, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stdout>\");\n            out.println(\"<stderr last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdErr, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stderr>\");\n\n            out.println(\"\");\n        }\n\n        BenchmarkException exception = reader.getException();\n        if (exception == null) {\n            if (ecode == 0) {\n                return reader.getResults();\n            } else {\n                throw new BenchmarkException(new IllegalStateException(\"Forked VM failed with exit code \" + ecode));\n            }\n        } else {\n            throw exception;\n        }\n\n    } catch (IOException ex) {\n        out.println(\"<failed to invoke the VM, caught IOException: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    } catch (InterruptedException ex) {\n        out.println(\"<host VM has been interrupted waiting for forked VM: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.*;\n\npublic class ProcessExecutor {\n\n    public static List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString, File stdOut, File stdErr,\n                                              boolean printOut, boolean printErr) throws BenchmarkException {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(commandString);\n            pb.redirectOutput(ProcessBuilder.Redirect.to(stdOut));\n            pb.redirectError(ProcessBuilder.Redirect.to(stdErr));\n\n            Process process = pb.start();\n\n            List<IterationResult> results = reader.readResults();\n\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new BenchmarkException(\"Process exited with non-zero status: \" + exitCode);\n            }\n\n            if (printOut) {\n                try (BufferedReader outReader = new BufferedReader(new FileReader(stdOut))) {\n                    String line;\n                    while ((line = outReader.readLine()) != null) {\n                        System.out.println(line);\n                    }\n                }\n            }\n\n            if (printErr) {\n                try (BufferedReader errReader = new BufferedReader(new FileReader(stdErr))) {\n                    String line;\n                    while ((line = errReader.readLine()) != null) {\n                        System.err.println(line);\n                    }\n                }\n            }\n\n            return results;\n\n        } catch (IOException | InterruptedException e) {\n            throw new BenchmarkException(\"Error during process execution\", e);\n        }\n    }\n\n    public static class IterationResult {\n        // Placeholder for actual result structure\n    }\n\n    public static class BinaryLinkServer {\n        public List<IterationResult> readResults() throws IOException {\n            // Implementation to read results from the forked process\n            return new ArrayList<>();\n        }\n    }\n\n    public static class BenchmarkException extends Exception {\n        public BenchmarkException(String message) {\n            super(message);\n        }\n\n        public BenchmarkException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}"
  },
  {
    "Task_id": 301,
    "Instruction": "Task Description: Create a Java utility class for executing shell commands with root privileges and handling process execution in Android environments.\n\nClass Description: ShellUtils is a utility class designed to execute shell commands, particularly in rooted Android environments. It provides methods for finding system binaries, executing commands with or without root privileges, and handling process input/output streams. The class includes functionality for environment variable handling and process synchronization.\n\nAttributes:\n\nBINARY_PLACES: String[] - Array of common binary directories in Android systems for command lookup\nPYTHON_HOME: String - Path to Python installation directory\nDATA_DIR: File - Application data directory\nBUSYBOX_FILE: File - Path to busybox binary\nIS_ROOTED: Boolean - Cached flag indicating whether the device is rooted\n\nMethods:\n\nexecuteNoWait: executeNoWait(Map<String, String> env, String... command) -> Process - Executes a command without waiting for completion, with optional environment variables\nsudoNoWait: sudoNoWait(Map<String, String> env, String... command) -> Process - Executes a command with root privileges (using su) without waiting for completion\nwaitFor: waitFor(String command, Process process) -> String - Waits for process completion and returns output, throws exception if process fails\nfindCommand: findCommand(String command) -> String - Searches for a command in common binary directories and returns full path if found",
    "Canonical_solution": "import java.io.*;\nimport java.util.*;\n\npublic class ShellUtils {\n    private final static String[] BINARY_PLACES = {\"/data/bin/\", \"/system/bin/\", \"/system/xbin/\", \"/sbin/\",\n            \"/data/local/xbin/\", \"/data/local/bin/\", \"/system/sd/xbin/\", \"/system/bin/failsafe/\",\n            \"/data/local/\"};\n    private final static String PYTHON_HOME = \"/data/data/fq.router2/python\";\n    public static File DATA_DIR = new File(\"/data/data/fq.router2\");\n    public static File BUSYBOX_FILE = new File(DATA_DIR, \"busybox\");\n    private static Boolean IS_ROOTED = null;\n\n    public static Process executeNoWait(Map<String, String> env, String... command) throws IOException {\n        List<String> envp = new ArrayList<String>();\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            envp.add(entry.getKey() + \"=\" + entry.getValue());\n        }\n        return Runtime.getRuntime().exec(command, envp.toArray(new String[envp.size()]));\n    }\n\n    public static Process sudoNoWait(Map<String, String> env, String... command) throws Exception {\n        if (Boolean.FALSE.equals(IS_ROOTED)) {\n            return executeNoWait(env, command);\n        }\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        Process process = processBuilder\n                .command(findCommand(\"su\"))\n                .redirectErrorStream(true)\n                .start();\n        OutputStreamWriter stdin = new OutputStreamWriter(process.getOutputStream());\n        try {\n            for (Map.Entry<String, String> entry : env.entrySet()) {\n                stdin.write(entry.getKey());\n                stdin.write(\"=\");\n                stdin.write(entry.getValue());\n                stdin.write(\" \");\n            }\n            for (String c : command) {\n                stdin.write(c);\n                stdin.write(\" \");\n            }\n            stdin.write(\"\\nexit\\n\");\n        } finally {\n            stdin.close();\n        }\n        return process;\n    }\n\n    public static String waitFor(String command, Process process) throws Exception {\n        BufferedReader stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        try {\n            String line;\n            while (null != (line = stdout.readLine())) {\n                output.append(line);\n                output.append(\"\\n\");\n            }\n        } finally {\n            stdout.close();\n        }\n        process.waitFor();\n        int exitValue = process.exitValue();\n        if (0 != exitValue) {\n            throw new Exception(\"failed to execute: \" + command + \", exit value: \" + exitValue + \", output: \" + output);\n        }\n        return output.toString();\n    }\n\n    public static String findCommand(String command) {\n        for (String binaryPlace : BINARY_PLACES) {\n            String path = binaryPlace + command;\n            if (new File(path).exists()) {\n                return path;\n            }\n        }\n        return command;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class ShellUtils {\n    private static final String[] BINARY_PLACES = {\n        \"/system/bin/\", \"/system/xbin/\", \"/sbin/\", \"/vendor/bin/\",\n        \"/data/local/tmp/\", \"/system/sbin/\", \"/system/bin/failsafe/\"\n    };\n    \n    private static final String PYTHON_HOME = \"/data/data/org.python.android/files/\";\n    private static File DATA_DIR = new File(\"/data/data/com.example.app/\");\n    private static File BUSYBOX_FILE = new File(DATA_DIR, \"busybox\");\n    private static Boolean IS_ROOTED = null;\n\n    public static Process executeNoWait(Map<String, String> env, String... command) throws IOException {\n        return Runtime.getRuntime().exec(buildCommandArray(env, command));\n    }\n\n    public static Process sudoNoWait(Map<String, String> env, String... command) throws IOException {\n        String[] suCommand = new String[]{\"su\", \"-c\", buildCommandString(env, command)};\n        return Runtime.getRuntime().exec(suCommand);\n    }\n\n    public static String waitFor(String command, Process process) throws IOException, InterruptedException {\n        StringBuilder output = new StringBuilder();\n        int exitCode = process.waitFor();\n        \n        if (exitCode != 0) {\n            throw new RuntimeException(\"Command failed with exit code \" + exitCode + \": \" + command);\n        }\n        \n        // Implementation for reading process output and appending to output\n        // This would read from process.getInputStream() and process.getErrorStream()\n        \n        return output.toString();\n    }\n\n    public static String findCommand(String command) {\n        for (String path : BINARY_PLACES) {\n            File commandFile = new File(path, command);\n            if (commandFile.exists() && commandFile.canExecute()) {\n                return commandFile.getAbsolutePath();\n            }\n        }\n        return null;\n    }\n\n    private static String[] buildCommandArray(Map<String, String> env, String... command) {\n        if (env == null || env.isEmpty()) {\n            return command;\n        }\n        \n        StringBuilder envString = new StringBuilder();\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            envString.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\" \");\n        }\n        \n        String[] result = new String[command.length + 1];\n        result[0] = envString.toString().trim();\n        System.arraycopy(command, 0, result, 1, command.length);\n        return result;\n    }\n\n    private static String buildCommandString(Map<String, String> env, String... command) {\n        StringBuilder sb = new StringBuilder();\n        \n        if (env != null && !env.isEmpty()) {\n            for (Map.Entry<String, String> entry : env.entrySet()) {\n                sb.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\" \");\n            }\n        }\n        \n        for (String part : command) {\n            sb.append(part).append(\" \");\n        }\n        \n        return sb.toString().trim();\n    }\n}"
  },
  {
    "Task_id": 303,
    "Instruction": "Task Description: Create a Java class that manages the execution of external commands, handles their input/output streams, and provides synchronization capabilities for waiting until the command completes.\n\nClass Description: The ExtCmd class provides functionality to execute external system commands, manage their input/output streams, and wait for their completion. It includes features for logging, condition checking before execution, and notification listeners for process completion.\n\nAttributes:\n\nconditionsWithDescriptions: Map<ExtCmdCondition, String> - Stores conditions that must be met before command execution along with their descriptions\nextCmdEndedListenerSet: Set<ExtCmdEndedListener> - Collection of listeners to be notified when command execution ends\noutReceiver: OutputReceiver - Handles the standard output stream from the executed command\nerrReceiver: OutputReceiver - Handles the error output stream from the executed command\nerrLog: ErrorReporter - Logger for command execution information\nstartTime: long - Timestamp when command execution started\nexecCommand: String[] - The command to be executed\nexecCommandStr: String - String representation of the command\nlogExecution: boolean - Flag to enable/disable execution logging\n\nMethods:\n\nexec(ProcessBuilder.Redirect, File, String...) -> OutputStream - Executes an external command with specified input redirection, working directory, and command arguments. Returns the process's output stream for writing input.\nsyncProcess() -> OutputData - Waits for the command to complete and returns its output data including stdout, stderr, and exit code.\ncheckForConditions() -> void - Internal method to verify all execution conditions are met before starting a command.\n\nNested Classes:\n\nOutputData: Contains the results of command execution including stdout, stderr, and exit code\nExtCmdCondition: Interface for defining pre-execution conditions\nExtCmdEndedListener: Interface for command completion notification callbacks",
    "Canonical_solution": "import com.linbit.ChildProcessTimeoutException;\nimport com.linbit.linstor.logging.ErrorReporter;\nimport com.linbit.timer.Action;\nimport com.linbit.timer.Timer;\nimport com.linbit.utils.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport org.slf4j.MDC;\n\npublic class ExtCmd extends ChildProcessHandler\n{\n    private final Map<ExtCmdCondition, String> conditionsWithDescriptions;\n    private final Set<ExtCmdEndedListener> extCmdEndedListenerSet;\n\n    private OutputReceiver outReceiver;\n    private OutputReceiver errReceiver;\n    private ErrorReporter errLog;\n    private long startTime;\n\n    private String[] execCommand;\n    private String execCommandStr;\n\n    private boolean logExecution = true;\n\n    public ExtCmd(Timer<String, Action<String>> timer, ErrorReporter errLogRef)\n    {\n        super(timer);\n        conditionsWithDescriptions = new HashMap<>();\n        outReceiver = null;\n        errReceiver = null;\n        errLog = errLogRef;\n        extCmdEndedListenerSet = new HashSet<>();\n    }\n\n    public OutputStream exec(ProcessBuilder.Redirect stdinRedirect, File directory, String... command)\n        throws IOException\n    {\n        execCommand = command;\n        execCommandStr = StringUtils.joinShellQuote(command);\n\n        if (logExecution)\n        {\n            errLog.logDebug(\"Executing command: %s\", execCommandStr);\n        }\n\n        ProcessBuilder pBuilder = new ProcessBuilder();\n        pBuilder.directory(directory);\n        pBuilder.command(command);\n        pBuilder.redirectError(ProcessBuilder.Redirect.PIPE);\n        pBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);\n        pBuilder.redirectInput(stdinRedirect);\n        Process child;\n        synchronized (conditionsWithDescriptions)\n        {\n            checkForConditions();\n            child = pBuilder.start();\n            startTime = System.currentTimeMillis();\n            setChild(child);\n            outReceiver = new OutputReceiver(\n                child.getInputStream(), errLog, logExecution, MDC.get(ErrorReporter.LOGID));\n            errReceiver = new OutputReceiver(\n                child.getErrorStream(), errLog, logExecution, MDC.get(ErrorReporter.LOGID));\n        }\n        new Thread(outReceiver).start();\n        new Thread(errReceiver).start();\n\n        return child.getOutputStream();\n    }\n\n    private void checkForConditions()\n    {\n        for (Entry<ExtCmdCondition, String> entry : conditionsWithDescriptions.entrySet())\n        {\n            if (!entry.getKey().isMet(this))\n            {\n                throw new ExtCmdConditionNotFullfilledException(entry.getValue() + \", command: \" + this.execCommandStr);\n            }\n        }\n    }\n\n    public OutputData syncProcess() throws IOException, ChildProcessTimeoutException\n    {\n        OutputData outData;\n        try\n        {\n            int exitCode = waitFor();\n            outReceiver.finish();\n            errReceiver.finish();\n            outData = new OutputData(\n                execCommand,\n                outReceiver.getData(),\n                errReceiver.getData(),\n                exitCode\n            );\n\n            if (logExecution)\n            {\n                errLog.logTrace(\n                    \"External command finished in %dms: %s\",\n                    (System.currentTimeMillis() - startTime),\n                    execCommandStr\n                );\n            }\n\n            for (ExtCmdEndedListener listener : extCmdEndedListenerSet)\n            {\n                listener.extCmdEnded(this);\n            }\n        }\n        catch (IOException | ChildProcessTimeoutException exc)\n        {\n            for (ExtCmdEndedListener listener : extCmdEndedListenerSet)\n            {\n                listener.extCmdEnded(this, exc);\n            }\n            throw exc;\n        }\n        return outData;\n    }\n\n    public static class OutputData\n    {\n        public final String[] executedCommand;\n        public final byte[] stdoutData;\n        public final byte[] stderrData;\n        public final int exitCode;\n\n        public OutputData(String[] executeCmd, byte[] out, byte[] err, int retCode)\n        {\n            executedCommand = executeCmd;\n            stdoutData = out;\n            stderrData = err;\n            exitCode = retCode;\n        }\n    }\n\n    public interface ExtCmdCondition\n    {\n        boolean isMet(ExtCmd extCmd);\n    }\n\n    public interface ExtCmdEndedListener\n    {\n        void extCmdEnded(ExtCmd extCmd);\n        void extCmdEnded(ExtCmd extCmd, Exception exc);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class ExtCmd {\n    private Map<ExtCmdCondition, String> conditionsWithDescriptions = new HashMap<>();\n    private Set<ExtCmdEndedListener> extCmdEndedListenerSet = new HashSet<>();\n    private OutputReceiver outReceiver;\n    private OutputReceiver errReceiver;\n    private ErrorReporter errLog;\n    private long startTime;\n    private String[] execCommand;\n    private String execCommandStr;\n    private boolean logExecution;\n\n    public ExtCmd() {\n        this(null, null, null);\n    }\n\n    public ExtCmd(OutputReceiver outReceiver, OutputReceiver errReceiver, ErrorReporter errLog) {\n        this.outReceiver = outReceiver != null ? outReceiver : output -> {};\n        this.errReceiver = errReceiver != null ? errReceiver : output -> {};\n        this.errLog = errLog != null ? errLog : (level, message) -> {};\n    }\n\n    public OutputStream exec(ProcessBuilder.Redirect inputRedirect, File workingDirectory, String... command) throws IOException {\n        if (command == null || command.length == 0) {\n            throw new IllegalArgumentException(\"Command cannot be null or empty\");\n        }\n\n        checkForConditions();\n\n        this.execCommand = command;\n        this.execCommandStr = String.join(\" \", command);\n        ProcessBuilder pb = new ProcessBuilder(command);\n        pb.redirectInput(inputRedirect);\n        if (workingDirectory != null) {\n            pb.directory(workingDirectory);\n        }\n\n        if (logExecution) {\n            errLog.report(LogLevel.INFO, \"Executing command: \" + execCommandStr);\n        }\n\n        Process process = pb.start();\n        startTime = System.currentTimeMillis();\n\n        // Stream handlers\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        executor.submit(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    outReceiver.onOutput(line);\n                }\n            } catch (IOException e) {\n                errLog.report(LogLevel.ERROR, \"Error reading stdout: \" + e.getMessage());\n            }\n        });\n\n        executor.submit(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    errReceiver.onOutput(line);\n                }\n            } catch (IOException e) {\n                errLog.report(LogLevel.ERROR, \"Error reading stderr: \" + e.getMessage());\n            }\n        });\n\n        executor.shutdown();\n\n        return process.getOutputStream();\n    }\n\n    public OutputData syncProcess() throws InterruptedException {\n        // Wait for the process to complete (simplified - in a real implementation you'd track the process)\n        // This would typically involve using Future or similar mechanism\n        Thread.sleep(100); // Placeholder for actual synchronization logic\n\n        int exitCode = 0; // Would get from actual process\n        List<String> stdoutLines = new ArrayList<>();\n        List<String> stderrLines = new ArrayList<>();\n\n        // Notify listeners\n        OutputData result = new OutputData(stdoutLines, stderrLines, exitCode);\n        for (ExtCmdEndedListener listener : extCmdEndedListenerSet) {\n            listener.onCommandEnded(this, result);\n        }\n\n        return result;\n    }\n\n    private void checkForConditions() {\n        for (Map.Entry<ExtCmdCondition, String> entry : conditionsWithDescriptions.entrySet()) {\n            if (!entry.getKey().check()) {\n                throw new RuntimeException(\"Condition not met: \" + entry.getValue());\n            }\n        }\n    }\n\n    // Nested classes\n\n    public static class OutputData {\n        private final List<String> stdoutLines;\n        private final List<String> stderrLines;\n        private final int exitCode;\n\n        public OutputData(List<String> stdoutLines, List<String> stderrLines, int exitCode) {\n            this.stdoutLines = Collections.unmodifiableList(new ArrayList<>(stdoutLines));\n            this.stderrLines = Collections.unmodifiableList(new ArrayList<>(stderrLines));\n            this.exitCode = exitCode;\n        }\n\n        public List<String> getStdoutLines() {\n            return stdoutLines;\n        }\n\n        public List<String> getStderrLines() {\n            return stderrLines;\n        }\n\n        public int getExitCode() {\n            return exitCode;\n        }\n    }\n\n    public interface ExtCmdCondition {\n        boolean check();\n    }\n\n    public interface ExtCmdEndedListener {\n        void onCommandEnded(ExtCmd cmd, OutputData result);\n    }\n\n    public interface OutputReceiver {\n        void onOutput(String line);\n    }\n\n    public interface ErrorReporter {\n        void report(LogLevel level, String message);\n    }\n\n    public enum LogLevel {\n        INFO, WARNING, ERROR\n    }\n\n    // Getters and setters for attributes\n    public void addCondition(ExtCmdCondition condition, String description) {\n        conditionsWithDescriptions.put(condition, description);\n    }\n\n    public void removeCondition(ExtCmdCondition condition) {\n        conditionsWithDescriptions.remove(condition);\n    }\n\n    public void addListener(ExtCmdEndedListener listener) {\n        extCmdEndedListenerSet.add(listener);\n    }\n\n    public void removeListener(ExtCmdEndedListener listener) {\n        extCmdEndedListenerSet.remove(listener);\n    }\n\n    public void setOutReceiver(OutputReceiver outReceiver) {\n        this.outReceiver = outReceiver;\n    }\n\n    public void setErrReceiver(OutputReceiver errReceiver) {\n        this.errReceiver = errReceiver;\n    }\n\n    public void setErrorReporter(ErrorReporter errLog) {\n        this.errLog = errLog;\n    }\n\n    public void setLogExecution(boolean logExecution) {\n        this.logExecution = logExecution;\n    }\n\n    public String[] getExecCommand() {\n        return Arrays.copyOf(execCommand, execCommand.length);\n    }\n\n    public String getExecCommandString() {\n        return execCommandStr;\n    }\n\n    public long getStartTime() {\n        return startTime;\n    }\n}"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a RabbitMQ message consumer in Java that connects to a RabbitMQ broker, declares a queue, and continuously consumes messages from that queue.\n\nClass Description: The MessageConsumer class provides functionality to connect to a RabbitMQ broker, initialize a message queue, consume messages from the queue, and properly close connections when finished.\n\nAttributes:\n- ROUTING_KEY: String - The name of the queue to consume messages from\n- factory: ConnectionFactory - RabbitMQ connection factory for broker configuration\n- connection: Connection - Active connection to the RabbitMQ broker\n- channel: Channel - Communication channel for message operations\n\nMethods:\n- MessageConsumer() - Constructor - Initializes the ConnectionFactory with default host settings\n- initializeConnection() throws Exception -> void - Establishes connection to RabbitMQ broker and creates a channel\n- startConsuming() throws Exception -> void - Starts consuming messages from the queue and prints received messages\n- close() throws Exception -> void - Closes the channel and connection to the RabbitMQ broker",
    "Canonical_solution": "import com.rabbitmq.client.*;\n\npublic class MessageConsumer {\n\n    private final static String ROUTING_KEY = \"SAMPLE_RABBITMQ\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        this.factory = new ConnectionFactory();\n        this.factory.setHost(\"127.0.0.1\");\n    }\n\n    public void initializeConnection() throws Exception {\n        this.connection = factory.newConnection();\n        this.channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        System.out.println(\"C [*] Waiting for messages. To exit press CTRL+C\");\n        Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"Consumer [x] Received '\" + message + \"'\");\n            }\n        };\n        channel.basicConsume(ROUTING_KEY, true, consumer);\n    }\n\n    public void close() throws Exception {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 41,
    "wrong_result": "import com.rabbitmq.client.*;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\npublic class MessageConsumer {\n    private static final String ROUTING_KEY = \"my_queue\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n    }\n\n    public void initializeConnection() throws IOException, TimeoutException {\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws IOException {\n        channel.basicConsume(ROUTING_KEY, true, (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"Received: \" + message);\n        }, consumerTag -> {});\n    }\n\n    public void close() throws IOException, TimeoutException {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 305,
    "Instruction": "Task Description: Implement a RabbitMQ message producer in Java that sends messages to a specified exchange.\n\nClass Description: A service class that handles the production and sending of messages to a RabbitMQ exchange using a fanout pattern. The class manages connection setup, message publishing, and resource cleanup.\n\nAttributes:\n- EXCHANGE_NAME: String - The name of the RabbitMQ exchange to which messages will be published.\n\nMethods:\n- produceMessage(String message) -> String - Publishes the given message to the configured RabbitMQ exchange. Returns a simple response string.\n  - Input Parameters:\n    - message: String - The message content to be published\n  - Return Type: String - A simple response string (\"response\") indicating completion",
    "Canonical_solution": "import com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.visualpathit.account.utils.RabbitMqUtil;\nimport com.rabbitmq.client.Channel;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\n@Service\npublic class ProducerServiceImpl implements ProducerService {\n\n    private static final String EXCHANGE_NAME = \"messages\";\n\n    @Override\n    public String produceMessage(String message) {\n        try {\n            ConnectionFactory factory = new ConnectionFactory();\n            factory.setHost(RabbitMqUtil.getRabbitMqHost());\n            factory.setPort(Integer.parseInt(RabbitMqUtil.getRabbitMqPort()));\n            factory.setUsername(RabbitMqUtil.getRabbitMqUser());\n            factory.setPassword(RabbitMqUtil.getRabbitMqPassword());\n            Connection connection = factory.newConnection();\n            Channel channel = connection.createChannel();\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n            channel.close();\n            connection.close();\n        } catch (IOException io) {\n            io.printStackTrace();\n        } catch (TimeoutException toe) {\n            toe.printStackTrace();\n        }\n        return \"response\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 40,
    "wrong_result": "import com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\npublic class RabbitMQProducerService {\n\n    private final String EXCHANGE_NAME;\n\n    public RabbitMQProducerService(String exchangeName) {\n        this.EXCHANGE_NAME = exchangeName;\n    }\n\n    public String produceMessage(String message) {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        try (Connection connection = factory.newConnection();\n             Channel channel = connection.createChannel()) {\n\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return \"response\";\n    }\n}"
  },
  {
    "Task_id": 308,
    "Instruction": "Task Description: Implement a utility class for Redis pipeline operations using Lettuce client in Java, enabling batch Redis commands execution with asynchronous processing.\n\nClass Description: LettuceRedisUtils is a singleton utility class that provides a method for executing Redis commands in pipeline mode using Lettuce client. It manages Redis connections and asynchronous command execution.\n\nAttributes:\n- REDIS_CLIENT: [RedisClient] - The singleton Redis client instance initialized with connection details (host, port, password)\n\nMethods:\n- pipeline: [pipeline](RedisPipelineCallBack pipelineCallBack) -> [void] - Executes Redis commands in pipeline mode. Takes a callback interface that contains the Redis operations to be performed. Handles connection management, command flushing, and waiting for completion of all operations. The callback should return a list of RedisFuture objects representing the asynchronous operations.",
    "Canonical_solution": "import io.lettuce.core.LettuceFutures;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisFuture;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class LettuceRedisUtils {\n\n    private static final RedisClient REDIS_CLIENT;\n\n    static {\n        RedisURI redisUri = RedisURI.Builder.redis(AustinFlinkConstant.REDIS_IP)\n                .withPort(Integer.parseInt(AustinFlinkConstant.REDIS_PORT))\n                .withPassword(AustinFlinkConstant.REDIS_PASSWORD.toCharArray())\n                .build();\n        REDIS_CLIENT = RedisClient.create(redisUri);\n    }\n\n    private LettuceRedisUtils() {\n    }\n\n    public static void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        StatefulRedisConnection<byte[], byte[]> connect = REDIS_CLIENT.connect(new ByteArrayCodec());\n        RedisAsyncCommands<byte[], byte[]> commands = connect.async();\n\n        List<RedisFuture<?>> futures = pipelineCallBack.invoke(commands);\n\n        commands.flushCommands();\n        LettuceFutures.awaitAll(10, TimeUnit.SECONDS,\n                futures.toArray(new RedisFuture[0]));\n        connect.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisFuture;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class LettuceRedisUtils {\n\n    private static final RedisClient REDIS_CLIENT = RedisClient.create(\"redis://password@localhost:6379/0\");\n\n    private static final LettuceRedisUtils INSTANCE = new LettuceRedisUtils();\n\n    private LettuceRedisUtils() {}\n\n    public static LettuceRedisUtils getInstance() {\n        return INSTANCE;\n    }\n\n    public void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        try (StatefulRedisConnection<String, String> connection = REDIS_CLIENT.connect()) {\n            RedisAsyncCommands<String, String> asyncCommands = connection.async();\n            List<RedisFuture<?>> futures = pipelineCallBack.execute(asyncCommands);\n\n            asyncCommands.flushCommands();\n            for (RedisFuture<?> future : futures) {\n                future.await(5, TimeUnit.SECONDS);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @FunctionalInterface\n    public interface RedisPipelineCallBack {\n        List<RedisFuture<?>> execute(RedisAsyncCommands<String, String> asyncCommands);\n    }\n}"
  },
  {
    "Task_id": 309,
    "Instruction": "Task Description: Create a Java class that manages Redis connections using the Jedis client library, providing methods to establish, close, and create new connections with configurable protocols.\n\nClass Description: The RedisConnectionManager class handles Redis connection management using Jedis, allowing for protocol configuration and providing essential connection operations. It encapsulates connection details and offers methods for connection lifecycle management.\n\nAttributes:\n\nendpoint: [EndpointConfig] - Configuration for Redis connection endpoint (host, port, etc.)\nprotocol: [RedisProtocol] - The Redis protocol to be used for connections\njedis: [Jedis] - The Jedis client instance for Redis operations\n\nMethods:\n\nsetUpConnection: [void]() -> [void] - Establishes a new Redis connection with the configured protocol and timeout, and flushes all existing data\ncloseConnection: [void]() -> [void] - Closes the current Redis connection and releases resources\ncreateNewConnection: [Jedis]() -> [Jedis] - Creates and returns a new Jedis connection instance with the configured protocol",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.HostAndPorts;\nimport redis.clients.jedis.RedisProtocol;\nimport redis.clients.jedis.EndpointConfig;\n\npublic class RedisConnectionManager {\n\n    protected static final EndpointConfig endpoint = HostAndPorts.getRedisEndpoint(\"standalone0\");\n    protected final RedisProtocol protocol;\n    protected Jedis jedis;\n\n    public RedisConnectionManager(RedisProtocol protocol) {\n        this.protocol = protocol;\n    }\n\n    public void setUpConnection() throws Exception {\n        jedis = new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).timeoutMillis(500).build());\n        jedis.flushAll();\n    }\n\n    public void closeConnection() throws Exception {\n        jedis.close();\n    }\n\n    public Jedis createNewConnection() {\n        return new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).build());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisConnectionManager {\n    private EndpointConfig endpoint;\n    private RedisProtocol protocol;\n    private Jedis jedis;\n\n    public RedisConnectionManager(EndpointConfig endpoint, RedisProtocol protocol) {\n        this.endpoint = endpoint;\n        this.protocol = protocol;\n    }\n\n    public void setUpConnection() {\n        this.jedis = createNewConnection();\n        this.jedis.flushAll();\n    }\n\n    public void closeConnection() {\n        if (jedis != null) {\n            jedis.close();\n        }\n    }\n\n    public Jedis createNewConnection() {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        JedisPool jedisPool = new JedisPool(poolConfig, endpoint.getHost(), endpoint.getPort(), protocol.getTimeout());\n        return jedisPool.getResource();\n    }\n\n    public static class EndpointConfig {\n        private String host;\n        private int port;\n\n        public EndpointConfig(String host, int port) {\n            this.host = host;\n            this.port = port;\n        }\n\n        public String getHost() {\n            return host;\n        }\n\n        public int getPort() {\n            return port;\n        }\n    }\n\n    public enum RedisProtocol {\n        REDIS_2_0(2000),\n        REDIS_3_0(3000),\n        REDIS_6_0(6000);\n\n        private final int timeout;\n\n        RedisProtocol(int timeout) {\n            this.timeout = timeout;\n        }\n\n        public int getTimeout() {\n            return timeout;\n        }\n    }\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Create a Java class that implements StreamSinkConduit to handle file channel operations for writing data to a file, with proper management of write operations and resource cleanup.\n\nClass Description: FileConduitTarget is a class that implements StreamSinkConduit to provide file channel operations for writing data. It manages file writes, transfers, and resource cleanup while integrating with an HTTP server exchange for thread management.\n\nAttributes:\n- fileChannel: FileChannel - The file channel used for writing data to the file\n- exchange: HttpServerExchange - The HTTP server exchange for thread management\n- writeReadyHandler: WriteReadyHandler - Handler for write readiness events\n- writesResumed: boolean - Flag indicating whether writes are currently resumed\n\nMethods:\n- transferFrom(FileChannel, long, long) -> long - Transfers data from the given file channel to this file channel\n- transferFrom(StreamSourceChannel, long, ByteBuffer) -> long - Transfers data from the given stream source channel to this file channel\n- write(ByteBuffer) -> int - Writes data from the given byte buffer to the file channel\n- write(ByteBuffer[], int, int) -> long - Writes data from the given byte buffer array to the file channel\n- writeFinal(ByteBuffer) -> int - Performs a final write operation from the given byte buffer\n- writeFinal(ByteBuffer[], int, int) -> long - Performs a final write operation from the given byte buffer array\n- terminateWrites() -> void - Closes the file channel to terminate writes\n- isWriteShutdown() -> boolean - Checks if writes are shutdown (file channel closed)\n- resumeWrites() -> void - Resumes write operations\n- suspendWrites() -> void - Suspends write operations\n- wakeupWrites() -> void - Wakes up pending write operations\n- isWriteResumed() -> boolean - Checks if writes are currently resumed\n- awaitWritable() -> void - Waits for the channel to become writable (no-op implementation)\n- awaitWritable(long, TimeUnit) -> void - Waits for the channel to become writable with timeout (no-op implementation)\n- getWriteThread() -> XnioIoThread - Gets the I/O thread from the exchange\n- setWriteReadyHandler(WriteReadyHandler) -> void - Sets the write ready handler\n- truncateWrites() -> void - Closes the file channel to truncate writes\n- flush() -> boolean - Flushes any buffered data (always returns true)\n- getWorker() -> XnioWorker - Gets the worker from the exchange connection",
    "Canonical_solution": "import io.undertow.server.HttpServerExchange;\nimport io.undertow.util.ImmediateConduitFactory;\nimport org.xnio.IoUtils;\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.Conduits;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed = false;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel fileChannel, long l, long l2) throws IOException {\n        return this.fileChannel.transferFrom(fileChannel, l, l2);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel streamSourceChannel, long l, ByteBuffer byteBuffer) throws IOException {\n        return IoUtils.transfer(streamSourceChannel, l, byteBuffer, fileChannel);\n    }\n\n    @Override\n    public int write(ByteBuffer byteBuffer) throws IOException {\n        return fileChannel.write(byteBuffer);\n    }\n\n    @Override\n    public long write(ByteBuffer[] byteBuffers, int i, int i2) throws IOException {\n        return fileChannel.write(byteBuffers, i, i2);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return Conduits.writeFinalBasic(this, src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return Conduits.writeFinalBasic(this, srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        wakeupWrites();\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null) {\n            writesResumed = true;\n            while (writesResumed && writeReadyHandler != null) {\n                writeReadyHandler.writeReady();\n            }\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n    }\n\n    @Override\n    public void awaitWritable(long l, TimeUnit timeUnit) throws IOException {\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler writeReadyHandler) {\n        this.writeReadyHandler = writeReadyHandler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.StreamSourceChannel;\nimport java.util.concurrent.TimeUnit;\nimport io.undertow.server.HttpServerExchange;\nimport org.xnio.ChannelListener;\nimport org.xnio.IoUtils;\nimport org.xnio.channels.StreamSinkConduit;\nimport org.xnio.conduits.ConduitWritableByteChannel;\nimport org.xnio.conduits.WriteReadyHandler;\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n\n    private FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private volatile boolean writesResumed = true;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel src, long position, long count) throws IOException {\n        return fileChannel.transferFrom(src, position, count);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel source, long count, ByteBuffer throughBuffer) throws IOException {\n        long totalTransferred = 0;\n        while (count > 0) {\n            int transferred = source.read(throughBuffer);\n            if (transferred == -1) break;\n            throughBuffer.flip();\n            int written = fileChannel.write(throughBuffer);\n            throughBuffer.compact();\n            totalTransferred += written;\n            count -= written;\n        }\n        return totalTransferred;\n    }\n\n    @Override\n    public int write(ByteBuffer src) throws IOException {\n        return fileChannel.write(src);\n    }\n\n    @Override\n    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        long totalWritten = 0;\n        for (int i = offset; i < offset + length; i++) {\n            int written = fileChannel.write(srcs[i]);\n            totalWritten += written;\n            if (!srcs[i].hasRemaining()) break;\n        }\n        return totalWritten;\n    }\n\n    public int writeFinal(ByteBuffer src) throws IOException {\n        int written = write(src);\n        if (!src.hasRemaining()) {\n            terminateWrites();\n        }\n        return written;\n    }\n\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        long totalWritten = write(srcs, offset, length);\n        boolean allEmpty = true;\n        for (int i = offset; i < offset + length; i++) {\n            if (srcs[i].hasRemaining()) {\n                allEmpty = false;\n                break;\n            }\n        }\n        if (allEmpty) {\n            terminateWrites();\n        }\n        return totalWritten;\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        IoUtils.safeClose(fileChannel);\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return fileChannel == null || !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        writesResumed = true;\n        if (writeReadyHandler != null) {\n            writeReadyHandler.handleReady();\n        }\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writesResumed && writeReadyHandler != null) {\n            exchange.addExchangeCompleteListener((exchange, nextListener) -> writeReadyHandler.handleReady());\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n        // No-op\n    }\n\n    @Override\n    public void awaitWritable(long time, TimeUnit unit) throws IOException {\n        // No-op\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler handler) {\n        this.writeReadyHandler = handler;\n    }\n\n    public void truncateWrites() throws IOException {\n        IoUtils.safeClose(fileChannel);\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}"
  },
  {
    "Task_id": 313,
    "Instruction": "Task Description: Create a Redis connection manager class in Java using Lettuce client that handles connection setup, management, and cleanup.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections using Lettuce client. It provides methods to establish a connection with configurable timeout options, retrieve the active connection, and properly close the connection when no longer needed.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used to create connections\n- connection: StatefulRedisConnection<byte[], byte[]> - The active Redis connection using byte array codec\n\nMethods:\n- setupConnection(String host, int port) -> void - Initializes the Redis client and establishes a connection to the specified Redis server with a 10-second timeout configuration\n- closeConnection() -> void - Properly closes the active connection and shuts down the Redis client\n- getConnection() -> StatefulRedisConnection<byte[], byte[]> - Returns the active Redis connection instance",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        redisClient = RedisClient.create(RedisURI.create(host, port));\n        redisClient.setOptions(ClientOptions.builder()\n                .timeoutOptions(TimeoutOptions.builder().fixedTimeout(Duration.ofSeconds(10)).build()).build());\n        connection = redisClient.connect(ByteArrayCodec.INSTANCE);\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown(0, 0, TimeUnit.SECONDS);\n        }\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\n\nimport java.time.Duration;\n\npublic class RedisConnectionManager {\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        RedisURI redisURI = RedisURI.Builder.redis(host, port)\n                .withTimeout(Duration.ofSeconds(10))\n                .build();\n        redisClient = RedisClient.create(redisURI);\n        connection = redisClient.connect(ByteArrayCodec.INSTANCE);\n    }\n\n    public void closeConnection() {\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n        if (redisClient != null && redisClient.isShutdown()) {\n            redisClient.shutdown();\n        }\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n}"
  },
  {
    "Task_id": 315,
    "Instruction": "Task Description: Implement a Redis connection class in Java that handles socket communication, authentication, and basic Redis operations while managing connection state and resources.\n\nClass Description: The Connection class represents a Redis client connection that manages socket communication with a Redis server. It handles connection establishment, command sending, response reading, and connection cleanup. The class implements Closeable for proper resource management.\n\nAttributes:\n- socketFactory: JedisSocketFactory - Factory for creating socket connections to Redis\n- socket: Socket - The underlying socket connection to Redis\n- outputStream: RedisOutputStream - Output stream for sending commands to Redis\n- inputStream: RedisInputStream - Input stream for reading responses from Redis\n- soTimeout: int - Socket timeout setting\n- broken: boolean - Flag indicating if the connection is in a broken state\n- currentCredentials: AtomicReference<RedisCredentials> - Current authentication credentials\n- authXManager: AuthXManager - Manager for authentication operations\n\nMethods:\n- Connection(JedisSocketFactory) -> void - Constructor that initializes with a socket factory\n- connect() -> void - Establishes connection to Redis server\n- disconnect() -> void - Closes the connection to Redis server\n- isConnected() -> boolean - Checks if connection is active\n- isBroken() -> boolean - Checks if connection is in broken state\n- setBroken() -> void - Marks connection as broken\n- sendCommand(ProtocolCommand, byte[]...) -> void - Sends a Redis command with arguments\n- getOne() -> Object - Reads and returns a single response from Redis\n- flush() -> void - Flushes the output stream\n- readProtocolWithCheckingBroken() -> Object - Reads protocol response while checking connection state\n- close() -> void - Implements Closeable interface to disconnect (alias for disconnect)",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Protocol.Keyword;\nimport redis.clients.jedis.args.Rawable;\nimport redis.clients.jedis.authentication.AuthXManager;\nimport redis.clients.jedis.commands.ProtocolCommand;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisDataException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.IOUtils;\nimport redis.clients.jedis.util.RedisInputStream;\nimport redis.clients.jedis.util.RedisOutputStream;\n\npublic class Connection implements Closeable {\n\n  private final JedisSocketFactory socketFactory;\n  private Socket socket;\n  private RedisOutputStream outputStream;\n  private RedisInputStream inputStream;\n  private int soTimeout = 0;\n  private boolean broken = false;\n  private AtomicReference<RedisCredentials> currentCredentials = new AtomicReference<>(null);\n  private AuthXManager authXManager;\n\n  public Connection(final JedisSocketFactory socketFactory) {\n    this.socketFactory = socketFactory;\n  }\n\n  public void connect() throws JedisConnectionException {\n    if (!isConnected()) {\n      try {\n        socket = socketFactory.createSocket();\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n        inputStream = new RedisInputStream(socket.getInputStream());\n        broken = false;\n      } catch (JedisConnectionException jce) {\n        setBroken();\n        throw jce;\n      } catch (IOException ioe) {\n        setBroken();\n        throw new JedisConnectionException(\"Failed to create input/output stream\", ioe);\n      } finally {\n        if (broken) {\n          IOUtils.closeQuietly(socket);\n        }\n      }\n    }\n  }\n\n  public void disconnect() {\n    if (isConnected()) {\n      try {\n        outputStream.flush();\n        socket.close();\n      } catch (IOException ex) {\n        throw new JedisConnectionException(ex);\n      } finally {\n        IOUtils.closeQuietly(socket);\n        setBroken();\n      }\n    }\n  }\n\n  public boolean isConnected() {\n    return socket != null && socket.isBound() && !socket.isClosed() && socket.isConnected()\n        && !socket.isInputShutdown() && !socket.isOutputShutdown();\n  }\n\n  public boolean isBroken() {\n    return broken;\n  }\n\n  public void setBroken() {\n    broken = true;\n  }\n\n  public void sendCommand(final ProtocolCommand cmd, final byte[]... args) {\n    try {\n      connect();\n      Protocol.sendCommand(outputStream, new CommandArguments(cmd).addObjects((Object[]) args));\n    } catch (JedisConnectionException ex) {\n      setBroken();\n      throw ex;\n    }\n  }\n\n  public Object getOne() {\n    flush();\n    return readProtocolWithCheckingBroken();\n  }\n\n  protected void flush() {\n    try {\n      outputStream.flush();\n    } catch (IOException ex) {\n      setBroken();\n      throw new JedisConnectionException(ex);\n    }\n  }\n\n  protected Object readProtocolWithCheckingBroken() {\n    if (broken) {\n      throw new JedisConnectionException(\"Attempting to read from a broken connection.\");\n    }\n    try {\n      return Protocol.read(inputStream);\n    } catch (JedisConnectionException exc) {\n      broken = true;\n      throw exc;\n    }\n  }\n\n  @Override\n  public void close() {\n    disconnect();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.net.Socket;\n\npublic class Connection implements Closeable {\n    private JedisSocketFactory socketFactory;\n    private Socket socket;\n    private RedisOutputStream outputStream;\n    private RedisInputStream inputStream;\n    private int soTimeout;\n    private boolean broken;\n    private AtomicReference<RedisCredentials> currentCredentials = new AtomicReference<>();\n    private AuthXManager authXManager;\n\n    public Connection(JedisSocketFactory socketFactory) {\n        this.socketFactory = socketFactory;\n    }\n\n    public void connect() {\n        if (isConnected()) {\n            return;\n        }\n        try {\n            socket = socketFactory.createSocket();\n            initStreams();\n            authXManager = new AuthXManager(this);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed connecting to Redis server\", e);\n        }\n    }\n\n    private void initStreams() throws IOException {\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n        inputStream = new RedisInputStream(socket.getInputStream());\n    }\n\n    public void disconnect() {\n        if (!isConnected()) {\n            return;\n        }\n        try {\n            socket.close();\n        } catch (IOException e) {\n            // Ignore\n        } finally {\n            socket = null;\n            outputStream = null;\n            inputStream = null;\n        }\n    }\n\n    public boolean isConnected() {\n        return socket != null && socket.isConnected() && !socket.isClosed();\n    }\n\n    public boolean isBroken() {\n        return broken;\n    }\n\n    public void setBroken() {\n        broken = true;\n    }\n\n    public void sendCommand(ProtocolCommand command, byte[]... args) {\n        if (!isConnected()) {\n            connect();\n        }\n        try {\n            outputStream.write(command.getBinary());\n            for (byte[] arg : args) {\n                outputStream.write(arg);\n            }\n            flush();\n        } catch (IOException e) {\n            setBroken();\n            throw new RuntimeException(\"Failed to send command to Redis\", e);\n        }\n    }\n\n    public Object getOne() {\n        return readProtocolWithCheckingBroken();\n    }\n\n    public void flush() {\n        try {\n            outputStream.flush();\n        } catch (IOException e) {\n            setBroken();\n            throw new RuntimeException(\"Failed to flush output stream\", e);\n        }\n    }\n\n    public Object readProtocolWithCheckingBroken() {\n        try {\n            return inputStream.read();\n        } catch (IOException e) {\n            setBroken();\n            throw new RuntimeException(\"Error reading response from Redis\", e);\n        }\n    }\n\n    @Override\n    public void close() {\n        disconnect();\n    }\n}"
  },
  {
    "Task_id": 319,
    "Instruction": "Task Description: Create a singleton Redis client class that manages a single Redis connection instance throughout the application lifecycle, with automatic shutdown handling.\n\nClass Description: DefaultRedisClient is a singleton class that provides centralized Redis client management. It creates and maintains a single RedisClient instance, configures default timeout settings, and ensures proper resource cleanup during JVM shutdown.\n\nAttributes:\n- instance: DefaultRedisClient - The singleton instance of the class\n- redisClient: RedisClient - The underlying Redis client connection instance\n\nMethods:\n- get() -> RedisClient - Returns the singleton RedisClient instance after setting a default timeout of 60 seconds\n- DefaultRedisClient() (constructor) - Private constructor that initializes the RedisClient with connection settings and registers a shutdown hook\n- run() (in anonymous Thread class) - Shutdown hook method that cleans up Redis client resources during JVM shutdown",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.test.settings.TestSettings;\nimport java.util.concurrent.TimeUnit;\n\npublic class DefaultRedisClient {\n\n    private static final DefaultRedisClient instance = new DefaultRedisClient();\n\n    private RedisClient redisClient;\n\n    private DefaultRedisClient() {\n        redisClient = RedisClient.create(RedisURI.Builder.redis(TestSettings.host(), TestSettings.port()).build());\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            @Override\n            public void run() {\n                FastShutdown.shutdown(redisClient);\n            }\n        });\n    }\n\n    public static RedisClient get() {\n        instance.redisClient.setDefaultTimeout(60, TimeUnit.SECONDS);\n        return instance.redisClient;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class DefaultRedisClient {\n    private static DefaultRedisClient instance;\n    private RedisClient redisClient;\n\n    private DefaultRedisClient() {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(128);\n        poolConfig.setMaxIdle(128);\n        poolConfig.setMinIdle(16);\n        poolConfig.setTestOnBorrow(true);\n        poolConfig.setTestOnReturn(true);\n        poolConfig.setTestWhileIdle(true);\n        poolConfig.setMinEvictableIdleTimeMillis(60000);\n        poolConfig.setTimeBetweenEvictionRunsMillis(30000);\n        poolConfig.setNumTestsPerEvictionRun(3);\n\n        JedisPool jedisPool = new JedisPool(poolConfig, \"localhost\", 6379, 2000);\n        this.redisClient = new RedisClient(jedisPool);\n\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            if (jedisPool != null && !jedisPool.isClosed()) {\n                jedisPool.destroy();\n            }\n        }));\n    }\n\n    public static synchronized DefaultRedisClient getInstance() {\n        if (instance == null) {\n            instance = new DefaultRedisClient();\n        }\n        return instance;\n    }\n\n    public RedisClient get() {\n        return this.redisClient;\n    }\n\n    public static class RedisClient {\n        private JedisPool jedisPool;\n\n        public RedisClient(JedisPool jedisPool) {\n            this.jedisPool = jedisPool;\n        }\n\n        public void set(String key, String value) {\n            try (Jedis jedis = jedisPool.getResource()) {\n                jedis.setex(key, 60, value); // Set with default timeout of 60 seconds\n            }\n        }\n\n        public String get(String key) {\n            try (Jedis jedis = jedisPool.getResource()) {\n                return jedis.get(key);\n            }\n        }\n\n        public void delete(String key) {\n            try (Jedis jedis = jedisPool.getResource()) {\n                jedis.del(key);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a TranslogReader class that handles reading operations from a transaction log (translog) file in Elasticsearch, including managing file channels, checkpoints, and ensuring thread-safe operations.\n\nClass Description: The TranslogReader class extends BaseTranslogReader and implements Closeable, providing functionality to read from a translog file while maintaining checkpoint information and ensuring proper resource management. It handles file channel operations, checkpoint updates, and provides thread-safe closing mechanisms.\n\nAttributes:\n- length: long - The length of the translog file in bytes.\n- totalOperations: int - The total number of operations recorded in the translog.\n- checkpoint: Checkpoint - The checkpoint information containing metadata about the translog state.\n- closed: AtomicBoolean - Thread-safe flag indicating whether the reader is closed.\n\nMethods:\n- TranslogReader(Checkpoint, FileChannel, Path, TranslogHeader) -> [Constructor] - Initializes a new TranslogReader with the given checkpoint, file channel, path, and translog header.\n- open(FileChannel, Path, Checkpoint, String) -> TranslogReader - Static method to open and initialize a TranslogReader instance with the specified parameters.\n- closeIntoTrimmedReader(long, ChannelFactory) -> TranslogReader - Closes the current reader and returns a new trimmed reader based on the specified sequence number, updating the checkpoint if necessary.\n- readBytes(ByteBuffer, long) -> void - Reads bytes from the translog file into the provided buffer at the specified position, with bounds checking.\n- close() -> void - Closes the file channel and marks the reader as closed in a thread-safe manner.\n- isClosed() -> boolean - Returns whether the reader is closed.\n- ensureOpen() -> void - Throws an AlreadyClosedException if the reader is closed.",
    "Canonical_solution": "import org.apache.lucene.store.AlreadyClosedException;\nimport org.elasticsearch.common.io.Channels;\nimport io.crate.common.io.IOUtils;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\n\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.elasticsearch.index.translog.Translog.getCommitCheckpointFileName;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    protected final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    protected final AtomicBoolean closed = new AtomicBoolean(false);\n\n    TranslogReader(final Checkpoint checkpoint, final FileChannel channel, final Path path, final TranslogHeader header) {\n        super(checkpoint.generation, channel, path, header);\n        this.length = checkpoint.offset;\n        this.totalOperations = checkpoint.numOps;\n        this.checkpoint = checkpoint;\n    }\n\n    public static TranslogReader open(\n            final FileChannel channel, final Path path, final Checkpoint checkpoint, final String translogUUID) throws IOException {\n        final TranslogHeader header = TranslogHeader.read(translogUUID, path, channel);\n        return new TranslogReader(checkpoint, channel, path, header);\n    }\n\n    TranslogReader closeIntoTrimmedReader(long aboveSeqNo, ChannelFactory channelFactory) throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            Closeable toCloseOnFailure = channel;\n            final TranslogReader newReader;\n            try {\n                if (aboveSeqNo < checkpoint.trimmedAboveSeqNo\n                    || aboveSeqNo < checkpoint.maxSeqNo && checkpoint.trimmedAboveSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {\n                    final Path checkpointFile = path.getParent().resolve(getCommitCheckpointFileName(checkpoint.generation));\n                    final Checkpoint newCheckpoint = new Checkpoint(checkpoint.offset, checkpoint.numOps,\n                        checkpoint.generation, checkpoint.minSeqNo, checkpoint.maxSeqNo,\n                        checkpoint.globalCheckpoint, checkpoint.minTranslogGeneration, aboveSeqNo);\n                    Checkpoint.write(channelFactory, checkpointFile, newCheckpoint, StandardOpenOption.WRITE);\n\n                    IOUtils.fsync(checkpointFile, false);\n                    IOUtils.fsync(checkpointFile.getParent(), true);\n\n                    newReader = new TranslogReader(newCheckpoint, channel, path, header);\n                } else {\n                    newReader = new TranslogReader(checkpoint, channel, path, header);\n                }\n                toCloseOnFailure = null;\n                return newReader;\n            } finally {\n                IOUtils.close(toCloseOnFailure);\n            }\n        } else {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n\n    protected void readBytes(ByteBuffer buffer, long position) throws IOException {\n        if (position >= length) {\n            throw new EOFException(\"read requested past EOF. pos [\" + position + \"] end: [\" + length + \"]\");\n        }\n        if (position < getFirstOperationOffset()) {\n            throw new IOException(\"read requested before position of first ops. pos [\" + position + \"] first op on: [\" + getFirstOperationOffset() + \"]\");\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, buffer);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            channel.close();\n        }\n    }\n\n    protected final boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n\n    private final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private FileChannel fileChannel;\n    private final Path path;\n\n    public TranslogReader(Checkpoint checkpoint, FileChannel fileChannel, Path path, TranslogHeader header) {\n        this.checkpoint = checkpoint;\n        this.fileChannel = fileChannel;\n        this.path = path;\n        this.length = checkpoint.offset;\n        this.totalOperations = checkpoint.operations;\n    }\n\n    public static TranslogReader open(FileChannel channel, Path path, Checkpoint checkpoint, String expectedUUID) throws IOException {\n        // Assume validation logic for UUID and header\n        return new TranslogReader(checkpoint, channel, path, new TranslogHeader(expectedUUID));\n    }\n\n    public TranslogReader closeIntoTrimmedReader(long sequenceNumber, ChannelFactory channelFactory) throws IOException {\n        ensureOpen();\n        close();\n        Checkpoint trimmedCheckpoint = new Checkpoint(sequenceNumber);\n        FileChannel newChannel = channelFactory.newChannel(path, trimmedCheckpoint);\n        return new TranslogReader(trimmedCheckpoint, newChannel, path, new TranslogHeader(\"trimmed\"));\n    }\n\n    public void readBytes(ByteBuffer buffer, long position) throws IOException {\n        ensureOpen();\n        if (position < 0 || position + buffer.remaining() > length) {\n            throw new IllegalArgumentException(\"Invalid read position or buffer size\");\n        }\n        synchronized (fileChannel) {\n            fileChannel.read(buffer, position);\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            fileChannel.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return closed.get();\n    }\n\n    private void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(\"Reader is already closed.\");\n        }\n    }\n\n    // Supporting classes and interfaces assumed to exist:\n    static class Checkpoint {\n        final long offset;\n        final int operations;\n\n        Checkpoint(long offset) {\n            this.offset = offset;\n            this.operations = 0; // Simplified\n        }\n    }\n\n    static class TranslogHeader {\n        TranslogHeader(String uuid) {}\n    }\n\n    interface ChannelFactory {\n        FileChannel newChannel(Path path, Checkpoint checkpoint) throws IOException;\n    }\n\n    static class AlreadyClosedException extends RuntimeException {\n        AlreadyClosedException(String message) {\n            super(message);\n        }\n    }\n}"
  },
  {
    "Task_id": 321,
    "Instruction": "Task Description: Implement a Redis cluster command executor in Java that handles command execution with retry logic, connection management, and error handling for a Redis cluster environment.\n\nClass Description: ClusterCommandExecutor is a Redis cluster command executor that provides functionality to execute commands across a Redis cluster with support for retries, connection pooling, and handling of various Redis cluster-specific exceptions.\n\nAttributes:\n- provider: ClusterConnectionProvider - Manages connections to the Redis cluster nodes\n- maxAttempts: int - Maximum number of retry attempts for command execution\n- maxTotalRetriesDuration: Duration - Maximum duration for all retry attempts\n- log: Logger - Logger instance for debugging and error logging\n\nMethods:\n- close() -> void - Closes the connection provider and releases resources\n- broadcastCommand(CommandObject<T> commandObject) -> T - Executes a command across all nodes in the cluster and collects responses/errors\n- executeCommand(CommandObject<T> commandObject) -> T - Executes a command on the primary node with retry logic\n- executeCommandToReplica(CommandObject<T> commandObject) -> T - Executes a command on a replica node with retry logic\n- doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) -> T - Internal method handling the execution logic with retries and error handling\n- execute(Connection connection, CommandObject<T> commandObject) -> T - Executes a command on a specific connection\n- handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) -> boolean - Handles connection issues with backoff and slot cache renewal\n- getBackoffSleepMillis(int attemptsLeft, Instant deadline) -> long - Calculates backoff sleep duration for retries\n- sleep(long sleepMillis) -> void - Sleeps for the specified milliseconds, handling interruptions",
    "Canonical_solution": "import redis.clients.jedis.CommandObject;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.exceptions.*;\nimport redis.clients.jedis.providers.ClusterConnectionProvider;\nimport redis.clients.jedis.util.IOUtils;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ClusterCommandExecutor implements CommandExecutor {\n\n  private final Logger log = LoggerFactory.getLogger(getClass());\n\n  public final ClusterConnectionProvider provider;\n  protected final int maxAttempts;\n  protected final Duration maxTotalRetriesDuration;\n\n  public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts,\n      Duration maxTotalRetriesDuration) {\n    this.provider = provider;\n    this.maxAttempts = maxAttempts;\n    this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n  }\n\n  @Override\n  public void close() {\n    this.provider.close();\n  }\n\n  @Override\n  public final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n      HostAndPort node = HostAndPort.from(entry.getKey());\n      ConnectionPool pool = entry.getValue();\n      try (Connection connection = pool.getResource()) {\n        T aReply = execute(connection, commandObject);\n        bcastError.addReply(node, aReply);\n        if (isErrored) {\n        } else if (reply == null) {\n          reply = aReply;\n        } else if (reply.equals(aReply)) {\n        } else {\n          isErrored = true;\n          reply = null;\n        }\n      } catch (Exception anError) {\n        bcastError.addReply(node, anError);\n        isErrored = true;\n      }\n    }\n    if (isErrored) {\n      throw bcastError;\n    }\n    return reply;\n  }\n\n  @Override\n  public final <T> T executeCommand(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, false);\n  }\n\n  public final <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, true);\n  }\n\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        ++consecutiveConnectionFailures;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        if (jre instanceof JedisMovedDataException) {\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n  protected <T> T execute(Connection connection, CommandObject<T> commandObject) {\n    return connection.executeCommand(commandObject);\n  }\n\n  private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n    if (this.maxAttempts < 3) {\n      if (attemptsLeft == 0) {\n        provider.renewSlotCache();\n        return true;\n      }\n      return false;\n    }\n\n    if (consecutiveConnectionFailures < 2) {\n      return false;\n    }\n\n    sleep(getBackoffSleepMillis(attemptsLeft, doneDeadline));\n    provider.renewSlotCache();\n    return true;\n  }\n\n  private static long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n    if (attemptsLeft <= 0) {\n      return 0;\n    }\n\n    long millisLeft = Duration.between(Instant.now(), deadline).toMillis();\n    if (millisLeft < 0) {\n      throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n    }\n\n    long maxBackOff = millisLeft / (attemptsLeft * attemptsLeft);\n    return ThreadLocalRandom.current().nextLong(maxBackOff + 1);\n  }\n\n  protected void sleep(long sleepMillis) {\n    try {\n      TimeUnit.MILLISECONDS.sleep(sleepMillis);\n    } catch (InterruptedException e) {\n      throw new JedisClusterOperationException(e);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.time.Duration;\nimport java.time.Instant;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.slf4j.Logger;\n\npublic class ClusterCommandExecutor implements AutoCloseable {\n\n    private final ClusterConnectionProvider provider;\n    private final int maxAttempts;\n    private final Duration maxTotalRetriesDuration;\n    private final Logger log;\n\n    public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration, Logger log) {\n        this.provider = provider;\n        this.maxAttempts = maxAttempts;\n        this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n        this.log = log;\n    }\n\n    @Override\n    public void close() {\n        provider.close();\n    }\n\n    public <T> T broadcastCommand(CommandObject<T> commandObject) {\n        // Implementation to execute the command across all nodes in the cluster\n        // This would involve iterating through all connections and executing the command\n        return null; // Placeholder\n    }\n\n    public <T> T executeCommand(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, false);\n    }\n\n    public <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, true);\n    }\n\n    private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n        int attemptsLeft = maxAttempts;\n        int consecutiveConnectionFailures = 0;\n        Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n        while (true) {\n            Connection connection = null;\n            try {\n                connection = provider.getConnection(toReplica);\n                return execute(connection, commandObject);\n            } catch (Exception e) {\n                if (attemptsLeft > 0 && isRetryableError(e)) {\n                    consecutiveConnectionFailures++;\n                    if (!handleConnectionProblem(attemptsLeft, consecutiveConnectionFailures, deadline)) {\n                        throw e;\n                    }\n                    attemptsLeft--;\n                } else {\n                    throw e;\n                }\n            } finally {\n                if (connection != null) {\n                    provider.releaseConnection(connection, toReplica);\n                }\n            }\n        }\n    }\n\n    private <T> T execute(Connection connection, CommandObject<T> commandObject) {\n        // Implementation of actual command execution on a given connection\n        return connection.execute(commandObject.getCommand());\n    }\n\n    private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n        long sleepTime = getBackoffSleepMillis(attemptsLeft, doneDeadline);\n        if (sleepTime <= 0) {\n            return false;\n        }\n        sleep(sleepTime);\n        provider.renewSlotCache();\n        return true;\n    }\n\n    private long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n        if (attemptsLeft <= 0 || Instant.now().isAfter(deadline)) {\n            return -1;\n        }\n        long remaining = Duration.between(Instant.now(), deadline).toMillis();\n        return Math.min(remaining, (long) Math.pow(2, maxAttempts - attemptsLeft) * 100);\n    }\n\n    private void sleep(long sleepMillis) {\n        try {\n            Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private boolean isRetryableError(Exception e) {\n        // Check for specific Redis exceptions that warrant retries\n        return e instanceof RedisClusterException || e instanceof ConnectionException;\n    }\n\n    // Placeholder interfaces and classes for compilation purposes\n    public interface CommandObject<T> {\n        String getCommand();\n    }\n\n    public static class ClusterConnectionProvider {\n        public Connection getConnection(boolean toReplica) {\n            return new Connection();\n        }\n\n        public void releaseConnection(Connection connection, boolean toReplica) {\n        }\n\n        public void renewSlotCache() {\n        }\n\n        public void close() {\n        }\n    }\n\n    public static class Connection {\n        public <T> T execute(String command) {\n            return null;\n        }\n    }\n\n    public static class RedisClusterException extends RuntimeException {}\n    public static class ConnectionException extends RuntimeException {}\n}"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a Redis data access object (DAO) class in Java that provides functionality for caching and retrieving Seckill objects using Redis as the storage backend. The class should handle connection management, serialization/deserialization, and implement a cache-aside pattern with distributed locking.\n\nClass Description: RedisDao is a Java class that interacts with Redis to store and retrieve Seckill objects. It uses Jedis as the Redis client, Protostuff for serialization, and implements distributed locking for thread-safe operations.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- schema: RuntimeSchema<Seckill> - The Protostuff schema for Seckill object serialization\n\nMethods:\n- RedisDao(String ip, int port) -> void - Constructor that initializes the JedisPool with given Redis server IP and port\n- getSeckill(long seckillId) -> Seckill - Retrieves a Seckill object from Redis by its ID\n- getSeckill(long seckillId, Jedis jedis) -> Seckill - Retrieves a Seckill object from Redis using an existing Jedis connection\n- getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) -> Seckill - Implements cache-aside pattern with distributed locking, fetching from DB if not in cache\n- putSeckill(Seckill seckill) -> String - Stores a Seckill object in Redis with default expiration\n- putSeckill(Seckill seckill, Jedis jedis) -> String - Stores a Seckill object in Redis using an existing Jedis connection\n- getSeckillRedisKey(long seckillId) -> String - Helper method to generate Redis key for a Seckill object",
    "Canonical_solution": "import cn.codingxiaxw.entity.Seckill;\nimport cn.codingxiaxw.utils.JedisUtils;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\nimport java.util.UUID;\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema = RuntimeSchema.createFrom(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        jedisPool = new JedisPool(ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        return getSeckill(seckillId, null);\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckillId);\n                byte[] bytes = jedis.get(key.getBytes());\n                if (bytes != null) {\n                    Seckill seckill = schema.newMessage();\n                    ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n                    return seckill;\n                }\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String lockKey = \"seckill:locks:getSeckill:\" + seckillId;\n        String lockRequestId = UUID.randomUUID().toString();\n        Jedis jedis = jedisPool.getResource();\n\n        try {\n            while (true) {\n                Seckill seckill = getSeckill(seckillId, jedis);\n                if (seckill != null) {\n                    return seckill;\n                }\n                boolean getLock = JedisUtils.tryGetDistributedLock(jedis, lockKey, lockRequestId, 1000);\n                if (getLock) {\n                    seckill = getDataFromDb.apply(seckillId);\n                    putSeckill(seckill, jedis);\n                    return seckill;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        } catch (Exception ignored) {\n        } finally {\n            JedisUtils.releaseDistributedLock(jedis, lockKey, lockRequestId);\n            jedis.close();\n        }\n        return null;\n    }\n\n    public String putSeckill(Seckill seckill) {\n        return putSeckill(seckill, null);\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckill.getSeckillId());\n                byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema,\n                        LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n                int timeout = 60 * 60;\n                return jedis.setex(key.getBytes(), timeout, bytes);\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.Schema;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private JedisPool jedisPool;\n    private Schema<Seckill> schema = RuntimeSchema.getSchema(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        jedisPool = new JedisPool(new JedisPoolConfig(), ip, port, 2000);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return getSeckill(seckillId, jedis);\n        }\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        try {\n            byte[] key = getSeckillRedisKey(seckillId).getBytes();\n            byte[] data = jedis.get(key);\n            if (data != null) {\n                Seckill seckill = schema.newMessage();\n                ProtostuffIOUtil.mergeFrom(data, seckill, schema);\n                return seckill;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String putSeckill(Seckill seckill) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return putSeckill(seckill, jedis);\n        }\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        try {\n            byte[] key = getSeckillRedisKey(seckill.getId()).getBytes();\n            byte[] data = ProtostuffIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n            int expireTime = 60 * 60; // 1 hour\n            return jedis.setex(key, expireTime, data);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"ERROR\";\n        }\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String lockKey = (\"lock:\" + getSeckillRedisKey(seckillId)).getBytes().toString();\n        String requestId = String.valueOf(System.currentTimeMillis());\n        int lockTimeout = 10000; // 10 seconds\n\n        try (Jedis jedis = jedisPool.getResource()) {\n            Seckill cached = getSeckill(seckillId, jedis);\n            if (cached != null) {\n                return cached;\n            }\n\n            Boolean locked = jedis.set(lockKey.getBytes(), requestId.getBytes(), \"NX\", \"PX\", lockTimeout);\n            if (Boolean.TRUE.equals(locked)) {\n                try {\n                    Seckill dbData = getDataFromDb.apply(seckillId);\n                    if (dbData != null) {\n                        putSeckill(dbData, jedis);\n                    }\n                    return dbData;\n                } finally {\n                    if (requestId.equals(jedis.get(lockKey))) {\n                        jedis.del(lockKey.getBytes());\n                    }\n                }\n            } else {\n                TimeUnit.MILLISECONDS.sleep(50);\n                return getOrPutSeckill(seckillId, getDataFromDb);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}\n\nclass Seckill {\n    private long id;\n    private String name;\n    private long startTime;\n    private long endTime;\n    private long number;\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public long getStartTime() {\n        return startTime;\n    }\n\n    public void setStartTime(long startTime) {\n        this.startTime = startTime;\n    }\n\n    public long getEndTime() {\n        return endTime;\n    }\n\n    public void setEndTime(long endTime) {\n        this.endTime = endTime;\n    }\n\n    public long getNumber() {\n        return number;\n    }\n\n    public void setNumber(long number) {\n        this.number = number;\n    }\n}"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Create a Java class that implements a socket factory for establishing connections to Redis servers, supporting both regular and SSL/TLS connections with configurable timeouts and hostname verification.\n\nClass Description: DefaultJedisSocketFactory is a socket factory implementation for Redis client connections that handles both plain and SSL/TLS sockets, with support for connection timeouts, socket timeouts, host shuffling, and hostname verification.\n\nAttributes:\n- hostAndPort: HostAndPort - The Redis server address and port\n- connectionTimeout: int - Connection timeout in milliseconds\n- socketTimeout: int - Socket timeout in milliseconds\n- ssl: boolean - Flag indicating whether to use SSL/TLS\n- sslSocketFactory: SSLSocketFactory - Factory for creating SSL sockets\n- sslParameters: SSLParameters - SSL/TLS parameters\n- hostnameVerifier: HostnameVerifier - Hostname verifier for SSL/TLS\n- hostAndPortMapper: HostAndPortMapper - Mapper for host and port addresses\n\nMethods:\n- DefaultJedisSocketFactory() -> void - Default constructor using default host and port\n- DefaultJedisSocketFactory(HostAndPort hostAndPort) -> void - Constructor with specified host and port\n- DefaultJedisSocketFactory(JedisClientConfig config) -> void - Constructor with client configuration\n- DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) -> void - Constructor with both host/port and configuration\n- connectToFirstSuccessfulHost(HostAndPort hostAndPort) -> Socket - Internal method to establish connection to first available host\n- createSocket() -> Socket - Creates and returns a configured socket (plain or SSL) to Redis server\n- getSocketHostAndPort() -> HostAndPort - Returns the effective host and port after applying any mapping",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.util.IOUtils;\n\npublic class DefaultJedisSocketFactory implements JedisSocketFactory {\n\n  protected static final HostAndPort DEFAULT_HOST_AND_PORT = new HostAndPort(Protocol.DEFAULT_HOST,\n      Protocol.DEFAULT_PORT);\n\n  private volatile HostAndPort hostAndPort = DEFAULT_HOST_AND_PORT;\n  private int connectionTimeout = Protocol.DEFAULT_TIMEOUT;\n  private int socketTimeout = Protocol.DEFAULT_TIMEOUT;\n  private boolean ssl = false;\n  private SSLSocketFactory sslSocketFactory = null;\n  private SSLParameters sslParameters = null;\n  private HostnameVerifier hostnameVerifier = null;\n  private HostAndPortMapper hostAndPortMapper = null;\n\n  public DefaultJedisSocketFactory() {\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n    this(hostAndPort, null);\n  }\n\n  public DefaultJedisSocketFactory(JedisClientConfig config) {\n    this(null, config);\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n    if (hostAndPort != null) {\n      this.hostAndPort = hostAndPort;\n    }\n    if (config != null) {\n      this.connectionTimeout = config.getConnectionTimeoutMillis();\n      this.socketTimeout = config.getSocketTimeoutMillis();\n      this.ssl = config.isSsl();\n      this.sslSocketFactory = config.getSslSocketFactory();\n      this.sslParameters = config.getSslParameters();\n      this.hostnameVerifier = config.getHostnameVerifier();\n      this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n  }\n\n  private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws Exception {\n    List<InetAddress> hosts = Arrays.asList(InetAddress.getAllByName(hostAndPort.getHost()));\n    if (hosts.size() > 1) {\n      Collections.shuffle(hosts);\n    }\n\n    JedisConnectionException jce = new JedisConnectionException(\"Failed to connect to \" + hostAndPort + \".\");\n    for (InetAddress host : hosts) {\n      try {\n        Socket socket = new Socket();\n\n        socket.setReuseAddress(true);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n        socket.setSoLinger(true, 0);\n\n        socket.connect(new InetSocketAddress(host, hostAndPort.getPort()), connectionTimeout);\n        return socket;\n      } catch (Exception e) {\n        jce.addSuppressed(e);\n      }\n    }\n    throw jce;\n  }\n\n  @Override\n  public Socket createSocket() throws JedisConnectionException {\n    Socket socket = null;\n    try {\n      HostAndPort _hostAndPort = getSocketHostAndPort();\n      socket = connectToFirstSuccessfulHost(_hostAndPort);\n      socket.setSoTimeout(socketTimeout);\n\n      if (ssl) {\n        SSLSocketFactory _sslSocketFactory = this.sslSocketFactory;\n        if (null == _sslSocketFactory) {\n          _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n        Socket plainSocket = socket;\n        socket = _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (null != sslParameters) {\n          ((SSLSocket) socket).setSSLParameters(sslParameters);\n        }\n        socket = new SSLSocketWrapper((SSLSocket) socket, plainSocket);\n\n        if (null != hostnameVerifier\n            && !hostnameVerifier.verify(_hostAndPort.getHost(), ((SSLSocket) socket).getSession())) {\n          String message = String.format(\n            \"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n          throw new JedisConnectionException(message);\n        }\n      }\n\n      return socket;\n\n    } catch (Exception ex) {\n      IOUtils.closeQuietly(socket);\n      if (ex instanceof JedisConnectionException) {\n        throw (JedisConnectionException) ex;\n      } else {\n        throw new JedisConnectionException(\"Failed to create socket.\", ex);\n      }\n    }\n  }\n\n  protected HostAndPort getSocketHostAndPort() {\n    HostAndPortMapper mapper = hostAndPortMapper;\n    HostAndPort hap = this.hostAndPort;\n    if (mapper != null) {\n      HostAndPort mapped = mapper.getHostAndPort(hap);\n      if (mapped != null) {\n        return mapped;\n      }\n    }\n    return hap;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.HostnameVerifier;\n\npublic class DefaultJedisSocketFactory {\n\n    private HostAndPort hostAndPort;\n    private int connectionTimeout;\n    private int socketTimeout;\n    private boolean ssl;\n    private SSLSocketFactory sslSocketFactory;\n    private SSLParameters sslParameters;\n    private HostnameVerifier hostnameVerifier;\n    private HostAndPortMapper hostAndPortMapper;\n\n    public DefaultJedisSocketFactory() {\n        this(null);\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n        this(hostAndPort, new JedisClientConfig());\n    }\n\n    public DefaultJedisSocketFactory(JedisClientConfig config) {\n        this(null, config);\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSocketTimeout();\n        this.ssl = config.isSsl();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    protected Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws IOException {\n        Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(hostAndPort.getHost(), hostAndPort.getPort()), connectionTimeout);\n            socket.setSoTimeout(socketTimeout);\n            return socket;\n        } catch (IOException e) {\n            try {\n                socket.close();\n            } catch (IOException ex) {\n                // Ignore exception during close\n            }\n            throw e;\n        }\n    }\n\n    public Socket createSocket() throws IOException {\n        HostAndPort targetHostAndPort = getSocketHostAndPort();\n\n        if (ssl) {\n            SSLSocket socket = (SSLSocket) (sslSocketFactory != null ? sslSocketFactory.createSocket() : (SSLSocketFactory) SSLSocketFactory.getDefault()).createSocket();\n            if (sslParameters != null) {\n                socket.setSSLParameters(sslParameters);\n            }\n            socket.connect(new InetSocketAddress(targetHostAndPort.getHost(), targetHostAndPort.getPort()), connectionTimeout);\n            socket.setSoTimeout(socketTimeout);\n\n            if (hostnameVerifier != null && !hostnameVerifier.verify(targetHostAndPort.getHost(), socket.getSession())) {\n                throw new IOException(\"Hostname verification failed for \" + targetHostAndPort.getHost());\n            }\n\n            return socket;\n        } else {\n            return connectToFirstSuccessfulHost(targetHostAndPort);\n        }\n    }\n\n    public HostAndPort getSocketHostAndPort() {\n        HostAndPort mappedHostAndPort = hostAndPortMapper != null ? hostAndPortMapper.mapHostAndPort(hostAndPort) : hostAndPort;\n        return mappedHostAndPort != null ? mappedHostAndPort : new HostAndPort(\"localhost\", 6379);\n    }\n}"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a Java class that utilizes Java NIO's FileChannel to map a file into memory for read-only access, providing methods to access the mapped memory address and file size, and properly closing the channel when done.\n\nClass Description: The FileChannelProcessor class provides functionality to open a file using FileChannel, map it into memory in read-only mode, and expose the memory address and file size. It ensures proper resource cleanup by implementing a close method.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedAddress: long - The memory address where the file is mapped\nfileSize: long - The size of the mapped file in bytes\n\nMethods:\nFileChannelProcessor: [Constructor](String filePath) throws IOException - Initializes the FileChannel, maps the file into memory in read-only mode, and stores the memory address and file size\ngetMappedAddress: () -> long - Returns the memory address where the file is mapped\ngetFileSize: () -> long - Returns the size of the mapped file\nclose: () throws IOException - Closes the FileChannel to release system resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelProcessor {\n    private FileChannel fileChannel;\n    private long mappedAddress;\n    private long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Path.of(filePath), StandardOpenOption.READ);\n        this.fileSize = fileChannel.size();\n        this.mappedAddress = fileChannel.map(MapMode.READ_ONLY, 0, fileSize, Arena.global()).address();\n    }\n\n    public long getMappedAddress() {\n        return mappedAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.MappedByteBuffer;\n\npublic class FileChannelProcessor implements AutoCloseable {\n    private FileChannel fileChannel;\n    private long mappedAddress;\n    private long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        FileInputStream fis = new FileInputStream(filePath);\n        this.fileChannel = fis.getChannel();\n        this.fileSize = fileChannel.size();\n        MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n        this.mappedAddress = ((sun.nio.ch.DirectBuffer) buffer).address();\n    }\n\n    public long getMappedAddress() {\n        return mappedAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (fileChannel != null && fileChannel.isOpen()) {\n            fileChannel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 330,
    "Instruction": "Task Description: Implement a Java class for interacting with Redis using the Lettuce client, including connection management and data operations.\n\nClass Description: The RedisInteraction class provides functionality to establish and manage a connection to a Redis server, perform bulk data operations, and clean up resources. It uses the Lettuce client library for Redis interactions.\n\nAttributes:\n- client: RedisClient - The Redis client instance used to create connections\n- connection: StatefulRedisConnection<String, String> - The active connection to the Redis server\n\nMethods:\n- initializeConnection() -> void - Initializes the Redis client and establishes a connection to the Redis server. Also clears all existing data in Redis.\n- closeConnection() -> void - Closes the Redis connection and shuts down the client to release resources.\n- createRedisPublisher(long elements) -> Publisher<String> - Creates and returns a Publisher that streams Redis keys. Populates Redis with test data (number of elements specified by input parameter) before creating the publisher. Returns null if elements equals Long.MAX_VALUE.",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.ScanStream;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.test.resource.FastShutdown;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.lettuce.test.settings.TestSettings;\nimport org.reactivestreams.Publisher;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RedisInteraction {\n\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(TestClientResources.get(), RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = client.connect();\n        connection.sync().flushall();\n    }\n\n    public void closeConnection() {\n        connection.close();\n        FastShutdown.shutdown(client);\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        RedisCommands<String, String> sync = connection.sync();\n        sync.flushall();\n\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        Map<String, String> map = new HashMap<>();\n        for (int i = 0; i < elements; i++) {\n            String element = \"RedisInteraction-\" + i;\n            map.put(element, element);\n\n            if (i % 1000 - 2020 == 0 && !map.isEmpty()) {\n                sync.mset(map);\n                map.clear();\n            }\n        }\n\n        if (!map.isEmpty()) {\n            sync.mset(map);\n            map.clear();\n        }\n\n        return ScanStream.scan(connection.reactive());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport reactor.core.publisher.Flux;\n\npublic class RedisInteraction {\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(RedisURI.create(\"localhost\", 6379));\n        connection = client.connect();\n        RedisCommands<String, String> commands = connection.sync();\n        commands.flushall();\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        RedisCommands<String, String> commands = connection.sync();\n\n        for (long i = 0; i < elements; i++) {\n            String key = \"key:\" + i;\n            String value = \"value:\" + i;\n            commands.set(key, value);\n        }\n\n        return Flux.range(0, (int) elements)\n                   .map(i -> \"key:\" + i)\n                   .toProcessor();\n    }\n}"
  },
  {
    "Task_id": 331,
    "Instruction": "Task Description: Implement a multi-cluster Redis connection provider that manages connections to multiple Redis clusters with failover capabilities and connection pooling.\n\nClass Description: MultiClusterPooledConnectionProvider is a connection provider that maintains connections to multiple Redis clusters, allowing for cluster failover and providing pooled connections to improve performance. It uses a priority-based system to determine the active cluster and provides thread-safe access to connections.\n\nAttributes:\n- log: Logger - Logger instance for logging events and errors\n- multiClusterMap: Map<Integer, Cluster> - Concurrent map storing Redis clusters with their priority as key\n- activeMultiClusterIndex: Integer - Currently active cluster index (volatile for thread visibility)\n- activeClusterIndexLock: Lock - Reentrant lock for thread-safe modification of active cluster index\n- lastClusterCircuitBreakerForcedOpen: boolean - Flag indicating if circuit breaker was last forced open (volatile for thread visibility)\n\nMethods:\n- MultiClusterPooledConnectionProvider(MultiClusterClientConfig) -> void - Constructor that initializes the connection pools for all configured Redis clusters\n  Input: multiClusterClientConfig - Configuration object containing cluster settings\n  Throws: JedisValidationException if config is null\n\n- getConnection() -> Connection - Gets a connection from the currently active Redis cluster\n  Output: Connection object from the active cluster's pool\n\n- getConnection(int) -> Connection - Gets a connection from a specific Redis cluster by index\n  Input: multiClusterIndex - Priority index of the desired cluster\n  Output: Connection object from the specified cluster's pool\n\n- close() -> void - Closes the connection pool of the currently active cluster\n\nNested Class: Cluster\n- connectionPool: ConnectionPool - Pool of Redis connections for a specific cluster\n- getConnection() -> Connection - Gets a connection from this cluster's pool\n- getConnectionPool() -> ConnectionPool - Returns the connection pool instance",
    "Canonical_solution": "import io.github.resilience4j.circuitbreaker.CircuitBreaker;\nimport io.github.resilience4j.circuitbreaker.CircuitBreaker.State;\nimport io.github.resilience4j.retry.Retry;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisValidationException;\nimport redis.clients.jedis.util.Pool;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class MultiClusterPooledConnectionProvider implements ConnectionProvider {\n\n    private final Logger log = LoggerFactory.getLogger(getClass());\n    private final Map<Integer, Cluster> multiClusterMap = new ConcurrentHashMap<>();\n    private volatile Integer activeMultiClusterIndex = 1;\n    private final Lock activeClusterIndexLock = new ReentrantLock(true);\n    private volatile boolean lastClusterCircuitBreakerForcedOpen = false;\n\n    public MultiClusterPooledConnectionProvider(MultiClusterClientConfig multiClusterClientConfig) {\n        if (multiClusterClientConfig == null)\n            throw new JedisValidationException(\"MultiClusterClientConfig must not be NULL for MultiClusterPooledConnectionProvider\");\n\n        ClusterConfig[] clusterConfigs = multiClusterClientConfig.getClusterConfigs();\n        for (ClusterConfig config : clusterConfigs) {\n            GenericObjectPoolConfig<Connection> poolConfig = config.getConnectionPoolConfig();\n            String clusterId = \"cluster:\" + config.getPriority() + \":\" + config.getHostAndPort();\n\n            if (poolConfig != null) {\n                multiClusterMap.put(config.getPriority(),\n                        new Cluster(new ConnectionPool(config.getHostAndPort(),\n                                config.getJedisClientConfig(), poolConfig)));\n            } else {\n                multiClusterMap.put(config.getPriority(),\n                        new Cluster(new ConnectionPool(config.getHostAndPort(),\n                                config.getJedisClientConfig())));\n            }\n        }\n    }\n\n    @Override\n    public Connection getConnection() {\n        return multiClusterMap.get(activeMultiClusterIndex).getConnection();\n    }\n\n    public Connection getConnection(int multiClusterIndex) {\n        return multiClusterMap.get(multiClusterIndex).getConnection();\n    }\n\n    @Override\n    public void close() {\n        multiClusterMap.get(activeMultiClusterIndex).getConnectionPool().close();\n    }\n\n    public static class Cluster {\n        private final ConnectionPool connectionPool;\n\n        public Cluster(ConnectionPool connectionPool) {\n            this.connectionPool = connectionPool;\n        }\n\n        public Connection getConnection() {\n            return connectionPool.getResource();\n        }\n\n        public ConnectionPool getConnectionPool() {\n            return connectionPool;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class MultiClusterPooledConnectionProvider {\n    private static final Logger log = LoggerFactory.getLogger(MultiClusterPooledConnectionProvider.class);\n    private final Map<Integer, Cluster> multiClusterMap = new ConcurrentHashMap<>();\n    private volatile Integer activeMultiClusterIndex;\n    private final Lock activeClusterIndexLock = new ReentrantLock();\n    private volatile boolean lastClusterCircuitBreakerForcedOpen = false;\n\n    public MultiClusterPooledConnectionProvider(MultiClusterClientConfig multiClusterClientConfig) throws JedisValidationException {\n        if (multiClusterClientConfig == null) {\n            throw new JedisValidationException(\"Configuration cannot be null\");\n        }\n\n        for (ClusterConfig clusterConfig : multiClusterClientConfig.getClusterConfigs()) {\n            Cluster cluster = new Cluster(clusterConfig);\n            multiClusterMap.put(clusterConfig.getPriority(), cluster);\n        }\n\n        this.activeMultiClusterIndex = multiClusterClientConfig.getDefaultClusterPriority();\n    }\n\n    public Connection getConnection() {\n        Integer currentActiveIndex = this.activeMultiClusterIndex;\n        Cluster activeCluster = multiClusterMap.get(currentActiveIndex);\n\n        if (activeCluster != null && isActiveClusterAvailable(activeCluster)) {\n            try {\n                return activeCluster.getConnection();\n            } catch (Exception e) {\n                log.error(\"Failed to get connection from active cluster: {}\", currentActiveIndex, e);\n                handleClusterFailure(currentActiveIndex);\n            }\n        }\n\n        // Try next available cluster in priority order\n        for (Integer priority : multiClusterMap.keySet()) {\n            if (priority.equals(currentActiveIndex)) continue;\n            Cluster candidateCluster = multiClusterMap.get(priority);\n            if (isActiveClusterAvailable(candidateCluster)) {\n                try {\n                    if (attemptFailoverToCluster(priority, candidateCluster)) {\n                        return candidateCluster.getConnection();\n                    }\n                } catch (Exception e) {\n                    log.error(\"Failed to get connection from candidate cluster: {}\", priority, e);\n                    markClusterAsUnhealthy(priority);\n                }\n            }\n        }\n\n        throw new RuntimeException(\"No available Redis clusters to establish a connection\");\n    }\n\n    public Connection getConnection(int multiClusterIndex) {\n        Cluster targetCluster = multiClusterMap.get(multiClusterIndex);\n        if (targetCluster == null) {\n            throw new IllegalArgumentException(\"No cluster configured with index: \" + multiClusterIndex);\n        }\n\n        try {\n            return targetCluster.getConnection();\n        } catch (Exception e) {\n            log.error(\"Failed to get connection from cluster: {}\", multiClusterIndex, e);\n            if (multiClusterIndex == activeMultiClusterIndex) {\n                handleClusterFailure(multiClusterIndex);\n            }\n            throw e;\n        }\n    }\n\n    public void close() {\n        Cluster activeCluster = multiClusterMap.get(activeMultiClusterIndex);\n        if (activeCluster != null) {\n            try {\n                activeCluster.getConnectionPool().close();\n                log.info(\"Closed connection pool for active cluster: {}\", activeMultiClusterIndex);\n            } catch (Exception e) {\n                log.warn(\"Error closing connection pool for cluster {}: {}\", activeMultiClusterIndex, e.getMessage());\n            }\n        }\n    }\n\n    private boolean isActiveClusterAvailable(Cluster cluster) {\n        try {\n            // Implement health check logic here\n            return !cluster.getConnectionPool().isClosed(); // Example condition\n        } catch (Exception e) {\n            log.warn(\"Health check failed for cluster: {}\", cluster, e);\n            return false;\n        }\n    }\n\n    private void handleClusterFailure(Integer failedClusterIndex) {\n        log.warn(\"Handling failure for cluster: {}\", failedClusterIndex);\n        markClusterAsUnhealthy(failedClusterIndex);\n        attemptAutomaticFailover();\n    }\n\n    private void markClusterAsUnhealthy(Integer clusterIndex) {\n        // Implementation for marking the cluster as unhealthy\n        log.debug(\"Marked cluster {} as unhealthy\", clusterIndex);\n    }\n\n    private void attemptAutomaticFailover() {\n        for (Integer priority : multiClusterMap.keySet()) {\n            Cluster candidate = multiClusterMap.get(priority);\n            if (isActiveClusterAvailable(candidate)) {\n                attemptFailoverToCluster(priority, candidate);\n                break;\n            }\n        }\n    }\n\n    private boolean attemptFailoverToCluster(Integer newClusterIndex, Cluster newCluster) {\n        activeClusterIndexLock.lock();\n        try {\n            if (!newClusterIndex.equals(activeMultiClusterIndex)) {\n                Integer oldIndex = activeMultiClusterIndex;\n                activeMultiClusterIndex = newClusterIndex;\n                log.info(\"Switching active cluster from {} to {}\", oldIndex, newClusterIndex);\n                return true;\n            }\n            return false;\n        } finally {\n            activeClusterIndexLock.unlock();\n        }\n    }\n\n    public static class Cluster {\n        private final ConnectionPool connectionPool;\n\n        public Cluster(ClusterConfig config) {\n            this.connectionPool = new ConnectionPool(config.getRedisNodes(), config.getMaxTotal(), config.getMaxIdle());\n        }\n\n        public Connection getConnection() {\n            return connectionPool.getConnection();\n        }\n\n        public ConnectionPool getConnectionPool() {\n            return connectionPool;\n        }\n    }\n}"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a Redis configuration class in Java that sets up Redis connection and template configurations using Spring Boot and Redisson.\n\nClass Description: The RedisConfig class is a Spring configuration class that provides Redis-related beans including RedisTemplate, RedissonClient, and a custom KeyGenerator. It configures connection settings, serialization, and client instances for Redis operations.\n\nAttributes:\n- REDIS_PREFIX: [String] - A constant string prefix for Redis connection URLs (\"redis://\")\n\nMethods:\n- redisTemplate: [redisTemplate](LettuceConnectionFactory lettuceConnectionFactory) -> RedisTemplate<Object, Object> - Creates and configures a RedisTemplate with FastJson serialization and String key serialization\n- redisson: [redisson](RedisProperties redisProperties) -> RedissonClient - Creates and configures a Redisson client instance with single server configuration\n- keyGenerator: [keyGenerator]() -> KeyGenerator - Creates a custom key generator that produces SHA-256 hashes of method invocation details\n\nThe class uses Spring annotations (@Configuration, @Bean, etc.) to manage bean creation and dependencies, and integrates with Spring Boot's RedisProperties for configuration.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.config.SingleServerConfig;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.data.redis.RedisProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.core.RedisOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean(name = \"redisTemplate\")\n    @ConditionalOnMissingBean(name = \"redisTemplate\")\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        FastJsonRedisSerializer<Object> fastJsonRedisSerializer = new FastJsonRedisSerializer<>(Object.class);\n        template.setValueSerializer(fastJsonRedisSerializer);\n        template.setHashValueSerializer(fastJsonRedisSerializer);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setConnectionFactory(lettuceConnectionFactory);\n        return template;\n    }\n\n    @Bean(destroyMethod = \"shutdown\")\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        SingleServerConfig singleServerConfig = config.useSingleServer();\n        singleServerConfig.setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort());\n        if (redisProperties.getPassword() != null && !redisProperties.getPassword().isEmpty()) {\n            singleServerConfig.setPassword(redisProperties.getPassword());\n        }\n        singleServerConfig.setPingConnectionInterval(1000);\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            Map<String, Object> container = new HashMap<>(3);\n            Class<?> targetClassClass = target.getClass();\n            container.put(\"class\", targetClassClass.toGenericString());\n            container.put(\"methodName\", method.getName());\n            container.put(\"package\", targetClassClass.getPackage());\n            for (int i = 0; i < params.length; i++) {\n                container.put(String.valueOf(i), params[i]);\n            }\n            String jsonString = JSON.toJSONString(container);\n            return DigestUtils.sha256Hex(jsonString);\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "@Configuration\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(lettuceConnectionFactory);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(new GenericFastJsonRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(new GenericFastJsonRedisSerializer());\n        return template;\n    }\n\n    @Bean\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        SingleServerConfig serverConfig = config.useSingleServer()\n                .setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort())\n                .setPassword(redisProperties.getPassword())\n                .setDatabase(redisProperties.getDatabase());\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            String key = target.getClass().getName() + \".\" + method.getName() + Arrays.deepToString(params);\n            byte[] hash = digest.digest(key.getBytes(StandardCharsets.UTF_8));\n            return new String(Hex.encodeHex(hash));\n        };\n    }\n}"
  },
  {
    "Task_id": 339,
    "Instruction": "Task Description: Implement a Redis client class in Java that supports read-write operations with master-slave architecture, connection pooling, and proper resource management.\n\nClass Description: ReadWriteRedisClient is a Java class that provides a Redis client implementation with support for master-slave architecture. It uses connection pooling (via JedisPool) for efficient resource management and implements basic CRUD operations with automatic routing of read operations to slaves and write operations to the master.\n\nAttributes:\n- master: JedisPool - Connection pool for the master Redis instance\n- slaves: List<JedisPool> - List of connection pools for slave Redis instances\n- jedisPoolConfig: JedisPoolConfig - Configuration for the connection pools\n- address: String - Comma-separated list of Redis server addresses (master first)\n- timeout: int - Connection timeout in milliseconds\n- random: Random - Random number generator for slave selection\n\nMethods:\n- initialize() -> void - Initializes the Redis connection pools based on the configured addresses\n- destroy() -> void - Closes all connection pools and releases resources\n- get(String key) -> String - Retrieves a value from Redis (reads from a random slave)\n- set(String key, String value) -> String - Stores a value in Redis (writes to master)\n- fetchResource(boolean read) -> Jedis - Internal method to get a Redis connection (selects master or random slave)\n- setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) -> void - Sets the connection pool configuration\n- setTimeout(int timeout) -> void - Sets the connection timeout\n- setAddress(String address) -> void - Sets the Redis server addresses",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class ReadWriteRedisClient {\n\n    private JedisPool master;\n    private List<JedisPool> slaves = new ArrayList<JedisPool>();\n    private JedisPoolConfig jedisPoolConfig;\n    private String address;\n    private int timeout = 3000;\n    private Random random = new Random();\n\n    public void initialize() throws Exception {\n        String[] hostAndPorts = address.split(\",\");\n        String masterHP = hostAndPorts[0];\n        String[] ms = masterHP.split(\":\");\n        master = new JedisPool(jedisPoolConfig, ms[0], Integer.valueOf(ms[1]), timeout);\n        if (hostAndPorts.length > 1) {\n            for (int i = 1; i < hostAndPorts.length; i++) {\n                String[] ss = hostAndPorts[i].split(\":\");\n                JedisPool slave = new JedisPool(jedisPoolConfig, ss[0], Integer.valueOf(ss[1]), timeout);\n                slaves.add(slave);\n            }\n        }\n        slaves.add(master);\n    }\n\n    public void destroy() throws Exception {\n        if (master != null) {\n            master.close();\n        }\n        for (JedisPool slave : slaves) {\n            if (slave != null) {\n                slave.close();\n            }\n        }\n    }\n\n    public String get(String key) {\n        Jedis jedis = fetchResource(true);\n        try {\n            return jedis.get(key);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public String set(String key, String value) {\n        Jedis jedis = fetchResource(false);\n        try {\n            return jedis.set(key, value);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    private Jedis fetchResource(boolean read) {\n        if(slaves.isEmpty() || !read) {\n            return master.getResource();\n        }\n        int size = slaves.size();\n        int i = random.nextInt(size);\n        return slaves.get(i).getResource();\n    }\n\n    public void setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) {\n        this.jedisPoolConfig = jedisPoolConfig;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.*;\nimport java.util.*;\n\npublic class ReadWriteRedisClient {\n    private JedisPool master;\n    private List<JedisPool> slaves = new ArrayList<>();\n    private JedisPoolConfig jedisPoolConfig;\n    private String address;\n    private int timeout = 2000;\n    private Random random = new Random();\n\n    public void initialize() {\n        if (address == null || address.isEmpty()) return;\n        String[] addresses = address.split(\",\");\n        if (addresses.length == 0) return;\n\n        String[] masterAddr = addresses[0].split(\":\");\n        JedisPool masterPool = new JedisPool(jedisPoolConfig, masterAddr[0], Integer.parseInt(masterAddr[1]), timeout);\n        this.master = masterPool;\n\n        for (int i = 1; i < addresses.length; i++) {\n            String[] slaveAddr = addresses[i].split(\":\");\n            this.slaves.add(new JedisPool(jedisPoolConfig, slaveAddr[0], Integer.parseInt(slaveAddr[1]), timeout));\n        }\n    }\n\n    public void destroy() {\n        if (master != null) master.close();\n        for (JedisPool pool : slaves) {\n            if (pool != null) pool.close();\n        }\n        slaves.clear();\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = fetchResource(true)) {\n            return jedis.get(key);\n        }\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = fetchResource(false)) {\n            return jedis.set(key, value);\n        }\n    }\n\n    private Jedis fetchResource(boolean read) {\n        if (read && !slaves.isEmpty()) {\n            return slaves.get(random.nextInt(slaves.size())).getResource();\n        } else {\n            return master.getResource();\n        }\n    }\n\n    public void setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) {\n        this.jedisPoolConfig = jedisPoolConfig;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}"
  },
  {
    "Task_id": 341,
    "Instruction": "Task Description: Create a Java class that implements Redis client functionality using Jedis for basic key-value operations, hash operations, and key expiration management.\n\nClass Description: JedisClientSingle is a Redis client wrapper class that provides simplified access to common Redis operations using connection pooling. It handles connection management, authentication, and resource cleanup automatically.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- password: String - The password for Redis authentication (optional)\n- port: int - The port number of the Redis server\n- host: String - The host address of the Redis server\n- logger: Logger - SLF4J logger instance for logging operations\n\nMethods:\n- getResource() -> Jedis - Internal method to get a Jedis instance from the pool and authenticate if needed\n- get(String key) -> String - Retrieves the value associated with the given key\n- set(String key, String value) -> String - Sets the value for the given key\n- hget(String hkey, String key) -> String - Gets the value of a field in a hash\n- hset(String hkey, String key, String value) -> long - Sets the value of a field in a hash\n- incr(String key) -> long - Increments the integer value of a key by 1\n- expire(String key, Integer second) -> long - Sets a timeout on a key\n- ttl(String key) -> long - Gets the remaining time to live of a key\n- del(String key) -> long - Deletes a key\n- hdel(String hkey, String key) -> long - Deletes a field from a hash",
    "Canonical_solution": "import org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class JedisClientSingle {\n\n    private static final Logger logger = LoggerFactory.getLogger(JedisClientSingle.class);\n\n    private JedisPool jedisPool;\n    private String password;\n    private int port;\n    private String host;\n\n    private Jedis getResource() {\n        if(jedisPool==null) {\n            jedisPool = new JedisPool(host, port);\n        }\n        Jedis resource = jedisPool.getResource();\n        if (StringUtils.isBlank(password)) {\n            return resource;\n        } else {\n            resource.auth(password);\n            return resource;\n        }\n    }\n\n    public String get(String key) {\n        Jedis resource = getResource();\n        String string = resource.get(key);\n        resource.close();\n        return string;\n    }\n\n    public String set(String key, String value) {\n        Jedis resource = getResource();\n        String string = resource.set(key, value);\n        resource.close();\n        return string;\n    }\n\n    public String hget(String hkey, String key) {\n        Jedis resource = getResource();\n        String string = resource.hget(hkey, key);\n        resource.close();\n        return string;\n    }\n\n    public long hset(String hkey, String key, String value) {\n        Jedis resource = getResource();\n        Long hset = resource.hset(hkey, key, value);\n        resource.close();\n        return hset;\n    }\n\n    public long incr(String key) {\n        Jedis resource = getResource();\n        Long incr = resource.incr(key);\n        resource.close();\n        return incr;\n    }\n\n    public long expire(String key, Integer second) {\n        Jedis resource = getResource();\n        Long expire = resource.expire(key, second);\n        resource.close();\n        return expire;\n    }\n\n    public long ttl(String key) {\n        Jedis resource = getResource();\n        Long ttl = resource.ttl(key);\n        resource.close();\n        return ttl;\n    }\n\n    public long del(String key) {\n        Jedis resource = getResource();\n        Long del = resource.del(key);\n        resource.close();\n        return del;\n    }\n\n    public long hdel(String hkey, String key) {\n        Jedis resource = getResource();\n        Long hdel = resource.hdel(hkey, key);\n        resource.close();\n        return hdel;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class JedisClientSingle {\n    private static final Logger logger = LoggerFactory.getLogger(JedisClientSingle.class);\n    private JedisPool jedisPool;\n    private String password;\n    private int port;\n    private String host;\n\n    public JedisClientSingle(String host, int port, String password) {\n        this.host = host;\n        this.port = port;\n        this.password = password;\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port);\n    }\n\n    private Jedis getResource() {\n        Jedis jedis = jedisPool.getResource();\n        if (password != null && !password.isEmpty()) {\n            jedis.auth(password);\n        }\n        return jedis;\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.get(key);\n        } catch (Exception e) {\n            logger.error(\"Error getting key: \" + key, e);\n            return null;\n        }\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getResource()) {\n            return jedis.set(key, value);\n        } catch (Exception e) {\n            logger.error(\"Error setting key: \" + key, e);\n            return null;\n        }\n    }\n\n    public String hget(String hkey, String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hget(hkey, key);\n        } catch (Exception e) {\n            logger.error(\"Error getting hash field: \" + key + \" from hash: \" + hkey, e);\n            return null;\n        }\n    }\n\n    public long hset(String hkey, String key, String value) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hset(hkey, key, value);\n        } catch (Exception e) {\n            logger.error(\"Error setting hash field: \" + key + \" in hash: \" + hkey, e);\n            return 0;\n        }\n    }\n\n    public long incr(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.incr(key);\n        } catch (Exception e) {\n            logger.error(\"Error incrementing key: \" + key, e);\n            return 0;\n        }\n    }\n\n    public long expire(String key, Integer second) {\n        try (Jedis jedis = getResource()) {\n            return jedis.expire(key, second);\n        } catch (Exception e) {\n            logger.error(\"Error expiring key: \" + key, e);\n            return 0;\n        }\n    }\n\n    public long ttl(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.ttl(key);\n        } catch (Exception e) {\n            logger.error(\"Error getting TTL for key: \" + key, e);\n            return -1;\n        }\n    }\n\n    public long del(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.del(key);\n        } catch (Exception e) {\n            logger.error(\"Error deleting key: \" + key, e);\n            return 0;\n        }\n    }\n\n    public long hdel(String hkey, String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hdel(hkey, key);\n        } catch (Exception e) {\n            logger.error(\"Error deleting hash field: \" + key + \" from hash: \" + hkey, e);\n            return 0;\n        }\n    }\n}"
  },
  {
    "Task_id": 342,
    "Instruction": "Task Description: Create a Redis connection factory class in Java that handles both standalone Redis instances and Redis clusters, with support for connection pooling and sentinel configurations.\n\nClass Description: The RedisConnectionFactory class provides a centralized way to create and manage Redis connections (both standalone and cluster) with configurable connection parameters. It handles connection pooling, authentication, and resource cleanup.\n\nAttributes:\n- hostName: String - The Redis server hostname (default: \"localhost\")\n- port: int - The Redis server port (default: 6379)\n- timeout: int - Connection timeout in milliseconds (default: 2000)\n- password: String - Password for Redis authentication\n- sentinelMaster: String - Name of the Redis sentinel master\n- redisServers: List<RedisNode> - List of Redis server nodes for cluster/sentinel configuration\n- isCluster: boolean - Flag indicating whether to use Redis cluster mode\n- dbIndex: int - Redis database index to select (default: 0)\n- shardInfo: JedisShardInfo - Redis connection shard information\n- pool: Pool<Jedis> - Jedis connection pool instance\n- cluster: JedisCluster - Jedis cluster instance\n- poolConfig: JedisPoolConfig - Configuration for the connection pool\n\nMethods:\n- init(): void - Initializes the Redis connection factory by creating either a connection pool or cluster instance\n- destroy(): void - Cleans up resources by closing all active connections and pools\n- fetchJedisConnector(): Jedis - Internal method to fetch a Jedis connection from pool or create a new one\n- createPool(): Pool<Jedis> - Creates a Redis connection pool (either regular or sentinel)\n- createRedisSentinelPool(): Pool<Jedis> - Creates a Redis sentinel connection pool\n- createRedisPool(): Pool<Jedis> - Creates a regular Redis connection pool\n- createCluster(): JedisCluster - Creates a Redis cluster connection\n- getJedisConnection(): Jedis - Returns a configured Jedis connection\n- getClusterConnection(): JedisCluster - Returns the Jedis cluster instance",
    "Canonical_solution": "import com.mpush.cache.redis.RedisServer;\nimport com.mpush.tools.config.data.RedisNode;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.util.Pool;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class RedisConnectionFactory {\n\n    private final static Logger log = LoggerFactory.getLogger(RedisConnectionFactory.class);\n\n    private String hostName = \"localhost\";\n    private int port = Protocol.DEFAULT_PORT;\n    private int timeout = Protocol.DEFAULT_TIMEOUT;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig = new JedisPoolConfig();\n\n    public RedisConnectionFactory() {\n    }\n\n    protected Jedis fetchJedisConnector() {\n        try {\n            if (pool != null) {\n                return pool.getResource();\n            }\n            Jedis jedis = new Jedis(getShardInfo());\n            jedis.connect();\n            return jedis;\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Cannot get Jedis connection\", ex);\n        }\n    }\n\n    public void init() {\n        if (shardInfo == null) {\n            shardInfo = new JedisShardInfo(hostName, port);\n            if (StringUtils.isNotEmpty(password)) {\n                shardInfo.setPassword(password);\n            }\n            if (timeout > 0) {\n                shardInfo.setConnectionTimeout(timeout);\n            }\n        }\n\n        if (isCluster) {\n            this.cluster = createCluster();\n        } else {\n            this.pool = createPool();\n        }\n    }\n\n    private Pool<Jedis> createPool() {\n        if (StringUtils.isNotBlank(sentinelMaster)) {\n            return createRedisSentinelPool();\n        }\n        return createRedisPool();\n    }\n\n    protected Pool<Jedis> createRedisSentinelPool() {\n        Set<String> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port).toString())\n                .collect(Collectors.toSet());\n        return new JedisSentinelPool(sentinelMaster, hostAndPorts, poolConfig, getShardInfo().getSoTimeout(), getShardInfo().getPassword());\n    }\n\n    protected Pool<Jedis> createRedisPool() {\n        return new JedisPool(getPoolConfig(), shardInfo.getHost(), shardInfo.getPort(), shardInfo.getSoTimeout(), shardInfo.getPassword());\n    }\n\n    protected JedisCluster createCluster() {\n        Set<HostAndPort> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port))\n                .collect(Collectors.toSet());\n        if (StringUtils.isNotEmpty(getPassword())) {\n            throw new IllegalArgumentException(\"Jedis does not support password protected Redis Cluster configurations!\");\n        }\n        int redirects = 5;\n        return new JedisCluster(hostAndPorts, timeout, redirects, poolConfig);\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            try {\n                pool.destroy();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis pool\", ex);\n            }\n            pool = null;\n        }\n        if (cluster != null) {\n            try {\n                cluster.close();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis cluster\", ex);\n            }\n            cluster = null;\n        }\n    }\n\n    public Jedis getJedisConnection() {\n        Jedis jedis = fetchJedisConnector();\n        if (dbIndex > 0 && jedis != null) {\n            jedis.select(dbIndex);\n        }\n        return jedis;\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.*;\nimport java.util.*;\n\npublic class RedisConnectionFactory {\n    private String hostName = \"localhost\";\n    private int port = 6379;\n    private int timeout = 2000;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers = new ArrayList<>();\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig = new JedisPoolConfig();\n\n    public void init() {\n        if (isCluster) {\n            cluster = createCluster();\n        } else {\n            pool = createPool();\n        }\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.destroy();\n        }\n        if (cluster != null) {\n            cluster.close();\n        }\n    }\n\n    private Jedis fetchJedisConnector() {\n        if (pool != null) {\n            return pool.getResource();\n        }\n        return new Jedis(shardInfo);\n    }\n\n    private Pool<Jedis> createPool() {\n        if (sentinelMaster != null && !redisServers.isEmpty()) {\n            return createRedisSentinelPool();\n        }\n        return createRedisPool();\n    }\n\n    private Pool<Jedis> createRedisSentinelPool() {\n        Set<String> sentinels = new HashSet<>();\n        for (RedisNode node : redisServers) {\n            sentinels.add(node.getHost() + \":\" + node.getPort());\n        }\n        return new JedisSentinelPool(sentinelMaster, sentinels, poolConfig, timeout, password, dbIndex);\n    }\n\n    private Pool<Jedis> createRedisPool() {\n        shardInfo = new JedisShardInfo(hostName, port, timeout);\n        if (password != null && !password.isEmpty()) {\n            shardInfo.setPassword(password);\n        }\n        return new JedisPool(poolConfig, hostName, port, timeout, password, dbIndex);\n    }\n\n    private JedisCluster createCluster() {\n        Set<HostAndPort> nodes = new HashSet<>();\n        for (RedisNode node : redisServers) {\n            nodes.add(new HostAndPort(node.getHost(), node.getPort()));\n        }\n        return new JedisCluster(nodes, timeout, timeout, 5, password, poolConfig, new GenericObjectPoolConfig<>());\n    }\n\n    public Jedis getJedisConnection() {\n        return fetchJedisConnector();\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n\n    public static class RedisNode {\n        private String host;\n        private int port;\n\n        public RedisNode(String host, int port) {\n            this.host = host;\n            this.port = port;\n        }\n\n        public String getHost() {\n            return host;\n        }\n\n        public int getPort() {\n            return port;\n        }\n    }\n}"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Create a Java class that implements Redis cluster operations using JedisCluster for caching management, including basic CRUD operations, hash operations, and batch operations.\n\nClass Description: JedisClusterCacheManager is a Redis cache manager implementation that uses JedisCluster to interact with a Redis cluster. It provides various Redis operations including setting/getting values, hash operations, batch operations, and deletion. The class handles serialization/deserialization of objects and manages Redis connections.\n\nAttributes:\n- redis: JedisClusterClient - The Redis client wrapper that implements IRedis interface\n- log: Logger - Logger instance for error logging\n- serializer: ISerializer<Object> - Serializer for converting objects to/from byte arrays (inherited from AbstractRedisCacheManager)\n\nMethods:\n- JedisClusterCacheManager(JedisCluster, ISerializer<Object>) -> void - Constructor that initializes the Redis client and serializer\n- getRedis() -> IRedis - Returns the Redis client instance\n- close() -> void - Closes the Redis connection (inherited from AbstractRedisCacheManager)\n- set(byte[], byte[]) -> void - Sets a key-value pair in Redis\n- setex(byte[], int, byte[]) -> void - Sets a key-value pair with expiration time\n- hset(byte[], byte[], byte[]) -> void - Sets a field in a Redis hash\n- hset(byte[], byte[], byte[], int) -> void - Sets a field in a Redis hash with expiration time for the key\n- mset(Collection<MSetParam>) -> void - Batch sets multiple key-value pairs\n- get(byte[]) -> byte[] - Gets a value by key\n- hget(byte[], byte[]) -> byte[] - Gets a field value from a Redis hash\n- mget(Type, Set<CacheKeyTO>) -> Map<CacheKeyTO, CacheWrapper<Object>> - Batch gets multiple values\n- delete(Set<CacheKeyTO>) -> void - Deletes multiple keys",
    "Canonical_solution": "import com.jarvis.cache.MSetParam;\nimport com.jarvis.cache.serializer.ISerializer;\nimport com.jarvis.cache.to.CacheKeyTO;\nimport com.jarvis.cache.to.CacheWrapper;\nimport redis.clients.jedis.JedisCluster;\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n\n    private static final Logger log = LoggerFactory.getLogger(JedisClusterCacheManager.class);\n    \n    private final JedisClusterClient redis;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        super(serializer);\n        this.redis = new JedisClusterClient(jedisCluster, this);\n    }\n\n    @Override\n    protected IRedis getRedis() {\n        return redis;\n    }\n\n    public static class JedisClusterClient implements IRedis {\n\n        private final JedisCluster jedisCluster;\n        private final AbstractRedisCacheManager cacheManager;\n\n        public JedisClusterClient(JedisCluster jedisCluster, AbstractRedisCacheManager cacheManager) {\n            this.jedisCluster = jedisCluster;\n            this.cacheManager = cacheManager;\n        }\n\n        @Override\n        public void close() throws IOException {\n        }\n\n        @Override\n        public void set(byte[] key, byte[] value) {\n            jedisCluster.set(key, value);\n        }\n\n        @Override\n        public void setex(byte[] key, int seconds, byte[] value) {\n            jedisCluster.setex(key, seconds, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value) {\n            jedisCluster.hset(key, field, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    pipeline.hset(key, field, value);\n                    pipeline.expire(key, seconds);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public void mset(Collection<MSetParam> params) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) throws Exception {\n                    JedisUtil.executeMSet(pipeline, cacheManager, params);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public byte[] get(byte[] key) {\n            return jedisCluster.get(key);\n        }\n\n        @Override\n        public byte[] hget(byte[] key, byte[] field) {\n            return jedisCluster.hget(key, field);\n        }\n\n        @Override\n        public Map<CacheKeyTO, CacheWrapper<Object>> mget(Type returnType, Set<CacheKeyTO> keys) throws Exception {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeMGet(pipeline, keys);\n                }\n            };\n            return cacheManager.deserialize(keys, retryableJedisClusterPipeline.syncAndReturnAll(), returnType);\n        }\n\n        @Override\n        public void delete(Set<CacheKeyTO> keys) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeDelete(pipeline, keys);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n    private JedisClusterClient redis;\n    private Logger log;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        super(serializer);\n        this.redis = new JedisClusterClient(jedisCluster);\n        this.log = Logger.getLogger(getClass().getName());\n    }\n\n    @Override\n    public IRedis getRedis() {\n        return redis;\n    }\n\n    @Override\n    public void close() {\n        try {\n            redis.close();\n        } catch (Exception e) {\n            log.severe(\"Error closing Redis connection: \" + e.getMessage());\n        }\n    }\n\n    public void set(byte[] key, byte[] value) {\n        try {\n            redis.set(key, value);\n        } catch (Exception e) {\n            log.warning(\"SET operation failed for key: \" + new String(key) + \", error: \" + e.getMessage());\n        }\n    }\n\n    public void setex(byte[] key, int seconds, byte[] value) {\n        try {\n            redis.setex(key, seconds, value);\n        } catch (Exception e) {\n            log.warning(\"SETEX operation failed for key: \" + new String(key) + \", error: \" + e.getMessage());\n        }\n    }\n\n    public void hset(byte[] key, byte[] field, byte[] value) {\n        try {\n            redis.hset(key, field, value);\n        } catch (Exception e) {\n            log.warning(\"HSET operation failed for key: \" + new String(key) + \", field: \" + new String(field) + \", error: \" + e.getMessage());\n        }\n    }\n\n    public void hset(byte[] key, byte[] field, byte[] value, int expireSeconds) {\n        try {\n            redis.hset(key, field, value, expireSeconds);\n        } catch (Exception e) {\n            log.warning(\"HSET with expiration failed for key: \" + new String(key) + \", field: \" + new String(field) + \", error: \" + e.getMessage());\n        }\n    }\n\n    public void mset(Collection<MSetParam> params) {\n        try {\n            redis.mset(params);\n        } catch (Exception e) {\n            log.warning(\"MSET operation failed, error: \" + e.getMessage());\n        }\n    }\n\n    public byte[] get(byte[] key) {\n        try {\n            return redis.get(key);\n        } catch (Exception e) {\n            log.warning(\"GET operation failed for key: \" + new String(key) + \", error: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    public byte[] hget(byte[] key, byte[] field) {\n        try {\n            return redis.hget(key, field);\n        } catch (Exception e) {\n            log.warning(\"HGET operation failed for key: \" + new String(key) + \", field: \" + new String(field) + \", error: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    public Map<CacheKeyTO, CacheWrapper<Object>> mget(Class<?> type, Set<CacheKeyTO> keys) {\n        try {\n            return redis.mget(type, keys);\n        } catch (Exception e) {\n            log.warning(\"MGET operation failed, error: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    public void delete(Set<CacheKeyTO> keys) {\n        try {\n            redis.delete(keys);\n        } catch (Exception e) {\n            log.warning(\"DELETE operation failed, error: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 366,
    "Instruction": "Task Description: Implement a RocketMQ consumer class in Java that can subscribe to a topic, consume messages asynchronously, and handle message consumption with configurable retry behavior.\n\nClass Description: The RocketMQConsumer class is responsible for consuming messages from a RocketMQ broker. It provides functionality to initialize the consumer, start message consumption with configurable retry behavior, and shutdown the consumer gracefully.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- consumerGroup: String - The consumer group name\n- topic: String - The topic to subscribe to\n- subscription: String - The subscription expression (tags filter)\n- returnFailedHalf: boolean - Flag to control whether to return failure status for half of the messages\n\nMethods:\n- initialize() throws MQClientException -> void - Initializes the consumer instance with the specified group name and subscription\n- start() throws MQClientException -> void - Starts the consumer with a message listener that handles incoming messages and implements the retry logic\n- shutdown() -> void - Shuts down the consumer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.subscribe(topic, subscription != null ? subscription : \"*\");\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            AtomicLong consumeTimes = new AtomicLong(0);\n\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                long currentTimes = this.consumeTimes.incrementAndGet();\n                System.out.printf(\"%-8d %s%n\", currentTimes, msgs);\n                if (returnFailedHalf) {\n                    if ((currentTimes % 2) == 0) {\n                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                    }\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class RocketMQConsumer {\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.subscribe(topic, subscription);\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                try {\n                    int halfSize = msgs.size() / 2;\n                    for (int i = 0; i < msgs.size(); i++) {\n                        MessageExt message = msgs.get(i);\n                        if (returnFailedHalf && i < halfSize) {\n                            System.out.println(\"Message ID: \" + message.getMsgId() + \" failed to consume.\");\n                            return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                        }\n                        System.out.println(\"Consuming message: \" + new String(message.getBody()));\n                    }\n                    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                }\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n\n        consumer.start();\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 370,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic, process them using an orderly message listener, and manage the consumer lifecycle.\n\nClass Description: The Consumer class encapsulates the functionality of a RocketMQ push consumer that subscribes to a topic, processes messages in order, and provides methods to start and stop the consumer.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- consumerGroup: String - The consumer group name for this consumer\n- topic: String - The topic to subscribe to\n- subExpression: String - The tag expression for message filtering\n\nMethods:\n- Consumer(String, String, String) -> None - Constructor that initializes the consumer group, topic, and subscription expression\n- initialize() -> None - Initializes the consumer instance with basic configuration and subscription\n- start() -> None - Registers the message listener and starts the consumer\n- shutdown() -> None - Gracefully shuts down the consumer",
    "Canonical_solution": "import java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class Consumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subExpression;\n\n    public Consumer(String consumerGroup, String topic, String subExpression) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subExpression = subExpression;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerOrderly() {\n            AtomicLong consumeTimes = new AtomicLong(0);\n\n            @Override\n            public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n                context.setAutoCommit(true);\n                System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n                this.consumeTimes.incrementAndGet();\n                if ((this.consumeTimes.get() % 2) == 0) {\n                    return ConsumeOrderlyStatus.SUCCESS;\n                } else if ((this.consumeTimes.get() % 5) == 0) {\n                    context.setSuspendCurrentQueueTimeMillis(3000);\n                    return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n                }\n                return ConsumeOrderlyStatus.SUCCESS;\n            }\n        });\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class Consumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subExpression;\n\n    public Consumer(String consumerGroup, String topic, String subExpression) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subExpression = subExpression;\n    }\n\n    public void initialize() {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        try {\n            consumer.subscribe(topic, subExpression);\n        } catch (MQClientException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n\n        try {\n            consumer.start();\n            System.out.println(\"Consumer started.\");\n        } catch (MQClientException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n        System.out.println(\"Consumer shut down.\");\n    }\n}"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic and handle them asynchronously.\n\nClass Description: The RocketMQConsumer class is a message consumer implementation that uses RocketMQ's push-based consumption model. It subscribes to a specified topic, configures consumption settings, and processes incoming messages through a registered message listener.\n\nAttributes:\n- log: Logger - SLF4J logger instance for logging consumer activities\n- defaultMQPushConsumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance\n- rpcHook: RPCHook - Optional RPC hook for custom communication handling\n- topicName: String - The topic name to subscribe to\n- consumerGroup: String - The consumer group name for this consumer\n\nMethods:\n- RocketMQConsumer(RPCHook, String, String) -> void - Constructor that initializes the consumer with RPC hook, topic name, and consumer group\n- startConsumer() -> void - Configures and starts the consumer instance, subscribes to the topic, and registers the message listener\n- shutdown() -> void - Gracefully shuts down the consumer instance\n- buildSendMessageRequestHeader(Message, String, int) -> SendMessageRequestHeader - Helper method to build message request headers for sending messages\n- (implements) consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Message listener implementation that processes consumed messages (inherited from MessageListenerConcurrently interface)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.proxy.common.ProxyContext;\nimport org.apache.rocketmq.proxy.common.ProxyException;\nimport org.apache.rocketmq.proxy.common.ProxyExceptionCode;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void startConsumer() throws Exception {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(this.consumerGroup, this.rpcHook);\n        this.defaultMQPushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        this.defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);\n        \n        try {\n            this.defaultMQPushConsumer.subscribe(this.topicName, \"*\");\n        } catch (MQClientException e) {\n            throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \n                \"subscribe to topic \" + this.topicName + \" failed. \" + e.getMessage());\n        }\n        \n        this.defaultMQPushConsumer.registerMessageListener(this);\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() throws Exception {\n        if (this.defaultMQPushConsumer != null) {\n            this.defaultMQPushConsumer.shutdown();\n        }\n    }\n\n    protected SendMessageRequestHeader buildSendMessageRequestHeader(Message message,\n        String producerGroup, int queueId) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(producerGroup);\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setDefaultTopic(TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC);\n        requestHeader.setDefaultTopicQueueNums(0);\n        requestHeader.setQueueId(queueId);\n        requestHeader.setSysFlag(0);\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n        requestHeader.setFlag(message.getFlag());\n        requestHeader.setProperties(MessageDecoder.messageProperties2String(message.getProperties()));\n        requestHeader.setReconsumeTimes(0);\n        requestHeader.setBatch(false);\n        return requestHeader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.header.SendMessageRequestHeader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n\n    private static final Logger log = LoggerFactory.getLogger(RocketMQConsumer.class);\n\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void startConsumer() throws MQClientException {\n        if (rpcHook != null) {\n            defaultMQPushConsumer = new DefaultMQPushConsumer(consumerGroup, rpcHook);\n        } else {\n            defaultMQPushConsumer = new DefaultMQPushConsumer(consumerGroup);\n        }\n\n        defaultMQPushConsumer.subscribe(topicName, \"*\");\n        defaultMQPushConsumer.registerMessageListener(this);\n        defaultMQPushConsumer.start();\n\n        log.info(\"RocketMQ consumer started for topic: {}\", topicName);\n    }\n\n    public void shutdown() {\n        if (defaultMQPushConsumer != null) {\n            defaultMQPushConsumer.shutdown();\n            log.info(\"RocketMQ consumer shutdown completed.\");\n        }\n    }\n\n    public SendMessageRequestHeader buildSendMessageRequestHeader(Message message, String brokerName, int queueId) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(this.consumerGroup);\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setDefaultTopic(brokerName);\n        requestHeader.setDefaultTopicQueueId(queueId);\n        requestHeader.setSysFlag(0);\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n\n        return requestHeader;\n    }\n\n    @Override\n    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n        try {\n            for (MessageExt msg : msgs) {\n                log.info(\"Consumed message: {}\", new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        } catch (Exception e) {\n            log.error(\"Error consuming messages\", e);\n            return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n        }\n    }\n}"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Implement a resource handler class that serves file content from a specified path, supporting both full file serving and range requests, using Java NIO's FileChannel for efficient file operations.\n\nClass Description: PathResource is a file resource handler that serves content from a file system path, supporting standard and ranged requests. It utilizes FileChannel for efficient reading and implements resource management through a PathResourceManager.\n\nAttributes:\n- file: Path - The file path to serve content from\n- manager: PathResourceManager - Manages resource access and transfer size thresholds\n\nMethods:\n- serve(Sender, HttpServerExchange, IoCallback) -> void - Serves the entire file content to the client\n- serveRange(Sender, HttpServerExchange, long, long, IoCallback) -> void - Serves a specific byte range of the file content\n- getContentLength() -> Long - Returns the size of the file in bytes or null if unavailable\n- serveImpl(Sender, HttpServerExchange, long, long, IoCallback, boolean) -> void - Internal implementation handling both full and ranged requests\n\nThe class uses nested BaseFileTask, ServerTask, and TransferTask classes to handle different serving strategies:\n- ServerTask: Reads file content in chunks using pooled buffers\n- TransferTask: Uses zero-copy transfer for efficient large file serving\n\nThe implementation demonstrates proper FileChannel usage including:\n1. Opening channels with StandardOpenOption.READ\n2. Position manipulation for range requests\n3. Proper resource cleanup with safeClose\n4. Buffer management with PooledByteBuffer\n5. Error handling for file operations",
    "Canonical_solution": "import io.undertow.io.IoCallback;\nimport io.undertow.io.Sender;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.connector.PooledByteBuffer;\nimport org.xnio.IoUtils;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class PathResource implements RangeAwareResource {\n\n    private final Path file;\n    private final PathResourceManager manager;\n\n    public PathResource(final Path file, final PathResourceManager manager, String path) {\n        this.file = file;\n        this.manager = manager;\n    }\n\n    @Override\n    public void serve(final Sender sender, final HttpServerExchange exchange, final IoCallback callback) {\n        serveImpl(sender, exchange, -1, -1, callback, false);\n    }\n\n    @Override\n    public void serveRange(final Sender sender, final HttpServerExchange exchange, final long start, final long end, final IoCallback callback) {\n        serveImpl(sender, exchange, start, end, callback, true);\n    }\n\n    private void serveImpl(final Sender sender, final HttpServerExchange exchange, final long start, final long end, final IoCallback callback, final boolean range) {\n        abstract class BaseFileTask implements Runnable {\n            protected volatile FileChannel fileChannel;\n\n            protected boolean openFile() {\n                try {\n                    fileChannel = FileChannel.open(file, StandardOpenOption.READ);\n                    if(range) {\n                        fileChannel.position(start);\n                    }\n                } catch (NoSuchFileException e) {\n                    exchange.setStatusCode(StatusCodes.NOT_FOUND);\n                    callback.onException(exchange, sender, e);\n                    return false;\n                } catch (IOException e) {\n                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);\n                    callback.onException(exchange, sender, e);\n                    return false;\n                }\n                return true;\n            }\n        }\n\n        class ServerTask extends BaseFileTask implements IoCallback {\n            private PooledByteBuffer pooled;\n            long remaining = end - start + 1;\n\n            @Override\n            public void run() {\n                if(range && remaining == 0) {\n                    if (pooled != null) {\n                        pooled.close();\n                        pooled = null;\n                    }\n                    IoUtils.safeClose(fileChannel);\n                    callback.onComplete(exchange, sender);\n                    return;\n                }\n                if (fileChannel == null) {\n                    if (!openFile()) {\n                        return;\n                    }\n                    pooled = exchange.getConnection().getByteBufferPool().allocate();\n                }\n                if (pooled != null) {\n                    ByteBuffer buffer = pooled.getBuffer();\n                    try {\n                        buffer.clear();\n                        int res = fileChannel.read(buffer);\n                        if (res == -1) {\n                            pooled.close();\n                            IoUtils.safeClose(fileChannel);\n                            callback.onComplete(exchange, sender);\n                            return;\n                        }\n                        buffer.flip();\n                        if(range) {\n                            if(buffer.remaining() > remaining) {\n                                buffer.limit((int) (buffer.position() + remaining));\n                            }\n                            remaining -= buffer.remaining();\n                        }\n                        sender.send(buffer, this);\n                    } catch (IOException e) {\n                        onException(exchange, sender, e);\n                    }\n                }\n            }\n\n            @Override\n            public void onComplete(final HttpServerExchange exchange, final Sender sender) {\n                if (exchange.isInIoThread()) {\n                    exchange.dispatch(this);\n                } else {\n                    run();\n                }\n            }\n\n            @Override\n            public void onException(final HttpServerExchange exchange, final Sender sender, final IOException exception) {\n                if (pooled != null) {\n                    pooled.close();\n                    pooled = null;\n                }\n                IoUtils.safeClose(fileChannel);\n                if (!exchange.isResponseStarted()) {\n                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);\n                }\n                callback.onException(exchange, sender, exception);\n            }\n        }\n\n        class TransferTask extends BaseFileTask {\n            @Override\n            public void run() {\n                if (!openFile()) {\n                    return;\n                }\n                sender.transferFrom(fileChannel, new IoCallback() {\n                    @Override\n                    public void onComplete(HttpServerExchange exchange, Sender sender) {\n                        try {\n                            IoUtils.safeClose(fileChannel);\n                        } finally {\n                            callback.onComplete(exchange, sender);\n                        }\n                    }\n\n                    @Override\n                    public void onException(HttpServerExchange exchange, Sender sender, IOException exception) {\n                        try {\n                            IoUtils.safeClose(fileChannel);\n                        } finally {\n                            callback.onException(exchange, sender, exception);\n                        }\n                    }\n                });\n            }\n        }\n\n        BaseFileTask task;\n        try {\n            task = manager.getTransferMinSize() > Files.size(file) || range ? new ServerTask() : new TransferTask();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        if (exchange.isInIoThread()) {\n            exchange.dispatch(task);\n        } else {\n            task.run();\n        }\n    }\n\n    @Override\n    public Long getContentLength() {\n        try {\n            if (Files.isSymbolicLink(file) && Files.notExists(file)) {\n                return null;\n            }\n            return Files.size(file);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class PathResource {\n    private final Path file;\n    private final PathResourceManager manager;\n\n    public PathResource(Path file, PathResourceManager manager) {\n        this.file = file;\n        this.manager = manager;\n    }\n\n    public void serve(Sender sender, HttpServerExchange exchange, IoCallback callback) {\n        try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {\n            long size = channel.size();\n            serveImpl(sender, exchange, 0, size, callback, false);\n        } catch (IOException e) {\n            callback.onException(exchange, e);\n        }\n    }\n\n    public void serveRange(Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback) {\n        try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {\n            long size = channel.size();\n            if (start < 0 || end >= size || start > end) {\n                throw new IOException(\"Invalid range\");\n            }\n            serveImpl(sender, exchange, start, end - start + 1, callback, true);\n        } catch (IOException e) {\n            callback.onException(exchange, e);\n        }\n    }\n\n    public Long getContentLength() {\n        try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {\n            return channel.size();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    private void serveImpl(Sender sender, HttpServerExchange exchange, long position, long count, IoCallback callback, boolean isRange) {\n        if (count <= manager.getBufferSize()) {\n            new BaseFileTask(sender, exchange, file, position, count, callback).run();\n        } else if (manager.isZeroCopyEnabled()) {\n            new TransferTask(sender, exchange, file, position, count, callback).run();\n        } else {\n            new ServerTask(sender, exchange, file, position, count, callback, manager.getBufferPool()).run();\n        }\n    }\n\n    private static class BaseFileTask {\n        private final Sender sender;\n        private final HttpServerExchange exchange;\n        private final Path file;\n        private final long position;\n        private final long count;\n        private final IoCallback callback;\n\n        public BaseFileTask(Sender sender, HttpServerExchange exchange, Path file, long position, long count, IoCallback callback) {\n            this.sender = sender;\n            this.exchange = exchange;\n            this.file = file;\n            this.position = position;\n            this.count = count;\n            this.callback = callback;\n        }\n\n        public void run() {\n            try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {\n                PooledByteBuffer buffer = PooledByteBuffer.allocate((int) Math.min(count, Integer.MAX_VALUE));\n                channel.position(position);\n                int read = channel.read(buffer.getBuffer());\n                if (read > 0) {\n                    buffer.getBuffer().flip();\n                    sender.send(buffer.getBuffer(), exchange, callback);\n                } else {\n                    callback.onComplete(exchange);\n                }\n            } catch (IOException e) {\n                callback.onException(exchange, e);\n            }\n        }\n    }\n\n    private static class ServerTask {\n        private final Sender sender;\n        private final HttpServerExchange exchange;\n        private final Path file;\n        private final long position;\n        private final long count;\n        private final IoCallback callback;\n        private final BufferPool bufferPool;\n\n        public ServerTask(Sender sender, HttpServerExchange exchange, Path file, long position, long count, IoCallback callback, BufferPool bufferPool) {\n            this.sender = sender;\n            this.exchange = exchange;\n            this.file = file;\n            this.position = position;\n            this.count = count;\n            this.callback = callback;\n            this.bufferPool = bufferPool;\n        }\n\n        public void run() {\n            try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {\n                long remaining = count;\n                long pos = position;\n                while (remaining > 0) {\n                    PooledByteBuffer buffer = bufferPool.allocate();\n                    int toRead = (int) Math.min(remaining, buffer.getBuffer().remaining());\n                    channel.position(pos);\n                    int read = channel.read(buffer.getBuffer());\n                    if (read == -1) break;\n                    buffer.getBuffer().flip();\n                    sender.send(buffer.getBuffer(), exchange, callback);\n                    remaining -= read;\n                    pos += read;\n                }\n                callback.onComplete(exchange);\n            } catch (IOException e) {\n                callback.onException(exchange, e);\n            }\n        }\n    }\n\n    private static class TransferTask {\n        private final Sender sender;\n        private final HttpServerExchange exchange;\n        private final Path file;\n        private final long position;\n        private final long count;\n        private final IoCallback callback;\n\n        public TransferTask(Sender sender, HttpServerExchange exchange, Path file, long position, long count, IoCallback callback) {\n            this.sender = sender;\n            this.exchange = exchange;\n            this.file = file;\n            this.position = position;\n            this.count = count;\n            this.callback = callback;\n        }\n\n        public void run() {\n            try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {\n                sender.transferFrom(channel, position, count, exchange, callback);\n            } catch (IOException e) {\n                callback.onException(exchange, e);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic with configurable group, tags, and keys.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It handles initialization, message sending, and shutdown operations. The class provides methods to start the producer, send messages synchronously, and gracefully shut down the producer.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- group: String - The producer group name\n- topic: String - The topic to which messages will be sent\n- tags: String - The tags for message categorization\n- keys: String - The keys for message identification\n\nMethods:\n- Producer(String group, String topic, String tags, String keys) -> void - Constructor that initializes the producer with given group, topic, tags, and keys\n- start() -> void - Starts the producer instance\n- sendMessage(String messageContent) -> SendResult - Synchronously sends a message with the given content and returns the send result\n- shutdown() -> void - Shuts down the producer instance\n- buildCommandline(String[] args) -> CommandLine - Static method that builds and parses command line arguments for producer configuration",
    "Canonical_solution": "import org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) throws MQClientException {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n        this.producer.setInstanceName(Long.toString(System.currentTimeMillis()));\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws Exception {\n        Message msg = new Message(\n            topic,\n            tags,\n            keys,\n            messageContent.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) {\n        final Options options = new Options();\n        Option opt = new Option(\"h\", \"help\", false, \"Print help\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"g\", \"producerGroup\", true, \"Producer Group Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"t\", \"topic\", true, \"Topic Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"a\", \"tags\", true, \"Tags Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"k\", \"keys\", true, \"Keys Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"c\", \"msgCount\", true, \"Message Count\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        DefaultParser parser = new DefaultParser();\n        HelpFormatter hf = new HelpFormatter();\n        hf.setWidth(110);\n        CommandLine commandLine = null;\n        try {\n            commandLine = parser.parse(options, args);\n            if (commandLine.hasOption('h')) {\n                hf.printHelp(\"producer\", options, true);\n                return null;\n            }\n        } catch (ParseException e) {\n            hf.printHelp(\"producer\", options, true);\n            return null;\n        }\n\n        return commandLine;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "import org.apache.commons.cli.*;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\n\npublic class Producer {\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws MQClientException {\n        Message msg = new Message(topic, tags.getBytes(), messageContent.getBytes());\n        if (keys != null && !keys.isEmpty()) {\n            msg.setKeys(keys);\n        }\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) throws ParseException {\n        Options options = new Options();\n        options.addOption(\"g\", \"group\", true, \"Producer group name\");\n        options.addOption(\"t\", \"topic\", true, \"Topic to send messages to\");\n        options.addOption(\"s\", \"tags\", true, \"Tags for message categorization\");\n        options.addOption(\"k\", \"keys\", true, \"Keys for message identification\");\n\n        CommandLineParser parser = new DefaultParser();\n        return parser.parse(options, args);\n    }\n}"
  },
  {
    "Task_id": 397,
    "Instruction": "Task Description: Create a Java class that implements an Icecast HTTP audio broadcaster using Apache MINA for TCP client communication. The class should handle connection management, session handling, and error states for streaming audio to an Icecast server.\n\nClass Description: The IcecastHTTPAudioBroadcaster class manages the connection and streaming of audio data to an Icecast server using HTTP over TCP. It handles connection states, authentication, and error recovery while maintaining a persistent session with the server.\n\nAttributes:\n- mLog: Logger - Logger instance for logging events and errors\n- RECONNECT_INTERVAL_MILLISECONDS: long - Time interval between connection attempts (30 seconds)\n- mSocketConnector: NioSocketConnector - MINA socket connector for TCP communication\n- mStreamingSession: IoSession - Current active streaming session\n- mConnecting: AtomicBoolean - Flag indicating if a connection attempt is in progress\n- mLastConnectionAttempt: long - Timestamp of last connection attempt\n\nMethods:\n- IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) -> void - Constructor that initializes the broadcaster with configuration\n- connect() -> boolean - Attempts to establish a connection to the Icecast server, returns true if successful\n- disconnect() -> void - Closes the current streaming session and cleans up resources\n- connected() -> boolean - Returns true if currently connected to the server\n- canConnect() -> boolean - Returns true if conditions allow for a connection attempt\n- getBroadcastConfiguration() -> IcecastHTTPConfiguration - Returns the current broadcast configuration\n- setBroadcastState(BroadcastState state) -> void - Updates the current broadcast state\n- getBroadcastState() -> BroadcastState - Returns the current broadcast state\n- getHTTPHeaders() -> Map<String,String> - Returns HTTP headers for the connection\n- getConfiguration() -> IcecastHTTPConfiguration - Returns the configuration object\n\nInner Class:\n- IcecastHTTPIOHandler extends IoHandlerAdapter - Handles MINA session events\n  Methods:\n  - sessionOpened(IoSession session) -> void - Sends HTTP PUT request when session opens\n  - sessionClosed(IoSession session) -> void - Handles session cleanup when closed\n  - exceptionCaught(IoSession session, Throwable throwable) -> void - Handles connection exceptions\n  - messageReceived(IoSession session, Object object) -> void - Processes server responses",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.BroadcastState;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastHTTPConfiguration;\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolDecoderException;\nimport org.apache.mina.http.HttpClientCodec;\nimport org.apache.mina.http.HttpRequestImpl;\nimport org.apache.mina.http.api.DefaultHttpResponse;\nimport org.apache.mina.http.api.HttpMethod;\nimport org.apache.mina.http.api.HttpVersion;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n\n    private static final Logger mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n\n    private NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession = null;\n    private AtomicBoolean mConnecting = new AtomicBoolean();\n    private long mLastConnectionAttempt = 0;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        // Constructor logic\n    }\n\n    private boolean connect() {\n        if(!connected() && canConnect() &&\n            (mLastConnectionAttempt + RECONNECT_INTERVAL_MILLISECONDS < System.currentTimeMillis()) &&\n            mConnecting.compareAndSet(false, true))\n        {\n            mLastConnectionAttempt = System.currentTimeMillis();\n\n            if(mSocketConnector == null) {\n                mSocketConnector = new NioSocketConnector();\n                mSocketConnector.setConnectTimeoutCheckInterval(10000);\n                mSocketConnector.getFilterChain().addLast(\"codec\", new HttpClientCodec());\n                mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n            }\n\n            mStreamingSession = null;\n\n            try {\n                ConnectFuture future = mSocketConnector.connect(\n                    new InetSocketAddress(getBroadcastConfiguration().getHost(),\n                    getBroadcastConfiguration().getPort()));\n                future.awaitUninterruptibly();\n                mStreamingSession = future.getSession();\n            } catch(RuntimeIoException rie) {\n                Throwable throwableCause = rie.getCause();\n                if(throwableCause instanceof ConnectException) {\n                    setBroadcastState(BroadcastState.NO_SERVER);\n                } else {\n                    setBroadcastState(BroadcastState.DISCONNECTED);\n                    mLog.debug(\"Failed to connect\", rie);\n                }\n                disconnect();\n            }\n            mConnecting.set(false);\n        }\n        return connected();\n    }\n\n    public void disconnect() {\n        if(mStreamingSession != null) {\n            mStreamingSession.closeNow();\n        }\n    }\n\n    public class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            HttpRequestImpl request = new HttpRequestImpl(HttpVersion.HTTP_1_1, HttpMethod.PUT,\n                getConfiguration().getMountPoint(), \"\", getHTTPHeaders());\n            session.write(request);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            if(!getBroadcastState().isErrorState()) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            mSocketConnector.dispose();\n            mStreamingSession = null;\n            mSocketConnector = null;\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            if(throwable instanceof ProtocolDecoderException) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            } else {\n                mLog.error(\"Broadcast error\", throwable);\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            disconnect();\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            if(object instanceof DefaultHttpResponse) {\n                DefaultHttpResponse response = (DefaultHttpResponse) object;\n                switch(response.getStatus()) {\n                    case SUCCESS_OK:\n                        setBroadcastState(BroadcastState.CONNECTED);\n                        mConnecting.set(false);\n                        break;\n                    case CLIENT_ERROR_UNAUTHORIZED:\n                        setBroadcastState(BroadcastState.INVALID_CREDENTIALS);\n                        break;\n                    case CLIENT_ERROR_FORBIDDEN:\n                        setBroadcastState(BroadcastState.CONFIGURATION_ERROR);\n                        break;\n                    default:\n                        if(!getBroadcastState().isErrorState()) {\n                            setBroadcastState(BroadcastState.ERROR);\n                        }\n                        break;\n                }\n                disconnect();\n            }\n        }\n    }\n\n    // Helper methods (stubs for compilation)\n    private boolean connected() { return false; }\n    private boolean canConnect() { return false; }\n    private IcecastHTTPConfiguration getBroadcastConfiguration() { return null; }\n    private void setBroadcastState(BroadcastState state) {}\n    private BroadcastState getBroadcastState() { return null; }\n    private Map<String,String> getHTTPHeaders() { return null; }\n    private IcecastHTTPConfiguration getConfiguration() { return null; }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 10,
    "wrong_result": "import java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class IcecastHTTPAudioBroadcaster {\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n    private final Logger mLog = LoggerFactory.getLogger(getClass());\n    private final NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession;\n    private final AtomicBoolean mConnecting = new AtomicBoolean(false);\n    private long mLastConnectionAttempt;\n    private final IcecastHTTPConfiguration mConfiguration;\n    private BroadcastState mBroadcastState = BroadcastState.DISCONNECTED;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        mConfiguration = configuration;\n        mSocketConnector = new NioSocketConnector();\n        mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n    }\n\n    public boolean connect() {\n        if (!canConnect()) {\n            return false;\n        }\n\n        mConnecting.set(true);\n        mLastConnectionAttempt = System.currentTimeMillis();\n\n        try {\n            ConnectFuture future = mSocketConnector.connect(new InetSocketAddress(mConfiguration.getHost(), mConfiguration.getPort()));\n            future.awaitUninterruptibly();\n            if (future.isConnected()) {\n                mStreamingSession = future.getSession();\n                mConnecting.set(false);\n                setBroadcastState(BroadcastState.CONNECTED);\n                return true;\n            }\n        } catch (Exception e) {\n            mLog.error(\"Connection failed\", e);\n        }\n\n        mConnecting.set(false);\n        return false;\n    }\n\n    public void disconnect() {\n        if (mStreamingSession != null && mStreamingSession.isConnected()) {\n            mStreamingSession.closeNow();\n        }\n        mStreamingSession = null;\n        setBroadcastState(BroadcastState.DISCONNECTED);\n    }\n\n    public boolean connected() {\n        return mStreamingSession != null && mStreamingSession.isConnected();\n    }\n\n    public boolean canConnect() {\n        return !connected() &&\n               !mConnecting.get() &&\n               (System.currentTimeMillis() - mLastConnectionAttempt > RECONNECT_INTERVAL_MILLISECONDS);\n    }\n\n    public IcecastHTTPConfiguration getBroadcastConfiguration() {\n        return mConfiguration;\n    }\n\n    public void setBroadcastState(BroadcastState state) {\n        mBroadcastState = state;\n    }\n\n    public BroadcastState getBroadcastState() {\n        return mBroadcastState;\n    }\n\n    public Map<String, String> getHTTPHeaders() {\n        return mConfiguration.getHTTPHeaders();\n    }\n\n    public IcecastHTTPConfiguration getConfiguration() {\n        return mConfiguration;\n    }\n\n    private class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            StringBuilder request = new StringBuilder();\n            request.append(\"PUT \").append(mConfiguration.getResourcePath()).append(\" HTTP/1.1\\r\\n\");\n            for (Map.Entry<String, String> header : getHTTPHeaders().entrySet()) {\n                request.append(header.getKey()).append(\": \").append(header.getValue()).append(\"\\r\\n\");\n            }\n            request.append(\"\\r\\n\");\n\n            session.write(request.toString());\n            mLog.info(\"Sent HTTP PUT request to initiate streaming\");\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            mLog.info(\"Session closed\");\n            disconnect();\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            mLog.error(\"Exception caught during session\", throwable);\n            disconnect();\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            String response = object.toString();\n            mLog.debug(\"Server response: {}\", response);\n\n            if (response.startsWith(\"HTTP/1.1 200 OK\")) {\n                mLog.info(\"Successfully connected to Icecast server\");\n            } else if (response.startsWith(\"HTTP/1.1 401 Unauthorized\")) {\n                mLog.error(\"Authentication failed\");\n                disconnect();\n            }\n        }\n    }\n\n    public enum BroadcastState {\n        CONNECTED,\n        DISCONNECTED,\n        ERROR\n    }\n}"
  },
  {
    "Task_id": 403,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function has no return value but may print error information to stderr if the operation fails)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TCPSender {\n    public static void sendStringToServer(String str) {\n        String serverAddress = \"localhost\"; // Default server address\n        int port = 8080; // Default port number\n\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream out = socket.getOutputStream()) {\n            out.write(str.getBytes());\n            out.flush();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"IO error: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            sendStringToServer(args[0]);\n        } else {\n            System.out.println(\"Please provide a string to send.\");\n        }\n    }\n}"
  },
  {
    "Task_id": 405,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for pushing metrics to a Graphite server, with support for periodic pushing and character sanitization for Graphite compatibility.\n\nClass Description: The Graphite class provides functionality to connect to a Graphite server via TCP and push metrics from a CollectorRegistry. It handles character sanitization for Graphite compatibility and supports both one-time pushes and periodic pushing via a daemon thread.\n\nAttributes:\n- host: String - The hostname or IP address of the Graphite server\n- port: int - The port number of the Graphite server\n- logger: Logger - Logger instance for error logging\n- INVALID_GRAPHITE_CHARS: Pattern - Regular expression pattern for invalid Graphite characters\n\nMethods:\n- Graphite(String host, int port) -> None - Constructor that initializes the Graphite client with server connection details\n- push(CollectorRegistry registry) -> void - Pushes all metrics from the registry to Graphite server immediately. Throws IOException if connection fails\n- start(CollectorRegistry registry) -> Thread - Starts a daemon thread that pushes metrics every 60 seconds\n- start(CollectorRegistry registry, int intervalSeconds) -> Thread - Starts a daemon thread that pushes metrics at specified intervals\n- PushThread(CollectorRegistry registry, int intervalSeconds) -> None - Inner class constructor for the periodic push thread\n- run() -> void - The main execution method of PushThread that handles periodic metric pushing",
    "Canonical_solution": "import io.prometheus.client.Collector;\nimport io.prometheus.client.CollectorRegistry;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Graphite {\n  private static final Logger logger = Logger.getLogger(Graphite.class.getName());\n  private final String host;\n  private final int port;\n  private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_-]\");\n\n  public Graphite(String host, int port) {\n    this.host = host;\n    this.port = port;\n  }\n\n  public void push(CollectorRegistry registry) throws IOException {\n    Socket s = new Socket(host, port);\n    BufferedWriter writer = new BufferedWriter(new PrintWriter(new OutputStreamWriter(s.getOutputStream(), Charset.forName(\"UTF-8\")));\n    Matcher m = INVALID_GRAPHITE_CHARS.matcher(\"\");\n    long now = System.currentTimeMillis() / 1000;\n    for (Collector.MetricFamilySamples metricFamilySamples: Collections.list(registry.metricFamilySamples())) {\n      for (Collector.MetricFamilySamples.Sample sample: metricFamilySamples.samples) {\n        m.reset(sample.name);\n        writer.write(m.replaceAll(\"_\"));\n        for (int i = 0; i < sample.labelNames.size(); ++i) {\n          m.reset(sample.labelValues.get(i));\n          writer.write(\";\" + sample.labelNames.get(i) + \"=\" + m.replaceAll(\"_\"));\n        }\n        writer.write(\" \" + sample.value + \" \" + now + \"\\n\");\n      }\n    }\n    writer.close();\n    s.close();\n  }\n\n  public Thread start(CollectorRegistry registry) {\n    return start(registry, 60);\n  }\n\n  public Thread start(CollectorRegistry registry, int intervalSeconds) {\n    Thread thread = new PushThread(registry, intervalSeconds);\n    thread.setDaemon(true);\n    thread.start();\n    return thread;\n  }\n\n  private class PushThread extends Thread {\n    private final CollectorRegistry registry;\n    private final int intervalSeconds;\n\n    PushThread(CollectorRegistry registry, int intervalSeconds) {\n      this.registry = registry;\n      this.intervalSeconds = intervalSeconds;\n    }\n\n    public void run() {\n      long waitUntil = System.currentTimeMillis();\n      while (true) {\n        try {\n          push(registry);\n        } catch (IOException e) {\n          logger.log(Level.WARNING, \"Exception \" + e + \" pushing to \" + host + \":\" + port, e);\n        }\n\n        long now = System.currentTimeMillis();\n        while (now >= waitUntil) {\n          waitUntil += intervalSeconds * 1000;\n        }\n        try {\n          Thread.sleep(waitUntil - now);\n        } catch (InterruptedException e) {\n          return;\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.regex.*;\nimport java.util.logging.*;\nimport io.prometheus.client.CollectorRegistry;\nimport io.prometheus.client.MetricFamilySamples;\n\npublic class Graphite {\n    private final String host;\n    private final int port;\n    private static final Logger logger = Logger.getLogger(Graphite.class.getName());\n    private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_-]\");\n\n    public Graphite(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void push(CollectorRegistry registry) throws IOException {\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(host, port), 5000);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            long timestamp = System.currentTimeMillis() / 1000;\n\n            for (MetricFamilySamples family : registry.metricFamilySamples()) {\n                for (MetricFamilySamples.Sample sample : family.samples) {\n                    String name = sanitizeName(sample.name);\n                    String value = String.valueOf(sample.value);\n                    out.println(name + \" \" + value + \" \" + timestamp);\n                }\n            }\n            out.flush();\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to push metrics to Graphite\", e);\n            throw e;\n        }\n    }\n\n    public Thread start(CollectorRegistry registry) {\n        return start(registry, 60);\n    }\n\n    public Thread start(CollectorRegistry registry, int intervalSeconds) {\n        Thread thread = new Thread(new PushThread(registry, intervalSeconds));\n        thread.setDaemon(true);\n        thread.start();\n        return thread;\n    }\n\n    private class PushThread implements Runnable {\n        private final CollectorRegistry registry;\n        private final int intervalSeconds;\n\n        public PushThread(CollectorRegistry registry, int intervalSeconds) {\n            this.registry = registry;\n            this.intervalSeconds = intervalSeconds;\n        }\n\n        @Override\n        public void run() {\n            ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n            scheduler.scheduleAtFixedRate(() -> {\n                try {\n                    push(registry);\n                } catch (IOException e) {\n                    logger.log(Level.WARNING, \"Error pushing metrics to Graphite\", e);\n                }\n            }, 0, intervalSeconds, TimeUnit.SECONDS);\n        }\n    }\n\n    private String sanitizeName(String name) {\n        return INVALID_GRAPHITE_CHARS.matcher(name).replaceAll(\"_\");\n    }\n}"
  },
  {
    "Task_id": 406,
    "Instruction": "Task Description: Write a Java function that tests a server's handling of a malformed HTTP request by sending a bad request and verifying the server's response.\n\nFunction Description: The function `testBadRequest` attempts to send a deliberately malformed HTTP POST request to a server and verifies that the server responds with a \"400 Bad Request\" error. The function creates a TCP socket connection to the server, sends the malformed request, reads the server's response, and compares it to the expected response. If the response matches, the test passes; otherwise, it may throw an IOException if the connection is closed prematurely.\n\nInput: None (The server address and port are obtained from `DefaultServer.getDefaultServerAddress()` internally)\n\nOutput: None (The function asserts the server's response matches the expected \"400 Bad Request\" response. Any mismatch or IOException will result in a test failure or exception.)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.Socket;\n\npublic void testBadRequest() throws IOException {\n    String request = \"POST /\\r HTTP/1.1\\r\\nTrailer:foo, bar\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n9\\r\\nabcdefghi\\r\\n0\\r\\nfoo: fooVal\\r\\n bar: barVal\\r\\n\\r\\n\";\n    String response1 = \"HTTP/1.1 400 Bad Request\\r\\nContent-Length: 0\\r\\nConnection: close\\r\\n\\r\\n\";\n    Socket s = new Socket(DefaultServer.getDefaultServerAddress().getAddress(), DefaultServer.getDefaultServerAddress().getPort());\n    try {\n        s.getOutputStream().write(request.getBytes());\n\n        StringBuilder sb = new StringBuilder();\n        int read = 0;\n        byte[] buf = new byte[100];\n        while (read < response1.length()) {\n            int r = s.getInputStream().read(buf);\n            if (r <= 0) break;\n            if (r > 0) {\n                read += r;\n                sb.append(new String(buf, 0, r));\n            }\n        }\n        Assert.assertEquals(response1, sb.toString());\n\n    } catch (IOException expected) {\n        //this can happen as well, as in some cases we may not have fully consumed the read side\n        //before the connection is shutdown, namely when we are running in test.single\n    } finally {\n        s.close();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class MalformedHttpRequestTest {\n\n    public static void testBadRequest() throws IOException {\n        String serverAddress = DefaultServer.getDefaultServerAddress();\n        int port = 80;\n        String malformedRequest = \"POST / HTTP/1.1\\r\\n\" +\n                                  \"Host: example.com\\r\\n\" +\n                                  \"Content-Length: 5\\r\\n\" +\n                                  \"Connection: close\\r\\n\" +\n                                  \"\\r\\n\" +\n                                  \"bad-data\";\n\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(serverAddress, port), 5000);\n            OutputStream out = socket.getOutputStream();\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            out.write(malformedRequest.getBytes());\n            out.flush();\n\n            String responseLine = in.readLine();\n            if (responseLine == null || !responseLine.contains(\"400 Bad Request\")) {\n                throw new IOException(\"Expected '400 Bad Request' response, but got: \" + responseLine);\n            }\n        }\n    }\n}\n\nclass DefaultServer {\n    public static String getDefaultServerAddress() {\n        return \"127.0.0.1\";\n    }\n}"
  },
  {
    "Task_id": 409,
    "Instruction": "Task Description: Create a Java function that sends a raw RDP (Remote Desktop Protocol) connection request to a specified host and port using TCP socket communication. The function should handle the socket connection, data transmission, and proper resource cleanup.\n\nFunction Description: The function establishes a TCP connection to a specified remote host and port, sends a pre-defined hexadecimal RDP protocol payload, and then closes the connection. The function includes error handling for connection issues and implements a socket timeout to prevent hanging.\n\nInput:\n- rhost: String - The remote host IP address or hostname to connect to\n- rport: int - The remote port number for the RDP service\n\nOutput: None (void function), though errors will be printed to standard error if they occur\n\nNote: The function uses a static hexadecimal string (exp) containing the RDP protocol payload, which is converted to bytes before transmission. The socket timeout is set to 3 milliseconds to prevent prolonged connection attempts.",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic static String exp = \"030000130ee000000000000100080000000000030001d602f0807f658201940401010401010101ff30190204000000000204000000020204000000000204000000010204000000000204000000010202ffff020400000002301902040000000102040000000102040000000102040000000102040000000002040000000102020420020400000002301c0202ffff0202fc170202ffff0204000000010204000000000204000000010202ffff02040000000204820133000500147c0001812a000800100001c00044756361811c01c0d800040008008002e00101ca03aa09040000ce0e000048004f005300540000000000000000000000000000000000000000000000000004000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ca010000000000100007000100300030003000300030002d003000300030002d0030003000300030003000300030002d003000300030003000300000000000000000000000000000000000000000000000000004c00c000d0000000000000002c00c001b0000000000000003c02c0003000000726470647200000000008080636c6970726472000000a0c0726470736e640000000000c00300000c02f08004010001000300000802f080280300000c02f08038000603ef0300000c02f08038000603eb0300000c02f08038000603ec0300000c02f08038000603ed0300000c02f08038000603ee0300000b06d00000123400\";\n\npublic void sendRDPRequest(String rhost, int rport) {\n    try {\n        byte[] bytes = HexUtils.hex2Bytes(exp);\n        Socket socket = new Socket(rhost, rport);\n        socket.setSoTimeout(3);\n        OutputStream out = socket.getOutputStream();\n        out.write(bytes);\n        out.flush();\n        out.close();\n        socket.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketTimeoutException;\n\npublic class RDPClient {\n\n    public static void sendRDPRequest(String rhost, int rport) {\n        String exp = \"030000130EAA00000000000100080002A000\"; // Example RDP payload in hex\n        byte[] payload = hexStringToByteArray(exp);\n\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(rhost, rport), 3000);\n            OutputStream out = socket.getOutputStream();\n            out.write(payload);\n            out.flush();\n        } catch (SocketTimeoutException e) {\n            System.err.println(\"Connection timed out: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"IO Exception: \" + e.getMessage());\n        }\n    }\n\n    private static byte[] hexStringToByteArray(String s) {\n        int len = s.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n                                 + Character.digit(s.charAt(i+1), 16));\n        }\n        return data;\n    }\n}"
  },
  {
    "Task_id": 415,
    "Instruction": "Task Description: Create a TCP client class in Java that can send commands to a server and receive responses, with methods for starting, stopping, checking status, and flushing methods on the server.\n\nClass Description: TProfilerClient is a utility class that provides functionality to communicate with a profiling server via TCP. It handles socket creation, command sending, response reading, and connection cleanup.\n\nMethods:\n\nMethod1: start(String server, int port) -> void - Sends a START command to the specified server and port\nMethod2: stop(String server, int port) -> void - Sends a STOP command to the specified server and port\nMethod3: status(String server, int port) -> String - Sends a STATUS command and returns the server's response\nMethod4: flushMethod(String server, int port) -> void - Sends a FLUSHMETHOD command to the specified server and port\nMethod5: doSend(String command, String server, int port) -> void - Private helper method to send a command to the server\nMethod6: getStatus(String command, String server, int port) -> String - Private helper method to send a command and read the server's response\nMethod7: read(InputStream in) -> String - Private helper method to read data from an input stream until a carriage return is encountered",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TProfilerClient {\n\n    public static void start(String server, int port) {\n        doSend(Manager.START, server, port);\n    }\n\n    public static void stop(String server, int port) {\n        doSend(Manager.STOP, server, port);\n    }\n\n    public static String status(String server, int port) {\n        return getStatus(Manager.STATUS, server, port);\n    }\n\n    public static void flushMethod(String server, int port) {\n        doSend(Manager.FLUSHMETHOD, server, port);\n    }\n\n    private static void doSend(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static String getStatus(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n            return read(socket.getInputStream());\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return null;\n    }\n\n    private static String read(InputStream in) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(in);\n        StringBuffer sb = new StringBuffer();\n        int i;\n        while ((i = bin.read()) != -1) {\n            char c = (char) i;\n            if (c == '\\r') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TProfilerClient {\n\n    public void start(String server, int port) {\n        doSend(\"START\", server, port);\n    }\n\n    public void stop(String server, int port) {\n        doSend(\"STOP\", server, port);\n    }\n\n    public String status(String server, int port) {\n        return getStatus(\"STATUS\", server, port);\n    }\n\n    public void flushMethod(String server, int port) {\n        doSend(\"FLUSHMETHOD\", server, port);\n    }\n\n    private void doSend(String command, String server, int port) {\n        try (Socket socket = new Socket(server, port);\n             OutputStream out = socket.getOutputStream()) {\n            out.write((command + \"\\r\\n\").getBytes());\n            out.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String getStatus(String command, String server, int port) {\n        String response = \"\";\n        try (Socket socket = new Socket(server, port);\n             OutputStream out = socket.getOutputStream();\n             InputStream in = socket.getInputStream()) {\n            out.write((command + \"\\r\\n\").getBytes());\n            out.flush();\n            response = read(in);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return response;\n    }\n\n    private String read(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while ((ch = in.read()) != -1 && ch != '\\r') {\n            sb.append((char) ch);\n        }\n        return sb.toString();\n    }\n}"
  },
  {
    "Task_id": 417,
    "Instruction": "Task Description: Create a Java class that establishes a TCP client connection to interact with a minitouch service on an Android device through ADB forwarding, allowing for touch event simulation and connection management.\n\nClass Description: The Minitouch class provides functionality to connect to a minitouch service running on an Android device via ADB port forwarding. It handles socket communication for sending touch events and manages connection lifecycle events through listeners.\n\nAttributes:\n- REMOTE_PATH: [String] - The remote path on the Android device where minitouch binary is located\n- MINITOUCH_BIN: [String] - The name of the minitouch binary\n- listenerList: [List<MinitouchListener>] - List of listeners for connection events\n- device: [AdbDevice] - The Android device to connect to\n- minitouchSocket: [Socket] - The socket connection to minitouch service\n- minitouchOutputStream: [OutputStream] - Output stream for sending touch events\n- forward: [AdbForward] - ADB forward information for the connection\n\nMethods:\n- Minitouch([AdbDevice device]) -> [void] - Constructor that initializes the class with the target device\n- addEventListener([MinitouchListener listener]) -> [void] - Adds a listener for connection events\n- start() -> [void] - Starts the minitouch connection by setting up ADB forwarding and socket connection\n- kill() -> [void] - Terminates the connection and cleans up resources\n- sendEvent([String str]) -> [void] - Sends a touch event string to the minitouch service\n- createForward() -> [AdbForward] - Creates an ADB forward for the minitouch connection\n- removeForward([AdbForward forward]) -> [void] - Removes the specified ADB forward\n- startInitialThread([String host, int port]) -> [void] - Internal method to establish socket connection in a background thread\n- onStartup([boolean success]) -> [void] - Notifies listeners about connection status\n- onClose() -> [void] - Notifies listeners about connection closure and cleans up\n- generateForwardInfo() -> [AdbForward] - Generates ADB forward information for the connection",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport com.yeetor.adb.AdbDevice;\nimport com.yeetor.adb.AdbForward;\nimport com.yeetor.adb.AdbServer;\nimport com.yeetor.minicap.MinicapInstallException;\nimport com.yeetor.util.Constant;\nimport com.yeetor.util.Util;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<MinitouchListener>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        if (listener != null) {\n            this.listenerList.add(listener);\n        }\n    }\n\n    public void start() {\n        AdbForward forward = createForward();\n        String command = \"/data/local/tmp/minitouch\" + \" -n \" + forward.getLocalabstract();\n        startInitialThread(\"127.0.0.1\", forward.getPort());\n    }\n\n    public void kill() {\n        onClose();\n        if (minitouchSocket != null && minitouchSocket.isConnected()) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n            }\n            minitouchSocket = null;\n        }\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream == null) {\n            return;\n        }\n        try {\n            minitouchOutputStream.write(str.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        forward = generateForwardInfo();\n        try {\n            device.getIDevice().createForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return forward;\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward == null || !forward.isForward()) {\n            return;\n        }\n        try {\n            device.getIDevice().removeForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n        }\n    }\n\n    private void startInitialThread(final String host, final int port) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int tryTime = 200;\n                while (true) {\n                    Socket socket = null;\n                    byte[] bytes = new byte[256];\n                    try {\n                        socket = new Socket(host, port);\n                        InputStream inputStream = socket.getInputStream();\n                        OutputStream outputStream = socket.getOutputStream();\n                        int n = inputStream.read(bytes);\n\n                        if (n == -1) {\n                            Thread.sleep(10);\n                            socket.close();\n                        } else {\n                            minitouchSocket = socket;\n                            minitouchOutputStream = outputStream;\n                            onStartup(true);\n                            break;\n                        }\n                    } catch (Exception ex) {\n                        if (socket != null) {\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        continue;\n                    }\n                    tryTime--;\n                    if (tryTime == 0) {\n                        onStartup(false);\n                        break;\n                    }\n                }\n            }\n        });\n        thread.start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(this, success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose(this);\n        }\n        removeForward(forward);\n    }\n\n    private AdbForward generateForwardInfo() {\n        AdbForward[] forwards = AdbServer.server().getForwardList();\n        int maxNumber = 0;\n        if (forwards.length > 0) {\n            for (AdbForward forward : forwards) {\n                if (forward.getSerialNumber().equals(device.getIDevice().getSerialNumber())) {\n                    String l = forward.getLocalabstract();\n                    String[] s = l.split(\"_\");\n                    if (s.length == 3) {\n                        int n = Integer.parseInt(s[2]);\n                        if (n > maxNumber) maxNumber = n;\n                    }\n                }\n            }\n        }\n        maxNumber += 1;\n\n        String forwardStr = String.format(\"%s_touch_%d\", device.getIDevice().getSerialNumber(), maxNumber);\n        int freePort = Util.getFreePort();\n        return new AdbForward(device.getIDevice().getSerialNumber(), freePort, forwardStr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n    private static final String REMOTE_PATH = \"/data/local/tmp/minitouch\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private final List<MinitouchListener> listenerList = new ArrayList<>();\n    private final AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        listenerList.add(listener);\n    }\n\n    public void start() {\n        try {\n            forward = createForward();\n            startInitialThread(\"127.0.0.1\", forward.getLocalPort());\n        } catch (Exception e) {\n            onStartup(false);\n        }\n    }\n\n    public void kill() {\n        try {\n            onClose();\n        } finally {\n            if (forward != null) {\n                removeForward(forward);\n                forward = null;\n            }\n        }\n    }\n\n    public void sendEvent(String str) {\n        try {\n            if (minitouchOutputStream != null) {\n                minitouchOutputStream.write(str.getBytes());\n                minitouchOutputStream.flush();\n            }\n        } catch (IOException e) {\n            kill();\n        }\n    }\n\n    private AdbForward createForward() throws IOException {\n        return generateForwardInfo();\n    }\n\n    private void removeForward(AdbForward forward) {\n        // Implementation to remove ADB forward\n    }\n\n    private void startInitialThread(String host, int port) {\n        new Thread(() -> {\n            try {\n                minitouchSocket = new Socket();\n                minitouchSocket.connect(new InetSocketAddress(host, port), 5000);\n                minitouchOutputStream = minitouchSocket.getOutputStream();\n                onStartup(true);\n            } catch (IOException e) {\n                onStartup(false);\n            }\n        }).start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onConnectionStatus(success);\n        }\n    }\n\n    private void onClose() {\n        try {\n            if (minitouchOutputStream != null) {\n                minitouchOutputStream.close();\n                minitouchOutputStream = null;\n            }\n            if (minitouchSocket != null && !minitouchSocket.isClosed()) {\n                minitouchSocket.close();\n                minitouchSocket = null;\n            }\n        } catch (IOException e) {\n            // Ignore\n        }\n\n        for (MinitouchListener listener : listenerList) {\n            listener.onConnectionClosed();\n        }\n    }\n\n    private AdbForward generateForwardInfo() {\n        // Generate and return AdbForward object with local and remote ports\n        return new AdbForward(12345, 1111); // Example ports\n    }\n}\n\ninterface MinitouchListener {\n    void onConnectionStatus(boolean success);\n    void onConnectionClosed();\n}\n\nclass AdbDevice {\n    // Placeholder for actual AdbDevice implementation\n}\n\nclass AdbForward {\n    private final int localPort;\n    private final int remotePort;\n\n    public AdbForward(int localPort, int remotePort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n\n    public int getRemotePort() {\n        return remotePort;\n    }\n}"
  },
  {
    "Task_id": 422,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function doesn't return any value, but sends data to the server and may print error information to stderr)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TCPSender {\n    public static void sendStringToServer(String str) {\n        String serverAddress = \"localhost\"; // Default server address\n        int port = 8080; // Default port number\n\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream out = socket.getOutputStream()) {\n\n            byte[] messageBytes = str.getBytes(\"UTF-8\");\n            out.write(messageBytes);\n            out.flush();\n\n        } catch (UnknownHostException e) {\n            System.err.println(\"Error: Unknown host - \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"IO Error: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 423,
    "Instruction": "Task Description: Create a Java function that establishes a TCP client connection to a server, sends HTTP upgrade requests and echo messages, and verifies server responses.\n\nFunction Description: The function connects to a predefined server using TCP, sends an HTTP upgrade request followed by echo messages, and asserts the correctness of server responses. It handles basic client-server communication including connection establishment, data exchange, and connection termination.\n\nInput: \n- url: String - The URL path to be used in the HTTP GET request\n\nOutput: \n- None (void) - The function performs assertions to verify server responses but doesn't return any value. It throws IOException if any network communication fails.\n\nNote: The function uses predefined host address and port from DefaultServer class, and includes a helper method readBytes() (not shown) to read data from the input stream.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic void runTest(final String url) throws IOException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET \" + url + \" HTTP/1.1\\r\\nHost:default\\r\\nConnection: upgrade\\r\\nUpgrade: servlet\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    Assert.assertTrue(readBytes(in).startsWith(\"HTTP/1.1 101 Switching Protocols\\r\\n\"));\n\n    out.write(\"Echo Messages\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"Echo Messages2\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages2\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"exit\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    out.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport static org.junit.Assert.*;\n\npublic class TcpClient {\n    public void connectAndTest(String url) throws IOException {\n        String host = DefaultServer.getHost();\n        int port = DefaultServer.getPort();\n\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(host, port), 5000);\n            OutputStream out = socket.getOutputStream();\n            InputStream in = socket.getInputStream();\n\n            String upgradeRequest = \"GET \" + url + \" HTTP/1.1\\r\\n\" +\n                                    \"Host: \" + host + \"\\r\\n\" +\n                                    \"Upgrade: websocket\\r\\n\" +\n                                    \"Connection: Upgrade\\r\\n\" +\n                                    \"\\r\\n\";\n            out.write(upgradeRequest.getBytes());\n            out.flush();\n\n            byte[] response = readBytes(in, 1024);\n            String responseStr = new String(response);\n            assertTrue(responseStr.contains(\"HTTP/1.1 101\"));\n\n            String echoMsg = \"Hello, Server!\";\n            out.write(echoMsg.getBytes());\n            out.flush();\n\n            response = readBytes(in, echoMsg.length());\n            assertEquals(echoMsg, new String(response));\n\n        } catch (IOException e) {\n            throw new IOException(\"Communication failed\", e);\n        }\n    }\n\n    private byte[] readBytes(InputStream in, int length) throws IOException {\n        byte[] data = new byte[length];\n        int totalRead = 0;\n        while (totalRead < length) {\n            int read = in.read(data, totalRead, length - totalRead);\n            if (read == -1) break;\n            totalRead += read;\n        }\n        return data;\n    }\n}"
  },
  {
    "Task_id": 425,
    "Instruction": "Task Description: Create a function that establishes a TCP connection to a server, sends JSON-formatted measurement data, and then closes the connection.\n\nFunction Description: The function `doSocketTest` establishes a TCP socket connection to a specified server (localhost) on a predefined port. It generates JSON-formatted measurement data using a helper class, writes this data to the server through the socket's output stream, flushes the stream to ensure all data is sent, and then closes both the output stream and the socket to release resources.\n\nInput: \n- None (The function uses predefined constants `SERVER_SOCKET_PORT` and `HARDWARE_ID` for server port and hardware identification, respectively.)\n\nOutput: \n- None (The function does not return any value but sends data to the server and may throw exceptions if the connection or data transmission fails.)",
    "Canonical_solution": "import java.net.Socket;\n\npublic void doSocketTest() throws Exception {\n    Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n    byte[] encoded = EventsHelper.generateJsonMeasurementsMessage(HARDWARE_ID);\n    socket.getOutputStream().write(encoded);\n    socket.getOutputStream().flush();\n    socket.getOutputStream().close();\n    socket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport com.google.gson.Gson;\n\npublic class SocketTest {\n    private static final String SERVER_IP = \"localhost\";\n    private static final int SERVER_SOCKET_PORT = 5000;\n    private static final String HARDWARE_ID = \"HARDWARE_001\";\n\n    public static void doSocketTest() throws IOException {\n        Gson gson = new Gson();\n        MeasurementData data = new MeasurementData(HARDWARE_ID, System.currentTimeMillis(), 25.5);\n\n        try (Socket socket = new Socket(SERVER_IP, SERVER_SOCKET_PORT);\n             OutputStream out = socket.getOutputStream()) {\n\n            String json = gson.toJson(data);\n            out.write(json.getBytes());\n            out.flush();\n        }\n    }\n\n    static class MeasurementData {\n        String hardwareId;\n        long timestamp;\n        double value;\n\n        MeasurementData(String hardwareId, long timestamp, double value) {\n            this.hardwareId = hardwareId;\n            this.timestamp = timestamp;\n            this.value = value;\n        }\n    }\n}"
  },
  {
    "Task_id": 427,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The class should handle connection establishment, data transmission, and connection termination while managing network buffers and packet processing.\n\nClass Description: TCPConnection is a non-blocking TCP client implementation that extends an abstract connection class and implements a packet source interface. It manages socket communication, handles I/O operations asynchronously, and processes network packets with proper flow control.\n\nAttributes:\n- MTU: [int] - Maximum Transmission Unit size (16384 bytes)\n- MAX_PAYLOAD_SIZE: [int] - Maximum payload size after accounting for protocol headers\n- clientToNetwork: [StreamBuffer] - Buffer for data being sent from client to network\n- networkToClient: [Packetizer] - Handles packetization of incoming data\n- packetForClient: [IPv4Packet] - Current packet being processed for the client\n- channel: [SocketChannel] - NIO channel for TCP communication\n- selectionKey: [SelectionKey] - Registration key with the selector\n- interests: [int] - Current interest set for the selection key\n\nMethods:\n- TCPConnection([ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader]) -> [void] - Constructor that initializes the connection with necessary headers and registers the channel with the selector\n- disconnect() -> [void] - Closes the connection and releases resources\n- processReceive() -> [void] - Handles incoming data from the network when readable\n- processSend() -> [void] - Handles outgoing data to the network when writable\n- createChannel() -> [SocketChannel] - Creates and configures the socket channel\n- sendToNetwork([IPv4Packet packet]) -> [void] - Sends a packet to the network\n- updateInterests() -> [void] - Updates the selector's interest ops based on current state\n- mayRead() -> [boolean] - Determines if the channel should be registered for read operations\n- mayWrite() -> [boolean] - Determines if the channel should be registered for write operations\n- mayConnect() -> [boolean] - Determines if the channel is in connecting state",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n\n    private static final int MTU = 0x4000;\n    private static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20;\n\n    private final StreamBuffer clientToNetwork = new StreamBuffer(4 * IPv4Packet.MAX_PACKET_LENGTH);\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client);\n\n        TCPHeader shrinkedTcpHeader = tcpHeader.copy();\n        shrinkedTcpHeader.shrinkOptions();\n\n        networkToClient = new Packetizer(ipv4Header, shrinkedTcpHeader);\n        networkToClient.getResponseIPv4Header().swapSourceAndDestination();\n        networkToClient.getResponseTransportHeader().swapSourceAndDestination();\n\n        SelectionHandler selectionHandler = (selectionKey) -> {\n            if (selectionKey.isValid() && selectionKey.isConnectable()) {\n                processConnect();\n            }\n            if (selectionKey.isValid() && selectionKey.isReadable()) {\n                processReceive();\n            }\n            if (selectionKey.isValid() && selectionKey.isWritable()) {\n                processSend();\n            }\n            updateInterests();\n        };\n        channel = createChannel();\n        interests = SelectionKey.OP_CONNECT;\n        selectionKey = channel.register(selector, interests, selectionHandler);\n    }\n\n    @Override\n    public void disconnect() {\n        selectionKey.cancel();\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private void processReceive() {\n        try {\n            assert packetForClient == null;\n            int remainingClientWindow = getRemainingClientWindow();\n            assert remainingClientWindow > 0;\n            int maxPayloadSize = Math.min(remainingClientWindow, MAX_PAYLOAD_SIZE);\n            updateHeaders(TCPHeader.FLAG_ACK | TCPHeader.FLAG_PSH);\n            packetForClient = networkToClient.packetize(channel, maxPayloadSize);\n            if (packetForClient == null) {\n                eof();\n                return;\n            }\n            consume(this);\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private void processSend() {\n        try {\n            int w = clientToNetwork.writeTo(channel);\n            if (w > 0) {\n                acknowledgementNumber += w;\n\n                if (finReceived && clientToNetwork.isEmpty()) {\n                    doHandleFin();\n                } else {\n                    sendEmptyPacketToClient(TCPHeader.FLAG_ACK);\n                }\n            } else {\n                close();\n            }\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(getRewrittenDestination());\n        return socketChannel;\n    }\n\n    @Override\n    public void sendToNetwork(IPv4Packet packet) {\n        handlePacket(packet);\n        updateInterests();\n    }\n\n    protected void updateInterests() {\n        if (!selectionKey.isValid()) {\n            return;\n        }\n        int interestOps = 0;\n        if (mayRead()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interestOps |= SelectionKey.OP_CONNECT;\n        }\n        if (interests != interestOps) {\n            interests = interestOps;\n            selectionKey.interestOps(interestOps);\n        }\n    }\n\n    private boolean mayRead() {\n        if (!state.isConnected() || state.isClosed()) {\n            return false;\n        }\n        if (packetForClient != null) {\n            return false;\n        }\n        return getRemainingClientWindow() > 0;\n    }\n\n    private boolean mayWrite() {\n        return !clientToNetwork.isEmpty();\n    }\n\n    private boolean mayConnect() {\n        return state == State.SYN_SENT;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Queue;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n    private static final int MTU = 16384;\n    private static final int MAX_PAYLOAD_SIZE = MTU - IPv4Header.IPV4_HEADER_LENGTH - TCPHeader.TCP_HEADER_LENGTH;\n    \n    private final StreamBuffer clientToNetwork;\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n    private SocketChannel channel;\n    private SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client, ipv4Header, tcpHeader);\n        this.clientToNetwork = new StreamBuffer();\n        this.networkToClient = new Packetizer();\n        this.packetForClient = null;\n        this.channel = createChannel();\n        this.selectionKey = channel.register(selector, 0);\n        this.interests = 0;\n    }\n\n    public void disconnect() {\n        try {\n            if (channel != null && channel.isOpen()) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            // Handle exception\n        }\n    }\n\n    public void processReceive() {\n        ByteBuffer buffer = ByteBuffer.allocate(MTU);\n        try {\n            int bytesRead = channel.read(buffer);\n            if (bytesRead > 0) {\n                buffer.flip();\n                networkToClient.processBytes(buffer);\n                \n                while (networkToClient.hasPacket()) {\n                    IPv4Packet receivedPacket = networkToClient.getNextPacket();\n                    getClient().handleIncomingPacket(receivedPacket);\n                }\n            } else if (bytesRead == -1) {\n                disconnect();\n            }\n        } catch (IOException e) {\n            disconnect();\n        }\n        \n        updateInterests();\n    }\n\n    public void processSend() {\n        if (!clientToNetwork.isEmpty()) {\n            IPv4Packet outgoingPacket = clientToNetwork.getNextPacket(MAX_PAYLOAD_SIZE);\n            if (outgoingPacket != null) {\n                sendToNetwork(outgoingPacket);\n            }\n        }\n        \n        updateInterests();\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        \n        InetSocketAddress address = new InetSocketAddress(getTcpHeader().getDestinationIP(), getTcpHeader().getDestinationPort());\n        boolean connected = socketChannel.connect(address);\n        \n        if (connected) {\n            handleConnected();\n        } else {\n            setConnecting(true);\n        }\n        \n        return socketChannel;\n    }\n\n    public void sendToNetwork(IPv4Packet packet) {\n        ByteBuffer buffer = packet.getByteBuffer();\n        try {\n            while (buffer.hasRemaining()) {\n                channel.write(buffer);\n            }\n        } catch (IOException e) {\n            disconnect();\n        }\n    }\n\n    public void updateInterests() {\n        int newInterests = 0;\n        \n        if (mayRead()) {\n            newInterests |= SelectionKey.OP_READ;\n        }\n        \n        if (mayWrite()) {\n            newInterests |= SelectionKey.OP_WRITE;\n        }\n        \n        if (mayConnect()) {\n            newInterests |= SelectionKey.OP_CONNECT;\n        }\n        \n        if (newInterests != interests) {\n            selectionKey.interestOps(newInterests);\n            interests = newInterests;\n        }\n    }\n\n    public boolean mayRead() {\n        return !isClosed() && !isClosing() && !isConnecting();\n    }\n\n    public boolean mayWrite() {\n        return !isClosed() && !isClosing() && !clientToNetwork.isEmpty();\n    }\n\n    public boolean mayConnect() {\n        return isConnecting();\n    }\n\n    // Additional helper methods and state management should be implemented as needed\n}"
  },
  {
    "Task_id": 429,
    "Instruction": "Task Description: Implement a Java class that handles reading data from a SocketChannel using Java NIO (Non-blocking I/O) for high-availability (HA) communication in a distributed messaging system.\n\nClass Description: ReadSocketService is a service thread that continuously reads data from a SocketChannel using a Selector and ByteBuffer. It processes incoming HA protocol messages (handshake and transfer states) and manages connection state. The class integrates with a high-availability service to maintain synchronization between master and slave nodes.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Constant defining the maximum buffer size for reading (1MB)\n- selector: [Selector] - NIO Selector for monitoring the SocketChannel\n- socketChannel: [SocketChannel] - The channel for communication with the remote peer\n- byteBufferRead: [ByteBuffer] - Buffer for storing read data\n- haReader: [AbstractHAReader] - Reader implementation for processing HA protocol messages\n- processPosition: [int] - Current processing position within the read buffer\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n\nMethods:\n- ReadSocketService([SocketChannel socketChannel]) -> [void] - Constructor that initializes the selector, configures the socket channel, and sets up the HA reader\n- run() -> [void] - Main service loop that performs selector operations, reads data, and handles connection state\n- getServiceName() -> [String] - Returns the service name with broker identifier if in container mode\n- HAServerReader.processReadResult([ByteBuffer byteBufferRead]) -> [boolean] - Processes the read buffer according to HA protocol (handshake and transfer states), returns true if processing succeeds\n\nThe class should handle connection timeouts, buffer management (including compaction), and proper resource cleanup when stopping. It should integrate with a parent HA connection service for state management and notification.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.ha.io.AbstractHAReader;\nimport org.apache.rocketmq.store.ha.io.HAWriter;\n\nclass ReadSocketService extends ServiceThread {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final AbstractHAReader haReader;\n    private int processPosition = 0;\n    private volatile long lastReadTimestamp = System.currentTimeMillis();\n\n    public ReadSocketService(final SocketChannel socketChannel) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.socketChannel = socketChannel;\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.setDaemon(true);\n        haReader = new HAServerReader();\n        haReader.registerHook(readSize -> {\n            if (readSize > 0) {\n                ReadSocketService.this.lastReadTimestamp =\n                    haService.getDefaultMessageStore().getSystemClock().now();\n            }\n        });\n    }\n\n    @Override\n    public void run() {\n        LOGGER.info(this.getServiceName() + \" service started\");\n\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                boolean ok = this.haReader.read(this.socketChannel, this.byteBufferRead);\n                if (!ok) {\n                    AutoSwitchHAConnection.LOGGER.error(\"processReadEvent error\");\n                    break;\n                }\n\n                long interval = haService.getDefaultMessageStore().getSystemClock().now() - this.lastReadTimestamp;\n                if (interval > haService.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {\n                    LOGGER.warn(\"ha housekeeping, found this connection[\" + clientAddress + \"] expired, \" + interval);\n                    break;\n                }\n            } catch (Exception e) {\n                AutoSwitchHAConnection.LOGGER.error(this.getServiceName() + \" service has exception.\", e);\n                break;\n            }\n        }\n\n        this.makeStop();\n\n        changeCurrentState(HAConnectionState.SHUTDOWN);\n\n        writeSocketService.makeStop();\n\n        haService.removeConnection(AutoSwitchHAConnection.this);\n\n        haService.getConnectionCount().decrementAndGet();\n\n        SelectionKey sk = this.socketChannel.keyFor(this.selector);\n        if (sk != null) {\n            sk.cancel();\n        }\n\n        try {\n            this.selector.close();\n            this.socketChannel.close();\n        } catch (IOException e) {\n            AutoSwitchHAConnection.LOGGER.error(\"\", e);\n        }\n\n        flowMonitor.shutdown(true);\n\n        AutoSwitchHAConnection.LOGGER.info(this.getServiceName() + \" service end\");\n    }\n\n    @Override\n    public String getServiceName() {\n        if (haService.getDefaultMessageStore().getBrokerConfig().isInBrokerContainer()) {\n            return haService.getDefaultMessageStore().getBrokerIdentity().getIdentifier() + ReadSocketService.class.getSimpleName();\n        }\n        return ReadSocketService.class.getSimpleName();\n    }\n\n    class HAServerReader extends AbstractHAReader {\n        @Override\n        protected boolean processReadResult(ByteBuffer byteBufferRead) {\n            while (true) {\n                boolean processSuccess = true;\n                int readSocketPos = byteBufferRead.position();\n                int diff = byteBufferRead.position() - ReadSocketService.this.processPosition;\n                if (diff >= AutoSwitchHAClient.MIN_HEADER_SIZE) {\n                    int readPosition = ReadSocketService.this.processPosition;\n                    HAConnectionState slaveState = HAConnectionState.values()[byteBufferRead.getInt(readPosition)];\n\n                    switch (slaveState) {\n                        case HANDSHAKE:\n                            Long slaveBrokerId = byteBufferRead.getLong(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 8);\n                            AutoSwitchHAConnection.this.slaveId = slaveBrokerId;\n                            short syncFromLastFileFlag = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 12);\n                            if (syncFromLastFileFlag == 1) {\n                                AutoSwitchHAConnection.this.isSyncFromLastFile = true;\n                            }\n                            short isAsyncLearner = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 10);\n                            if (isAsyncLearner == 1) {\n                                AutoSwitchHAConnection.this.isAsyncLearner = true;\n                            }\n\n                            isSlaveSendHandshake = true;\n                            byteBufferRead.position(readSocketPos);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE;\n                            LOGGER.info(\"Receive slave handshake, slaveBrokerId:{}, isSyncFromLastFile:{}, isAsyncLearner:{}\",\n                                AutoSwitchHAConnection.this.slaveId, AutoSwitchHAConnection.this.isSyncFromLastFile, AutoSwitchHAConnection.this.isAsyncLearner);\n                            break;\n                        case TRANSFER:\n                            long slaveMaxOffset = byteBufferRead.getLong(readPosition + 4);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.TRANSFER_HEADER_SIZE;\n\n                            AutoSwitchHAConnection.this.slaveAckOffset = slaveMaxOffset;\n                            if (slaveRequestOffset < 0) {\n                                slaveRequestOffset = slaveMaxOffset;\n                            }\n                            byteBufferRead.position(readSocketPos);\n                            maybeExpandInSyncStateSet(slaveMaxOffset);\n                            AutoSwitchHAConnection.this.haService.updateConfirmOffsetWhenSlaveAck(AutoSwitchHAConnection.this.slaveId);\n                            AutoSwitchHAConnection.this.haService.notifyTransferSome(AutoSwitchHAConnection.this.slaveAckOffset);\n                            break;\n                        default:\n                            LOGGER.error(\"Current state illegal {}\", currentState);\n                            return false;\n                    }\n\n                    if (!slaveState.equals(currentState)) {\n                        LOGGER.warn(\"Master change state from {} to {}\", currentState, slaveState);\n                        changeCurrentState(slaveState);\n                    }\n                    if (processSuccess) {\n                        continue;\n                    }\n                }\n\n                if (!byteBufferRead.hasRemaining()) {\n                    byteBufferRead.position(ReadSocketService.this.processPosition);\n                    byteBufferRead.compact();\n                    ReadSocketService.this.processPosition = 0;\n                }\n                break;\n            }\n\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class ReadSocketService extends ServiceThread {\n    public static final int READ_MAX_BUFFER_SIZE = 1024 * 1024; // 1MB\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final AbstractHAReader haReader;\n    private int processPosition = 0;\n    private long lastReadTimestamp = System.currentTimeMillis();\n\n    public ReadSocketService(SocketChannel socketChannel) throws IOException {\n        this.socketChannel = socketChannel;\n        this.selector = Selector.open();\n        this.socketChannel.configureBlocking(false);\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.haReader = new HAServerReader();\n    }\n\n    @Override\n    public void run() {\n        while (!isStopped()) {\n            try {\n                int readyChannels = selector.select(1000);\n                if (readyChannels == 0) {\n                    continue;\n                }\n\n                Set<SelectionKey> selectedKeys = selector.selectedKeys();\n                Iterator<SelectionKey> keyIterator = selectedKeys.iterator();\n\n                while (keyIterator.hasNext()) {\n                    SelectionKey key = keyIterator.next();\n\n                    if (key.isReadable()) {\n                        SocketChannel clientChannel = (SocketChannel) key.channel();\n                        int bytesRead = clientChannel.read(byteBufferRead);\n\n                        if (bytesRead > 0) {\n                            lastReadTimestamp = System.currentTimeMillis();\n                            processPosition = 0;\n\n                            boolean processed = haReader.processReadResult(byteBufferRead);\n                            if (!processed) {\n                                handleProtocolError();\n                            }\n                        } else if (bytesRead == -1) {\n                            handleRemoteClose();\n                            return;\n                        }\n                    }\n\n                    keyIterator.remove();\n                }\n\n                checkConnectionTimeout();\n                compactBufferIfNecessary();\n            } catch (IOException e) {\n                handleNetworkError(e);\n            }\n        }\n    }\n\n    private void checkConnectionTimeout() {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastReadTimestamp > HAConfig.CONNECTION_TIMEOUT_MS) {\n            handleTimeout();\n        }\n    }\n\n    private void compactBufferIfNecessary() {\n        if (processPosition > 0) {\n            int remaining = byteBufferRead.position() - processPosition;\n            if (remaining > 0) {\n                byteBufferRead.position(processPosition).limit(byteBufferRead.position());\n                byteBufferRead.compact();\n            } else {\n                byteBufferRead.clear();\n            }\n            processPosition = 0;\n        }\n    }\n\n    private void handleTimeout() {\n        shutdownGracefully();\n        notifyHAServiceOnTimeout();\n    }\n\n    private void handleRemoteClose() {\n        shutdownGracefully();\n        notifyHAServiceOnDisconnect();\n    }\n\n    private void handleProtocolError() {\n        shutdownGracefully();\n        notifyHAServiceOnProtocolError();\n    }\n\n    private void handleNetworkError(IOException e) {\n        shutdownGracefully();\n        notifyHAServiceOnError(e);\n    }\n\n    private void shutdownGracefully() {\n        try {\n            if (socketChannel != null && socketChannel.isOpen()) {\n                socketChannel.close();\n            }\n        } catch (IOException ignored) {\n        }\n\n        try {\n            if (selector != null && selector.isOpen()) {\n                selector.close();\n            }\n        } catch (IOException ignored) {\n        }\n    }\n\n    protected void notifyHAServiceOnTimeout() {\n        HAService.getInstance().onConnectionTimeout(socketChannel.getRemoteAddress());\n    }\n\n    protected void notifyHAServiceOnDisconnect() {\n        HAService.getInstance().onRemoteDisconnect(socketChannel.getRemoteAddress());\n    }\n\n    protected void notifyHAServiceOnProtocolError() {\n        HAService.getInstance().onProtocolError(socketChannel.getRemoteAddress());\n    }\n\n    protected void notifyHAServiceOnError(IOException e) {\n        HAService.getInstance().onConnectionError(socketChannel.getRemoteAddress(), e);\n    }\n\n    public String getServiceName() {\n        if (System.getProperty(\"containerMode\") != null && Boolean.parseBoolean(System.getProperty(\"containerMode\"))) {\n            return \"HAReadSocketService_\" + BrokerContainer.getCurrentBrokerId();\n        }\n        return \"HAReadSocketService\";\n    }\n\n    private static class HAServerReader implements HAReader {\n        public boolean processReadResult(ByteBuffer byteBufferRead) {\n            try {\n                byteBufferRead.flip();\n                while (byteBufferRead.hasRemaining()) {\n                    byte messageType = byteBufferRead.get();\n                    switch (messageType) {\n                        case HA_PROTOCOL_MESSAGE_TYPE.HANDSHAKE:\n                            processHandshakeMessage(byteBufferRead);\n                            break;\n                        case HA_PROTOCOL_MESSAGE_TYPE.TRANSFER_DATA:\n                            processTransferDataMessage(byteBufferRead);\n                            break;\n                        default:\n                            return false;\n                    }\n                }\n                return true;\n            } finally {\n                byteBufferRead.compact();\n            }\n        }\n\n        private void processHandshakeMessage(ByteBuffer buffer) {\n            byte[] handshakeData = new byte[buffer.remaining()];\n            buffer.get(handshakeData);\n            HAService.getInstance().handleHandshake(handshakeData);\n        }\n\n        private void processTransferDataMessage(ByteBuffer buffer) {\n            int dataSize = buffer.getInt();\n            byte[] data = new byte[dataSize];\n            buffer.get(data);\n            HAService.getInstance().handleTransferData(data);\n        }\n    }\n\n    interface HAReader {\n        boolean processReadResult(ByteBuffer byteBufferRead);\n    }\n\n    interface HAServiceInterface {\n        void handleHandshake(byte[] handshakeData);\n        void handleTransferData(byte[] data);\n        void onConnectionTimeout(InetSocketAddress remoteAddress);\n        void onRemoteDisconnect(InetSocketAddress remoteAddress);\n        void onProtocolError(InetSocketAddress remoteAddress);\n        void onConnectionError(InetSocketAddress remoteAddress, IOException e);\n        static HAServiceInterface getInstance() {\n            return HAServiceImpl.INSTANCE;\n        }\n    }\n\n    enum HA_PROTOCOL_MESSAGE_TYPE {\n        HANDSHAKE,\n        TRANSFER_DATA\n    }\n\n    static class HAServiceImpl implements HAServiceInterface {\n        static final HAServiceImpl INSTANCE = new HAServiceImpl();\n\n        public void handleHandshake(byte[] handshakeData) {}\n\n        public void handleTransferData(byte[] data) {}\n\n        public void onConnectionTimeout(InetSocketAddress remoteAddress) {}\n\n        public void onRemoteDisconnect(InetSocketAddress remoteAddress) {}\n\n        public void onProtocolError(InetSocketAddress remoteAddress) {}\n\n        public void onConnectionError(InetSocketAddress remoteAddress, IOException e) {}\n    }\n\n    static class HAConfig {\n        static final int CONNECTION_TIMEOUT_MS = 30000;\n    }\n\n    static class BrokerContainer {\n        public static String getCurrentBrokerId() {\n            return \"BROKER_001\";\n        }\n    }\n}"
  },
  {
    "Task_id": 431,
    "Instruction": "Task Description: Implement a Java class for a High Availability (HA) client that manages communication with a master server using non-blocking I/O (NIO) techniques. The client should handle connection management, data reporting, and read event processing.\n\nClass Description: DefaultHAClient is a service thread that maintains a connection to a master server for high availability purposes. It uses Java NIO's SocketChannel and Selector for non-blocking communication, manages buffer operations for data transfer, and handles connection lifecycle events.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Maximum buffer size for reading data (4MB)\n- masterHaAddress: [AtomicReference<String>] - Atomic reference to the master server's address\n- reportOffset: [ByteBuffer] - Buffer for reporting slave offset to master (8 bytes)\n- socketChannel: [SocketChannel] - Channel for communication with master\n- selector: [Selector] - Selector for non-blocking I/O operations\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n- lastWriteTimestamp: [long] - Timestamp of last successful write operation\n- currentReportedOffset: [long] - Current offset reported to master\n- dispatchPosition: [int] - Position in read buffer for dispatching data\n- byteBufferRead: [ByteBuffer] - Primary buffer for reading data\n- byteBufferBackup: [ByteBuffer] - Backup buffer for buffer reallocation\n- defaultMessageStore: [DefaultMessageStore] - Reference to the message store for offset information\n\nMethods:\n- DefaultHAClient([DefaultMessageStore defaultMessageStore]) -> [void] - Constructor that initializes selector and message store reference\n- updateHaMasterAddress([String newAddr]) -> [void] - Updates the master server address atomically\n- reportSlaveMaxOffset([long maxOffset]) -> [boolean] - Reports the slave's maximum offset to master, returns success status\n- reallocateByteBuffer() -> [void] - Reallocates and swaps read buffers when needed\n- swapByteBuffer() -> [void] - Swaps primary and backup byte buffers\n- processReadEvent() -> [boolean] - Processes read events from socket channel, returns success status\n- connectMaster() -> [boolean] - Connects to master server, returns connection status\n- closeMaster() -> [void] - Closes connection with master and cleans up resources\n- shutdown() -> [void] - Shuts down the client by closing all resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.store.DefaultMessageStore;\n\npublic class DefaultHAClient extends ServiceThread implements HAClient {\n\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024 * 4;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp = System.currentTimeMillis();\n    private long lastWriteTimestamp = System.currentTimeMillis();\n    private long currentReportedOffset = 0;\n    private int dispatchPosition = 0;\n    private ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(DefaultMessageStore defaultMessageStore) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.defaultMessageStore = defaultMessageStore;\n    }\n\n    public void updateHaMasterAddress(final String newAddr) {\n        String currentAddr = this.masterHaAddress.get();\n        if (masterHaAddress.compareAndSet(currentAddr, newAddr)) {\n            log.info(\"update master ha address, OLD: \" + currentAddr + \" NEW: \" + newAddr);\n        }\n    }\n\n    private boolean reportSlaveMaxOffset(final long maxOffset) {\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n        this.reportOffset.putLong(maxOffset);\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n\n        for (int i = 0; i < 3 && this.reportOffset.hasRemaining(); i++) {\n            try {\n                this.socketChannel.write(this.reportOffset);\n            } catch (IOException e) {\n                log.error(this.getServiceName()\n                    + \"reportSlaveMaxOffset this.socketChannel.write exception\", e);\n                return false;\n            }\n        }\n        lastWriteTimestamp = this.defaultMessageStore.getSystemClock().now();\n        return !this.reportOffset.hasRemaining();\n    }\n\n    private void reallocateByteBuffer() {\n        int remain = READ_MAX_BUFFER_SIZE - this.dispatchPosition;\n        if (remain > 0) {\n            this.byteBufferRead.position(this.dispatchPosition);\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferBackup.put(this.byteBufferRead);\n        }\n\n        this.swapByteBuffer();\n        this.byteBufferRead.position(remain);\n        this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        this.dispatchPosition = 0;\n    }\n\n    private void swapByteBuffer() {\n        ByteBuffer tmp = this.byteBufferRead;\n        this.byteBufferRead = this.byteBufferBackup;\n        this.byteBufferBackup = tmp;\n    }\n\n    private boolean processReadEvent() {\n        int readSizeZeroTimes = 0;\n        while (this.byteBufferRead.hasRemaining()) {\n            try {\n                int readSize = this.socketChannel.read(this.byteBufferRead);\n                if (readSize > 0) {\n                    readSizeZeroTimes = 0;\n                    boolean result = this.dispatchReadRequest();\n                    if (!result) {\n                        log.error(\"HAClient, dispatchReadRequest error\");\n                        return false;\n                    }\n                    lastReadTimestamp = System.currentTimeMillis();\n                } else if (readSize == 0) {\n                    if (++readSizeZeroTimes >= 3) {\n                        break;\n                    }\n                } else {\n                    log.info(\"HAClient, processReadEvent read socket < 0\");\n                    return false;\n                }\n            } catch (IOException e) {\n                log.info(\"HAClient, processReadEvent read socket exception\", e);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean connectMaster() throws ClosedChannelException {\n        if (null == socketChannel) {\n            String addr = this.masterHaAddress.get();\n            if (addr != null) {\n                SocketAddress socketAddress = NetworkUtil.string2SocketAddress(addr);\n                this.socketChannel = RemotingHelper.connect(socketAddress);\n                if (this.socketChannel != null) {\n                    this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n                    log.info(\"HAClient connect to master {}\", addr);\n                }\n            }\n            this.currentReportedOffset = this.defaultMessageStore.getMaxPhyOffset();\n            this.lastReadTimestamp = System.currentTimeMillis();\n        }\n        return this.socketChannel != null;\n    }\n\n    public void closeMaster() {\n        if (null != this.socketChannel) {\n            try {\n                SelectionKey sk = this.socketChannel.keyFor(this.selector);\n                if (sk != null) {\n                    sk.cancel();\n                }\n                this.socketChannel.close();\n                this.socketChannel = null;\n                log.info(\"HAClient close connection with master {}\", this.masterHaAddress.get());\n            } catch (IOException e) {\n                log.warn(\"closeMaster exception. \", e);\n            }\n            this.lastReadTimestamp = 0;\n            this.dispatchPosition = 0;\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferRead.position(0);\n            this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        super.shutdown();\n        closeMaster();\n        try {\n            this.selector.close();\n        } catch (IOException e) {\n            log.warn(\"Close the selector of AutoRecoverHAClient error, \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.Iterator;\n\npublic class DefaultHAClient extends Thread {\n    private static final int READ_MAX_BUFFER_SIZE = 4 * 1024 * 1024;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp = System.currentTimeMillis();\n    private long lastWriteTimestamp = System.currentTimeMillis();\n    private long currentReportedOffset = 0;\n    private int dispatchPosition = 0;\n    private ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(DefaultMessageStore defaultMessageStore) {\n        this.defaultMessageStore = defaultMessageStore;\n        try {\n            this.selector = Selector.open();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void updateHaMasterAddress(String newAddr) {\n        masterHaAddress.set(newAddr);\n    }\n\n    public boolean reportSlaveMaxOffset(long maxOffset) {\n        if (socketChannel != null && socketChannel.isConnected()) {\n            reportOffset.clear();\n            reportOffset.putLong(maxOffset);\n            reportOffset.flip();\n            try {\n                socketChannel.write(reportOffset);\n                lastWriteTimestamp = System.currentTimeMillis();\n                currentReportedOffset = maxOffset;\n                return true;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return false;\n    }\n\n    private void reallocateByteBuffer() {\n        if (byteBufferRead.remaining() < READ_MAX_BUFFER_SIZE / 4) {\n            swapByteBuffer();\n        }\n    }\n\n    private void swapByteBuffer() {\n        ByteBuffer temp = byteBufferRead;\n        byteBufferRead = byteBufferBackup;\n        byteBufferBackup = temp;\n        byteBufferRead.compact();\n        dispatchPosition = 0;\n    }\n\n    public boolean processReadEvent() {\n        if (socketChannel == null || !socketChannel.isConnected()) return false;\n        try {\n            int numRead = socketChannel.read(byteBufferRead);\n            if (numRead > 0) {\n                lastReadTimestamp = System.currentTimeMillis();\n                return true;\n            } else if (numRead == -1) {\n                closeMaster();\n                return false;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            closeMaster();\n        }\n        return false;\n    }\n\n    public boolean connectMaster() {\n        String addr = masterHaAddress.get();\n        if (addr == null || addr.isEmpty()) return false;\n        try {\n            InetSocketAddress address = new InetSocketAddress(addr.split(\":\")[0], Integer.parseInt(addr.split(\":\")[1]));\n            socketChannel = SocketChannel.open();\n            socketChannel.configureBlocking(false);\n            if (socketChannel.connect(address)) {\n                socketChannel.register(selector, SelectionKey.OP_READ);\n                return true;\n            } else {\n                socketChannel.register(selector, SelectionKey.OP_CONNECT);\n                return false;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public void closeMaster() {\n        try {\n            if (socketChannel != null) {\n                socketChannel.close();\n                socketChannel = null;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        closeMaster();\n        try {\n            if (selector != null) {\n                selector.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        while (!isInterrupted()) {\n            try {\n                selector.select(1000);\n                Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n                while (it.hasNext()) {\n                    SelectionKey key = it.next();\n                    it.remove();\n                    if (key.isConnectable()) {\n                        connectMaster();\n                    }\n                    if (key.isReadable()) {\n                        processReadEvent();\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        shutdown();\n    }\n}"
  },
  {
    "Task_id": 440,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that handles multiple client connections asynchronously, processes incoming data, and sends responses back to clients.\n\nClass Description: The Server class implements a Component interface and provides non-blocking TCP server functionality using Java NIO channels and selectors. It manages client connections, reads incoming data in a length-prefixed format, processes commands, and writes responses back to clients.\n\nAttributes:\n- SERVER_PORT: [int] - The port number on which the server listens for incoming connections\n- conMan: [NIOConnectionManager] - Manages NIO connections and selection operations\n- acceptor: [ServerSocketChannel] - The main server socket channel that accepts incoming connections\n- dhts: [Collection<DHT>] - Collection of DHT instances used for command processing\n\nMethods:\n- start([Collection<DHT> dhts, ConfigReader config]) -> [void] - Initializes the server by creating a non-blocking ServerSocketChannel, binding it to the specified port, and registering it with the connection manager\n- stop() -> [void] - Stops the server by closing the ServerSocketChannel and releasing resources\n- accept() -> [void] - Accepts new client connections, configures them as non-blocking, and registers them with the connection manager for read/write operations\n- read() -> [void] - Reads data from a client channel in a length-prefixed format (4-byte header followed by payload)\n- process([ByteBuffer buf]) -> [void] - Processes the received data buffer by decoding it and executing the appropriate command\n- write() -> [void] - Writes response data back to the client channel\n- calcInterestOps() -> [int] - Calculates the current interest operations (OP_READ/OP_WRITE) for the selection key\n- selectionEvent([SelectionKey key]) -> [void] - Handles selection events (readable/writable) for client channels\n- registrationEvent([NIOConnectionManager manager, SelectionKey key]) -> [void] - Handles registration events with the connection manager\n- getChannel() -> [SelectableChannel] - Returns the associated channel (either server or client channel)\n- doStateChecks([long now]) -> [void] - Performs periodic state checks (currently empty implementation)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentLinkedDeque;\n\nimport lbms.plugins.mldht.kad.DHT;\nimport lbms.plugins.mldht.utils.NIOConnectionManager;\nimport lbms.plugins.mldht.utils.Selectable;\nimport the8472.bencode.BDecoder;\nimport the8472.mldht.Component;\nimport the8472.utils.ConfigReader;\n\npublic class Server implements Component {\n\t\n\tpublic static int SERVER_PORT = 33348;\n\t\n\tNIOConnectionManager conMan = new NIOConnectionManager(\"CLI-server\");\n\tServerSocketChannel acceptor;\n\tCollection<DHT> dhts;\n\t\n\t@Override\n\tpublic void start(Collection<DHT> dhts, ConfigReader config) {\n\t\tthis.dhts = dhts;\n\t\t\n\t\ttry {\n\t\t\tacceptor = ServerSocketChannel.open();\n\t\t\tacceptor.configureBlocking(false);\n\t\t\tacceptor.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n\t\t\tacceptor.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), SERVER_PORT));\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(key.isAcceptable())\n\t\t\t\t\t\taccept();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn acceptor;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\treturn SelectionKey.OP_ACCEPT;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tvoid accept() {\n\t\ttry {\n\t\t\tSocketChannel chan = acceptor.accept();\n\t\t\tchan.configureBlocking(false);\n\t\t\tchan.socket().setSoTimeout(0);\n\t\t\tchan.setOption(StandardSocketOptions.SO_KEEPALIVE, true);\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\tByteBuffer header = ByteBuffer.allocate(4);\n\t\t\t\tByteBuffer payload = null;\n\t\t\t\tByteBuffer currentReadTarget = header;\n\t\t\t\tDeque<ByteBuffer> writes = new ConcurrentLinkedDeque<>();\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(!chan.isOpen()) {\n\t\t\t\t\t\tconMan.deRegister(this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(key.isValid() && key.isReadable())\n\t\t\t\t\t\tread();\n\t\t\t\t\tif(key.isValid() && key.isWritable())\n\t\t\t\t\t\twrite();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid read() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint read = chan.read(currentReadTarget);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(read == -1) {\n\t\t\t\t\t\t\theader = null;\n\t\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(currentReadTarget.remaining() == 0) {\n\t\t\t\t\t\t\tcurrentReadTarget.flip();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(currentReadTarget == header) {\n\t\t\t\t\t\t\t\tpayload = ByteBuffer.allocate(header.getInt(0));\n\t\t\t\t\t\t\t\tcurrentReadTarget = payload;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocess(payload);\n\t\t\t\t\t\t\t\tpayload = null;\n\t\t\t\t\t\t\t\theader.clear();\n\t\t\t\t\t\t\t\tcurrentReadTarget = header;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid process(ByteBuffer buf) {\n\t\t\t\t\tBDecoder decoder = new BDecoder();\n\t\t\t\t\tMap<String, Object> map = decoder.decode(buf);\n\t\t\t\t\tList<byte[]> args = (List<byte[]>) map.get(\"arguments\");\n\t\t\t\t\tCommandProcessor processor = CommandProcessor.from(args, (b) -> {\n\t\t\t\t\t\tByteBuffer h = ByteBuffer.allocate(4);\n\t\t\t\t\t\th.putInt(0, b.remaining());\n\t\t\t\t\t\tsynchronized (writes) {\n\t\t\t\t\t\t\twrites.add(h);\n\t\t\t\t\t\t\twrites.add(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t}, dhts);\n\t\t\t\t\tprocessor.currentWorkDir = Paths.get(new String((byte[])map.get(\"cwd\"), StandardCharsets.UTF_8));\n\t\t\t\t\tprocessor.active = chan::isOpen;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessor.process();\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tprocessor.handleException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid write() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile (!writes.isEmpty()) {\n\t\t\t\t\t\t\tif (!writes.peekFirst().hasRemaining()) {\n\t\t\t\t\t\t\t\twrites.removeFirst();\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlong written = chan.write(writes.stream().toArray(ByteBuffer[]::new));\n\t\t\t\t\t\t\tif (written == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(writes.isEmpty())\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn chan;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\tint ops = 0;\n\t\t\t\t\tif(header != null)\n\t\t\t\t\t\tops = SelectionKey.OP_READ;\n\t\t\t\t\tif(writes.peek() != null)\n\t\t\t\t\t\tops |= SelectionKey.OP_WRITE;\n\t\t\t\t\treturn ops;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void stop() {\n\t\ttry {\n\t\t\tacceptor.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Collection;\nimport java.util.Iterator;\n\npublic class Server implements Component {\n    private final int SERVER_PORT;\n    private final NIOConnectionManager conMan;\n    private ServerSocketChannel acceptor;\n    private Collection<DHT> dhts;\n\n    public Server(int port, NIOConnectionManager connectionManager) {\n        this.SERVER_PORT = port;\n        this.conMan = connectionManager;\n    }\n\n    public void start(Collection<DHT> dhts, ConfigReader config) {\n        try {\n            acceptor = ServerSocketChannel.open();\n            acceptor.configureBlocking(false);\n            acceptor.bind(new InetSocketAddress(SERVER_PORT));\n            conMan.register(acceptor, SelectionKey.OP_ACCEPT);\n            this.dhts = dhts;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (acceptor != null && acceptor.isOpen()) {\n                acceptor.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void accept() {\n        try {\n            SocketChannel clientChannel = acceptor.accept();\n            if (clientChannel != null) {\n                clientChannel.configureBlocking(false);\n                conMan.register(clientChannel, SelectionKey.OP_READ);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void read() {\n        ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n        while (lengthBuffer.hasRemaining()) {\n            // Assume key.channel() is a properly cast SocketChannel\n            if (((SocketChannel) conMan.getSelectedKey().channel()).read(lengthBuffer) < 0) {\n                break;\n            }\n        }\n        lengthBuffer.flip();\n        int payloadLength = lengthBuffer.getInt();\n        if (payloadLength > 0) {\n            ByteBuffer payloadBuffer = ByteBuffer.allocate(payloadLength);\n            while (payloadBuffer.hasRemaining()) {\n                if (((SocketChannel) conMan.getSelectedKey().channel()).read(payloadBuffer) < 0) {\n                    break;\n                }\n            }\n            payloadBuffer.flip();\n            process(payloadBuffer);\n        }\n    }\n\n    public void process(ByteBuffer buf) {\n        byte[] data = new byte[buf.remaining()];\n        buf.get(data);\n        String request = new String(data);\n        String[] parts = request.split(\" \", 2);\n        String command = parts[0];\n        String argument = parts.length > 1 ? parts[1] : \"\";\n\n        StringBuilder response = new StringBuilder();\n        switch (command) {\n            case \"GET\":\n                for (DHT dht : dhts) {\n                    String value = dht.get(argument);\n                    if (value != null) {\n                        response.append(value).append(\"\\n\");\n                    }\n                }\n                break;\n            case \"PUT\":\n                String[] keyValue = argument.split(\"=\", 2);\n                if (keyValue.length == 2) {\n                    for (DHT dht : dhts) {\n                        dht.put(keyValue[0], keyValue[1]);\n                    }\n                    response.append(\"OK\\n\");\n                }\n                break;\n            default:\n                response.append(\"ERROR: Unknown command \").append(command).append(\"\\n\");\n        }\n        ByteBuffer responseBuffer = ByteBuffer.wrap(response.toString().getBytes());\n        write(responseBuffer);\n    }\n\n    public void write(ByteBuffer buf) {\n        try {\n            ((SocketChannel) conMan.getSelectedKey().channel()).write(buf);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int calcInterestOps() {\n        return SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n    }\n\n    public void selectionEvent(SelectionKey key) {\n        if (key.isAcceptable()) {\n            accept();\n        } else if (key.isReadable()) {\n            read();\n        } else if (key.isWritable()) {\n            // Assuming there's a queued buffer to send\n        }\n    }\n\n    public void registrationEvent(NIOConnectionManager manager, SelectionKey key) {\n        if (key.channel() == acceptor) {\n            key.interestOps(SelectionKey.OP_ACCEPT);\n        } else {\n            key.interestOps(SelectionKey.OP_READ);\n        }\n    }\n\n    public SelectableChannel getChannel() {\n        return acceptor;\n    }\n\n    public void doStateChecks(long now) {\n        // No-op as per description\n    }\n}"
  },
  {
    "Task_id": 443,
    "Instruction": "Task Description: Create a Java class that implements a non-blocking TCP server using Java NIO (New I/O) to handle multiple client connections efficiently. The server should accept incoming connections, assign them to processors in a round-robin fashion, and manage connection lifecycle.\n\nClass Description: NIOAcceptor is a thread-based TCP server that uses Java NIO's Selector pattern to handle multiple client connections asynchronously. It creates a ServerSocketChannel, binds it to a specified port, and processes incoming connections by distributing them among available NIOProcessor instances.\n\nAttributes:\nport: [int] - The port number on which the server listens for incoming connections\nselector: [Selector] - The NIO selector used to monitor connection events\nserverChannel: [ServerSocketChannel] - The server socket channel that accepts client connections\nfactory: [FrontendConnectionFactory] - Factory for creating FrontendConnection objects\nprocessors: [NIOProcessor[]] - Array of processors for handling client connections\nnextProcessor: [int] - Index of the next processor to be used (round-robin assignment)\nacceptCount: [long] - Counter for accepted connections\n\nMethods:\nrun: [run()] -> [void] - Main thread loop that continuously checks for incoming connections using the selector\naccept: [accept()] -> [void] - Accepts a new client connection, configures it as non-blocking, and assigns it to a processor\nnextProcessor: [nextProcessor()] -> [NIOProcessor] - Returns the next available processor in round-robin fashion\ncloseChannel: [closeChannel(SocketChannel)] -> [void] - Closes the specified socket channel safely\n\nNested Class:\nAcceptIdGenerator: [static class] - Generates unique IDs for accepted connections with thread-safe increment operation\n  - acceptId: [long] - Current ID value\n  - lock: [Object] - Synchronization object\n  - getId: [getId()] -> [long] - Returns and increments the connection ID safely",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOAcceptor extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOAcceptor.class);\n    private static final AcceptIdGenerator ID_GENERATOR = new AcceptIdGenerator();\n\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n\n    public NIOAcceptor(String name, int port, FrontendConnectionFactory factory) throws IOException {\n        super.setName(name);\n        this.port = port;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.socket().bind(new InetSocketAddress(port));\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        this.factory = factory;\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++acceptCount;\n            try {\n                selector.select(1000L);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        if (key.isValid() && key.isAcceptable()) {\n                            accept();\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(getName(), e);\n            }\n        }\n    }\n\n    private void accept() {\n        SocketChannel channel = null;\n        try {\n            channel = serverChannel.accept();\n            channel.configureBlocking(false);\n            FrontendConnection c = factory.make(channel);\n            c.setAccepted(true);\n            c.setId(ID_GENERATOR.getId());\n            NIOProcessor processor = nextProcessor();\n            c.setProcessor(processor);\n            processor.postRegister(c);\n        } catch (Throwable e) {\n            closeChannel(channel);\n            LOGGER.warn(getName(), e);\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static void closeChannel(SocketChannel channel) {\n        if (channel == null) {\n            return;\n        }\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private static class AcceptIdGenerator {\n        private static final long MAX_VALUE = 0xffffffffL;\n        private long acceptId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (acceptId >= MAX_VALUE) {\n                    acceptId = 0L;\n                }\n                return ++acceptId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\n\npublic class NIOAcceptor extends Thread {\n    private final int port;\n    private Selector selector;\n    private ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private final NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n\n    public NIOAcceptor(int port, FrontendConnectionFactory factory, NIOProcessor[] processors) {\n        this.port = port;\n        this.factory = factory;\n        this.processors = processors;\n        this.nextProcessor = 0;\n        this.acceptCount = 0;\n    }\n\n    @Override\n    public void run() {\n        try {\n            selector = Selector.open();\n            serverChannel = ServerSocketChannel.open();\n            serverChannel.configureBlocking(false);\n            serverChannel.socket().bind(new InetSocketAddress(port));\n            serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (!Thread.interrupted()) {\n                selector.select();\n                Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\n                while (keys.hasNext()) {\n                    SelectionKey key = keys.next();\n                    keys.remove();\n                    if (key.isAcceptable()) {\n                        accept();\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeChannel();\n        }\n    }\n\n    private void accept() {\n        try {\n            SocketChannel channel = serverChannel.accept();\n            if (channel != null) {\n                channel.configureBlocking(false);\n                NIOProcessor processor = nextProcessor();\n                FrontendConnection connection = factory.create(channel, processor.getSelector(), AcceptIdGenerator.getId());\n                connection.initialize();\n                acceptCount++;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        NIOProcessor processor = processors[nextProcessor];\n        nextProcessor = (nextProcessor + 1) % processors.length;\n        return processor;\n    }\n\n    private void closeChannel(SocketChannel channel) {\n        if (channel != null) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void closeChannel() {\n        if (serverChannel != null) {\n            try {\n                serverChannel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static class AcceptIdGenerator {\n        private static long acceptId = 0;\n        private static final Object lock = new Object();\n\n        public static long getId() {\n            synchronized (lock) {\n                return ++acceptId;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 451,
    "Instruction": "Task Description: Create a Java class that implements a clustered event bus using Vert.x TCP server for inter-process communication, handling message delivery between distributed components.\n\nClass Description: The ClusteredEventBus class extends EventBusImpl to provide clustered event bus functionality using Vert.x's TCP server capabilities. It manages TCP connections, processes incoming messages, and delivers them locally within the cluster.\n\nAttributes:\n- options: [EventBusOptions] - Configuration options for the event bus including port, host, and other TCP settings\n- server: [NetServer] - The Vert.x TCP server instance that handles incoming connections\n\nMethods:\n- ClusteredEventBus([VertxInternal vertx, VertxOptions options]) -> [void] - Constructor that initializes the clustered event bus with Vertx instance and options\n- getServerOptions() -> [NetServerOptions] - Creates and returns NetServerOptions based on the event bus configuration\n- start([Promise<Void> promise]) -> [void] - Starts the TCP server and sets up connection handlers\n- getServerHandler() -> [Handler<NetSocket>] - Creates and returns the handler for processing incoming TCP connections and messages\n- getClusterPort() -> [int] - Returns the configured cluster port from options\n- getClusterHost() -> [String] - Returns the configured cluster host address from options or default address if not specified",
    "Canonical_solution": "import io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.parsetools.RecordParser;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n  private final EventBusOptions options;\n  private NetServer server;\n\n  public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n    super(vertx);\n    this.options = options.getEventBusOptions();\n  }\n\n  private NetServerOptions getServerOptions() {\n    return new NetServerOptions(this.options.toJson());\n  }\n\n  @Override\n  public void start(Promise<Void> promise) {\n    NetServerOptions serverOptions = getServerOptions();\n    server = vertx.createNetServer(serverOptions);\n    server.connectHandler(getServerHandler());\n    int port = getClusterPort();\n    String host = getClusterHost();\n    server.listen(port, host).onComplete(promise);\n  }\n\n  private Handler<NetSocket> getServerHandler() {\n    return socket -> {\n      RecordParser parser = RecordParser.newFixed(4);\n      Handler<Buffer> handler = new Handler<Buffer>() {\n        int size = -1;\n\n        public void handle(Buffer buff) {\n          if (size == -1) {\n            size = buff.getInt(0);\n            parser.fixedSizeMode(size);\n          } else {\n            ClusteredMessage received = new ClusteredMessage(ClusteredEventBus.this);\n            received.readFromWire(buff, codecManager);\n            parser.fixedSizeMode(4);\n            size = -1;\n            if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {\n              socket.write(PONG);\n            } else {\n              deliverMessageLocally(received);\n            }\n          }\n        }\n      };\n      parser.setOutput(handler);\n      socket.handler(parser);\n    };\n  }\n\n  private int getClusterPort() {\n    return options.getPort();\n  }\n\n  private String getClusterHost() {\n    String host;\n    if ((host = options.getHost()) != null) {\n      return host;\n    }\n    return AddressHelper.defaultAddress();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "import io.vertx.core.*;\nimport io.vertx.core.eventbus.EventBus;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n  private final EventBusOptions options;\n  private NetServer server;\n\n  public ClusteredEventBus(VertxInternal vertx, EventBusOptions options) {\n    super(vertx, options);\n    this.options = options;\n    this.server = vertx.createNetServer(getServerOptions());\n  }\n\n  private NetServerOptions getServerOptions() {\n    return new NetServerOptions()\n      .setPort(getClusterPort())\n      .setHost(getClusterHost())\n      .setReuseAddress(true)\n      .setTcpKeepAlive(true);\n  }\n\n  @Override\n  public void start(Promise<Void> promise) {\n    server.connectHandler(getServerHandler()).listen(ar -> {\n      if (ar.succeeded()) {\n        promise.complete();\n      } else {\n        promise.fail(ar.cause());\n      }\n    });\n  }\n\n  private Handler<NetSocket> getServerHandler() {\n    return socket -> {\n      socket.handler(buffer -> {\n        // Handle incoming message buffer and deliver locally\n        try {\n          Object message = deserialize(buffer);\n          deliverLocal(message);\n        } catch (Exception e) {\n          // Log error or handle accordingly\n        }\n      });\n    };\n  }\n\n  private int getClusterPort() {\n    return options.getClusterPort();\n  }\n\n  private String getClusterHost() {\n    return options.getClusterHost() == null ? \"0.0.0.0\" : options.getClusterHost();\n  }\n\n  // Placeholder for deserialization logic\n  private Object deserialize(Buffer buffer) throws Exception {\n    // Implement actual deserialization based on your message format\n    return buffer.toString();\n  }\n\n  // Placeholder for local delivery logic\n  private void deliverLocal(Object message) {\n    // Implement message dispatching to local handlers\n  }\n}"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a Java class that implements metadata updates for an Icecast broadcast server using HTTP client functionality.\n\nClass Description: The IcecastBroadcastMetadataUpdater class is responsible for sending metadata updates to an Icecast server via HTTP requests. It constructs the appropriate URL, handles authentication, and manages the HTTP communication asynchronously. The class implements the IBroadcastMetadataUpdater interface and handles character encoding, error logging, and connection status tracking.\n\nAttributes:\n- mLog: Logger - Logger instance for error and status logging\n- mHttpClient: HttpClient - HTTP client instance for making requests\n- mIcecastConfiguration: IcecastConfiguration - Configuration object containing server details (host, port, mount point, credentials)\n- mConnectionLoggingSuppressed: boolean - Flag to prevent duplicate connection error logs\n\nMethods:\n- IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) -> void - Constructor that initializes the class with Icecast server configuration\n- update(IdentifierCollection identifierCollection) -> void - Main method that constructs and sends the metadata update request to the Icecast server. Takes an IdentifierCollection containing metadata information as input. Handles URL construction, encoding, and asynchronous request execution.",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.IBroadcastMetadataUpdater;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastConfiguration;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastMetadata;\nimport io.github.dsheirer.identifier.IdentifierCollection;\nimport io.github.dsheirer.properties.SystemProperties;\nimport io.github.dsheirer.util.ThreadPool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater\n{\n    private final static Logger mLog = LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n    private final static String UTF8 = \"UTF-8\";\n    private HttpClient mHttpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).build();\n    private IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration)\n    {\n        mIcecastConfiguration = icecastConfiguration;\n    }\n\n    public void update(IdentifierCollection identifierCollection)\n    {\n        if(mIcecastConfiguration.hasInline())\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        try\n        {\n            sb.append(\"http://\");\n            sb.append(mIcecastConfiguration.getHost());\n            sb.append(\":\");\n            sb.append(mIcecastConfiguration.getPort());\n            sb.append(\"/admin/metadata?mode=updinfo&mount=\");\n            sb.append(URLEncoder.encode(mIcecastConfiguration.getMountPoint(), UTF8));\n            sb.append(\"&charset=UTF%2d8\");\n            sb.append(\"&song=\").append(URLEncoder.encode(IcecastMetadata.getTitle(identifierCollection), UTF8));\n        }\n        catch(UnsupportedEncodingException uee)\n        {\n            mLog.error(\"Error encoding metadata information to UTF-8\", uee);\n            sb = null;\n        }\n\n        if(sb != null)\n        {\n            final String metadataUpdateURL = sb.toString();\n            URI uri = URI.create(metadataUpdateURL);\n\n            ThreadPool.CACHED.submit(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        HttpRequest request = HttpRequest.newBuilder()\n                            .uri(uri)\n                            .header(\"Authorization\", mIcecastConfiguration.getBase64EncodedCredentials())\n                            .header(\"User-Agent\", SystemProperties.getInstance().getApplicationName())\n                            .GET()\n                            .build();\n\n                        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n                        if(response != null)\n                        {\n                            if(response.statusCode() == 200)\n                            {\n                                mConnectionLoggingSuppressed = false;\n                            }\n                            else if(!mConnectionLoggingSuppressed)\n                            {\n                                mLog.info(\"Error submitting Icecast 2 Metadata update to URL [\" + metadataUpdateURL +\n                                    \"] HTTP Response Code [\" + response.statusCode() + \"] Body [\" + response.body() + \"]\");\n                                mConnectionLoggingSuppressed = true;\n                            }\n                        }\n                    }\n                    catch(IOException | InterruptedException e)\n                    {\n                        mLog.error(\"Error submitting Icecast metadata update\", e);\n                    }\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater {\n    private final Logger mLog;\n    private final HttpClient mHttpClient;\n    private final IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) {\n        mIcecastConfiguration = icecastConfiguration;\n        mLog = LoggerFactory.getLogger(getClass());\n        mHttpClient = new HttpClient();\n        mConnectionLoggingSuppressed = false;\n    }\n\n    @Override\n    public void update(IdentifierCollection identifierCollection) {\n        try {\n            String streamTitle = identifierCollection.get(StreamTitleKey);\n            String streamUrl = identifierCollection.get(StreamUrlKey);\n            String genre = identifierCollection.get(GenreKey);\n            String artist = identifierCollection.get(ArtistKey);\n            String description = identifierCollection.get(DescriptionKey);\n\n            String encodedStreamTitle = URLEncoder.encode(streamTitle, StandardCharsets.UTF_8);\n            String encodedStreamUrl = URLEncoder.encode(streamUrl, StandardCharsets.UTF_8);\n            String encodedGenre = URLEncoder.encode(genre, StandardCharsets.UTF_8);\n            String encodedArtist = URLEncoder.encode(artist, StandardCharsets.UTF_8);\n            String encodedDescription = URLEncoder.encode(description, StandardCharsets.UTF_8);\n\n            String metadataUpdateUrl = String.format(\"http://%s:%d/admin/metadata?mount=/%s&mode=updinfo&song=%s\",\n                    mIcecastConfiguration.getHost(),\n                    mIcecastConfiguration.getPort(),\n                    URLEncoder.encode(mIcecastConfiguration.getMountPoint(), StandardCharsets.UTF_8),\n                    encodedStreamTitle);\n\n            if (!encodedStreamUrl.isEmpty()) {\n                metadataUpdateUrl += \"&url=\" + encodedStreamUrl;\n            }\n            if (!encodedGenre.isEmpty()) {\n                metadataUpdateUrl += \"&genre=\" + encodedGenre;\n            }\n            if (!encodedArtist.isEmpty()) {\n                metadataUpdateUrl += \"&artist=\" + encodedArtist;\n            }\n            if (!encodedDescription.isEmpty()) {\n                metadataUpdateUrl += \"&description=\" + encodedDescription;\n            }\n\n            ExecutorService executor = Executors.newSingleThreadExecutor();\n            executor.submit(() -> {\n                try {\n                    URI uri = new URI(metadataUpdateUrl);\n                    HttpGet request = new HttpGet(uri);\n                    String credentials = mIcecastConfiguration.getUsername() + \":\" + mIcecastConfiguration.getPassword();\n                    String encodedCredentials = Base64.getEncoder().encodeToString(credentials.getBytes(StandardCharsets.UTF_8));\n                    request.setHeader(\"Authorization\", \"Basic \" + encodedCredentials);\n\n                    HttpResponse response = mHttpClient.execute(request);\n                    int statusCode = response.getStatusLine().getStatusCode();\n\n                    if (statusCode == HttpStatus.SC_OK) {\n                        if (mLog.isInfoEnabled()) {\n                            mLog.info(\"Successfully updated Icecast metadata for mount point: {}\", mIcecastConfiguration.getMountPoint());\n                        }\n                    } else {\n                        if (!mConnectionLoggingSuppressed) {\n                            mLog.error(\"Failed to update Icecast metadata. Status code: {}\", statusCode);\n                            mConnectionLoggingSuppressed = true;\n                        }\n                    }\n                } catch (Exception e) {\n                    if (!mConnectionLoggingSuppressed) {\n                        mLog.error(\"Error updating Icecast metadata\", e);\n                        mConnectionLoggingSuppressed = true;\n                    }\n                }\n            });\n            executor.shutdown();\n        } catch (Exception e) {\n            mLog.warn(\"Exception occurred while preparing metadata update\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Java HTTP client class that simplifies making HTTP requests (GET, POST, DELETE) to a base URI, with support for parameterized URLs and exception handling.\n\nClass Description: TeenyHttpClient is a lightweight HTTP client wrapper that provides methods for common HTTP operations. It handles request construction, execution, and basic response handling while abstracting away boilerplate code.\n\nAttributes:\nbaseUri: String - The base URL to which all requests will be appended\nhttpClient: HttpClient - The underlying HttpClient instance used for making requests\n\nMethods:\nget: get(String url) -> HttpResponse<String> - Sends a GET request to the specified URL appended to the base URI\nget: get(String url, Object... params) -> HttpResponse<String> - Sends a GET request with URL parameters (formatted using String.format)\ndelete: delete(String url, Object... params) -> HttpResponse<String> - Sends a DELETE request with URL parameters\npost: post(String url, Object... params) -> HttpResponse<String> - Sends a POST request with URL parameters (with empty body)\nunchecked: unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) -> T - Helper method that wraps checked exceptions in RuntimeException",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\n\npublic class TeenyHttpClient {\n\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        httpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_1_1)\n                .build();\n    }\n\n    public HttpResponse<String> get(String url) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + url))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .DELETE()\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    private <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\npublic class TeenyHttpClient {\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public HttpResponse<String> get(String url) {\n        return unchecked(() -> {\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(baseUri + url))\n                    .GET()\n                    .build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        });\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        String formattedUrl = formatUrl(url, params);\n        return get(formattedUrl);\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        return unchecked(() -> {\n            String formattedUrl = formatUrl(url, params);\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(baseUri + formattedUrl))\n                    .DELETE()\n                    .build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        });\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        return unchecked(() -> {\n            String formattedUrl = formatUrl(url, params);\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(baseUri + formattedUrl))\n                    .POST(HttpRequest.BodyPublishers.noBody())\n                    .build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        });\n    }\n\n    private String formatUrl(String url, Object... params) {\n        if (params.length == 0) return url;\n        return String.format(url, params);\n    }\n\n    public static <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\ninterface Exceptions {\n    @FunctionalInterface\n    interface ThrowingSupplier<T> {\n        T get() throws Exception;\n    }\n}"
  },
  {
    "Task_id": 502,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with a PD (Placement Driver) server, supporting both blocking and asynchronous communication patterns, with connection management and error handling capabilities.\n\nClass Description: AbstractClient is an abstract base class that provides core gRPC client functionality for PD server communication. It manages channel connections, creates stubs, implements retry logic, and handles connection failures. The class is designed to be extended by concrete implementations that provide specific stub creation methods.\n\nAttributes:\n- chs: ConcurrentHashMap<String, ManagedChannel> - Shared map of managed channels by host\n- stubProxy: AbstractClientStubProxy - Proxy for managing stub instances\n- config: PDConfig - Configuration object containing server hosts and timeout settings\n- channel: ManagedChannel - Current active channel connection\n- stubs: ConcurrentMap<String, AbstractBlockingStub> - Map of blocking stubs by address\n\nMethods:\n- AbstractClient(PDConfig config) -> void - Constructor that initializes the client with configuration\n- getBlockingStub() -> AbstractBlockingStub - Gets or creates a blocking stub instance\n- getStub() -> AbstractStub - Gets or creates an async stub instance\n- createStub() -> AbstractStub - Abstract method to be implemented for creating async stubs\n- createBlockingStub() -> AbstractBlockingStub - Abstract method to be implemented for creating blocking stubs\n- resetStub() -> String - Resets the connection and finds the current leader host\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) -> RespT - Makes a blocking unary RPC call with default retries\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) -> RespT - Makes a blocking unary RPC call with specified retries\n- concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) -> KVPair<Boolean, RespT> - Makes concurrent calls to multiple hosts\n- streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) -> void - Makes a server streaming call\n- close() -> void - Closes all active channels and cleans up resources\n- closeChannel(ManagedChannel channel) -> void - Helper method to safely close a channel",
    "Canonical_solution": "import java.io.Closeable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\nimport org.apache.hugegraph.pd.common.KVPair;\nimport org.apache.hugegraph.pd.common.PDException;\nimport org.apache.hugegraph.pd.grpc.PDGrpc;\nimport org.apache.hugegraph.pd.grpc.PDGrpc.PDBlockingStub;\nimport org.apache.hugegraph.pd.grpc.Pdpb;\n\nimport io.grpc.Channel;\nimport io.grpc.ClientCall;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.ClientCalls;\nimport io.grpc.stub.StreamObserver;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic abstract class AbstractClient implements Closeable {\n\n    private static final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel = null;\n    protected volatile ConcurrentMap<String, AbstractBlockingStub> stubs = null;\n\n    protected AbstractClient(PDConfig config) {\n        String[] hosts = config.getServerHost().split(\",\");\n        this.stubProxy = new AbstractClientStubProxy(hosts);\n        this.config = config;\n    }\n\n    protected AbstractBlockingStub getBlockingStub() throws PDException {\n        if (stubProxy.getBlockingStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getBlockingStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return (AbstractBlockingStub) stubProxy.getBlockingStub()\n                                               .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                  TimeUnit.MILLISECONDS);\n    }\n\n    protected AbstractStub getStub() throws PDException {\n        if (stubProxy.getStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return stubProxy.getStub();\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    private String resetStub() {\n        String leaderHost = \"\";\n        for (int i = 0; i < stubProxy.getHostCount(); i++) {\n            String host = stubProxy.nextHost();\n            channel = ManagedChannelBuilder.forTarget(host).usePlaintext().build();\n            PDBlockingStub blockingStub = PDGrpc.newBlockingStub(channel)\n                                                .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                   TimeUnit.MILLISECONDS);\n            try {\n                GetMembersRequest request = Pdpb.GetMembersRequest.newBuilder()\n                                                                  .setHeader(header).build();\n                GetMembersResponse members = blockingStub.getMembers(request);\n                Metapb.Member leader = members.getLeader();\n                leaderHost = leader.getGrpcUrl();\n                close();\n                channel = ManagedChannelBuilder.forTarget(leaderHost).usePlaintext().build();\n                stubProxy.setBlockingStub(createBlockingStub());\n                stubProxy.setStub(createStub());\n                log.info(\"PDClient connect to host = {} success\", leaderHost);\n                break;\n            } catch (Exception e) {\n                log.error(\"PDClient connect to {} exception {}, {}\", host, e.getMessage(),\n                          e.getCause() != null ? e.getCause().getMessage() : \"\");\n            }\n        }\n        return leaderHost;\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req) throws PDException {\n        return blockingUnaryCall(method, req, 5);\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) throws PDException {\n        AbstractBlockingStub stub = getBlockingStub();\n        try {\n            RespT resp =\n                    ClientCalls.blockingUnaryCall(stub.getChannel(), method, stub.getCallOptions(),\n                                                  req);\n            return resp;\n        } catch (Exception e) {\n            log.error(method.getFullMethodName() + \" exception, {}\", e.getMessage());\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setBlockingStub(null);\n                    }\n                    return blockingUnaryCall(method, req, ++retry);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        LinkedList<String> hostList = this.stubProxy.getHostList();\n        if (this.stubs == null) {\n            synchronized (this) {\n                if (this.stubs == null) {\n                    this.stubs = new ConcurrentHashMap<>(hostList.size());\n                }\n            }\n        }\n        Stream<RespT> respTStream = hostList.parallelStream().map((address) -> {\n            AbstractBlockingStub stub = getConcurrentBlockingStub(address);\n            RespT resp = ClientCalls.blockingUnaryCall(stub.getChannel(),\n                                                       method, stub.getCallOptions(), req);\n            return resp;\n        });\n        KVPair<Boolean, RespT> pair;\n        AtomicReference<RespT> response = new AtomicReference<>();\n        boolean result = respTStream.anyMatch((r) -> {\n            response.set(r);\n            return predicate.test(r);\n        });\n        if (result) {\n            pair = new KVPair<>(true, null);\n        } else {\n            pair = new KVPair<>(false, response.get());\n        }\n        return pair;\n    }\n\n    protected <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request,\n                                               StreamObserver<RespT> responseObserver,\n                                               int retry) throws PDException {\n        AbstractStub stub = getStub();\n        try {\n            ClientCall<ReqT, RespT> call = stub.getChannel().newCall(method, stub.getCallOptions());\n            ClientCalls.asyncServerStreamingCall(call, request, responseObserver);\n        } catch (Exception e) {\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setStub(null);\n                    }\n                    streamingCall(method, request, responseObserver, ++retry);\n                    return;\n                }\n            }\n            log.error(\"rpc call with exception, {}\", e.getMessage());\n        }\n    }\n\n    @Override\n    public void close() {\n        closeChannel(channel);\n        if (stubs != null) {\n            for (AbstractBlockingStub stub : stubs.values()) {\n                closeChannel((ManagedChannel) stub.getChannel());\n            }\n        }\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        try {\n            while (channel != null &&\n                   !channel.shutdownNow().awaitTermination(100, TimeUnit.MILLISECONDS)) {\n                continue;\n            }\n        } catch (Exception e) {\n            log.info(\"Close channel with error : \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "import io.grpc.ManagedChannel;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.netty.NettyChannelBuilder;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.StreamObserver;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.Predicate;\n\npublic abstract class AbstractClient {\n    protected final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel;\n    protected final ConcurrentMap<String, AbstractBlockingStub> stubs = new ConcurrentHashMap<>();\n\n    public AbstractClient(PDConfig config) {\n        this.config = config;\n        this.stubProxy = new AbstractClientStubProxy();\n        this.channel = getOrCreateChannel(config.getLeaderHost());\n    }\n\n    private ManagedChannel getOrCreateChannel(String host) {\n        return chs.computeIfAbsent(host, h -> NettyChannelBuilder.forTarget(h)\n                .usePlaintext()\n                .build());\n    }\n\n    public AbstractBlockingStub getBlockingStub() {\n        return stubs.computeIfAbsent(channel.getTarget(), h -> createBlockingStub());\n    }\n\n    public AbstractStub getStub() {\n        return createStub();\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    public String resetStub() {\n        try {\n            channel.shutdown();\n            String currentLeader = determineCurrentLeader();\n            channel = getOrCreateChannel(currentLeader);\n            return currentLeader;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to reset stub and find leader\", e);\n        }\n    }\n\n    private String determineCurrentLeader() {\n        // Logic to discover the current leader host\n        return config.getHosts()[0]; // Simplified for example\n    }\n\n    public <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) {\n        return blockingUnaryCall(method, req, 3); // Default retries\n    }\n\n    public <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) {\n        int attempts = 0;\n        while (attempts++ < retry) {\n            try {\n                return getBlockingStub().blockingUnaryCall(method, req);\n            } catch (StatusRuntimeException e) {\n                if (e.getStatus().getCode() == io.grpc.Status.Code.UNAVAILABLE) {\n                    resetStub();\n                }\n            }\n        }\n        throw new RuntimeException(\"RPC call failed after \" + retry + \" retries\");\n    }\n\n    public <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        // Implementation of concurrent calls to multiple hosts would go here\n        // This is a placeholder for demonstration purposes\n        RespT response = blockingUnaryCall(method, req);\n        boolean result = predicate.test(response);\n        return new KVPair<>(result, response);\n    }\n\n    public <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) {\n        AbstractStub stub = getStub();\n        StreamObserver<ReqT> requestObserver = stub.serverStreamingCall(method, responseObserver);\n        try {\n            requestObserver.onNext(request);\n            requestObserver.onCompleted();\n        } catch (Exception e) {\n            responseObserver.onError(e);\n        }\n    }\n\n    public void close() {\n        chs.forEach((host, channel) -> closeChannel(channel));\n        chs.clear();\n        stubs.clear();\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        if (channel != null && !channel.isShutdown()) {\n            channel.shutdown();\n        }\n    }\n}\n\nclass KVPair<K, V> {\n    private final K key;\n    private final V value;\n\n    public KVPair(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    public K getKey() {\n        return key;\n    }\n\n    public V getValue() {\n        return value;\n    }\n}"
  },
  {
    "Task_id": 520,
    "Instruction": "Here is the structured instruction for the class-level reference code:\n\nTask Description: Implement a class that facilitates TCP socket communication between a server and client on the local machine, using a secret string for verification and callback notifications.\n\nClass Description: The `SocketCommunication` class establishes a TCP server that listens for incoming connections and a client that probes open ports. When the client finds a matching server using a secret string, it triggers a callback notification.\n\nAttributes:\n- TAG: String - A tag used for logging purposes\n- secret: String - The secret string used for verification between client and server\n- callback: VirtualCheckCallback - A callback interface to notify when a suspect is found\n- portList: ArrayList<Integer> - A list of ports to probe for server connections\n\nMethods:\n- checkByPortListening(String, VirtualCheckCallback) -> void - Initiates the client and server threads for communication\n- startServer(String, VirtualCheckCallback) -> void - Creates a server socket that listens for incoming connections and spawns read threads\n- startClient(String) -> void - Scans for open ports and spawns client threads to probe them\n- ServerThread(String, VirtualCheckCallback) -> void - A thread class that runs the server socket\n- ReadThread(String, Socket, VirtualCheckCallback) -> void - A thread class that reads incoming data from a socket connection\n- ClientThread(String, int) -> void - A thread class that attempts to connect to a server socket and send the secret string",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.BindException;\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class SocketCommunication {\n    private String TAG = \"SocketCommunication\";\n    \n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        startClient(secret);\n        new ServerThread(secret, callback).start();\n    }\n\n    private class ServerThread extends Thread {\n        String secret;\n        VirtualCheckCallback callback;\n\n        private ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            startServer(secret, callback);\n        }\n    }\n\n    private void startServer(String secret, VirtualCheckCallback callback) {\n        Random random = new Random();\n        ServerSocket serverSocket = null;\n        try {\n            serverSocket = new ServerSocket();\n            serverSocket.bind(new InetSocketAddress(\"127.0.0.1\",\n                    random.nextInt(55534) + 10000));\n            while (true) {\n                Socket socket = serverSocket.accept();\n                ReadThread readThread = new ReadThread(secret, socket, callback);\n                readThread.start();\n            }\n        } catch (BindException e) {\n            startServer(secret, callback);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            InputStream inputStream = null;\n            try {\n                inputStream = socket.getInputStream();\n                byte buffer[] = new byte[1024 * 4];\n                int temp = 0;\n                while ((temp = inputStream.read(buffer)) != -1) {\n                    String result = new String(buffer, 0, temp);\n                    if (result.contains(secret) && callback != null)\n                        callback.findSuspect();\n                }\n                inputStream.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void startClient(String secret) {\n        String tcp6 = CommandUtil.getSingleInstance().exec(\"cat /proc/net/tcp6\");\n        if (TextUtils.isEmpty(tcp6)) return;\n        String[] lines = tcp6.split(\"\\n\");\n        ArrayList<Integer> portList = new ArrayList<>();\n        for (int i = 0, len = lines.length; i < len; i++) {\n            int localHost = lines[i].indexOf(\"0100007F:\");\n            if (localHost < 0) continue;\n            String singlePort = lines[i].substring(localHost + 9, localHost + 13);\n            Integer port = Integer.parseInt(singlePort, 16);\n            portList.add(port);\n        }\n        if (portList.isEmpty()) return;\n        for (int port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    private class ClientThread extends Thread {\n        String secret;\n        int port;\n\n        private ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            try {\n                Socket socket = new Socket(\"127.0.0.1\", port);\n                socket.setSoTimeout(2000);\n                OutputStream outputStream = socket.getOutputStream();\n                outputStream.write((secret + \"\\n\").getBytes(\"utf-8\"));\n                outputStream.flush();\n                socket.shutdownOutput();\n\n                InputStream inputStream = socket.getInputStream();\n                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n                String info = null;\n                while ((info = bufferedReader.readLine()) != null) {\n                    Log.i(TAG, \"ClientThread: \" + info);\n                }\n\n                bufferedReader.close();\n                inputStream.close();\n                socket.close();\n            } catch (ConnectException e) {\n                Log.i(TAG, port + \"port refused\");\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (UnknownHostException e) {\n                e.printStackTrace();\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class SocketCommunication {\n    private static final String TAG = \"SocketCommunication\";\n    private String secret;\n    private VirtualCheckCallback callback;\n    private ArrayList<Integer> portList;\n\n    public SocketCommunication(String secret, VirtualCheckCallback callback, ArrayList<Integer> portList) {\n        this.secret = secret;\n        this.callback = callback;\n        this.portList = portList;\n    }\n\n    public void checkByPortListening(String action, VirtualCheckCallback callback) {\n        new Thread(() -> {\n            startServer(action, callback);\n            startClient(action);\n        }).start();\n    }\n\n    public void startServer(String action, VirtualCheckCallback callback) {\n        new ServerThread(action, callback).start();\n    }\n\n    public void startClient(String action) {\n        for (int port : portList) {\n            new ClientThread(action, port).start();\n        }\n    }\n\n    private class ServerThread extends Thread {\n        private String action;\n        private VirtualCheckCallback callback;\n\n        public ServerThread(String action, VirtualCheckCallback callback) {\n            this.action = action;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try (ServerSocket serverSocket = new ServerSocket(0)) {\n                int port = serverSocket.getLocalPort();\n                System.out.println(TAG + \": Server started on port \" + port);\n\n                while (true) {\n                    Socket clientSocket = serverSocket.accept();\n                    new ReadThread(action, clientSocket, callback).start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private String action;\n        private Socket socket;\n        private VirtualCheckCallback callback;\n\n        public ReadThread(String action, Socket socket, VirtualCheckCallback callback) {\n            this.action = action;\n            this.socket = socket;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n                String receivedSecret = in.readLine();\n                if (secret.equals(receivedSecret)) {\n                    callback.onSuspectFound(action);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class ClientThread extends Thread {\n        private String action;\n        private int port;\n\n        public ClientThread(String action, int port) {\n            this.action = action;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            try (Socket socket = new Socket()) {\n                socket.connect(new InetSocketAddress(\"127.0.0.1\", port), 1000);\n                BufferedWriter out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n                out.write(secret + \"\\n\");\n                out.flush();\n            } catch (IOException e) {\n                // Silent failure; server not listening here\n            }\n        }\n    }\n}\n\ninterface VirtualCheckCallback {\n    void onSuspectFound(String action);\n}"
  },
  {
    "Task_id": 535,
    "Instruction": "Task Description: Implement an Android input capture provider that uses TCP socket communication to interface with a native evdev reader process for handling input events from rooted devices.\n\nClass Description: EvdevCaptureProvider is an Android input capture implementation that establishes a TCP server to communicate with a native evdev reader process running with root privileges. It handles input event capture and forwarding while managing the lifecycle of the socket connection and root process.\n\nAttributes:\n- listener: [EvdevListener] - Callback interface for handling input events\n- libraryPath: [String] - Path to the native library directory\n- shutdown: [boolean] - Flag indicating whether the provider should terminate\n- evdevIn: [InputStream] - Input stream from the evdev reader socket\n- evdevOut: [OutputStream] - Output stream to the evdev reader socket\n- su: [Process] - Root process running the evdev reader\n- servSock: [ServerSocket] - TCP server socket for accepting connections\n- evdevSock: [Socket] - Socket connection to the evdev reader\n- activity: [Activity] - Android activity context\n- started: [boolean] - Flag indicating if the provider has started\n- handlerThread: [Thread] - Thread handling the socket communication\n\nMethods:\n- EvdevCaptureProvider([Activity activity, EvdevListener listener]) -> [void] - Constructor that initializes the capture provider with activity context and event listener\n- destroy() -> [void] - Cleans up resources including sockets, streams, and terminates the root process\n- reportDeviceNotRooted() -> [void] - Displays a toast message when the device isn't rooted (private helper method)\n- run() -> [void] - Thread implementation that establishes the server socket, launches the root process, and handles event reading (inner Thread class method)",
    "Canonical_solution": "import android.app.Activity;\nimport android.os.Build;\nimport android.os.Looper;\nimport android.widget.Toast;\n\nimport com.limelight.LimeLog;\nimport com.limelight.binding.input.capture.InputCaptureProvider;\n\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EvdevCaptureProvider extends InputCaptureProvider {\n\n    private final EvdevListener listener;\n    private final String libraryPath;\n\n    private boolean shutdown = false;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started = false;\n\n    private static final byte UNGRAB_REQUEST = 1;\n    private static final byte REGRAB_REQUEST = 2;\n\n    private final Thread handlerThread = new Thread() {\n        @Override\n        public void run() {\n            try {\n                servSock = new ServerSocket(0, 1);\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            final String evdevReaderCmd = libraryPath+File.separatorChar+\"libevdev_reader.so \"+servSock.getLocalPort();\n\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n                try {\n                    su = new ProcessBuilder(\"su\", \"-c\", evdevReaderCmd).start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n            else {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                try {\n                    su = builder.start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n\n                DataOutputStream suOut = new DataOutputStream(su.getOutputStream());\n                try {\n                    suOut.writeChars(evdevReaderCmd+\"\\n\");\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n\n            LimeLog.info(\"Waiting for EvdevReader connection to port \"+servSock.getLocalPort());\n            try {\n                evdevSock = servSock.accept();\n                evdevIn = evdevSock.getInputStream();\n                evdevOut = evdevSock.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n            LimeLog.info(\"EvdevReader connected from port \"+evdevSock.getPort());\n\n            while (!isInterrupted() && !shutdown) {\n                EvdevEvent event;\n                try {\n                    event = EvdevReader.read(evdevIn);\n                } catch (IOException e) {\n                    event = null;\n                }\n                if (event == null) {\n                    break;\n                }\n            }\n        }\n    };\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.listener = listener;\n        this.activity = activity;\n        this.libraryPath = activity.getApplicationInfo().nativeLibraryDir;\n    }\n\n    private void reportDeviceNotRooted() {\n        activity.runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                Toast.makeText(activity, \"This device is not rooted - Mouse capture is unavailable\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n\n    @Override\n    public void destroy() {\n        if (!started) {\n            return;\n        }\n\n        shutdown = true;\n        handlerThread.interrupt();\n\n        if (servSock != null) {\n            try {\n                servSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevSock != null) {\n            try {\n                evdevSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevIn != null) {\n            try {\n                evdevIn.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevOut != null) {\n            try {\n                evdevOut.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (su != null) {\n            su.destroy();\n        }\n\n        try {\n            handlerThread.join();\n        } catch (InterruptedException ignored) {}\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class EvdevCaptureProvider {\n    private EvdevListener listener;\n    private String libraryPath;\n    private boolean shutdown;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started;\n    private Thread handlerThread;\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.activity = activity;\n        this.listener = listener;\n        this.libraryPath = activity.getApplicationInfo().nativeLibraryDir;\n    }\n\n    public void destroy() {\n        shutdown = true;\n        try {\n            if (evdevSock != null) evdevSock.close();\n            if (servSock != null) servSock.close();\n            if (su != null) su.destroy();\n        } catch (IOException e) {\n            // Ignore\n        }\n    }\n\n    private void reportDeviceNotRooted() {\n        activity.runOnUiThread(() -> Toast.makeText(activity, \"Device not rooted\", Toast.LENGTH_SHORT).show());\n    }\n\n    public interface EvdevListener {\n        void onInputEvent(byte[] event);\n    }\n\n    public void start() {\n        if (started) return;\n        started = true;\n        handlerThread = new Thread(this::run);\n        handlerThread.start();\n    }\n\n    private void run() {\n        try {\n            servSock = new ServerSocket(0);\n            servSock.setReuseAddress(true);\n\n            String[] cmd = {\"su\", \"-c\", libraryPath + \"/libevdev_reader.so \" + servSock.getLocalPort()};\n            su = new ProcessBuilder(cmd).start();\n\n            evdevSock = servSock.accept();\n            servSock.close();\n            servSock = null;\n\n            evdevIn = evdevSock.getInputStream();\n            evdevOut = evdevSock.getOutputStream();\n\n            byte[] buffer = new byte[16];\n            int read;\n            while (!shutdown && (read = evdevIn.read(buffer)) > 0) {\n                listener.onInputEvent(buffer);\n            }\n        } catch (IOException e) {\n            if (!shutdown) {\n                reportDeviceNotRooted();\n            }\n        } finally {\n            destroy();\n            started = false;\n        }\n    }\n}"
  },
  {
    "Task_id": 547,
    "Instruction": "Task Description: Implement a TCP server class that listens for incoming client connections, processes client commands, and sends responses back. The server should run in a dedicated thread and support graceful shutdown.\n\nClass Description: SnapshotService is a TCP server implementation that listens on a specified port for client connections. It processes incoming commands from clients and responds with processed messages. The server runs in a separate thread and maintains its state through a boolean flag for controlled shutdown.\n\nAttributes:\n- port: [int] - The port number on which the server listens for incoming connections\n- serverSocket: [ServerSocket] - The server socket instance used to accept client connections\n- closed: [boolean] - Flag indicating whether the server has been shut down\n\nMethods:\n- SnapshotService(int port) -> [void] - Constructor that validates and sets the server port\n- listen() -> [void] - Starts the server by opening a socket and beginning to listen for connections\n- openSocket(int port) -> [int] - Creates a ServerSocket and starts a thread to handle client connections, returns the actual port being used\n- isIgnoredException() -> [boolean] - Checks if an exception should be ignored based on server socket state\n- process(Socket socket) -> [void] - Processes an individual client connection, reading input and sending responses\n- outputMessage(BufferedWriter outputWriter, String msg) -> [void] - Helper method to send messages to clients\n- close() -> [void] - Gracefully shuts down the server by closing the server socket",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n@Slf4j\npublic final class SnapshotService {\n\n    private final int port;\n    private ServerSocket serverSocket;\n    private volatile boolean closed;\n\n    public SnapshotService(final int port) {\n        Preconditions.checkArgument(port >= 0 && port <= 0xFFFF, \"Port value out of range: \" + port);\n        this.port = port;\n    }\n\n    public void listen() {\n        try {\n            log.info(\"ElasticJob: Snapshot service is running on port '{}'\", openSocket(port));\n        } catch (final IOException ex) {\n            log.error(\"ElasticJob: Snapshot service listen failure, error is: \", ex);\n        }\n    }\n\n    private int openSocket(final int port) throws IOException {\n        closed = false;\n        serverSocket = new ServerSocket(port);\n        int localPort = serverSocket.getLocalPort();\n        String threadName = String.format(\"elasticjob-snapshot-service-%d\", localPort);\n        new Thread(() -> {\n            while (!closed) {\n                try {\n                    process(serverSocket.accept());\n                } catch (final IOException ex) {\n                    if (isIgnoredException()) {\n                        return;\n                    }\n                    log.error(\"ElasticJob: Snapshot service open socket failure, error is: \", ex);\n                }\n            }\n        }, threadName).start();\n        return localPort;\n    }\n\n    private boolean isIgnoredException() {\n        return serverSocket.isClosed();\n    }\n\n    private void process(final Socket socket) throws IOException {\n        try (\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n                Socket ignored = socket) {\n            String cmdLine = reader.readLine();\n            if (null != cmdLine) {\n                outputMessage(writer, \"Processed: \" + cmdLine);\n            }\n        }\n    }\n\n    private void outputMessage(final BufferedWriter outputWriter, final String msg) throws IOException {\n        outputWriter.append(msg);\n        outputWriter.flush();\n    }\n\n    public void close() {\n        closed = true;\n        if (null != serverSocket && !serverSocket.isClosed()) {\n            try {\n                serverSocket.close();\n            } catch (final IOException ex) {\n                log.error(\"ElasticJob: Snapshot service close failure, error is: \", ex);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class SnapshotService implements Runnable {\n    private int port;\n    private ServerSocket serverSocket;\n    private boolean closed;\n    private ExecutorService executorService;\n\n    public SnapshotService(int port) {\n        this.port = port;\n        this.closed = false;\n        this.executorService = Executors.newCachedThreadPool();\n    }\n\n    public void listen() {\n        try {\n            openSocket(this.port);\n            while (!closed && !serverSocket.isClosed()) {\n                Socket socket = serverSocket.accept();\n                if (closed) {\n                    break;\n                }\n                executorService.submit(() -> process(socket));\n            }\n        } catch (IOException e) {\n            if (!isIgnoredException()) {\n                e.printStackTrace();\n            }\n        } finally {\n            close();\n        }\n    }\n\n    private int openSocket(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n        int actualPort = serverSocket.getLocalPort();\n        return actualPort;\n    }\n\n    private boolean isIgnoredException() {\n        return closed || (serverSocket != null && serverSocket.isClosed());\n    }\n\n    private void process(Socket socket) {\n        try (\n            BufferedReader inputReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            BufferedWriter outputWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))\n        ) {\n            String line;\n            while ((line = inputReader.readLine()) != null) {\n                String response = \"Processed: \" + line;\n                outputMessage(outputWriter, response);\n            }\n        } catch (IOException e) {\n            if (!isIgnoredException()) {\n                e.printStackTrace();\n            }\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void outputMessage(BufferedWriter outputWriter, String msg) throws IOException {\n        outputWriter.write(msg);\n        outputWriter.newLine();\n        outputWriter.flush();\n    }\n\n    public void close() {\n        closed = true;\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        executorService.shutdownNow();\n    }\n\n    @Override\n    public void run() {\n        listen();\n    }\n}"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and responses, including POST operations, with support for proxies, timeouts, and error handling.\n\nClass Description: JavaHttpUtility is a helper class designed to simplify HTTP communication in Java applications. It provides methods for making POST requests, handling responses, and managing errors. The class supports proxy configuration, connection timeouts, and compressed responses (gzip).\n\nAttributes:\nCONNECT_TIMEOUT: [int] - Connection timeout in milliseconds (default: 10000)\nREAD_TIMEOUT: [int] - Read timeout in milliseconds (default: 10000)\n\nMethods:\ngetProxy: () -> [Proxy] - Retrieves system proxy settings if configured\ndoPost: (String urlAddress, Map<String, String> param) -> [String] - Executes a POST request to the specified URL with given parameters\nhandleResponse: (HttpURLConnection httpURLConnection) -> [String] - Processes the HTTP response and handles errors\nreadResult: (HttpURLConnection urlConnection) -> [String] - Reads and returns the successful response body\nhandleError: (HttpURLConnection urlConnection) -> [String] - Processes and throws appropriate exceptions for error responses",
    "Canonical_solution": "import org.json.JSONException;\nimport org.json.JSONObject;\nimport org.qii.weiciyuan.support.debug.AppLogger;\nimport org.qii.weiciyuan.support.error.ErrorCode;\nimport org.qii.weiciyuan.support.error.WeiboException;\nimport org.qii.weiciyuan.support.utils.Utility;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.InterruptedIOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class JavaHttpUtility {\n\n    private static final int CONNECT_TIMEOUT = 10 * 1000;\n    private static final int READ_TIMEOUT = 10 * 1000;\n\n    private static Proxy getProxy() {\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if (!TextUtils.isEmpty(proxyHost) && !TextUtils.isEmpty(proxyPort)) {\n            return new Proxy(java.net.Proxy.Type.HTTP,\n                    new InetSocketAddress(proxyHost, Integer.valueOf(proxyPort)));\n        } else {\n            return null;\n        }\n    }\n\n    public String doPost(String urlAddress, Map<String, String> param) throws WeiboException {\n        try {\n            URL url = new URL(urlAddress);\n            Proxy proxy = getProxy();\n            HttpsURLConnection uRLConnection;\n            if (proxy != null) {\n                uRLConnection = (HttpsURLConnection) url.openConnection(proxy);\n            } else {\n                uRLConnection = (HttpsURLConnection) url.openConnection();\n            }\n\n            uRLConnection.setDoInput(true);\n            uRLConnection.setDoOutput(true);\n            uRLConnection.setRequestMethod(\"POST\");\n            uRLConnection.setUseCaches(false);\n            uRLConnection.setConnectTimeout(CONNECT_TIMEOUT);\n            uRLConnection.setReadTimeout(READ_TIMEOUT);\n            uRLConnection.setInstanceFollowRedirects(false);\n            uRLConnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            uRLConnection.setRequestProperty(\"Charset\", \"UTF-8\");\n            uRLConnection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");\n            uRLConnection.connect();\n\n            DataOutputStream out = new DataOutputStream(uRLConnection.getOutputStream());\n            out.write(Utility.encodeUrl(param).getBytes());\n            out.flush();\n            out.close();\n            return handleResponse(uRLConnection);\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        }\n    }\n\n    private String handleResponse(HttpURLConnection httpURLConnection) throws WeiboException {\n        int status = 0;\n        try {\n            status = httpURLConnection.getResponseCode();\n        } catch (IOException e) {\n            httpURLConnection.disconnect();\n            throw new WeiboException(\"Timeout\", e);\n        }\n\n        if (status != HttpURLConnection.HTTP_OK) {\n            return handleError(httpURLConnection);\n        }\n\n        return readResult(httpURLConnection);\n    }\n\n    private String readResult(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getInputStream();\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            return strBuilder.toString();\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n\n    private String handleError(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getErrorStream();\n            if (is == null) {\n                throw new WeiboException(\"Unknown network error\");\n            }\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            AppLogger.d(\"error result=\" + strBuilder.toString());\n            \n            JSONObject json = new JSONObject(strBuilder.toString());\n            String err = json.optString(\"error_description\", \"\");\n            if (TextUtils.isEmpty(err)) {\n                err = json.getString(\"error\");\n            }\n            int errCode = json.getInt(\"error_code\");\n            WeiboException exception = new WeiboException();\n            exception.setError_code(errCode);\n            exception.setOriError(err);\n\n            if (errCode == ErrorCode.EXPIRED_TOKEN || errCode == ErrorCode.INVALID_TOKEN) {\n                Utility.showExpiredTokenDialogOrNotification();\n            }\n\n            throw exception;\n        } catch (IOException | JSONException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.zip.*;\n\npublic class JavaHttpUtility {\n    private static final int CONNECT_TIMEOUT = 10000;\n    private static final int READ_TIMEOUT = 10000;\n\n    private Proxy getProxy() {\n        String host = System.getProperty(\"http.proxyHost\");\n        String portStr = System.getProperty(\"http.proxyPort\");\n        if (host != null && !host.isEmpty() && portStr != null && !portStr.isEmpty()) {\n            try {\n                int port = Integer.parseInt(portStr);\n                return new Proxy(Proxy.Type.HTTP, new InetSocketAddress(host, port));\n            } catch (NumberFormatException e) {\n                return Proxy.NO_PROXY;\n            }\n        }\n        return Proxy.NO_PROXY;\n    }\n\n    public String doPost(String urlAddress, Map<String, String> param) throws IOException {\n        URL url = new URL(urlAddress);\n        Proxy proxy = getProxy();\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(proxy);\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setConnectTimeout(CONNECT_TIMEOUT);\n        urlConnection.setReadTimeout(READ_TIMEOUT);\n        urlConnection.setDoOutput(true);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        urlConnection.setRequestProperty(\"Accept-Encoding\", \"gzip\");\n\n        StringBuilder postData = new StringBuilder();\n        for (Map.Entry<String, String> entry : param.entrySet()) {\n            if (postData.length() != 0) postData.append('&');\n            postData.append(URLEncoder.encode(entry.getKey(), \"UTF-8\"));\n            postData.append('=');\n            postData.append(URLEncoder.encode(entry.getValue(), \"UTF-8\"));\n        }\n\n        try (OutputStream os = urlConnection.getOutputStream();\n             BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"))) {\n            writer.write(postData.toString());\n        }\n\n        return handleResponse(urlConnection);\n    }\n\n    private String handleResponse(HttpURLConnection httpURLConnection) throws IOException {\n        int responseCode = httpURLConnection.getResponseCode();\n        if (responseCode >= 400) {\n            return handleError(httpURLConnection);\n        }\n        return readResult(httpURLConnection);\n    }\n\n    private String readResult(HttpURLConnection urlConnection) throws IOException {\n        InputStream inputStream = urlConnection.getInputStream();\n        if (\"gzip\".equals(urlConnection.getContentEncoding())) {\n            inputStream = new GZIPInputStream(inputStream);\n        }\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n        return response.toString();\n    }\n\n    private String handleError(HttpURLConnection urlConnection) throws IOException {\n        int responseCode = urlConnection.getResponseCode();\n        String error = \"HTTP error code: \" + responseCode + \", Message: \" + urlConnection.getResponseMessage();\n\n        try (InputStream errorStream = urlConnection.getErrorStream()) {\n            if (errorStream != null) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(errorStream));\n                StringBuilder errorMessage = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    errorMessage.append(line);\n                }\n                error += \", Details: \" + errorMessage.toString();\n            }\n        }\n        throw new IOException(error);\n    }\n}"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Implement a utility class for handling media uploads to the WeChat API, including processing file types and managing HTTP connections for file transfer.\n\nClass Description: WechatMediaUtil is a Spring component that provides functionality to upload media files to WeChat's servers through their API. It handles authentication, file type validation, and multipart form data submission.\n\nAttributes:\n- wechatAccessTokenUtil: [WechatAccessTokenUtil] - Autowired dependency for managing WeChat access tokens\n- MEDIA_URL: [String] - Constant URL template for WeChat media upload API (contains ACCESS_TOKEN and TYPE placeholders)\n\nMethods:\n- uploadMedia: [uploadMedia](String type, String mediaFileUrl) -> String - Uploads a media file to WeChat servers. Takes media type and file URL as input, returns WeChat media ID. Handles token refresh on expiration and error cases.\n- judgeType: [judgeType](String contentType) -> String - Determines file extension from content type. Throws exception for unsupported types. Used internally by uploadMedia.\n\nInput for uploadMedia:\n- type: [String] - Media type (e.g., \"image\")\n- mediaFileUrl: [String] - URL of the media file to upload\n\nOutput for uploadMedia:\n- [String] - WeChat media ID of the uploaded file\n\nInput for judgeType:\n- contentType: [String] - MIME type of the file\n\nOutput for judgeType:\n- [String] - Corresponding file extension (e.g., \".jpg\")",
    "Canonical_solution": "import cn.hutool.json.JSONObject;\nimport cn.lili.common.enums.ClientTypeEnum;\nimport cn.lili.common.enums.ResultCode;\nimport cn.lili.common.exception.ServiceException;\nimport cn.lili.modules.wechat.util.WechatAccessTokenUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\n@Component\npublic class WechatMediaUtil {\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.cgiAccessToken(ClientTypeEnum.WECHAT_MP);\n        String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n        StringBuffer resultStr = null;\n        String mediaStr = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n        URL mediaUrl;\n        try {\n            String boundary = \"----WebKitFormBoundaryOYXo8heIv9pgpGjT\";\n            URL url = new URL(mediaStr);\n            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setDoInput(true);\n            urlConn.setDoOutput(true);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            urlConn.setRequestMethod(\"POST\");\n            OutputStream out = urlConn.getOutputStream();\n\n            mediaUrl = new URL(mediaFileUrl);\n            HttpURLConnection mediaConn = (HttpURLConnection) mediaUrl.openConnection();\n            mediaConn.setRequestMethod(\"GET\");\n            mediaConn.setDoInput(true);\n            String contentType = mediaConn.getHeaderField(\"Content-Type\");\n            String fileExt = judgeType(contentType);\n            InputStream in = mediaConn.getInputStream();\n            BufferedInputStream bufferedIn = new BufferedInputStream(in);\n            byte[] bytes = new byte[1024];\n            int size = 0;\n            out.write((\"--\" + boundary + \"\\r\\n\").getBytes());\n            out.write((\"Content-Disposition: form-data; name=\\\"media\\\";\\r\\n\"\n                    + \"filename=\\\"\" + (System.currentTimeMillis()) + fileExt + \"\\\"\\r\\n\"\n                    + \"Content-Type: \" + contentType + \"\\r\\n\\r\\n\").getBytes());\n            while ((size = bufferedIn.read(bytes)) != -1) {\n                out.write(bytes, 0, size);\n            }\n            out.write((\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes());\n\n            bufferedIn.close();\n            in.close();\n            mediaConn.disconnect();\n\n            InputStream resultIn = urlConn.getInputStream();\n            InputStreamReader reader = new InputStreamReader(resultIn);\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String tempStr = null;\n            resultStr = new StringBuffer();\n            while ((tempStr = bufferedReader.readLine()) != null) {\n                resultStr.append(tempStr);\n            }\n            bufferedReader.close();\n            reader.close();\n            resultIn.close();\n            urlConn.disconnect();\n        } catch (Exception e) {\n            log.error(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20\u5931\u8d25\", e);\n        }\n        assert resultStr != null;\n        JSONObject jsonObject = new JSONObject(resultStr.toString());\n        log.info(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20:\" + jsonObject);\n        if (jsonObject.get(\"errcode\") != null && (\"40001\").equals(jsonObject.get(\"errcode\"))) {\n            wechatAccessTokenUtil.removeAccessToken(ClientTypeEnum.WECHAT_MP);\n            return this.uploadMedia(type, mediaFileUrl);\n        } else if (jsonObject.get(\"errcode\") != null) {\n            throw new ServiceException(jsonObject.get(\"errmsg\").toString());\n        } else {\n            return jsonObject.get(\"media_id\").toString();\n        }\n    }\n\n    public String judgeType(String contentType) {\n        String fileExt = \"\";\n        switch (contentType) {\n            case \"image/png\":\n                fileExt = \".png\";\n                break;\n            case \"image/jpeg\":\n                fileExt = \".jpeg\";\n                break;\n            case \"image/jpg\":\n                fileExt = \".jpg\";\n                break;\n            default:\n                throw new ServiceException(ResultCode.IMAGE_FILE_EXT_ERROR);\n        }\n        return fileExt;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.client.RestTemplate;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Component\npublic class WechatMediaUtil {\n\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    private static final String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.getAccessToken();\n        String url = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n\n        try {\n            File file = downloadFileFromUrl(mediaFileUrl);\n            String extension = judgeType(getContentType(file));\n            \n            // Create multipart request and send to WeChat API\n            // Simplified example using RestTemplate\n            RestTemplate restTemplate = new RestTemplate();\n            Map<String, Object> body = new HashMap<>();\n            body.put(\"media\", file);\n            \n            Map<String, String> response = restTemplate.postForObject(url, body, Map.class);\n            \n            if (response != null && response.containsKey(\"media_id\")) {\n                return response.get(\"media_id\");\n            } else {\n                // Handle error, possibly token expiration\n                if (\"40001\".equals(response.get(\"errcode\"))) { // Token expired error code\n                    accessToken = wechatAccessTokenUtil.refreshToken();\n                    url = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n                    response = restTemplate.postForObject(url, body, Map.class);\n                    if (response != null && response.containsKey(\"media_id\")) {\n                        return response.get(\"media_id\");\n                    }\n                }\n                throw new RuntimeException(\"Failed to upload media: \" + response);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error uploading media\", e);\n        }\n    }\n\n    private String getContentType(File file) throws IOException {\n        BufferedImage image = ImageIO.read(file);\n        if (image != null) {\n            return \"image/\" + getFileExtension(file.getName()).substring(1);\n        }\n        return \"application/octet-stream\";\n    }\n\n    private String getFileExtension(String fileName) {\n        int dotIndex = fileName.lastIndexOf(\".\");\n        return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex);\n    }\n\n    private File downloadFileFromUrl(String fileUrl) throws IOException {\n        URL url = new URL(fileUrl);\n        InputStream in = url.openStream();\n        File tempFile = File.createTempFile(\"wechat-media-\", \".tmp\");\n        OutputStream out = new FileOutputStream(tempFile);\n\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);\n        }\n\n        out.close();\n        in.close();\n\n        return tempFile;\n    }\n\n    private String judgeType(String contentType) {\n        switch (contentType.toLowerCase()) {\n            case \"image/jpeg\":\n                return \".jpg\";\n            case \"image/png\":\n                return \".png\";\n            case \"image/gif\":\n                return \".gif\";\n            case \"audio/mpeg\":\n                return \".mp3\";\n            case \"audio/amr\":\n                return \".amr\";\n            case \"video/mp4\":\n                return \".mp4\";\n            default:\n                throw new IllegalArgumentException(\"Unsupported content type: \" + contentType);\n        }\n    }\n}"
  },
  {
    "Task_id": 560,
    "Instruction": "Task Description: Create a Java class that implements a secure socket client using SSL/TLS to communicate with a server. The client should be able to send HTTP requests and read responses.\n\nClass Description: The SocketClient class establishes a secure connection to a server using SSL/TLS, sends an HTTP GET request, and reads the response. It handles socket creation, SSL handshake, request sending, and response parsing.\n\nAttributes:\n- clientSslContext: [SSLContext] - The SSL context used for creating secure sockets\n- address: [InetSocketAddress] - The server address (host and port) to connect to\n\nMethods:\n- Constructor: [SocketClient]([SSLContext clientSslContext, InetSocketAddress address]) -> [void] - Initializes the client with SSL context and server address\n- doRequest: [doRequest]() -> [void] - Establishes connection, sends HTTP request, reads response, and closes connection (throws IOException)\n- readLine: [readLine]([InputStream is]) -> [String] - Helper method to read a line from input stream (throws IOException)\n- readResponse: [readResponse]([SSLSocket sslSocket]) -> [void] - Reads and processes the HTTP response headers and body (throws IOException)",
    "Canonical_solution": "import io.undertow.Undertow;\nimport io.undertow.util.Headers;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\npublic class SocketClient {\n\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        Socket rawSocket = new Socket();\n        rawSocket.connect(address);\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory()\n            .createSocket(rawSocket, \"localhost\", address.getPort(), false);\n        PrintWriter writer = new PrintWriter(sslSocket.getOutputStream());\n        writer.println(\"GET / HTTP/1.1\");\n        writer.println(\"Host: localhost\");\n        writer.println(\"Connection: keep-alive\");\n        writer.println();\n        writer.flush();\n        readResponse(sslSocket);\n\n        sslSocket.shutdownOutput();\n        rawSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder line = new StringBuilder();\n        while (true) {\n            int c = is.read();\n            switch (c) {\n                case -1:\n                    throw new RuntimeException(\"Unexpected EOF\");\n                case '\\r':\n                    continue;\n                case '\\n':\n                    return line.toString();\n                default:\n                    line.append((char) c);\n            }\n        }\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        String line;\n        int contentLength = 0;\n        Pattern CONTENT_LENGTH_PATTERN = Pattern.compile(\"Content-Length: ([0-9]+)\", Pattern.CASE_INSENSITIVE);\n\n        do {\n            line = readLine(sslSocket.getInputStream());\n            Matcher matcher = CONTENT_LENGTH_PATTERN.matcher(line);\n            if (matcher.matches()) {\n                contentLength = Integer.parseInt(matcher.group(1), 10);\n            }\n        } while (!line.isEmpty());\n\n        for (int i = 0; i < contentLength; i++) {\n            sslSocket.getInputStream().read();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.*;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\n\npublic class SocketClient {\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        SSLSocket sslSocket = null;\n        try {\n            SSLSocketFactory socketFactory = clientSslContext.getSocketFactory();\n            sslSocket = (SSLSocket) socketFactory.createSocket(address.getAddress(), address.getPort());\n            sslSocket.startHandshake();\n\n            OutputStream out = sslSocket.getOutputStream();\n            String request = \"GET / HTTP/1.1\\r\\n\" +\n                             \"Host: \" + address.getHostString() + \"\\r\\n\" +\n                             \"Connection: close\\r\\n\\r\\n\";\n            out.write(request.getBytes());\n            out.flush();\n\n            readResponse(sslSocket);\n        } finally {\n            if (sslSocket != null) {\n                sslSocket.close();\n            }\n        }\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = is.read()) != -1) {\n            sb.append((char) c);\n            if (c == '\\n') {\n                break;\n            }\n        }\n        return sb.toString().trim();\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        InputStream in = sslSocket.getInputStream();\n        String line;\n        boolean headerDone = false;\n        int contentLength = 0;\n        boolean chunked = false;\n\n        while ((line = readLine(in)) != null && !line.isEmpty()) {\n            System.out.println(\"Header: \" + line);\n            if (line.toLowerCase().startsWith(\"content-length:\")) {\n                contentLength = Integer.parseInt(line.split(\":\")[1].trim());\n            } else if (line.toLowerCase().startsWith(\"transfer-encoding:\") && line.toLowerCase().contains(\"chunked\")) {\n                chunked = true;\n            }\n        }\n\n        if (chunked) {\n            readChunkedBody(in);\n        } else if (contentLength > 0) {\n            readFixedLengthBody(in, contentLength);\n        } else {\n            int c;\n            while ((c = in.read()) != -1) {\n                System.out.print((char) c);\n            }\n        }\n    }\n\n    private void readChunkedBody(InputStream in) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line;\n        while (!(line = reader.readLine()).equals(\"0\")) {\n            int length = Integer.parseInt(line.trim(), 16);\n            char[] data = new char[length];\n            reader.read(data, 0, length);\n            System.out.print(new String(data, 0, length));\n            reader.readLine(); // consume trailing \\r\\n\n        }\n    }\n\n    private void readFixedLengthBody(InputStream in, int length) throws IOException {\n        byte[] body = new byte[length];\n        int bytesRead = 0;\n        int result;\n        while (bytesRead < length && (result = in.read(body, bytesRead, body.length - bytesRead)) != -1) {\n            bytesRead += result;\n        }\n        System.out.println(new String(body));\n    }\n}"
  },
  {
    "Task_id": 561,
    "Instruction": "Task Description: Create a Java class that implements a TCP socket client capable of connecting to servers directly or through HTTP proxies, with support for SSL/TLS connections.\n\nClass Description: RouterSocketClient is a networking class that handles socket connections to remote servers, supporting both direct connections and HTTP proxy connections. It includes SSL/TLS capabilities and handles various connection scenarios with appropriate timeouts.\n\nAttributes:\n- TAG: [String] - Class tag for logging purposes\n- SERVER_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for server connections (20 seconds)\n- HTTP_PROXY_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for HTTP proxy connections (5 seconds)\n- TLS_HANDSHAKE_TIMEOUT_MILLIS: [int] - Timeout for TLS handshake (20 seconds)\n- mLock: [Object] - Synchronization lock object\n- mConnectivityManager: [ConnectivityManager] - Android network connectivity manager\n- mSSLSocketFactory: [SSLSocketFactory] - SSL socket factory for secure connections\n- mContext: [Context] - Android application context\n- mDelayedRestartHandler: [Handler] - Handler for delayed operations\n- mSocket: [Socket] - Current active socket connection\n- mThread: [Thread] - Thread handling socket operations\n\nMethods:\n- RouterSocketClient(Context, ConnectivityManager, Random) -> [Constructor] - Initializes the client with context, connectivity manager, and random number generator\n- connectSocket(String host, int port) -> [Socket] - Static method that establishes a socket connection to the specified host:port, handling both direct and proxy connections\n- connectSocketNoProxy(String host, int port) -> [Socket] - Static helper method for direct socket connections without proxy\n- connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) -> [Socket] - Static helper method for establishing connections through HTTP proxies using CONNECT method\n- tryEnableSni(SSLSocket socket, String hostname) -> [void] - Attempts to enable Server Name Indication (SNI) on the SSL socket\n- tryEnableSessionTickets(SSLSocket socket) -> [void] - Attempts to enable session tickets on the SSL socket",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.security.cert.X509Certificate;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n\n    private static final String TAG = RouterSocketClient.class.getSimpleName();\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(\n            Context context,\n            ConnectivityManager connectivityManager,\n            Random rng) {\n        mContext = context;\n        mDelayedRestartHandler = new Handler(mContext.getMainLooper());\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    private static Socket connectSocket(String host, int port) throws IOException {\n        URI serverUri = URI.create(\"https://\" + host + \":\" + port);\n        ProxySelector proxySelector = ProxySelector.getDefault();\n        List<Proxy> proxies = proxySelector.select(serverUri);\n        if ((proxies == null) || (proxies.isEmpty())) {\n            proxies = Collections.singletonList(Proxy.NO_PROXY);\n        }\n\n        IOException lastFailure = null;\n        for (Proxy proxy : proxies) {\n            SocketAddress proxyAddress = proxy.address();\n            try {\n                if (Proxy.NO_PROXY.equals(proxy)) {\n                    return connectSocketNoProxy(host, port);\n                } else if (proxy.type() == Proxy.Type.HTTP) {\n                    return connectSocketViaHttpProxyConnectMethod(host, port, proxyAddress);\n                }\n            } catch (IOException e) {\n                lastFailure = e;\n                if (proxyAddress != null) {\n                    proxySelector.connectFailed(serverUri, proxyAddress, e);\n                }\n            }\n        }\n\n        if (lastFailure != null) {\n            throw lastFailure;\n        }\n        throw new IOException(\"No suitable connection methods found for \" + serverUri + \": \" + proxies);\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" directly\");\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            SocketAddress address = new InetSocketAddress(host, port);\n            socket = new Socket();\n            socket.connect(address, SERVER_CONNECT_TIMEOUT_MILLIS);\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(\n            String host, int port, SocketAddress proxyAddress) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" via HTTP proxy \" + proxyAddress);\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            InetSocketAddress proxyInetAddress = (InetSocketAddress) proxyAddress;\n            if (proxyInetAddress.isUnresolved()) {\n                proxyInetAddress = new InetSocketAddress(\n                        proxyInetAddress.getHostName(),\n                        proxyInetAddress.getPort());\n            }\n            socket = new Socket();\n            socket.connect(proxyInetAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\n                    socket.getOutputStream(), \"US-ASCII\"));\n            out.write(\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\");\n            out.write(\"Host: \" + host + \":\" + port + \"\\r\\n\");\n            out.write(\"\\r\\n\");\n            out.flush();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream(), \"US-ASCII\"));\n            String line;\n            boolean statusLineRead = false;\n            boolean responseHeadersRead = false;\n            socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n            while ((line = in.readLine()) != null) {\n                if (!statusLineRead) {\n                    String[] tokens = line.split(\"\\\\s+\", 3);\n                    if (tokens.length != 3) {\n                        throw new IOException(\"Unexpected reply from HTTP proxy: \" + line);\n                    }\n                    String httpVersion = tokens[0];\n                    String statusCodeString = tokens[1];\n                    String reason = tokens[2];\n                    if (!httpVersion.startsWith(\"HTTP/1.\")) {\n                        throw new IOException(\"Unsupported HTTP version in HTTP proxy response: \" + line);\n                    }\n                    if (!\"200\".equals(statusCodeString)) {\n                        throw new IOException(\n                                \"HTTP proxy CONNECT failed. Status: \" + statusCodeString + \", reason: \" + reason);\n                    }\n                    statusLineRead = true;\n                    continue;\n                }\n                if (line.length() == 0) {\n                    responseHeadersRead = true;\n                    break;\n                }\n            }\n\n            if (!statusLineRead) {\n                throw new EOFException(\"Empty response from HTTP proxy\");\n            }\n            if (!responseHeadersRead) {\n                throw new EOFException(\"Premature end of stream while reading HTTP proxy response\");\n            }\n\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static void tryEnableSni(SSLSocket socket, String hostname) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setHostname\", String.class).invoke(socket, hostname);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable SNI via Reflection API\", e);\n        }\n    }\n\n    private static void tryEnableSessionTickets(SSLSocket socket) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setUseSessionTickets\", boolean.class).invoke(socket, true);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable session tickets via Reflection API\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.os.Handler;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n\n    private static final String TAG = \"RouterSocketClient\";\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(Context context, ConnectivityManager connectivityManager, Random unused) {\n        mContext = context.getApplicationContext();\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        mDelayedRestartHandler = new Handler();\n    }\n\n    public static Socket connectSocket(String host, int port) throws IOException {\n        if (useHttpProxy()) {\n            SocketAddress proxyAddress = getHttpProxyAddress();\n            return connectSocketViaHttpProxyConnectMethod(host, port, proxyAddress);\n        } else {\n            return connectSocketNoProxy(host, port);\n        }\n    }\n\n    public static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        try {\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(host, port), SERVER_CONNECT_TIMEOUT_MILLIS);\n            return socket;\n        } catch (UnknownHostException e) {\n            throw new IOException(\"Unknown host: \" + host, e);\n        }\n    }\n\n    public static Socket connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) throws IOException {\n        try {\n            Socket proxySocket = new Socket();\n            proxySocket.connect(proxyAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n\n            return proxySocket;\n        } catch (IOException e) {\n            throw new IOException(\"Failed to connect via HTTP proxy\", e);\n        }\n    }\n\n    private void tryEnableSni(SSLSocket socket, String hostname) {\n        try {\n            SSLParameters sslParams = socket.getSSLParameters();\n            Class<?> cls = Class.forName(\"javax.net.ssl.SSLParameters\");\n            Method setServerNames = cls.getMethod(\"setServerNames\", java.util.List.class);\n            Class<?> sniClass = Class.forName(\"javax.net.ssl.SNIServerName\");\n            Class<?> builderClass = Class.forName(\"javax.net.ssl.SNIHostName$Builder\");\n            Object builderInstance = builderClass.getConstructor(int.class).newInstance(0);\n            Method builderBuild = builderClass.getMethod(\"build\");\n            Object sniInstance = builderBuild.invoke(builderInstance);\n            java.util.List<Object> serverNamesList = new java.util.ArrayList<>();\n            serverNamesList.add(sniInstance);\n            setServerNames.invoke(sslParams, serverNamesList);\n            socket.setSSLParameters(sslParams);\n        } catch (Exception ignored) {\n        }\n    }\n\n    private void tryEnableSessionTickets(SSLSocket socket) {\n        try {\n            Method method = socket.getClass().getMethod(\"setUseSessionTickets\", boolean.class);\n            method.invoke(socket, true);\n        } catch (Exception ignored) {\n        }\n    }\n}"
  },
  {
    "Task_id": 562,
    "Instruction": "Task Description: Implement a Java class that handles sending emails with attachments via SMTP protocol using socket programming.\n\nClass Description: The SendMailJob class provides functionality to connect to an SMTP server, compose and send emails with attachments, and properly handle the email sending process including connection management and error handling.\n\nAttributes:\n- socket: [Socket] - The socket connection to the SMTP server\n- in: [BufferedReader] - Input stream for reading server responses\n- out: [OutputStream] - Output stream for sending commands to the server\n- out64: [Base64OutputStream] - Base64 encoded output stream for sending attachments\n- connectedToMailServer: [boolean] - Flag indicating connection status\n- mailServer: [String] - SMTP server address\n- fromAddress: [String] - Sender's email address\n- boundary: [String] - MIME boundary for multipart messages\n- recipientString: [String] - Comma-separated recipient addresses\n- mailSubject: [String] - Email subject line\n- mailBody: [String] - Email body content\n- errorDialogTitle: [String] - Title for error dialogs\n\nMethods:\n- SendMailJob([ProgressDialog, MainFrame, FileSet, String, String, String]) -> [void] - Constructor that initializes email parameters and configurations\n- openConnection() -> [void] - Establishes connection with SMTP server and initializes streams\n- sendBody() -> [void] - Sends email headers and body content to the server\n- sendAttachment([AbstractFile]) -> [void] - Encodes and sends file attachments to the server\n- closeConnection() -> [void] - Closes all connections and releases resources\n- readWriteLine([String]) -> [void] - Sends a command to server and reads response\n- writeLine([String]) -> [void] - Writes a line to the output stream\n- splitRecipientString([String, List<String>]) -> [String] - Parses recipient string into individual addresses",
    "Canonical_solution": "import com.mucommander.commons.file.AbstractFile;\nimport com.mucommander.commons.io.StreamUtils;\nimport com.mucommander.commons.io.base64.Base64OutputStream;\nimport com.mucommander.conf.MuConfigurations;\nimport com.mucommander.conf.MuPreference;\nimport com.mucommander.conf.MuPreferences;\nimport com.mucommander.job.FileJobState;\nimport com.mucommander.text.Translator;\nimport com.mucommander.ui.dialog.DialogAction;\nimport com.mucommander.ui.dialog.file.ProgressDialog;\nimport com.mucommander.ui.main.MainFrame;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\npublic class SendMailJob {\n\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet filesToSend, String recipientString, String mailSubject, String mailBody) {\n        this.boundary = \"mucommander\" + System.currentTimeMillis();\n        this.recipientString = recipientString;\n        this.mailSubject = mailSubject;\n        this.mailBody = mailBody + \"\\n\\n\" + \"Sent by muCommander - http://www.mucommander.com\\n\";\n        this.mailServer = MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_SERVER);\n        this.fromAddress = MuConfigurations.getPreferences().getVariable(MuPreference.MAIL_SENDER_ADDRESS);\n        this.errorDialogTitle = Translator.get(\"email_dialog.error_title\");\n    }\n\n    private void openConnection() throws IOException {\n        this.socket = new Socket(mailServer, MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_PORT, MuPreferences.DEFAULT_SMTP_PORT));\n        this.in = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\"));\n        this.out = socket.getOutputStream();\n        this.out64 = new Base64OutputStream(out, true);\n        this.connectedToMailServer = true;\n    }\n\n    private void sendBody() throws IOException {\n        readWriteLine(\"HELO muCommander\");\n        readWriteLine(\"MAIL FROM: \" + fromAddress);\n\n        List<String> recipients = new Vector<String>();\n        recipientString = splitRecipientString(recipientString, recipients);\n        int nbRecipients = recipients.size();\n        for (int i = 0; i < nbRecipients; i++)\n            readWriteLine(\"RCPT TO: <\" + recipients.get(i) + \">\");\n        readWriteLine(\"DATA\");\n        writeLine(\"MIME-Version: 1.0\");\n        writeLine(\"Subject: \" + this.mailSubject);\n        writeLine(\"From: \" + this.fromName + \" <\" + this.fromAddress + \">\");\n        writeLine(\"To: \" + recipientString);\n        writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n        writeLine(\"\\r\\n--\" + boundary);\n        writeLine(\"Content-Type: text/plain; charset=\\\"utf-8\\\"\\r\\n\");\n        writeLine(this.mailBody + \"\\r\\n\\r\\n\");\n        writeLine(\"\\r\\n--\" + boundary);\n    }\n\n    private void sendAttachment(AbstractFile file) throws IOException {\n        InputStream fileIn = null;\n        try {\n            String mimeType = MimeTypes.getMimeType(file);\n            if (mimeType == null)\n                mimeType = \"application/octet-stream\";\n            writeLine(\"Content-Type:\" + mimeType + \"; name=\" + file.getName());\n            writeLine(\"Content-Disposition: attachment;filename=\\\"\" + file.getName() + \"\\\"\");\n            writeLine(\"Content-transfer-encoding: base64\\r\\n\");\n            fileIn = setCurrentInputStream(file.getInputStream());\n            StreamUtils.copyStream(fileIn, out64);\n            out64.writePadding();\n            writeLine(\"\\r\\n--\" + boundary);\n        } finally {\n            if (fileIn != null)\n                fileIn.close();\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            socket.close();\n            in.close();\n            out64.close();\n        } catch (Exception e) {\n        }\n    }\n\n    private void readWriteLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n        in.readLine();\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n    }\n\n    private String splitRecipientString(String recipientsStr, List<String> recipients) {\n        StringBuilder newRecipientsSb = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(recipientsStr, \",;\");\n        String rec;\n        int pos1, pos2;\n        while (st.hasMoreTokens()) {\n            rec = st.nextToken().trim();\n            if ((pos1 = rec.indexOf('<')) != -1 && (pos2 = rec.indexOf('>', pos1 + 1)) != -1)\n                recipients.add(rec.substring(pos1 + 1, pos2));\n            else\n                recipients.add(rec);\n\n            newRecipientsSb.append(rec);\n            if (st.hasMoreTokens())\n                newRecipientsSb.append(\", \");\n        }\n        return newRecipientsSb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport javax.swing.*;\n\npublic class SendMailJob {\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer = false;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary = \"=====0123456789=====\";\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle = \"Error Sending Email\";\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet fileSet, String s, String s1, String s2) {\n        // Constructor implementation placeholder\n    }\n\n    public void openConnection() throws IOException {\n        try {\n            socket = new Socket(mailServer, 25);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out = socket.getOutputStream();\n            readWriteLine(null); // Read initial server response\n            connectedToMailServer = true;\n        } catch (IOException e) {\n            showErrorDialog(\"Failed to connect to mail server.\");\n            throw e;\n        }\n    }\n\n    public void sendBody() throws IOException {\n        writeLine(\"MAIL FROM:<\" + fromAddress + \">\");\n        readWriteLine(\"RCPT TO:<\" + recipientString + \">\");\n        writeLine(\"DATA\");\n        readWriteLine(null);\n\n        writeLine(\"From: \" + fromAddress);\n        writeLine(\"To: \" + recipientString);\n        writeLine(\"Subject: \" + mailSubject);\n        writeLine(\"MIME-Version: 1.0\");\n        writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n        writeLine(\"\");\n\n        writeLine(\"--\" + boundary);\n        writeLine(\"Content-Type: text/plain\");\n        writeLine(\"\");\n        writeLine(mailBody);\n        writeLine(\"\");\n    }\n\n    public void sendAttachment(AbstractFile file) throws IOException {\n        writeLine(\"--\" + boundary);\n        writeLine(\"Content-Type: application/octet-stream\");\n        writeLine(\"Content-Transfer-Encoding: base64\");\n        writeLine(\"Content-Disposition: attachment; filename=\\\"\" + file.getName() + \"\\\"\");\n        writeLine(\"\");\n\n        FileInputStream fis = new FileInputStream(file);\n        out64 = new Base64OutputStream(out);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = fis.read(buffer)) != -1) {\n            out64.write(buffer, 0, bytesRead);\n        }\n        out64.flush();\n        fis.close();\n\n        writeLine(\"\");\n    }\n\n    public void closeConnection() throws IOException {\n        if (!connectedToMailServer) return;\n\n        writeLine(\".\");\n        readWriteLine(null);\n        writeLine(\"QUIT\");\n        readWriteLine(null);\n\n        in.close();\n        out.close();\n        socket.close();\n        connectedToMailServer = false;\n    }\n\n    private void readWriteLine(String command) throws IOException {\n        if (command != null) {\n            writeLine(command);\n        }\n\n        String response = in.readLine();\n        if (response != null && !response.startsWith(\"2\") && !response.startsWith(\"3\")) {\n            showErrorDialog(\"SMTP Error: \" + response);\n        }\n    }\n\n    private void writeLine(String line) throws IOException {\n        if (line != null) {\n            out.write(line.getBytes());\n        }\n        out.write(\"\\r\\n\".getBytes());\n        out.flush();\n    }\n\n    private String splitRecipientString(String recipients, List<String> recipientList) {\n        String[] addresses = recipients.split(\",\");\n        recipientList.addAll(Arrays.asList(addresses));\n        return addresses.length > 0 ? addresses[0].trim() : \"\";\n    }\n\n    private void showErrorDialog(String message) {\n        JOptionPane.showMessageDialog(null, message, errorDialogTitle, JOptionPane.ERROR_MESSAGE);\n    }\n}"
  },
  {
    "Task_id": 563,
    "Instruction": "Task Description: Create a Java function that tests a client-server connection using Socket programming, including handling connection events and verifying successful communication.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP GET request, and verifies both connection establishment and message delivery. It uses CountDownLatch for synchronization between the main thread and callback handlers. The function fails if either the connection or message delivery doesn't complete within specified timeouts.\n\nInput: None (uses DefaultServer class for host configuration)\n\nOutput: None (throws exceptions or asserts failures for unsuccessful operations)\n\nKey Operations:\n1. Creates Socket connection to default server\n2. Sets up server event handlers with callbacks\n3. Obtains input/output streams for communication\n4. Sends HTTP GET request\n5. Verifies connection establishment within 10 seconds\n6. Verifies message delivery within 10 seconds\n7. Properly closes resources\n8. Uses synchronization primitives for thread coordination",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testConnectionFail() throws IOException, InterruptedException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch connected = new CountDownLatch(1);\n    DefaultServer.setRootHandler(new ServerSentEventHandler(new ServerSentEventConnectionCallback() {\n        @Override\n        public void connected(final ServerSentEventConnection connection, final String lastEventId) {\n            final XnioIoThread thread = (XnioIoThread) Thread.currentThread();\n            connected.countDown();\n            thread.execute(new Runnable() {\n                @Override\n                public void run() {\n                    connection.send(\"hello\", new ServerSentEventConnection.EventCallback() {\n                        @Override\n                        public void done(ServerSentEventConnection connection, String data, String event, String id) {\n                        }\n\n                        @Override\n                        public void failed(ServerSentEventConnection connection, String data, String event, String id, IOException e) {\n                            latch.countDown();\n                        }\n                    });\n                    if(latch.getCount() > 0) {\n                        WorkerUtils.executeAfter(thread, this, 100, TimeUnit.MILLISECONDS);\n                    }\n                }\n            });\n        }\n    }));\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET / HTTP/1.1\\r\\nHost:\" + DefaultServer.getHostAddress() +\"\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    if(!connected.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n    out.close();\n    in.close();\n    if(!latch.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic class ClientServerTest {\n    private static final int CONNECTION_TIMEOUT = 10000; // 10 seconds\n    private static final int MESSAGE_TIMEOUT = 10000; // 10 seconds\n\n    public void testClientServerConnection() throws Exception {\n        DefaultServer server = new DefaultServer();\n        CountDownLatch connectLatch = new CountDownLatch(1);\n        CountDownLatch messageLatch = new CountDownLatch(1);\n\n        Thread serverThread = new Thread(() -> {\n            try (ServerSocket serverSocket = new ServerSocket(server.getPort())) {\n                connectLatch.countDown(); // Signal that server is ready\n                try (Socket clientSocket = serverSocket.accept();\n                     BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                     PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n\n                    String request = in.readLine();\n                    if (request != null && request.startsWith(\"GET\")) {\n                        out.println(\"HTTP/1.1 200 OK\");\n                        messageLatch.countDown(); // Signal successful message exchange\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n\n        serverThread.start();\n\n        if (!connectLatch.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {\n            throw new AssertionError(\"Failed to establish connection within timeout\");\n        }\n\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(server.getHost(), server.getPort()), CONNECTION_TIMEOUT);\n            OutputStream outStream = socket.getOutputStream();\n            InputStream inStream = socket.getInputStream();\n\n            String getRequest = \"GET / HTTP/1.1\\r\\nHost: \" + server.getHost() + \"\\r\\n\\r\\n\";\n            outStream.write(getRequest.getBytes());\n            outStream.flush();\n\n            byte[] buffer = new byte[1024];\n            int bytesRead = inStream.read(buffer);\n            if (bytesRead <= 0 || !new String(buffer, 0, bytesRead).contains(\"200 OK\")) {\n                throw new AssertionError(\"Message delivery verification failed\");\n            }\n\n            if (!messageLatch.await(MESSAGE_TIMEOUT, TimeUnit.MILLISECONDS)) {\n                throw new AssertionError(\"Message handling timed out\");\n            }\n        } catch (IOException e) {\n            throw new AssertionError(\"Communication error during test\", e);\n        } finally {\n            serverThread.interrupt();\n        }\n    }\n\n    static class DefaultServer {\n        public String getHost() {\n            return \"localhost\";\n        }\n\n        public int getPort() {\n            return 8080;\n        }\n    }\n}"
  },
  {
    "Task_id": 566,
    "Instruction": "Task Description: Create a Java class that implements Unix domain socket communication using SocketChannel for inter-process communication on Unix-like systems.\n\nClass Description: The UnixSocket class extends AbstractSocket and provides functionality for Unix domain socket communication. It uses Java's SocketChannel for establishing connections and supports input/output stream operations.\n\nAttributes:\n- socketAddress: [SocketAddress] - The address of the Unix domain socket\n- socketChannel: [SocketChannel] - The channel used for socket communication\n\nMethods:\n- UnixSocket(String path) -> [void] - Constructor that creates a Unix domain socket connection to the specified path. Throws various exceptions if the operation fails.\n- getInputStream() -> [InputStream] - Returns an input stream for reading data from the socket. Throws SocketException if the socket is closed, not connected, or input is shutdown.\n- getOutputStream() -> [OutputStream] - Returns an output stream for writing data to the socket. Throws SocketException if the socket is closed, not connected, or output is shutdown.\n- getLocalSocketAddress() -> [SocketAddress] - Returns the local socket address.\n- getRemoteSocketAddress() -> [SocketAddress] - Returns the remote socket address (same as local for Unix domain sockets).\n- close() -> [void] - Closes the socket channel and releases resources.\n- WrappedWritableByteChannel.write(ByteBuffer src) -> [int] - Inner class method that writes data from the buffer to the socket channel.\n- WrappedWritableByteChannel.isOpen() -> [boolean] - Inner class method that checks if the channel is open.\n- WrappedWritableByteChannel.close() -> [void] - Inner class method that closes the channel.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\n\npublic class UnixSocket extends AbstractSocket {\n\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n            IllegalAccessException, IOException {\n        Class<?> unixDomainSocketAddress = Class.forName(\"java.net.UnixDomainSocketAddress\");\n        this.socketAddress =\n                (SocketAddress) unixDomainSocketAddress.getMethod(\"of\", String.class)\n                        .invoke(null, path);\n        this.socketChannel = SocketChannel.open(this.socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isInputShutdown()) {\n            throw new SocketException(\"Socket input is shutdown\");\n        }\n        return Channels.newInputStream(socketChannel);\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isOutputShutdown()) {\n            throw new SocketException(\"Socket output is shutdown\");\n        }\n        return Channels.newOutputStream(new WrappedWritableByteChannel());\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n        this.socketChannel.close();\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return UnixSocket.this.socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return UnixSocket.this.socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            UnixSocket.this.socketChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class UnixSocket extends AbstractSocket {\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final WrappedWritableByteChannel wrappedOutputChannel;\n\n    public UnixSocket(String path) throws IOException {\n        this.socketAddress = new UnixDomainSocketAddress(new File(path));\n        this.socketChannel = SocketChannel.open(socketAddress);\n        this.wrappedOutputChannel = new WrappedWritableByteChannel();\n    }\n\n    public InputStream getInputStream() throws SocketException {\n        if (closed.get()) throw new SocketException(\"Socket is closed\");\n        if (!socketChannel.isOpen()) throw new SocketException(\"Socket is not open\");\n        return new InputStream() {\n            private final ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n            @Override\n            public int read() throws IOException {\n                if (!buffer.hasRemaining()) {\n                    buffer.clear();\n                    int bytesRead = socketChannel.read(buffer);\n                    if (bytesRead == -1) return -1;\n                    buffer.flip();\n                }\n                return buffer.get() & 0xFF;\n            }\n\n            @Override\n            public int read(byte[] b, int off, int len) throws IOException {\n                if (b == null) throw new NullPointerException();\n                if (off < 0 || len < 0 || off + len > b.length) throw new IndexOutOfBoundsException();\n                if (len == 0) return 0;\n\n                buffer.clear();\n                int bytesRead = socketChannel.read(buffer);\n                if (bytesRead == -1) return -1;\n                buffer.flip();\n                int bytesToCopy = Math.min(len, buffer.remaining());\n                buffer.get(b, off, bytesToCopy);\n                return bytesToCopy;\n            }\n        };\n    }\n\n    public OutputStream getOutputStream() throws SocketException {\n        if (closed.get()) throw new SocketException(\"Socket is closed\");\n        if (!socketChannel.isOpen()) throw new SocketException(\"Socket is not open\");\n        return new OutputStream() {\n            private final ByteBuffer buffer = ByteBuffer.allocate(1024);\n            private final Object lock = new Object();\n\n            @Override\n            public void write(int b) throws IOException {\n                synchronized (lock) {\n                    if (!buffer.hasRemaining()) flushBuffer();\n                    buffer.put((byte) b);\n                }\n            }\n\n            @Override\n            public void write(byte[] b, int off, int len) throws IOException {\n                if (b == null) throw new NullPointerException();\n                if (off < 0 || len < 0 || off + len > b.length) throw new IndexOutOfBoundsException();\n\n                synchronized (lock) {\n                    int remaining = buffer.remaining();\n                    if (len <= remaining) {\n                        buffer.put(b, off, len);\n                    } else {\n                        if (remaining > 0) buffer.put(b, off, remaining);\n                        flushBuffer();\n                        if (len - remaining <= buffer.capacity()) {\n                            buffer.put(b, off + remaining, len - remaining);\n                        } else {\n                            socketChannel.write(ByteBuffer.wrap(b, off + remaining, len - remaining));\n                        }\n                    }\n                }\n            }\n\n            private void flushBuffer() throws IOException {\n                buffer.flip();\n                while (buffer.hasRemaining()) {\n                    socketChannel.write(buffer);\n                }\n                buffer.clear();\n            }\n\n            @Override\n            public void flush() throws IOException {\n                synchronized (lock) {\n                    flushBuffer();\n                }\n            }\n        };\n    }\n\n    public SocketAddress getLocalSocketAddress() {\n        return socketChannel.socket().getLocalSocketAddress();\n    }\n\n    public SocketAddress getRemoteSocketAddress() {\n        return socketChannel.socket().getRemoteSocketAddress();\n    }\n\n    public void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            socketChannel.close();\n        }\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            if (closed.get()) throw new ClosedChannelException();\n            return socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return !closed.get() && socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            UnixSocket.this.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 567,
    "Instruction": "Task Description: Implement a TCP client class in Java that handles network communication with a server, including connection management, data transmission, and reception with proper error handling and resource management.\n\nClass Description: The TcpClient class establishes and maintains a TCP connection to a specified server, sends data packets, and receives responses. It uses a custom protocol with 8-byte headers (4 bytes for type, 4 bytes for length) followed by the message body. The class runs network operations on a dedicated background thread and provides callback mechanisms for received data.\n\nAttributes:\n- TAG: String - Tag for logging purposes\n- PACKAGE_HEAD_LENGTH: int - Fixed length of packet header (8 bytes)\n- receiveListener: ReceiveListener - Callback interface for received data\n- hostip: String - Server IP address to connect to\n- port: int - Server port number\n- socketClient: Socket - The TCP socket instance\n- handler: Handler - Handler for background thread operations\n- receiveThread: Thread - Thread for receiving data\n\nMethods:\n- TcpClient() -> void - Constructor that initializes the background thread and attempts connection\n- tryConnect() -> void - Internal method to attempt server connection in a loop\n- connect() -> boolean - Establishes socket connection to server (returns success status)\n- send(byte[] data) -> void - Sends data to the server (runs on background thread)\n- onReceive(ReceiveListener receiveListener) -> void - Sets the receive callback listener\n- destroy() -> void - Cleans up resources and stops all network operations\n- closeAll() -> void - Safely closes socket and releases resources\n- startReceive() -> void - Starts the data receiving thread\n- getLengthFromHeadByte(byte[] b) -> int - Extracts message length from header bytes\n- getTypeFromHeadByte(byte[] b) -> int - Extracts message type from header bytes\n\nNested Classes:\n- Receiver implements Runnable - Background thread implementation for continuous data reception",
    "Canonical_solution": "import android.os.Handler;\nimport android.os.HandlerThread;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\n\npublic class TcpClient {\n    private static final String TAG = TcpClient.class.getSimpleName();\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n\n    public interface ReceiveListener {\n        void onReceive(int type, byte[] data);\n    }\n\n    private ReceiveListener receiveListener;\n    private String hostip = \"192.168.3.28\";\n    private int port = 2233;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient() {\n        HandlerThread tcpThread = new HandlerThread(\"tcpThread\");\n        tcpThread.start();\n        handler = new Handler(tcpThread.getLooper());\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        handler.post(() -> {\n            while (true) {\n                if (connect()) {\n                    startReceive();\n                    break;\n                }\n            }\n        });\n    }\n\n    private boolean connect() {\n        closeAll();\n        try {\n            socketClient = new Socket();\n            SocketAddress socAddress = new InetSocketAddress(hostip, port);\n            socketClient.connect(socAddress, 5000);\n            Log.i(TAG, \"socket connected successfully\");\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return false;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    public void send(byte[] data) {\n        Log.d(TAG, \"send data len:\" + data.length);\n        handler.post(() -> {\n            try {\n                OutputStream outputStream = socketClient.getOutputStream();\n                outputStream.write(data);\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        closeAll();\n    }\n\n    private void closeAll() {\n        if (socketClient == null || socketClient.isClosed() || !socketClient.isConnected()) {\n            return;\n        }\n        try {\n            socketClient.shutdownInput();\n            socketClient.shutdownOutput();\n            socketClient.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startReceive() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            while (true) {\n                if (receiveThread.isInterrupted()) {\n                    break;\n                }\n                try {\n                    InputStream inputStream = socketClient.getInputStream();\n                    boolean badPackage = false;\n                    int countHeadBytesLength = 0;\n                    byte[] headData = new byte[PACKAGE_HEAD_LENGTH];\n                    while (countHeadBytesLength < PACKAGE_HEAD_LENGTH) {\n                        int result = inputStream.read(headData, countHeadBytesLength, PACKAGE_HEAD_LENGTH - countHeadBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countHeadBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    int packageType = getTypeFromHeadByte(headData);\n                    int packageBodyBytesLength = getLengthFromHeadByte(headData);\n                    Log.d(TAG, \"new data received type:\" + packageType + \" body len:\" + packageBodyBytesLength);\n\n                    int countBodyBytesLength = 0;\n                    byte[] bodyData = new byte[packageBodyBytesLength];\n                    while (countBodyBytesLength < packageBodyBytesLength) {\n                        int result = inputStream.read(bodyData, countBodyBytesLength, packageBodyBytesLength - countBodyBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countBodyBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    if (receiveListener != null) {\n                        receiveListener.onReceive(packageType, bodyData);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    if (receiveThread.isInterrupted()) {\n                        break;\n                    }\n                    tryConnect();\n                    break;\n                }\n            }\n        }\n    }\n\n    private int getLengthFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[4] & 0x00FF;\n        int ch2 = b[5] & 0x00FF;\n        int ch3 = b[6] & 0x00FF;\n        int ch4 = b[7] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n\n    private int getTypeFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[0] & 0x00FF;\n        int ch2 = b[1] & 0x00FF;\n        int ch3 = b[2] & 0x00FF;\n        int ch4 = b[3] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\n\npublic class TcpClient {\n    private static final String TAG = \"TcpClient\";\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n    private ReceiveListener receiveListener;\n    private String hostip;\n    private int port;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public interface ReceiveListener {\n        void onReceived(int type, byte[] data);\n    }\n\n    public TcpClient(String hostip, int port) {\n        this.hostip = hostip;\n        this.port = port;\n        handler = new Handler();\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        new Thread(() -> {\n            while (!connect()) {\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            startReceive();\n        }).start();\n    }\n\n    private boolean connect() {\n        try {\n            socketClient = new Socket(hostip, port);\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public void send(byte[] data) {\n        handler.post(() -> {\n            if (socketClient == null || socketClient.isClosed()) return;\n            try {\n                OutputStream out = socketClient.getOutputStream();\n                byte[] header = ByteBuffer.allocate(PACKAGE_HEAD_LENGTH)\n                        .putInt(data.length)\n                        .putInt(0) // default type\n                        .array();\n                out.write(header);\n                out.write(data);\n                out.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n                closeAll();\n            }\n        });\n    }\n\n    public void onReceive(ReceiveListener listener) {\n        this.receiveListener = listener;\n    }\n\n    public void destroy() {\n        closeAll();\n        if (receiveThread != null && receiveThread.isAlive()) {\n            receiveThread.interrupt();\n        }\n    }\n\n    private void closeAll() {\n        try {\n            if (socketClient != null && !socketClient.isClosed()) {\n                socketClient.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startReceive() {\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private int getLengthFromHeadByte(byte[] b) {\n        return ByteBuffer.wrap(b).getInt();\n    }\n\n    private int getTypeFromHeadByte(byte[] b) {\n        return ByteBuffer.wrap(b).getInt(4);\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            try {\n                InputStream in = socketClient.getInputStream();\n                byte[] head = new byte[PACKAGE_HEAD_LENGTH];\n                while (!socketClient.isClosed()) {\n                    int totalRead = 0;\n                    while (totalRead < PACKAGE_HEAD_LENGTH) {\n                        int read = in.read(head, totalRead, PACKAGE_HEAD_LENGTH - totalRead);\n                        if (read == -1) throw new IOException(\"Stream closed\");\n                        totalRead += read;\n                    }\n                    int length = getLengthFromHeadByte(head);\n                    int type = getTypeFromHeadByte(head);\n\n                    byte[] body = new byte[length];\n                    totalRead = 0;\n                    while (totalRead < length) {\n                        int read = in.read(body, totalRead, length - totalRead);\n                        if (read == -1) throw new IOException(\"Stream closed\");\n                        totalRead += read;\n                    }\n                    if (receiveListener != null) {\n                        receiveListener.onReceived(type, body);\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                closeAll();\n            }\n        }\n    }\n\n    private class Handler {\n        void post(Runnable r) {\n            new Thread(r).start();\n        }\n    }\n}"
  },
  {
    "Task_id": 572,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data from an input stream, and verifies the successful transmission of data.\n\nFunction Description: The function should establish a connection to a server using a Socket, send data from an input stream to the server via an output stream, and ensure the data was transmitted successfully. It should also handle resource cleanup and verify the progress of the transmission.\n\nInput: \n- uri: [URI] - The URI object containing the host and port of the server to connect to.\n- inputStream: [InputStream] - The input stream containing the data to be sent to the server.\n- parser: [Object] - An object that manages the start and stop of the parsing process (assumed to have start() and stop() methods).\n\nOutput: \n- bytes: [long] - The number of bytes successfully transmitted to the server.\n- The function also asserts that the socket is connected, the number of bytes transmitted is greater than 0, and the progress of the transmission matches the expected progress. \n\nNote: The function may throw IOException, InterruptedException, or URISyntaxException.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.URISyntaxException;\n\npublic void testNormal() throws IOException, InterruptedException, URISyntaxException {\n    parser.start();\n\n    Socket client = new Socket(uri.getHost(), uri.getPort());\n    assertTrue(\"Socket is connected\", client.isConnected());\n\n    InputStream inputStream = combineResource(Progresses.allFiles);\n    OutputStream outputStream = client.getOutputStream();\n\n    long bytes = ByteStreams.copy(inputStream, outputStream);\n\n    Thread.sleep(100);\n\n    client.close();\n    parser.stop();\n\n    assertThat(bytes, greaterThan(0L));\n    assertThat(progesses, equalTo(Progresses.allProgresses));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.URI;\n\npublic class TcpClientFunction {\n\n    public static long sendDataToServer(URI uri, InputStream inputStream, Object parser) throws Exception {\n        String host = uri.getHost();\n        int port = uri.getPort();\n\n        Socket socket = new Socket(host, port);\n        try (InputStream in = inputStream; OutputStream out = socket.getOutputStream()) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            long totalBytesSent = 0;\n\n            ((Runnable) () -> parser.getClass().getMethod(\"start\").invoke(parser)).run();\n\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n                totalBytesSent += bytesRead;\n            }\n\n            out.flush();\n            ((Runnable) () -> {\n                try {\n                    parser.getClass().getMethod(\"stop\").invoke(parser);\n                } catch (Exception e) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(e);\n                }\n            }).run();\n\n            assert socket.isConnected();\n            assert totalBytesSent > 0;\n            assert totalBytesSent == inputStream.available() || /* expected progress logic */ true;\n\n            return totalBytesSent;\n        } finally {\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 573,
    "Instruction": "Task Description: Implement a TCP client class in Java that can establish a connection to a server, send and receive data, and properly close the connection.\n\nClass Description: The GaNetCat class provides functionality for TCP client-server communication. It encapsulates socket operations, including connection establishment, data transmission, and resource cleanup.\n\nAttributes:\n- socket: Socket - The underlying socket used for network communication\n- inputStream: InputStream - Stream for receiving data from the server\n- outputStream: OutputStream - Stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendData(InputStream source) -> void - Reads data from the source InputStream and sends it to the server through the output stream. Throws IOException if transmission fails.\n- receiveData(OutputStream destination) -> void - Receives data from the server and writes it to the destination OutputStream. Stops when encountering EOF or 0x04 (EOT) character. Throws IOException if reception fails.\n- close() -> void - Closes all resources (input stream, output stream, and socket) quietly, suppressing any exceptions during closure.",
    "Canonical_solution": "import org.apache.commons.io.IOUtils;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class GaNetCat {\n\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port));\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = source.read(dataArray);\n            if (length <= 0) {\n                break;\n            }\n            outputStream.write(dataArray, 0, length);\n            outputStream.flush();\n        } while (length > 0);\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = inputStream.read(dataArray);\n            if (length == 1 && dataArray[0] == 0x04) {\n                destination.flush();\n                break;\n            }\n            if (length <= 0) {\n                break;\n            }\n            destination.write(dataArray, 0, length);\n        } while (length > 0);\n    }\n\n    public void close() {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(outputStream);\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // ignore\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class GaNetCat {\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = source.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n        outputStream.flush();\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        int data;\n        while ((data = inputStream.read()) != -1 && data != 0x04) {\n            destination.write(data);\n        }\n    }\n\n    public void close() {\n        try {\n            if (inputStream != null) inputStream.close();\n        } catch (IOException e) {}\n        try {\n            if (outputStream != null) outputStream.close();\n        } catch (IOException e) {}\n        try {\n            if (socket != null) socket.close();\n        } catch (IOException e) {}\n    }\n}"
  },
  {
    "Task_id": 574,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a service discovered via Eureka, sends a request, and processes the response.\n\nFunction Description: The function uses Eureka client to discover a service instance, establishes a socket connection to the discovered service, sends a formatted request string, and reads the response. It handles connection errors and IO exceptions appropriately.\n\nInput: \n- eurekaClient: EurekaClient - The Eureka client instance used for service discovery\n- (implicit) vipAddress: String - The virtual IP address of the service to discover (\"sampleservice.mydomain.net\")\n\nOutput: \n- void - The function doesn't return a value but prints the server response or error messages to standard output/error\n- Side effect: Establishes a network connection and communicates with the discovered service\n\nNote: The function includes error handling for service discovery failures, connection issues, and IO operations. The request string is dynamically generated with a timestamp.",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.IOException;\n\npublic void sendRequestToServiceUsingEureka(EurekaClient eurekaClient) {\n    String vipAddress = \"sampleservice.mydomain.net\";\n\n    InstanceInfo nextServerInfo = null;\n    try {\n        nextServerInfo = eurekaClient.getNextServerFromEureka(vipAddress, false);\n    } catch (Exception e) {\n        System.err.println(\"Cannot get an instance of example service to talk to from eureka\");\n        System.exit(-1);\n    }\n\n    Socket s = new Socket();\n    int serverPort = nextServerInfo.getPort();\n    try {\n        s.connect(new InetSocketAddress(nextServerInfo.getHostName(), serverPort));\n    } catch (IOException e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort);\n    } catch (Exception e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort + \"due to Exception \" + e);\n    }\n    try {\n        String request = \"FOO \" + new Date();\n\n        PrintStream out = new PrintStream(s.getOutputStream());\n        out.println(request);\n\n        BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        String str = rd.readLine();\n        if (str != null) {\n            System.out.println(\"Received response from server: \" + str);\n        }\n        rd.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import com.netflix.appinfo.InstanceInfo;\nimport com.netflix.discovery.EurekaClient;\nimport java.io.*;\nimport java.net.*;\nimport java.time.Instant;\n\npublic class ServiceCommunicator {\n\n    public static void communicateWithService(EurekaClient eurekaClient) {\n        String vipAddress = \"sampleservice.mydomain.net\";\n        InstanceInfo instanceInfo = eurekaClient.getNextServerFromEureka(vipAddress, false);\n\n        if (instanceInfo == null) {\n            System.err.println(\"Failed to discover service instance for: \" + vipAddress);\n            return;\n        }\n\n        String hostName = instanceInfo.getHostName();\n        int port = instanceInfo.getPort();\n\n        String request = \"Request at \" + Instant.now().toString();\n\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(hostName, port), 5000);\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            writer.write(request);\n            writer.newLine();\n            writer.flush();\n\n            String responseLine;\n            while ((responseLine = reader.readLine()) != null) {\n                System.out.println(\"Server response: \" + responseLine);\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + hostName + \", error: \" + e.getMessage());\n        } catch (SocketTimeoutException e) {\n            System.err.println(\"Connection timed out to: \" + hostName + \":\" + port + \", error: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"IO error during communication with: \" + hostName + \":\" + port + \", error: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 575,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP client connection to a server, sends a command, and retrieves the server's response using socket programming.\n\nClass Description: The FourLetterCommand class provides functionality to connect to a server, send a command string, and receive the server's response. It handles socket creation, connection, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n\nMethods:\n- FourLetterCommand(String host, int port) -> None - Constructor that initializes the host and port attributes\n- request(String command) -> String - Establishes a connection to the server, sends the command, and returns the server's response\n- response(Socket client) -> String - Reads the server's response from the socket input stream and returns it as a string\n- cleanup(Closeable c) -> void - Closes the provided Closeable resource (socket or stream) and handles any IOExceptions silently",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        final Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(command.getBytes());\n            outputStream.flush();\n            return response(socket);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private String response(Socket client) {\n        try {\n            var reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            var builder = new StringBuilder(\"\");\n            String str;\n            while ((str = reader.readLine()) != null) {\n                builder.append(str).append(\"\\n\");\n            }\n            cleanup(client);\n            return builder.toString();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        Socket client = null;\n        try {\n            client = new Socket(host, port);\n            OutputStream out = client.getOutputStream();\n            out.write(command.getBytes());\n            out.flush();\n            return response(client);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            cleanup(client);\n        }\n    }\n\n    private String response(Socket client) {\n        InputStream in = null;\n        try {\n            in = client.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead = in.read(buffer);\n            if (bytesRead > 0) {\n                return new String(buffer, 0, bytesRead);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            cleanup(in);\n        }\n        return null;\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 576,
    "Instruction": "Task Description: Create a Java class that handles socket communication for receiving and processing video stream data from an Android device using scrcpy (Screen Copy) technology.\n\nClass Description: ScrcpyInputSocketThread is a thread class that establishes a socket connection to receive video stream data from an Android device, processes the NAL units (Network Abstraction Layer units) from the stream, and manages the communication lifecycle.\n\nAttributes:\n- log: Logger - Logger instance for recording operational information\n- iDevice: IDevice - Represents the connected Android device\n- dataQueue: BlockingQueue<byte[]> - Queue for storing processed video data packets\n- scrcpyLocalThread: ScrcpyLocalThread - Reference to the main scrcpy control thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - Reference to the Android test task thread\n- session: Session - WebSocket session for sending device information\n- BUFFER_SIZE: int (static final) - Maximum buffer size for video data (10MB)\n- READ_BUFFER_SIZE: int (static final) - Chunk size for reading from the input stream (5KB)\n\nMethods:\n- Constructor(IDevice, BlockingQueue<byte[]>, ScrcpyLocalThread, Session) -> void - Initializes the thread with device, data queue, control thread, and session references\n- run() -> void - Main thread execution that:\n  1. Sets up port forwarding for scrcpy\n  2. Establishes socket connection to localhost\n  3. Sends device screen dimensions via WebSocket\n  4. Continuously reads and processes video stream data\n  5. Manages resources cleanup on termination\n  6. Handles NAL unit detection and packetization\n\nThe class implements proper resource management by:\n1. Closing sockets and streams in finally blocks\n2. Removing port forwarding when done\n3. Cleaning up session references\n4. Interrupting related threads when needed\n5. Handling IOExceptions during communication",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.BytesTool;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\npublic class ScrcpyInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(ScrcpyInputSocketThread.class);\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private ScrcpyLocalThread scrcpyLocalThread;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n    private static final int BUFFER_SIZE = 1024 * 1024 * 10;\n    private static final int READ_BUFFER_SIZE = 1024 * 5;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n        this.androidTestTaskBootThread = scrcpyLocalThread.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(\"android-scrcpy-input-socket-task-%s-%s-%s\"));\n    }\n\n    @Override\n    public void run() {\n        int scrcpyPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, scrcpyPort, \"scrcpy\");\n        Socket videoSocket = new Socket();\n        InputStream inputStream = null;\n        try {\n            videoSocket.connect(new InetSocketAddress(\"localhost\", scrcpyPort));\n            inputStream = videoSocket.getInputStream();\n            if (videoSocket.isConnected()) {\n                String sizeTotal = AndroidDeviceBridgeTool.getScreenSize(iDevice);\n                BytesTool.sendText(session, String.format(\"{\\\"msg\\\":\\\"size\\\",\\\"width\\\":\\\"%s\\\",\\\"height\\\":\\\"%s\\\"}\", \n                    sizeTotal.split(\"x\")[0], sizeTotal.split(\"x\")[1]));\n            }\n            int readLength;\n            int naLuIndex;\n            int bufferLength = 0;\n            byte[] buffer = new byte[BUFFER_SIZE];\n            while (scrcpyLocalThread.isAlive()) {\n                readLength = inputStream.read(buffer, bufferLength, READ_BUFFER_SIZE);\n                if (readLength > 0) {\n                    bufferLength += readLength;\n                    for (int i = 5; i < bufferLength - 4; i++) {\n                        if (buffer[i] == 0x00 &&\n                                buffer[i + 1] == 0x00 &&\n                                buffer[i + 2] == 0x00 &&\n                                buffer[i + 3] == 0x01\n                        ) {\n                            naLuIndex = i;\n                            byte[] naluBuffer = new byte[naLuIndex];\n                            System.arraycopy(buffer, 0, naluBuffer, 0, naLuIndex);\n                            dataQueue.add(naluBuffer);\n                            bufferLength -= naLuIndex;\n                            System.arraycopy(buffer, naLuIndex, buffer, 0, bufferLength);\n                            i = 5;\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (scrcpyLocalThread.isAlive()) {\n                scrcpyLocalThread.interrupt();\n                log.info(\"scrcpy thread closed.\");\n            }\n            if (videoSocket.isConnected()) {\n                try {\n                    videoSocket.close();\n                    log.info(\"scrcpy video socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"scrcpy input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, scrcpyPort, \"scrcpy\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\nimport org.slf4j.Logger;\nimport com.example.androidtool.interfaces.IDevice;\nimport com.example.scrcpy.Session;\nimport com.example.scrcpy.ScrcpyLocalThread;\nimport com.example.androidtool.threads.AndroidTestTaskBootThread;\n\npublic class ScrcpyInputSocketThread extends Thread {\n    private static final int BUFFER_SIZE = 10 * 1024 * 1024;\n    private static final int READ_BUFFER_SIZE = 5 * 1024;\n    \n    private final Logger log;\n    private final IDevice iDevice;\n    private final BlockingQueue<byte[]> dataQueue;\n    private final ScrcpyLocalThread scrcpyLocalThread;\n    private final AndroidTestTaskBootThread androidTestTaskBootThread;\n    private final Session session;\n    private Socket socket;\n    private InputStream inputStream;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n        this.log = org.slf4j.LoggerFactory.getLogger(getClass());\n        this.androidTestTaskBootThread = new AndroidTestTaskBootThread();\n    }\n\n    @Override\n    public void run() {\n        try {\n            iDevice.executeShellCommand(\"am start -n com.genymobile.scrcpy/.MainActivity\");\n            iDevice.createForward(localhostPort(), getScrcpyPort());\n\n            socket = new Socket(\"127.0.0.1\", localhostPort());\n            inputStream = socket.getInputStream();\n\n            sendDeviceInfoMessage(session);\n\n            byte[] buffer = new byte[BUFFER_SIZE];\n            int offset = 0;\n            byte[] readBuffer = new byte[READ_BUFFER_SIZE];\n\n            while (!isInterrupted()) {\n                int bytesRead = inputStream.read(readBuffer);\n                if (bytesRead == -1) break;\n\n                if (offset + bytesRead > buffer.length) {\n                    log.warn(\"Buffer overflow, resetting buffer\");\n                    offset = 0;\n                }\n\n                System.arraycopy(readBuffer, 0, buffer, offset, bytesRead);\n                offset += bytesRead;\n\n                processNALUnits(buffer, offset);\n                offset = 0;\n            }\n        } catch (IOException e) {\n            log.error(\"IO error in ScrcpyInputSocketThread: \", e);\n        } finally {\n            cleanupResources();\n            removePortForwarding();\n            cleanupSessionReference();\n            interruptRelatedThreads();\n        }\n    }\n\n    private int localhostPort() {\n        return 27183;\n    }\n\n    private int getScrcpyPort() {\n        return 27185;\n    }\n\n    private void sendDeviceInfoMessage(Session session) throws IOException {\n        String deviceInfo = String.format(\"%d:%d:%s\", iDevice.getDisplayWidth(), iDevice.getDisplayHeight(), iDevice.getSerialNumber());\n        session.sendMessage(deviceInfo);\n    }\n\n    private void processNALUnits(byte[] data, int length) {\n        int nalStartOffset = findNALStartCode(data, 0, length);\n        \n        while (nalStartOffset >= 0) {\n            int nalEndOffset = findNALStartCode(data, nalStartOffset + 4, length);\n            if (nalEndOffset < 0) nalEndOffset = length;\n\n            byte[] nalUnit = new byte[nalEndOffset - nalStartOffset];\n            System.arraycopy(data, nalStartOffset, nalUnit, 0, nalUnit.length);\n\n            try {\n                dataQueue.put(nalUnit);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.error(\"Interrupted while putting NAL unit in queue: \", e);\n            }\n\n            nalStartOffset = nalEndOffset;\n        }\n    }\n\n    private int findNALStartCode(byte[] data, int start, int end) {\n        for (int i = start; i < end - 3; i++) {\n            if (data[i] == 0x00 && data[i+1] == 0x00 && data[i+2] == 0x00 && data[i+3] == 0x01) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private void cleanupResources() {\n        try {\n            if (inputStream != null) inputStream.close();\n        } catch (IOException e) {\n            log.error(\"Error closing input stream: \", e);\n        }\n\n        try {\n            if (socket != null && !socket.isClosed()) socket.close();\n        } catch (IOException e) {\n            log.error(\"Error closing socket: \", e);\n        }\n    }\n\n    private void removePortForwarding() {\n        try {\n            iDevice.removeForward(getScrcpyPort());\n        } catch (Exception e) {\n            log.warn(\"Failed to remove port forwarding: \", e);\n        }\n    }\n\n    private void cleanupSessionReference() {\n        if (session != null && session.isOpen()) {\n            try {\n                session.close();\n            } catch (IOException e) {\n                log.error(\"Error closing WebSocket session: \", e);\n            }\n        }\n    }\n\n    private void interruptRelatedThreads() {\n        if (scrcpyLocalThread != null) {\n            scrcpyLocalThread.interrupt();\n        }\n\n        if (androidTestTaskBootThread != null) {\n            androidTestTaskBootThread.interrupt();\n        }\n    }\n}"
  },
  {
    "Task_id": 578,
    "Instruction": "Task Description: Implement a Java class for sending HTTP requests and receiving responses using socket communication.\n\nClass Description: The HTTPRequest class extends HTTPPacket and provides functionality to send HTTP POST requests to a specified server. It handles connection management, request formatting, and response processing, with support for keep-alive connections and chunked transfer encoding.\n\nAttributes:\npostSocket: Socket - The socket used for communication with the server\n\nMethods:\npost: [Name](host: String, port: int, isKeepAlive: boolean) -> HTTPResponse - Sends an HTTP POST request to the specified host and port, with optional keep-alive connection\npost: [Name](host: String, port: int) -> HTTPResponse - Sends an HTTP POST request to the specified host and port with connection closing by default (calls the 3-parameter version with isKeepAlive=false)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.InetSocketAddress;\n\npublic class HTTPRequest extends HTTPPacket {\n\n    private Socket postSocket = null;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) {\n        HTTPResponse httpRes = new HTTPResponse();\n        setHost(host);\n        setConnection((isKeepAlive == true) ? HTTP.KEEP_ALIVE : HTTP.CLOSE);\n        boolean isHeaderRequest = isHeadRequest();\n        \n        OutputStream out = null;\n        InputStream in = null;\n        \n        try {\n            if (postSocket == null){\n                postSocket = new Socket();\n                postSocket.connect(new InetSocketAddress(host, port), HTTPServer.DEFAULT_TIMEOUT);\n            }\n\n            out = postSocket.getOutputStream();\n            PrintStream pout = new PrintStream(out);\n\n            String httpPacket = \"\";\n            httpPacket += getHeader();\n            httpPacket += HTTP.CRLF;\n            \n            boolean isChunkedRequest = isChunked();\n            String content = getContentString();\n            int contentLength = 0;\n            if (content != null)\n                contentLength = content.length();\n            \n            if (0 < contentLength) {\n                if (isChunkedRequest == true) {\n                    String chunSizeBuf = Long.toHexString(contentLength);\n                    httpPacket += chunSizeBuf;\n                    httpPacket += HTTP.CRLF;\n                }\n                httpPacket += content;\n                if (isChunkedRequest == true) {\n                    httpPacket += HTTP.CRLF;\n                }\n            }\n\n            if (isChunkedRequest == true) {\n                httpPacket += \"0\";\n                httpPacket += HTTP.CRLF;\n            }\n\n            pout.print(httpPacket);\n            pout.flush();\n\n            in = postSocket.getInputStream();\n            httpRes.set(in, isHeaderRequest);        \n        } catch (SocketException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } catch (IOException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } finally {\n            if (isKeepAlive == false) {    \n                try {\n                    if (in != null) in.close();\n                } catch (Exception e) {};\n                try {\n                    if (out != null) out.close();\n                } catch (Exception e) {};\n                try {\n                    if (postSocket != null) postSocket.close();\n                } catch (Exception e) {};\n                postSocket = null;\n            }\n        }\n        \n        return httpRes;\n    }\n\n    public HTTPResponse post(String host, int port) {\n        return post(host, port, false);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class HTTPRequest extends HTTPPacket {\n    private Socket postSocket;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) {\n        try {\n            if (postSocket == null || postSocket.isClosed()) {\n                postSocket = new Socket(host, port);\n            }\n\n            OutputStream out = postSocket.getOutputStream();\n            InputStream in = postSocket.getInputStream();\n\n            StringBuilder requestBuilder = new StringBuilder();\n            requestBuilder.append(\"POST \").append(getPath()).append(\" HTTP/1.1\\r\\n\");\n            requestBuilder.append(\"Host: \").append(host).append(\"\\r\\n\");\n            requestBuilder.append(\"Content-Type: application/x-www-form-urlencoded\\r\\n\");\n\n            if (isKeepAlive) {\n                requestBuilder.append(\"Connection: keep-alive\\r\\n\");\n            } else {\n                requestBuilder.append(\"Connection: close\\r\\n\");\n            }\n\n            String body = getBody(); \n            requestBuilder.append(\"Content-Length: \").append(body.length()).append(\"\\r\\n\");\n            requestBuilder.append(\"\\r\\n\");\n            requestBuilder.append(body);\n\n            out.write(requestBuilder.toString().getBytes());\n            out.flush();\n\n            return processResponse(in);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public HTTPResponse post(String host, int port) {\n        return post(host, port, false);\n    }\n\n    private String getPath() {\n        return \"/\"; \n    }\n\n    private String getBody() {\n        return \"\"; \n    }\n\n    private HTTPResponse processResponse(InputStream in) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        HTTPResponse response = new HTTPResponse();\n\n        String line;\n        boolean headersDone = false;\n        StringBuilder bodyBuilder = new StringBuilder();\n\n        while ((line = reader.readLine()) != null) {\n            if (!headersDone) {\n                if (line.isEmpty()) {\n                    headersDone = true;\n                } else {\n                    response.addHeader(line);\n                }\n            } else {\n                bodyBuilder.append(line);\n            }\n        }\n\n        response.setBody(bodyBuilder.toString());\n        return response;\n    }\n}"
  },
  {
    "Task_id": 579,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The TCPClient class provides functionality for establishing and managing a TCP connection with a server. It handles connection establishment, message sending/receiving, and resource cleanup.\n\nAttributes:\n- mClientSocket: [Socket] - The socket object representing the connection to the server\n- mPrintWriter: [PrintWriter] - Output stream for sending data to the server\n- mBufferedReader: [BufferedReader] - Input stream for receiving data from the server\n\nMethods:\n- connectTCPServer(): [void] - Establishes a persistent connection to the TCP server at \"localhost:8688\" and continuously listens for incoming messages\n- sendMessage(String msg): [void] - Sends a message to the connected server (Input: msg - the message string to send)\n- closeConnection(): [void] - Properly closes all network resources and connections",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        Socket socket = null;\n        while (socket == null) {\n            try {\n                socket = new Socket(\"localhost\", 8688);\n                mClientSocket = socket;\n                mPrintWriter = new PrintWriter(new BufferedWriter(\n                        new OutputStreamWriter(socket.getOutputStream())), true);\n                System.out.println(\"connect server success\");\n            } catch (IOException e) {\n                System.out.println(\"connect tcp server failed, retry...\");\n            }\n        }\n\n        try {\n            mBufferedReader = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream()));\n            while (true) {\n                String msg = mBufferedReader.readLine();\n                System.out.println(\"receive :\" + msg);\n                if (msg != null) {\n                    System.out.println(\"server:\" + msg);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (!msg.isEmpty() && mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mClientSocket != null) {\n                mClientSocket.shutdownInput();\n                mClientSocket.close();\n            }\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TCPClient {\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        try {\n            mClientSocket = new Socket(\"localhost\", 8688);\n            mPrintWriter = new PrintWriter(mClientSocket.getOutputStream(), true);\n            mBufferedReader = new BufferedReader(new InputStreamReader(mClientSocket.getInputStream()));\n\n            // Continuously listen for incoming messages\n            String response;\n            while ((response = mBufferedReader.readLine()) != null) {\n                System.out.println(\"Received: \" + response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (mPrintWriter != null && !mPrintWriter.checkError()) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mBufferedReader != null) mBufferedReader.close();\n            if (mPrintWriter != null) mPrintWriter.close();\n            if (mClientSocket != null && !mClientSocket.isClosed()) mClientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using HttpURLConnection for making network requests, with support for request configuration, response handling, and optional GZIP compression.\n\nClass Description: Networker is a singleton class that manages HTTP requests and responses. It uses a thread pool for asynchronous request execution and provides methods for configuring requests, handling responses, and managing connection settings.\n\nAttributes:\n\nsInstance: Networker - Singleton instance of the Networker class\nsExecutor: Executor - Thread pool executor for handling requests asynchronously\nREAD_TIMEOUT_MS: int - Timeout for reading from connection (10000ms)\nCONNECT_TIMEOUT_MS: int - Timeout for establishing connection (15000ms)\nHEADER_ACCEPT_ENCODING: String - Header key for accept encoding (\"Accept-Encoding\")\nGZIP_ENCODING: String - Value for GZIP encoding (\"gzip\")\n\nMethods:\n\nget(): void -> Networker - Returns the singleton instance of Networker\nsubmit(HttpRequest request, Callback callback): void - Submits an HTTP request for asynchronous execution\nHttpRequestTask(HttpRequest request, Callback callback): void - Constructor for the internal request task class\nrun(): void - Executes the HTTP request task\ndoFetch(): void -> HttpResponse - Performs the actual HTTP request and returns the response\nconfigureAndConnectRequest(): void -> HttpURLConnection - Configures and connects the HTTP request\nrequestDecompression(HttpURLConnection conn): void - Sets the Accept-Encoding header for GZIP compression\napplyDecompressionIfApplicable(HttpURLConnection conn, InputStream in): InputStream - Applies GZIP decompression if needed\ncopy(InputStream in, OutputStream out, byte[] buf): void - Copies data between streams\nHttpRequest(Builder b): void - Constructor for HTTP request object\nnewBuilder(): void -> Builder - Creates a new HttpRequest builder\nBuilder(): void - Constructor for HttpRequest builder\nfriendlyName(String friendlyName): Builder -> Builder - Sets friendly name for request\nmethod(HttpMethod method): Builder -> Builder - Sets HTTP method\nurl(String url): Builder -> Builder - Sets request URL\nbody(byte[] body): Builder -> Builder - Sets request body\nbuild(): void -> HttpRequest - Builds the HttpRequest object\nHttpResponse(int statusCode, byte[] body): void - Constructor for HTTP response object\nonResponse(HttpResponse result): void - Callback for successful response\nonFailure(IOException e): void - Callback for failed request",
    "Canonical_solution": "import com.facebook.stetho.urlconnection.ByteArrayRequestEntity;\nimport com.facebook.stetho.urlconnection.SimpleRequestEntity;\nimport com.facebook.stetho.urlconnection.StethoURLConnectionManager;\nimport javax.annotation.Nullable;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n  private static Networker sInstance;\n  private final Executor sExecutor = Executors.newFixedThreadPool(4);\n  private static final int READ_TIMEOUT_MS = 10000;\n  private static final int CONNECT_TIMEOUT_MS = 15000;\n  private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n  private static final String GZIP_ENCODING = \"gzip\";\n\n  public static synchronized Networker get() {\n    if (sInstance == null) {\n      sInstance = new Networker();\n    }\n    return sInstance;\n  }\n\n  private Networker() {\n  }\n\n  public void submit(HttpRequest request, Callback callback) {\n    sExecutor.execute(new HttpRequestTask(request, callback));\n  }\n\n  private class HttpRequestTask implements Runnable {\n    private final HttpRequest request;\n    private final Callback callback;\n    private final StethoURLConnectionManager stethoManager;\n\n    public HttpRequestTask(HttpRequest request, Callback callback) {\n      this.request = request;\n      this.callback = callback;\n      stethoManager = new StethoURLConnectionManager(request.friendlyName);\n    }\n\n    @Override\n    public void run() {\n      try {\n        HttpResponse response = doFetch();\n        callback.onResponse(response);\n      } catch (IOException e) {\n        callback.onFailure(e);\n      }\n    }\n\n    private HttpResponse doFetch() throws IOException {\n      HttpURLConnection conn = configureAndConnectRequest();\n      try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        InputStream rawStream = conn.getInputStream();\n        try {\n          rawStream = stethoManager.interpretResponseStream(rawStream);\n          InputStream decompressedStream = applyDecompressionIfApplicable(conn, rawStream);\n          if (decompressedStream != null) {\n            copy(decompressedStream, out, new byte[1024]);\n          }\n        } finally {\n          if (rawStream != null) {\n            rawStream.close();\n          }\n        }\n        return new HttpResponse(conn.getResponseCode(), out.toByteArray());\n      } finally {\n        conn.disconnect();\n      }\n    }\n\n    private HttpURLConnection configureAndConnectRequest() throws IOException {\n      URL url = new URL(request.url);\n      HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n      try {\n        conn.setReadTimeout(READ_TIMEOUT_MS);\n        conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n        conn.setRequestMethod(request.method.toString());\n        requestDecompression(conn);\n\n        SimpleRequestEntity requestEntity = null;\n        if (request.body != null) {\n          requestEntity = new ByteArrayRequestEntity(request.body);\n        }\n\n        stethoManager.preConnect(conn, requestEntity);\n        try {\n          if (request.method == HttpMethod.POST) {\n            if (requestEntity == null) {\n              throw new IllegalStateException(\"POST requires an entity\");\n            }\n            conn.setDoOutput(true);\n            requestEntity.writeTo(conn.getOutputStream());\n          }\n\n          conn.connect();\n          stethoManager.postConnect();\n          return conn;\n        } catch (IOException inner) {\n          stethoManager.httpExchangeFailed(inner);\n          throw inner;\n        }\n      } catch (IOException outer) {\n        conn.disconnect();\n        throw outer;\n      }\n    }\n  }\n\n  private static void requestDecompression(HttpURLConnection conn) {\n    conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n  }\n\n  @Nullable\n  private static InputStream applyDecompressionIfApplicable(\n      HttpURLConnection conn, @Nullable InputStream in) throws IOException {\n    if (in != null && GZIP_ENCODING.equals(conn.getContentEncoding())) {\n      return new GZIPInputStream(in);\n    }\n    return in;\n  }\n\n  private static void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n    if (in == null) {\n      return;\n    }\n    int n;\n    while ((n = in.read(buf)) != -1) {\n      out.write(buf, 0, n);\n    }\n  }\n\n  public static class HttpRequest {\n    public final String friendlyName;\n    public final HttpMethod method;\n    public final String url;\n    public final byte[] body;\n\n    public static Builder newBuilder() {\n      return new Builder();\n    }\n\n    HttpRequest(Builder b) {\n      this.friendlyName = b.friendlyName;\n      this.method = b.method;\n      this.url = b.url;\n      this.body = b.body;\n    }\n\n    public static class Builder {\n      private String friendlyName;\n      private Networker.HttpMethod method;\n      private String url;\n      private byte[] body = null;\n\n      Builder() {\n      }\n\n      public Builder friendlyName(String friendlyName) {\n        this.friendlyName = friendlyName;\n        return this;\n      }\n\n      public Builder method(Networker.HttpMethod method) {\n        this.method = method;\n        return this;\n      }\n\n      public Builder url(String url) {\n        this.url = url;\n        return this;\n      }\n\n      public Builder body(byte[] body) {\n        this.body = body;\n        return this;\n      }\n\n      public HttpRequest build() {\n        return new HttpRequest(this);\n      }\n    }\n  }\n\n  public static enum HttpMethod {\n    GET, POST\n  }\n\n  public static class HttpResponse {\n    public final int statusCode;\n    public final byte[] body;\n\n    HttpResponse(int statusCode, byte[] body) {\n      this.statusCode = statusCode;\n      this.body = body;\n    }\n  }\n\n  public interface Callback {\n    public void onResponse(HttpResponse result);\n    public void onFailure(IOException e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n    private static Networker sInstance;\n    private static Executor sExecutor = Executors.newCachedThreadPool();\n    private static final int READ_TIMEOUT_MS = 10000;\n    private static final int CONNECT_TIMEOUT_MS = 15000;\n    private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n    private static final String GZIP_ENCODING = \"gzip\";\n\n    public static Networker get() {\n        if (sInstance == null) {\n            sInstance = new Networker();\n        }\n        return sInstance;\n    }\n\n    public void submit(HttpRequest request, Callback callback) {\n        sExecutor.execute(new HttpRequestTask(request, callback));\n    }\n\n    private static class HttpRequestTask implements Runnable {\n        private HttpRequest request;\n        private Callback callback;\n\n        public HttpRequestTask(HttpRequest request, Callback callback) {\n            this.request = request;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try {\n                HttpResponse response = doFetch();\n                callback.onResponse(response);\n            } catch (IOException e) {\n                callback.onFailure(e);\n            }\n        }\n\n        private HttpResponse doFetch() throws IOException {\n            HttpURLConnection conn = configureAndConnectRequest();\n            return new HttpResponse(conn.getResponseCode(), readResponseBody(conn));\n        }\n\n        private HttpURLConnection configureAndConnectRequest() throws IOException {\n            URL url = new URL(request.getUrl());\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(READ_TIMEOUT_MS);\n            conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n            conn.setRequestMethod(request.getMethod().name());\n            conn.setDoInput(true);\n\n            if (request.getBody() != null) {\n                conn.setDoOutput(true);\n                conn.setRequestProperty(\"Content-Length\", String.valueOf(request.getBody().length));\n                try (OutputStream out = conn.getOutputStream()) {\n                    copy(new ByteArrayInputStream(request.getBody()), out, new byte[1024]);\n                }\n            }\n\n            requestDecompression(conn);\n            conn.connect();\n            return conn;\n        }\n\n        private void requestDecompression(HttpURLConnection conn) {\n            conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n        }\n\n        private byte[] readResponseBody(HttpURLConnection conn) throws IOException {\n            InputStream in = null;\n            try {\n                in = conn.getInputStream();\n            } catch (IOException e) {\n                in = conn.getErrorStream();\n            }\n            if (in == null) {\n                return new byte[0];\n            }\n\n            in = applyDecompressionIfApplicable(conn, in);\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            copy(in, out, new byte[1024]);\n            return out.toByteArray();\n        }\n\n        private InputStream applyDecompressionIfApplicable(HttpURLConnection conn, InputStream in) {\n            String contentEncoding = conn.getHeaderField(\"Content-Encoding\");\n            if (contentEncoding != null && contentEncoding.contains(GZIP_ENCODING)) {\n                try {\n                    return new GZIPInputStream(in);\n                } catch (IOException e) {\n                    return in;\n                }\n            }\n            return in;\n        }\n\n        private void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n            int bytesRead;\n            while ((bytesRead = in.read(buf)) > 0) {\n                out.write(buf, 0, bytesRead);\n            }\n        }\n    }\n\n    public static class HttpRequest {\n        private String friendlyName;\n        private HttpMethod method;\n        private String url;\n        private byte[] body;\n\n        public HttpRequest(Builder b) {\n            this.friendlyName = b.friendlyName;\n            this.method = b.method;\n            this.url = b.url;\n            this.body = b.body;\n        }\n\n        public static Builder newBuilder() {\n            return new Builder();\n        }\n\n        public String getUrl() {\n            return url;\n        }\n\n        public HttpMethod getMethod() {\n            return method;\n        }\n\n        public byte[] getBody() {\n            return body;\n        }\n\n        public static class Builder {\n            private String friendlyName;\n            private HttpMethod method;\n            private String url;\n            private byte[] body;\n\n            public Builder() {}\n\n            public Builder friendlyName(String friendlyName) {\n                this.friendlyName = friendlyName;\n                return this;\n            }\n\n            public Builder method(HttpMethod method) {\n                this.method = method;\n                return this;\n            }\n\n            public Builder url(String url) {\n                this.url = url;\n                return this;\n            }\n\n            public Builder body(byte[] body) {\n                this.body = body;\n                return this;\n            }\n\n            public HttpRequest build() {\n                return new HttpRequest(this);\n            }\n        }\n    }\n\n    public enum HttpMethod {\n        GET,\n        POST,\n        PUT,\n        DELETE\n    }\n\n    public static class HttpResponse {\n        private int statusCode;\n        private byte[] body;\n\n        public HttpResponse(int statusCode, byte[] body) {\n            this.statusCode = statusCode;\n            this.body = body;\n        }\n    }\n\n    public interface Callback {\n        void onResponse(HttpResponse result);\n        void onFailure(IOException e);\n    }\n}"
  },
  {
    "Task_id": 581,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that handles both client and server roles for message exchange between two endpoints.\n\nClass Description: UnicastTestTcpSlow is a TCP unicast communication class that establishes connections, sends and receives messages, and manages socket resources. It acts as both a client (connecting to remote endpoints) and a server (accepting incoming connections).\n\nAttributes:\n- local: InetSocketAddress - Local address and port for server socket binding\n- remote: InetSocketAddress - Remote address and port for client connection\n- sock: Socket - Client socket for outgoing connections\n- output: DataOutputStream - Output stream for sending data\n- output_lock: Lock - Synchronization lock for thread-safe output operations\n- srv_sock: ServerSocket - Server socket for accepting incoming connections\n- acceptor: Acceptor - Thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up server socket and attempting client connection\n- receive(Message msg) -> void - Handles received messages by printing message type\n- readMessage(byte[] buf, int offset, int length) -> Message - Static helper method to deserialize message from byte array\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Main acceptor loop that accepts connections and processes messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from input stream",
    "Canonical_solution": "import org.jgroups.BytesMessage;\nimport org.jgroups.Global;\nimport org.jgroups.Message;\nimport org.jgroups.Version;\nimport org.jgroups.util.*;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    protected InetSocketAddress    local, remote;\n    protected Socket               sock;\n    protected DataOutputStream     output;\n    protected final Lock           output_lock=new ReentrantLock();\n    protected ServerSocket         srv_sock;\n    protected Acceptor             acceptor;\n\n    protected static final boolean TCP_NODELAY=false;\n    protected static final int     SOCK_SEND_BUF_SIZE=200 * 1000;\n    protected static final int     SOCK_RECV_BUF_SIZE=200 * 1000;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local=new InetSocketAddress(local_addr, local_port);\n        remote=new InetSocketAddress(remote_addr, remote_port);\n        srv_sock=Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(), local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor=new Acceptor();\n        acceptor.start();\n\n        sock=new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output=new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected class Acceptor extends Thread {\n        protected byte[] buf=new byte[1024];\n\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock=null;\n                DataInputStream in=null;\n                try {\n                    client_sock=srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in=new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            int len=in.readInt();\n            if(len > buf.length)\n                buf=new byte[len];\n            in.readFully(buf, 0, len);\n\n            Message msg=readMessage(buf, 0, len);\n            receive(msg);\n        }\n    }\n\n    protected static Message readMessage(byte[] buf, int offset, int length) throws Exception {\n        ByteArrayDataInputStream in=new ByteArrayDataInputStream(buf, offset, length);\n        short ver=in.readShort();\n        byte flags=in.readByte();\n        Message msg=new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    public void receive(Message msg) {\n        byte[] buf=msg.getArray();\n        byte   type=buf[msg.getOffset()];\n        System.out.println(\"Received message of type: \" + type);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private final Lock output_lock = new ReentrantLock();\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws IOException {\n        this.local = new InetSocketAddress(local_addr, local_port);\n        this.remote = new InetSocketAddress(remote_addr, remote_port);\n\n        // Start server socket and acceptor thread\n        srv_sock = new ServerSocket();\n        srv_sock.bind(local);\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        // Attempt client connection\n        connectToServer();\n    }\n\n    private void connectToServer() throws IOException {\n        sock = new Socket();\n        sock.connect(remote);\n        output = new DataOutputStream(sock.getOutputStream());\n    }\n\n    public void receive(Message msg) {\n        System.out.println(\"Received message type: \" + msg.getType());\n    }\n\n    public static Message readMessage(byte[] buf, int offset, int length) {\n        // Deserialize message from byte array (stub implementation)\n        return new Message(buf[offset]); // Assuming first byte is message type\n    }\n\n    private class Acceptor extends Thread {\n        @Override\n        public void run() {\n            while (!Thread.currentThread().isInterrupted()) {\n                try {\n                    Socket clientSocket = srv_sock.accept();\n                    handleRequest(new DataInputStream(clientSocket.getInputStream()));\n                } catch (IOException e) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n\n        private void handleRequest(DataInputStream in) throws IOException {\n            // Read message size\n            int size = in.readInt();\n            byte[] buffer = new byte[size];\n            in.readFully(buffer);\n            Message msg = readMessage(buffer, 0, size);\n            receive(msg);\n        }\n    }\n\n    // Stub Message class for demonstration purposes\n    public static class Message {\n        private byte type;\n\n        public Message(byte type) {\n            this.type = type;\n        }\n\n        public byte getType() {\n            return type;\n        }\n    }\n}"
  },
  {
    "Task_id": 586,
    "Instruction": "Task Description: Implement a QMP (QEMU Machine Protocol) client class that can communicate with a QEMU instance either through a local Unix domain socket or a TCP socket, depending on configuration. The client should be able to send commands and receive responses from the QEMU monitor interface.\n\nClass Description: The QmpClient class provides functionality to connect to a QEMU instance via QMP protocol, send commands, and receive responses. It supports both local Unix domain sockets (for local QEMU instances) and TCP sockets (for remote QEMU instances). The class handles connection establishment, command sending, response parsing, and resource cleanup.\n\nAttributes:\n- TAG: String - A constant for logging purposes\n- requestCommandMode: String - The initial QMP capabilities request command\n- external: boolean - Flag indicating whether to use external TCP connection (true) or local Unix socket (false)\n\nMethods:\n- setExternal(boolean value) -> void - Sets the connection mode (TCP socket or local Unix socket)\n- sendCommand(String command) -> String - Sends a QMP command and returns the response\n- tryGetResponse(BufferedReader in) -> String - Attempts to get a response with retries\n- sendRequest(PrintWriter out, String request) -> void - Sends a request to the QEMU monitor\n- getResponse(BufferedReader in) -> String - Reads and parses the response from QEMU monitor",
    "Canonical_solution": "import android.net.LocalSocket;\nimport android.net.LocalSocketAddress;\nimport android.util.Log;\n\nimport com.max2idea.android.limbo.main.Config;\nimport com.max2idea.android.limbo.main.LimboApplication;\n\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class QmpClient {\n\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{ \\\"execute\\\": \\\"qmp_capabilities\\\" }\";\n    private static boolean external = false;\n\n    public static void setExternal(boolean value) {\n        external = value;\n    }\n\n    public synchronized static String sendCommand(String command) {\n        String response = null;\n        Socket pingSocket = null;\n        LocalSocket localSocket = null;\n        PrintWriter out = null;\n        BufferedReader in = null;\n\n        try {\n            if(external) {\n                pingSocket = new Socket(Config.QMPServer, Config.QMPPort);\n                pingSocket.setSoTimeout(5000);\n                out = new PrintWriter(pingSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(pingSocket.getInputStream()));\n            } else {\n                localSocket = new LocalSocket();\n                String localQMPSocketPath = LimboApplication.getLocalQMPSocketPath();\n                LocalSocketAddress localSocketAddr = new LocalSocketAddress(localQMPSocketPath, LocalSocketAddress.Namespace.FILESYSTEM);\n                localSocket.connect(localSocketAddr);\n                localSocket.setSoTimeout(5000);\n                out = new PrintWriter(localSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(localSocket.getInputStream()));\n            }\n            sendRequest(out, QmpClient.requestCommandMode);\n            response = tryGetResponse(in);\n            sendRequest(out, command);\n            response = tryGetResponse(in);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (out != null)\n                out.close();\n            try {\n                if (in != null)\n                    in.close();\n                if (pingSocket != null)\n                    pingSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if(Config.debugQmp)\n            Log.d(TAG, \"Response: \" + response);\n        return response;\n    }\n\n    private static String tryGetResponse(BufferedReader in) throws Exception {\n        String response = null;\n        int trial = 0;\n        while((response = getResponse(in)).equals(\"\") && trial < 3){\n            Thread.sleep(1000);\n            trial++;\n        }\n        return response;\n    }\n\n    private static void sendRequest(PrintWriter out, String request) {\n        if(Config.debugQmp)\n            Log.d(TAG, \"QMP request\" + request);\n        out.println(request);\n    }\n\n    private static String getResponse(BufferedReader in) throws Exception {\n        String line;\n        StringBuilder stringBuilder = new StringBuilder(\"\");\n        try {\n            do {\n                line = in.readLine();\n                if (line != null) {\n                    if(Config.debugQmp)\n                        Log.d(TAG, \"QMP response: \" + line);\n                    JSONObject object = new JSONObject(line);\n                    String returnStr = null;\n                    String errStr = null;\n\n                    try {\n                        if(line.contains(\"return\"))\n                            returnStr = object.getString(\"return\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n\n                    if (returnStr != null) {\n                        stringBuilder.append(line);\n                        stringBuilder.append(\"\\n\");\n                        break;\n                    }\n\n                    try {\n                        if(line.contains(\"error\"))\n                            errStr = object.getString(\"error\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n                    stringBuilder.append(line);\n                    stringBuilder.append(\"\\n\");\n                    if (errStr != null) {\n                        break;\n                    }\n                } else\n                    break;\n            } while (true);\n        } catch (Exception ex) {\n            Log.e(TAG, \"Could not get Response: \" + ex.getMessage());\n            if(Config.debugQmp)\n                ex.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport android.util.Log;\n\npublic class QmpClient {\n    private static final String TAG = \"QmpClient\";\n    private String requestCommandMode = \"{\\\"execute\\\":\\\"qmp_capabilities\\\"}\";\n    private boolean external = false;\n\n    public void setExternal(boolean value) {\n        external = value;\n    }\n\n    public String sendCommand(String command) {\n        Socket socket = null;\n        PrintWriter out = null;\n        BufferedReader in = null;\n        String response = \"\";\n\n        try {\n            if (external) {\n                socket = new Socket(\"127.0.0.1\", 4444);\n            } else {\n                // Unix domain socket not directly supported in standard Java\n                throw new UnsupportedOperationException(\"Unix socket not supported in this environment\");\n            }\n\n            out = new PrintWriter(socket.getOutputStream(), true);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            sendRequest(out, requestCommandMode);\n            String initResponse = getResponse(in);\n\n            sendRequest(out, command);\n            response = getResponse(in);\n        } catch (Exception e) {\n            Log.e(TAG, \"Error communicating with QEMU: \" + e.getMessage());\n        } finally {\n            try {\n                if (out != null) out.close();\n                if (in != null) in.close();\n                if (socket != null) socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Error closing resources: \" + e.getMessage());\n            }\n        }\n\n        return response;\n    }\n\n    private String tryGetResponse(BufferedReader in) {\n        int retryCount = 3;\n        String response = \"\";\n\n        for (int i = 0; i < retryCount; i++) {\n            try {\n                if ((response = in.readLine()) != null) {\n                    break;\n                }\n            } catch (IOException e) {\n                Log.e(TAG, \"Read error during retry: \" + e.getMessage());\n            }\n        }\n\n        return response;\n    }\n\n    private void sendRequest(PrintWriter out, String request) {\n        out.println(request);\n    }\n\n    private String getResponse(BufferedReader in) {\n        StringBuilder responseBuilder = new StringBuilder();\n        String line;\n\n        try {\n            while ((line = in.readLine()) != null) {\n                responseBuilder.append(line).append(\"\\n\");\n                if (line.trim().endsWith(\"}\")) break;\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"Error reading response: \" + e.getMessage());\n        }\n\n        return responseBuilder.toString();\n    }\n}"
  },
  {
    "Task_id": 589,
    "Instruction": "Task Description: Create a custom SocketFactory implementation that supports both direct connections and proxy connections (SOCKS and HTTP) with optional authentication for HTTP proxies.\n\nClass Description: CustomSocketFactory is a SocketFactory subclass that provides socket creation capabilities with proxy support. It handles both direct connections and connections through SOCKS or HTTP proxies, including HTTP proxy authentication when required.\n\nAttributes:\n- proxyHost: String - The hostname or IP address of the proxy server\n- proxyPort: int - The port number of the proxy server\n- proxyUser: String - The username for proxy authentication (optional)\n- proxyPass: String - The password for proxy authentication (optional)\n- proxyType: Proxy.Type - The type of proxy (SOCKS or HTTP)\n\nMethods:\n- createSocket(String host, int port) -> Socket - Creates a socket connected to the specified host and port\n- createSocket(String host, int port, InetAddress localHost, int localPort) -> Socket - Creates a socket connected to the specified host and port, binding to the specified local address and port\n- createSocket(InetAddress host, int port) -> Socket - Creates a socket connected to the specified InetAddress and port\n- createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) -> Socket - Creates a socket connected to the specified InetAddress and port, binding to the specified local address and port\n- createSocket() -> Socket - Creates an unconnected socket with proxy configuration\n- connectToProxy(Socket socket) -> void - Handles HTTP proxy connection and authentication (private method)\n- getBasicAuthStr() -> String - Generates Base64 encoded proxy authentication string (private method)\n- readLine(InputStream in) -> String - Reads a line from the input stream (private method)\n- getResponseCode(String statusLine) -> int - Extracts HTTP response code from status line (private static method)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.Base64;\nimport javax.net.SocketFactory;\n\npublic class CustomSocketFactory extends SocketFactory {\n\n    private String proxyHost, proxyUser, proxyPass;\n    private int proxyPort;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort,\n            String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port)\n            throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost,\n            int localPort) throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port, localHost,\n                localPort);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return this.createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port,\n            InetAddress localAddress, int localPort) throws IOException {\n        Socket socket = this.createSocket();\n        if (localAddress != null) {\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n        }\n        if (address != null) {\n            socket.connect(new InetSocketAddress(address, port));\n        }\n\n        if (this.proxyType == Proxy.Type.HTTP && proxyUser != null) {\n            connectToProxy(socket);\n        }\n\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Proxy proxy = Proxy.NO_PROXY;\n        if (this.proxyType == Proxy.Type.SOCKS) {\n            proxy = new Proxy(Proxy.Type.SOCKS,\n                    new InetSocketAddress(proxyHost, proxyPort));\n        } else if (this.proxyType == Proxy.Type.HTTP) {\n            if (proxyUser == null || proxyUser.length() < 1) {\n                proxy = new Proxy(Proxy.Type.HTTP,\n                        new InetSocketAddress(proxyHost, proxyPort));\n            }\n        }\n\n        Socket socket = new Socket(proxy);\n        return socket;\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n        StringBuilder requestHeaders = new StringBuilder();\n        requestHeaders\n                .append(\"HTTP \" + proxyHost + \":\" + proxyPort + \" HTTP/1.1\\r\\n\")\n                .append(\"Host: \" + proxyHost + \":\" + proxyPort + \"\\r\\n\");\n        String proxyAuth = getBasicAuthStr();\n        if (proxyAuth != null) {\n            requestHeaders\n                    .append(\"Proxy-Authorization: basic \" + proxyAuth + \"\\r\\n\");\n        }\n        requestHeaders.append(\"\\r\\n\");\n        out.write(requestHeaders.toString().getBytes(\"utf-8\"));\n        out.flush();\n\n        String statusLine = readLine(in);\n        if (statusLine == null) {\n            socket.close();\n            throw new IOException(\"Proxy sent blank response\");\n        }\n\n        int responseCode = getResponseCode(statusLine);\n        if (responseCode < 200 && responseCode >= 300) {\n            socket.close();\n            throw new IOException(\"Invalid response code: \" + responseCode);\n        }\n\n        while (true) {\n            String line = readLine(in);\n            if (line.length() < 1)\n                break;\n        }\n    }\n\n    private String getBasicAuthStr() {\n        if (proxyUser != null && proxyUser.length() > 0) {\n            try {\n                return (Base64.getEncoder().encodeToString(\n                        (proxyUser + \":\" + (proxyPass == null ? \"\" : proxyPass))\n                                .getBytes(\"utf-8\")));\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n\n    public final String readLine(InputStream in) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        while (true) {\n            int x = in.read();\n            if (x == -1)\n                throw new IOException(\n                        \"Unexpected EOF while reading header line\");\n            if (x == '\\n')\n                return buf.toString();\n            if (x != '\\r')\n                buf.append((char) x);\n        }\n    }\n\n    public static final int getResponseCode(String statusLine) {\n        String arr[] = statusLine.split(\" \");\n        if (arr.length < 2)\n            return 400;\n        return Integer.parseInt(arr[1]);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class CustomSocketFactory extends SocketFactory {\n    private String proxyHost;\n    private int proxyPort;\n    private String proxyUser;\n    private String proxyPass;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyType = proxyType;\n    }\n\n    public CustomSocketFactory(String proxyHost, int proxyPort, String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this(proxyHost, proxyPort, proxyType);\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port) throws IOException {\n        return createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {\n        if (proxyType == Proxy.Type.SOCKS) {\n            Proxy proxy = new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(proxyHost, proxyPort));\n            Socket socket = new Socket(proxy);\n            socket.connect(new InetSocketAddress(host, port), 5000);\n            return socket;\n        } else if (proxyType == Proxy.Type.HTTP) {\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(proxyHost, proxyPort), 5000);\n            connectToProxy(socket);\n            return socket;\n        } else {\n            return new Socket(host, port, localHost, localPort);\n        }\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n        return createSocket(address.getHostAddress(), port, localAddress, localPort);\n    }\n\n    public Socket createSocket() throws IOException {\n        if (proxyType == Proxy.Type.SOCKS) {\n            return new Socket(new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(proxyHost, proxyPort)));\n        } else if (proxyType == Proxy.Type.HTTP) {\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(proxyHost, proxyPort), 5000);\n            connectToProxy(socket);\n            return socket;\n        } else {\n            return new Socket();\n        }\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        OutputStream out = socket.getOutputStream();\n        InputStream in = socket.getInputStream();\n\n        String request = \"CONNECT \" + proxyHost + \":\" + proxyPort + \" HTTP/1.1\\r\\n\" +\n                \"Host: \" + proxyHost + \":\" + proxyPort + \"\\r\\n\";\n\n        if (proxyUser != null && proxyPass != null) {\n            String auth = getBasicAuthStr();\n            request += \"Proxy-Authorization: Basic \" + auth + \"\\r\\n\";\n        }\n\n        request += \"\\r\\n\";\n        out.write(request.getBytes());\n        out.flush();\n\n        String statusLine = readLine(in);\n        int responseCode = getResponseCode(statusLine);\n\n        if (responseCode != 200) {\n            throw new IOException(\"HTTP proxy connection failed: \" + statusLine);\n        }\n\n        while (true) {\n            String line = readLine(in);\n            if (line.isEmpty()) break;\n        }\n    }\n\n    private String getBasicAuthStr() {\n        String userPass = proxyUser + \":\" + proxyPass;\n        return Base64.getEncoder().encodeToString(userPass.getBytes());\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = in.read()) >= 0) {\n            sb.append((char) c);\n            if (c == '\\n') break;\n        }\n        return sb.toString().trim();\n    }\n\n    private static int getResponseCode(String statusLine) {\n        if (statusLine == null || statusLine.length() < 4) return -1;\n        try {\n            return Integer.parseInt(statusLine.substring(0, 3));\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    }\n}"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a Java class that provides functionality to read and check the existence of URL-based resources, with support for character encoding.\n\nClass Description: The UrlTemplateResource class is designed to handle URL resources by providing methods to read their content and check their existence. It supports specifying character encoding for proper text reading and handles both regular URL connections and HTTP-specific operations.\n\nAttributes:\n- url: URL - The URL of the resource to be accessed\n- characterEncoding: String - The character encoding to be used when reading the resource (can be null)\n\nMethods:\n- Constructor: UrlTemplateResource(String path, String characterEncoding) -> void - Creates an instance with a URL path string and character encoding\n- Constructor: UrlTemplateResource(URL url, String characterEncoding) -> void - Creates an instance with a URL object and character encoding\n- reader: reader() -> Reader - Returns a Reader for the URL resource with optional character encoding\n- inputStream: inputStream() -> InputStream - Internal method that opens and returns an InputStream for the URL\n- exists: exists() -> boolean - Checks if the URL resource exists by attempting to connect to it",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic final class UrlTemplateResource {\n\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(final String path, final String characterEncoding) throws MalformedURLException {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(final URL url, final String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        final InputStream inputStream = inputStream();\n        if (this.characterEncoding != null && !this.characterEncoding.trim().isEmpty()) {\n            return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream), this.characterEncoding));\n        }\n        return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream)));\n    }\n\n    private InputStream inputStream() throws IOException {\n        final URLConnection connection = this.url.openConnection();\n        if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n            connection.setUseCaches(true);\n        }\n\n        final InputStream inputStream;\n        try {\n            inputStream = connection.getInputStream();\n        } catch (final IOException e) {\n            if (connection instanceof HttpURLConnection) {\n                ((HttpURLConnection) connection).disconnect();\n            }\n            throw e;\n        }\n        return inputStream;\n    }\n\n    public boolean exists() {\n        try {\n            final URLConnection connection = this.url.openConnection();\n            if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n                connection.setUseCaches(true);\n            }\n\n            if (connection instanceof HttpURLConnection) {\n                final HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestMethod(\"HEAD\");\n                int responseCode = httpConnection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    return true;\n                } else if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n                    return false;\n                }\n                if (httpConnection.getContentLength() >= 0) {\n                    return true;\n                }\n                httpConnection.disconnect();\n                return false;\n            }\n\n            if (connection.getContentLength() >= 0) {\n                return true;\n            }\n\n            final InputStream is = inputStream();\n            is.close();\n            return true;\n        } catch (final IOException ignored) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class UrlTemplateResource {\n    private URL url;\n    private String characterEncoding;\n\n    public UrlTemplateResource(String path, String characterEncoding) throws MalformedURLException {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(URL url, String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        if (characterEncoding != null) {\n            return new InputStreamReader(inputStream(), characterEncoding);\n        } else {\n            return new InputStreamReader(inputStream());\n        }\n    }\n\n    private InputStream inputStream() throws IOException {\n        URLConnection connection = url.openConnection();\n        if (connection instanceof HttpURLConnection) {\n            HttpURLConnection httpConnection = (HttpURLConnection) connection;\n            int responseCode = httpConnection.getResponseCode();\n            if (responseCode >= 400) {\n                throw new FileNotFoundException(\"Resource not found: \" + url);\n            }\n        }\n        return connection.getInputStream();\n    }\n\n    public boolean exists() {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                int responseCode = httpConnection.getResponseCode();\n                return responseCode < 400;\n            } else {\n                // For non-HTTP URLs, try to open the input stream\n                InputStream is = connection.getInputStream();\n                is.close();\n                return true;\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 590,
    "Instruction": "Task Description: Write a Java function that tests the behavior of a servlet when the client closes the socket early during an HTTP POST request. The function should verify that the servlet properly handles the premature connection closure by detecting an exception and not completing normally.\n\nFunction Description: The function `testServletInputStreamEarlyClose` creates a TCP client socket, sends an HTTP POST request with a large body, and immediately closes the socket before the server can fully process the request. It then verifies that the servlet detected the premature closure through exception handling.\n\nInput: None (The function uses predefined constants and helper classes like `DefaultServer`, `TestHttpClient`, and `EarlyCloseClientServlet`)\n\nOutput: None (The function asserts expected behavior through JUnit assertions. Side effects include socket communication and servlet state changes)",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic void testServletInputStreamEarlyClose() throws Exception {\n    Assume.assumeFalse(DefaultServer.isH2());\n    TestHttpClient client = new TestHttpClient();\n    EarlyCloseClientServlet.reset();\n    try (Socket socket = new Socket()) {\n        socket.connect(DefaultServer.getDefaultServerAddress());\n        try {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 10000; ++i) {\n                sb.append(\"hello world\\r\\n\");\n            }\n            String request = \"POST /servletContext/\" + SERVLET + \" HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n            OutputStream outputStream = socket.getOutputStream();\n\n            outputStream.write(request.getBytes(\"US-ASCII\"));\n            outputStream.flush();\n            socket.close();\n\n            Assert.assertTrue(EarlyCloseClientServlet.getLatch().await(10, TimeUnit.SECONDS));\n            Assert.assertFalse(EarlyCloseClientServlet.isCompletedNormally());\n            Assert.assertTrue(EarlyCloseClientServlet.isExceptionThrown());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.junit.*;\n\npublic class EarlyCloseTest {\n\n    @Test\n    public void testServletInputStreamEarlyClose() throws Exception {\n        int port = 8080;\n        DefaultServer server = new DefaultServer(port);\n        server.start();\n\n        Socket socket = new Socket(\"localhost\", port);\n        OutputStream out = socket.getOutputStream();\n        String request = \"POST /earlyClose HTTP/1.1\\r\\n\" +\n                         \"Host: localhost\\r\\n\" +\n                         \"Content-Length: 1000000\\r\\n\" +\n                         \"\\r\\n\";\n        out.write(request.getBytes());\n        for (int i = 0; i < 1000 && !socket.isClosed(); i++) {\n            try {\n                out.write((\"x\").repeat(1024).getBytes());\n            } catch (IOException e) {\n                break;\n            }\n        }\n\n        socket.close();\n\n        Thread.sleep(2000);\n\n        Assert.assertTrue(EarlyCloseClientServlet.isEarlyCloseDetected());\n\n        server.stop();\n    }\n}\n\nclass DefaultServer {\n    private final int port;\n    private HttpServer httpServer;\n\n    public DefaultServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        httpServer = HttpServer.create(new InetSocketAddress(port), 0);\n        httpServer.createContext(\"/earlyClose\", new EarlyCloseClientServlet());\n        httpServer.setExecutor(null);\n        httpServer.start();\n    }\n\n    public void stop() {\n        httpServer.stop(0);\n    }\n}\n\nclass EarlyCloseClientServlet extends HttpServlet {\n    private static volatile boolean earlyCloseDetected = false;\n\n    public static boolean isEarlyCloseDetected() {\n        return earlyCloseDetected;\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) {\n        try (ServletInputStream input = req.getInputStream()) {\n            byte[] buffer = new byte[1024];\n            while (input.read(buffer) != -1) {\n                // Simulate processing delay\n                Thread.sleep(10);\n            }\n        } catch (IOException | InterruptedException e) {\n            earlyCloseDetected = true;\n        }\n    }\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for downloading images and handling multipart form data submissions.\n\nClass Description: The HttpClient class provides methods to download images via HTTP POST requests and to construct and send multipart form data (including both text parameters and file attachments) to a server. It handles connection management, request configuration, and response processing.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart form data (default \"--\")\n- boundary: String - Unique boundary string for multipart requests (generated with timestamp)\n\nMethods:\n- HttpClient(String url) -> None - Constructor that initializes the client with target URL\n- downloadImage(String imgName) -> byte[] - Downloads an image by sending the image name as a POST parameter and returns the image data as byte array\n- connectForMultipart() -> void - Initializes connection for multipart form data submission\n- addFormPart(String paramName, String value) -> void - Adds a text parameter to multipart form data\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file attachment to multipart form data\n- finishMultipart() -> void - Finalizes the multipart form data construction\n- getResponse() -> String - Retrieves and returns the server response as a string\n- writeParamData(String paramName, String value) -> void - Internal helper method for writing form parameters",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    public HttpClient(String url) {        \n        this.url = url;\n    }\n    \n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.connect();\n            con.getOutputStream().write( (\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while ( is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.connect();\n        os = con.getOutputStream();\n    }\n    \n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n    \n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName +  \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Type: application/octet-stream\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Transfer-Encoding: binary\\r\\n\"  ).getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        \n        os.write(\"\\r\\n\".getBytes());\n    }\n    \n    public void finishMultipart() throws Exception {\n        os.write( (delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n    \n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while ( is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n    \n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( \"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());;\n        os.write( (\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter = \"--\";\n    private String boundary;\n\n    public HttpClient(String url) {\n        this.url = url;\n        this.boundary = \"Boundary_\" + new Date().getTime();\n    }\n\n    public byte[] downloadImage(String imgName) throws IOException {\n        URL obj = new URL(url);\n        HttpURLConnection connection = (HttpURLConnection) obj.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n\n        try (OutputStream output = connection.getOutputStream();\n             BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8))) {\n            writer.write(imgName);\n        }\n\n        try (InputStream response = connection.getInputStream()) {\n            return readStream(response);\n        }\n    }\n\n    private byte[] readStream(InputStream inputStream) throws IOException {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = inputStream.read(buffer)) != -1) {\n            byteArrayOutputStream.write(buffer, 0, length);\n        }\n        return byteArrayOutputStream.toByteArray();\n    }\n\n    public void connectForMultipart() throws IOException {\n        con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.connect();\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws IOException {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws IOException {\n        StringBuilder builder = new StringBuilder();\n        builder.append(delimiter).append(boundary).append(\"\\r\\n\");\n        builder.append(\"Content-Disposition: form-data; name=\\\"\").append(paramName).append(\"\\\"; filename=\\\"\").append(fileName).append(\"\\\"\\r\\n\");\n        builder.append(\"Content-Type: application/octet-stream\\r\\n\\r\\n\");\n        os.write(builder.toString().getBytes(StandardCharsets.UTF_8));\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    public void finishMultipart() throws IOException {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws IOException {\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK || responseCode == HttpURLConnection.HTTP_CREATED) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()))) {\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                return response.toString();\n            }\n        } else {\n            throw new IOException(\"Server responded with code: \" + responseCode);\n        }\n    }\n\n    private void writeParamData(String paramName, String value) throws IOException {\n        StringBuilder builder = new StringBuilder();\n        builder.append(delimiter).append(boundary).append(\"\\r\\n\");\n        builder.append(\"Content-Disposition: form-data; name=\\\"\").append(paramName).append(\"\\\"\\r\\n\");\n        builder.append(\"Content-Type: text/plain; charset=\").append(StandardCharsets.UTF_8.name()).append(\"\\r\\n\\r\\n\");\n        builder.append(value).append(\"\\r\\n\");\n        os.write(builder.toString().getBytes(StandardCharsets.UTF_8));\n    }\n}"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests (GET and POST) using HttpURLConnection, with proper error handling and response processing.\n\nClass Description: HttpUtils is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests, manages connection settings, processes responses, and includes custom error handling for HTTP errors.\n\nAttributes:\n\nError.responseCode: int - The HTTP response code when an error occurs\nError.output: String - The error response body from the server\n\nMethods:\n\npost: post(String request) -> String - Makes a POST request to the specified URL with an empty body\npost: post(String request, String body) -> String - Makes a POST request to the specified URL with the given body\nget: get(String request) -> String - Makes a GET request to the specified URL with default timeout\nget: get(String request, IOUtils.LineRead callback, int timeout) -> String - Makes a GET request to the specified URL with custom timeout and response line callback\nhandleResponse: handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) -> String - Internal method to process the HTTP response\nError.toString: toString() -> String - Returns a string representation of the error including response code and output",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n\n    public static String post(String request) throws Exception {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(body.getBytes().length));\n            connection.setUseCaches(false);\n            connection.setConnectTimeout(60000);\n            connection.setReadTimeout(60000);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            try {\n                wr.writeBytes(body);\n                wr.flush();\n            } finally {\n                wr.close();\n            }\n            return handleResponse(connection, null);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    public static String get(String request) throws Exception {\n        return get(request, null, 3000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setUseCaches(false);\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            return handleResponse(connection, callback);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws Exception {\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return IOUtils.readAll(connection.getInputStream(), callback);\n        } else {\n            throw new Error(responseCode, IOUtils.readAll(connection.getErrorStream(), callback));\n        }\n    }\n\n    public static class Error extends RuntimeException {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n    public static class Error extends Exception {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"HttpError{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n\n    public interface LineRead {\n        void onLine(String line);\n    }\n\n    public static String post(String request) throws Error {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Error {\n        try {\n            URL url = new URL(request);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = body.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n\n            return handleResponse(conn, null);\n        } catch (IOException e) {\n            throw new Error(-1, e.getMessage());\n        }\n    }\n\n    public static String get(String request) throws Error {\n        return get(request, null, 5000);\n    }\n\n    public static String get(String request, LineRead callback, int timeout) throws Error {\n        try {\n            URL url = new URL(request);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout(timeout);\n            conn.setReadTimeout(timeout);\n\n            return handleResponse(conn, callback);\n        } catch (IOException e) {\n            throw new Error(-1, e.getMessage());\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection connection, LineRead callback) throws Error {\n        try {\n            int responseCode = connection.getResponseCode();\n            StringBuilder response = new StringBuilder();\n\n            try (BufferedReader reader = new BufferedReader(\n                    new InputStreamReader((responseCode >= 400 ? connection.getErrorStream() : connection.getInputStream())))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                    if (callback != null) {\n                        callback.onLine(line);\n                    }\n                }\n            }\n\n            if (responseCode >= 400) {\n                throw new Error(responseCode, response.toString());\n            }\n\n            return response.toString();\n        } catch (IOException e) {\n            throw new Error(connection.getResponseCode(), e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a function to check if a given URL is accessible and usable by sending a HEAD request and verifying the HTTP response code.\n\nFunction Description: The function checks the accessibility of a URL by attempting to establish a connection and sending a HEAD request. It returns true if the URL responds with HTTP OK (status code 200), indicating it's usable, and false otherwise (including invalid URLs or connection failures).\n\nInput: \n- url: String - The URL to be checked for accessibility.\n\nOutput: \n- boolean - Returns true if the URL is accessible (HTTP status code 200), false otherwise.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic static boolean isUrlUsable(String url) {\n    if (CommonUtils.isEmpty(url)) {\n        return false;\n    }\n\n    URL urlTemp = null;\n    HttpURLConnection connt = null;\n    try {\n        urlTemp = new URL(url);\n        connt = (HttpURLConnection) urlTemp.openConnection();\n        connt.setRequestMethod(\"HEAD\");\n        int returnCode = connt.getResponseCode();\n        if (returnCode == HttpURLConnection.HTTP_OK) {\n            return true;\n        }\n    } catch (Exception e) {\n        return false;\n    } finally {\n        connt.disconnect();\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\npublic class UrlChecker {\n    public static boolean isUrlAccessible(String url) {\n        try {\n            URL urlObj = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();\n            connection.setRequestMethod(\"HEAD\");\n            int responseCode = connection.getResponseCode();\n            return responseCode == HttpURLConnection.HTTP_OK;\n        } catch (MalformedURLException e) {\n            return false;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for sending feedback data to a remote server using HttpURLConnection.\n\nClass Description: The HttpFeedbackClient class provides functionality to send feedback content and environment information to a specified URL via HTTP POST request. It handles connection setup, parameter encoding, request sending, and response handling with appropriate callbacks for success or failure scenarios.\n\nAttributes:\ncontent: String - The feedback content to be sent to the server\nenv: String - The environment information associated with the feedback\ncallback: OnRequestCallback - The callback interface for handling request results\n\nMethods:\nsendFeedback: sendFeedback() -> void - Sends the feedback data to the server. Sets up the HTTP connection, encodes parameters, writes the request body, and processes the response. Calls onSuccess() or onFailure() on the callback object depending on the outcome.\n\nNote: The OnRequestCallback interface (not shown in the reference code) would typically contain two methods:\n- onSuccess(): Called when the request completes successfully\n- onFailure(Exception e): Called when the request fails, with the exception that occurred",
    "Canonical_solution": "import com.antfortune.freeline.idea.utils.NotificationUtils;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpFeedbackClient {\n\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"content\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(content, \"UTF-8\"));\n            builder.append(\"&\");\n            builder.append(URLEncoder.encode(\"env\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(env, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\npublic class HttpFeedbackClient {\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        new Thread(() -> {\n            try {\n                URL url = new URL(\"https://example.com/feedback\");\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(\"POST\");\n                conn.setDoOutput(true);\n                conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n                String postData = \"content=\" + java.net.URLEncoder.encode(content, StandardCharsets.UTF_8.toString()) +\n                                  \"&env=\" + java.net.URLEncoder.encode(env, StandardCharsets.UTF_8.toString());\n\n                try (OutputStream os = conn.getOutputStream()) {\n                    os.write(postData.getBytes(StandardCharsets.UTF_8));\n                }\n\n                int responseCode = conn.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    callback.onSuccess();\n                } else {\n                    callback.onFailure(new Exception(\"Server returned HTTP code: \" + responseCode));\n                }\n            } catch (Exception e) {\n                callback.onFailure(e);\n            }\n        }).start();\n    }\n}\n\ninterface OnRequestCallback {\n    void onSuccess();\n    void onFailure(Exception e);\n}"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Implement a class that handles preloading of HTTP content in the background using a thread pool, with support for cancellation and blacklisting of failed URLs.\n\nClass Description: The PreloadTask class is a Runnable implementation that preloads HTTP content from a given URL up to a specified length. It manages connection timeouts, handles failures by blacklisting URLs, and supports task cancellation. The class works with an HttpProxyCacheServer to get proxied URLs and executes tasks through an ExecutorService.\n\nAttributes:\n- mRawUrl: String - The original URL to be preloaded\n- mPosition: int - The position/index of this preload task (optional tracking)\n- mCacheServer: HttpProxyCacheServer - The proxy server used to get cached URLs\n- mIsCanceled: boolean - Flag indicating if the task was canceled\n- mIsExecuted: boolean - Flag indicating if the task was executed\n- blackList: static List<String> - Shared list of URLs that failed to load\n\nMethods:\n- run(): void - The main execution method called by the thread pool, which starts the preload task if not canceled\n- start(): void - Internal method that performs the actual HTTP request and content preloading\n- executeOn(ExecutorService executorService): void - Submits the task to the provided executor service\n- cancel(): void - Cancels the task if it has been executed but not completed",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PreloadTask implements Runnable {\n\n    public String mRawUrl;\n    public int mPosition;\n    public HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled;\n    private boolean mIsExecuted;\n    private final static List<String> blackList = new ArrayList<>();\n\n    @Override\n    public void run() {\n        if (!mIsCanceled) {\n            start();\n        }\n        mIsExecuted = false;\n        mIsCanceled = false;\n    }\n\n    private void start() {\n        if (blackList.contains(mRawUrl)) return;\n        HttpURLConnection connection = null;\n        try {\n            String proxyUrl = mCacheServer.getProxyUrl(mRawUrl);\n            URL url = new URL(proxyUrl);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5_000);\n            connection.setReadTimeout(5_000);\n            InputStream in = new BufferedInputStream(connection.getInputStream());\n            int length;\n            int read = -1;\n            byte[] bytes = new byte[8 * 1024];\n            while ((length = in.read(bytes)) != -1) {\n                read += length;\n                if (mIsCanceled || read >= PreloadManager.PRELOAD_LENGTH) {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            blackList.add(mRawUrl);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        if (mIsExecuted) return;\n        mIsExecuted = true;\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        if (mIsExecuted) {\n            mIsCanceled = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class PreloadTask implements Runnable {\n    private final String mRawUrl;\n    private final int mPosition;\n    private final HttpProxyCacheServer mCacheServer;\n    private static List<String> blackList;\n    private final AtomicBoolean mIsCanceled = new AtomicBoolean(false);\n    private final AtomicBoolean mIsExecuted = new AtomicBoolean(false);\n\n    public PreloadTask(String rawUrl, int position, HttpProxyCacheServer cacheServer, List<String> failedUrlsList) {\n        this.mRawUrl = rawUrl;\n        this.mPosition = position;\n        this.mCacheServer = cacheServer;\n        this.blackList = failedUrlsList;\n    }\n\n    @Override\n    public void run() {\n        if (mIsCanceled.get()) return;\n        mIsExecuted.set(true);\n        start();\n    }\n\n    private void start() {\n        try {\n            URL url = new URL(mCacheServer.getProxyUrl(mRawUrl));\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.connect();\n\n            if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                // Simulate reading content up to a limit\n                // In real implementation, use InputStream and read up to specified length\n            } else {\n                throw new IOException(\"HTTP error code: \" + connection.getResponseCode());\n            }\n        } catch (IOException e) {\n            synchronized (blackList) {\n                if (!blackList.contains(mRawUrl)) {\n                    blackList.add(mRawUrl);\n                }\n            }\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        mIsCanceled.set(true);\n    }\n}"
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, specifically designed for Android applications to fetch and process JSON data from a server.\n\nClass Description: HttpRequestHandler is a utility class containing an inner AsyncTask subclass (MyAsyncTaskgetNews) that performs HTTP GET requests in the background. It handles connection setup, timeout configuration, input stream processing, and JSON response parsing. The class demonstrates typical operations for user authentication flows.\n\nAttributes:\n- None (All required objects are created locally within methods)\n\nMethods:\n- MyAsyncTaskgetNews: [Inner Class] - Extends AsyncTask<String, String, String> to perform network operations off the UI thread\n  - doInBackground(String... params) -> String - Main execution method that:\n    1. Takes URL string as input parameter\n    2. Establishes HTTP connection with 7-second timeout\n    3. Reads input stream and converts to string\n    4. Publishes progress with response data\n    5. Returns null (results handled via progress updates)\n  \n  - onProgressUpdate(String... progress) -> void - UI thread callback that:\n    1. Parses JSON response\n    2. Handles \"user is added\" case by showing toast and initiating login\n    3. Processes successful login by saving user credentials\n    4. Handles errors via logging\n\nNote: The class assumes existence of helper classes (Operations for stream conversion, SaveSettings for persistence) and Android context availability via getApplicationContext().",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(getApplicationContext());\n                    NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                if (json.getString(\"msg\") == null)\n                    return;\n                if (json.getString(\"msg\").equalsIgnoreCase(\"user is added\")) {\n                    Toast.makeText(getApplicationContext(), json.getString(\"msg\"), Toast.LENGTH_LONG).show();\n                    String url = \"http://10.0.2.2/~hussienalrubaye/twitterserver/login.php?email=\" + etEmail.getText().toString() + \"&password=\" + etPassword.getText().toString();\n                    new MyAsyncTaskgetNews().execute(url);\n                }\n\n                if (json.getString(\"msg\").equalsIgnoreCase(\"Pass Login\")) {\n                    JSONArray UserInfo = new JSONArray(json.getString(\"info\"));\n                    JSONObject UserCreintal = UserInfo.getJSONObject(0);\n                    hideProgressDialog();\n                    SaveSettings saveSettings = new SaveSettings(getApplicationContext());\n                    saveSettings.SaveData(UserCreintal.getString(\"user_id\"));\n                    finish();\n                }\n            } catch (Exception ex) {\n                Log.d(\"er\", ex.getMessage());\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.os.AsyncTask;\nimport android.util.Log;\nimport android.widget.Toast;\nimport org.json.JSONObject;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.setReadTimeout(7000);\n                connection.setConnectTimeout(7000);\n                connection.connect();\n\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                StringBuilder result = new StringBuilder();\n                String line;\n\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n\n                String response = result.toString();\n                publishProgress(response);\n\n            } catch (Exception e) {\n                Log.e(\"HttpRequestHandler\", \"Error during HTTP request: \" + e.getMessage());\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n\n                if (json.has(\"message\") && json.getString(\"message\").equals(\"user is added\")) {\n                    Toast.makeText(getApplicationContext(), \"User registered successfully\", Toast.LENGTH_SHORT).show();\n                    // Assuming login initiation logic here\n                }\n\n                if (json.has(\"success\") && json.getBoolean(\"success\")) {\n                    JSONObject user = json.getJSONObject(\"user\");\n                    SaveSettings.saveUserCredentials(getApplicationContext(), user.getString(\"token\"));\n                }\n\n            } catch (Exception e) {\n                Log.e(\"HttpRequestHandler\", \"JSON parsing error: \" + e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Implement a Java class for handling Microsoft authentication flows, including acquiring access tokens, Xbox Live tokens, and XSTS tokens for Minecraft services authentication.\n\nClass Description: The MicrosoftHttpClient class provides methods to authenticate with Microsoft's OAuth2.0 service and obtain various tokens required for Xbox Live and Minecraft services authentication. It handles HTTP communication with Microsoft's authentication endpoints and processes JSON responses.\n\nAttributes:\nXSTS_ERRORS: Map<Long, Integer> - A static map containing XSTS error codes mapped to corresponding error message resource IDs\n\nMethods:\nacquireAccessToken: acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) -> String - Acquires an OAuth access token from Microsoft's authentication service. Uses either an authorization code or refresh token based on the isRefresh parameter.\n\nacquireXBLToken: acquireXBLToken(String accessToken, String xblAuthUrl) -> String - Acquires an Xbox Live (XBL) token using the Microsoft OAuth access token.\n\nacquireXsts: acquireXsts(String xblToken, String xstsAuthUrl) -> String[] - Acquires XSTS (Xbox Secure Token Service) token and user hash using the XBL token. Returns an array containing the user hash and token.\n\nsetCommonProperties: setCommonProperties(HttpURLConnection conn, String formData) -> void - Helper method to set common HTTP connection properties for JSON requests.\n\nconvertToFormData: convertToFormData(String... data) -> String - Converts key-value pairs into URL-encoded form data format.\n\ngetResponseThrowable: getResponseThrowable(HttpURLConnection conn) -> RuntimeException - Creates an appropriate exception based on HTTP response status code.",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n\n    private static final Map<Long, Integer> XSTS_ERRORS;\n    static {\n        XSTS_ERRORS = new ArrayMap<>();\n        XSTS_ERRORS.put(2148916233L, R.string.xerr_no_account);\n        XSTS_ERRORS.put(2148916235L, R.string.xerr_not_available);\n        XSTS_ERRORS.put(2148916236L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916237L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916238L ,R.string.xerr_child);\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException, JSONException {\n        URL url = new URL(authTokenUrl);\n        Log.i(\"MicrosoftLogin\", \"isRefresh=\" + isRefresh + \", authCode= \"+authcode);\n\n        String formData = convertToFormData(\n                \"client_id\", \"00000000402b5328\",\n                isRefresh ? \"refresh_token\" : \"code\", authcode,\n                \"grant_type\", isRefresh ? \"refresh_token\" : \"authorization_code\",\n                \"redirect_url\", \"https://login.live.com/oauth20_desktop.srf\",\n                \"scope\", \"service::user.auth.xboxlive.com::MBI_SSL\"\n        );\n\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n        conn.setRequestMethod(\"POST\");\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n        conn.connect();\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(formData.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"access_token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xblAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"AuthMethod\", \"RPS\");\n        properties.put(\"SiteName\", \"user.auth.xboxlive.com\");\n        properties.put(\"RpsTicket\", accessToken);\n        data.put(\"Properties\",properties);\n        data.put(\"RelyingParty\", \"http://auth.xboxlive.com\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"Token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xstsAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"SandboxId\", \"RETAIL\");\n        properties.put(\"UserTokens\", new JSONArray(Collections.singleton(xblToken)));\n        data.put(\"Properties\", properties);\n        data.put(\"RelyingParty\", \"rp://api.minecraftservices.com/\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            String uhs = jo.getJSONObject(\"DisplayClaims\").getJSONArray(\"xui\").getJSONObject(0).getString(\"uhs\");\n            String token = jo.getString(\"Token\");\n            conn.disconnect();\n            return new String[]{uhs, token};\n        }else if(conn.getResponseCode() == 401) {\n            String responseContents = Tools.read(conn.getErrorStream());\n            JSONObject jo = new JSONObject(responseContents);\n            long xerr = jo.optLong(\"XErr\", -1);\n            Integer locale_id = XSTS_ERRORS.get(xerr);\n            if(locale_id != null) {\n                throw new PresentedException(new RuntimeException(responseContents), locale_id);\n            }\n            throw new PresentedException(new RuntimeException(responseContents), R.string.xerr_unknown, xerr);\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    private static void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        try {\n            conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n            conn.setRequestMethod(\"POST\");\n        }catch (ProtocolException e) {\n            Log.e(\"MicrosoftAuth\", e.toString());\n        }\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n    }\n\n    private static String convertToFormData(String... data) throws UnsupportedEncodingException {\n        StringBuilder builder = new StringBuilder();\n        for(int i=0; i<data.length; i+=2){\n            if (builder.length() > 0) builder.append(\"&\");\n            builder.append(URLEncoder.encode(data[i], \"UTF-8\"))\n                    .append(\"=\")\n                    .append(URLEncoder.encode(data[i+1], \"UTF-8\"));\n        }\n        return builder.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        Log.i(\"MicrosoftLogin\", \"Error code: \" + conn.getResponseCode() + \": \" + conn.getResponseMessage());\n        if(conn.getResponseCode() == 429) {\n            return new PresentedException(R.string.microsoft_login_retry_later);\n        }\n        return new RuntimeException(conn.getResponseMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n    private static final Map<Long, Integer> XSTS_ERRORS = new HashMap<>();\n\n    static {\n        XSTS_ERRORS.put(2148916233L, 0);\n        XSTS_ERRORS.put(2148916235L, 1);\n        XSTS_ERRORS.put(2148916236L, 2);\n        XSTS_ERRORS.put(2148916238L, 3);\n        XSTS_ERRORS.put(2148916239L, 4);\n        XSTS_ERRORS.put(2148916415L, 5);\n        XSTS_ERRORS.put(2148916417L, 6);\n        XSTS_ERRORS.put(2148916418L, 7);\n        XSTS_ERRORS.put(2148916419L, 8);\n        XSTS_ERRORS.put(2148916420L, 9);\n        XSTS_ERRORS.put(2148916421L, 10);\n        XSTS_ERRORS.put(2148916422L, 11);\n        XSTS_ERRORS.put(2148916423L, 12);\n        XSTS_ERRORS.put(2148916424L, 13);\n        XSTS_ERRORS.put(2148916425L, 14);\n        XSTS_ERRORS.put(2148916426L, 15);\n        XSTS_ERRORS.put(2148916427L, 16);\n        XSTS_ERRORS.put(2148916428L, 17);\n        XSTS_ERRORS.put(2148916430L, 18);\n        XSTS_ERRORS.put(2148916431L, 19);\n        XSTS_ERRORS.put(2148916432L, 20);\n        XSTS_ERRORS.put(2148916433L, 21);\n        XSTS_ERRORS.put(2148916434L, 22);\n        XSTS_ERRORS.put(2148916435L, 23);\n        XSTS_ERRORS.put(2148916436L, 24);\n        XSTS_ERRORS.put(2148916437L, 25);\n        XSTS_ERRORS.put(2148916438L, 26);\n        XSTS_ERRORS.put(2148916439L, 27);\n        XSTS_ERRORS.put(2148916440L, 28);\n        XSTS_ERRORS.put(2148916441L, 29);\n        XSTS_ERRORS.put(2148916442L, 30);\n        XSTS_ERRORS.put(2148916443L, 31);\n        XSTS_ERRORS.put(2148916444L, 32);\n        XSTS_ERRORS.put(2148916445L, 33);\n        XSTS_ERRORS.put(2148916446L, 34);\n        XSTS_ERRORS.put(2148916447L, 35);\n        XSTS_ERRORS.put(2148916448L, 36);\n        XSTS_ERRORS.put(2148916449L, 37);\n        XSTS_ERRORS.put(2148916450L, 38);\n        XSTS_ERRORS.put(2148916451L, 39);\n        XSTS_ERRORS.put(2148916452L, 40);\n        XSTS_ERRORS.put(2148916453L, 41);\n        XSTS_ERRORS.put(2148916454L, 42);\n        XSTS_ERRORS.put(2148916455L, 43);\n        XSTS_ERRORS.put(2148916456L, 44);\n        XSTS_ERRORS.put(2148916457L, 45);\n        XSTS_ERRORS.put(2148916458L, 46);\n        XSTS_ERRORS.put(2148916459L, 47);\n        XSTS_ERRORS.put(2148916460L, 48);\n        XSTS_ERRORS.put(2148916461L, 49);\n        XSTS_ERRORS.put(2148916462L, 50);\n        XSTS_ERRORS.put(2148916463L, 51);\n        XSTS_ERRORS.put(2148916464L, 52);\n        XSTS_ERRORS.put(2148916465L, 53);\n        XSTS_ERRORS.put(2148916466L, 54);\n        XSTS_ERRORS.put(2148916467L, 55);\n        XSTS_ERRORS.put(2148916468L, 56);\n        XSTS_ERRORS.put(2148916469L, 57);\n        XSTS_ERRORS.put(2148916470L, 58);\n        XSTS_ERRORS.put(2148916471L, 59);\n        XSTS_ERRORS.put(2148916472L, 60);\n        XSTS_ERRORS.put(2148916473L, 61);\n        XSTS_ERRORS.put(2148916474L, 62);\n        XSTS_ERRORS.put(2148916475L, 63);\n        XSTS_ERRORS.put(2148916476L, 64);\n        XSTS_ERRORS.put(2148916477L, 65);\n        XSTS_ERRORS.put(2148916478L, 66);\n        XSTS_ERRORS.put(2148916479L, 67);\n        XSTS_ERRORS.put(2148916480L, 68);\n        XSTS_ERRORS.put(2148916481L, 69);\n        XSTS_ERRORS.put(2148916482L, 70);\n        XSTS_ERRORS.put(2148916483L, 71);\n        XSTS_ERRORS.put(2148916484L, 72);\n        XSTS_ERRORS.put(2148916485L, 73);\n        XSTS_ERRORS.put(2148916486L, 74);\n        XSTS_ERRORS.put(2148916487L, 75);\n        XSTS_ERRORS.put(2148916488L, 76);\n        XSTS_ERRORS.put(2148916489L, 77);\n        XSTS_ERRORS.put(2148916490L, 78);\n        XSTS_ERRORS.put(2148916491L, 79);\n        XSTS_ERRORS.put(2148916492L, 80);\n        XSTS_ERRORS.put(2148916493L, 81);\n        XSTS_ERRORS.put(2148916494L, 82);\n        XSTS_ERRORS.put(2148916495L, 83);\n        XSTS_ERRORS.put(2148916496L, 84);\n        XSTS_ERRORS.put(2148916497L, 85);\n        XSTS_ERRORS.put(2148916498L, 86);\n        XSTS_ERRORS.put(2148916499L, 87);\n        XSTS_ERRORS.put(2148916500L, 88);\n        XSTS_ERRORS.put(2148916501L, 89);\n        XSTS_ERRORS.put(2148916502L, 90);\n        XSTS_ERRORS.put(2148916503L, 91);\n        XSTS_ERRORS.put(2148916504L, 92);\n        XSTS_ERRORS.put(2148916505L, 93);\n        XSTS_ERRORS.put(2148916506L, 94);\n        XSTS_ERRORS.put(2148916507L, 95);\n        XSTS_ERRORS.put(2148916508L, 96);\n        XSTS_ERRORS.put(2148916509L, 97);\n        XSTS_ERRORS.put(2148916510L, 98);\n        XSTS_ERRORS.put(2148916511L, 99);\n        XSTS_ERRORS.put(2148916512L, 100);\n        XSTS_ERRORS.put(2148916513L, 101);\n        XSTS_ERRORS.put(2148916514L, 102);\n        XSTS_ERRORS.put(2148916515L, 103);\n        XSTS_ERRORS.put(2148916516L, 104);\n        XSTS_ERRORS.put(2148916517L, 105);\n        XSTS_ERRORS.put(2148916518L, 106);\n        XSTS_ERRORS.put(2148916519L, 107);\n        XSTS_ERRORS.put(2148916520L, 108);\n        XSTS_ERRORS.put(2148916521L, 109);\n        XSTS_ERRORS.put(2148916522L, 110);\n        XSTS_ERRORS.put(2148916523L, 111);\n        XSTS_ERRORS.put(2148916524L, 112);\n        XSTS_ERRORS.put(2148916525L, 113);\n        XSTS_ERRORS.put(2148916526L, 114);\n        XSTS_ERRORS.put(2148916527L, 115);\n        XSTS_ERRORS.put(2148916528L, 116);\n        XSTS_ERRORS.put(2148916529L, 117);\n        XSTS_ERRORS.put(2148916530L, 118);\n        XSTS_ERRORS.put(2148916531L, 119);\n        XSTS_ERRORS.put(2148916532L, 120);\n        XSTS_ERRORS.put(2148916533L, 121);\n        XSTS_ERRORS.put(2148916534L, 122);\n        XSTS_ERRORS.put(2148916535L, 123);\n        XSTS_ERRORS.put(2148916536L, 124);\n        XSTS_ERRORS.put(2148916537L, 125);\n        XSTS_ERRORS.put(2148916538L, 126);\n        XSTS_ERRORS.put(2148916539L, 127);\n        XSTS_ERRORS.put(2148916540L, 128);\n        XSTS_ERRORS.put(2148916541L, 129);\n        XSTS_ERRORS.put(2148916542L, 130);\n        XSTS_ERRORS.put(2148916543L, 131);\n        XSTS_ERRORS.put(2148916544L, 132);\n        XSTS_ERRORS.put(2148916545L, 133);\n        XSTS_ERRORS.put(2148916546L, 134);\n        XSTS_ERRORS.put(2148916547L, 135);\n        XSTS_ERRORS.put(2148916548L, 136);\n        XSTS_ERRORS.put(2148916549L, 137);\n        XSTS_ERRORS.put(2148916550L, 138);\n        XSTS_ERRORS.put(2148916551L, 139);\n        XSTS_ERRORS.put(2148916552L, 140);\n        XSTS_ERRORS.put(2148916553L, 141);\n        XSTS_ERRORS.put(2148916554L, 142);\n        XSTS_ERRORS.put(2148916555L, 143);\n        XSTS_ERRORS.put(2148916556L, 144);\n        XSTS_ERRORS.put(2148916557L, 145);\n        XSTS_ERRORS.put(2148916558L, 146);\n        XSTS_ERRORS.put(2148916559L, 147);\n        XSTS_ERRORS.put(2148916560L, 148);\n        XSTS_ERRORS.put(2148916561L, 149);\n        XSTS_ERRORS.put(2148916562L, 150);\n        XSTS_ERRORS.put(2148916563L, 151);\n        XSTS_ERRORS.put(2148916564L, 152);\n        XSTS_ERRORS.put(2148916565L, 153);\n        XSTS_ERRORS.put(2148916566L, 154);\n        XSTS_ERRORS.put(2148916567L, 155);\n        XSTS_ERRORS.put(2148916568L, 156);\n        XSTS_ERRORS.put(2148916569L, 157);\n        XSTS_ERRORS.put(2148916570L, 158);\n        XSTS_ERRORS.put(2148916571L, 159);\n        XSTS_ERRORS.put(2148916572L, 160);\n        XSTS_ERRORS.put(2148916573L, 161);\n        XSTS_ERRORS.put(2148916574L, 162);\n        XSTS_ERRORS.put(2148916575L, 163);\n        XSTS_ERRORS.put(2148916576L, 164);\n        XSTS_ERRORS.put(2148916577L, 165);\n        XSTS_ERRORS.put(2148916578L, 166);\n        XSTS_ERRORS.put(2148916579L, 167);\n        XSTS_ERRORS.put(2148916580L, 168);\n        XSTS_ERRORS.put(2148916581L, 169);\n        XSTS_ERRORS.put(2148916582L, 170);\n        XSTS_ERRORS.put(2148916583L, 171);\n        XSTS_ERRORS.put(2148916584L, 172);\n        XSTS_ERRORS.put(2148916585L, 173);\n        XSTS_ERRORS.put(2148916586L, 174);\n        XSTS_ERRORS.put(2148916587L, 175);\n        XSTS_ERRORS.put(2148916588L, 176);\n        XSTS_ERRORS.put(2148916589L, 177);\n        XSTS_ERRORS.put(2148916590L, 178);\n        XSTS_ERRORS.put(2148916591L, 179);\n        XSTS_ERRORS.put(2148916592L, 180);\n        XSTS_ERRORS.put(2148916593L, 181);\n        XSTS_ERRORS.put(2148916594L, 182);\n        XSTS_ERRORS.put(2148916595L, 183);\n        XSTS_ERRORS.put(2148916596L, 184);\n        XSTS_ERRORS.put(2148916597L, 185);\n        XSTS_ERRORS.put(2148916598L, 186);\n        XSTS_ERRORS.put(2148916599L, 187);\n        XSTS_ERRORS.put(2148916600L, 188);\n        XSTS_ERRORS.put(2148916601L, 189);\n        XSTS_ERRORS.put(2148916602L, 190);\n        XSTS_ERRORS.put(2148916603L, 191);\n        XSTS_ERRORS.put(2148916604L, 192);\n        XSTS_ERRORS.put(2148916605L, 193);\n        XSTS_ERRORS.put(2148916606L, 194);\n        XSTS_ERRORS.put(2148916607L, 195);\n        XSTS_ERRORS.put(2148916608L, 196);\n        XSTS_ERRORS.put(2148916609L, 197);\n        XSTS_ERRORS.put(2148916610L, 198);\n        XSTS_ERRORS.put(2148916611L, 199);\n        XSTS_ERRORS.put(2148916612L, 200);\n        XSTS_ERRORS.put(2148916613L, 201);\n        XSTS_ERRORS.put(2148916614L, 202);\n        XSTS_ERRORS.put(2148916615L, 203);\n        XSTS_ERRORS.put(2148916616L, 204);\n        XSTS_ERRORS.put(2148916617L, 205);\n        XSTS_ERRORS.put(2148916618L, 206);\n        XSTS_ERRORS.put(2148916619L, 207);\n        XSTS_ERRORS.put(2148916620L, 208);\n        XSTS_ERRORS.put(2148916621L, 209);\n        XSTS_ERRORS.put(2148916622L, 210);\n        XSTS_ERRORS.put(2148916623L, 211);\n        XSTS_ERRORS.put(2148916624L, 212);\n        XSTS_ERRORS.put(2148916625L, 213);\n        XSTS_ERRORS.put(2148916626L, 214);\n        XSTS_ERRORS.put(2148916627L, 215);\n        XSTS_ERRORS.put(2148916628L, 216);\n        XSTS_ERRORS.put(2148916629L, 217);\n        XSTS_ERRORS.put(2148916630L, 218);\n        XSTS_ERRORS.put(2148916631L, 219);\n        XSTS_ERRORS.put(2148916632L, 220);\n        XSTS_ERRORS.put(2148916633L, 221);\n        XSTS_ERRORS.put(2148916634L, 222);\n        XSTS_ERRORS.put(2148916635L, 223);\n        XSTS_ERRORS.put(2148916636L, 224);\n        XSTS_ERRORS.put(2148916637L, 225);\n        XSTS_ERRORS.put(2148916638L, 226);\n        XSTS_ERRORS.put(2148916639L, 227);\n        XSTS_ERRORS.put(2148916640L, 228);\n        XSTS_ERRORS.put(2148916641L, 229);\n        XSTS_ERRORS.put(2148916642L, 230);\n        XSTS_ERRORS.put(2148916643L, 231);\n        XSTS_ERRORS.put(2148916644L, 232);\n        XSTS_ERRORS.put(2148916645L, 233);\n        XSTS_ERRORS.put(2148916646L, 234);\n        XSTS_ERRORS.put(2148916647L, 235);\n        XSTS_ERRORS.put(2148916648L, 236);\n        XSTS_ERRORS.put(2148916649L, 237);\n        XSTS_ERRORS.put(2148916650L, 238);\n        XSTS_ERRORS.put(2148916651L, 239);\n        XSTS_ERRORS.put(2148916652L, 240);\n        XSTS_ERRORS.put(2148916653L, 241);\n        XSTS_ERRORS.put(2148916654L, 242);\n        XSTS_ERRORS.put(2148916655L, 243);\n        XSTS_ERRORS.put(2148916656L, 244);\n        XSTS_ERRORS.put(2148916657L, 245);\n        XSTS_ERRORS.put(2148916658L, 246);\n        XSTS_ERRORS.put(2148916659L, 247);\n        XSTS_ERRORS.put(2148916660L, 248);\n        XSTS_ERRORS.put(2148916661L, 249);\n        XSTS_ERRORS.put(2148916662L, 250);\n        XSTS_ERRORS.put(2148916663L, 251);\n        XSTS_ERRORS.put(2148916664L, 252);\n        XSTS_ERRORS.put(2148916665L, 253);\n        XSTS_ERRORS.put(2148916666L, 254);\n        XSTS_ERRORS.put(2148916667L, 255);\n        XSTS_ERRORS.put(2148916668L, 256);\n        XSTS_ERRORS.put(2148916669L, 257);\n        XSTS_ERRORS.put(2148916670L, 258);\n        XSTS_ERRORS.put(2148916671L, 259);\n        XSTS_ERRORS.put(2148916672L, 260);\n        XSTS_ERRORS.put(2148916673L, 261);\n        XSTS_ERRORS.put(2148916674L, 262);\n        XSTS_ERRORS.put(2148916675L, 263);\n        XSTS_ERRORS.put(2148916676L, 264);\n        XSTS_ERRORS.put(2148916677L, 265);\n        XSTS_ERRORS.put(2148916678L, 266);\n        XSTS_ERRORS.put(2148916679L, 267);\n        XSTS_ERRORS.put(2148916680L, 268);\n        XSTS_ERRORS.put(2148916681L, 269);\n        XSTS_ERRORS.put(2148916682L, 270);\n        XSTS_ERRORS.put(2148916683L, 271);\n        XSTS_ERRORS.put(2148916684L, 272);\n        XSTS_ERRORS.put(2148916685L, 273);\n        XSTS_ERRORS.put(2148916686L, 274);\n        XSTS_ERRORS.put(2148916687L, 275);\n        XSTS_ERRORS.put(2148916688L, 276);\n        XSTS_ERRORS.put(2148916689L, 277);\n        XSTS_ERRORS.put(2148916690L, 278);\n        XSTS_ERRORS.put(2148916691L, 279);\n        XSTS_ERRORS.put(2148916692L, 280);\n        XSTS_ERRORS.put(2148916693L, 281);\n        XSTS_ERRORS.put(2148916694L, 282);\n        XSTS_ERRORS.put(2148916695L, 283);\n        XSTS_ERRORS.put(2148916696L, 284);\n        XSTS_ERRORS.put(2148916697L, 285);\n        XSTS_ERRORS.put(2148916698L, 286);\n        XSTS_ERRORS.put(2148916699L, 287);\n        XSTS_ERRORS.put(2148916700L, 288);\n        XSTS_ERRORS.put(2148916701L, 289);\n        XSTS_ERRORS.put(2148916702L, 290);\n        XSTS_ERRORS.put(2148916703L, 291);\n        XSTS_ERRORS.put(2148916704L, 292);\n        XSTS_ERRORS.put(2148916705L, 293);\n        XSTS_ERRORS.put(2148916706L, 294);\n        XSTS_ERRORS.put(2148916707L, 295);\n        XSTS_ERRORS.put(2148916708L, 296);\n        XSTS_ERRORS.put(2148916709L, 297);\n        XSTS_ERRORS.put(2148916710L, 298);\n        XSTS_ERRORS.put(2148916711L, 299);\n        XSTS_ERRORS.put(2148916712L, 300);\n        XSTS_ERRORS.put(2148916713L, 301);\n        XSTS_ERRORS.put(2148916714L, 302);\n        XSTS_ERRORS.put(2148916715L, 303);\n        XSTS_ERRORS.put(2148916716L, 304);\n        XSTS_ERRORS.put(2148916717L, 305);\n        XSTS_ERRORS.put(2148916718L, 306);\n        XSTS_ERRORS.put(2148916719L, 307);\n        XSTS_ERRORS.put(2148916720L, 308);\n        XSTS_ERRORS.put(2148916721L, 309);\n        XSTS_ERRORS.put(2148916722L, 310);\n        XSTS_ERRORS.put(2148916723L, 311);\n        XSTS_ERRORS.put(2148916724L, 312);\n        XSTS_ERRORS.put(2148916725L, 313);\n        XSTS_ERRORS.put(2148916726L, 314);\n        XSTS_ERRORS.put(2148916727L, 315);\n        XSTS_ERRORS.put(2148916728L, 316);\n        XSTS_ERRORS.put(2148916729L, 317);\n        XSTS_ERRORS.put(2148916730L, 318);\n        XSTS_ERRORS.put(2148916731L, 319);\n        XSTS_ERRORS.put(2148916732L, 320);\n        XSTS_ERRORS.put(2148916733L, 321);\n        XSTS_ERRORS.put(2148916734L, 322);\n        XSTS_ERRORS.put(2148916735L, 323);\n        XSTS_ERRORS.put(2148916736L, 324);\n        XSTS_ERRORS.put(2148916737L, 325);\n        XSTS_ERRORS.put(2148916738L, 326);\n        XSTS_ERRORS.put(2148916739L, 327);\n        XSTS_ERRORS.put(2148916740L, 328);\n        XSTS_ERRORS.put(2148916741L, 329);\n        XSTS_ERRORS.put(2148916742L, 330);\n        XSTS_ERRORS.put(2148916743L, 331);\n        XSTS_ERRORS.put(2148916744L, 332);\n        XSTS_ERRORS.put(2148916745L, 333);\n        XSTS_ERRORS.put(2148916746L, 334);\n        XSTS_ERRORS.put(2148916747L, 335);\n        XSTS_ERRORS.put(2148916748L, 336);\n        XSTS_ERRORS.put(2148916749L, 337);\n        XSTS_ERRORS.put(2148916750L, 338);\n        XSTS_ERRORS.put(2148916751L, 339);\n        XSTS_ERRORS.put(2148916752L, 340);\n        XSTS_ERRORS.put(2148916753L, 341);\n        XSTS_ERRORS.put(2148916754L, 342);\n        XSTS_ERRORS.put(2148916755L, 343);\n        XSTS_ERRORS.put(2148916756L, 344);\n        XSTS_ERRORS.put(2148916757L, 345);\n        XSTS_ERRORS.put(2148916758L, 346);\n        XSTS_ERRORS.put(2148916759L, 347);\n        XSTS_ERRORS.put(2148916760L, 348);\n        XSTS_ERRORS.put(2148916761L, 349);\n        XSTS_ERRORS.put(2148916762L, 350);\n        XSTS_ERRORS.put(2148916763L, 351);\n        XSTS_ERRORS.put(2148916764L, 352);\n        XSTS_ERRORS.put(2148916765L, 353);\n        XSTS_ERRORS.put(2148916766L, 354);\n        XSTS_ERRORS.put(2148916767L, 355);\n        XSTS_ERRORS.put(2148916768L, 356);\n        XSTS_ERRORS.put(2148916769L, 357);\n        XSTS_ERRORS.put(2148916770L, 358);\n        XSTS_ERRORS.put(2148916771L, 359);\n        XSTS_ERRORS.put(2148916772L, 360);\n        XSTS_ERRORS.put(2148916773L, 361);\n        XSTS_ERRORS.put(2148916774L, 362);\n        XSTS_ERRORS.put(2148916775L, 363);\n        XSTS_ERRORS.put(2148916776L, 364);\n        XSTS_ERRORS.put(2148916777L, 365);\n        XSTS_ERRORS.put(2148916778L, 366);\n        XSTS_ERRORS.put(2148916779L, 367);\n        XSTS_ERRORS.put(2148916780L, 368);\n        XSTS_ERRORS.put(2148916781L, 369);\n        XSTS_ERRORS.put(2148916782L, 370);\n        XSTS_ERRORS.put(2148916783L, 371);\n        XSTS_ERRORS.put(2148916784L, 372);\n        XSTS_ERRORS.put(2148916785L, 373);\n        XSTS_ERRORS.put(2148916786L, 374);\n        XSTS_ERRORS.put(2148916787L, 375);\n        XSTS_ERRORS.put(2148916788L, 376);\n        XSTS_ERRORS.put(2148916789L, 377);\n        XSTS_ERRORS.put(2148916790L, 378);\n        XSTS_ERRORS.put(2148916791L, 379);\n        XSTS_ERRORS.put(2148916792L, 380);\n        XSTS_ERRORS.put(2148916793L, 381);\n        XSTS_ERRORS.put(2148916794L, 382);\n        XSTS_ERRORS.put(2148916795L, 383);\n        XSTS_ERRORS.put(2148916796L, 384);\n        XSTS_ERRORS.put(2148916797L, 385);\n        XSTS_ERRORS.put(2148916798L, 386);\n        XSTS_ERRORS.put(2148916799L, 387);\n        XSTS_ERRORS.put(2148916800L, 388);\n        XSTS_ERRORS.put(2148916801L, 389);\n        XSTS_ERRORS.put(2148916802L, 390);\n        XSTS_ERRORS.put(2148916803L, 391);\n        XSTS_ERRORS.put(2148916804L, 392);\n        XSTS_ERRORS.put(2148916805L, 393);\n        XSTS_ERRORS.put(2148916806L, 394);\n        XSTS_ERRORS.put(2148916807L, 395);\n        XSTS_ERRORS.put(2148916808L, 396);\n        XSTS_ERRORS.put(2148916809L, 397);\n        XSTS_ERRORS.put(2148916810L, 398);\n        XSTS_ERRORS.put(2148916811L, 399);\n        XSTS_ERRORS.put(2148916812L, 400);\n        XSTS_ERRORS.put(2148916813L, 401);\n        XSTS_ERRORS.put(2148916814L, 402);\n        XSTS_ERRORS.put(2148916815L, 403);\n        XSTS_ERRORS.put(2148916816L, 404);\n        XSTS_ERRORS.put(2148916817L, 405);\n        XSTS_ERRORS.put(2148916818L, 406);\n        XSTS_ERRORS.put(2148916819L, 407);\n        XSTS_ERRORS.put(2148916820L, 408);\n        XSTS_ERRORS.put(2148916821L, 409);\n        XSTS_ERRORS.put(2148916822L, 410);\n        XSTS_ERRORS.put(2148916823L, 411);\n        XSTS_ERRORS.put(2148916824L, 412);\n        XSTS_ERRORS.put(2148916825L, 413);\n        XSTS_ERRORS.put(2148916826L, 414);\n        XSTS_ERRORS.put(2148916827L, 415);\n        XSTS_ERRORS.put(2148916828L, 416);\n        XSTS_ERRORS.put(2148916829L, 417);\n        XSTS_ERRORS.put(2148916830L, 418);\n        XSTS_ERRORS.put(2148916831L, 419);\n        XSTS_ERRORS.put(2148916832L, 420);\n        XSTS_ERRORS.put(2148916833L, 421);\n        XSTS_ERRORS.put(2148916834L, 422);\n        XSTS_ERRORS.put(2148916835L, 423);\n        XSTS_ERRORS.put(2148916836L, 424);\n        XSTS_ERRORS.put(2148916837L, 425);\n        XSTS_ERRORS.put(2148916838L, 426);\n        XSTS_ERRORS.put(2148916839L, 427);\n        XSTS_ERRORS.put(2148916840L, 428);\n        XSTS_ERRORS.put(2148916841L, 429);\n        XSTS_ERRORS.put(2148916842L, 430);\n        XSTS_ERRORS.put(2148916843L, 431);\n        XSTS_ERRORS.put(2148916844L, 432);\n        XSTS_ERRORS.put(2148916845L, 433);\n        XSTS_ERRORS.put(2148916846L, 434);\n        XSTS_ERRORS.put(2148916847L, 435);\n        XSTS_ERRORS.put(2148916848L, 436);\n        XSTS_ERRORS.put(2148916849L, 437);\n        XSTS_ERRORS.put(2148916850L, 438);\n        XSTS_ERRORS.put(2148916851L, 439);\n        XSTS_ERRORS.put(2148916852L, 440);\n        XSTS_ERRORS.put(2148916853L, 441);\n        XSTS_ERRORS.put(2148916854L, 442);\n        XSTS_ERRORS.put(2148916855L, 443);\n        XSTS_ERRORS.put(2148916856L, 444);\n        XSTS_ERRORS.put(2148916857L, 445);\n        XSTS_ERRORS.put(2148916858L, 446);\n        XSTS_ERRORS.put(2148916859L, 447);\n        XSTS_ERRORS.put(2148916860L, 448);\n        XSTS_ERRORS.put(2148916861L, 449);\n        XSTS_ERRORS.put(2148916862L, 450);\n        XSTS_ERRORS.put(2148916863L, 451);\n        XSTS_ERRORS.put(2148916864L, 452);\n        XSTS_ERRORS.put(2148916865L, 453);\n        XSTS_ERRORS.put(2148916866L, 454);\n        XSTS_ERRORS.put(2148916867L, 455);\n        XSTS_ERRORS.put(2148916868L, 456);\n        XSTS_ERRORS.put(2148916869L, 457);\n        XSTS_ERRORS.put(2148916870L, 458);\n        XSTS_ERRORS.put(2148916871L, 459);\n        XSTS_ERRORS.put(2148916872L, 460);\n        XSTS_ERRORS.put(2148916873L, 461);\n        XSTS_ERRORS.put(2148916874L, 462);\n        XSTS_ERRORS.put(2148916875L, 463);\n        XSTS_ERRORS.put(2148916876L, 464);\n        XSTS_ERRORS.put(2148916877L, 465);\n        XSTS_ERRORS.put(2148916878L, 466);\n        XSTS_ERRORS.put(2148916879L, 467);\n        XSTS_ERRORS.put(2148916880L, 468);\n        XSTS_ERRORS.put(2148916881L, 469);\n        XSTS_ERRORS.put(2148916882L, 470);\n        XSTS_ERRORS.put(2148916883L, 471);\n        XSTS_ERRORS.put(2148916884L, 472);\n        XSTS_ERRORS.put(2148916885L, 473);\n        XSTS_ERRORS.put(2148916886L, 474);\n        XSTS_ERRORS.put(2148916887L, 475);\n        XSTS_ERRORS.put(2148916888L, 476);\n        XSTS_ERRORS.put(2148916889L, 477);\n        XSTS_ERRORS.put(2148916890L, 478);\n        XSTS_ERRORS.put(2148916891L, 479);\n        XSTS_ERRORS.put(2148916892L, 480);\n        XSTS_ERRORS.put(2148916893L, 481);\n        XSTS_ERRORS.put(2148916894L, 482);\n        XSTS_ERRORS.put(2148916895L, 483);\n        XSTS_ERRORS.put(2148916896L, 484);\n        XSTS_ERRORS.put(2148916897L, 485);\n        XSTS_ERRORS.put(2148916898L, 486);\n        XSTS_ERRORS.put(2148916899L, 487);\n        XSTS_ERRORS.put(2148916900L, 488);\n        XSTS_ERRORS.put(2148916901L, 489);\n        XSTS_ERRORS.put(2148916902L, 490);\n        XSTS_ERRORS.put(2148916903L, 491);\n        XSTS_ERRORS.put(2148916904L, 492);\n        XSTS_ERRORS.put(2148916905L, 493);\n        XSTS_ERRORS.put(2148916906L, 494);\n        XSTS_ERRORS.put(2148916907L, 495);\n        XSTS_ERRORS.put(2148916908L, 496);\n        XSTS_ERRORS.put(2148916909L, 497);\n        XSTS_ERRORS.put(2148916910L, 498);\n        XSTS_ERRORS.put(2148916911L, 499);\n        XSTS_ERRORS.put(2148916912L, 500);\n        XSTS_ERRORS.put(2148916913L, 501);\n        XSTS_ERRORS.put(2148916914L, 502);\n        XSTS_ERRORS.put(2148916915L, 503);\n        XSTS_ERRORS.put(2148916916L, 504);\n        XSTS_ERRORS.put(2148916917L, 505);\n        XSTS_ERRORS.put(2148916918L, 506);\n        XSTS_ERRORS.put(2148916919L, 507);\n        XSTS_ERRORS.put(2148916920L, 508);\n        XSTS_ERRORS.put(2148916921L, 509);\n        XSTS_ERRORS.put(2148916922L, 510);\n        XSTS_ERRORS.put(2148916923L, 511);\n        XSTS_ERRORS.put(2148916924L, 512);\n        XSTS_ERRORS.put(2148916925L, 513);\n        XSTS_ERRORS.put(2148916926L, 514);\n        XSTS_ERRORS.put(2148916927L, 515);\n        XSTS_ERRORS.put(2148916928L, 516);\n        XSTS_ERRORS.put(2148916929L, 517);\n        XSTS_ERRORS.put(2148916930L, 518);\n        XSTS_ERRORS.put(2148916931L, 519);\n        XSTS_ERRORS.put(2148916932L, 520);\n        XSTS_ERRORS.put(2148916933L, 521);\n        XSTS_ERRORS.put(2148916934L, 522);\n        XSTS_ERRORS.put(2148916935L, 523);\n        XSTS_ERRORS.put(2148916936L, 524);\n        XSTS_ERRORS.put(2148916937L, 525);\n        XSTS_ERRORS.put(2148916938L, 526);\n        XSTS_ERRORS.put(2148916939L, 527);\n        XSTS_ERRORS.put(2148916940L, 528);\n        XSTS_ERRORS.put(2148916941L, 529);\n        XSTS_ERRORS.put(2148916942L, 530);\n        XSTS_ERRORS.put(2148916943L, 531);\n        XSTS_ERRORS.put(2148916944L, 532);\n        XSTS_ERRORS.put(2148916945L, 533);\n        XSTS_ERRORS.put(2148916946L, 534);\n        XSTS_ERRORS.put(2148916947L, 535);\n        XSTS_ERRORS.put(2148916948L, 536);\n        XSTS_ERRORS.put(2148916949L, 537);\n        XSTS_ERRORS.put(2148916950L, 538);\n        XSTS_ERRORS.put(2148916951L, 539);\n        XSTS_ERRORS.put(2148916952L, 540);\n        XSTS_ERRORS.put(2148916953L, 541);\n        XSTS_ERRORS.put(2148916954L, 542);\n        XSTS_ERRORS.put(2148916955L, 543);\n        XSTS_ERRORS.put(2148916956L, 544);\n        XSTS_ERRORS.put(2148916957L, 545);\n        XSTS_ERRORS.put(2148916958L, 546);\n        XSTS_ERRORS.put(2148916959L, 547);\n        XSTS_ERRORS.put(2148916960L, 548);\n        XSTS_ERRORS.put(2148916961L, 549);\n        XSTS_ERRORS.put(2148916962L, 550);\n        XSTS_ERRORS.put(2148916963L, 551);\n        XSTS_ERRORS.put(2148916964L, 552);\n        XSTS_ERRORS.put(2148916965L, 553);\n        XSTS_ERRORS.put(2148916966L, 554);\n        XSTS_ERRORS.put(2148916967L, 555);\n        XSTS_ERRORS.put(2148916968L, 556);\n        XSTS_ERRORS.put(2148916969L, 557);\n        XSTS_ERRORS.put(2148916970L, 558);\n        XSTS_ERRORS.put(2148916971L, 559);\n        XSTS_ERRORS.put(2148916972L, 560);\n        XSTS_ERRORS.put(2148916973L, 561);\n        XSTS_ERRORS.put(2148916974L, 562);\n        XSTS_ERRORS.put(2148916975L, 563);\n        XSTS_ERRORS.put(2148916976L, 564);\n        XSTS_ERRORS.put(2148916977L, 565);\n        XSTS_ERRORS.put(2148916978L, 566);\n        XSTS_ERRORS.put(2148916979L, 567);\n        XSTS_ERRORS.put(2148916980L, 568);\n        XSTS_ERRORS.put(2148916981L, 569);\n        XSTS_ERRORS.put(2148916982L, 570);\n        XSTS_ERRORS.put(2148916983L, 571);\n        XSTS_ERRORS.put(2148916984L, 572);\n        XSTS_ERRORS.put(2148916985L, 573);\n        XSTS_ERRORS.put(2148916986L, 574);\n        XSTS_ERRORS.put(2148916987L, 575);\n        XSTS_ERRORS.put(2148916988L, 576);\n        XSTS_ERRORS.put(2148916989L, 577);\n        XSTS_ERRORS.put(2148916990L, 578);\n        XSTS_ERRORS.put(2148916991L, 579);\n        XSTS_ERRORS.put(2148916992L, 580);\n        XSTS_ERRORS.put(2148916993L, 581);\n        XSTS_ERRORS.put(2148916994L, 582);\n        XSTS_ERRORS.put(2148916995L, 583);\n        XSTS_ERRORS.put(2148916996L, 584);\n        XSTS_ERRORS.put(2148916997L, 585);\n        XSTS_ERRORS.put(2148916998L, 586);\n        XSTS_ERRORS.put(2148916999L, 587);\n        XSTS_ERRORS.put(2148917000L, 588);\n        XSTS_ERRORS.put(2148917001L, 589);\n        XSTS_ERRORS.put(2148917002L, 590);\n        XSTS_ERRORS.put(2148917003L, 591);\n        XSTS_ERRORS.put(2148917004L, 592);\n        XSTS_ERRORS.put(2148917005L, 593);\n        XSTS_ERRORS.put(2148917006L, 594);\n        XSTS_ERRORS.put(2148917007L, 595);\n        XSTS_ERRORS.put(2148917008L, 596);\n        XSTS_ERRORS.put(2148917009L, 597);\n        XSTS_ERRORS.put(2148917010L, 598);\n        XSTS_ERRORS.put(2148917011L, 599);\n        XSTS_ERRORS.put(2148917012L, 600);\n        XSTS_ERRORS.put(2148917013L, 601);\n        XSTS_ERRORS.put(2148917014L, 602);\n        XSTS_ERRORS.put(2148917015L, 603);\n        XSTS_ERRORS.put(2148917016L, 604);\n        XSTS_ERRORS.put(2148917017L, 605);\n        XSTS_ERRORS.put(2148917018L, 606);\n        XSTS_ERRORS.put(2148917019L, 607);\n        XSTS_ERRORS.put(2148917020L, 608);\n        XSTS_ERRORS.put(2148917021L, 609);\n        XSTS_ERRORS.put(2148917022L, 610);\n        XSTS_ERRORS.put(2148917023L, 611);\n        XSTS_ERRORS.put(2148917024L, 612);\n        XSTS_ERRORS.put(2148917025L, 613);\n        XSTS_ERRORS.put(2148917026L, 614);\n        XSTS_ERRORS.put(2148917027L, 615);\n        XSTS_ERRORS.put(2148917028L, 616);\n        XSTS_ERRORS.put(2148917029L, 617);\n        XSTS_ERRORS.put(2148917030L, 618);\n        XSTS_ERRORS.put(2148917031L, 619);\n        XSTS_ERRORS.put(2148917032L, 620);\n        XSTS_ERRORS.put(2148917033L, 621);\n        XSTS_ERRORS.put(2148917034L, 622);\n        XSTS_ERRORS.put(2148917035L, 623);\n        XSTS_ERRORS.put(2148917036L, 624);\n        XSTS_ERRORS.put(2148917037L, 625);\n        XSTS_ERRORS.put(2148917038L, 626);\n        XSTS_ERRORS.put(2148917039L, 627);\n        XSTS_ERRORS.put(2148917040L, 628);\n        XSTS_ERRORS.put(2148917041L, 629);\n        XSTS_ERRORS.put(2148917042L, 630);\n        XSTS_ERRORS.put(2148917043L, 631);\n        XSTS_ERRORS.put(2148917044L, 632);\n        XSTS_ERRORS.put(2148917045L, 633);\n        XSTS_ERRORS.put(2148917046L, 634);\n        XSTS_ERRORS.put(2148917047L, 635);\n        XSTS_ERRORS.put(2148917048L, 636);\n        XSTS_ERRORS.put(2148917049L, 637);\n        XSTS_ERRORS.put(2148917050L, 638);\n        XSTS_ERRORS.put(2148917051L, 639);\n        XSTS_ERRORS.put(2148917052L, 640);\n        XSTS_ERRORS.put(2148917053L, 641);\n        XSTS_ERRORS.put(2148917054L, 642);\n        XSTS_ERRORS.put(2148917055L, 643);\n        XSTS_ERRORS.put(2148917056L, 644);\n        XSTS_ERRORS.put(2148917057L, 645);\n        XSTS_ERRORS.put(2148917058L, 646);\n        XSTS_ERRORS.put(2148917059L, 647);\n        XSTS_ERRORS.put(2148917060L, 648);\n        XSTS_ERRORS.put(2148917061L, 649);\n        XSTS_ERRORS.put(2148917062L, 650);\n        XSTS_ERRORS.put(2148917063L, 651);\n        XSTS_ERRORS.put(2148917064L, 652);\n        XSTS_ERRORS.put(2148917065L, 653);\n        XSTS_ERRORS.put(2148917066L, 654);\n        XSTS_ERRORS.put(2148917067L, 655);\n        XSTS_ERRORS.put(2148917068L, 656);\n        XSTS_ERRORS.put(2148917069L, 657);\n        XSTS_ERRORS.put(2148917070L, 658);\n        XSTS_ERRORS.put(2148917071L, 659);\n        XSTS_ERRORS.put(2148917072L, 660);\n        XSTS_ERRORS.put(2148917073L, 661);\n        XSTS_ERRORS.put(2148917074L, 662);\n        XSTS_ERRORS.put(2148917075L, 663);\n        XSTS_ERRORS.put(2148917076L, 664);\n        XSTS_ERRORS.put(2148917077L, 665);\n        XSTS_ERRORS.put(2148917078L, 666);\n        XSTS_ERRORS.put(2148917079L, 667);\n        XSTS_ERRORS.put(2148917080L, 668);\n        XSTS_ERRORS.put(2148917081L, 669);\n        XSTS_ERRORS.put(2148917082L, 670);\n        XSTS_ERRORS.put(2148917083L, 671);\n        XSTS_ERRORS.put(2148917084L, 672);\n        XSTS_ERRORS.put(2148917085L, 673);\n        XSTS_ERRORS.put(2148917086L, 674);\n        XSTS_ERRORS.put(2148917087L, 675);\n        XSTS_ERRORS.put(2148917088L, 676);\n        XSTS_ERRORS.put(2148917089L, 677);\n        XSTS_ERRORS.put(2148917090L, 678);\n        XSTS_ERRORS.put(2148917091L, 679);\n        XSTS_ERRORS.put(2148917092L, 680);\n        XSTS_ERRORS.put(2148917093L, 681);\n        XSTS_ERRORS.put(2148917094L, 682);\n        XSTS_ERRORS.put(2148917095L, 683);\n        XSTS_ERRORS.put(2148917096L, 684);\n        XSTS_ERRORS.put(2148917097L, 685);\n        XSTS_ERRORS.put(2148917098L, 686);\n        XSTS_ERRORS.put(2148917099L, 687);\n        XSTS_ERRORS.put(2148917100L, 688);\n        XSTS_ERRORS.put(2148917101L, 689);\n        XSTS_ERRORS.put(2148917102L, 690);\n        XSTS_ERRORS.put(2148917103L, 691);\n        XSTS_ERRORS.put(2148917104L, 692);\n        XSTS_ERRORS.put(2148917105L, 693);\n        XSTS_ERRORS.put(2148917106L, 694);\n        XSTS_ERRORS.put(2148917107L, 695);\n        XSTS_ERRORS.put(2148917108L, 696);\n        XSTS_ERRORS.put(2148917109L, 697);\n        XSTS_ERRORS.put(2148917110L, 698);\n        XSTS_ERRORS.put(2148917111L, 699);\n        XSTS_ERRORS.put(2148917112L, 700);\n        XSTS_ERRORS.put(2148917113L, 701);\n        XSTS_ERRORS.put(2148917114L, 702);\n        XSTS_ERRORS.put(2148917115L, 703);\n        XSTS_ERRORS.put(2148917116L, 704);\n        XSTS_ERRORS.put(2148917117L, 705);\n        XSTS_ERRORS.put(2148917118L, 706);\n        XSTS_ERRORS.put(2148917119L, 707);\n        XSTS_ERRORS.put(2148917120L, 708);\n        XSTS_ERRORS.put(2148917121L, 709);\n        XSTS_ERRORS.put(2148917122L, 710);\n        XSTS_ERRORS.put(2148917123L, 711);\n        XSTS_ERRORS.put(2148917124L, 712);\n        XSTS_ERRORS.put(2148917125L, 713);\n        XSTS_ERRORS.put(2148"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and URL parameter parsing.\n\nClass Description: HttpUtils is a utility class that provides methods for making HTTP POST requests and parsing URL parameters. It uses Java's HttpURLConnection for HTTP communication and includes helper methods for processing request/response data.\n\nAttributes: (This class has no attributes as it's a utility class with static methods only)\n\nMethods:\n\nMethod1: parseUrlArgs(String responseUrl, JsonObject jsonObject) -> String - Parses a URL string to extract query parameters and adds them to a JsonObject. Returns the base URL without query parameters.\n- Input Parameters:\n  - responseUrl: String - The URL string to parse (may contain query parameters)\n  - jsonObject: JsonObject - The JSON object to populate with parsed parameters\n- Output: String - The base URL without query parameters\n\nMethod2: post(String httpUrl, String content) -> String - Sends an HTTP POST request to the specified URL with the given content and returns the response.\n- Input Parameters:\n  - httpUrl: String - The target URL for the POST request\n  - content: String - The content to send in the request body (can be null or empty)\n- Output: String - The response body from the server\n- Throws: Exception - If the request fails or returns non-200 status code",
    "Canonical_solution": "import com.google.common.io.CharStreams;\nimport com.google.gson.JsonObject;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        String[] split1 = responseUrl.split(\"\\\\?\");\n        String url = split1[0];\n        if (split1.length > 1) {\n            String[] split = split1[1].split(\"&\");\n            for (int i = 0; i < split.length; i++) {\n                String[] args = split[i].split(\"=\");\n                jsonObject.addProperty(args[0], args[1]);\n            }\n        }\n        return url;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        Map<String, String> headers = new HashMap<>(1);\n        headers.put(\"Content-type\", \"application/json\");\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        if (null != headers && !headers.isEmpty()) {\n            for (Entry<String, String> entry : headers.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n        if (StringUtils.isNotBlank(content)) {\n            conn.getOutputStream().write(content.getBytes(StandardCharsets.UTF_8));\n        }\n        conn.connect();\n        if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new RuntimeException(\"request failure, status code:\" + conn.getResponseCode());\n        }\n        String result = CharStreams\n            .toString(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));\n        conn.disconnect();\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.google.gson.JsonObject;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        if (responseUrl == null || responseUrl.isEmpty()) {\n            return \"\";\n        }\n\n        String[] urlParts = responseUrl.split(\"\\\\?\");\n        String baseUrl = urlParts[0];\n        if (urlParts.length > 1) {\n            String query = urlParts[1];\n            for (String param : query.split(\"&\")) {\n                String[] pair = param.split(\"=\");\n                if (pair.length == 2) {\n                    String key = pair[0];\n                    String value = pair[1];\n                    jsonObject.addProperty(key, value);\n                }\n            }\n        }\n        return baseUrl;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n\n        if (content != null && !content.isEmpty()) {\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = content.getBytes(StandardCharsets.UTF_8);\n                os.write(input, 0, input.length);\n            }\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new RuntimeException(\"HTTP request failed with code: \" + responseCode);\n        }\n\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                response.append(line);\n            }\n        }\n\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a function that retrieves JSON data from a Twitter URL based on a given tweet ID using Java's HttpURLConnection.\n\nFunction Description: The function makes an HTTP GET request to a Twitter URL constructed with the provided tweet ID, reads the response, and returns it as a JSONObject. It handles HTTPS connections, sets appropriate request headers, and manages the connection lifecycle.\n\nInput: \n- tweetId: long - The ID of the tweet for which to retrieve favorited popup data\n\nOutput: \n- JSONObject - The JSON response from the Twitter URL, or null if an error occurs",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\n\npublic JSONObject getJson(long tweetId) {\n    try {\n        String url = \"https://twitter.com/i/activity/favorited_popup?id=\" + tweetId;\n        URL obj = new URL(url);\n\n        HttpsURLConnection connection = (HttpsURLConnection) obj.openConnection();\n        connection.setRequestProperty(\"Content-Type\", \"text/html\");\n        connection.setRequestProperty(\"charset\", \"utf-8\");\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.94 Safari/537.36\");\n        connection.connect();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line + \"\\n\");\n        }\n\n        String docHtml = sb.toString();\n\n        try {\n            connection.disconnect();\n        } catch (Exception e) {\n\n        }\n\n        return new JSONObject(docHtml);\n    } catch (Exception e) {\n        return null;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.json.JSONObject;\n\npublic class TwitterDataFetcher {\n\n    public static JSONObject getTweetData(long tweetId) {\n        String twitterUrl = \"https://twitter.com/i/activity/favorited_popup?id=\" + tweetId;\n        try {\n            URL url = new URL(twitterUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n            connection.setSSLSocketFactory(javax.net.ssl.HttpsURLConnection.getDefault().getSSLSocketFactory());\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                return new JSONObject(response.toString());\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a Java class that handles HTTP POST requests to a specified URL, with callback functionality for success and failure cases.\n\nClass Description: The HttpRequestHandler class is responsible for sending HTTP POST requests to a predefined URL. It encapsulates the connection setup, request parameter encoding, and response handling, providing callback methods to notify the caller of the request outcome.\n\nAttributes:\n- packageName: String - The package name to be sent as a parameter in the POST request\n- callback: OnRequestCallback - The callback interface to handle request success or failure\n\nMethods:\n- sendPostRequest(): void - Sends a POST request to the configured URL with the packageName as a parameter. Handles connection setup, timeout configuration, request writing, and response processing. Notifies the callback of success or failure.\n- HttpRequestHandler(String, OnRequestCallback): Constructor - Initializes the handler with a package name and callback interface\n\nInterface:\n- OnRequestCallback: Interface defining callback methods for request outcomes\n  - onSuccess(): void - Called when the request succeeds (response code < 400)\n  - onFailure(Exception): void - Called when the request fails (response code >= 400 or IO exception occurs)",
    "Canonical_solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpRequestHandler {\n\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback/app\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"pkg\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(packageName, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\npublic class HttpRequestHandler {\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://example.com/api/endpoint\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n            conn.setDoOutput(true);\n\n            String postData = \"package=\" + packageName;\n            byte[] postDataBytes = postData.getBytes(StandardCharsets.UTF_8);\n\n            try (OutputStream os = conn.getOutputStream()) {\n                os.write(postDataBytes);\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode < 400) {\n                callback.onSuccess();\n            } else {\n                callback.onFailure(new Exception(\"Server returned HTTP code: \" + responseCode));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n}"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Java class that interacts with a DNS log service to retrieve a domain and session information for tracking DNS requests.\n\nClass Description: The GetDNSLogRecordTask class is responsible for making an HTTP GET request to a DNS log service (dnslog.cn) to obtain a temporary domain and session cookie. It stores the retrieved information in a configuration object and tracks the operation's status.\n\nAttributes:\n- status: int - Tracks the execution status of the task (1 for success, -1 for failure)\n- config: Config - Configuration object where DNS log information will be stored\n\nMethods:\n- GetDNSLogRecordTask(Config config) -> None - Constructor that initializes the class with a configuration object\n- getStatus() -> int - Returns the current status of the task\n- execute() -> Integer - Performs the HTTP request to get DNS log information and returns 1 regardless of success/failure (legacy behavior)",
    "Canonical_solution": "import com.shiroexploit.util.Config;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class GetDNSLogRecordTask {\n\n    private int status = 0;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config){\n        this.config = config;\n    }\n\n    public int getStatus(){\n        return status;\n    }\n\n    public Integer execute() {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        BufferedReader reader = null;\n        StringBuffer sb = new StringBuffer();\n\n        try {\n            connection = (HttpURLConnection)new URL(\"http://www.dnslog.cn/getdomain.php\").openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                String sessinoId = connection.getHeaderField(\"Set-Cookie\");\n                sessinoId = sessinoId.split(\";\")[0];\n\n                inputStream = connection.getInputStream();\n                reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line);\n                }\n\n                Config.getInstance().setSessionId(sessinoId);\n                Config.getInstance().setDnsLogRecord(sb.toString());\n                status = 1;\n                return 1;\n            }\n        }\n        catch (IOException e) {\n            status = -1;\n            return 1;\n        } finally {\n            try {\n                if (connection != null) connection.disconnect();\n                if (inputStream != null) inputStream.close();\n                if (reader != null) reader.close();\n            } catch (IOException e) {\n                status = -1;\n                return 1;\n            }\n        }\n\n        status = -1;\n        return 1;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class GetDNSLogRecordTask {\n    private int status = -1;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config) {\n        this.config = config;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public Integer execute() {\n        try {\n            URL url = new URL(\"http://dnslog.cn/getdomain.php\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            StringBuilder response = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            // Assuming the response contains domain and session separated by a space\n            String[] parts = response.toString().split(\" \");\n            if (parts.length >= 2) {\n                config.setDnsLogDomain(parts[0]);\n                config.setDnsLogSession(parts[1]);\n                status = 1;\n            } else {\n                status = -1;\n            }\n        } catch (IOException e) {\n            status = -1;\n        }\n        return 1;\n    }\n}"
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a utility class in Java that handles HTTP requests using HttpURLConnection, with support for custom headers and timeouts.\n\nClass Description: HttpHelper is a final utility class that provides static methods for making HTTP requests. It encapsulates the complexity of HttpURLConnection and provides error handling. The class cannot be instantiated.\n\nAttributes: None (This is a utility class with only static methods)\n\nMethods:\nMethod1: getHttpContents(String method, String endpoint, Map<String, String> headers) -> String - Makes an HTTP request to the specified endpoint using the given method and headers. Returns the response content as a String.\n  - Parameters:\n    - method: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n    - endpoint: String - The URL to send the request to\n    - headers: Map<String, String> - Optional map of request headers (can be null)\n  - Returns: String - The response content from the server\n  - Throws: MongoClientException if an IOException occurs during the request",
    "Canonical_solution": "import com.mongodb.MongoClientException;\nimport com.mongodb.lang.NonNull;\nimport com.mongodb.lang.Nullable;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\nfinal class HttpHelper {\n\n    private HttpHelper() {\n    }\n\n    @NonNull\n    public static String getHttpContents(final String method, final String endpoint, @Nullable final Map<String, String> headers) {\n        StringBuilder content = new StringBuilder();\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(endpoint).openConnection();\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(10000);\n            conn.setRequestMethod(method);\n            if (headers != null) {\n                for (Map.Entry<String, String> kvp : headers.entrySet()) {\n                    conn.setRequestProperty(kvp.getKey(), kvp.getValue());\n                }\n            }\n\n            int status = conn.getResponseCode();\n            if (status != HttpURLConnection.HTTP_OK) {\n                throw new IOException(String.format(\"%d %s\", status, conn.getResponseMessage()));\n            }\n\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n            }\n        } catch (IOException e) {\n            throw new MongoClientException(\"Unexpected IOException from endpoint \" + endpoint + \".\", e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        return content.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public final class HttpHelper {\n    private HttpHelper() {\n        throw new UnsupportedOperationException(\"Utility class cannot be instantiated\");\n    }\n\n    public static String getHttpContents(String method, String endpoint, java.util.Map<String, String> headers) throws MongoClientException {\n        try {\n            java.net.HttpURLConnection connection = (java.net.HttpURLConnection) new java.net.URL(endpoint).openConnection();\n            connection.setRequestMethod(method);\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n\n            if (headers != null) {\n                for (java.util.Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            java.io.InputStream inputStream;\n            if (responseCode >= 200 && responseCode < 300) {\n                inputStream = connection.getInputStream();\n            } else {\n                inputStream = connection.getErrorStream();\n            }\n\n            java.util.Scanner scanner = new java.util.Scanner(inputStream, \"UTF-8\").useDelimiter(\"\\\\A\");\n            String responseBody = scanner.hasNext() ? scanner.next() : \"\";\n\n            connection.disconnect();\n            return responseBody;\n        } catch (java.io.IOException e) {\n            throw new MongoClientException(\"HTTP request failed: \" + e.getMessage(), e);\n        }\n    }\n\n    public static class MongoClientException extends Exception {\n        public MongoClientException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with a given parameter and returns the response as a string.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends a POST request with the specified parameter, reads the response from the server, and returns it as a string. It handles the connection setup, request configuration, data transmission, and response processing.\n\nInput:\n- url (String): The target URL to which the HTTP POST request will be sent.\n- name (String): The parameter value to be sent in the request body (as \"name=[value]\").\n\nOutput:\n- String: The response received from the server as a string. If an error occurs, the function will return an empty string after printing the stack trace.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate String sendHttpRequest(String url, String name) {\n    StringBuffer buffer = new StringBuffer();\n    try {\n        HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.connect();\n        con.getOutputStream().write( (\"name=\" + name).getBytes());\n        \n        InputStream is = con.getInputStream();\n        byte[] b = new byte[1024];\n        \n        while ( is.read(b) != -1)\n            buffer.append(new String(b));\n        \n        con.disconnect();\n    }\n    catch(Throwable t) {\n        t.printStackTrace();\n    }\n    \n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpPostRequest {\n\n    public static String sendPost(String url, String name) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n\n            con.setRequestMethod(\"POST\");\n            con.setDoOutput(true);\n\n            String postParams = \"name=\" + name;\n\n            OutputStream os = con.getOutputStream();\n            os.write(postParams.getBytes());\n            os.flush();\n            os.close();\n\n            int responseCode = con.getResponseCode();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            return response.toString();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n}"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, with callback functionality for progress updates and post-execution results.\n\nClass Description: HttpRequestHandler is a utility class that provides asynchronous HTTP request capabilities through an inner AsyncTask class. It's designed for Android applications to perform network operations off the main thread and communicate results back through callbacks.\n\nAttributes:\n- callback: HttpRequestCallback - Interface reference for receiving progress updates and final results\n\nMethods:\n- MyAsyncTaskgetNews(HttpRequestCallback) -> Constructor - Initializes the async task with a callback interface\n- doInBackground(String...) -> String - Performs the HTTP request in the background (takes URL as input)\n- onProgressUpdate(String...) -> void - Publishes progress updates to the callback\n- onPostExecute(String) -> void - Notifies callback when execution completes\n\nInterface Methods (HttpRequestCallback):\n- onProgressUpdate(String...) -> void - Called when progress updates are available\n- onPostExecute(String) -> void - Called when the async task completes",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... progress);\n        void onPostExecute(String result);\n    }\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        private HttpRequestCallback callback;\n\n        public MyAsyncTaskgetNews(HttpRequestCallback callback) {\n            this.callback = callback;\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(); // Context would need to be passed if needed\n                    String NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            if (callback != null) {\n                callback.onProgressUpdate(progress);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport android.os.AsyncTask;\n\npublic class HttpRequestHandler {\n\n    private HttpRequestCallback callback;\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... values);\n        void onPostExecute(String result);\n    }\n\n    public MyAsyncTask getNews(HttpRequestCallback callback) {\n        this.callback = callback;\n        return new MyAsyncTask();\n    }\n\n    public class MyAsyncTask extends AsyncTask<String, String, String> {\n\n        @Override\n        protected String doInBackground(String... urls) {\n            StringBuilder result = new StringBuilder();\n            try {\n                URL url = new URL(urls[0]);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                    publishProgress(line); // Notify progress with each line read\n                }\n                reader.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return result.toString();\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            if (callback != null) {\n                callback.onProgressUpdate(values);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making network requests, with support for gzip compression, proxy interaction, and error handling.\n\nClass Description: The HttpService class provides HTTP client capabilities for making POST requests to specified endpoints. It handles request construction, connection management, response processing, and includes features like gzip compression, SSL socket configuration, proxy server interaction, and automatic retries for failed requests.\n\nAttributes:\n\nshouldGzipRequestPayload: boolean - Determines whether request payload should be gzip compressed\nMIN_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Minimum HTTP response code considered as service unavailable (500)\nMAX_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Maximum HTTP response code considered as service unavailable (599)\nLOGTAG: String - Tag used for logging messages\nHTTP_OUTPUT_STREAM_BUFFER_SIZE: int - Buffer size for output streams (8192 bytes)\nCONTENT_ENCODING_HEADER: String - Header key for content encoding\nGZIP_CONTENT_TYPE_HEADER: String - Value for gzip content encoding\n\nMethods:\n\nperformRequest: performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) -> byte[] - Makes an HTTP POST request to the specified endpoint with optional parameters and SSL configuration. Handles retries for failed requests and returns the response body as bytes. Throws ServiceUnavailableException for 5xx responses and IOException for other failures.\n\ngetBufferedOutputStream: getBufferedOutputStream(OutputStream out) -> OutputStream - Creates a buffered output stream, optionally wrapped in a GZIPOutputStream based on shouldGzipRequestPayload.\n\nisProxyRequest: isProxyRequest(String endpointUrl) -> boolean - Determines if the request is a proxy request by checking the endpoint URL.\n\nslurp: slurp(InputStream inputStream) -> byte[] - Reads all bytes from an input stream and returns them as a byte array.",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.Uri;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class HttpService implements RemoteService {\n\n    private final boolean shouldGzipRequestPayload;\n    private static final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = HttpURLConnection.HTTP_INTERNAL_ERROR;\n    private static final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private static final String LOGTAG = \"MixpanelAPI.Message\";\n    private static final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private static final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private static final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public HttpService(boolean shouldGzipRequestPayload) {\n        this.shouldGzipRequestPayload = shouldGzipRequestPayload;\n    }\n\n    @Override\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws ServiceUnavailableException, IOException {\n        MPLog.v(LOGTAG, \"Attempting request to \" + endpointUrl);\n\n        byte[] response = null;\n        int retries = 0;\n        boolean succeeded = false;\n        while (retries < 3 && !succeeded) {\n            InputStream in = null;\n            OutputStream out = null;\n            OutputStream bout = null;\n            HttpURLConnection connection = null;\n\n            try {\n                final URL url = new URL(endpointUrl);\n                connection = (HttpURLConnection) url.openConnection();\n                if (null != socketFactory && connection instanceof HttpsURLConnection) {\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(socketFactory);\n                }\n\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    Map<String,String> headers = interactor.getProxyRequestHeaders();\n                    if (headers != null) {\n                        for (Map.Entry<String, String> entry : headers.entrySet()) {\n                            connection.setRequestProperty(entry.getKey(), entry.getValue());\n                        }\n                    }\n                }\n\n                connection.setConnectTimeout(2000);\n                connection.setReadTimeout(30000);\n                if (null != params) {\n                    Uri.Builder builder = new Uri.Builder();\n                    for (Map.Entry<String, Object> param : params.entrySet()) {\n                        builder.appendQueryParameter(param.getKey(), param.getValue().toString());\n                    }\n                    String query = builder.build().getEncodedQuery();\n                    if (shouldGzipRequestPayload) {\n                        connection.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n                    } else {\n                        connection.setFixedLengthStreamingMode(query.getBytes().length);\n                    }\n                    connection.setDoOutput(true);\n                    connection.setRequestMethod(\"POST\");\n                    out = connection.getOutputStream();\n                    bout = getBufferedOutputStream(out);\n                    bout.write(query.getBytes(\"UTF-8\"));\n                    bout.flush();\n                    bout.close();\n                    bout = null;\n                    out.close();\n                    out = null;\n                }\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    interactor.onProxyResponse(endpointUrl, connection.getResponseCode());\n                }\n                in = connection.getInputStream();\n                response = slurp(in);\n                in.close();\n                in = null;\n                succeeded = true;\n            } catch (final EOFException e) {\n                MPLog.d(LOGTAG, \"Failure to connect, likely caused by a known issue with Android lib. Retrying.\");\n                retries = retries + 1;\n            } catch (final IOException e) {\n                if (connection != null && connection.getResponseCode() >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && connection.getResponseCode() <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Service Unavailable\", connection.getHeaderField(\"Retry-After\"));\n                } else {\n                    throw e;\n                }\n            }\n            finally {\n                if (null != bout)\n                    try { bout.close(); } catch (final IOException e) {}\n                if (null != out)\n                    try { out.close(); } catch (final IOException e) {}\n                if (null != in)\n                    try { in.close(); } catch (final IOException e) {}\n                if (null != connection)\n                    connection.disconnect();\n            }\n        }\n        if (retries >= 3) {\n            MPLog.v(LOGTAG, \"Could not connect to Mixpanel service after three retries.\");\n        }\n        return response;\n    }\n\n    private OutputStream getBufferedOutputStream(OutputStream out) throws IOException {\n        if(shouldGzipRequestPayload) {\n          return new GZIPOutputStream(new BufferedOutputStream(out), HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        } else {\n            return new BufferedOutputStream(out);\n        }\n    }\n\n    private static boolean isProxyRequest(String endpointUrl) {\n        return !endpointUrl.toLowerCase().contains(MIXPANEL_API.toLowerCase());\n    }\n\n    private static byte[] slurp(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[8192];\n\n        while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport javax.net.ssl.*;\n\npublic class HttpService {\n    private boolean shouldGzipRequestPayload;\n    private static final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = 500;\n    private static final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private static final String LOGTAG = \"HttpService\";\n    private static final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private static final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private static final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws ServiceUnavailableException, IOException {\n        int retryCount = 0;\n        int maxRetries = 3; // Example retry count\n        while (retryCount <= maxRetries) {\n            try {\n                URL url = new URL(endpointUrl);\n                HttpURLConnection connection;\n\n                if (isProxyRequest(endpointUrl)) {\n                    Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(interactor.getHost(), interactor.getPort()));\n                    connection = (HttpURLConnection) url.openConnection(proxy);\n                } else {\n                    connection = (HttpURLConnection) url.openConnection();\n                }\n\n                if (socketFactory != null && connection instanceof HttpsURLConnection) {\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(socketFactory);\n                }\n\n                connection.setRequestMethod(\"POST\");\n                connection.setDoOutput(true);\n\n                if (params != null && !params.isEmpty()) {\n                    connection.setRequestProperty(\"Content-Type\", \"application/json\");\n                    try (OutputStream out = getBufferedOutputStream(connection.getOutputStream())) {\n                        byte[] postData = new JSONObject(params).toString().getBytes();\n                        out.write(postData);\n                        out.flush();\n                    }\n                }\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && responseCode <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Server returned error: \" + responseCode);\n                }\n\n                try (InputStream inputStream = connection.getInputStream()) {\n                    return slurp(inputStream);\n                }\n            } catch (IOException e) {\n                retryCount++;\n                if (retryCount > maxRetries) {\n                    throw e;\n                }\n            }\n        }\n        return new byte[0];\n    }\n\n    protected OutputStream getBufferedOutputStream(OutputStream out) {\n        BufferedOutputStream bufferedStream = new BufferedOutputStream(out, HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        if (shouldGzipRequestPayload) {\n            try {\n                return new GZIPOutputStream(bufferedStream);\n            } catch (IOException e) {\n                return bufferedStream;\n            }\n        }\n        return bufferedStream;\n    }\n\n    private boolean isProxyRequest(String endpointUrl) {\n        return endpointUrl.contains(\"proxy\");\n    }\n\n    protected byte[] slurp(InputStream inputStream) throws IOException {\n        ByteArrayOutputStream result = new ByteArrayOutputStream();\n        byte[] buffer = new byte[HTTP_OUTPUT_STREAM_BUFFER_SIZE];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            result.write(buffer, 0, bytesRead);\n        }\n        return result.toByteArray();\n    }\n}\n\nclass ServiceUnavailableException extends Exception {\n    public ServiceUnavailableException(String message) {\n        super(message);\n    }\n}\n\ninterface ProxyServerInteractor {\n    String getHost();\n    int getPort();\n}"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Implement a Java class for SSRF (Server-Side Request Forgery) security checks that validates URLs to prevent internal network access.\n\nClass Description: The SSRFChecker class provides functionality to check if a given URL is safe by verifying it doesn't resolve to internal IP addresses. It includes methods for URL validation, host extraction, IP resolution, and internal IP detection.\n\nAttributes:\n- logger: Logger - Used for logging error and info messages\n- decimalIp: String - Stores converted IP address in decimal format\n\nMethods:\n- checkSSRF(String url, int checkTimes) -> boolean - Main method to validate URL against SSRF risks. Follows redirects up to checkTimes. Returns true if safe, false if dangerous.\n- isInternalIpByUrl(String url) -> boolean - Checks if URL's host resolves to an internal IP. Returns true if internal/dangerous.\n- isInternalIp(String strIP) -> boolean - Verifies if given IP is in blocked subnets. Returns true if IP is internal.\n- host2ip(String host) -> String - Resolves hostname to IP address. Returns empty string on failure.\n- url2host(String url) -> String - Extracts host from URL. Returns empty string for non-HTTP URLs or invalid URLs.\n- isOctalIP(String host) -> boolean - (Private) Checks if host is in octal IP format. Returns true if octal format detected.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.net.util.SubnetUtils;\nimport org.joychou.config.WebConfig;\nimport org.joychou.security.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SSRFChecker {\n\n    private static final Logger logger = LoggerFactory.getLogger(SSRFChecker.class);\n    private static String decimalIp;\n\n    public static boolean checkSSRF(String url, int checkTimes) {\n        HttpURLConnection connection;\n        int connectTime = 5 * 1000;\n        int i = 1;\n        String finalUrl = url;\n        try {\n            do {\n                if (isInternalIpByUrl(finalUrl)) {\n                    logger.error(\"[-] SSRF check failed. Dangerous url: \" + finalUrl);\n                    return false;\n                }\n\n                connection = (HttpURLConnection) new URL(finalUrl).openConnection();\n                connection.setInstanceFollowRedirects(false);\n                connection.setUseCaches(false);\n                connection.setConnectTimeout(connectTime);\n                connection.connect();\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= 300 && responseCode <= 307 && responseCode != 304 && responseCode != 306) {\n                    String redirectedUrl = connection.getHeaderField(\"Location\");\n                    if (null == redirectedUrl)\n                        break;\n                    finalUrl = redirectedUrl;\n                    i += 1;\n                    logger.info(\"redirected url: \" + finalUrl);\n                    if (i == checkTimes) {\n                        return false;\n                    }\n                } else\n                    break;\n            } while (connection.getResponseCode() != HttpURLConnection.HTTP_OK);\n            connection.disconnect();\n        } catch (Exception e) {\n            return true;\n        }\n        return true;\n    }\n\n    public static boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.equals(\"\")) {\n            return true;\n        }\n\n        String ip = host2ip(host);\n        if (ip.equals(\"\")) {\n            return true;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public static boolean isInternalIp(String strIP) {\n        if (StringUtils.isEmpty(strIP)) {\n            logger.error(\"[-] SSRF check failed. IP is empty. \" + strIP);\n            return true;\n        }\n\n        ArrayList<String> blackSubnets = WebConfig.getSsrfBlockIps();\n        for (String subnet : blackSubnets) {\n            SubnetUtils utils = new SubnetUtils(subnet);\n            if (utils.getInfo().isInRange(strIP)) {\n                logger.error(\"[-] SSRF check failed. Internal IP: \" + strIP);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static String host2ip(String host) {\n        if (null == host) {\n            return \"\";\n        }\n\n        if(isOctalIP(host)) {\n            host = decimalIp;\n        }\n\n        try {\n            InetAddress IpAddress = InetAddress.getByName(host);\n            return IpAddress.getHostAddress();\n        } catch (Exception e) {\n            logger.error(\"host2ip exception \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private static String url2host(String url) {\n        try {\n            URI u = new URI(url);\n            if (SecurityUtil.isHttp(url)) {\n                return u.getHost();\n            }\n            return \"\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.*;\nimport java.util.*;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class SSRFChecker {\n    private static final Logger logger = Logger.getLogger(SSRFChecker.class.getName());\n    private String decimalIp;\n\n    public boolean checkSSRF(String url, int checkTimes) {\n        if (url == null || url.isEmpty()) {\n            logger.info(\"URL is empty\");\n            return true;\n        }\n\n        if (checkTimes <= 0) {\n            logger.warning(\"Too many redirects\");\n            return true;\n        }\n\n        String host = url2host(url);\n        if (host.isEmpty()) {\n            logger.warning(\"Invalid URL format: \" + url);\n            return true;\n        }\n\n        if (isOctalIP(host)) {\n            logger.warning(\"Octal IP detected: \" + host);\n            return false;\n        }\n\n        if (isInternalIpByUrl(host)) {\n            logger.warning(\"Internal IP detected: \" + host);\n            return false;\n        }\n\n        try {\n            URL parsedUrl = new URL(url);\n            URLConnection conn = parsedUrl.openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection httpConn = (HttpURLConnection) conn;\n                httpConn.setInstanceFollowRedirects(false);\n                httpConn.connect();\n                int responseCode = httpConn.getResponseCode();\n                if (responseCode >= 300 && responseCode < 400) {\n                    String location = httpConn.getHeaderField(\"Location\");\n                    if (location != null && !location.isEmpty()) {\n                        return checkSSRF(location, checkTimes - 1);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            logger.warning(\"Error checking URL: \" + url + \", \" + e.getMessage());\n            return true;\n        }\n\n        return true;\n    }\n\n    public boolean isInternalIpByUrl(String urlHost) {\n        if (urlHost == null || urlHost.isEmpty()) {\n            return false;\n        }\n\n        String ip = host2ip(urlHost);\n        if (ip.isEmpty()) {\n            return false;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public boolean isInternalIp(String strIP) {\n        if (strIP == null || strIP.isEmpty()) {\n            return false;\n        }\n\n        Pattern pattern = Pattern.compile(\"(\\\\d+)(?:\\\\.(\\\\d+)(?:\\\\.(\\\\d+)(?:\\\\.(\\\\d+))?)?)?\");\n        Matcher matcher = pattern.matcher(strIP);\n\n        if (!matcher.matches()) {\n            return false;\n        }\n\n        try {\n            int[] parts = new int[4];\n            for (int i = 0; i < 4; i++) {\n                String partStr = matcher.group(i + 1);\n                if (partStr == null) {\n                    parts[i] = 0;\n                } else {\n                    parts[i] = Integer.parseInt(partStr);\n                    if (parts[i] < 0 || parts[i] > 255) {\n                        return false;\n                    }\n                }\n            }\n\n            int ipNum = (parts[0] << 24) & 0xFF000000 |\n                        (parts[1] << 16) & 0x00FF0000 |\n                        (parts[2] << 8)  & 0x0000FF00 |\n                        (parts[3])       & 0x000000FF;\n\n            this.decimalIp = String.valueOf(ipNum);\n\n            int[][] internalRanges = {\n                {0xAC100000, 0xFFFF0000}, // 172.16.0.0/12\n                {0xC0A80000, 0xFFFFFF00}, // 192.168.0.0/16\n                {0x7F000000, 0xFF000000}, // 127.0.0.0/8\n                {0xA9FE0000, 0xFFFF0000}, // 169.254.0.0/16\n                {0x00000000, 0xFFFFFFFF}, // 0.0.0.0/32\n                {0x00000000, 0x00000000}  // Default route 0.0.0.0/0\n            };\n\n            for (int[] range : internalRanges) {\n                if ((ipNum & range[1]) == range[0]) {\n                    return true;\n                }\n            }\n\n        } catch (Exception e) {\n            logger.warning(\"Error parsing IP: \" + strIP + \", \" + e.getMessage());\n            return false;\n        }\n\n        return false;\n    }\n\n    public String host2ip(String host) {\n        if (host == null || host.isEmpty()) {\n            return \"\";\n        }\n\n        try {\n            InetAddress address = InetAddress.getByName(host);\n            return address.getHostAddress();\n        } catch (UnknownHostException e) {\n            logger.warning(\"Unable to resolve host: \" + host + \", \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    public String url2host(String url) {\n        if (url == null || url.isEmpty()) {\n            return \"\";\n        }\n\n        try {\n            URL parsedUrl = new URL(url);\n            String protocol = parsedUrl.getProtocol().toLowerCase();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\")) {\n                logger.warning(\"Unsupported protocol: \" + protocol);\n                return \"\";\n            }\n\n            String host = parsedUrl.getHost();\n            if (host == null || host.isEmpty()) {\n                logger.warning(\"No host found in URL: \" + url);\n                return \"\";\n            }\n\n            return host;\n        } catch (MalformedURLException e) {\n            logger.warning(\"Invalid URL: \" + url + \", \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private boolean isOctalIP(String host) {\n        if (host == null || host.isEmpty()) {\n            return false;\n        }\n\n        String[] parts = host.split(\"\\\\.\");\n        if (parts.length != 4) {\n            return false;\n        }\n\n        for (String part : parts) {\n            if (part.isEmpty() || part.length() > 1 && part.startsWith(\"0\")) {\n                try {\n                    int value = Integer.parseInt(part, 8);\n                    if (value > 255) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests with support for proxy configuration, including making GET requests, processing responses, and handling callbacks for success and failure scenarios.\n\nClass Description: The HttpRequestManager class manages HTTP requests with configurable proxy settings. It provides functionality to make GET requests to a specified URL, process the response (including Base64 decoding), and notify the caller of success or failure through a callback interface.\n\nAttributes:\n- mProxyOn: boolean - Indicates whether proxy is enabled\n- mProxyHost: String - The host address of the proxy server\n- mProxyPort: long - The port number of the proxy server\n\nMethods:\n- HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) -> void - Constructor that initializes proxy configuration\n- requestSubscribeServerConfigs(String urlStr, Callback callback) -> void - Makes a GET request to the specified URL and processes the response, notifying through callback\n- readStringFromStream(InputStream inputStream) -> String - Helper method to read and convert an InputStream to a String\n- interface Callback - Nested interface for handling request results\n  - onSuccess(String response) -> void - Called when request succeeds\n  - onFailed() -> void - Called when request fails",
    "Canonical_solution": "import android.net.Uri;\nimport android.text.TextUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        mProxyOn = proxyOn;\n        mProxyHost = proxyHost;\n        mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, @NonNull Callback callback) {\n        URL url;\n        try {\n            url = new URL(urlStr);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            callback.onFailed();\n            return;\n        }\n        HttpURLConnection connection = null;\n        try {\n            if (mProxyOn) {\n                InetSocketAddress proxyAddress = new InetSocketAddress(mProxyHost, (int) mProxyPort);\n                Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.setRequestMethod(\"GET\");\n            connection.setDoInput(true);\n            connection.connect();\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpsURLConnection.HTTP_OK) {\n                callback.onFailed();\n                return;\n            }\n            try (InputStream stream = connection.getInputStream()) {\n                if (stream != null) {\n                    @Nullable String response = DecodeUtils.decodeBase64(readStringFromStream(stream));\n                    if (TextUtils.isEmpty(response)) {\n                        callback.onFailed();\n                    } else {\n                        callback.onSuccess(response);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            callback.onFailed();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        try (Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n            char[] buf = new char[4096];\n            StringBuilder sb = new StringBuilder();\n            int readSize;\n            while ((readSize = reader.read(buf)) != -1) {\n                sb.append(buf, 0, readSize);\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        this.mProxyOn = proxyOn;\n        this.mProxyHost = proxyHost;\n        this.mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, Callback callback) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection connection;\n            if (mProxyOn) {\n                Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(mProxyHost, (int) mProxyPort));\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                InputStream inputStream = connection.getInputStream();\n                String response = readStringFromStream(inputStream);\n                String decodedResponse = new String(Base64.getDecoder().decode(response));\n                callback.onSuccess(decodedResponse);\n            } else {\n                callback.onFailed();\n            }\n        } catch (Exception e) {\n            callback.onFailed();\n        }\n    }\n\n    public String readStringFromStream(InputStream inputStream) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder response = new StringBuilder();\n        String line;\n\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n\n        reader.close();\n        return response.toString();\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Implement a lightweight HTTP client class in Java that can perform GET and POST requests with configurable headers, parameters, and timeouts.\n\nClass Description: HttpTinyClient is a utility class that provides basic HTTP GET and POST functionality using Java's HttpURLConnection. It handles URL parameter encoding, header management, and response processing.\n\nAttributes:\nNone (This is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP GET request to the specified URL with given headers and parameters. Encodes parameters in the URL query string.\n\nMethod2: httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP POST request to the specified URL with given headers and parameters. Encodes parameters in the request body.\n\nMethod3: encodingParams(List<String> paramValues, String encoding) -> String - Helper method that encodes parameter values for URL or POST body using the specified character encoding.\n\nMethod4: setHeaders(HttpURLConnection conn, List<String> headers, String encoding) -> void - Helper method that sets request headers including default headers for content type and client version.\n\nNested Class: HttpResult - Represents the result of an HTTP request with status code and response content.\n\nAttributes:\ncode: int - HTTP response status code\ncontent: String - Response body content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.rocketmq.common.MQVersion;\nimport org.apache.rocketmq.common.MixAll;\n\npublic class HttpTinyClient {\n\n    static public HttpResult httpGet(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n        url += (null == encodedContent) ? \"\" : (\"?\" + encodedContent);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout((int) readTimeoutMs);\n            conn.setReadTimeout((int) readTimeoutMs);\n            setHeaders(conn, headers, encoding);\n\n            conn.connect();\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static private String encodingParams(List<String> paramValues, String encoding)\n        throws UnsupportedEncodingException {\n        StringBuilder sb = new StringBuilder();\n        if (null == paramValues) {\n            return null;\n        }\n\n        for (Iterator<String> iter = paramValues.iterator(); iter.hasNext(); ) {\n            sb.append(iter.next()).append(\"=\");\n            sb.append(URLEncoder.encode(iter.next(), encoding));\n            if (iter.hasNext()) {\n                sb.append(\"&\");\n            }\n        }\n        return sb.toString();\n    }\n\n    static private void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        if (null != headers) {\n            for (Iterator<String> iter = headers.iterator(); iter.hasNext(); ) {\n                conn.addRequestProperty(iter.next(), iter.next());\n            }\n        }\n        conn.addRequestProperty(\"Client-Version\", MQVersion.getVersionDesc(MQVersion.CURRENT_VERSION));\n        conn.addRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded;charset=\" + encoding);\n\n        String ts = String.valueOf(System.currentTimeMillis());\n        conn.addRequestProperty(\"Metaq-Client-RequestTS\", ts);\n    }\n\n    static public HttpResult httpPost(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            setHeaders(conn, headers, encoding);\n\n            conn.getOutputStream().write(encodedContent.getBytes(MixAll.DEFAULT_CHARSET));\n\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (null != conn) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static public class HttpResult {\n        final public int code;\n        final public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.nio.charset.*;\n\npublic class HttpTinyClient {\n\n    public static class HttpResult {\n        public final int code;\n        public final String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n\n    public static HttpResult httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws IOException {\n        String encodedParams = encodingParams(paramValues, encoding);\n        if (!encodedParams.isEmpty()) {\n            url += \"?\" + encodedParams;\n        }\n\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"GET\");\n        setHeaders(conn, headers, encoding);\n        conn.setReadTimeout((int) readTimeoutMs);\n\n        return processResponse(conn);\n    }\n\n    public static HttpResult httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        setHeaders(conn, headers, encoding);\n        conn.setReadTimeout((int) readTimeoutMs);\n\n        String encodedParams = encodingParams(paramValues, encoding);\n        try (OutputStream os = conn.getOutputStream()) {\n            os.write(encodedParams.getBytes(StandardCharsets.UTF_8));\n        }\n\n        return processResponse(conn);\n    }\n\n    public static String encodingParams(List<String> paramValues, String encoding) {\n        if (paramValues == null || paramValues.isEmpty() || paramValues.size() % 2 != 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < paramValues.size(); i += 2) {\n            if (i > 0) sb.append(\"&\");\n\n            String key = paramValues.get(i);\n            String value = (i + 1 < paramValues.size()) ? paramValues.get(i + 1) : \"\";\n\n            sb.append(encodeValue(key, encoding)).append(\"=\").append(encodeValue(value, encoding));\n        }\n        return sb.toString();\n    }\n\n    private static void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded;charset=\" + encoding);\n        conn.setRequestProperty(\"User-Agent\", \"HttpTinyClient/1.0\");\n\n        if (headers != null && headers.size() % 2 == 0) {\n            for (int i = 0; i < headers.size(); i += 2) {\n                String name = headers.get(i);\n                String value = headers.get(i + 1);\n                conn.setRequestProperty(name, value);\n            }\n        }\n    }\n\n    private static HttpResult processResponse(HttpURLConnection conn) throws IOException {\n        int responseCode = conn.getResponseCode();\n\n        InputStream inputStream;\n        if (responseCode >= 200 && responseCode < 300) {\n            inputStream = conn.getInputStream();\n        } else {\n            inputStream = conn.getErrorStream();\n        }\n\n        String content;\n        if (inputStream != null) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n                StringBuilder sb = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line).append(\"\\n\");\n                }\n                content = sb.toString();\n            }\n        } else {\n            content = \"\";\n        }\n\n        return new HttpResult(responseCode, content);\n    }\n\n    private static String encodeValue(String value, String encoding) {\n        try {\n            return URLEncoder.encode(value, encoding);\n        } catch (UnsupportedEncodingException e) {\n            return URLEncoder.encode(value, StandardCharsets.UTF_8);\n        }\n    }\n}"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests (GET and POST) to a REST API, with support for custom headers, query parameters, and JSON serialization/deserialization.\n\nClass Description: The ApiHandler class provides a convenient way to make HTTP requests to a REST API endpoint. It supports both GET and POST methods, handles query parameters, includes custom headers (like API keys), and automatically serializes/deserializes JSON data using Gson. The class maintains a base URL and optional additional headers that are included in every request.\n\nAttributes:\n- baseUrl: String - The base URL for all API requests\n- additionalHeaders: Map<String, String> - Optional headers to include in all requests\n\nMethods:\n- Constructor: ApiHandler(String url) - Initializes the handler with a base URL\n- Constructor: ApiHandler(String url, String apiKey) - Initializes with base URL and sets an API key header\n- get: <T> get(String endpoint, Class<T> tClass) -> T - Makes a GET request to the endpoint and returns deserialized response\n- get: <T> get(String endpoint, HashMap<String, Object> query, Class<T> tClass) -> T - Makes a GET request with query parameters\n- post: <T> post(String endpoint, T body, Class<T> tClass) -> T - Makes a POST request with a request body\n- post: <T> post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) -> T - Makes a POST request with query parameters and body\n- getRaw: static String getRaw(Map<String, String> headers, String url) -> String - Makes a raw GET request and returns response as string\n- postRaw: static String postRaw(Map<String, String> headers, String url, String body) -> String - Makes a raw POST request and returns response as string\n- addHeaders: static void addHeaders(HttpURLConnection connection, Map<String, String> headers) - Helper to add headers to a connection\n- parseQueries: static String parseQueries(HashMap<String, Object> query) -> String - Converts query parameters to URL encoded string\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) -> T - Makes GET request to full URL and deserializes response\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) -> T - GET with query params to full URL\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) -> T - POST to full URL with body\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) -> T - POST with query params to full URL\n- urlEncodeUTF8: static String urlEncodeUTF8(String input) -> String - URL encodes a string using UTF-8",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\nimport com.google.gson.Gson;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ApiHandler {\n    public final String baseUrl;\n    public final Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        baseUrl = url;\n        additionalHeaders = null;\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        baseUrl = url;\n        additionalHeaders = new ArrayMap<>();\n        additionalHeaders.put(\"x-api-key\", apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) {\n        Log.d(\"ApiHandler\", url);\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            addHeaders(conn, headers);\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            Log.d(ApiHandler.class.toString(), data);\n            inputStream.close();\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) {\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n            addHeaders(conn, headers);\n            conn.setDoOutput(true);\n\n            OutputStream outputStream = conn.getOutputStream();\n            byte[] input = body.getBytes(StandardCharsets.UTF_8);\n            outputStream.write(input, 0, input.length);\n            outputStream.close();\n\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            inputStream.close();\n\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        if(headers != null) {\n            for(String key : headers.keySet())\n                connection.addRequestProperty(key, headers.get(key));\n        }\n    }\n\n    private static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder params = new StringBuilder(\"?\");\n        for (String param : query.keySet()) {\n            String value = Objects.toString(query.get(param));\n            params.append(urlEncodeUTF8(param))\n                    .append(\"=\")\n                    .append(urlEncodeUTF8(value))\n                    .append(\"&\");\n        }\n        return params.substring(0, params.length() - 1);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) {\n        return new Gson().fromJson(getRaw(headers, url), tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(headers, url + parseQueries(query), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url, body.toString()), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url + parseQueries(query), body.toString()), tClass);\n    }\n\n    private static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, \"UTF-8\");\n        }catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"UTF-8 is required\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import com.google.gson.Gson;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\n\npublic class ApiHandler {\n    private String baseUrl;\n    private Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        this.baseUrl = url;\n        this.additionalHeaders = new HashMap<>();\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        this.baseUrl = url;\n        this.additionalHeaders = new HashMap<>();\n        this.additionalHeaders.put(\"API-Key\", apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) throws IOException {\n        return get(endpoint, new HashMap<>(), tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) throws IOException {\n        String queryString = parseQueries(query);\n        String fullUrl = baseUrl + endpoint + (queryString.isEmpty() ? \"\" : \"?\" + queryString);\n        return getFullUrl(additionalHeaders, fullUrl, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) throws IOException {\n        return post(endpoint, new HashMap<>(), body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) throws IOException {\n        String queryString = parseQueries(query);\n        String fullUrl = baseUrl + endpoint + (queryString.isEmpty() ? \"\" : \"?\" + queryString);\n        return postFullUrl(additionalHeaders, fullUrl, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setRequestMethod(\"GET\");\n        addHeaders(connection, headers);\n\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n        }\n        return response.toString();\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        addHeaders(connection, headers);\n\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = body.getBytes(StandardCharsets.UTF_8);\n            os.write(input, 0, input.length);\n        }\n\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n        }\n        return response.toString();\n    }\n\n    public static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            connection.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n    }\n\n    public static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, Object> entry : query.entrySet()) {\n            if (sb.length() > 0) sb.append(\"&\");\n            sb.append(urlEncodeUTF8(entry.getKey())).append(\"=\").append(urlEncodeUTF8(entry.getValue().toString()));\n        }\n        return sb.toString();\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) throws IOException {\n        String jsonResponse = getRaw(headers, url);\n        return new Gson().fromJson(jsonResponse, tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) throws IOException {\n        String queryString = parseQueries(query);\n        String fullUrl = url + (queryString.isEmpty() ? \"\" : \"?\" + queryString);\n        return getFullUrl(headers, fullUrl, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) throws IOException {\n        String jsonBody = new Gson().toJson(body);\n        String jsonResponse = postRaw(headers, url, jsonBody);\n        return new Gson().fromJson(jsonResponse, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) throws IOException {\n        String queryString = parseQueries(query);\n        String fullUrl = url + (queryString.isEmpty() ? \"\" : \"?\" + queryString);\n        return postFullUrl(headers, fullUrl, body, tClass);\n    }\n\n    public static String urlEncodeUTF8(String input) {\n        return URLEncoder.encode(input, StandardCharsets.UTF_8);\n    }\n}"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Implement a Java class that provides remote service capabilities for retrieving knowledge packages from a repository server using HTTP communication.\n\nClass Description: RemoteServiceImpl is a service class that handles HTTP communication with a remote repository server to fetch knowledge packages. It manages the connection, request/response handling, and data processing.\n\nAttributes:\n- resporityServerUrl: String - The base URL of the remote repository server\n- log: Logger - Logger instance for logging information and errors\n\nMethods:\n- getKnowledge(String packageId, String timestamp) -> KnowledgePackage - Retrieves a knowledge package from the remote server using the specified package ID and timestamp\n- sendRequest(String packageId, String timestamp) -> String - Internal method that handles the HTTP request/response cycle with the remote server\n- setResporityServerUrl(String resporityServerUrl) -> void - Sets the repository server URL, appending the default endpoint if not present",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport com.bstek.urule.RuleException;\nimport com.bstek.urule.Utils;\nimport com.bstek.urule.model.flow.FlowDefinition;\nimport com.bstek.urule.model.rete.JsonUtils;\nimport com.bstek.urule.runtime.KnowledgePackage;\nimport com.bstek.urule.runtime.KnowledgePackageWrapper;\n\npublic class RemoteServiceImpl implements RemoteService {\n    private String resporityServerUrl;\n    private Logger log = Logger.getLogger(RemoteServiceImpl.class.getName());\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        if(StringUtils.isEmpty(resporityServerUrl)){\n            return null;\n        }\n        log.info(\"Load knowledgepackage from remote...\");\n        String content = sendRequest(packageId, timestamp);\n        if(StringUtils.isEmpty(content)){\n            return null;\n        }\n        KnowledgePackageWrapper wrapper = JsonUtils.parseKnowledgePackageWrapper(content);\n        KnowledgePackage knowledgePackage = wrapper.getKnowledgePackage();\n        Map<String, FlowDefinition> flowMap = knowledgePackage.getFlowMap();\n        if(flowMap != null && flowMap.size() > 0){\n            for(FlowDefinition fd : flowMap.values()){\n                fd.buildConnectionToNode();\n            }\n        }\n        return knowledgePackage;\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        HttpURLConnection connection = null;\n        OutputStreamWriter writer = null;\n        InputStream inputStream = null;\n        InputStreamReader inputStreamReader = null;\n        BufferedReader bufferedReader = null;\n        try {\n            packageId = Utils.encodeURL(packageId);\n            packageId = Utils.encodeURL(packageId);\n            String content = \"packageId=\" + packageId + \"\";\n            if(StringUtils.isNotEmpty(timestamp)){\n                content += \"&timestamp=\" + timestamp + \"\";\n            }\n            URL url = new URL(resporityServerUrl);\n            connection = (HttpURLConnection)url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", String.valueOf(content.length()));\n            connection.setUseCaches(false);\n            connection.setDoOutput(true);\n            connection.connect();\n            writer = new OutputStreamWriter(connection.getOutputStream());\n            writer.write(content);\n            writer.flush();\n            if (connection.getResponseCode() != 200) {\n                throw new RuleException(\"Server request was failed, Response message : \" + connection.getResponseMessage());\n            }\n            inputStream = connection.getInputStream();\n            inputStreamReader = new InputStreamReader(inputStream,\"utf-8\");\n            bufferedReader = new BufferedReader(inputStreamReader);\n            String line = null;\n            StringBuilder sb = new StringBuilder();\n            while ((line = bufferedReader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            throw new RuleException(e);\n        } finally {\n            try {\n                if(writer != null){\n                    writer.close();\n                }\n                if(bufferedReader != null){\n                    bufferedReader.close();\n                }\n                if(inputStreamReader != null){\n                    inputStreamReader.close();\n                }\n                if(inputStream != null){\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if(connection != null){\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if(StringUtils.isEmpty(resporityServerUrl) || resporityServerUrl.equals(\"urule.resporityServerUrl\")){\n            return;\n        }\n        if(resporityServerUrl.endsWith(\"/\")){\n            resporityServerUrl += \"urule/loadknowledge\";\n        }else{\n            resporityServerUrl += \"/urule/loadknowledge\";\n        }\n        this.resporityServerUrl = resporityServerUrl;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.logging.Logger;\n\npublic class RemoteServiceImpl {\n\n    private String resporityServerUrl;\n    private static final String DEFAULT_ENDPOINT = \"/knowledge\";\n    private Logger log;\n\n    public RemoteServiceImpl(Logger log) {\n        this.log = log;\n    }\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        try {\n            String response = sendRequest(packageId, timestamp);\n            // Assuming a simple parse method exists for converting JSON string to KnowledgePackage\n            return KnowledgePackage.parse(response);\n        } catch (IOException e) {\n            log.severe(\"Error retrieving knowledge package: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    private String sendRequest(String packageId, String timestamp) throws IOException {\n        String requestUrl = resporityServerUrl + \"?packageId=\" + packageId + \"&timestamp=\" + timestamp;\n        URL url = new URL(requestUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != 200) {\n            throw new IOException(\"Server returned HTTP code: \" + responseCode);\n        }\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n\n        reader.close();\n        return response.toString();\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if (!resporityServerUrl.endsWith(DEFAULT_ENDPOINT)) {\n            this.resporityServerUrl = resporityServerUrl + DEFAULT_ENDPOINT;\n        } else {\n            this.resporityServerUrl = resporityServerUrl;\n        }\n    }\n}\n\n// Dummy KnowledgePackage class for illustrative purposes\nclass KnowledgePackage {\n    public static KnowledgePackage parse(String json) {\n        // Implement actual parsing logic here\n        return new KnowledgePackage();\n    }\n}"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a class that handles fetching MIME types from URLs and managing download requests using Android's DownloadManager.\n\nClass Description: The FetchUrlMimeType class is responsible for determining the MIME type of a resource at a given URL, setting up a download request with appropriate parameters, and enqueuing the download using Android's DownloadManager. It handles HTTP connections, processes response headers, and manages file naming and destination.\n\nAttributes:\n- mRequest: [DownloadManager.Request] - The download request to be configured and enqueued\n- mDownloadManager: [DownloadManager] - The Android DownloadManager instance used to enqueue downloads\n- mUri: [String] - The URL of the resource to be downloaded\n- mCookies: [String] - Optional cookies to be included in the HTTP request\n- mUserAgent: [String] - The user agent string to be used in the HTTP request\n\nMethods:\n- Constructor: [FetchUrlMimeType](DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) -> [void] - Initializes the class with download manager, request, URI, cookies, and user agent\n- create: [create]() -> [Single<Result>] - Creates and executes the download process, returning a Single observable with the result status. This method:\n  1. Establishes an HTTP connection to the URL\n  2. Extracts MIME type and content disposition from headers\n  3. Configures the download request with proper MIME type and filename\n  4. Enqueues the download request\n  5. Returns success/failure status through the observable\n\nNested Enum:\n- Result: [enum] - Represents possible outcomes of the download enqueue operation:\n  - FAILURE_ENQUEUE: Failed to enqueue the download request\n  - FAILURE_LOCATION: Failed due to storage location issues\n  - SUCCESS: Download successfully enqueued",
    "Canonical_solution": "import android.app.DownloadManager;\nimport android.os.Environment;\nimport android.util.Log;\nimport android.webkit.MimeTypeMap;\nimport android.webkit.URLUtil;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport acr.browser.lightning.utils.Utils;\nimport androidx.annotation.NonNull;\nimport io.reactivex.rxjava3.core.Single;\n\nclass FetchUrlMimeType {\n\n    private static final String TAG = \"FetchUrlMimeType\";\n\n    private final DownloadManager.Request mRequest;\n    private final DownloadManager mDownloadManager;\n    private final String mUri;\n    private final String mCookies;\n    private final String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager,\n                            DownloadManager.Request request,\n                            String uri,\n                            String cookies,\n                            String userAgent) {\n        mRequest = request;\n        mDownloadManager = downloadManager;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            String mimeType = null;\n            String contentDisposition = null;\n            HttpURLConnection connection = null;\n            try {\n                URL url = new URL(mUri);\n                connection = (HttpURLConnection) url.openConnection();\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.addRequestProperty(\"Cookie\", mCookies);\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n                connection.connect();\n                if (connection.getResponseCode() == 200) {\n                    String header = connection.getHeaderField(\"Content-Type\");\n                    if (header != null) {\n                        mimeType = header;\n                        final int semicolonIndex = mimeType.indexOf(';');\n                        if (semicolonIndex != -1) {\n                            mimeType = mimeType.substring(0, semicolonIndex);\n                        }\n                    }\n                    String contentDispositionHeader = connection.getHeaderField(\"Content-Disposition\");\n                    if (contentDispositionHeader != null) {\n                        contentDisposition = contentDispositionHeader;\n                    }\n                }\n            } catch (@NonNull IllegalArgumentException | IOException ex) {\n                if (connection != null)\n                    connection.disconnect();\n            } finally {\n                if (connection != null)\n                    connection.disconnect();\n            }\n\n            if (mimeType != null) {\n                if (mimeType.equalsIgnoreCase(\"text/plain\")\n                    || mimeType.equalsIgnoreCase(\"application/octet-stream\")) {\n                    String newMimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                        Utils.guessFileExtension(mUri));\n                    if (newMimeType != null) {\n                        mRequest.setMimeType(newMimeType);\n                    }\n                }\n                final String filename = URLUtil.guessFileName(mUri, contentDisposition, mimeType);\n                mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename);\n            }\n\n            try {\n                mDownloadManager.enqueue(mRequest);\n                emitter.onSuccess(Result.SUCCESS);\n            } catch (IllegalArgumentException e) {\n                Log.e(TAG, \"Unable to enqueue request\", e);\n                emitter.onSuccess(Result.FAILURE_ENQUEUE);\n            } catch (SecurityException e) {\n                emitter.onSuccess(Result.FAILURE_LOCATION);\n            }\n        });\n    }\n\n    enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.app.DownloadManager;\nimport android.net.Uri;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport io.reactivex.Single;\n\npublic class FetchUrlMimeType {\n    private DownloadManager.Request mRequest;\n    private DownloadManager mDownloadManager;\n    private String mUri;\n    private String mCookies;\n    private String mUserAgent;\n\n    public enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n\n    public FetchUrlMimeType(DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) {\n        mDownloadManager = downloadManager;\n        mRequest = request;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            HttpURLConnection connection = null;\n            try {\n                URL url = new URL(mUri);\n                connection = (HttpURLConnection) url.openConnection();\n                if (mCookies != null) {\n                    connection.setRequestProperty(\"Cookie\", mCookies);\n                }\n                if (mUserAgent != null) {\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n                connection.connect();\n\n                String mimeType = connection.getContentType();\n                String contentDisposition = connection.getHeaderField(\"Content-Disposition\");\n\n                mRequest.setMimeType(mimeType);\n\n                String fileName = \"downloaded_file\";\n                if (contentDisposition != null) {\n                    Pattern pattern = Pattern.compile(\"filename=\\\"?(.+?)\\\"?\");\n                    Matcher matcher = pattern.matcher(contentDisposition);\n                    if (matcher.find()) {\n                        fileName = matcher.group(1);\n                    }\n                }\n\n                mRequest.addRequestHeader(\"User-Agent\", mUserAgent);\n                mRequest.addRequestHeader(\"Cookie\", mCookies);\n\n                long downloadId = mDownloadManager.enqueue(mRequest);\n                emitter.onSuccess(downloadId != -1 ? Result.SUCCESS : Result.FAILURE_ENQUEUE);\n            } catch (IOException e) {\n                emitter.onError(e);\n            } finally {\n                if (connection != null) {\n                    connection.disconnect();\n                }\n            }\n        });\n    }\n}"
  }
]